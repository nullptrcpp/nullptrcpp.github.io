<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Address.h", "content": "//===-- Address.h -----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_CORE_ADDRESS_H\n#define LLDB_CORE_ADDRESS_H\n\n#include \"lldb/lldb-defines.h\"\n#include \"lldb/lldb-forward.h\"\n#include \"lldb/lldb-private-enumerations.h\"\n#include \"lldb/lldb-types.h\"\n\n#include <stddef.h>\n#include <stdint.h>\n\nnamespace lldb_private {\nclass Block;\nclass CompileUnit;\nclass ExecutionContextScope;\nclass Function;\nclass SectionList;\nclass Stream;\nclass Symbol;\nclass SymbolContext;\nclass Target;\nstruct LineEntry;\n\n/// \\class Address Address.h \"lldb/Core/Address.h\"\n/// A section + offset based address class.\n///\n/// The Address class allows addresses to be relative to a section that can\n/// move during runtime due to images (executables, shared libraries, bundles,\n/// frameworks) being loaded at different addresses than the addresses found\n/// in the object file that represents them on disk. There are currently two\n/// types of addresses for a section:\n///     \\li file addresses\n///     \\li load addresses\n///\n/// File addresses represent the virtual addresses that are in the \"on disk\"\n/// object files. These virtual addresses are converted to be relative to\n/// unique sections scoped to the object file so that when/if the addresses\n/// slide when the images are loaded/unloaded in memory, we can easily track\n/// these changes without having to update every object (compile unit ranges,\n/// line tables, function address ranges, lexical block and inlined subroutine\n/// address ranges, global and static variables) each time an image is loaded\n/// or unloaded.\n///\n/// Load addresses represent the virtual addresses where each section ends up\n/// getting loaded at runtime. Before executing a program, it is common for\n/// all of the load addresses to be unresolved. When a DynamicLoader plug-in\n/// receives notification that shared libraries have been loaded/unloaded, the\n/// load addresses of the main executable and any images (shared libraries)\n/// will be  resolved/unresolved. When this happens, breakpoints that are in\n/// one of these sections can be set/cleared.\nclass Address {\npublic:\n  /// Dump styles allow the Address::Dump(Stream *,DumpStyle) const function\n  /// to display Address contents in a variety of ways.\n  enum DumpStyle {\n    /// Invalid dump style.\n    DumpStyleInvalid,\n    /// Display as the section name + offset.\n    /// \\code\n    /// // address for printf in libSystem.B.dylib as a section name + offset\n    /// libSystem.B.dylib.__TEXT.__text + 0x0005cfdf\n    /// \\endcode\n    DumpStyleSectionNameOffset,\n    /// Display as the section pointer + offset (debug output).\n    /// \\code\n    /// // address for printf in libSystem.B.dylib as a section pointer +\n    /// offset (lldb::Section *)0x35cc50 + 0x000000000005cfdf\n    /// \\endcode\n    DumpStyleSectionPointerOffset,\n    /// Display as the file address (if any).\n    /// \\code\n    /// // address for printf in libSystem.B.dylib as a file address\n    /// 0x000000000005dcff\n    /// \\endcode\n    ///\n    DumpStyleFileAddress,\n    /// Display as the file address with the module name prepended (if any).\n    /// \\code\n    /// // address for printf in libSystem.B.dylib as a file address\n    /// libSystem.B.dylib[0x000000000005dcff]\n    /// \\endcode\n    DumpStyleModuleWithFileAddress,\n    /// Display as the load address (if resolved).\n    /// \\code\n    /// // address for printf in libSystem.B.dylib as a load address\n    /// 0x00007fff8306bcff\n    /// \\endcode\n    DumpStyleLoadAddress,\n    /// Display the details about what an address resolves to. This can be\n    /// anything from a symbol context summary (module, function/symbol, and\n    /// file and line), to information about what the pointer points to if the\n    /// address is in a section (section of pointers, c strings, etc).\n    DumpStyleResolvedDescription,\n    DumpStyleResolvedDescriptionNoModule,\n    DumpStyleResolvedDescriptionNoFunctionArguments,\n    /// Elide the function name; display an offset into the current function.\n    /// Used primarily in disassembly symbolication\n    DumpStyleNoFunctionName,\n    /// Detailed symbol context information for an address for all symbol\n    /// context members.\n    DumpStyleDetailedSymbolContext,\n    /// Dereference a pointer at the current address and then lookup the\n    /// dereferenced address using DumpStyleResolvedDescription\n    DumpStyleResolvedPointerDescription\n  };\n\n  /// Default constructor.\n  ///\n  /// Initialize with a invalid section (NULL) and an invalid offset\n  /// (LLDB_INVALID_ADDRESS).\n  Address() : m_section_wp(), m_offset(LLDB_INVALID_ADDRESS) {}\n\n  /// Copy constructor\n  ///\n  /// Makes a copy of the another Address object \\a rhs.\n  ///\n  /// \\param[in] rhs\n  ///     A const Address object reference to copy.\n  Address(const Address &rhs)\n      : m_section_wp(rhs.m_section_wp), m_offset(rhs.m_offset) {}\n\n  /// Construct with a section pointer and offset.\n  ///\n  /// Initialize the address with the supplied \\a section and \\a offset.\n  ///\n  /// \\param[in] section_sp\n  ///     A section pointer to a valid lldb::Section, or NULL if the\n  ///     address doesn't have a section or will get resolved later.\n  ///\n  /// \\param[in] offset\n  ///     The offset in bytes into \\a section.\n  Address(const lldb::SectionSP &section_sp, lldb::addr_t offset)\n      : m_section_wp(), // Don't init with section_sp in case section_sp is\n                        // invalid (the weak_ptr will throw)\n        m_offset(offset) {\n    if (section_sp)\n      m_section_wp = section_sp;\n  }\n\n  /// Construct with a virtual address and section list.\n  ///\n  /// Initialize and resolve the address with the supplied virtual address \\a\n  /// file_addr.\n  ///\n  /// \\param[in] file_addr\n  ///     A virtual file address.\n  ///\n  /// \\param[in] section_list\n  ///     A list of sections, one of which may contain the \\a file_addr.\n  Address(lldb::addr_t file_addr, const SectionList *section_list);\n\n  Address(lldb::addr_t abs_addr);\n\n/// Assignment operator.\n///\n/// Copies the address value from another Address object \\a rhs into \\a this\n/// object.\n///\n/// \\param[in] rhs\n///     A const Address object reference to copy.\n///\n/// \\return\n///     A const Address object reference to \\a this.\n  const Address &operator=(const Address &rhs);\n\n  /// Clear the object's state.\n  ///\n  /// Sets the section to an invalid value (NULL) and an invalid offset\n  /// (LLDB_INVALID_ADDRESS).\n  void Clear() {\n    m_section_wp.reset();\n    m_offset = LLDB_INVALID_ADDRESS;\n  }\n\n  /// Compare two Address objects.\n  ///\n  /// \\param[in] lhs\n  ///     The Left Hand Side const Address object reference.\n  ///\n  /// \\param[in] rhs\n  ///     The Right Hand Side const Address object reference.\n  ///\n  /// \\return\n  ///     -1 if lhs < rhs\n  ///     0 if lhs == rhs\n  ///     1 if lhs > rhs\n  static int CompareFileAddress(const Address &lhs, const Address &rhs);\n\n  static int CompareLoadAddress(const Address &lhs, const Address &rhs,\n                                Target *target);\n\n  static int CompareModulePointerAndOffset(const Address &lhs,\n                                           const Address &rhs);\n\n  // For use with std::map, std::multi_map\n  class ModulePointerAndOffsetLessThanFunctionObject {\n  public:\n    ModulePointerAndOffsetLessThanFunctionObject() = default;\n\n    bool operator()(const Address &a, const Address &b) const {\n      return Address::CompareModulePointerAndOffset(a, b) < 0;\n    }\n  };\n\n  /// Dump a description of this object to a Stream.\n  ///\n  /// Dump a description of the contents of this object to the supplied stream\n  /// \\a s. There are many ways to display a section offset based address, and\n  /// \\a style lets the user choose.\n  ///\n  /// \\param[in] s\n  ///     The stream to which to dump the object description.\n  ///\n  /// \\param[in] style\n  ///     The display style for the address.\n  ///\n  /// \\param[in] fallback_style\n  ///     The display style for the address.\n  ///\n  /// \\return\n  ///     Returns \\b true if the address was able to be displayed.\n  ///     File and load addresses may be unresolved and it may not be\n  ///     possible to display a valid value, \\b false will be returned\n  ///     in such cases.\n  ///\n  /// \\see Address::DumpStyle\n  bool Dump(Stream *s, ExecutionContextScope *exe_scope, DumpStyle style,\n            DumpStyle fallback_style = DumpStyleInvalid,\n            uint32_t addr_byte_size = UINT32_MAX) const;\n\n  AddressClass GetAddressClass() const;\n\n  /// Get the file address.\n  ///\n  /// If an address comes from a file on disk that has section relative\n  /// addresses, then it has a virtual address that is relative to unique\n  /// section in the object file.\n  ///\n  /// \\return\n  ///     The valid file virtual address, or LLDB_INVALID_ADDRESS if\n  ///     the address doesn't have a file virtual address (image is\n  ///     from memory only with no representation on disk).\n  lldb::addr_t GetFileAddress() const;\n\n  /// Get the load address.\n  ///\n  /// If an address comes from a file on disk that has section relative\n  /// addresses, then it has a virtual address that is relative to unique\n  /// section in the object file. Sections get resolved at runtime by\n  /// DynamicLoader plug-ins as images (executables and shared libraries) get\n  /// loaded/unloaded. If a section is loaded, then the load address can be\n  /// resolved.\n  ///\n  /// \\return\n  ///     The valid load virtual address, or LLDB_INVALID_ADDRESS if\n  ///     the address is currently not loaded.\n  lldb::addr_t GetLoadAddress(Target *target) const;\n\n  /// Get the load address as a callable code load address.\n  ///\n  /// This function will first resolve its address to a load address. Then, if\n  /// the address turns out to be in code address, return the load address\n  /// that would be required to call or return to. The address might have\n  /// extra bits set (bit zero will be set to Thumb functions for an ARM\n  /// target) that are required when changing the program counter to setting a\n  /// return address.\n  ///\n  /// \\return\n  ///     The valid load virtual address, or LLDB_INVALID_ADDRESS if\n  ///     the address is currently not loaded.\n  lldb::addr_t GetCallableLoadAddress(Target *target,\n                                      bool is_indirect = false) const;\n\n  /// Get the load address as an opcode load address.\n  ///\n  /// This function will first resolve its address to a load address. Then, if\n  /// the address turns out to be in code address, return the load address for\n  /// an opcode. This address object might have extra bits set (bit zero will\n  /// be set to Thumb functions for an\n  /// ARM target) that are required for changing the program counter\n  /// and this function will remove any bits that are intended for these\n  /// special purposes. The result of this function can be used to safely\n  /// write a software breakpoint trap to memory.\n  ///\n  /// \\return\n  ///     The valid load virtual address with extra callable bits\n  ///     removed, or LLDB_INVALID_ADDRESS if the address is currently\n  ///     not loaded.\n  lldb::addr_t GetOpcodeLoadAddress(\n      Target *target,\n      AddressClass addr_class = AddressClass::eInvalid) const;\n\n  /// Get the section relative offset value.\n  ///\n  /// \\return\n  ///     The current offset, or LLDB_INVALID_ADDRESS if this address\n  ///     doesn't contain a valid offset.\n  lldb::addr_t GetOffset() const { return m_offset; }\n\n  /// Check if an address is section offset.\n  ///\n  /// When converting a virtual file or load address into a section offset\n  /// based address, we often need to know if, given a section list, if the\n  /// address was able to be converted to section offset. This function\n  /// returns true if the current value contained in this object is section\n  /// offset based.\n  ///\n  /// \\return\n  ///     Returns \\b true if the address has a valid section and\n  ///     offset, \\b false otherwise.\n  bool IsSectionOffset() const {\n    return IsValid() && (GetSection().get() != nullptr);\n  }\n\n  /// Check if the object state is valid.\n  ///\n  /// A valid Address object contains either a section pointer and\n  /// offset (for section offset based addresses), or just a valid offset\n  /// (for absolute addresses that have no section).\n  ///\n  /// \\return\n  ///     Returns \\b true if the offset is valid, \\b false\n  ///     otherwise.\n  bool IsValid() const { return m_offset != LLDB_INVALID_ADDRESS; }\n\n  /// Get the memory cost of this object.\n  ///\n  /// \\return\n  ///     The number of bytes that this object occupies in memory.\n  size_t MemorySize() const;\n\n  /// Resolve a file virtual address using a section list.\n  ///\n  /// Given a list of sections, attempt to resolve \\a addr as an offset into\n  /// one of the file sections.\n  ///\n  /// \\return\n  ///     Returns \\b true if \\a addr was able to be resolved, \\b false\n  ///     otherwise.\n  bool ResolveAddressUsingFileSections(lldb::addr_t addr,\n                                       const SectionList *sections);\n\n  /// Resolve this address to its containing function and optionally get\n  /// that function's address range.\n  ///\n  /// \\param[out] sym_ctx\n  ///     The symbol context describing the function in which this address lies\n  ///\n  /// \\parm[out] addr_range_ptr\n  ///     Pointer to the AddressRange to fill in with the function's address\n  ///     range.  Caller may pass null if they don't need the address range.\n  ///\n  /// \\return\n  ///     Returns \\b false if the function/symbol could not be resolved\n  ///     or if the address range was requested and could not be resolved;\n  ///     returns \\b true otherwise.\n  bool ResolveFunctionScope(lldb_private::SymbolContext &sym_ctx,\n                            lldb_private::AddressRange *addr_range_ptr = nullptr);\n\n  /// Set the address to represent \\a load_addr.\n  ///\n  /// The address will attempt to find a loaded section within \\a target that\n  /// contains \\a load_addr. If successful, this address object will have a\n  /// valid section and offset. Else this address object will have no section\n  /// (NULL) and the offset will be \\a load_addr.\n  ///\n  /// \\param[in] load_addr\n  ///     A load address from a current process.\n  ///\n  /// \\param[in] target\n  ///     The target to use when trying resolve the address into\n  ///     a section + offset. The Target's SectionLoadList object\n  ///     is used to resolve the address.\n  ///\n  /// \\param[in] allow_section_end\n  ///     If true, treat an address pointing to the end of the module as\n  ///     belonging to that module.\n  ///\n  /// \\return\n  ///     Returns \\b true if the load address was resolved to be\n  ///     section/offset, \\b false otherwise. It is often ok for an\n  ///     address to not resolve to a section in a module, this often\n  ///     happens for JIT'ed code, or any load addresses on the stack\n  ///     or heap.\n  bool SetLoadAddress(lldb::addr_t load_addr, Target *target,\n                      bool allow_section_end = false);\n\n  bool SetOpcodeLoadAddress(\n      lldb::addr_t load_addr, Target *target,\n      AddressClass addr_class = AddressClass::eInvalid,\n      bool allow_section_end = false);\n\n  bool SetCallableLoadAddress(lldb::addr_t load_addr, Target *target);\n\n  /// Get accessor for the module for this address.\n  ///\n  /// \\return\n  ///     Returns the Module pointer that this address is an offset\n  ///     in, or NULL if this address doesn't belong in a module, or\n  ///     isn't resolved yet.\n  lldb::ModuleSP GetModule() const;\n\n  /// Get const accessor for the section.\n  ///\n  /// \\return\n  ///     Returns the const lldb::Section pointer that this address is an\n  ///     offset in, or NULL if this address is absolute.\n  lldb::SectionSP GetSection() const { return m_section_wp.lock(); }\n\n  /// Set accessor for the offset.\n  ///\n  /// \\param[in] offset\n  ///     A new offset value for this object.\n  ///\n  /// \\return\n  ///     Returns \\b true if the offset changed, \\b false otherwise.\n  bool SetOffset(lldb::addr_t offset) {\n    bool changed = m_offset != offset;\n    m_offset = offset;\n    return changed;\n  }\n\n  void SetRawAddress(lldb::addr_t addr) {\n    m_section_wp.reset();\n    m_offset = addr;\n  }\n\n  bool Slide(int64_t offset) {\n    if (m_offset != LLDB_INVALID_ADDRESS) {\n      m_offset += offset;\n      return true;\n    }\n    return false;\n  }\n\n  /// Set accessor for the section.\n  ///\n  /// \\param[in] section_sp\n  ///     A new lldb::Section pointer to use as the section base. Can\n  ///     be NULL for absolute addresses that are not relative to\n  ///     any section.\n  void SetSection(const lldb::SectionSP &section_sp) {\n    m_section_wp = section_sp;\n  }\n\n  void ClearSection() { m_section_wp.reset(); }\n\n  /// Reconstruct a symbol context from an address.\n  ///\n  /// This class doesn't inherit from SymbolContextScope because many address\n  /// objects have short lifespans. Address objects that are section offset\n  /// can reconstruct their symbol context by looking up the address in the\n  /// module found in the section.\n  ///\n  /// \\see SymbolContextScope::CalculateSymbolContext(SymbolContext*)\n  uint32_t CalculateSymbolContext(SymbolContext *sc,\n                                  lldb::SymbolContextItem resolve_scope =\n                                      lldb::eSymbolContextEverything) const;\n\n  lldb::ModuleSP CalculateSymbolContextModule() const;\n\n  CompileUnit *CalculateSymbolContextCompileUnit() const;\n\n  Function *CalculateSymbolContextFunction() const;\n\n  Block *CalculateSymbolContextBlock() const;\n\n  Symbol *CalculateSymbolContextSymbol() const;\n\n  bool CalculateSymbolContextLineEntry(LineEntry &line_entry) const;\n\n  // Returns true if the section should be valid, but isn't because the shared\n  // pointer to the section can't be reconstructed from a weak pointer that\n  // contains a valid weak reference to a section. Returns false if the section\n  // weak pointer has no reference to a section, or if the section is still\n  // valid\n  bool SectionWasDeleted() const;\n\nprotected:\n  // Member variables.\n  lldb::SectionWP m_section_wp; ///< The section for the address, can be NULL.\n  lldb::addr_t m_offset; ///< Offset into section if \\a m_section_wp is valid...\n\n  // Returns true if the m_section_wp once had a reference to a valid section\n  // shared pointer, but no longer does. This can happen if we have an address\n  // from a module that gets unloaded and deleted. This function should only be\n  // called if GetSection() returns an empty shared pointer and you want to\n  // know if this address used to have a valid section.\n  bool SectionWasDeletedPrivate() const;\n};\n\n// NOTE: Be careful using this operator. It can correctly compare two\n// addresses from the same Module correctly. It can't compare two addresses\n// from different modules in any meaningful way, but it will compare the module\n// pointers.\n//\n// To sum things up:\n// - works great for addresses within the same module - it works for addresses\n// across multiple modules, but don't expect the\n//   address results to make much sense\n//\n// This basically lets Address objects be used in ordered collection classes.\nbool operator<(const Address &lhs, const Address &rhs);\nbool operator>(const Address &lhs, const Address &rhs);\nbool operator==(const Address &lhs, const Address &rhs);\nbool operator!=(const Address &lhs, const Address &rhs);\n\n} // namespace lldb_private\n\n#endif // LLDB_CORE_ADDRESS_H\n"}, "1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Disassembler.h", "content": "//===-- Disassembler.h ------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_CORE_DISASSEMBLER_H\n#define LLDB_CORE_DISASSEMBLER_H\n\n#include \"lldb/Core/Address.h\"\n#include \"lldb/Core/EmulateInstruction.h\"\n#include \"lldb/Core/FormatEntity.h\"\n#include \"lldb/Core/Opcode.h\"\n#include \"lldb/Core/PluginInterface.h\"\n#include \"lldb/Interpreter/OptionValue.h\"\n#include \"lldb/Symbol/LineEntry.h\"\n#include \"lldb/Target/ExecutionContext.h\"\n#include \"lldb/Utility/ArchSpec.h\"\n#include \"lldb/Utility/ConstString.h\"\n#include \"lldb/Utility/FileSpec.h\"\n#include \"lldb/lldb-defines.h\"\n#include \"lldb/lldb-forward.h\"\n#include \"lldb/lldb-private-enumerations.h\"\n#include \"lldb/lldb-types.h\"\n\n#include \"llvm/ADT/StringRef.h\"\n\n#include <functional>\n#include <map>\n#include <memory>\n#include <set>\n#include <string>\n#include <vector>\n\n#include <stddef.h>\n#include <stdint.h>\n#include <stdio.h>\n\nnamespace llvm {\ntemplate <typename T> class SmallVectorImpl;\n}\n\nnamespace lldb_private {\nclass AddressRange;\nclass DataExtractor;\nclass Debugger;\nclass Disassembler;\nclass Module;\nclass StackFrame;\nclass Stream;\nclass SymbolContext;\nclass SymbolContextList;\nclass Target;\nstruct RegisterInfo;\n\nclass Instruction {\npublic:\n  Instruction(const Address &address,\n              AddressClass addr_class = AddressClass::eInvalid);\n\n  virtual ~Instruction();\n\n  const Address &GetAddress() const { return m_address; }\n\n  const char *GetMnemonic(const ExecutionContext *exe_ctx) {\n    CalculateMnemonicOperandsAndCommentIfNeeded(exe_ctx);\n    return m_opcode_name.c_str();\n  }\n\n  const char *GetOperands(const ExecutionContext *exe_ctx) {\n    CalculateMnemonicOperandsAndCommentIfNeeded(exe_ctx);\n    return m_mnemonics.c_str();\n  }\n\n  const char *GetComment(const ExecutionContext *exe_ctx) {\n    CalculateMnemonicOperandsAndCommentIfNeeded(exe_ctx);\n    return m_comment.c_str();\n  }\n\n  virtual void\n  CalculateMnemonicOperandsAndComment(const ExecutionContext *exe_ctx) = 0;\n\n  AddressClass GetAddressClass();\n\n  void SetAddress(const Address &addr) {\n    // Invalidate the address class to lazily discover it if we need to.\n    m_address_class = AddressClass::eInvalid;\n    m_address = addr;\n  }\n\n  /// Dump the text representation of this Instruction to a Stream\n  ///\n  /// Print the (optional) address, (optional) bytes, opcode,\n  /// operands, and instruction comments to a stream.\n  ///\n  /// \\param[in] s\n  ///     The Stream to add the text to.\n  ///\n  /// \\param[in] show_address\n  ///     Whether the address (using disassembly_addr_format_spec formatting)\n  ///     should be printed.\n  ///\n  /// \\param[in] show_bytes\n  ///     Whether the bytes of the assembly instruction should be printed.\n  ///\n  /// \\param[in] max_opcode_byte_size\n  ///     The size (in bytes) of the largest instruction in the list that\n  ///     we are printing (for text justification/alignment purposes)\n  ///     Only needed if show_bytes is true.\n  ///\n  /// \\param[in] exe_ctx\n  ///     The current execution context, if available.  May be used in\n  ///     the assembling of the operands+comments for this instruction.\n  ///     Pass NULL if not applicable.\n  ///\n  /// \\param[in] sym_ctx\n  ///     The SymbolContext for this instruction.\n  ///     Pass NULL if not available/computed.\n  ///     Only needed if show_address is true.\n  ///\n  /// \\param[in] prev_sym_ctx\n  ///     The SymbolContext for the previous instruction.  Depending on\n  ///     the disassembly address format specification, a change in\n  ///     Symbol / Function may mean that a line is printed with the new\n  ///     symbol/function name.\n  ///     Pass NULL if unavailable, or if this is the first instruction of\n  ///     the InstructionList.\n  ///     Only needed if show_address is true.\n  ///\n  /// \\param[in] disassembly_addr_format\n  ///     The format specification for how addresses are printed.\n  ///     Only needed if show_address is true.\n  ///\n  /// \\param[in] max_address_text_size\n  ///     The length of the longest address string at the start of the\n  ///     disassembly line that will be printed (the\n  ///     Debugger::FormatDisassemblerAddress() string)\n  ///     so this method can properly align the instruction opcodes.\n  ///     May be 0 to indicate no indentation/alignment of the opcodes.\n  virtual void Dump(Stream *s, uint32_t max_opcode_byte_size, bool show_address,\n                    bool show_bytes, const ExecutionContext *exe_ctx,\n                    const SymbolContext *sym_ctx,\n                    const SymbolContext *prev_sym_ctx,\n                    const FormatEntity::Entry *disassembly_addr_format,\n                    size_t max_address_text_size);\n\n  virtual bool DoesBranch() = 0;\n\n  virtual bool HasDelaySlot();\n\n  bool CanSetBreakpoint ();\n\n  virtual size_t Decode(const Disassembler &disassembler,\n                        const DataExtractor &data,\n                        lldb::offset_t data_offset) = 0;\n\n  virtual void SetDescription(llvm::StringRef) {\n  } // May be overridden in sub-classes that have descriptions.\n\n  lldb::OptionValueSP ReadArray(FILE *in_file, Stream *out_stream,\n                                OptionValue::Type data_type);\n\n  lldb::OptionValueSP ReadDictionary(FILE *in_file, Stream *out_stream);\n\n  bool DumpEmulation(const ArchSpec &arch);\n\n  virtual bool TestEmulation(Stream *stream, const char *test_file_name);\n\n  bool Emulate(const ArchSpec &arch, uint32_t evaluate_options, void *baton,\n               EmulateInstruction::ReadMemoryCallback read_mem_callback,\n               EmulateInstruction::WriteMemoryCallback write_mem_calback,\n               EmulateInstruction::ReadRegisterCallback read_reg_callback,\n               EmulateInstruction::WriteRegisterCallback write_reg_callback);\n\n  const Opcode &GetOpcode() const { return m_opcode; }\n\n  uint32_t GetData(DataExtractor &data);\n\n  struct Operand {\n    enum class Type {\n      Invalid = 0,\n      Register,\n      Immediate,\n      Dereference,\n      Sum,\n      Product\n    } m_type = Type::Invalid;\n    std::vector<Operand> m_children;\n    lldb::addr_t m_immediate = 0;\n    ConstString m_register;\n    bool m_negative = false;\n    bool m_clobbered = false;\n\n    bool IsValid() { return m_type != Type::Invalid; }\n\n    static Operand BuildRegister(ConstString &r);\n    static Operand BuildImmediate(lldb::addr_t imm, bool neg);\n    static Operand BuildImmediate(int64_t imm);\n    static Operand BuildDereference(const Operand &ref);\n    static Operand BuildSum(const Operand &lhs, const Operand &rhs);\n    static Operand BuildProduct(const Operand &lhs, const Operand &rhs);\n  };\n\n  virtual bool ParseOperands(llvm::SmallVectorImpl<Operand> &operands) {\n    return false;\n  }\n\n  virtual bool IsCall() { return false; }\n\nprotected:\n  Address m_address; // The section offset address of this instruction\n                     // We include an address class in the Instruction class to\n                     // allow the instruction specify the\n                     // AddressClass::eCodeAlternateISA (currently used for\n                     // thumb), and also to specify data (AddressClass::eData).\n                     // The usual value will be AddressClass::eCode, but often\n                     // when disassembling memory, you might run into data.\n                     // This can help us to disassemble appropriately.\nprivate:\n  AddressClass m_address_class; // Use GetAddressClass () accessor function!\n\nprotected:\n  Opcode m_opcode; // The opcode for this instruction\n  std::string m_opcode_name;\n  std::string m_mnemonics;\n  std::string m_comment;\n  bool m_calculated_strings;\n\n  void\n  CalculateMnemonicOperandsAndCommentIfNeeded(const ExecutionContext *exe_ctx) {\n    if (!m_calculated_strings) {\n      m_calculated_strings = true;\n      CalculateMnemonicOperandsAndComment(exe_ctx);\n    }\n  }\n};\n\nnamespace OperandMatchers {\nstd::function<bool(const Instruction::Operand &)>\nMatchBinaryOp(std::function<bool(const Instruction::Operand &)> base,\n              std::function<bool(const Instruction::Operand &)> left,\n              std::function<bool(const Instruction::Operand &)> right);\n\nstd::function<bool(const Instruction::Operand &)>\nMatchUnaryOp(std::function<bool(const Instruction::Operand &)> base,\n             std::function<bool(const Instruction::Operand &)> child);\n\nstd::function<bool(const Instruction::Operand &)>\nMatchRegOp(const RegisterInfo &info);\n\nstd::function<bool(const Instruction::Operand &)> FetchRegOp(ConstString &reg);\n\nstd::function<bool(const Instruction::Operand &)> MatchImmOp(int64_t imm);\n\nstd::function<bool(const Instruction::Operand &)> FetchImmOp(int64_t &imm);\n\nstd::function<bool(const Instruction::Operand &)>\nMatchOpType(Instruction::Operand::Type type);\n}\n\nclass InstructionList {\npublic:\n  InstructionList();\n  ~InstructionList();\n\n  size_t GetSize() const;\n\n  uint32_t GetMaxOpcocdeByteSize() const;\n\n  lldb::InstructionSP GetInstructionAtIndex(size_t idx) const;\n\n  /// Get the instruction at the given address.\n  ///\n  /// \\return\n  ///    A valid \\a InstructionSP if the address could be found, or null\n  ///    otherwise.\n  lldb::InstructionSP GetInstructionAtAddress(const Address &addr);\n\n  //------------------------------------------------------------------\n  /// Get the index of the next branch instruction.\n  ///\n  /// Given a list of instructions, find the next branch instruction\n  /// in the list by returning an index.\n  ///\n  /// @param[in] start\n  ///     The instruction index of the first instruction to check.\n  ///\n  /// @param[in] ignore_calls\n  ///     It true, then fine the first branch instruction that isn't\n  ///     a function call (a branch that calls and returns to the next\n  ///     instruction). If false, find the instruction index of any \n  ///     branch in the list.\n  ///     \n  /// @param[out] found_calls\n  ///     If non-null, this will be set to true if any calls were found in \n  ///     extending the range.\n  ///    \n  /// @return\n  ///     The instruction index of the first branch that is at or past\n  ///     \\a start. Returns UINT32_MAX if no matching branches are \n  ///     found.\n  //------------------------------------------------------------------\n  uint32_t GetIndexOfNextBranchInstruction(uint32_t start,\n                                           bool ignore_calls,\n                                           bool *found_calls) const;\n\n  uint32_t GetIndexOfInstructionAtLoadAddress(lldb::addr_t load_addr,\n                                              Target &target);\n\n  uint32_t GetIndexOfInstructionAtAddress(const Address &addr);\n\n  void Clear();\n\n  void Append(lldb::InstructionSP &inst_sp);\n\n  void Dump(Stream *s, bool show_address, bool show_bytes,\n            const ExecutionContext *exe_ctx);\n\nprivate:\n  typedef std::vector<lldb::InstructionSP> collection;\n  typedef collection::iterator iterator;\n  typedef collection::const_iterator const_iterator;\n\n  collection m_instructions;\n};\n\nclass PseudoInstruction : public Instruction {\npublic:\n  PseudoInstruction();\n\n  ~PseudoInstruction() override;\n\n  bool DoesBranch() override;\n\n  bool HasDelaySlot() override;\n\n  void CalculateMnemonicOperandsAndComment(\n      const ExecutionContext *exe_ctx) override {\n    // TODO: fill this in and put opcode name into Instruction::m_opcode_name,\n    // mnemonic into Instruction::m_mnemonics, and any comment into\n    // Instruction::m_comment\n  }\n\n  size_t Decode(const Disassembler &disassembler, const DataExtractor &data,\n                lldb::offset_t data_offset) override;\n\n  void SetOpcode(size_t opcode_size, void *opcode_data);\n\n  void SetDescription(llvm::StringRef description) override;\n\nprotected:\n  std::string m_description;\n\n  PseudoInstruction(const PseudoInstruction &) = delete;\n  const PseudoInstruction &operator=(const PseudoInstruction &) = delete;\n};\n\nclass Disassembler : public std::enable_shared_from_this<Disassembler>,\n                     public PluginInterface {\npublic:\n  enum {\n    eOptionNone = 0u,\n    eOptionShowBytes = (1u << 0),\n    eOptionRawOuput = (1u << 1),\n    eOptionMarkPCSourceLine = (1u << 2), // Mark the source line that contains\n                                         // the current PC (mixed mode only)\n    eOptionMarkPCAddress =\n        (1u << 3) // Mark the disassembly line the contains the PC\n  };\n\n  enum HexImmediateStyle {\n    eHexStyleC,\n    eHexStyleAsm,\n  };\n\n  // FindPlugin should be lax about the flavor string (it is too annoying to\n  // have various internal uses of the disassembler fail because the global\n  // flavor string gets set wrong. Instead, if you get a flavor string you\n  // don't understand, use the default.  Folks who care to check can use the\n  // FlavorValidForArchSpec method on the disassembler they got back.\n  static lldb::DisassemblerSP\n  FindPlugin(const ArchSpec &arch, const char *flavor, const char *plugin_name);\n\n  // This version will use the value in the Target settings if flavor is NULL;\n  static lldb::DisassemblerSP FindPluginForTarget(const Target &target,\n                                                  const ArchSpec &arch,\n                                                  const char *flavor,\n                                                  const char *plugin_name);\n\n  struct Limit {\n    enum { Bytes, Instructions } kind;\n    lldb::addr_t value;\n  };\n\n  static lldb::DisassemblerSP\n  DisassembleRange(const ArchSpec &arch, const char *plugin_name,\n                   const char *flavor, Target &target,\n                   const AddressRange &disasm_range, bool prefer_file_cache);\n\n  static lldb::DisassemblerSP\n  DisassembleBytes(const ArchSpec &arch, const char *plugin_name,\n                   const char *flavor, const Address &start, const void *bytes,\n                   size_t length, uint32_t max_num_instructions,\n                   bool data_from_file);\n\n  static bool Disassemble(Debugger &debugger, const ArchSpec &arch,\n                          const char *plugin_name, const char *flavor,\n                          const ExecutionContext &exe_ctx, const Address &start,\n                          Limit limit, bool mixed_source_and_assembly,\n                          uint32_t num_mixed_context_lines, uint32_t options,\n                          Stream &strm);\n\n  static bool Disassemble(Debugger &debugger, const ArchSpec &arch,\n                          StackFrame &frame, Stream &strm);\n\n  // Constructors and Destructors\n  Disassembler(const ArchSpec &arch, const char *flavor);\n  ~Disassembler() override;\n\n  void PrintInstructions(Debugger &debugger, const ArchSpec &arch,\n                         const ExecutionContext &exe_ctx,\n                         bool mixed_source_and_assembly,\n                         uint32_t num_mixed_context_lines, uint32_t options,\n                         Stream &strm);\n\n  size_t ParseInstructions(Target &target, Address address, Limit limit,\n                           Stream *error_strm_ptr, bool prefer_file_cache);\n\n  virtual size_t DecodeInstructions(const Address &base_addr,\n                                    const DataExtractor &data,\n                                    lldb::offset_t data_offset,\n                                    size_t num_instructions, bool append,\n                                    bool data_from_file) = 0;\n\n  InstructionList &GetInstructionList();\n\n  const InstructionList &GetInstructionList() const;\n\n  const ArchSpec &GetArchitecture() const { return m_arch; }\n\n  const char *GetFlavor() const { return m_flavor.c_str(); }\n\n  virtual bool FlavorValidForArchSpec(const lldb_private::ArchSpec &arch,\n                                      const char *flavor) = 0;\n\nprotected:\n  // SourceLine and SourceLinesToDisplay structures are only used in the mixed\n  // source and assembly display methods internal to this class.\n\n  struct SourceLine {\n    FileSpec file;\n    uint32_t line;\n    uint32_t column;\n\n    SourceLine() : file(), line(LLDB_INVALID_LINE_NUMBER), column(0) {}\n\n    bool operator==(const SourceLine &rhs) const {\n      return file == rhs.file && line == rhs.line && rhs.column == column;\n    }\n\n    bool operator!=(const SourceLine &rhs) const {\n      return file != rhs.file || line != rhs.line || column != rhs.column;\n    }\n\n    bool IsValid() const { return line != LLDB_INVALID_LINE_NUMBER; }\n  };\n\n  struct SourceLinesToDisplay {\n    std::vector<SourceLine> lines;\n\n    // index of the \"current\" source line, if we want to highlight that when\n    // displaying the source lines.  (as opposed to the surrounding source\n    // lines provided to give context)\n    size_t current_source_line;\n\n    // Whether to print a blank line at the end of the source lines.\n    bool print_source_context_end_eol;\n\n    SourceLinesToDisplay()\n        : lines(), current_source_line(-1), print_source_context_end_eol(true) {\n    }\n  };\n\n  // Get the function's declaration line number, hopefully a line number\n  // earlier than the opening curly brace at the start of the function body.\n  static SourceLine GetFunctionDeclLineEntry(const SymbolContext &sc);\n\n  // Add the provided SourceLine to the map of filenames-to-source-lines-seen.\n  static void AddLineToSourceLineTables(\n      SourceLine &line,\n      std::map<FileSpec, std::set<uint32_t>> &source_lines_seen);\n\n  // Given a source line, determine if we should print it when we're doing\n  // mixed source & assembly output. We're currently using the\n  // target.process.thread.step-avoid-regexp setting (which is used for\n  // stepping over inlined STL functions by default) to determine what source\n  // lines to avoid showing.\n  //\n  // Returns true if this source line should be elided (if the source line\n  // should not be displayed).\n  static bool\n  ElideMixedSourceAndDisassemblyLine(const ExecutionContext &exe_ctx,\n                                     const SymbolContext &sc, SourceLine &line);\n\n  static bool\n  ElideMixedSourceAndDisassemblyLine(const ExecutionContext &exe_ctx,\n                                     const SymbolContext &sc, LineEntry &line) {\n    SourceLine sl;\n    sl.file = line.file;\n    sl.line = line.line;\n    sl.column = line.column;\n    return ElideMixedSourceAndDisassemblyLine(exe_ctx, sc, sl);\n  };\n\n  // Classes that inherit from Disassembler can see and modify these\n  ArchSpec m_arch;\n  InstructionList m_instruction_list;\n  lldb::addr_t m_base_addr;\n  std::string m_flavor;\n\nprivate:\n  // For Disassembler only\n  Disassembler(const Disassembler &) = delete;\n  const Disassembler &operator=(const Disassembler &) = delete;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_CORE_DISASSEMBLER_H\n"}, "2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/FormatEntity.h", "content": "//===-- FormatEntity.h ------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_CORE_FORMATENTITY_H\n#define LLDB_CORE_FORMATENTITY_H\n\n#include \"lldb/Utility/CompletionRequest.h\"\n#include \"lldb/Utility/FileSpec.h\"\n#include \"lldb/Utility/Status.h\"\n#include \"lldb/lldb-enumerations.h\"\n#include \"lldb/lldb-types.h\"\n#include <algorithm>\n#include <stddef.h>\n#include <stdint.h>\n\n#include <string>\n#include <vector>\n\nnamespace lldb_private {\nclass Address;\nclass ExecutionContext;\nclass Stream;\nclass StringList;\nclass SymbolContext;\nclass ValueObject;\n}\nnamespace llvm {\nclass StringRef;\n}\n\nnamespace lldb_private {\nclass FormatEntity {\npublic:\n  struct Entry {\n    enum class Type {\n      Invalid,\n      ParentNumber,\n      ParentString,\n      EscapeCode,\n      Root,\n      String,\n      Scope,\n      Variable,\n      VariableSynthetic,\n      ScriptVariable,\n      ScriptVariableSynthetic,\n      AddressLoad,\n      AddressFile,\n      AddressLoadOrFile,\n      ProcessID,\n      ProcessFile,\n      ScriptProcess,\n      ThreadID,\n      ThreadProtocolID,\n      ThreadIndexID,\n      ThreadName,\n      ThreadQueue,\n      ThreadStopReason,\n      ThreadStopReasonRaw,\n      ThreadReturnValue,\n      ThreadCompletedExpression,\n      ScriptThread,\n      ThreadInfo,\n      TargetArch,\n      ScriptTarget,\n      ModuleFile,\n      File,\n      Lang,\n      FrameIndex,\n      FrameNoDebug,\n      FrameRegisterPC,\n      FrameRegisterSP,\n      FrameRegisterFP,\n      FrameRegisterFlags,\n      FrameRegisterByName,\n      FrameIsArtificial,\n      ScriptFrame,\n      FunctionID,\n      FunctionDidChange,\n      FunctionInitialFunction,\n      FunctionName,\n      FunctionNameWithArgs,\n      FunctionNameNoArgs,\n      FunctionMangledName,\n      FunctionAddrOffset,\n      FunctionAddrOffsetConcrete,\n      FunctionLineOffset,\n      FunctionPCOffset,\n      FunctionInitial,\n      FunctionChanged,\n      FunctionIsOptimized,\n      LineEntryFile,\n      LineEntryLineNumber,\n      LineEntryColumn,\n      LineEntryStartAddress,\n      LineEntryEndAddress,\n      CurrentPCArrow\n    };\n\n    struct Definition {\n      const char *name;\n      const char *string; // Insert this exact string into the output\n      Entry::Type type;\n      uint64_t data;\n      uint32_t num_children;\n      Definition *children; // An array of \"num_children\" Definition entries,\n      bool keep_separator;\n    };\n\n    Entry(Type t = Type::Invalid, const char *s = nullptr,\n          const char *f = nullptr)\n        : string(s ? s : \"\"), printf_format(f ? f : \"\"), children(),\n          definition(nullptr), type(t), fmt(lldb::eFormatDefault), number(0),\n          deref(false) {}\n\n    Entry(llvm::StringRef s);\n    Entry(char ch);\n\n    void AppendChar(char ch);\n\n    void AppendText(const llvm::StringRef &s);\n\n    void AppendText(const char *cstr);\n\n    void AppendEntry(const Entry &&entry) { children.push_back(entry); }\n\n    void Clear() {\n      string.clear();\n      printf_format.clear();\n      children.clear();\n      definition = nullptr;\n      type = Type::Invalid;\n      fmt = lldb::eFormatDefault;\n      number = 0;\n      deref = false;\n    }\n\n    static const char *TypeToCString(Type t);\n\n    void Dump(Stream &s, int depth = 0) const;\n\n    bool operator==(const Entry &rhs) const {\n      if (string != rhs.string)\n        return false;\n      if (printf_format != rhs.printf_format)\n        return false;\n      const size_t n = children.size();\n      const size_t m = rhs.children.size();\n      for (size_t i = 0; i < std::min<size_t>(n, m); ++i) {\n        if (!(children[i] == rhs.children[i]))\n          return false;\n      }\n      if (children != rhs.children)\n        return false;\n      if (definition != rhs.definition)\n        return false;\n      if (type != rhs.type)\n        return false;\n      if (fmt != rhs.fmt)\n        return false;\n      if (deref != rhs.deref)\n        return false;\n      return true;\n    }\n\n    std::string string;\n    std::string printf_format;\n    std::vector<Entry> children;\n    Definition *definition;\n    Type type;\n    lldb::Format fmt;\n    lldb::addr_t number;\n    bool deref;\n  };\n\n  static bool Format(const Entry &entry, Stream &s, const SymbolContext *sc,\n                     const ExecutionContext *exe_ctx, const Address *addr,\n                     ValueObject *valobj, bool function_changed,\n                     bool initial_function);\n\n  static bool FormatStringRef(const llvm::StringRef &format, Stream &s,\n                              const SymbolContext *sc,\n                              const ExecutionContext *exe_ctx,\n                              const Address *addr, ValueObject *valobj,\n                              bool function_changed, bool initial_function);\n\n  static bool FormatCString(const char *format, Stream &s,\n                            const SymbolContext *sc,\n                            const ExecutionContext *exe_ctx,\n                            const Address *addr, ValueObject *valobj,\n                            bool function_changed, bool initial_function);\n\n  static Status Parse(const llvm::StringRef &format, Entry &entry);\n\n  static Status ExtractVariableInfo(llvm::StringRef &format_str,\n                                    llvm::StringRef &variable_name,\n                                    llvm::StringRef &variable_format);\n\n  static void AutoComplete(lldb_private::CompletionRequest &request);\n\n  // Format the current elements into the stream \\a s.\n  //\n  // The root element will be stripped off and the format str passed in will be\n  // either an empty string (print a description of this object), or contain a\n  // `.`-separated series like a domain name that identifies further\n  //  sub-elements to display.\n  static bool FormatFileSpec(const FileSpec &file, Stream &s,\n                             llvm::StringRef elements,\n                             llvm::StringRef element_format);\n\nprotected:\n  static Status ParseInternal(llvm::StringRef &format, Entry &parent_entry,\n                              uint32_t depth);\n};\n} // namespace lldb_private\n\n#endif // LLDB_CORE_FORMATENTITY_H\n"}, "3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/LoadedModuleInfoList.h", "content": "//===-- LoadedModuleInfoList.h ----------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_CORE_LOADEDMODULEINFOLIST_H\n#define LLDB_CORE_LOADEDMODULEINFOLIST_H\n\n#include <cassert>\n#include <string>\n#include <vector>\n\n#include \"lldb/lldb-defines.h\"\n#include \"lldb/lldb-private-forward.h\"\n#include \"lldb/lldb-types.h\"\n\nnamespace lldb_private {\nclass LoadedModuleInfoList {\npublic:\n  class LoadedModuleInfo {\n  public:\n    enum e_data_point {\n      e_has_name = 0,\n      e_has_base,\n      e_has_dynamic,\n      e_has_link_map,\n      e_num\n    };\n\n    LoadedModuleInfo() {\n      for (uint32_t i = 0; i < e_num; ++i)\n        m_has[i] = false;\n    };\n\n    void set_name(const std::string &name) {\n      m_name = name;\n      m_has[e_has_name] = true;\n    }\n    bool get_name(std::string &out) const {\n      out = m_name;\n      return m_has[e_has_name];\n    }\n\n    void set_base(const lldb::addr_t base) {\n      m_base = base;\n      m_has[e_has_base] = true;\n    }\n    bool get_base(lldb::addr_t &out) const {\n      out = m_base;\n      return m_has[e_has_base];\n    }\n\n    void set_base_is_offset(bool is_offset) { m_base_is_offset = is_offset; }\n    bool get_base_is_offset(bool &out) const {\n      out = m_base_is_offset;\n      return m_has[e_has_base];\n    }\n\n    void set_link_map(const lldb::addr_t addr) {\n      m_link_map = addr;\n      m_has[e_has_link_map] = true;\n    }\n    bool get_link_map(lldb::addr_t &out) const {\n      out = m_link_map;\n      return m_has[e_has_link_map];\n    }\n\n    void set_dynamic(const lldb::addr_t addr) {\n      m_dynamic = addr;\n      m_has[e_has_dynamic] = true;\n    }\n    bool get_dynamic(lldb::addr_t &out) const {\n      out = m_dynamic;\n      return m_has[e_has_dynamic];\n    }\n\n    bool has_info(e_data_point datum) const {\n      assert(datum < e_num);\n      return m_has[datum];\n    }\n\n    bool operator==(LoadedModuleInfo const &rhs) const {\n      for (size_t i = 0; i < e_num; ++i) {\n        if (m_has[i] != rhs.m_has[i])\n          return false;\n      }\n\n      return (m_base == rhs.m_base) && (m_link_map == rhs.m_link_map) &&\n             (m_dynamic == rhs.m_dynamic) && (m_name == rhs.m_name);\n    }\n\n  protected:\n    bool m_has[e_num];\n    std::string m_name;\n    lldb::addr_t m_link_map;\n    lldb::addr_t m_base;\n    bool m_base_is_offset;\n    lldb::addr_t m_dynamic;\n  };\n\n  LoadedModuleInfoList() : m_list(), m_link_map(LLDB_INVALID_ADDRESS) {}\n\n  void add(const LoadedModuleInfo &mod) { m_list.push_back(mod); }\n\n  void clear() { m_list.clear(); }\n\n  std::vector<LoadedModuleInfo> m_list;\n  lldb::addr_t m_link_map;\n};\n} // namespace lldb_private\n\n#endif // LLDB_CORE_LOADEDMODULEINFOLIST_H\n"}, "4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Host/Host.h", "content": "//===-- Host.h --------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_HOST_HOST_H\n#define LLDB_HOST_HOST_H\n\n#include \"lldb/Host/File.h\"\n#include \"lldb/Host/HostThread.h\"\n#include \"lldb/Utility/Environment.h\"\n#include \"lldb/Utility/FileSpec.h\"\n#include \"lldb/Utility/Timeout.h\"\n#include \"lldb/lldb-private-forward.h\"\n#include \"lldb/lldb-private.h\"\n#include <cerrno>\n#include <map>\n#include <stdarg.h>\n#include <string>\n#include <type_traits>\n\nnamespace lldb_private {\n\nclass FileAction;\nclass ProcessLaunchInfo;\nclass ProcessInstanceInfo;\nclass ProcessInstanceInfoMatch;\ntypedef std::vector<ProcessInstanceInfo> ProcessInstanceInfoList;\n\n// Exit Type for inferior processes\nstruct WaitStatus {\n  enum Type : uint8_t {\n    Exit,   // The status represents the return code from normal\n            // program exit (i.e. WIFEXITED() was true)\n    Signal, // The status represents the signal number that caused\n            // the program to exit (i.e. WIFSIGNALED() was true)\n    Stop,   // The status represents the signal number that caused the\n            // program to stop (i.e. WIFSTOPPED() was true)\n  };\n\n  Type type;\n  uint8_t status;\n\n  WaitStatus(Type type, uint8_t status) : type(type), status(status) {}\n\n  static WaitStatus Decode(int wstatus);\n};\n\ninline bool operator==(WaitStatus a, WaitStatus b) {\n  return a.type == b.type && a.status == b.status;\n}\n\ninline bool operator!=(WaitStatus a, WaitStatus b) { return !(a == b); }\n\n/// \\class Host Host.h \"lldb/Host/Host.h\"\n/// A class that provides host computer information.\n///\n/// Host is a class that answers information about the host operating system.\nclass Host {\npublic:\n  typedef std::function<bool(\n      lldb::pid_t pid, bool exited,\n      int signal,  // Zero for no signal\n      int status)> // Exit value of process if signal is zero\n      MonitorChildProcessCallback;\n\n  /// Start monitoring a child process.\n  ///\n  /// Allows easy monitoring of child processes. \\a callback will be called\n  /// when the child process exits or if it gets a signal. The callback will\n  /// only be called with signals if \\a monitor_signals is \\b true. \\a\n  /// callback will usually be called from another thread so the callback\n  /// function must be thread safe.\n  ///\n  /// When the callback gets called, the return value indicates if monitoring\n  /// should stop. If \\b true is returned from \\a callback the information\n  /// will be removed. If \\b false is returned then monitoring will continue.\n  /// If the child process exits, the monitoring will automatically stop after\n  /// the callback returned regardless of the callback return value.\n  ///\n  /// \\param[in] callback\n  ///     A function callback to call when a child receives a signal\n  ///     (if \\a monitor_signals is true) or a child exits.\n  ///\n  /// \\param[in] pid\n  ///     The process ID of a child process to monitor, -1 for all\n  ///     processes.\n  ///\n  /// \\param[in] monitor_signals\n  ///     If \\b true the callback will get called when the child\n  ///     process gets a signal. If \\b false, the callback will only\n  ///     get called if the child process exits.\n  ///\n  /// \\return\n  ///     A thread handle that can be used to cancel the thread that\n  ///     was spawned to monitor \\a pid.\n  ///\n  /// \\see static void Host::StopMonitoringChildProcess (uint32_t)\n  static llvm::Expected<HostThread>\n  StartMonitoringChildProcess(const MonitorChildProcessCallback &callback,\n                              lldb::pid_t pid, bool monitor_signals);\n\n  enum SystemLogType { eSystemLogWarning, eSystemLogError };\n\n  static void SystemLog(SystemLogType type, const char *format, ...)\n      __attribute__((format(printf, 2, 3)));\n\n  static void SystemLog(SystemLogType type, const char *format, va_list args);\n\n  /// Get the process ID for the calling process.\n  ///\n  /// \\return\n  ///     The process ID for the current process.\n  static lldb::pid_t GetCurrentProcessID();\n\n  static void Kill(lldb::pid_t pid, int signo);\n\n  /// Get the thread token (the one returned by ThreadCreate when the thread\n  /// was created) for the calling thread in the current process.\n  ///\n  /// \\return\n  ///     The thread token for the calling thread in the current process.\n  static lldb::thread_t GetCurrentThread();\n\n  static const char *GetSignalAsCString(int signo);\n\n  /// Given an address in the current process (the process that is running the\n  /// LLDB code), return the name of the module that it comes from. This can\n  /// be useful when you need to know the path to the shared library that your\n  /// code is running in for loading resources that are relative to your\n  /// binary.\n  ///\n  /// \\param[in] host_addr\n  ///     The pointer to some code in the current process.\n  ///\n  /// \\return\n  ///     \\b A file spec with the module that contains \\a host_addr,\n  ///     which may be invalid if \\a host_addr doesn't fall into\n  ///     any valid module address range.\n  static FileSpec GetModuleFileSpecForHostAddress(const void *host_addr);\n\n  /// If you have an executable that is in a bundle and want to get back to\n  /// the bundle directory from the path itself, this function will change a\n  /// path to a file within a bundle to the bundle directory itself.\n  ///\n  /// \\param[in] file\n  ///     A file spec that might point to a file in a bundle.\n  ///\n  /// \\param[out] bundle_directory\n  ///     An object will be filled in with the bundle directory for\n  ///     the bundle when \\b true is returned. Otherwise \\a file is\n  ///     left untouched and \\b false is returned.\n  ///\n  /// \\return\n  ///     \\b true if \\a file was resolved in \\a bundle_directory,\n  ///     \\b false otherwise.\n  static bool GetBundleDirectory(const FileSpec &file,\n                                 FileSpec &bundle_directory);\n\n  /// When executable files may live within a directory, where the directory\n  /// represents an executable bundle (like the MacOSX app bundles), then\n  /// locate the executable within the containing bundle.\n  ///\n  /// \\param[in,out] file\n  ///     A file spec that currently points to the bundle that will\n  ///     be filled in with the executable path within the bundle\n  ///     if \\b true is returned. Otherwise \\a file is left untouched.\n  ///\n  /// \\return\n  ///     \\b true if \\a file was resolved, \\b false if this function\n  ///     was not able to resolve the path.\n  static bool ResolveExecutableInBundle(FileSpec &file);\n\n  static uint32_t FindProcesses(const ProcessInstanceInfoMatch &match_info,\n                                ProcessInstanceInfoList &proc_infos);\n\n  typedef std::map<lldb::pid_t, bool> TidMap;\n  typedef std::pair<lldb::pid_t, bool> TidPair;\n  static bool FindProcessThreads(const lldb::pid_t pid, TidMap &tids_to_attach);\n\n  static bool GetProcessInfo(lldb::pid_t pid, ProcessInstanceInfo &proc_info);\n\n  /// Launch the process specified in launch_info. The monitoring callback in\n  /// launch_info must be set, and it will be called when the process\n  /// terminates.\n  static Status LaunchProcess(ProcessLaunchInfo &launch_info);\n\n  /// Perform expansion of the command-line for this launch info This can\n  /// potentially involve wildcard expansion\n  /// environment variable replacement, and whatever other\n  /// argument magic the platform defines as part of its typical\n  /// user experience\n  static Status ShellExpandArguments(ProcessLaunchInfo &launch_info);\n\n  /// Run a shell command.\n  /// \\arg command  shouldn't be empty\n  /// \\arg working_dir Pass empty FileSpec to use the current working directory\n  /// \\arg status_ptr  Pass NULL if you don't want the process exit status\n  /// \\arg signo_ptr   Pass NULL if you don't want the signal that caused the\n  ///                  process to exit\n  /// \\arg command_output  Pass NULL if you don't want the command output\n  /// \\arg hide_stderr if this is false, redirect stderr to stdout\n  static Status RunShellCommand(llvm::StringRef command,\n                                const FileSpec &working_dir, int *status_ptr,\n                                int *signo_ptr, std::string *command_output,\n                                const Timeout<std::micro> &timeout,\n                                bool run_in_shell = true,\n                                bool hide_stderr = false);\n\n  /// Run a shell command.\n  /// \\arg shell  Pass an empty string if you want to use the default shell\n  /// interpreter \\arg command \\arg working_dir  Pass empty FileSpec to use the\n  /// current working directory \\arg status_ptr   Pass NULL if you don't want\n  /// the process exit status \\arg signo_ptr    Pass NULL if you don't want the\n  /// signal that caused\n  ///                   the process to exit\n  /// \\arg command_output  Pass NULL if you don't want the command output\n  /// \\arg hide_stderr  If this is \\b false, redirect stderr to stdout\n  static Status RunShellCommand(llvm::StringRef shell, llvm::StringRef command,\n                                const FileSpec &working_dir, int *status_ptr,\n                                int *signo_ptr, std::string *command_output,\n                                const Timeout<std::micro> &timeout,\n                                bool run_in_shell = true,\n                                bool hide_stderr = false);\n\n  /// Run a shell command.\n  /// \\arg working_dir Pass empty FileSpec to use the current working directory\n  /// \\arg status_ptr  Pass NULL if you don't want the process exit status\n  /// \\arg signo_ptr   Pass NULL if you don't want the signal that caused the\n  ///                  process to exit\n  /// \\arg command_output  Pass NULL if you don't want the command output\n  /// \\arg hide_stderr if this is false, redirect stderr to stdout\n  static Status RunShellCommand(const Args &args, const FileSpec &working_dir,\n                                int *status_ptr, int *signo_ptr,\n                                std::string *command_output,\n                                const Timeout<std::micro> &timeout,\n                                bool run_in_shell = true,\n                                bool hide_stderr = false);\n\n  /// Run a shell command.\n  /// \\arg shell            Pass an empty string if you want to use the default\n  /// shell interpreter \\arg command \\arg working_dir Pass empty FileSpec to use\n  /// the current working directory \\arg status_ptr    Pass NULL if you don't\n  /// want the process exit status \\arg signo_ptr     Pass NULL if you don't\n  /// want the signal that caused the\n  ///               process to exit\n  /// \\arg command_output  Pass NULL if you don't want the command output\n  /// \\arg hide_stderr If this is \\b false, redirect stderr to stdout\n  static Status RunShellCommand(llvm::StringRef shell, const Args &args,\n                                const FileSpec &working_dir, int *status_ptr,\n                                int *signo_ptr, std::string *command_output,\n                                const Timeout<std::micro> &timeout,\n                                bool run_in_shell = true,\n                                bool hide_stderr = false);\n\n  static bool OpenFileInExternalEditor(const FileSpec &file_spec,\n                                       uint32_t line_no);\n\n  static Environment GetEnvironment();\n\n  static std::unique_ptr<Connection>\n  CreateDefaultConnection(llvm::StringRef url);\n\nprotected:\n  static uint32_t FindProcessesImpl(const ProcessInstanceInfoMatch &match_info,\n                                    ProcessInstanceInfoList &proc_infos);\n};\n\n} // namespace lldb_private\n\nnamespace llvm {\ntemplate <> struct format_provider<lldb_private::WaitStatus> {\n  /// Options = \"\" gives a human readable description of the status Options =\n  /// \"g\" gives a gdb-remote protocol status (e.g., X09)\n  static void format(const lldb_private::WaitStatus &WS, raw_ostream &OS,\n                     llvm::StringRef Options);\n};\n} // namespace llvm\n\n#endif // LLDB_HOST_HOST_H\n"}, "5": {"id": 5, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/CompilerDecl.h", "content": "//===-- CompilerDecl.h ------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_SYMBOL_COMPILERDECL_H\n#define LLDB_SYMBOL_COMPILERDECL_H\n\n#include \"lldb/Symbol/CompilerType.h\"\n#include \"lldb/Utility/ConstString.h\"\n#include \"lldb/lldb-private.h\"\n\nnamespace lldb_private {\n\n/// Represents a generic declaration such as a function declaration.\n///\n/// This class serves as an abstraction for a declaration inside one of the\n/// TypeSystems implemented by the language plugins. It does not have any actual\n/// logic in it but only stores an opaque pointer and a pointer to the\n/// TypeSystem that gives meaning to this opaque pointer. All methods of this\n/// class should call their respective method in the TypeSystem interface and\n/// pass the opaque pointer along.\n///\n/// \\see lldb_private::TypeSystem\nclass CompilerDecl {\npublic:\n  // Constructors and Destructors\n  CompilerDecl() = default;\n\n  /// Creates a CompilerDecl with the given TypeSystem and opaque pointer.\n  ///\n  /// This constructor should only be called from the respective TypeSystem\n  /// implementation.\n  CompilerDecl(TypeSystem *type_system, void *decl)\n      : m_type_system(type_system), m_opaque_decl(decl) {}\n\n  // Tests\n\n  explicit operator bool() const { return IsValid(); }\n\n  bool operator<(const CompilerDecl &rhs) const {\n    if (m_type_system == rhs.m_type_system)\n      return m_opaque_decl < rhs.m_opaque_decl;\n    return m_type_system < rhs.m_type_system;\n  }\n\n  bool IsValid() const {\n    return m_type_system != nullptr && m_opaque_decl != nullptr;\n  }\n\n  // Accessors\n\n  TypeSystem *GetTypeSystem() const { return m_type_system; }\n\n  void *GetOpaqueDecl() const { return m_opaque_decl; }\n\n  void SetDecl(TypeSystem *type_system, void *decl) {\n    m_type_system = type_system;\n    m_opaque_decl = decl;\n  }\n\n  void Clear() {\n    m_type_system = nullptr;\n    m_opaque_decl = nullptr;\n  }\n\n  ConstString GetName() const;\n\n  ConstString GetMangledName() const;\n\n  CompilerDeclContext GetDeclContext() const;\n\n  // If this decl represents a function, return the return type\n  CompilerType GetFunctionReturnType() const;\n\n  // If this decl represents a function, return the number of arguments for the\n  // function\n  size_t GetNumFunctionArguments() const;\n\n  // If this decl represents a function, return the argument type given a zero\n  // based argument index\n  CompilerType GetFunctionArgumentType(size_t arg_idx) const;\n\nprivate:\n  TypeSystem *m_type_system = nullptr;\n  void *m_opaque_decl = nullptr;\n};\n\nbool operator==(const CompilerDecl &lhs, const CompilerDecl &rhs);\nbool operator!=(const CompilerDecl &lhs, const CompilerDecl &rhs);\n\n} // namespace lldb_private\n\n#endif // LLDB_SYMBOL_COMPILERDECL_H\n"}, "6": {"id": 6, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/CompilerDeclContext.h", "content": "//===-- CompilerDeclContext.h -----------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_SYMBOL_COMPILERDECLCONTEXT_H\n#define LLDB_SYMBOL_COMPILERDECLCONTEXT_H\n\n#include <vector>\n\n#include \"lldb/Utility/ConstString.h\"\n#include \"lldb/lldb-private.h\"\n\nnamespace lldb_private {\n\n/// Represents a generic declaration context in a program. A declaration context\n/// is data structure that contains declarations (e.g. namespaces).\n///\n/// This class serves as an abstraction for a declaration context inside one of\n/// the TypeSystems implemented by the language plugins. It does not have any\n/// actual logic in it but only stores an opaque pointer and a pointer to the\n/// TypeSystem that gives meaning to this opaque pointer. All methods of this\n/// class should call their respective method in the TypeSystem interface and\n/// pass the opaque pointer along.\n///\n/// \\see lldb_private::TypeSystem\nclass CompilerDeclContext {\npublic:\n  /// Constructs an invalid CompilerDeclContext.\n  CompilerDeclContext() = default;\n\n  /// Constructs a CompilerDeclContext with the given opaque decl context\n  /// and its respective TypeSystem instance.\n  ///\n  /// This constructor should only be called from the respective TypeSystem\n  /// implementation.\n  ///\n  /// \\see lldb_private::TypeSystemClang::CreateDeclContext(clang::DeclContext*)\n  CompilerDeclContext(TypeSystem *type_system, void *decl_ctx)\n      : m_type_system(type_system), m_opaque_decl_ctx(decl_ctx) {}\n\n  // Tests\n\n  explicit operator bool() const { return IsValid(); }\n\n  bool operator<(const CompilerDeclContext &rhs) const {\n    if (m_type_system == rhs.m_type_system)\n      return m_opaque_decl_ctx < rhs.m_opaque_decl_ctx;\n    return m_type_system < rhs.m_type_system;\n  }\n\n  bool IsValid() const {\n    return m_type_system != nullptr && m_opaque_decl_ctx != nullptr;\n  }\n\n  std::vector<CompilerDecl> FindDeclByName(ConstString name,\n                                           const bool ignore_using_decls);\n\n  /// Checks if this decl context represents a method of a class.\n  ///\n  /// \\param[out] language_ptr\n  ///     If non NULL and \\b true is returned from this function,\n  ///     this will indicate if the language that respresents the method.\n  ///\n  /// \\param[out] is_instance_method_ptr\n  ///     If non NULL and \\b true is returned from this function,\n  ///     this will indicate if the method is an instance function (true)\n  ///     or a class method (false indicating the function is static, or\n  ///     doesn't require an instance of the class to be called).\n  ///\n  /// \\param[out] language_object_name_ptr\n  ///     If non NULL and \\b true is returned from this function,\n  ///     this will indicate if implicit object name for the language\n  ///     like \"this\" for C++, and \"self\" for Objective C.\n  ///\n  /// \\return\n  ///     Returns true if this is a decl context that represents a method\n  ///     in a struct, union or class.\n  bool IsClassMethod(lldb::LanguageType *language_ptr,\n                     bool *is_instance_method_ptr,\n                     ConstString *language_object_name_ptr);\n\n  /// Check if the given other decl context is contained in the lookup\n  /// of this decl context (for example because the other context is a nested\n  /// inline namespace).\n  ///\n  /// @param[in] other\n  ///     The other decl context for which we should check if it is contained\n  ///     in the lookoup of this context.\n  ///\n  /// @return\n  ///     Returns true iff the other decl context is contained in the lookup\n  ///     of this decl context.\n  bool IsContainedInLookup(CompilerDeclContext other) const;\n\n  // Accessors\n\n  TypeSystem *GetTypeSystem() const { return m_type_system; }\n\n  void *GetOpaqueDeclContext() const { return m_opaque_decl_ctx; }\n\n  void SetDeclContext(TypeSystem *type_system, void *decl_ctx) {\n    m_type_system = type_system;\n    m_opaque_decl_ctx = decl_ctx;\n  }\n\n  void Clear() {\n    m_type_system = nullptr;\n    m_opaque_decl_ctx = nullptr;\n  }\n\n  ConstString GetName() const;\n\n  ConstString GetScopeQualifiedName() const;\n\nprivate:\n  TypeSystem *m_type_system = nullptr;\n  void *m_opaque_decl_ctx = nullptr;\n};\n\nbool operator==(const CompilerDeclContext &lhs, const CompilerDeclContext &rhs);\nbool operator!=(const CompilerDeclContext &lhs, const CompilerDeclContext &rhs);\n\n} // namespace lldb_private\n\n#endif // LLDB_SYMBOL_COMPILERDECLCONTEXT_H\n"}, "7": {"id": 7, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/CompilerType.h", "content": "//===-- CompilerType.h ------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_SYMBOL_COMPILERTYPE_H\n#define LLDB_SYMBOL_COMPILERTYPE_H\n\n#include <functional>\n#include <string>\n#include <vector>\n\n#include \"lldb/lldb-private.h\"\n#include \"llvm/ADT/APSInt.h\"\n\nnamespace lldb_private {\n\nclass DataExtractor;\n\n/// Generic representation of a type in a programming language.\n///\n/// This class serves as an abstraction for a type inside one of the TypeSystems\n/// implemented by the language plugins. It does not have any actual logic in it\n/// but only stores an opaque pointer and a pointer to the TypeSystem that\n/// gives meaning to this opaque pointer. All methods of this class should call\n/// their respective method in the TypeSystem interface and pass the opaque\n/// pointer along.\n///\n/// \\see lldb_private::TypeSystem\nclass CompilerType {\npublic:\n  /// Creates a CompilerType with the given TypeSystem and opaque compiler type.\n  ///\n  /// This constructor should only be called from the respective TypeSystem\n  /// implementation.\n  ///\n  /// \\see lldb_private::TypeSystemClang::GetType(clang::QualType)\n  CompilerType(TypeSystem *type_system, lldb::opaque_compiler_type_t type)\n      : m_type(type), m_type_system(type_system) {\n    assert(Verify() && \"verification failed\");\n  }\n\n  CompilerType(const CompilerType &rhs)\n      : m_type(rhs.m_type), m_type_system(rhs.m_type_system) {}\n\n  CompilerType() = default;\n\n  /// Operators.\n  /// \\{\n  const CompilerType &operator=(const CompilerType &rhs) {\n    m_type = rhs.m_type;\n    m_type_system = rhs.m_type_system;\n    return *this;\n  }\n\n  bool operator<(const CompilerType &rhs) const {\n    if (m_type_system == rhs.m_type_system)\n      return m_type < rhs.m_type;\n    return m_type_system < rhs.m_type_system;\n  }\n  /// \\}\n\n  /// Tests.\n  /// \\{\n  explicit operator bool() const {\n    return m_type != nullptr && m_type_system != nullptr;\n  }\n\n  bool IsValid() const { return m_type != nullptr && m_type_system != nullptr; }\n\n  bool IsArrayType(CompilerType *element_type = nullptr,\n                   uint64_t *size = nullptr,\n                   bool *is_incomplete = nullptr) const;\n\n  bool IsVectorType(CompilerType *element_type = nullptr,\n                    uint64_t *size = nullptr) const;\n\n  bool IsArrayOfScalarType() const;\n\n  bool IsAggregateType() const;\n\n  bool IsAnonymousType() const;\n\n  bool IsScopedEnumerationType() const;\n\n  bool IsBeingDefined() const;\n\n  bool IsCharType() const;\n\n  bool IsCompleteType() const;\n\n  bool IsConst() const;\n\n  bool IsCStringType(uint32_t &length) const;\n\n  bool IsDefined() const;\n\n  bool IsFloatingPointType(uint32_t &count, bool &is_complex) const;\n\n  bool IsFunctionType() const;\n\n  uint32_t IsHomogeneousAggregate(CompilerType *base_type_ptr) const;\n\n  size_t GetNumberOfFunctionArguments() const;\n\n  CompilerType GetFunctionArgumentAtIndex(const size_t index) const;\n\n  bool IsVariadicFunctionType() const;\n\n  bool IsFunctionPointerType() const;\n\n  bool\n  IsBlockPointerType(CompilerType *function_pointer_type_ptr = nullptr) const;\n\n  bool IsIntegerType(bool &is_signed) const;\n\n  bool IsEnumerationType(bool &is_signed) const;\n\n  bool IsIntegerOrEnumerationType(bool &is_signed) const;\n\n  bool IsPolymorphicClass() const;\n\n  /// \\param target_type    Can pass nullptr.\n  bool IsPossibleDynamicType(CompilerType *target_type, bool check_cplusplus,\n                             bool check_objc) const;\n\n  bool IsPointerToScalarType() const;\n\n  bool IsRuntimeGeneratedType() const;\n\n  bool IsPointerType(CompilerType *pointee_type = nullptr) const;\n\n  bool IsPointerOrReferenceType(CompilerType *pointee_type = nullptr) const;\n\n  bool IsReferenceType(CompilerType *pointee_type = nullptr,\n                       bool *is_rvalue = nullptr) const;\n\n  bool ShouldTreatScalarValueAsAddress() const;\n\n  bool IsScalarType() const;\n\n  bool IsTypedefType() const;\n\n  bool IsVoidType() const;\n  /// \\}\n\n  /// Type Completion.\n  /// \\{\n  bool GetCompleteType() const;\n  /// \\}\n\n  /// AST related queries.\n  /// \\{\n  size_t GetPointerByteSize() const;\n  /// \\}\n\n  /// Accessors.\n  /// \\{\n  TypeSystem *GetTypeSystem() const { return m_type_system; }\n\n  ConstString GetTypeName() const;\n\n  ConstString GetDisplayTypeName() const;\n\n  uint32_t\n  GetTypeInfo(CompilerType *pointee_or_element_compiler_type = nullptr) const;\n\n  lldb::LanguageType GetMinimumLanguage();\n\n  lldb::opaque_compiler_type_t GetOpaqueQualType() const { return m_type; }\n\n  lldb::TypeClass GetTypeClass() const;\n\n  void SetCompilerType(TypeSystem *type_system,\n                       lldb::opaque_compiler_type_t type);\n\n  unsigned GetTypeQualifiers() const;\n  /// \\}\n\n  /// Creating related types.\n  /// \\{\n  CompilerType GetArrayElementType(ExecutionContextScope *exe_scope) const;\n\n  CompilerType GetArrayType(uint64_t size) const;\n\n  CompilerType GetCanonicalType() const;\n\n  CompilerType GetFullyUnqualifiedType() const;\n\n  CompilerType GetEnumerationIntegerType() const;\n\n  /// Returns -1 if this isn't a function of if the function doesn't\n  /// have a prototype Returns a value >= 0 if there is a prototype.\n  int GetFunctionArgumentCount() const;\n\n  CompilerType GetFunctionArgumentTypeAtIndex(size_t idx) const;\n\n  CompilerType GetFunctionReturnType() const;\n\n  size_t GetNumMemberFunctions() const;\n\n  TypeMemberFunctionImpl GetMemberFunctionAtIndex(size_t idx);\n\n  /// If this type is a reference to a type (L value or R value reference),\n  /// return a new type with the reference removed, else return the current type\n  /// itself.\n  CompilerType GetNonReferenceType() const;\n\n  /// If this type is a pointer type, return the type that the pointer points\n  /// to, else return an invalid type.\n  CompilerType GetPointeeType() const;\n\n  /// Return a new CompilerType that is a pointer to this type\n  CompilerType GetPointerType() const;\n\n  /// Return a new CompilerType that is a L value reference to this type if this\n  /// type is valid and the type system supports L value references, else return\n  /// an invalid type.\n  CompilerType GetLValueReferenceType() const;\n\n  /// Return a new CompilerType that is a R value reference to this type if this\n  /// type is valid and the type system supports R value references, else return\n  /// an invalid type.\n  CompilerType GetRValueReferenceType() const;\n\n  /// Return a new CompilerType adds a const modifier to this type if this type\n  /// is valid and the type system supports const modifiers, else return an\n  /// invalid type.\n  CompilerType AddConstModifier() const;\n\n  /// Return a new CompilerType adds a volatile modifier to this type if this\n  /// type is valid and the type system supports volatile modifiers, else return\n  /// an invalid type.\n  CompilerType AddVolatileModifier() const;\n\n  /// Return a new CompilerType that is the atomic type of this type. If this\n  /// type is not valid or the type system doesn't support atomic types, this\n  /// returns an invalid type.\n  CompilerType GetAtomicType() const;\n\n  /// Return a new CompilerType adds a restrict modifier to this type if this\n  /// type is valid and the type system supports restrict modifiers, else return\n  /// an invalid type.\n  CompilerType AddRestrictModifier() const;\n\n  /// Create a typedef to this type using \"name\" as the name of the typedef this\n  /// type is valid and the type system supports typedefs, else return an\n  /// invalid type.\n  /// \\param payload   The typesystem-specific \\p lldb::Type payload.\n  CompilerType CreateTypedef(const char *name,\n                             const CompilerDeclContext &decl_ctx,\n                             uint32_t payload) const;\n\n  /// If the current object represents a typedef type, get the underlying type\n  CompilerType GetTypedefedType() const;\n\n  /// Create related types using the current type's AST\n  CompilerType GetBasicTypeFromAST(lldb::BasicType basic_type) const;\n  /// \\}\n\n  /// Exploring the type.\n  /// \\{\n  struct IntegralTemplateArgument;\n\n  /// Return the size of the type in bytes.\n  llvm::Optional<uint64_t> GetByteSize(ExecutionContextScope *exe_scope) const;\n  /// Return the size of the type in bits.\n  llvm::Optional<uint64_t> GetBitSize(ExecutionContextScope *exe_scope) const;\n\n  lldb::Encoding GetEncoding(uint64_t &count) const;\n\n  lldb::Format GetFormat() const;\n\n  llvm::Optional<size_t>\n  GetTypeBitAlign(ExecutionContextScope *exe_scope) const;\n\n  uint32_t GetNumChildren(bool omit_empty_base_classes,\n                          const ExecutionContext *exe_ctx) const;\n\n  lldb::BasicType GetBasicTypeEnumeration() const;\n\n  static lldb::BasicType GetBasicTypeEnumeration(ConstString name);\n\n  /// If this type is an enumeration, iterate through all of its enumerators\n  /// using a callback. If the callback returns true, keep iterating, else abort\n  /// the iteration.\n  void ForEachEnumerator(\n      std::function<bool(const CompilerType &integer_type, ConstString name,\n                         const llvm::APSInt &value)> const &callback) const;\n\n  uint32_t GetNumFields() const;\n\n  CompilerType GetFieldAtIndex(size_t idx, std::string &name,\n                               uint64_t *bit_offset_ptr,\n                               uint32_t *bitfield_bit_size_ptr,\n                               bool *is_bitfield_ptr) const;\n\n  uint32_t GetNumDirectBaseClasses() const;\n\n  uint32_t GetNumVirtualBaseClasses() const;\n\n  CompilerType GetDirectBaseClassAtIndex(size_t idx,\n                                         uint32_t *bit_offset_ptr) const;\n\n  CompilerType GetVirtualBaseClassAtIndex(size_t idx,\n                                          uint32_t *bit_offset_ptr) const;\n\n  uint32_t GetIndexOfFieldWithName(const char *name,\n                                   CompilerType *field_compiler_type = nullptr,\n                                   uint64_t *bit_offset_ptr = nullptr,\n                                   uint32_t *bitfield_bit_size_ptr = nullptr,\n                                   bool *is_bitfield_ptr = nullptr) const;\n\n  CompilerType GetChildCompilerTypeAtIndex(\n      ExecutionContext *exe_ctx, size_t idx, bool transparent_pointers,\n      bool omit_empty_base_classes, bool ignore_array_bounds,\n      std::string &child_name, uint32_t &child_byte_size,\n      int32_t &child_byte_offset, uint32_t &child_bitfield_bit_size,\n      uint32_t &child_bitfield_bit_offset, bool &child_is_base_class,\n      bool &child_is_deref_of_parent, ValueObject *valobj,\n      uint64_t &language_flags) const;\n\n  /// Lookup a child given a name. This function will match base class names and\n  /// member member names in \"clang_type\" only, not descendants.\n  uint32_t GetIndexOfChildWithName(const char *name,\n                                   bool omit_empty_base_classes) const;\n\n  /// Lookup a child member given a name. This function will match member names\n  /// only and will descend into \"clang_type\" children in search for the first\n  /// member in this class, or any base class that matches \"name\".\n  /// TODO: Return all matches for a given name by returning a\n  /// vector<vector<uint32_t>>\n  /// so we catch all names that match a given child name, not just the first.\n  size_t\n  GetIndexOfChildMemberWithName(const char *name, bool omit_empty_base_classes,\n                                std::vector<uint32_t> &child_indexes) const;\n\n  size_t GetNumTemplateArguments() const;\n\n  lldb::TemplateArgumentKind GetTemplateArgumentKind(size_t idx) const;\n  CompilerType GetTypeTemplateArgument(size_t idx) const;\n\n  /// Returns the value of the template argument and its type.\n  llvm::Optional<IntegralTemplateArgument>\n  GetIntegralTemplateArgument(size_t idx) const;\n\n  CompilerType GetTypeForFormatters() const;\n\n  LazyBool ShouldPrintAsOneLiner(ValueObject *valobj) const;\n\n  bool IsMeaninglessWithoutDynamicResolution() const;\n  /// \\}\n\n  /// Dumping types.\n  /// \\{\n#ifndef NDEBUG\n  /// Convenience LLVM-style dump method for use in the debugger only.\n  /// Don't call this function from actual code.\n  LLVM_DUMP_METHOD void dump() const;\n#endif\n\n  void DumpValue(ExecutionContext *exe_ctx, Stream *s, lldb::Format format,\n                 const DataExtractor &data, lldb::offset_t data_offset,\n                 size_t data_byte_size, uint32_t bitfield_bit_size,\n                 uint32_t bitfield_bit_offset, bool show_types,\n                 bool show_summary, bool verbose, uint32_t depth);\n\n  bool DumpTypeValue(Stream *s, lldb::Format format, const DataExtractor &data,\n                     lldb::offset_t data_offset, size_t data_byte_size,\n                     uint32_t bitfield_bit_size, uint32_t bitfield_bit_offset,\n                     ExecutionContextScope *exe_scope);\n\n  void DumpSummary(ExecutionContext *exe_ctx, Stream *s,\n                   const DataExtractor &data, lldb::offset_t data_offset,\n                   size_t data_byte_size);\n\n  /// Dump to stdout.\n  void DumpTypeDescription(lldb::DescriptionLevel level =\n                           lldb::eDescriptionLevelFull) const;\n\n  /// Print a description of the type to a stream. The exact implementation\n  /// varies, but the expectation is that eDescriptionLevelFull returns a\n  /// source-like representation of the type, whereas eDescriptionLevelVerbose\n  /// does a dump of the underlying AST if applicable.\n  void DumpTypeDescription(Stream *s, lldb::DescriptionLevel level =\n                                          lldb::eDescriptionLevelFull) const;\n  /// \\}\n\n  bool GetValueAsScalar(const DataExtractor &data, lldb::offset_t data_offset,\n                        size_t data_byte_size, Scalar &value,\n                        ExecutionContextScope *exe_scope) const;\n  void Clear() {\n    m_type = nullptr;\n    m_type_system = nullptr;\n  }\n\nprivate:\n#ifndef NDEBUG\n  /// If the type is valid, ask the TypeSystem to verify the integrity\n  /// of the type to catch CompilerTypes that mix and match invalid\n  /// TypeSystem/Opaque type pairs.\n  bool Verify() const;\n#endif\n\n  lldb::opaque_compiler_type_t m_type = nullptr;\n  TypeSystem *m_type_system = nullptr;\n};\n\nbool operator==(const CompilerType &lhs, const CompilerType &rhs);\nbool operator!=(const CompilerType &lhs, const CompilerType &rhs);\n\nstruct CompilerType::IntegralTemplateArgument {\n  llvm::APSInt value;\n  CompilerType type;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_SYMBOL_COMPILERTYPE_H\n"}, "8": {"id": 8, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/Declaration.h", "content": "//===-- Declaration.h -------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_SYMBOL_DECLARATION_H\n#define LLDB_SYMBOL_DECLARATION_H\n\n#include \"lldb/Utility/FileSpec.h\"\n#include \"lldb/lldb-private.h\"\n\nnamespace lldb_private {\n\n/// \\class Declaration Declaration.h \"lldb/Symbol/Declaration.h\"\n/// A class that describes the declaration location of a\n///        lldb object.\n///\n/// The declarations include the file specification, line number, and the\n/// column info and can help track where functions, blocks, inlined functions,\n/// types, variables, any many other debug core objects were declared.\nclass Declaration {\npublic:\n  /// Default constructor.\n  Declaration()\n      : m_file(), m_line(0)\n#ifdef LLDB_ENABLE_DECLARATION_COLUMNS\n        ,\n        m_column(0)\n#endif\n  {\n  }\n\n  /// Construct with file specification, and optional line and column.\n  ///\n  /// \\param[in] file_spec\n  ///     The file specification that describes where this was\n  ///     declared.\n  ///\n  /// \\param[in] line\n  ///     The line number that describes where this was declared. Set\n  ///     to zero if there is no line number information.\n  ///\n  /// \\param[in] column\n  ///     The column number that describes where this was declared.\n  ///     Set to zero if there is no column number information.\n  Declaration(const FileSpec &file_spec, uint32_t line = 0, uint32_t column = 0)\n      : m_file(file_spec), m_line(line)\n#ifdef LLDB_ENABLE_DECLARATION_COLUMNS\n        ,\n        m_column(column)\n#endif\n  {\n  }\n\n  /// Construct with a pointer to another Declaration object.\n  Declaration(const Declaration *decl_ptr)\n      : m_file(), m_line(0)\n#ifdef LLDB_ENABLE_DECLARATION_COLUMNS\n        ,\n        m_column(0)\n#endif\n  {\n    if (decl_ptr)\n      *this = *decl_ptr;\n  }\n\n  /// Clear the object's state.\n  ///\n  /// Sets the file specification to be empty, and the line and column to\n  /// zero.\n  void Clear() {\n    m_file.Clear();\n    m_line = 0;\n#ifdef LLDB_ENABLE_DECLARATION_COLUMNS\n    m_column = 0;\n#endif\n  }\n\n  /// Compare two declaration objects.\n  ///\n  /// Compares the two file specifications from \\a lhs and \\a rhs. If the file\n  /// specifications are equal, then continue to compare the line number and\n  /// column numbers respectively.\n  ///\n  /// \\param[in] lhs\n  ///     The Left Hand Side const Declaration object reference.\n  ///\n  /// \\param[in] rhs\n  ///     The Right Hand Side const Declaration object reference.\n  ///\n  /// \\return\n  ///     -1 if lhs < rhs\n  ///     0 if lhs == rhs\n  ///     1 if lhs > rhs\n  static int Compare(const Declaration &lhs, const Declaration &rhs);\n\n  /// Checks if this object has the same file and line as another declaration\n  /// object.\n  ///\n  /// \\param[in] declaration\n  ///     The const Declaration object to compare with.\n  ///\n  /// \\return\n  ///     Returns \\b true if \\b declaration is at the same file and\n  ///     line, \\b false otherwise.\n  bool FileAndLineEqual(const Declaration &declaration) const;\n\n  /// Dump a description of this object to a Stream.\n  ///\n  /// Dump a description of the contents of this object to the supplied stream\n  /// \\a s.\n  ///\n  /// \\param[in] s\n  ///     The stream to which to dump the object description.\n  void Dump(Stream *s, bool show_fullpaths) const;\n\n  bool DumpStopContext(Stream *s, bool show_fullpaths) const;\n  /// Get accessor for the declaration column number.\n  ///\n  /// \\return\n  ///     Non-zero indicates a valid column number, zero indicates no\n  ///     column information is available.\n  uint32_t GetColumn() const {\n#ifdef LLDB_ENABLE_DECLARATION_COLUMNS\n    return m_column;\n#else\n    return 0;\n#endif\n  }\n\n  /// Get accessor for file specification.\n  ///\n  /// \\return\n  ///     A reference to the file specification object.\n  FileSpec &GetFile() { return m_file; }\n\n  /// Get const accessor for file specification.\n  ///\n  /// \\return\n  ///     A const reference to the file specification object.\n  const FileSpec &GetFile() const { return m_file; }\n\n  /// Get accessor for the declaration line number.\n  ///\n  /// \\return\n  ///     Non-zero indicates a valid line number, zero indicates no\n  ///     line information is available.\n  uint32_t GetLine() const { return m_line; }\n\n  bool IsValid() const { return m_file && m_line != 0; }\n\n  /// Get the memory cost of this object.\n  ///\n  /// \\return\n  ///     The number of bytes that this object occupies in memory.\n  ///     The returned value does not include the bytes for any\n  ///     shared string values.\n  ///\n  /// \\see ConstString::StaticMemorySize ()\n  size_t MemorySize() const;\n\n  /// Set accessor for the declaration column number.\n  ///\n  /// \\param[in] column\n  ///     Non-zero indicates a valid column number, zero indicates no\n  ///     column information is available.\n  void SetColumn(uint32_t column) {\n#ifdef LLDB_ENABLE_DECLARATION_COLUMNS\n    m_column = col;\n#endif\n  }\n\n  /// Set accessor for the declaration file specification.\n  ///\n  /// \\param[in] file_spec\n  ///     The new declaration file specification.\n  void SetFile(const FileSpec &file_spec) { m_file = file_spec; }\n\n  /// Set accessor for the declaration line number.\n  ///\n  /// \\param[in] line\n  ///     Non-zero indicates a valid line number, zero indicates no\n  ///     line information is available.\n  void SetLine(uint32_t line) { m_line = line; }\n\nprotected:\n  /// Member variables.\n  FileSpec m_file; ///< The file specification that points to the\n                   ///< source file where the declaration occurred.\n  uint32_t m_line; ///< Non-zero values indicates a valid line number,\n                   ///< zero indicates no line number information is available.\n#ifdef LLDB_ENABLE_DECLARATION_COLUMNS\n  uint32_t m_column; ///< Non-zero values indicates a valid column number,\n                     ///< zero indicates no column information is available.\n#endif\n};\n\nbool operator==(const Declaration &lhs, const Declaration &rhs);\n\n} // namespace lldb_private\n\n#endif // LLDB_SYMBOL_DECLARATION_H\n"}, "9": {"id": 9, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/LineEntry.h", "content": "//===-- LineEntry.h ---------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_SYMBOL_LINEENTRY_H\n#define LLDB_SYMBOL_LINEENTRY_H\n\n#include \"lldb/Core/AddressRange.h\"\n#include \"lldb/Utility/FileSpec.h\"\n#include \"lldb/lldb-private.h\"\n\nnamespace lldb_private {\n\n/// \\class LineEntry LineEntry.h \"lldb/Symbol/LineEntry.h\"\n/// A line table entry class.\nstruct LineEntry {\n  /// Default constructor.\n  ///\n  /// Initialize all member variables to invalid values.\n  LineEntry();\n\n  LineEntry(const lldb::SectionSP &section_sp, lldb::addr_t section_offset,\n            lldb::addr_t byte_size, const FileSpec &file, uint32_t _line,\n            uint16_t _column, bool _is_start_of_statement,\n            bool _is_start_of_basic_block, bool _is_prologue_end,\n            bool _is_epilogue_begin, bool _is_terminal_entry);\n\n  /// Clear the object's state.\n  ///\n  /// Clears all member variables to invalid values.\n  void Clear();\n\n  /// Dump a description of this object to a Stream.\n  ///\n  /// Dump a description of the contents of this object to the supplied stream\n  /// \\a s.\n  ///\n  /// \\param[in] s\n  ///     The stream to which to dump the object description.\n  ///\n  /// \\param[in] show_file\n  ///     If \\b true, display the filename with the line entry which\n  ///     requires that the compile unit object \\a comp_unit be a\n  ///     valid pointer.\n  ///\n  /// \\param[in] style\n  ///     The display style for the section offset address.\n  ///\n  /// \\return\n  ///     Returns \\b true if the address was able to be displayed\n  ///     using \\a style. File and load addresses may be unresolved\n  ///     and it may not be possible to display a valid address value.\n  ///     Returns \\b false if the address was not able to be properly\n  ///     dumped.\n  ///\n  /// \\see Address::DumpStyle\n  bool Dump(Stream *s, Target *target, bool show_file, Address::DumpStyle style,\n            Address::DumpStyle fallback_style, bool show_range) const;\n\n  bool GetDescription(Stream *s, lldb::DescriptionLevel level, CompileUnit *cu,\n                      Target *target, bool show_address_only) const;\n\n  /// Dumps information specific to a process that stops at this line entry to\n  /// the supplied stream \\a s.\n  ///\n  /// \\param[in] s\n  ///     The stream to which to dump the object description.\n  ///\n  /// \\return\n  ///     Returns \\b true if the file and line were properly dumped,\n  ///     \\b false otherwise.\n  bool DumpStopContext(Stream *s, bool show_fullpaths) const;\n\n  /// Check if a line entry object is valid.\n  ///\n  /// \\return\n  ///     Returns \\b true if the line entry contains a valid section\n  ///     offset address, file index, and line number, \\b false\n  ///     otherwise.\n  bool IsValid() const;\n\n  /// Compare two LineEntry objects.\n  ///\n  /// \\param[in] lhs\n  ///     The Left Hand Side const LineEntry object reference.\n  ///\n  /// \\param[in] rhs\n  ///     The Right Hand Side const LineEntry object reference.\n  ///\n  /// \\return\n  ///     -1 if lhs < rhs\n  ///     0 if lhs == rhs\n  ///     1 if lhs > rhs\n  static int Compare(const LineEntry &lhs, const LineEntry &rhs);\n\n  /// Give the range for this LineEntry + any additional LineEntries for this\n  /// same source line that are contiguous.\n  ///\n  /// A compiler may emit multiple line entries for a single source line,\n  /// e.g. to indicate subexpressions at different columns.  This method will\n  /// get the AddressRange for all of the LineEntries for this source line\n  /// that are contiguous.\n  //\n  /// Line entries with a line number of 0 are treated specially - these are\n  /// compiler-generated line table entries that the user did not write in\n  /// their source code, and we want to skip past in the debugger. If this\n  /// LineEntry is for line 32, and the following LineEntry is for line 0, we\n  /// will extend the range to include the AddressRange of the line 0\n  /// LineEntry (and it will include the range of the following LineEntries\n  /// that match either 32 or 0.)\n  ///\n  /// When \\b include_inlined_functions is \\b true inlined functions with\n  /// a call site at this LineEntry will also be included in the complete\n  /// range.\n  ///\n  /// If the initial LineEntry this method is called on is a line #0, only the\n  /// range of continuous LineEntries with line #0 will be included in the\n  /// complete range.\n  ///\n  /// @param[in] include_inlined_functions\n  ///     Whether to include inlined functions at the same line or not.\n  ///\n  /// \\return\n  ///     The contiguous AddressRange for this source line.\n  AddressRange\n  GetSameLineContiguousAddressRange(bool include_inlined_functions) const;\n\n  /// Apply file mappings from target.source-map to the LineEntry's file.\n  ///\n  /// \\param[in] target_sp\n  ///     Shared pointer to the target this LineEntry belongs to.\n  void ApplyFileMappings(lldb::TargetSP target_sp);\n\n  // Member variables.\n  AddressRange range; ///< The section offset address range for this line entry.\n  FileSpec file; ///< The source file, possibly mapped by the target.source-map\n                 ///setting\n  FileSpec original_file; ///< The original source file, from debug info.\n  uint32_t line; ///< The source line number, or zero if there is no line number\n                 ///information.\n  uint16_t column; ///< The column number of the source line, or zero if there\n                   ///is no column information.\n  uint16_t is_start_of_statement : 1, ///< Indicates this entry is the beginning\n                                      ///of a statement.\n      is_start_of_basic_block : 1, ///< Indicates this entry is the beginning of\n                                   ///a basic block.\n      is_prologue_end : 1,   ///< Indicates this entry is one (of possibly many)\n                             ///where execution should be suspended for an entry\n                             ///breakpoint of a function.\n      is_epilogue_begin : 1, ///< Indicates this entry is one (of possibly many)\n                             ///where execution should be suspended for an exit\n                             ///breakpoint of a function.\n      is_terminal_entry : 1; ///< Indicates this entry is that of the first byte\n                             ///after the end of a sequence of target machine\n                             ///instructions.\n};\n\n/// Less than operator.\n///\n/// \\param[in] lhs\n///     The Left Hand Side const LineEntry object reference.\n///\n/// \\param[in] rhs\n///     The Right Hand Side const LineEntry object reference.\n///\n/// \\return\n///     Returns \\b true if lhs < rhs, false otherwise.\nbool operator<(const LineEntry &lhs, const LineEntry &rhs);\n\n} // namespace lldb_private\n\n#endif // LLDB_SYMBOL_LINEENTRY_H\n"}, "10": {"id": 10, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/SymbolContext.h", "content": "//===-- SymbolContext.h -----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_SYMBOL_SYMBOLCONTEXT_H\n#define LLDB_SYMBOL_SYMBOLCONTEXT_H\n\n#include <memory>\n#include <string>\n#include <vector>\n\n#include \"lldb/Core/Address.h\"\n#include \"lldb/Core/Mangled.h\"\n#include \"lldb/Symbol/LineEntry.h\"\n#include \"lldb/Utility/Iterable.h\"\n#include \"lldb/lldb-private.h\"\n\nnamespace lldb_private {\n\nclass SymbolContextScope;\n\n/// \\class SymbolContext SymbolContext.h \"lldb/Symbol/SymbolContext.h\" Defines\n/// a symbol context baton that can be handed other debug core functions.\n///\n/// Many debugger functions require a context when doing lookups. This class\n/// provides a common structure that can be used as the result of a query that\n/// can contain a single result. Examples of such queries include\n///     \\li Looking up a load address.\nclass SymbolContext {\npublic:\n  /// Default constructor.\n  ///\n  /// Initialize all pointer members to nullptr and all struct members to\n  /// their default state.\n  SymbolContext();\n\n  /// Construct with an object that knows how to reconstruct its symbol\n  /// context.\n  ///\n  /// \\param[in] sc_scope\n  ///     A symbol context scope object that knows how to reconstruct\n  ///     it's context.\n  explicit SymbolContext(SymbolContextScope *sc_scope);\n\n  /// Construct with module, and optional compile unit, function, block, line\n  /// table, line entry and symbol.\n  ///\n  /// Initialize all pointer to the specified values.\n  ///\n  /// \\param[in] module_sp\n  ///     A Module pointer to the module for this context.\n  ///\n  /// \\param[in] comp_unit\n  ///     A CompileUnit pointer to the compile unit for this context.\n  ///\n  /// \\param[in] function\n  ///     A Function pointer to the function for this context.\n  ///\n  /// \\param[in] block\n  ///     A Block pointer to the deepest block for this context.\n  ///\n  /// \\param[in] line_entry\n  ///     A LineEntry pointer to the line entry for this context.\n  ///\n  /// \\param[in] symbol\n  ///     A Symbol pointer to the symbol for this context.\n  explicit SymbolContext(const lldb::TargetSP &target_sp,\n                         const lldb::ModuleSP &module_sp,\n                         CompileUnit *comp_unit = nullptr,\n                         Function *function = nullptr, Block *block = nullptr,\n                         LineEntry *line_entry = nullptr,\n                         Symbol *symbol = nullptr);\n\n  // This version sets the target to a NULL TargetSP if you don't know it.\n  explicit SymbolContext(const lldb::ModuleSP &module_sp,\n                         CompileUnit *comp_unit = nullptr,\n                         Function *function = nullptr, Block *block = nullptr,\n                         LineEntry *line_entry = nullptr,\n                         Symbol *symbol = nullptr);\n\n  ~SymbolContext();\n\n  /// Clear the object's state.\n  ///\n  /// Resets all pointer members to nullptr, and clears any class objects to\n  /// their default state.\n  void Clear(bool clear_target);\n\n  /// Dump a description of this object to a Stream.\n  ///\n  /// Dump a description of the contents of this object to the supplied stream\n  /// \\a s.\n  ///\n  /// \\param[in] s\n  ///     The stream to which to dump the object description.\n  void Dump(Stream *s, Target *target) const;\n\n  /// Dump the stop context in this object to a Stream.\n  ///\n  /// Dump the best description of this object to the stream. The information\n  /// displayed depends on the amount and quality of the information in this\n  /// context. If a module, function, file and line number are available, they\n  /// will be dumped. If only a module and function or symbol name with offset\n  /// is available, that will be output. Else just the address at which the\n  /// target was stopped will be displayed.\n  ///\n  /// \\param[in] s\n  ///     The stream to which to dump the object description.\n  ///\n  /// \\param[in] so_addr\n  ///     The resolved section offset address.\n  ///\n  /// \\param[in] show_fullpaths\n  ///     When printing file paths (with the Module), whether the\n  ///     base name of the Module should be printed or the full path.\n  ///\n  /// \\param[in] show_module\n  ///     Whether the module name should be printed followed by a\n  ///     grave accent \"`\" character.\n  ///\n  /// \\param[in] show_inlined_frames\n  ///     If a given pc is in inlined function(s), whether the inlined\n  ///     functions should be printed on separate lines in addition to\n  ///     the concrete function containing the pc.\n  ///\n  /// \\param[in] show_function_arguments\n  ///     If false, this method will try to elide the function argument\n  ///     types when printing the function name.  This may be ambiguous\n  ///     for languages that have function overloading - but it may\n  ///     make the \"function name\" too long to include all the argument\n  ///     types.\n  ///\n  /// \\param[in] show_function_name\n  ///     Normally this should be true - the function/symbol name should\n  ///     be printed.  In disassembly formatting, where we want a format\n  ///     like \"<*+36>\", this should be false and \"*\" will be printed\n  ///     instead.\n  ///\n  /// \\param[in] show_inline_callsite_line_info\n  ///     When processing an inline block, the line info of the callsite\n  ///     is dumped if this flag is \\b true, otherwise the line info\n  ///     of the actual inlined function is dumped.\n  ///\n  /// \\return\n  ///     \\b true if some text was dumped, \\b false otherwise.\n  bool DumpStopContext(Stream *s, ExecutionContextScope *exe_scope,\n                       const Address &so_addr, bool show_fullpaths,\n                       bool show_module, bool show_inlined_frames,\n                       bool show_function_arguments, bool show_function_name,\n                       bool show_inline_callsite_line_info = true) const;\n\n  /// Get the address range contained within a symbol context.\n  ///\n  /// Address range priority is as follows:\n  ///     - line_entry address range if line_entry is valid and\n  ///     eSymbolContextLineEntry is set in \\a scope\n  ///     - block address range if block is not nullptr and eSymbolContextBlock\n  ///     is set in \\a scope\n  ///     - function address range if function is not nullptr and\n  ///     eSymbolContextFunction is set in \\a scope\n  ///     - symbol address range if symbol is not nullptr and\n  ///     eSymbolContextSymbol is set in \\a scope\n  ///\n  /// \\param[in] scope\n  ///     A mask of symbol context bits telling this function which\n  ///     address ranges it can use when trying to extract one from\n  ///     the valid (non-nullptr) symbol context classes.\n  ///\n  /// \\param[in] range_idx\n  ///     The address range index to grab. Since many functions and\n  ///     blocks are not always contiguous, they may have more than\n  ///     one address range.\n  ///\n  /// \\param[in] use_inline_block_range\n  ///     If \\a scope has the eSymbolContextBlock bit set, and there\n  ///     is a valid block in the symbol context, return the block\n  ///     address range for the containing inline function block, not\n  ///     the deepest most block. This allows us to extract information\n  ///     for the address range of the inlined function block, not\n  ///     the deepest lexical block.\n  ///\n  /// \\param[out] range\n  ///     An address range object that will be filled in if \\b true\n  ///     is returned.\n  ///\n  /// \\return\n  ///     \\b True if this symbol context contains items that describe\n  ///     an address range, \\b false otherwise.\n  bool GetAddressRange(uint32_t scope, uint32_t range_idx,\n                       bool use_inline_block_range, AddressRange &range) const;\n\n  bool GetAddressRangeFromHereToEndLine(uint32_t end_line, AddressRange &range,\n                                        Status &error);\n\n  /// Find the best global data symbol visible from this context.\n  ///\n  /// Symbol priority is:\n  ///     - extern symbol in the current module if there is one\n  ///     - non-extern symbol in the current module if there is one\n  ///     - extern symbol in the target\n  ///     - non-extern symbol in the target\n  /// It is an error if the highest-priority result is ambiguous.\n  ///\n  /// \\param[in] name\n  ///     The name of the symbol to search for.\n  ///\n  /// \\param[out] error\n  ///     An error that will be populated with a message if there was an\n  ///     ambiguous result.  The error will not be populated if no result\n  ///     was found.\n  ///\n  /// \\return\n  ///     The symbol that was found, or \\b nullptr if none was found.\n  const Symbol *FindBestGlobalDataSymbol(ConstString name, Status &error);\n\n  void GetDescription(Stream *s, lldb::DescriptionLevel level,\n                      Target *target) const;\n\n  uint32_t GetResolvedMask() const;\n\n  lldb::LanguageType GetLanguage() const;\n\n  /// Find a block that defines the function represented by this symbol\n  /// context.\n  ///\n  /// If this symbol context points to a block that is an inlined function, or\n  /// is contained within an inlined function, the block that defines the\n  /// inlined function is returned.\n  ///\n  /// If this symbol context has no block in it, or the block is not itself an\n  /// inlined function block or contained within one, we return the top level\n  /// function block.\n  ///\n  /// This is a handy function to call when you want to get the block whose\n  /// variable list will include the arguments for the function that is\n  /// represented by this symbol context (whether the function is an inline\n  /// function or not).\n  ///\n  /// \\return\n  ///     The block object pointer that defines the function that is\n  ///     represented by this symbol context object, nullptr otherwise.\n  Block *GetFunctionBlock();\n\n  /// If this symbol context represents a function that is a method, return\n  /// true and provide information about the method.\n  ///\n  /// \\param[out] language\n  ///     If \\b true is returned, the language for the method.\n  ///\n  /// \\param[out] is_instance_method\n  ///     If \\b true is returned, \\b true if this is a instance method,\n  ///     \\b false if this is a static/class function.\n  ///\n  /// \\param[out] language_object_name\n  ///     If \\b true is returned, the name of the artificial variable\n  ///     for the language (\"this\" for C++, \"self\" for ObjC).\n  ///\n  /// \\return\n  ///     \\b True if this symbol context represents a function that\n  ///     is a method of a class, \\b false otherwise.\n  bool GetFunctionMethodInfo(lldb::LanguageType &language,\n                             bool &is_instance_method,\n                             ConstString &language_object_name);\n\n  /// Sorts the types in TypeMap according to SymbolContext to TypeList\n  ///\n  void SortTypeList(TypeMap &type_map, TypeList &type_list) const;\n\n  /// Find a name of the innermost function for the symbol context.\n  ///\n  /// For instance, if the symbol context contains an inlined block, it will\n  /// return the inlined function name.\n  ///\n  /// \\return\n  ///     The name of the function represented by this symbol context.\n  ConstString GetFunctionName(\n      Mangled::NamePreference preference = Mangled::ePreferDemangled) const;\n\n  /// Get the line entry that corresponds to the function.\n  ///\n  /// If the symbol context contains an inlined block, the line entry for the\n  /// start address of the inlined function will be returned, otherwise the\n  /// line entry for the start address of the function will be returned. This\n  /// can be used after doing a Module::FindFunctions(...) or\n  /// ModuleList::FindFunctions(...) call in order to get the correct line\n  /// table information for the symbol context. it will return the inlined\n  /// function name.\n  LineEntry GetFunctionStartLineEntry() const;\n\n  /// Find the block containing the inlined block that contains this block.\n  ///\n  /// For instance, if the symbol context contains an inlined block, it will\n  /// return the inlined function name.\n  ///\n  /// \\param[in] curr_frame_pc\n  ///    The address within the block of this object.\n  ///\n  /// \\param[out] next_frame_sc\n  ///     A new symbol context that does what the title says it does.\n  ///\n  /// \\param[out] inlined_frame_addr\n  ///     This is what you should report as the PC in \\a next_frame_sc.\n  ///\n  /// \\return\n  ///     \\b true if this SymbolContext specifies a block contained in an\n  ///     inlined block.  If this returns \\b true, \\a next_frame_sc and\n  ///     \\a inlined_frame_addr will be filled in correctly.\n  bool GetParentOfInlinedScope(const Address &curr_frame_pc,\n                               SymbolContext &next_frame_sc,\n                               Address &inlined_frame_addr) const;\n\n  // Member variables\n  lldb::TargetSP target_sp; ///< The Target for a given query\n  lldb::ModuleSP module_sp; ///< The Module for a given query\n  CompileUnit *comp_unit;   ///< The CompileUnit for a given query\n  Function *function;       ///< The Function for a given query\n  Block *block;             ///< The Block for a given query\n  LineEntry line_entry;     ///< The LineEntry for a given query\n  Symbol *symbol;           ///< The Symbol for a given query\n  Variable *variable;       ///< The global variable matching the given query\n};\n\nclass SymbolContextSpecifier {\npublic:\n  enum SpecificationType {\n    eNothingSpecified = 0,\n    eModuleSpecified = 1 << 0,\n    eFileSpecified = 1 << 1,\n    eLineStartSpecified = 1 << 2,\n    eLineEndSpecified = 1 << 3,\n    eFunctionSpecified = 1 << 4,\n    eClassOrNamespaceSpecified = 1 << 5,\n    eAddressRangeSpecified = 1 << 6\n  };\n\n  // This one produces a specifier that matches everything...\n  SymbolContextSpecifier(const lldb::TargetSP &target_sp);\n\n  ~SymbolContextSpecifier();\n\n  bool AddSpecification(const char *spec_string, SpecificationType type);\n\n  bool AddLineSpecification(uint32_t line_no, SpecificationType type);\n\n  void Clear();\n\n  bool SymbolContextMatches(const SymbolContext &sc);\n\n  bool AddressMatches(lldb::addr_t addr);\n\n  void GetDescription(Stream *s, lldb::DescriptionLevel level) const;\n\nprivate:\n  lldb::TargetSP m_target_sp;\n  std::string m_module_spec;\n  lldb::ModuleSP m_module_sp;\n  std::unique_ptr<FileSpec> m_file_spec_up;\n  size_t m_start_line;\n  size_t m_end_line;\n  std::string m_function_spec;\n  std::string m_class_name;\n  std::unique_ptr<AddressRange> m_address_range_up;\n  uint32_t m_type; // Or'ed bits from SpecificationType\n};\n\n/// \\class SymbolContextList SymbolContext.h \"lldb/Symbol/SymbolContext.h\"\n/// Defines a list of symbol context objects.\n///\n/// This class provides a common structure that can be used to contain the\n/// result of a query that can contain a multiple results. Examples of such\n/// queries include:\n///     \\li Looking up a function by name.\n///     \\li Finding all addresses for a specified file and line number.\nclass SymbolContextList {\npublic:\n  /// Default constructor.\n  ///\n  /// Initialize with an empty list.\n  SymbolContextList();\n\n  /// Destructor.\n  ~SymbolContextList();\n\n  /// Append a new symbol context to the list.\n  ///\n  /// \\param[in] sc\n  ///     A symbol context to append to the list.\n  void Append(const SymbolContext &sc);\n\n  void Append(const SymbolContextList &sc_list);\n\n  bool AppendIfUnique(const SymbolContext &sc, bool merge_symbol_into_function);\n\n  uint32_t AppendIfUnique(const SymbolContextList &sc_list,\n                          bool merge_symbol_into_function);\n\n  /// Clear the object's state.\n  ///\n  /// Clears the symbol context list.\n  void Clear();\n\n  /// Dump a description of this object to a Stream.\n  ///\n  /// Dump a description of the contents of each symbol context in the list to\n  /// the supplied stream \\a s.\n  ///\n  /// \\param[in] s\n  ///     The stream to which to dump the object description.\n  void Dump(Stream *s, Target *target) const;\n\n  /// Get accessor for a symbol context at index \\a idx.\n  ///\n  /// Dump a description of the contents of each symbol context in the list to\n  /// the supplied stream \\a s.\n  ///\n  /// \\param[in] idx\n  ///     The zero based index into the symbol context list.\n  ///\n  /// \\param[out] sc\n  ///     A reference to the symbol context to fill in.\n  ///\n  /// \\return\n  ///     Returns \\b true if \\a idx was a valid index into this\n  ///     symbol context list and \\a sc was filled in, \\b false\n  ///     otherwise.\n  bool GetContextAtIndex(size_t idx, SymbolContext &sc) const;\n\n  /// Direct reference accessor for a symbol context at index \\a idx.\n  ///\n  /// The index \\a idx must be a valid index, no error checking will be done\n  /// to ensure that it is valid.\n  ///\n  /// \\param[in] idx\n  ///     The zero based index into the symbol context list.\n  ///\n  /// \\return\n  ///     A const reference to the symbol context to fill in.\n  SymbolContext &operator[](size_t idx) { return m_symbol_contexts[idx]; }\n\n  const SymbolContext &operator[](size_t idx) const {\n    return m_symbol_contexts[idx];\n  }\n\n  bool RemoveContextAtIndex(size_t idx);\n\n  /// Get accessor for a symbol context list size.\n  ///\n  /// \\return\n  ///     Returns the number of symbol context objects in the list.\n  uint32_t GetSize() const;\n\n  bool IsEmpty() const;\n\n  uint32_t NumLineEntriesWithLine(uint32_t line) const;\n\n  void GetDescription(Stream *s, lldb::DescriptionLevel level,\n                      Target *target) const;\n\nprotected:\n  typedef std::vector<SymbolContext>\n      collection; ///< The collection type for the list.\n\n  // Member variables.\n  collection m_symbol_contexts; ///< The list of symbol contexts.\n\npublic:\n  typedef AdaptedIterable<collection, SymbolContext, vector_adapter>\n      SymbolContextIterable;\n  SymbolContextIterable SymbolContexts() {\n    return SymbolContextIterable(m_symbol_contexts);\n  }\n};\n\nbool operator==(const SymbolContext &lhs, const SymbolContext &rhs);\nbool operator!=(const SymbolContext &lhs, const SymbolContext &rhs);\n\nbool operator==(const SymbolContextList &lhs, const SymbolContextList &rhs);\nbool operator!=(const SymbolContextList &lhs, const SymbolContextList &rhs);\n\n} // namespace lldb_private\n\n#endif // LLDB_SYMBOL_SYMBOLCONTEXT_H\n"}, "11": {"id": 11, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/Type.h", "content": "//===-- Type.h --------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_SYMBOL_TYPE_H\n#define LLDB_SYMBOL_TYPE_H\n\n#include \"lldb/Symbol/CompilerDecl.h\"\n#include \"lldb/Symbol/CompilerType.h\"\n#include \"lldb/Symbol/Declaration.h\"\n#include \"lldb/Utility/ConstString.h\"\n#include \"lldb/Utility/UserID.h\"\n#include \"lldb/lldb-private.h\"\n\n#include \"llvm/ADT/APSInt.h\"\n\n#include <set>\n\nnamespace lldb_private {\n\n/// CompilerContext allows an array of these items to be passed to perform\n/// detailed lookups in SymbolVendor and SymbolFile functions.\nstruct CompilerContext {\n  CompilerContext(CompilerContextKind t, ConstString n) : kind(t), name(n) {}\n\n  bool operator==(const CompilerContext &rhs) const {\n    return kind == rhs.kind && name == rhs.name;\n  }\n  bool operator!=(const CompilerContext &rhs) const { return !(*this == rhs); }\n\n  void Dump() const;\n\n  CompilerContextKind kind;\n  ConstString name;\n};\n\n/// Match \\p context_chain against \\p pattern, which may contain \"Any\"\n/// kinds. The \\p context_chain should *not* contain any \"Any\" kinds.\nbool contextMatches(llvm::ArrayRef<CompilerContext> context_chain,\n                    llvm::ArrayRef<CompilerContext> pattern);\n\nclass SymbolFileType : public std::enable_shared_from_this<SymbolFileType>,\n                       public UserID {\npublic:\n  SymbolFileType(SymbolFile &symbol_file, lldb::user_id_t uid)\n      : UserID(uid), m_symbol_file(symbol_file) {}\n\n  SymbolFileType(SymbolFile &symbol_file, const lldb::TypeSP &type_sp);\n\n  ~SymbolFileType() {}\n\n  Type *operator->() { return GetType(); }\n\n  Type *GetType();\n  SymbolFile &GetSymbolFile() const { return m_symbol_file; }\n\nprotected:\n  SymbolFile &m_symbol_file;\n  lldb::TypeSP m_type_sp;\n};\n\nclass Type : public std::enable_shared_from_this<Type>, public UserID {\npublic:\n  enum EncodingDataType {\n    eEncodingInvalid,\n    eEncodingIsUID,      ///< This type is the type whose UID is m_encoding_uid\n    eEncodingIsConstUID, ///< This type is the type whose UID is m_encoding_uid\n                         /// with the const qualifier added\n    eEncodingIsRestrictUID, ///< This type is the type whose UID is\n                            /// m_encoding_uid with the restrict qualifier added\n    eEncodingIsVolatileUID, ///< This type is the type whose UID is\n                            /// m_encoding_uid with the volatile qualifier added\n    eEncodingIsTypedefUID,  ///< This type is pointer to a type whose UID is\n                            /// m_encoding_uid\n    eEncodingIsPointerUID,  ///< This type is pointer to a type whose UID is\n                            /// m_encoding_uid\n    eEncodingIsLValueReferenceUID, ///< This type is L value reference to a type\n                                   /// whose UID is m_encoding_uid\n    eEncodingIsRValueReferenceUID, ///< This type is R value reference to a type\n                                   /// whose UID is m_encoding_uid,\n    eEncodingIsAtomicUID,          ///< This type is the type whose UID is\n                                   /// m_encoding_uid as an atomic type.\n    eEncodingIsSyntheticUID\n  };\n\n  enum class ResolveState : unsigned char {\n    Unresolved = 0,\n    Forward = 1,\n    Layout = 2,\n    Full = 3\n  };\n\n  Type(lldb::user_id_t uid, SymbolFile *symbol_file, ConstString name,\n       llvm::Optional<uint64_t> byte_size, SymbolContextScope *context,\n       lldb::user_id_t encoding_uid, EncodingDataType encoding_uid_type,\n       const Declaration &decl, const CompilerType &compiler_qual_type,\n       ResolveState compiler_type_resolve_state, uint32_t opaque_payload = 0);\n\n  // This makes an invalid type.  Used for functions that return a Type when\n  // they get an error.\n  Type();\n\n  void Dump(Stream *s, bool show_context,\n            lldb::DescriptionLevel level = lldb::eDescriptionLevelFull);\n\n  void DumpTypeName(Stream *s);\n\n  /// Since Type instances only keep a \"SymbolFile *\" internally, other classes\n  /// like TypeImpl need make sure the module is still around before playing\n  /// with\n  /// Type instances. They can store a weak pointer to the Module;\n  lldb::ModuleSP GetModule();\n\n  /// GetModule may return module for compile unit's object file.\n  /// GetExeModule returns module for executable object file that contains\n  /// compile unit where type was actualy defined.\n  /// GetModule and GetExeModule may return the same value.\n  lldb::ModuleSP GetExeModule();\n\n  void GetDescription(Stream *s, lldb::DescriptionLevel level, bool show_name,\n                      ExecutionContextScope *exe_scope);\n\n  SymbolFile *GetSymbolFile() { return m_symbol_file; }\n  const SymbolFile *GetSymbolFile() const { return m_symbol_file; }\n\n  ConstString GetName();\n\n  llvm::Optional<uint64_t> GetByteSize(ExecutionContextScope *exe_scope);\n\n  uint32_t GetNumChildren(bool omit_empty_base_classes);\n\n  bool IsAggregateType();\n\n  bool IsValidType() { return m_encoding_uid_type != eEncodingInvalid; }\n\n  bool IsTypedef() { return m_encoding_uid_type == eEncodingIsTypedefUID; }\n\n  lldb::TypeSP GetTypedefType();\n\n  ConstString GetName() const { return m_name; }\n\n  ConstString GetQualifiedName();\n\n  void DumpValue(ExecutionContext *exe_ctx, Stream *s,\n                 const DataExtractor &data, uint32_t data_offset,\n                 bool show_type, bool show_summary, bool verbose,\n                 lldb::Format format = lldb::eFormatDefault);\n\n  bool DumpValueInMemory(ExecutionContext *exe_ctx, Stream *s,\n                         lldb::addr_t address, AddressType address_type,\n                         bool show_types, bool show_summary, bool verbose);\n\n  bool ReadFromMemory(ExecutionContext *exe_ctx, lldb::addr_t address,\n                      AddressType address_type, DataExtractor &data);\n\n  bool WriteToMemory(ExecutionContext *exe_ctx, lldb::addr_t address,\n                     AddressType address_type, DataExtractor &data);\n\n  bool GetIsDeclaration() const;\n\n  void SetIsDeclaration(bool b);\n\n  bool GetIsExternal() const;\n\n  void SetIsExternal(bool b);\n\n  lldb::Format GetFormat();\n\n  lldb::Encoding GetEncoding(uint64_t &count);\n\n  SymbolContextScope *GetSymbolContextScope() { return m_context; }\n  const SymbolContextScope *GetSymbolContextScope() const { return m_context; }\n  void SetSymbolContextScope(SymbolContextScope *context) {\n    m_context = context;\n  }\n\n  const lldb_private::Declaration &GetDeclaration() const;\n\n  // Get the clang type, and resolve definitions for any\n  // class/struct/union/enum types completely.\n  CompilerType GetFullCompilerType();\n\n  // Get the clang type, and resolve definitions enough so that the type could\n  // have layout performed. This allows ptrs and refs to\n  // class/struct/union/enum types remain forward declarations.\n  CompilerType GetLayoutCompilerType();\n\n  // Get the clang type and leave class/struct/union/enum types as forward\n  // declarations if they haven't already been fully defined.\n  CompilerType GetForwardCompilerType();\n\n  static int Compare(const Type &a, const Type &b);\n\n  // From a fully qualified typename, split the type into the type basename and\n  // the remaining type scope (namespaces/classes).\n  static bool GetTypeScopeAndBasename(const llvm::StringRef& name,\n                                      llvm::StringRef &scope,\n                                      llvm::StringRef &basename,\n                                      lldb::TypeClass &type_class);\n  void SetEncodingType(Type *encoding_type) { m_encoding_type = encoding_type; }\n\n  uint32_t GetEncodingMask();\n\n  typedef uint32_t Payload;\n  /// Return the language-specific payload.\n  Payload GetPayload() { return m_payload; }\n  /// Return the language-specific payload.\n  void SetPayload(Payload opaque_payload) { m_payload = opaque_payload; }\n\nprotected:\n  ConstString m_name;\n  SymbolFile *m_symbol_file;\n  /// The symbol context in which this type is defined.\n  SymbolContextScope *m_context;\n  Type *m_encoding_type;\n  lldb::user_id_t m_encoding_uid;\n  EncodingDataType m_encoding_uid_type;\n  uint64_t m_byte_size : 63;\n  uint64_t m_byte_size_has_value : 1;\n  Declaration m_decl;\n  CompilerType m_compiler_type;\n  ResolveState m_compiler_type_resolve_state;\n  /// Language-specific flags.\n  Payload m_payload;\n\n  Type *GetEncodingType();\n\n  bool ResolveCompilerType(ResolveState compiler_type_resolve_state);\n};\n\n// the two classes here are used by the public API as a backend to the SBType\n// and SBTypeList classes\n\nclass TypeImpl {\npublic:\n  TypeImpl() = default;\n\n  ~TypeImpl() {}\n\n  TypeImpl(const lldb::TypeSP &type_sp);\n\n  TypeImpl(const CompilerType &compiler_type);\n\n  TypeImpl(const lldb::TypeSP &type_sp, const CompilerType &dynamic);\n\n  TypeImpl(const CompilerType &compiler_type, const CompilerType &dynamic);\n\n  void SetType(const lldb::TypeSP &type_sp);\n\n  void SetType(const CompilerType &compiler_type);\n\n  void SetType(const lldb::TypeSP &type_sp, const CompilerType &dynamic);\n\n  void SetType(const CompilerType &compiler_type, const CompilerType &dynamic);\n\n  bool operator==(const TypeImpl &rhs) const;\n\n  bool operator!=(const TypeImpl &rhs) const;\n\n  bool IsValid() const;\n\n  explicit operator bool() const;\n\n  void Clear();\n\n  lldb::ModuleSP GetModule() const;\n\n  ConstString GetName() const;\n\n  ConstString GetDisplayTypeName() const;\n\n  TypeImpl GetPointerType() const;\n\n  TypeImpl GetPointeeType() const;\n\n  TypeImpl GetReferenceType() const;\n\n  TypeImpl GetTypedefedType() const;\n\n  TypeImpl GetDereferencedType() const;\n\n  TypeImpl GetUnqualifiedType() const;\n\n  TypeImpl GetCanonicalType() const;\n\n  CompilerType GetCompilerType(bool prefer_dynamic);\n\n  TypeSystem *GetTypeSystem(bool prefer_dynamic);\n\n  bool GetDescription(lldb_private::Stream &strm,\n                      lldb::DescriptionLevel description_level);\n\nprivate:\n  bool CheckModule(lldb::ModuleSP &module_sp) const;\n  bool CheckExeModule(lldb::ModuleSP &module_sp) const;\n  bool CheckModuleCommon(const lldb::ModuleWP &input_module_wp,\n                         lldb::ModuleSP &module_sp) const;\n\n  lldb::ModuleWP m_module_wp;\n  lldb::ModuleWP m_exe_module_wp;\n  CompilerType m_static_type;\n  CompilerType m_dynamic_type;\n};\n\nclass TypeListImpl {\npublic:\n  TypeListImpl() : m_content() {}\n\n  void Append(const lldb::TypeImplSP &type) { m_content.push_back(type); }\n\n  class AppendVisitor {\n  public:\n    AppendVisitor(TypeListImpl &type_list) : m_type_list(type_list) {}\n\n    void operator()(const lldb::TypeImplSP &type) { m_type_list.Append(type); }\n\n  private:\n    TypeListImpl &m_type_list;\n  };\n\n  void Append(const lldb_private::TypeList &type_list);\n\n  lldb::TypeImplSP GetTypeAtIndex(size_t idx) {\n    lldb::TypeImplSP type_sp;\n    if (idx < GetSize())\n      type_sp = m_content[idx];\n    return type_sp;\n  }\n\n  size_t GetSize() { return m_content.size(); }\n\nprivate:\n  std::vector<lldb::TypeImplSP> m_content;\n};\n\nclass TypeMemberImpl {\npublic:\n  TypeMemberImpl()\n      : m_type_impl_sp(), m_bit_offset(0), m_name(), m_bitfield_bit_size(0),\n        m_is_bitfield(false)\n\n  {}\n\n  TypeMemberImpl(const lldb::TypeImplSP &type_impl_sp, uint64_t bit_offset,\n                 ConstString name, uint32_t bitfield_bit_size = 0,\n                 bool is_bitfield = false)\n      : m_type_impl_sp(type_impl_sp), m_bit_offset(bit_offset), m_name(name),\n        m_bitfield_bit_size(bitfield_bit_size), m_is_bitfield(is_bitfield) {}\n\n  TypeMemberImpl(const lldb::TypeImplSP &type_impl_sp, uint64_t bit_offset)\n      : m_type_impl_sp(type_impl_sp), m_bit_offset(bit_offset), m_name(),\n        m_bitfield_bit_size(0), m_is_bitfield(false) {\n    if (m_type_impl_sp)\n      m_name = m_type_impl_sp->GetName();\n  }\n\n  const lldb::TypeImplSP &GetTypeImpl() { return m_type_impl_sp; }\n\n  ConstString GetName() const { return m_name; }\n\n  uint64_t GetBitOffset() const { return m_bit_offset; }\n\n  uint32_t GetBitfieldBitSize() const { return m_bitfield_bit_size; }\n\n  void SetBitfieldBitSize(uint32_t bitfield_bit_size) {\n    m_bitfield_bit_size = bitfield_bit_size;\n  }\n\n  bool GetIsBitfield() const { return m_is_bitfield; }\n\n  void SetIsBitfield(bool is_bitfield) { m_is_bitfield = is_bitfield; }\n\nprotected:\n  lldb::TypeImplSP m_type_impl_sp;\n  uint64_t m_bit_offset;\n  ConstString m_name;\n  uint32_t m_bitfield_bit_size; // Bit size for bitfield members only\n  bool m_is_bitfield;\n};\n\n///\n/// Sometimes you can find the name of the type corresponding to an object, but\n/// we don't have debug\n/// information for it.  If that is the case, you can return one of these\n/// objects, and then if it\n/// has a full type, you can use that, but if not at least you can print the\n/// name for informational\n/// purposes.\n///\n\nclass TypeAndOrName {\npublic:\n  TypeAndOrName() = default;\n  TypeAndOrName(lldb::TypeSP &type_sp);\n  TypeAndOrName(const CompilerType &compiler_type);\n  TypeAndOrName(const char *type_str);\n  TypeAndOrName(ConstString &type_const_string);\n\n  bool operator==(const TypeAndOrName &other) const;\n\n  bool operator!=(const TypeAndOrName &other) const;\n\n  ConstString GetName() const;\n\n  CompilerType GetCompilerType() const { return m_compiler_type; }\n\n  void SetName(ConstString type_name);\n\n  void SetName(const char *type_name_cstr);\n\n  void SetTypeSP(lldb::TypeSP type_sp);\n\n  void SetCompilerType(CompilerType compiler_type);\n\n  bool IsEmpty() const;\n\n  bool HasName() const;\n\n  bool HasCompilerType() const;\n\n  bool HasType() const { return HasCompilerType(); }\n\n  void Clear();\n\n  explicit operator bool() { return !IsEmpty(); }\n\nprivate:\n  CompilerType m_compiler_type;\n  ConstString m_type_name;\n};\n\nclass TypeMemberFunctionImpl {\npublic:\n  TypeMemberFunctionImpl()\n      : m_type(), m_decl(), m_name(), m_kind(lldb::eMemberFunctionKindUnknown) {\n  }\n\n  TypeMemberFunctionImpl(const CompilerType &type, const CompilerDecl &decl,\n                         const std::string &name,\n                         const lldb::MemberFunctionKind &kind)\n      : m_type(type), m_decl(decl), m_name(name), m_kind(kind) {}\n\n  bool IsValid();\n\n  ConstString GetName() const;\n\n  ConstString GetMangledName() const;\n\n  CompilerType GetType() const;\n\n  CompilerType GetReturnType() const;\n\n  size_t GetNumArguments() const;\n\n  CompilerType GetArgumentAtIndex(size_t idx) const;\n\n  lldb::MemberFunctionKind GetKind() const;\n\n  bool GetDescription(Stream &stream);\n\nprotected:\n  std::string GetPrintableTypeName();\n\nprivate:\n  CompilerType m_type;\n  CompilerDecl m_decl;\n  ConstString m_name;\n  lldb::MemberFunctionKind m_kind;\n};\n\nclass TypeEnumMemberImpl {\npublic:\n  TypeEnumMemberImpl()\n      : m_integer_type_sp(), m_name(\"<invalid>\"), m_value(), m_valid(false) {}\n\n  TypeEnumMemberImpl(const lldb::TypeImplSP &integer_type_sp,\n                     ConstString name, const llvm::APSInt &value);\n\n  TypeEnumMemberImpl(const TypeEnumMemberImpl &rhs) = default;\n\n  TypeEnumMemberImpl &operator=(const TypeEnumMemberImpl &rhs);\n\n  bool IsValid() { return m_valid; }\n\n  ConstString GetName() const { return m_name; }\n\n  const lldb::TypeImplSP &GetIntegerType() const { return m_integer_type_sp; }\n\n  uint64_t GetValueAsUnsigned() const { return m_value.getZExtValue(); }\n\n  int64_t GetValueAsSigned() const { return m_value.getSExtValue(); }\n\nprotected:\n  lldb::TypeImplSP m_integer_type_sp;\n  ConstString m_name;\n  llvm::APSInt m_value;\n  bool m_valid;\n};\n\nclass TypeEnumMemberListImpl {\npublic:\n  TypeEnumMemberListImpl() : m_content() {}\n\n  void Append(const lldb::TypeEnumMemberImplSP &type) {\n    m_content.push_back(type);\n  }\n\n  void Append(const lldb_private::TypeEnumMemberListImpl &type_list);\n\n  lldb::TypeEnumMemberImplSP GetTypeEnumMemberAtIndex(size_t idx) {\n    lldb::TypeEnumMemberImplSP enum_member;\n    if (idx < GetSize())\n      enum_member = m_content[idx];\n    return enum_member;\n  }\n\n  size_t GetSize() { return m_content.size(); }\n\nprivate:\n  std::vector<lldb::TypeEnumMemberImplSP> m_content;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_SYMBOL_TYPE_H\n"}, "12": {"id": 12, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Target/ExecutionContext.h", "content": "//===-- ExecutionContext.h --------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_TARGET_EXECUTIONCONTEXT_H\n#define LLDB_TARGET_EXECUTIONCONTEXT_H\n\n#include <mutex>\n\n#include \"lldb/Target/StackID.h\"\n#include \"lldb/lldb-private.h\"\n\nnamespace lldb_private {\n\n//===----------------------------------------------------------------------===//\n/// Execution context objects refer to objects in the execution of the program\n/// that is being debugged. The consist of one or more of the following\n/// objects: target, process, thread, and frame. Many objects in the debugger\n/// need to track different executions contexts. For example, a local function\n/// variable might have an execution context that refers to a stack frame. A\n/// global or static variable might refer to a target since a stack frame\n/// isn't required in order to evaluate a global or static variable (a process\n/// isn't necessarily needed for a global variable since we might be able to\n/// read the variable value from a data section in one of the object files in\n/// a target). There are two types of objects that hold onto execution\n/// contexts: ExecutionContextRef and ExecutionContext. Both of these objects\n/// are described below.\n///\n/// Not all objects in an ExecutionContext objects will be valid. If you want\n/// to refer strongly (ExecutionContext) or weakly (ExecutionContextRef) to a\n/// process, then only the process and target references will be valid. For\n/// threads, only the thread, process and target references will be filled in.\n/// For frames, all of the objects will be filled in.\n///\n/// These classes are designed to be used as baton objects that get passed to\n/// a wide variety of functions that require execution contexts.\n//===----------------------------------------------------------------------===//\n\n/// \\class ExecutionContextRef ExecutionContext.h\n/// \"lldb/Target/ExecutionContext.h\"\n/// A class that holds a weak reference to an execution context.\n///\n/// ExecutionContextRef objects are designed to hold onto an execution context\n/// that might change over time. For example, if an object wants to refer to a\n/// stack frame, it should hold onto an ExecutionContextRef to a frame object.\n/// The backing object that represents the stack frame might change over time\n/// and instances of this object can track the logical object that refers to a\n/// frame even if it does change.\n///\n/// These objects also don't keep execution objects around longer than they\n/// should since they use weak pointers. For example if an object refers to a\n/// stack frame and a stack frame is no longer in a thread, then a\n/// ExecutionContextRef object that refers to that frame will not be able to\n/// get a shared pointer to those objects since they are no longer around.\n///\n/// ExecutionContextRef objects can also be used as objects in classes that\n/// want to track a \"previous execution context\". Since the weak references to\n/// the execution objects (target, process, thread and frame) don't keep these\n/// objects around, they are safe to keep around.\n///\n/// The general rule of thumb is all long lived objects that want to refer to\n/// execution contexts should use ExecutionContextRef objects. The\n/// ExecutionContext class is used to temporarily get shared pointers to any\n/// execution context objects that are still around so they are guaranteed to\n/// exist during a function that requires the objects. ExecutionContext\n/// objects should NOT be used for long term storage since they will keep\n/// objects alive with extra shared pointer references to these  objects.\nclass ExecutionContextRef {\npublic:\n  /// Default Constructor.\n  ExecutionContextRef();\n\n  /// Copy Constructor.\n  ExecutionContextRef(const ExecutionContextRef &rhs);\n\n  /// Construct using an ExecutionContext object that might be nullptr.\n  ///\n  /// If \\a exe_ctx_ptr is valid, then make weak references to any valid\n  /// objects in the ExecutionContext, otherwise no weak references to any\n  /// execution context objects will be made.\n  ExecutionContextRef(const ExecutionContext *exe_ctx_ptr);\n\n  /// Construct using an ExecutionContext object.\n  ///\n  /// Make weak references to any valid objects in the ExecutionContext.\n  ExecutionContextRef(const ExecutionContext &exe_ctx);\n\n  /// Construct using the target and all the selected items inside of it (the\n  /// process and its selected thread, and the thread's selected frame). If\n  /// there is no selected thread, default to the first thread If there is no\n  /// selected frame, default to the first frame.\n  ExecutionContextRef(Target *target, bool adopt_selected);\n\n  /// Construct using an execution context scope.\n  ///\n  /// If the ExecutionContextScope object is valid and refers to a frame, make\n  /// weak references too the frame, thread, process and target. If the\n  /// ExecutionContextScope object is valid and refers to a thread, make weak\n  /// references too the thread, process and target. If the\n  /// ExecutionContextScope object is valid and refers to a process, make weak\n  /// references too the process and target. If the ExecutionContextScope\n  /// object is valid and refers to a target, make weak references too the\n  /// target.\n  ExecutionContextRef(ExecutionContextScope *exe_scope);\n\n  /// Construct using an execution context scope.\n  ///\n  /// If the ExecutionContextScope object refers to a frame, make weak\n  /// references too the frame, thread, process and target. If the\n  /// ExecutionContextScope object refers to a thread, make weak references\n  /// too the thread, process and target. If the ExecutionContextScope object\n  /// refers to a process, make weak references too the process and target. If\n  /// the ExecutionContextScope object refers to a target, make weak\n  /// references too the target.\n  ExecutionContextRef(ExecutionContextScope &exe_scope);\n\n  ~ExecutionContextRef();\n\n  /// Assignment operator\n  ///\n  /// Copy all weak references in \\a rhs.\n  ExecutionContextRef &operator=(const ExecutionContextRef &rhs);\n\n  /// Assignment operator from a ExecutionContext\n  ///\n  /// Make weak references to any strongly referenced objects in \\a exe_ctx.\n  ExecutionContextRef &operator=(const ExecutionContext &exe_ctx);\n\n  /// Clear the object's state.\n  ///\n  /// Sets the process and thread to nullptr, and the frame index to an\n  /// invalid value.\n  void Clear();\n\n  /// Set accessor that creates a weak reference to the target referenced in\n  /// \\a target_sp.\n  ///\n  /// If \\a target_sp is valid this object will create a weak reference to\n  /// that object, otherwise any previous target weak reference contained in\n  /// this object will be reset.\n  ///\n  /// Only the weak reference to the target will be updated, no other weak\n  /// references will be modified. If you want this execution context to make\n  /// a weak reference to the target's process, use the\n  /// ExecutionContextRef::SetContext() functions.\n  ///\n  /// \\see ExecutionContextRef::SetContext(const lldb::TargetSP &, bool)\n  void SetTargetSP(const lldb::TargetSP &target_sp);\n\n  /// Set accessor that creates a weak reference to the process referenced in\n  /// \\a process_sp.\n  ///\n  /// If \\a process_sp is valid this object will create a weak reference to\n  /// that object, otherwise any previous process weak reference contained in\n  /// this object will be reset.\n  ///\n  /// Only the weak reference to the process will be updated, no other weak\n  /// references will be modified. If you want this execution context to make\n  /// a weak reference to the target, use the\n  /// ExecutionContextRef::SetContext() functions.\n  ///\n  /// \\see ExecutionContextRef::SetContext(const lldb::ProcessSP &)\n  void SetProcessSP(const lldb::ProcessSP &process_sp);\n\n  /// Set accessor that creates a weak reference to the thread referenced in\n  /// \\a thread_sp.\n  ///\n  /// If \\a thread_sp is valid this object will create a weak reference to\n  /// that object, otherwise any previous thread weak reference contained in\n  /// this object will be reset.\n  ///\n  /// Only the weak reference to the thread will be updated, no other weak\n  /// references will be modified. If you want this execution context to make\n  /// a weak reference to the thread's process and target, use the\n  /// ExecutionContextRef::SetContext() functions.\n  ///\n  /// \\see ExecutionContextRef::SetContext(const lldb::ThreadSP &)\n  void SetThreadSP(const lldb::ThreadSP &thread_sp);\n\n  /// Set accessor that creates a weak reference to the frame referenced in \\a\n  /// frame_sp.\n  ///\n  /// If \\a frame_sp is valid this object will create a weak reference to that\n  /// object, otherwise any previous frame weak reference contained in this\n  /// object will be reset.\n  ///\n  /// Only the weak reference to the frame will be updated, no other weak\n  /// references will be modified. If you want this execution context to make\n  /// a weak reference to the frame's thread, process and target, use the\n  /// ExecutionContextRef::SetContext() functions.\n  ///\n  /// \\see ExecutionContextRef::SetContext(const lldb::StackFrameSP &)\n  void SetFrameSP(const lldb::StackFrameSP &frame_sp);\n\n  void SetTargetPtr(Target *target, bool adopt_selected);\n\n  void SetProcessPtr(Process *process);\n\n  void SetThreadPtr(Thread *thread);\n\n  void SetFramePtr(StackFrame *frame);\n\n  /// Get accessor that creates a strong reference from the weak target\n  /// reference contained in this object.\n  ///\n  /// \\returns\n  ///     A shared pointer to a target that is not guaranteed to be valid.\n  lldb::TargetSP GetTargetSP() const;\n\n  /// Get accessor that creates a strong reference from the weak process\n  /// reference contained in this object.\n  ///\n  /// \\returns\n  ///     A shared pointer to a process that is not guaranteed to be valid.\n  lldb::ProcessSP GetProcessSP() const;\n\n  /// Get accessor that creates a strong reference from the weak thread\n  /// reference contained in this object.\n  ///\n  /// \\returns\n  ///     A shared pointer to a thread that is not guaranteed to be valid.\n  lldb::ThreadSP GetThreadSP() const;\n\n  /// Get accessor that creates a strong reference from the weak frame\n  /// reference contained in this object.\n  ///\n  /// \\returns\n  ///     A shared pointer to a frame that is not guaranteed to be valid.\n  lldb::StackFrameSP GetFrameSP() const;\n\n  /// Create an ExecutionContext object from this object.\n  ///\n  /// Create strong references to any execution context objects that are still\n  /// valid. Any of the returned shared pointers in the ExecutionContext\n  /// objects is not guaranteed to be valid. \\returns\n  ///     An execution context object that has strong references to\n  ///     any valid weak references in this object.\n  ExecutionContext Lock(bool thread_and_frame_only_if_stopped) const;\n\n  /// Returns true if this object has a weak reference to a thread. The return\n  /// value is only an indication of whether this object has a weak reference\n  /// and does not indicate whether the weak reference is valid or not.\n  bool HasThreadRef() const { return m_tid != LLDB_INVALID_THREAD_ID; }\n\n  /// Returns true if this object has a weak reference to a frame. The return\n  /// value is only an indication of whether this object has a weak reference\n  /// and does not indicate whether the weak reference is valid or not.\n  bool HasFrameRef() const { return m_stack_id.IsValid(); }\n\n  void ClearThread() {\n    m_thread_wp.reset();\n    m_tid = LLDB_INVALID_THREAD_ID;\n  }\n\n  void ClearFrame() { m_stack_id.Clear(); }\n\nprotected:\n  // Member variables\n  lldb::TargetWP m_target_wp;         ///< A weak reference to a target\n  lldb::ProcessWP m_process_wp;       ///< A weak reference to a process\n  mutable lldb::ThreadWP m_thread_wp; ///< A weak reference to a thread\n  lldb::tid_t m_tid;  ///< The thread ID that this object refers to in case the\n                      ///backing object changes\n  StackID m_stack_id; ///< The stack ID that this object refers to in case the\n                      ///backing object changes\n};\n\n/// \\class ExecutionContext ExecutionContext.h\n/// \"lldb/Target/ExecutionContext.h\"\n/// A class that contains an execution context.\n///\n/// This baton object can be passed into any function that requires a context\n/// that specifies a target, process, thread and frame. These objects are\n/// designed to be used for short term execution context object storage while\n/// a function might be trying to evaluate something that requires a thread or\n/// frame. ExecutionContextRef objects can be used to initialize one of these\n/// objects to turn the weak execution context object references to the\n/// target, process, thread and frame into strong references (shared pointers)\n/// so that functions can guarantee that these objects won't go away in the\n/// middle of a function.\n///\n/// ExecutionContext objects should be used as short lived objects (typically\n/// on the stack) in order to lock down an execution context for local use and\n/// for passing down to other functions that also require specific contexts.\n/// They should NOT be used for long term storage, for long term storage use\n/// ExecutionContextRef objects.\nclass ExecutionContext {\npublic:\n  /// Default Constructor.\n  ExecutionContext();\n\n  // Copy constructor\n  ExecutionContext(const ExecutionContext &rhs);\n\n  // Adopt the target and optionally its current context.\n  ExecutionContext(Target *t, bool fill_current_process_thread_frame = true);\n\n  // Create execution contexts from shared pointers\n  ExecutionContext(const lldb::TargetSP &target_sp, bool get_process);\n  ExecutionContext(const lldb::ProcessSP &process_sp);\n  ExecutionContext(const lldb::ThreadSP &thread_sp);\n  ExecutionContext(const lldb::StackFrameSP &frame_sp);\n\n  // Create execution contexts from weak pointers\n  ExecutionContext(const lldb::TargetWP &target_wp, bool get_process);\n  ExecutionContext(const lldb::ProcessWP &process_wp);\n  ExecutionContext(const lldb::ThreadWP &thread_wp);\n  ExecutionContext(const lldb::StackFrameWP &frame_wp);\n  ExecutionContext(const ExecutionContextRef &exe_ctx_ref);\n  ExecutionContext(const ExecutionContextRef *exe_ctx_ref,\n                   bool thread_and_frame_only_if_stopped = false);\n\n  // These two variants take in a locker, and grab the target, lock the API\n  // mutex into locker, then fill in the rest of the shared pointers.\n  ExecutionContext(const ExecutionContextRef &exe_ctx_ref,\n                   std::unique_lock<std::recursive_mutex> &locker);\n  ExecutionContext(const ExecutionContextRef *exe_ctx_ref,\n                   std::unique_lock<std::recursive_mutex> &locker);\n  // Create execution contexts from execution context scopes\n  ExecutionContext(ExecutionContextScope *exe_scope);\n  ExecutionContext(ExecutionContextScope &exe_scope);\n\n  /// Construct with process, thread, and frame index.\n  ///\n  /// Initialize with process \\a p, thread \\a t, and frame index \\a f.\n  ///\n  /// \\param[in] process\n  ///     The process for this execution context.\n  ///\n  /// \\param[in] thread\n  ///     The thread for this execution context.\n  ///\n  /// \\param[in] frame\n  ///     The frame index for this execution context.\n  ExecutionContext(Process *process, Thread *thread = nullptr,\n                   StackFrame *frame = nullptr);\n\n  ~ExecutionContext();\n\n  ExecutionContext &operator=(const ExecutionContext &rhs);\n\n  bool operator==(const ExecutionContext &rhs) const;\n\n  bool operator!=(const ExecutionContext &rhs) const;\n\n  /// Clear the object's state.\n  ///\n  /// Sets the process and thread to nullptr, and the frame index to an\n  /// invalid value.\n  void Clear();\n\n  RegisterContext *GetRegisterContext() const;\n\n  ExecutionContextScope *GetBestExecutionContextScope() const;\n\n  uint32_t GetAddressByteSize() const;\n\n  lldb::ByteOrder GetByteOrder() const;\n\n  /// Returns a pointer to the target object.\n  ///\n  /// The returned pointer might be nullptr. Calling HasTargetScope(),\n  /// HasProcessScope(), HasThreadScope(), or HasFrameScope() can help to pre-\n  /// validate this pointer so that this accessor can freely be used without\n  /// having to check for nullptr each time.\n  ///\n  /// \\see ExecutionContext::HasTargetScope() const @see\n  /// ExecutionContext::HasProcessScope() const @see\n  /// ExecutionContext::HasThreadScope() const @see\n  /// ExecutionContext::HasFrameScope() const\n  Target *GetTargetPtr() const;\n\n  /// Returns a pointer to the process object.\n  ///\n  /// The returned pointer might be nullptr. Calling HasProcessScope(),\n  /// HasThreadScope(), or HasFrameScope()  can help to pre-validate this\n  /// pointer so that this accessor can freely be used without having to check\n  /// for nullptr each time.\n  ///\n  /// \\see ExecutionContext::HasProcessScope() const @see\n  /// ExecutionContext::HasThreadScope() const @see\n  /// ExecutionContext::HasFrameScope() const\n  Process *GetProcessPtr() const;\n\n  /// Returns a pointer to the thread object.\n  ///\n  /// The returned pointer might be nullptr. Calling HasThreadScope() or\n  /// HasFrameScope() can help to pre-validate this pointer so that this\n  /// accessor can freely be used without having to check for nullptr each\n  /// time.\n  ///\n  /// \\see ExecutionContext::HasThreadScope() const @see\n  /// ExecutionContext::HasFrameScope() const\n  Thread *GetThreadPtr() const { return m_thread_sp.get(); }\n\n  /// Returns a pointer to the frame object.\n  ///\n  /// The returned pointer might be nullptr. Calling HasFrameScope(), can help\n  /// to pre-validate this pointer so that this accessor can freely be used\n  /// without having to check for nullptr each time.\n  ///\n  /// \\see ExecutionContext::HasFrameScope() const\n  StackFrame *GetFramePtr() const { return m_frame_sp.get(); }\n\n  /// Returns a reference to the target object.\n  ///\n  /// Clients should call HasTargetScope(), HasProcessScope(),\n  /// HasThreadScope(), or HasFrameScope() prior to calling this function to\n  /// ensure that this ExecutionContext object contains a valid target.\n  ///\n  /// \\see ExecutionContext::HasTargetScope() const @see\n  /// ExecutionContext::HasProcessScope() const @see\n  /// ExecutionContext::HasThreadScope() const @see\n  /// ExecutionContext::HasFrameScope() const\n  Target &GetTargetRef() const;\n\n  /// Returns a reference to the process object.\n  ///\n  /// Clients should call HasProcessScope(), HasThreadScope(), or\n  /// HasFrameScope() prior to calling this  function to ensure that this\n  /// ExecutionContext object contains a valid target.\n  ///\n  /// \\see ExecutionContext::HasProcessScope() const @see\n  /// ExecutionContext::HasThreadScope() const @see\n  /// ExecutionContext::HasFrameScope() const\n  Process &GetProcessRef() const;\n\n  /// Returns a reference to the thread object.\n  ///\n  /// Clients should call HasThreadScope(), or  HasFrameScope() prior to\n  /// calling this  function to ensure that  this ExecutionContext object\n  /// contains a valid target.\n  ///\n  /// \\see ExecutionContext::HasThreadScope() const @see\n  /// ExecutionContext::HasFrameScope() const\n  Thread &GetThreadRef() const;\n\n  /// Returns a reference to the thread object.\n  ///\n  /// Clients should call HasFrameScope() prior to calling this function to\n  /// ensure that  this ExecutionContext object contains a valid target.\n  ///\n  /// \\see ExecutionContext::HasFrameScope() const\n  StackFrame &GetFrameRef() const;\n\n  /// Get accessor to get the target shared pointer.\n  ///\n  /// The returned shared pointer is not guaranteed to be valid.\n  const lldb::TargetSP &GetTargetSP() const { return m_target_sp; }\n\n  /// Get accessor to get the process shared pointer.\n  ///\n  /// The returned shared pointer is not guaranteed to be valid.\n  const lldb::ProcessSP &GetProcessSP() const { return m_process_sp; }\n\n  /// Get accessor to get the thread shared pointer.\n  ///\n  /// The returned shared pointer is not guaranteed to be valid.\n  const lldb::ThreadSP &GetThreadSP() const { return m_thread_sp; }\n\n  /// Get accessor to get the frame shared pointer.\n  ///\n  /// The returned shared pointer is not guaranteed to be valid.\n  const lldb::StackFrameSP &GetFrameSP() const { return m_frame_sp; }\n\n  /// Set accessor to set only the target shared pointer.\n  void SetTargetSP(const lldb::TargetSP &target_sp);\n\n  /// Set accessor to set only the process shared pointer.\n  void SetProcessSP(const lldb::ProcessSP &process_sp);\n\n  /// Set accessor to set only the thread shared pointer.\n  void SetThreadSP(const lldb::ThreadSP &thread_sp);\n\n  /// Set accessor to set only the frame shared pointer.\n  void SetFrameSP(const lldb::StackFrameSP &frame_sp);\n\n  /// Set accessor to set only the target shared pointer from a target\n  /// pointer.\n  void SetTargetPtr(Target *target);\n\n  /// Set accessor to set only the process shared pointer from a process\n  /// pointer.\n  void SetProcessPtr(Process *process);\n\n  /// Set accessor to set only the thread shared pointer from a thread\n  /// pointer.\n  void SetThreadPtr(Thread *thread);\n\n  /// Set accessor to set only the frame shared pointer from a frame pointer.\n  void SetFramePtr(StackFrame *frame);\n\n  // Set the execution context using a target shared pointer.\n  //\n  // If \"target_sp\" is valid, sets the target context to match and if\n  // \"get_process\" is true, sets the process shared pointer if the target\n  // currently has a process.\n  void SetContext(const lldb::TargetSP &target_sp, bool get_process);\n\n  // Set the execution context using a process shared pointer.\n  //\n  // If \"process_sp\" is valid, then set the process and target in this context.\n  // Thread and frame contexts will be cleared. If \"process_sp\" is not valid,\n  // all shared pointers are reset.\n  void SetContext(const lldb::ProcessSP &process_sp);\n\n  // Set the execution context using a thread shared pointer.\n  //\n  // If \"thread_sp\" is valid, then set the thread, process and target in this\n  // context. The frame context will be cleared. If \"thread_sp\" is not valid,\n  // all shared pointers are reset.\n  void SetContext(const lldb::ThreadSP &thread_sp);\n\n  // Set the execution context using a frame shared pointer.\n  //\n  // If \"frame_sp\" is valid, then set the frame, thread, process and target in\n  // this context If \"frame_sp\" is not valid, all shared pointers are reset.\n  void SetContext(const lldb::StackFrameSP &frame_sp);\n\n  /// Returns true the ExecutionContext object contains a valid target.\n  ///\n  /// This function can be called after initializing an ExecutionContext\n  /// object, and if it returns true, calls to GetTargetPtr() and\n  /// GetTargetRef() do not need to be checked for validity.\n  bool HasTargetScope() const;\n\n  /// Returns true the ExecutionContext object contains a valid target and\n  /// process.\n  ///\n  /// This function can be called after initializing an ExecutionContext\n  /// object, and if it returns true, calls to GetTargetPtr() and\n  /// GetTargetRef(), GetProcessPtr(), and GetProcessRef(), do not need to be\n  /// checked for validity.\n  bool HasProcessScope() const;\n\n  /// Returns true the ExecutionContext object contains a valid target,\n  /// process, and thread.\n  ///\n  /// This function can be called after initializing an ExecutionContext\n  /// object, and if it returns true, calls to GetTargetPtr(), GetTargetRef(),\n  /// GetProcessPtr(), GetProcessRef(), GetThreadPtr(), and GetThreadRef() do\n  /// not need to be checked for validity.\n  bool HasThreadScope() const;\n\n  /// Returns true the ExecutionContext object contains a valid target,\n  /// process, thread and frame.\n  ///\n  /// This function can be called after initializing an ExecutionContext\n  /// object, and if it returns true, calls to GetTargetPtr(), GetTargetRef(),\n  /// GetProcessPtr(), GetProcessRef(), GetThreadPtr(), GetThreadRef(),\n  /// GetFramePtr(), and GetFrameRef() do not need to be checked for validity.\n  bool HasFrameScope() const;\n\nprotected:\n  // Member variables\n  lldb::TargetSP m_target_sp; ///< The target that owns the process/thread/frame\n  lldb::ProcessSP m_process_sp;  ///< The process that owns the thread/frame\n  lldb::ThreadSP m_thread_sp;    ///< The thread that owns the frame\n  lldb::StackFrameSP m_frame_sp; ///< The stack frame in thread.\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_TARGET_EXECUTIONCONTEXT_H\n"}, "13": {"id": 13, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Target/Process.h", "content": "//===-- Process.h -----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_TARGET_PROCESS_H\n#define LLDB_TARGET_PROCESS_H\n\n#include \"lldb/Host/Config.h\"\n\n#include <limits.h>\n\n#include <chrono>\n#include <list>\n#include <memory>\n#include <mutex>\n#include <string>\n#include <unordered_set>\n#include <vector>\n\n#include \"lldb/Breakpoint/BreakpointSiteList.h\"\n#include \"lldb/Core/Communication.h\"\n#include \"lldb/Core/LoadedModuleInfoList.h\"\n#include \"lldb/Core/PluginInterface.h\"\n#include \"lldb/Core/ThreadSafeValue.h\"\n#include \"lldb/Core/UserSettingsController.h\"\n#include \"lldb/Host/HostThread.h\"\n#include \"lldb/Host/ProcessLaunchInfo.h\"\n#include \"lldb/Host/ProcessRunLock.h\"\n#include \"lldb/Symbol/ObjectFile.h\"\n#include \"lldb/Target/ExecutionContextScope.h\"\n#include \"lldb/Target/InstrumentationRuntime.h\"\n#include \"lldb/Target/Memory.h\"\n#include \"lldb/Target/QueueList.h\"\n#include \"lldb/Target/ThreadList.h\"\n#include \"lldb/Target/ThreadPlanStack.h\"\n#include \"lldb/Target/Trace.h\"\n#include \"lldb/Utility/ArchSpec.h\"\n#include \"lldb/Utility/Broadcaster.h\"\n#include \"lldb/Utility/Event.h\"\n#include \"lldb/Utility/Listener.h\"\n#include \"lldb/Utility/NameMatches.h\"\n#include \"lldb/Utility/ProcessInfo.h\"\n#include \"lldb/Utility/Status.h\"\n#include \"lldb/Utility/StructuredData.h\"\n#include \"lldb/Utility/TraceOptions.h\"\n#include \"lldb/Utility/UnimplementedError.h\"\n#include \"lldb/Utility/UserIDResolver.h\"\n#include \"lldb/lldb-private.h\"\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/Support/Threading.h\"\n#include \"llvm/Support/VersionTuple.h\"\n\nnamespace lldb_private {\n\ntemplate <typename B, typename S> struct Range;\n\nclass ProcessExperimentalProperties : public Properties {\npublic:\n  ProcessExperimentalProperties();\n};\n\nclass ProcessProperties : public Properties {\npublic:\n  // Pass nullptr for \"process\" if the ProcessProperties are to be the global\n  // copy\n  ProcessProperties(lldb_private::Process *process);\n\n  ~ProcessProperties() override;\n\n  bool GetDisableMemoryCache() const;\n  uint64_t GetMemoryCacheLineSize() const;\n  Args GetExtraStartupCommands() const;\n  void SetExtraStartupCommands(const Args &args);\n  FileSpec GetPythonOSPluginPath() const;\n  void SetPythonOSPluginPath(const FileSpec &file);\n  bool GetIgnoreBreakpointsInExpressions() const;\n  void SetIgnoreBreakpointsInExpressions(bool ignore);\n  bool GetUnwindOnErrorInExpressions() const;\n  void SetUnwindOnErrorInExpressions(bool ignore);\n  bool GetStopOnSharedLibraryEvents() const;\n  void SetStopOnSharedLibraryEvents(bool stop);\n  bool GetDetachKeepsStopped() const;\n  void SetDetachKeepsStopped(bool keep_stopped);\n  bool GetWarningsOptimization() const;\n  bool GetWarningsUnsupportedLanguage() const;\n  bool GetStopOnExec() const;\n  std::chrono::seconds GetUtilityExpressionTimeout() const;\n  bool GetOSPluginReportsAllThreads() const;\n  void SetOSPluginReportsAllThreads(bool does_report);\n  bool GetSteppingRunsAllThreads() const;\n\nprotected:\n  Process *m_process; // Can be nullptr for global ProcessProperties\n  std::unique_ptr<ProcessExperimentalProperties> m_experimental_properties_up;\n};\n\ntypedef std::shared_ptr<ProcessProperties> ProcessPropertiesSP;\n\n// ProcessAttachInfo\n//\n// Describes any information that is required to attach to a process.\n\nclass ProcessAttachInfo : public ProcessInstanceInfo {\npublic:\n  ProcessAttachInfo()\n      : ProcessInstanceInfo(), m_listener_sp(), m_hijack_listener_sp(),\n        m_plugin_name(), m_resume_count(0), m_wait_for_launch(false),\n        m_ignore_existing(true), m_continue_once_attached(false),\n        m_detach_on_error(true), m_async(false) {}\n\n  ProcessAttachInfo(const ProcessLaunchInfo &launch_info)\n      : ProcessInstanceInfo(), m_listener_sp(), m_hijack_listener_sp(),\n        m_plugin_name(), m_resume_count(0), m_wait_for_launch(false),\n        m_ignore_existing(true), m_continue_once_attached(false),\n        m_detach_on_error(true), m_async(false) {\n    ProcessInfo::operator=(launch_info);\n    SetProcessPluginName(launch_info.GetProcessPluginName());\n    SetResumeCount(launch_info.GetResumeCount());\n    SetListener(launch_info.GetListener());\n    SetHijackListener(launch_info.GetHijackListener());\n    m_detach_on_error = launch_info.GetDetachOnError();\n  }\n\n  bool GetWaitForLaunch() const { return m_wait_for_launch; }\n\n  void SetWaitForLaunch(bool b) { m_wait_for_launch = b; }\n\n  bool GetAsync() const { return m_async; }\n\n  void SetAsync(bool b) { m_async = b; }\n\n  bool GetIgnoreExisting() const { return m_ignore_existing; }\n\n  void SetIgnoreExisting(bool b) { m_ignore_existing = b; }\n\n  bool GetContinueOnceAttached() const { return m_continue_once_attached; }\n\n  void SetContinueOnceAttached(bool b) { m_continue_once_attached = b; }\n\n  uint32_t GetResumeCount() const { return m_resume_count; }\n\n  void SetResumeCount(uint32_t c) { m_resume_count = c; }\n\n  const char *GetProcessPluginName() const {\n    return (m_plugin_name.empty() ? nullptr : m_plugin_name.c_str());\n  }\n\n  void SetProcessPluginName(llvm::StringRef plugin) {\n    m_plugin_name = std::string(plugin);\n  }\n\n  void Clear() {\n    ProcessInstanceInfo::Clear();\n    m_plugin_name.clear();\n    m_resume_count = 0;\n    m_wait_for_launch = false;\n    m_ignore_existing = true;\n    m_continue_once_attached = false;\n  }\n\n  bool ProcessInfoSpecified() const {\n    if (GetExecutableFile())\n      return true;\n    if (GetProcessID() != LLDB_INVALID_PROCESS_ID)\n      return true;\n    if (GetParentProcessID() != LLDB_INVALID_PROCESS_ID)\n      return true;\n    return false;\n  }\n\n  lldb::ListenerSP GetHijackListener() const { return m_hijack_listener_sp; }\n\n  void SetHijackListener(const lldb::ListenerSP &listener_sp) {\n    m_hijack_listener_sp = listener_sp;\n  }\n\n  bool GetDetachOnError() const { return m_detach_on_error; }\n\n  void SetDetachOnError(bool enable) { m_detach_on_error = enable; }\n\n  // Get and set the actual listener that will be used for the process events\n  lldb::ListenerSP GetListener() const { return m_listener_sp; }\n\n  void SetListener(const lldb::ListenerSP &listener_sp) {\n    m_listener_sp = listener_sp;\n  }\n\n  lldb::ListenerSP GetListenerForProcess(Debugger &debugger);\n\nprotected:\n  lldb::ListenerSP m_listener_sp;\n  lldb::ListenerSP m_hijack_listener_sp;\n  std::string m_plugin_name;\n  uint32_t m_resume_count; // How many times do we resume after launching\n  bool m_wait_for_launch;\n  bool m_ignore_existing;\n  bool m_continue_once_attached; // Supports the use-case scenario of\n                                 // immediately continuing the process once\n                                 // attached.\n  bool m_detach_on_error; // If we are debugging remotely, instruct the stub to\n                          // detach rather than killing the target on error.\n  bool m_async; // Use an async attach where we start the attach and return\n                // immediately (used by GUI programs with --waitfor so they can\n                // call SBProcess::Stop() to cancel attach)\n};\n\n// This class tracks the Modification state of the process.  Things that can\n// currently modify the program are running the program (which will up the\n// StopID) and writing memory (which will up the MemoryID.)\n// FIXME: Should we also include modification of register states?\n\nclass ProcessModID {\n  friend bool operator==(const ProcessModID &lhs, const ProcessModID &rhs);\n\npublic:\n  ProcessModID()\n      : m_stop_id(0), m_last_natural_stop_id(0), m_resume_id(0), m_memory_id(0),\n        m_last_user_expression_resume(0), m_running_user_expression(false),\n        m_running_utility_function(0) {}\n\n  ProcessModID(const ProcessModID &rhs)\n      : m_stop_id(rhs.m_stop_id), m_memory_id(rhs.m_memory_id) {}\n\n  const ProcessModID &operator=(const ProcessModID &rhs) {\n    if (this != &rhs) {\n      m_stop_id = rhs.m_stop_id;\n      m_memory_id = rhs.m_memory_id;\n    }\n    return *this;\n  }\n\n  ~ProcessModID() = default;\n\n  void BumpStopID() {\n    m_stop_id++;\n    if (!IsLastResumeForUserExpression())\n      m_last_natural_stop_id++;\n  }\n\n  void BumpMemoryID() { m_memory_id++; }\n\n  void BumpResumeID() {\n    m_resume_id++;\n    if (m_running_user_expression > 0)\n      m_last_user_expression_resume = m_resume_id;\n  }\n\n  bool IsRunningUtilityFunction() const {\n    return m_running_utility_function > 0;\n  }\n\n  uint32_t GetStopID() const { return m_stop_id; }\n  uint32_t GetLastNaturalStopID() const { return m_last_natural_stop_id; }\n  uint32_t GetMemoryID() const { return m_memory_id; }\n  uint32_t GetResumeID() const { return m_resume_id; }\n  uint32_t GetLastUserExpressionResumeID() const {\n    return m_last_user_expression_resume;\n  }\n\n  bool MemoryIDEqual(const ProcessModID &compare) const {\n    return m_memory_id == compare.m_memory_id;\n  }\n\n  bool StopIDEqual(const ProcessModID &compare) const {\n    return m_stop_id == compare.m_stop_id;\n  }\n\n  void SetInvalid() { m_stop_id = UINT32_MAX; }\n\n  bool IsValid() const { return m_stop_id != UINT32_MAX; }\n\n  bool IsLastResumeForUserExpression() const {\n    // If we haven't yet resumed the target, then it can't be for a user\n    // expression...\n    if (m_resume_id == 0)\n      return false;\n\n    return m_resume_id == m_last_user_expression_resume;\n  }\n\n  void SetRunningUserExpression(bool on) {\n    if (on)\n      m_running_user_expression++;\n    else\n      m_running_user_expression--;\n  }\n\n  void SetRunningUtilityFunction(bool on) {\n    if (on)\n      m_running_utility_function++;\n    else {\n      assert(m_running_utility_function > 0 &&\n             \"Called SetRunningUtilityFunction(false) without calling \"\n             \"SetRunningUtilityFunction(true) before?\");\n      m_running_utility_function--;\n    }\n  }\n\n  void SetStopEventForLastNaturalStopID(lldb::EventSP event_sp) {\n    m_last_natural_stop_event = std::move(event_sp);\n  }\n\n  lldb::EventSP GetStopEventForStopID(uint32_t stop_id) const {\n    if (stop_id == m_last_natural_stop_id)\n      return m_last_natural_stop_event;\n    return lldb::EventSP();\n  }\n\nprivate:\n  uint32_t m_stop_id;\n  uint32_t m_last_natural_stop_id;\n  uint32_t m_resume_id;\n  uint32_t m_memory_id;\n  uint32_t m_last_user_expression_resume;\n  uint32_t m_running_user_expression;\n  uint32_t m_running_utility_function;\n  lldb::EventSP m_last_natural_stop_event;\n};\n\ninline bool operator==(const ProcessModID &lhs, const ProcessModID &rhs) {\n  if (lhs.StopIDEqual(rhs) && lhs.MemoryIDEqual(rhs))\n    return true;\n  else\n    return false;\n}\n\ninline bool operator!=(const ProcessModID &lhs, const ProcessModID &rhs) {\n  return (!lhs.StopIDEqual(rhs) || !lhs.MemoryIDEqual(rhs));\n}\n\n/// \\class Process Process.h \"lldb/Target/Process.h\"\n/// A plug-in interface definition class for debugging a process.\nclass Process : public std::enable_shared_from_this<Process>,\n                public ProcessProperties,\n                public Broadcaster,\n                public ExecutionContextScope,\n                public PluginInterface {\n  friend class FunctionCaller; // For WaitForStateChangeEventsPrivate\n  friend class Debugger; // For PopProcessIOHandler and ProcessIOHandlerIsActive\n  friend class DynamicLoader; // For LoadOperatingSystemPlugin\n  friend class ProcessEventData;\n  friend class StopInfo;\n  friend class Target;\n  friend class ThreadList;\n\npublic:\n  /// Broadcaster event bits definitions.\n  enum {\n    eBroadcastBitStateChanged = (1 << 0),\n    eBroadcastBitInterrupt = (1 << 1),\n    eBroadcastBitSTDOUT = (1 << 2),\n    eBroadcastBitSTDERR = (1 << 3),\n    eBroadcastBitProfileData = (1 << 4),\n    eBroadcastBitStructuredData = (1 << 5),\n  };\n\n  enum {\n    eBroadcastInternalStateControlStop = (1 << 0),\n    eBroadcastInternalStateControlPause = (1 << 1),\n    eBroadcastInternalStateControlResume = (1 << 2)\n  };\n\n  /// Process warning types.\n  enum Warnings { eWarningsOptimization = 1, eWarningsUnsupportedLanguage = 2 };\n\n  typedef Range<lldb::addr_t, lldb::addr_t> LoadRange;\n  // We use a read/write lock to allow on or more clients to access the process\n  // state while the process is stopped (reader). We lock the write lock to\n  // control access to the process while it is running (readers, or clients\n  // that want the process stopped can block waiting for the process to stop,\n  // or just try to lock it to see if they can immediately access the stopped\n  // process. If the try read lock fails, then the process is running.\n  typedef ProcessRunLock::ProcessRunLocker StopLocker;\n\n  // These two functions fill out the Broadcaster interface:\n\n  static ConstString &GetStaticBroadcasterClass();\n\n  ConstString &GetBroadcasterClass() const override {\n    return GetStaticBroadcasterClass();\n  }\n\n/// A notification structure that can be used by clients to listen\n/// for changes in a process's lifetime.\n///\n/// \\see RegisterNotificationCallbacks (const Notifications&) @see\n/// UnregisterNotificationCallbacks (const Notifications&)\n  typedef struct {\n    void *baton;\n    void (*initialize)(void *baton, Process *process);\n    void (*process_state_changed)(void *baton, Process *process,\n                                  lldb::StateType state);\n  } Notifications;\n\n  class ProcessEventData : public EventData {\n    friend class Process;\n\n  public:\n    ProcessEventData();\n    ProcessEventData(const lldb::ProcessSP &process, lldb::StateType state);\n\n    ~ProcessEventData() override;\n\n    static ConstString GetFlavorString();\n\n    ConstString GetFlavor() const override;\n\n    lldb::ProcessSP GetProcessSP() const { return m_process_wp.lock(); }\n\n    lldb::StateType GetState() const { return m_state; }\n    bool GetRestarted() const { return m_restarted; }\n\n    size_t GetNumRestartedReasons() { return m_restarted_reasons.size(); }\n\n    const char *GetRestartedReasonAtIndex(size_t idx) {\n      return ((idx < m_restarted_reasons.size())\n                  ? m_restarted_reasons[idx].c_str()\n                  : nullptr);\n    }\n\n    bool GetInterrupted() const { return m_interrupted; }\n\n    void Dump(Stream *s) const override;\n\n    virtual bool ShouldStop(Event *event_ptr, bool &found_valid_stopinfo);\n\n    void DoOnRemoval(Event *event_ptr) override;\n\n    static const Process::ProcessEventData *\n    GetEventDataFromEvent(const Event *event_ptr);\n\n    static lldb::ProcessSP GetProcessFromEvent(const Event *event_ptr);\n\n    static lldb::StateType GetStateFromEvent(const Event *event_ptr);\n\n    static bool GetRestartedFromEvent(const Event *event_ptr);\n\n    static size_t GetNumRestartedReasons(const Event *event_ptr);\n\n    static const char *GetRestartedReasonAtIndex(const Event *event_ptr,\n                                                 size_t idx);\n\n    static void AddRestartedReason(Event *event_ptr, const char *reason);\n\n    static void SetRestartedInEvent(Event *event_ptr, bool new_value);\n\n    static bool GetInterruptedFromEvent(const Event *event_ptr);\n\n    static void SetInterruptedInEvent(Event *event_ptr, bool new_value);\n\n    static bool SetUpdateStateOnRemoval(Event *event_ptr);\n\n  private:\n    void SetUpdateStateOnRemoval() { m_update_state++; }\n\n    void SetRestarted(bool new_value) { m_restarted = new_value; }\n\n    void SetInterrupted(bool new_value) { m_interrupted = new_value; }\n\n    void AddRestartedReason(const char *reason) {\n      m_restarted_reasons.push_back(reason);\n    }\n\n    lldb::ProcessWP m_process_wp;\n    lldb::StateType m_state;\n    std::vector<std::string> m_restarted_reasons;\n    bool m_restarted; // For \"eStateStopped\" events, this is true if the target\n                      // was automatically restarted.\n    int m_update_state;\n    bool m_interrupted;\n\n    ProcessEventData(const ProcessEventData &) = delete;\n    const ProcessEventData &operator=(const ProcessEventData &) = delete;\n  };\n\n  /// Construct with a shared pointer to a target, and the Process listener.\n  /// Uses the Host UnixSignalsSP by default.\n  Process(lldb::TargetSP target_sp, lldb::ListenerSP listener_sp);\n\n  /// Construct with a shared pointer to a target, the Process listener, and\n  /// the appropriate UnixSignalsSP for the process.\n  Process(lldb::TargetSP target_sp, lldb::ListenerSP listener_sp,\n          const lldb::UnixSignalsSP &unix_signals_sp);\n\n  /// Destructor.\n  ///\n  /// The destructor is virtual since this class is designed to be inherited\n  /// from by the plug-in instance.\n  ~Process() override;\n\n  static void SettingsInitialize();\n\n  static void SettingsTerminate();\n\n  static const ProcessPropertiesSP &GetGlobalProperties();\n\n  /// Find a Process plug-in that can debug \\a module using the currently\n  /// selected architecture.\n  ///\n  /// Scans all loaded plug-in interfaces that implement versions of the\n  /// Process plug-in interface and returns the first instance that can debug\n  /// the file.\n  ///\n  /// \\see Process::CanDebug ()\n  static lldb::ProcessSP FindPlugin(lldb::TargetSP target_sp,\n                                    llvm::StringRef plugin_name,\n                                    lldb::ListenerSP listener_sp,\n                                    const FileSpec *crash_file_path,\n                                    bool can_connect);\n\n  /// Static function that can be used with the \\b host function\n  /// Host::StartMonitoringChildProcess ().\n  ///\n  /// This function can be used by lldb_private::Process subclasses when they\n  /// want to watch for a local process and have its exit status automatically\n  /// set when the host child process exits. Subclasses should call\n  /// Host::StartMonitoringChildProcess () with:\n  ///     callback = Process::SetHostProcessExitStatus\n  ///     pid = Process::GetID()\n  ///     monitor_signals = false\n  static bool\n  SetProcessExitStatus(lldb::pid_t pid, // The process ID we want to monitor\n                       bool exited,\n                       int signo,   // Zero for no signal\n                       int status); // Exit value of process if signal is zero\n\n  lldb::ByteOrder GetByteOrder() const;\n\n  uint32_t GetAddressByteSize() const;\n\n  /// Sets the stored pid.\n  ///\n  /// This does not change the pid of underlying process.\n  lldb::pid_t GetID() const { return m_pid; }\n\n  /// Returns the pid of the process or LLDB_INVALID_PROCESS_ID if there is\n  /// no known pid.\n  void SetID(lldb::pid_t new_pid) { m_pid = new_pid; }\n\n  uint32_t GetUniqueID() const { return m_process_unique_id; }\n\n  /// Check if a plug-in instance can debug the file in \\a module.\n  ///\n  /// Each plug-in is given a chance to say whether it can debug the file in\n  /// \\a module. If the Process plug-in instance can debug a file on the\n  /// current system, it should return \\b true.\n  ///\n  /// \\return\n  ///     Returns \\b true if this Process plug-in instance can\n  ///     debug the executable, \\b false otherwise.\n  virtual bool CanDebug(lldb::TargetSP target,\n                        bool plugin_specified_by_name) = 0;\n\n  /// This object is about to be destroyed, do any necessary cleanup.\n  ///\n  /// Subclasses that override this method should always call this superclass\n  /// method.\n  virtual void Finalize();\n\n  /// Return whether this object is valid (i.e. has not been finalized.)\n  ///\n  /// \\return\n  ///     Returns \\b true if this Process has not been finalized\n  ///     and \\b false otherwise.\n  bool IsValid() const { return !m_finalizing; }\n\n  /// Return a multi-word command object that can be used to expose plug-in\n  /// specific commands.\n  ///\n  /// This object will be used to resolve plug-in commands and can be\n  /// triggered by a call to:\n  ///\n  ///     (lldb) process command <args>\n  ///\n  /// \\return\n  ///     A CommandObject which can be one of the concrete subclasses\n  ///     of CommandObject like CommandObjectRaw, CommandObjectParsed,\n  ///     or CommandObjectMultiword.\n  virtual CommandObject *GetPluginCommandObject() { return nullptr; }\n\n  /// Launch a new process.\n  ///\n  /// Launch a new process by spawning a new process using the target object's\n  /// executable module's file as the file to launch.\n  ///\n  /// This function is not meant to be overridden by Process subclasses. It\n  /// will first call Process::WillLaunch (Module *) and if that returns \\b\n  /// true, Process::DoLaunch (Module*, char const *[],char const *[],const\n  /// char *,const char *, const char *) will be called to actually do the\n  /// launching. If DoLaunch returns \\b true, then Process::DidLaunch() will\n  /// be called.\n  ///\n  /// \\param[in] launch_info\n  ///     Details regarding the environment, STDIN/STDOUT/STDERR\n  ///     redirection, working path, etc. related to the requested launch.\n  ///\n  /// \\return\n  ///     An error object. Call GetID() to get the process ID if\n  ///     the error object is success.\n  virtual Status Launch(ProcessLaunchInfo &launch_info);\n\n  virtual Status LoadCore();\n\n  virtual Status DoLoadCore() {\n    Status error;\n    error.SetErrorStringWithFormat(\n        \"error: %s does not support loading core files.\",\n        GetPluginName().GetCString());\n    return error;\n  }\n\n  // FUTURE WORK: GetLoadImageUtilityFunction are the first use we've\n  // had of having other plugins cache data in the Process.  This is handy for\n  // long-living plugins - like the Platform - which manage interactions whose\n  // lifetime is governed by the Process lifetime.  If we find we need to do\n  // this more often, we should construct a general solution to the problem.\n  // The consensus suggestion was that we have a token based registry in the\n  // Process. Some undecided questions are  (1) who manages the tokens.  It's\n  // probably best that you add the element  and get back a token that\n  // represents it.  That will avoid collisions.  But there may be some utility\n  // in the registerer controlling the token? (2) whether the thing added\n  // should be simply owned by Process, and just go away when it does (3)\n  // whether the registree should be notified of the Process' demise.\n  //\n  // We are postponing designing this till we have at least a second use case.\n  /// Get the cached UtilityFunction that assists in loading binary images\n  /// into the process.\n  ///\n  /// \\param[in] platform\n  ///     The platform fetching the UtilityFunction.\n  /// \\param[in] factory\n  ///     A function that will be called only once per-process in a\n  ///     thread-safe way to create the UtilityFunction if it has not\n  ///     been initialized yet.\n  ///\n  /// \\return\n  ///     The cached utility function or null if the platform is not the\n  ///     same as the target's platform.\n  UtilityFunction *GetLoadImageUtilityFunction(\n      Platform *platform,\n      llvm::function_ref<std::unique_ptr<UtilityFunction>()> factory);\n\n  /// Get the dynamic loader plug-in for this process.\n  ///\n  /// The default action is to let the DynamicLoader plug-ins check the main\n  /// executable and the DynamicLoader will select itself automatically.\n  /// Subclasses can override this if inspecting the executable is not\n  /// desired, or if Process subclasses can only use a specific DynamicLoader\n  /// plug-in.\n  virtual DynamicLoader *GetDynamicLoader();\n\n  // Returns AUXV structure found in many ELF-based environments.\n  //\n  // The default action is to return an empty data buffer.\n  //\n  // \\return\n  //    A data extractor containing the contents of the AUXV data.\n  virtual DataExtractor GetAuxvData();\n\n  /// Sometimes processes know how to retrieve and load shared libraries. This\n  /// is normally done by DynamicLoader plug-ins, but sometimes the connection\n  /// to the process allows retrieving this information. The dynamic loader\n  /// plug-ins can use this function if they can't determine the current\n  /// shared library load state.\n  ///\n  /// \\return\n  ///    A status object indicating if the operation was sucessful or not.\n  virtual llvm::Error LoadModules() {\n    return llvm::make_error<llvm::StringError>(\"Not implemented.\",\n                                               llvm::inconvertibleErrorCode());\n  }\n\n  /// Query remote GDBServer for a detailed loaded library list\n  /// \\return\n  ///    The list of modules currently loaded by the process, or an error.\n  virtual llvm::Expected<LoadedModuleInfoList> GetLoadedModuleList() {\n    return llvm::createStringError(llvm::inconvertibleErrorCode(),\n                                   \"Not implemented\");\n  }\n\nprotected:\n  virtual JITLoaderList &GetJITLoaders();\n\npublic:\n  /// Get the system runtime plug-in for this process.\n  ///\n  /// \\return\n  ///   Returns a pointer to the SystemRuntime plugin for this Process\n  ///   if one is available.  Else returns nullptr.\n  virtual SystemRuntime *GetSystemRuntime();\n\n  /// Attach to an existing process using the process attach info.\n  ///\n  /// This function is not meant to be overridden by Process subclasses. It\n  /// will first call WillAttach (lldb::pid_t) or WillAttach (const char *),\n  /// and if that returns \\b true, DoAttach (lldb::pid_t) or DoAttach (const\n  /// char *) will be called to actually do the attach. If DoAttach returns \\b\n  /// true, then Process::DidAttach() will be called.\n  ///\n  /// \\param[in] attach_info\n  ///     The process attach info.\n  ///\n  /// \\return\n  ///     Returns \\a pid if attaching was successful, or\n  ///     LLDB_INVALID_PROCESS_ID if attaching fails.\n  virtual Status Attach(ProcessAttachInfo &attach_info);\n\n  /// Attach to a remote system via a URL\n  ///\n  /// \\param[in] remote_url\n  ///     The URL format that we are connecting to.\n  ///\n  /// \\return\n  ///     Returns an error object.\n  virtual Status ConnectRemote(llvm::StringRef remote_url);\n\n  bool GetShouldDetach() const { return m_should_detach; }\n\n  void SetShouldDetach(bool b) { m_should_detach = b; }\n\n  /// Get the image vector for the current process.\n  ///\n  /// \\return\n  ///     The constant reference to the member m_image_tokens.\n  const std::vector<lldb::addr_t>& GetImageTokens() { return m_image_tokens; }\n\n  /// Get the image information address for the current process.\n  ///\n  /// Some runtimes have system functions that can help dynamic loaders locate\n  /// the dynamic loader information needed to observe shared libraries being\n  /// loaded or unloaded. This function is in the Process interface (as\n  /// opposed to the DynamicLoader interface) to ensure that remote debugging\n  /// can take advantage of this functionality.\n  ///\n  /// \\return\n  ///     The address of the dynamic loader information, or\n  ///     LLDB_INVALID_ADDRESS if this is not supported by this\n  ///     interface.\n  virtual lldb::addr_t GetImageInfoAddress();\n\n  /// Called when the process is about to broadcast a public stop.\n  ///\n  /// There are public and private stops. Private stops are when the process\n  /// is doing things like stepping and the client doesn't need to know about\n  /// starts and stop that implement a thread plan. Single stepping over a\n  /// source line in code might end up being implemented by one or more\n  /// process starts and stops. Public stops are when clients will be notified\n  /// that the process is stopped. These events typically trigger UI updates\n  /// (thread stack frames to be displayed, variables to be displayed, and\n  /// more). This function can be overriden and allows process subclasses to\n  /// do something before the eBroadcastBitStateChanged event is sent to\n  /// public clients.\n  virtual void WillPublicStop() {}\n\n/// Register for process and thread notifications.\n///\n/// Clients can register notification callbacks by filling out a\n/// Process::Notifications structure and calling this function.\n///\n/// \\param[in] callbacks\n///     A structure that contains the notification baton and\n///     callback functions.\n///\n/// \\see Process::Notifications\n  void RegisterNotificationCallbacks(const Process::Notifications &callbacks);\n\n/// Unregister for process and thread notifications.\n///\n/// Clients can unregister notification callbacks by passing a copy of the\n/// original baton and callbacks in \\a callbacks.\n///\n/// \\param[in] callbacks\n///     A structure that contains the notification baton and\n///     callback functions.\n///\n/// \\return\n///     Returns \\b true if the notification callbacks were\n///     successfully removed from the process, \\b false otherwise.\n///\n/// \\see Process::Notifications\n  bool UnregisterNotificationCallbacks(const Process::Notifications &callbacks);\n\n  //==================================================================\n  // Built in Process Control functions\n  //==================================================================\n  /// Resumes all of a process's threads as configured using the Thread run\n  /// control functions.\n  ///\n  /// Threads for a process should be updated with one of the run control\n  /// actions (resume, step, or suspend) that they should take when the\n  /// process is resumed. If no run control action is given to a thread it\n  /// will be resumed by default.\n  ///\n  /// This function is not meant to be overridden by Process subclasses. This\n  /// function will take care of disabling any breakpoints that threads may be\n  /// stopped at, single stepping, and re-enabling breakpoints, and enabling\n  /// the basic flow control that the plug-in instances need not worry about.\n  ///\n  /// N.B. This function also sets the Write side of the Run Lock, which is\n  /// unset when the corresponding stop event is pulled off the Public Event\n  /// Queue.  If you need to resume the process without setting the Run Lock,\n  /// use PrivateResume (though you should only do that from inside the\n  /// Process class.\n  ///\n  /// \\return\n  ///     Returns an error object.\n  ///\n  /// \\see Thread:Resume()\n  /// \\see Thread:Step()\n  /// \\see Thread:Suspend()\n  Status Resume();\n\n  Status ResumeSynchronous(Stream *stream);\n\n  /// Halts a running process.\n  ///\n  /// This function is not meant to be overridden by Process subclasses. If\n  /// the process is successfully halted, a eStateStopped process event with\n  /// GetInterrupted will be broadcast.  If false, we will halt the process\n  /// with no events generated by the halt.\n  ///\n  /// \\param[in] clear_thread_plans\n  ///     If true, when the process stops, clear all thread plans.\n  ///\n  /// \\param[in] use_run_lock\n  ///     Whether to release the run lock after the stop.\n  ///\n  /// \\return\n  ///     Returns an error object.  If the error is empty, the process is\n  ///     halted.\n  ///     otherwise the halt has failed.\n  Status Halt(bool clear_thread_plans = false, bool use_run_lock = true);\n\n  /// Detaches from a running or stopped process.\n  ///\n  /// This function is not meant to be overridden by Process subclasses.\n  ///\n  /// \\param[in] keep_stopped\n  ///     If true, don't resume the process on detach.\n  ///\n  /// \\return\n  ///     Returns an error object.\n  Status Detach(bool keep_stopped);\n\n  /// Kills the process and shuts down all threads that were spawned to track\n  /// and monitor the process.\n  ///\n  /// This function is not meant to be overridden by Process subclasses.\n  ///\n  /// \\param[in] force_kill\n  ///     Whether lldb should force a kill (instead of a detach) from\n  ///     the inferior process.  Normally if lldb launched a binary and\n  ///     Destory is called, lldb kills it.  If lldb attached to a\n  ///     running process and Destory is called, lldb detaches.  If\n  ///     this behavior needs to be over-ridden, this is the bool that\n  ///     can be used.\n  ///\n  /// \\return\n  ///     Returns an error object.\n  Status Destroy(bool force_kill);\n\n  /// Sends a process a UNIX signal \\a signal.\n  ///\n  /// This function is not meant to be overridden by Process subclasses.\n  ///\n  /// \\return\n  ///     Returns an error object.\n  Status Signal(int signal);\n\n  void SetUnixSignals(lldb::UnixSignalsSP &&signals_sp);\n\n  const lldb::UnixSignalsSP &GetUnixSignals();\n\n  //==================================================================\n  // Plug-in Process Control Overrides\n  //==================================================================\n\n  /// Called before attaching to a process.\n  ///\n  /// Allow Process plug-ins to execute some code before attaching a process.\n  ///\n  /// \\return\n  ///     Returns an error object.\n  virtual Status WillAttachToProcessWithID(lldb::pid_t pid) { return Status(); }\n\n  /// Called before attaching to a process.\n  ///\n  /// Allow Process plug-ins to execute some code before attaching a process.\n  ///\n  /// \\return\n  ///     Returns an error object.\n  virtual Status WillAttachToProcessWithName(const char *process_name,\n                                             bool wait_for_launch) {\n    return Status();\n  }\n\n  /// Attach to a remote system via a URL\n  ///\n  /// \\param[in] remote_url\n  ///     The URL format that we are connecting to.\n  ///\n  /// \\return\n  ///     Returns an error object.\n  virtual Status DoConnectRemote(llvm::StringRef remote_url) {\n    Status error;\n    error.SetErrorString(\"remote connections are not supported\");\n    return error;\n  }\n\n  /// Attach to an existing process using a process ID.\n  ///\n  /// \\param[in] pid\n  ///     The process ID that we should attempt to attach to.\n  ///\n  /// \\param[in] attach_info\n  ///     Information on how to do the attach. For example, GetUserID()\n  ///     will return the uid to attach as.\n  ///\n  /// \\return\n  ///     Returns a successful Status attaching was successful, or\n  ///     an appropriate (possibly platform-specific) error code if\n  ///     attaching fails.\n  /// hanming : need flag\n  virtual Status DoAttachToProcessWithID(lldb::pid_t pid,\n                                         const ProcessAttachInfo &attach_info) {\n    Status error;\n    error.SetErrorStringWithFormat(\n        \"error: %s does not support attaching to a process by pid\",\n        GetPluginName().GetCString());\n    return error;\n  }\n\n  /// Attach to an existing process using a partial process name.\n  ///\n  /// \\param[in] process_name\n  ///     The name of the process to attach to.\n  ///\n  /// \\param[in] attach_info\n  ///     Information on how to do the attach. For example, GetUserID()\n  ///     will return the uid to attach as.\n  ///\n  /// \\return\n  ///     Returns a successful Status attaching was successful, or\n  ///     an appropriate (possibly platform-specific) error code if\n  ///     attaching fails.\n  virtual Status\n  DoAttachToProcessWithName(const char *process_name,\n                            const ProcessAttachInfo &attach_info) {\n    Status error;\n    error.SetErrorString(\"attach by name is not supported\");\n    return error;\n  }\n\n  /// Called after attaching a process.\n  ///\n  /// \\param[in] process_arch\n  ///     If you can figure out the process architecture after attach, fill it\n  ///     in here.\n  ///\n  /// Allow Process plug-ins to execute some code after attaching to a\n  /// process.\n  virtual void DidAttach(ArchSpec &process_arch) { process_arch.Clear(); }\n\n  /// Called after a process re-execs itself.\n  ///\n  /// Allow Process plug-ins to execute some code after a process has exec'ed\n  /// itself. Subclasses typically should override DoDidExec() as the\n  /// lldb_private::Process class needs to remove its dynamic loader, runtime,\n  /// ABI and other plug-ins, as well as unload all shared libraries.\n  virtual void DidExec();\n\n  /// Subclasses of Process should implement this function if they need to do\n  /// anything after a process exec's itself.\n  virtual void DoDidExec() {}\n\n  /// Called before launching to a process.\n  ///\n  /// Allow Process plug-ins to execute some code before launching a process.\n  ///\n  /// \\return\n  ///     Returns an error object.\n  virtual Status WillLaunch(Module *module) { return Status(); }\n\n  /// Launch a new process.\n  ///\n  /// Launch a new process by spawning a new process using \\a exe_module's\n  /// file as the file to launch. Launch details are provided in \\a\n  /// launch_info.\n  ///\n  /// \\param[in] exe_module\n  ///     The module from which to extract the file specification and\n  ///     launch.\n  ///\n  /// \\param[in] launch_info\n  ///     Details (e.g. arguments, stdio redirection, etc.) for the\n  ///     requested launch.\n  ///\n  /// \\return\n  ///     An Status instance indicating success or failure of the\n  ///     operation.\n  virtual Status DoLaunch(Module *exe_module, ProcessLaunchInfo &launch_info) {\n    Status error;\n    error.SetErrorStringWithFormat(\n        \"error: %s does not support launching processes\",\n        GetPluginName().GetCString());\n    return error;\n  }\n\n  /// Called after launching a process.\n  ///\n  /// Allow Process plug-ins to execute some code after launching a process.\n  virtual void DidLaunch() {}\n\n  /// Called before resuming to a process.\n  ///\n  /// Allow Process plug-ins to execute some code before resuming a process.\n  ///\n  /// \\return\n  ///     Returns an error object.\n  virtual Status WillResume() { return Status(); }\n\n  /// Resumes all of a process's threads as configured using the Thread run\n  /// control functions.\n  ///\n  /// Threads for a process should be updated with one of the run control\n  /// actions (resume, step, or suspend) that they should take when the\n  /// process is resumed. If no run control action is given to a thread it\n  /// will be resumed by default.\n  ///\n  /// \\return\n  ///     Returns \\b true if the process successfully resumes using\n  ///     the thread run control actions, \\b false otherwise.\n  ///\n  /// \\see Thread:Resume()\n  /// \\see Thread:Step()\n  /// \\see Thread:Suspend()\n  virtual Status DoResume() {\n    Status error;\n    error.SetErrorStringWithFormat(\n        \"error: %s does not support resuming processes\",\n        GetPluginName().GetCString());\n    return error;\n  }\n\n  /// Called after resuming a process.\n  ///\n  /// Allow Process plug-ins to execute some code after resuming a process.\n  virtual void DidResume() {}\n\n  /// Called before halting to a process.\n  ///\n  /// Allow Process plug-ins to execute some code before halting a process.\n  ///\n  /// \\return\n  ///     Returns an error object.\n  virtual Status WillHalt() { return Status(); }\n\n  /// Halts a running process.\n  ///\n  /// DoHalt must produce one and only one stop StateChanged event if it\n  /// actually stops the process.  If the stop happens through some natural\n  /// event (for instance a SIGSTOP), then forwarding that event will do.\n  /// Otherwise, you must generate the event manually. This function is called\n  /// from the context of the private state thread.\n  ///\n  /// \\param[out] caused_stop\n  ///     If true, then this Halt caused the stop, otherwise, the\n  ///     process was already stopped.\n  ///\n  /// \\return\n  ///     Returns \\b true if the process successfully halts, \\b false\n  ///     otherwise.\n  virtual Status DoHalt(bool &caused_stop) {\n    Status error;\n    error.SetErrorStringWithFormat(\n        \"error: %s does not support halting processes\",\n        GetPluginName().GetCString());\n    return error;\n  }\n\n  /// Called after halting a process.\n  ///\n  /// Allow Process plug-ins to execute some code after halting a process.\n  virtual void DidHalt() {}\n\n  /// Called before detaching from a process.\n  ///\n  /// Allow Process plug-ins to execute some code before detaching from a\n  /// process.\n  ///\n  /// \\return\n  ///     Returns an error object.\n  virtual Status WillDetach() { return Status(); }\n\n  /// Detaches from a running or stopped process.\n  ///\n  /// \\return\n  ///     Returns \\b true if the process successfully detaches, \\b\n  ///     false otherwise.\n  virtual Status DoDetach(bool keep_stopped) {\n    Status error;\n    error.SetErrorStringWithFormat(\n        \"error: %s does not support detaching from processes\",\n        GetPluginName().GetCString());\n    return error;\n  }\n\n  /// Called after detaching from a process.\n  ///\n  /// Allow Process plug-ins to execute some code after detaching from a\n  /// process.\n  virtual void DidDetach() {}\n\n  virtual bool DetachRequiresHalt() { return false; }\n\n  /// Called before sending a signal to a process.\n  ///\n  /// Allow Process plug-ins to execute some code before sending a signal to a\n  /// process.\n  ///\n  /// \\return\n  ///     Returns no error if it is safe to proceed with a call to\n  ///     Process::DoSignal(int), otherwise an error describing what\n  ///     prevents the signal from being sent.\n  virtual Status WillSignal() { return Status(); }\n\n  /// Sends a process a UNIX signal \\a signal.\n  ///\n  /// \\return\n  ///     Returns an error object.\n  virtual Status DoSignal(int signal) {\n    Status error;\n    error.SetErrorStringWithFormat(\n        \"error: %s does not support sending signals to processes\",\n        GetPluginName().GetCString());\n    return error;\n  }\n\n  virtual Status WillDestroy() { return Status(); }\n\n  virtual Status DoDestroy() = 0;\n\n  virtual void DidDestroy() {}\n\n  virtual bool DestroyRequiresHalt() { return true; }\n\n  /// Called after sending a signal to a process.\n  ///\n  /// Allow Process plug-ins to execute some code after sending a signal to a\n  /// process.\n  virtual void DidSignal() {}\n\n  /// Currently called as part of ShouldStop.\n  /// FIXME: Should really happen when the target stops before the\n  /// event is taken from the queue...\n  ///\n  /// This callback is called as the event\n  /// is about to be queued up to allow Process plug-ins to execute some code\n  /// prior to clients being notified that a process was stopped. Common\n  /// operations include updating the thread list, invalidating any thread\n  /// state (registers, stack, etc) prior to letting the notification go out.\n  ///\n  virtual void RefreshStateAfterStop() = 0;\n\n  /// Sometimes the connection to a process can detect the host OS version\n  /// that the process is running on. The current platform should be checked\n  /// first in case the platform is connected, but clients can fall back onto\n  /// this function if the platform fails to identify the host OS version. The\n  /// platform should be checked first in case you are running a simulator\n  /// platform that might itself be running natively, but have different\n  /// heuristics for figuring out which OS is is emulating.\n  ///\n  /// \\return\n  ///     Returns the version tuple of the host OS. In case of failure an empty\n  ///     VersionTuple is returner.\n  virtual llvm::VersionTuple GetHostOSVersion() { return llvm::VersionTuple(); }\n\n  /// \\return the macCatalyst version of the host OS.\n  virtual llvm::VersionTuple GetHostMacCatalystVersion() { return {}; }\n\n  /// Get the target object pointer for this module.\n  ///\n  /// \\return\n  ///     A Target object pointer to the target that owns this\n  ///     module.\n  Target &GetTarget() { return *m_target_wp.lock(); }\n\n  /// Get the const target object pointer for this module.\n  ///\n  /// \\return\n  ///     A const Target object pointer to the target that owns this\n  ///     module.\n  const Target &GetTarget() const { return *m_target_wp.lock(); }\n\n  /// Flush all data in the process.\n  ///\n  /// Flush the memory caches, all threads, and any other cached data in the\n  /// process.\n  ///\n  /// This function can be called after a world changing event like adding a\n  /// new symbol file, or after the process makes a large context switch (from\n  /// boot ROM to booted into an OS).\n  void Flush();\n\n  /// Get accessor for the current process state.\n  ///\n  /// \\return\n  ///     The current state of the process.\n  ///\n  /// \\see lldb::StateType\n  lldb::StateType GetState();\n\n  lldb::ExpressionResults\n  RunThreadPlan(ExecutionContext &exe_ctx, lldb::ThreadPlanSP &thread_plan_sp,\n                const EvaluateExpressionOptions &options,\n                DiagnosticManager &diagnostic_manager);\n\n  static const char *ExecutionResultAsCString(lldb::ExpressionResults result);\n\n  void GetStatus(Stream &ostrm);\n\n  size_t GetThreadStatus(Stream &ostrm, bool only_threads_with_stop_reason,\n                         uint32_t start_frame, uint32_t num_frames,\n                         uint32_t num_frames_with_source,\n                         bool stop_format);\n\n  void SendAsyncInterrupt();\n\n  // Notify this process class that modules got loaded.\n  //\n  // If subclasses override this method, they must call this version before\n  // doing anything in the subclass version of the function.\n  virtual void ModulesDidLoad(ModuleList &module_list);\n\n  /// Retrieve the list of shared libraries that are loaded for this process\n  /// This method is used on pre-macOS 10.12, pre-iOS 10, pre-tvOS 10, pre-\n  /// watchOS 3 systems.  The following two methods are for newer versions of\n  /// those OSes.\n  ///\n  /// For certain platforms, the time it takes for the DynamicLoader plugin to\n  /// read all of the shared libraries out of memory over a slow communication\n  /// channel may be too long.  In that instance, the gdb-remote stub may be\n  /// able to retrieve the necessary information about the solibs out of\n  /// memory and return a concise summary sufficient for the DynamicLoader\n  /// plugin.\n  ///\n  /// \\param [in] image_list_address\n  ///     The address where the table of shared libraries is stored in memory,\n  ///     if that is appropriate for this platform.  Else this may be\n  ///     passed as LLDB_INVALID_ADDRESS.\n  ///\n  /// \\param [in] image_count\n  ///     The number of shared libraries that are present in this process, if\n  ///     that is appropriate for this platofrm  Else this may be passed as\n  ///     LLDB_INVALID_ADDRESS.\n  ///\n  /// \\return\n  ///     A StructuredDataSP object which, if non-empty, will contain the\n  ///     information the DynamicLoader needs to get the initial scan of\n  ///     solibs resolved.\n  virtual lldb_private::StructuredData::ObjectSP\n  GetLoadedDynamicLibrariesInfos(lldb::addr_t image_list_address,\n                                 lldb::addr_t image_count) {\n    return StructuredData::ObjectSP();\n  }\n\n  // On macOS 10.12, tvOS 10, iOS 10, watchOS 3 and newer, debugserver can\n  // return the full list of loaded shared libraries without needing any input.\n  virtual lldb_private::StructuredData::ObjectSP\n  GetLoadedDynamicLibrariesInfos() {\n    return StructuredData::ObjectSP();\n  }\n\n  // On macOS 10.12, tvOS 10, iOS 10, watchOS 3 and newer, debugserver can\n  // return information about binaries given their load addresses.\n  virtual lldb_private::StructuredData::ObjectSP GetLoadedDynamicLibrariesInfos(\n      const std::vector<lldb::addr_t> &load_addresses) {\n    return StructuredData::ObjectSP();\n  }\n\n  // Get information about the library shared cache, if that exists\n  //\n  // On macOS 10.12, tvOS 10, iOS 10, watchOS 3 and newer, debugserver can\n  // return information about the library shared cache (a set of standard\n  // libraries that are loaded at the same location for all processes on a\n  // system) in use.\n  virtual lldb_private::StructuredData::ObjectSP GetSharedCacheInfo() {\n    return StructuredData::ObjectSP();\n  }\n\n  /// Print a user-visible warning about a module being built with\n  /// optimization\n  ///\n  /// Prints a async warning message to the user one time per Module where a\n  /// function is found that was compiled with optimization, per Process.\n  ///\n  /// \\param [in] sc\n  ///     A SymbolContext with eSymbolContextFunction and eSymbolContextModule\n  ///     pre-computed.\n  void PrintWarningOptimization(const SymbolContext &sc);\n\n  /// Print a user-visible warning about a function written in a\n  /// language that this version of LLDB doesn't support.\n  ///\n  /// \\see PrintWarningOptimization\n  void PrintWarningUnsupportedLanguage(const SymbolContext &sc);\n\n  virtual bool GetProcessInfo(ProcessInstanceInfo &info);\n\n  /// Get the exit status for a process.\n  ///\n  /// \\return\n  ///     The process's return code, or -1 if the current process\n  ///     state is not eStateExited.\n  int GetExitStatus();\n\n  /// Get a textual description of what the process exited.\n  ///\n  /// \\return\n  ///     The textual description of why the process exited, or nullptr\n  ///     if there is no description available.\n  const char *GetExitDescription();\n\n  virtual void DidExit() {}\n\n  /// Get the Modification ID of the process.\n  ///\n  /// \\return\n  ///     The modification ID of the process.\n  ProcessModID GetModID() const { return m_mod_id; }\n\n  const ProcessModID &GetModIDRef() const { return m_mod_id; }\n\n  uint32_t GetStopID() const { return m_mod_id.GetStopID(); }\n\n  uint32_t GetResumeID() const { return m_mod_id.GetResumeID(); }\n\n  uint32_t GetLastUserExpressionResumeID() const {\n    return m_mod_id.GetLastUserExpressionResumeID();\n  }\n\n  uint32_t GetLastNaturalStopID() const {\n    return m_mod_id.GetLastNaturalStopID();\n  }\n\n  lldb::EventSP GetStopEventForStopID(uint32_t stop_id) const {\n    return m_mod_id.GetStopEventForStopID(stop_id);\n  }\n\n  /// Set accessor for the process exit status (return code).\n  ///\n  /// Sometimes a child exits and the exit can be detected by global functions\n  /// (signal handler for SIGCHLD for example). This accessor allows the exit\n  /// status to be set from an external source.\n  ///\n  /// Setting this will cause a eStateExited event to be posted to the process\n  /// event queue.\n  ///\n  /// \\param[in] exit_status\n  ///     The value for the process's return code.\n  ///\n  /// \\see lldb::StateType\n  virtual bool SetExitStatus(int exit_status, const char *cstr);\n\n  /// Check if a process is still alive.\n  ///\n  /// \\return\n  ///     Returns \\b true if the process is still valid, \\b false\n  ///     otherwise.\n  virtual bool IsAlive();\n\n  virtual bool IsLiveDebugSession() const { return true; };\n\n  /// Before lldb detaches from a process, it warns the user that they are\n  /// about to lose their debug session. In some cases, this warning doesn't\n  /// need to be emitted -- for instance, with core file debugging where the\n  /// user can reconstruct the \"state\" by simply re-running the debugger on\n  /// the core file.\n  ///\n  /// \\return\n  ///     Returns \\b true if the user should be warned about detaching from\n  ///     this process.\n  virtual bool WarnBeforeDetach() const { return true; }\n\n  /// Read of memory from a process.\n  ///\n  /// This function will read memory from the current process's address space\n  /// and remove any traps that may have been inserted into the memory.\n  ///\n  /// This function is not meant to be overridden by Process subclasses, the\n  /// subclasses should implement Process::DoReadMemory (lldb::addr_t, size_t,\n  /// void *).\n  ///\n  /// \\param[in] vm_addr\n  ///     A virtual load address that indicates where to start reading\n  ///     memory from.\n  ///\n  /// \\param[out] buf\n  ///     A byte buffer that is at least \\a size bytes long that\n  ///     will receive the memory bytes.\n  ///\n  /// \\param[in] size\n  ///     The number of bytes to read.\n  ///\n  /// \\param[out] error\n  ///     An error that indicates the success or failure of this\n  ///     operation. If error indicates success (error.Success()),\n  ///     then the value returned can be trusted, otherwise zero\n  ///     will be returned.\n  ///\n  /// \\return\n  ///     The number of bytes that were actually read into \\a buf. If\n  ///     the returned number is greater than zero, yet less than \\a\n  ///     size, then this function will get called again with \\a\n  ///     vm_addr, \\a buf, and \\a size updated appropriately. Zero is\n  ///     returned in the case of an error.\n  virtual size_t ReadMemory(lldb::addr_t vm_addr, void *buf, size_t size,\n                            Status &error);\n\n  /// Read of memory from a process.\n  ///\n  /// This function has the same semantics of ReadMemory except that it\n  /// bypasses caching.\n  ///\n  /// \\param[in] vm_addr\n  ///     A virtual load address that indicates where to start reading\n  ///     memory from.\n  ///\n  /// \\param[out] buf\n  ///     A byte buffer that is at least \\a size bytes long that\n  ///     will receive the memory bytes.\n  ///\n  /// \\param[in] size\n  ///     The number of bytes to read.\n  ///\n  /// \\param[out] error\n  ///     An error that indicates the success or failure of this\n  ///     operation. If error indicates success (error.Success()),\n  ///     then the value returned can be trusted, otherwise zero\n  ///     will be returned.\n  ///\n  /// \\return\n  ///     The number of bytes that were actually read into \\a buf. If\n  ///     the returned number is greater than zero, yet less than \\a\n  ///     size, then this function will get called again with \\a\n  ///     vm_addr, \\a buf, and \\a size updated appropriately. Zero is\n  ///     returned in the case of an error.\n  size_t ReadMemoryFromInferior(lldb::addr_t vm_addr, void *buf, size_t size,\n                                Status &error);\n\n  /// Read a NULL terminated string from memory\n  ///\n  /// This function will read a cache page at a time until a NULL string\n  /// terminator is found. It will stop reading if an aligned sequence of NULL\n  /// termination \\a type_width bytes is not found before reading \\a\n  /// cstr_max_len bytes.  The results are always guaranteed to be NULL\n  /// terminated, and that no more than (max_bytes - type_width) bytes will be\n  /// read.\n  ///\n  /// \\param[in] vm_addr\n  ///     The virtual load address to start the memory read.\n  ///\n  /// \\param[in] str\n  ///     A character buffer containing at least max_bytes.\n  ///\n  /// \\param[in] max_bytes\n  ///     The maximum number of bytes to read.\n  ///\n  /// \\param[in] error\n  ///     The error status of the read operation.\n  ///\n  /// \\param[in] type_width\n  ///     The size of the null terminator (1 to 4 bytes per\n  ///     character).  Defaults to 1.\n  ///\n  /// \\return\n  ///     The error status or the number of bytes prior to the null terminator.\n  size_t ReadStringFromMemory(lldb::addr_t vm_addr, char *str, size_t max_bytes,\n                              Status &error, size_t type_width = 1);\n\n  /// Read a NULL terminated C string from memory\n  ///\n  /// This function will read a cache page at a time until the NULL\n  /// C string terminator is found. It will stop reading if the NULL\n  /// termination byte isn't found before reading \\a cstr_max_len bytes, and\n  /// the results are always guaranteed to be NULL terminated (at most\n  /// cstr_max_len - 1 bytes will be read).\n  size_t ReadCStringFromMemory(lldb::addr_t vm_addr, char *cstr,\n                               size_t cstr_max_len, Status &error);\n\n  size_t ReadCStringFromMemory(lldb::addr_t vm_addr, std::string &out_str,\n                               Status &error);\n\n  /// Reads an unsigned integer of the specified byte size from process\n  /// memory.\n  ///\n  /// \\param[in] load_addr\n  ///     A load address of the integer to read.\n  ///\n  /// \\param[in] byte_size\n  ///     The size in byte of the integer to read.\n  ///\n  /// \\param[in] fail_value\n  ///     The value to return if we fail to read an integer.\n  ///\n  /// \\param[out] error\n  ///     An error that indicates the success or failure of this\n  ///     operation. If error indicates success (error.Success()),\n  ///     then the value returned can be trusted, otherwise zero\n  ///     will be returned.\n  ///\n  /// \\return\n  ///     The unsigned integer that was read from the process memory\n  ///     space. If the integer was smaller than a uint64_t, any\n  ///     unused upper bytes will be zero filled. If the process\n  ///     byte order differs from the host byte order, the integer\n  ///     value will be appropriately byte swapped into host byte\n  ///     order.\n  uint64_t ReadUnsignedIntegerFromMemory(lldb::addr_t load_addr,\n                                         size_t byte_size, uint64_t fail_value,\n                                         Status &error);\n\n  int64_t ReadSignedIntegerFromMemory(lldb::addr_t load_addr, size_t byte_size,\n                                      int64_t fail_value, Status &error);\n\n  lldb::addr_t ReadPointerFromMemory(lldb::addr_t vm_addr, Status &error);\n\n  bool WritePointerToMemory(lldb::addr_t vm_addr, lldb::addr_t ptr_value,\n                            Status &error);\n\n  /// Actually do the writing of memory to a process.\n  ///\n  /// \\param[in] vm_addr\n  ///     A virtual load address that indicates where to start writing\n  ///     memory to.\n  ///\n  /// \\param[in] buf\n  ///     A byte buffer that is at least \\a size bytes long that\n  ///     contains the data to write.\n  ///\n  /// \\param[in] size\n  ///     The number of bytes to write.\n  ///\n  /// \\param[out] error\n  ///     An error value in case the memory write fails.\n  ///\n  /// \\return\n  ///     The number of bytes that were actually written.\n  virtual size_t DoWriteMemory(lldb::addr_t vm_addr, const void *buf,\n                               size_t size, Status &error) {\n    error.SetErrorStringWithFormat(\n        \"error: %s does not support writing to processes\",\n        GetPluginName().GetCString());\n    return 0;\n  }\n\n  /// Write all or part of a scalar value to memory.\n  ///\n  /// The value contained in \\a scalar will be swapped to match the byte order\n  /// of the process that is being debugged. If \\a size is less than the size\n  /// of scalar, the least significant \\a size bytes from scalar will be\n  /// written. If \\a size is larger than the byte size of scalar, then the\n  /// extra space will be padded with zeros and the scalar value will be\n  /// placed in the least significant bytes in memory.\n  ///\n  /// \\param[in] vm_addr\n  ///     A virtual load address that indicates where to start writing\n  ///     memory to.\n  ///\n  /// \\param[in] scalar\n  ///     The scalar to write to the debugged process.\n  ///\n  /// \\param[in] size\n  ///     This value can be smaller or larger than the scalar value\n  ///     itself. If \\a size is smaller than the size of \\a scalar,\n  ///     the least significant bytes in \\a scalar will be used. If\n  ///     \\a size is larger than the byte size of \\a scalar, then\n  ///     the extra space will be padded with zeros. If \\a size is\n  ///     set to UINT32_MAX, then the size of \\a scalar will be used.\n  ///\n  /// \\param[out] error\n  ///     An error value in case the memory write fails.\n  ///\n  /// \\return\n  ///     The number of bytes that were actually written.\n  size_t WriteScalarToMemory(lldb::addr_t vm_addr, const Scalar &scalar,\n                             size_t size, Status &error);\n\n  size_t ReadScalarIntegerFromMemory(lldb::addr_t addr, uint32_t byte_size,\n                                     bool is_signed, Scalar &scalar,\n                                     Status &error);\n\n  /// Write memory to a process.\n  ///\n  /// This function will write memory to the current process's address space\n  /// and maintain any traps that might be present due to software\n  /// breakpoints.\n  ///\n  /// This function is not meant to be overridden by Process subclasses, the\n  /// subclasses should implement Process::DoWriteMemory (lldb::addr_t,\n  /// size_t, void *).\n  ///\n  /// \\param[in] vm_addr\n  ///     A virtual load address that indicates where to start writing\n  ///     memory to.\n  ///\n  /// \\param[in] buf\n  ///     A byte buffer that is at least \\a size bytes long that\n  ///     contains the data to write.\n  ///\n  /// \\param[in] size\n  ///     The number of bytes to write.\n  ///\n  /// \\return\n  ///     The number of bytes that were actually written.\n  // TODO: change this to take an ArrayRef<uint8_t>\n  size_t WriteMemory(lldb::addr_t vm_addr, const void *buf, size_t size,\n                     Status &error);\n\n  /// Actually allocate memory in the process.\n  ///\n  /// This function will allocate memory in the process's address space.  This\n  /// can't rely on the generic function calling mechanism, since that\n  /// requires this function.\n  ///\n  /// \\param[in] size\n  ///     The size of the allocation requested.\n  ///\n  /// \\return\n  ///     The address of the allocated buffer in the process, or\n  ///     LLDB_INVALID_ADDRESS if the allocation failed.\n\n  virtual lldb::addr_t DoAllocateMemory(size_t size, uint32_t permissions,\n                                        Status &error) {\n    error.SetErrorStringWithFormat(\n        \"error: %s does not support allocating in the debug process\",\n        GetPluginName().GetCString());\n    return LLDB_INVALID_ADDRESS;\n  }\n\n  virtual Status WriteObjectFile(std::vector<ObjectFile::LoadableData> entries);\n\n  /// The public interface to allocating memory in the process.\n  ///\n  /// This function will allocate memory in the process's address space.  This\n  /// can't rely on the generic function calling mechanism, since that\n  /// requires this function.\n  ///\n  /// \\param[in] size\n  ///     The size of the allocation requested.\n  ///\n  /// \\param[in] permissions\n  ///     Or together any of the lldb::Permissions bits.  The permissions on\n  ///     a given memory allocation can't be changed after allocation.  Note\n  ///     that a block that isn't set writable can still be written on from\n  ///     lldb,\n  ///     just not by the process itself.\n  ///\n  /// \\param[in,out] error\n  ///     An error object to fill in if things go wrong.\n  /// \\return\n  ///     The address of the allocated buffer in the process, or\n  ///     LLDB_INVALID_ADDRESS if the allocation failed.\n  lldb::addr_t AllocateMemory(size_t size, uint32_t permissions, Status &error);\n\n  /// The public interface to allocating memory in the process, this also\n  /// clears the allocated memory.\n  ///\n  /// This function will allocate memory in the process's address space.  This\n  /// can't rely on the generic function calling mechanism, since that\n  /// requires this function.\n  ///\n  /// \\param[in] size\n  ///     The size of the allocation requested.\n  ///\n  /// \\param[in] permissions\n  ///     Or together any of the lldb::Permissions bits.  The permissions on\n  ///     a given memory allocation can't be changed after allocation.  Note\n  ///     that a block that isn't set writable can still be written on from\n  ///     lldb,\n  ///     just not by the process itself.\n  ///\n  /// \\param[in,out] error\n  ///     An error object to fill in if things go wrong.\n  ///\n  /// \\return\n  ///     The address of the allocated buffer in the process, or\n  ///     LLDB_INVALID_ADDRESS if the allocation failed.\n\n  lldb::addr_t CallocateMemory(size_t size, uint32_t permissions,\n                               Status &error);\n\n  /// Resolve dynamically loaded indirect functions.\n  ///\n  /// \\param[in] address\n  ///     The load address of the indirect function to resolve.\n  ///\n  /// \\param[out] error\n  ///     An error value in case the resolve fails.\n  ///\n  /// \\return\n  ///     The address of the resolved function.\n  ///     LLDB_INVALID_ADDRESS if the resolution failed.\n  virtual lldb::addr_t ResolveIndirectFunction(const Address *address,\n                                               Status &error);\n\n  /// Locate the memory region that contains load_addr.\n  ///\n  /// If load_addr is within the address space the process has mapped\n  /// range_info will be filled in with the start and end of that range as\n  /// well as the permissions for that range and range_info.GetMapped will\n  /// return true.\n  ///\n  /// If load_addr is outside any mapped region then range_info will have its\n  /// start address set to load_addr and the end of the range will indicate\n  /// the start of the next mapped range or be set to LLDB_INVALID_ADDRESS if\n  /// there are no valid mapped ranges between load_addr and the end of the\n  /// process address space.\n  ///\n  /// GetMemoryRegionInfo will only return an error if it is unimplemented for\n  /// the current process.\n  ///\n  /// \\param[in] load_addr\n  ///     The load address to query the range_info for.\n  ///\n  /// \\param[out] range_info\n  ///     An range_info value containing the details of the range.\n  ///\n  /// \\return\n  ///     An error value.\n  virtual Status GetMemoryRegionInfo(lldb::addr_t load_addr,\n                                     MemoryRegionInfo &range_info) {\n    Status error;\n    error.SetErrorString(\"Process::GetMemoryRegionInfo() not supported\");\n    return error;\n  }\n\n  /// Obtain all the mapped memory regions within this process.\n  ///\n  /// \\param[out] region_list\n  ///     A vector to contain MemoryRegionInfo objects for all mapped\n  ///     ranges.\n  ///\n  /// \\return\n  ///     An error value.\n  virtual Status\n  GetMemoryRegions(lldb_private::MemoryRegionInfos &region_list);\n\n  virtual Status GetWatchpointSupportInfo(uint32_t &num) {\n    Status error;\n    num = 0;\n    error.SetErrorString(\"Process::GetWatchpointSupportInfo() not supported\");\n    return error;\n  }\n\n  virtual Status GetWatchpointSupportInfo(uint32_t &num, bool &after) {\n    Status error;\n    num = 0;\n    after = true;\n    error.SetErrorString(\"Process::GetWatchpointSupportInfo() not supported\");\n    return error;\n  }\n\n  lldb::ModuleSP ReadModuleFromMemory(const FileSpec &file_spec,\n                                      lldb::addr_t header_addr,\n                                      size_t size_to_read = 512);\n\n  /// Attempt to get the attributes for a region of memory in the process.\n  ///\n  /// It may be possible for the remote debug server to inspect attributes for\n  /// a region of memory in the process, such as whether there is a valid page\n  /// of memory at a given address or whether that page is\n  /// readable/writable/executable by the process.\n  ///\n  /// \\param[in] load_addr\n  ///     The address of interest in the process.\n  ///\n  /// \\param[out] permissions\n  ///     If this call returns successfully, this bitmask will have\n  ///     its Permissions bits set to indicate whether the region is\n  ///     readable/writable/executable.  If this call fails, the\n  ///     bitmask values are undefined.\n  ///\n  /// \\return\n  ///     Returns true if it was able to determine the attributes of the\n  ///     memory region.  False if not.\n  virtual bool GetLoadAddressPermissions(lldb::addr_t load_addr,\n                                         uint32_t &permissions);\n\n  /// Determines whether executing JIT-compiled code in this process is\n  /// possible.\n  ///\n  /// \\return\n  ///     True if execution of JIT code is possible; false otherwise.\n  bool CanJIT();\n\n  /// Sets whether executing JIT-compiled code in this process is possible.\n  ///\n  /// \\param[in] can_jit\n  ///     True if execution of JIT code is possible; false otherwise.\n  void SetCanJIT(bool can_jit);\n\n  /// Determines whether executing function calls using the interpreter is\n  /// possible for this process.\n  ///\n  /// \\return\n  ///     True if possible; false otherwise.\n  bool CanInterpretFunctionCalls() { return m_can_interpret_function_calls; }\n\n  /// Sets whether executing function calls using the interpreter is possible\n  /// for this process.\n  ///\n  /// \\param[in] can_interpret_function_calls\n  ///     True if possible; false otherwise.\n  void SetCanInterpretFunctionCalls(bool can_interpret_function_calls) {\n    m_can_interpret_function_calls = can_interpret_function_calls;\n  }\n\n  /// Sets whether executing code in this process is possible. This could be\n  /// either through JIT or interpreting.\n  ///\n  /// \\param[in] can_run_code\n  ///     True if execution of code is possible; false otherwise.\n  void SetCanRunCode(bool can_run_code);\n\n  /// Actually deallocate memory in the process.\n  ///\n  /// This function will deallocate memory in the process's address space that\n  /// was allocated with AllocateMemory.\n  ///\n  /// \\param[in] ptr\n  ///     A return value from AllocateMemory, pointing to the memory you\n  ///     want to deallocate.\n  ///\n  /// \\return\n  ///     \\btrue if the memory was deallocated, \\bfalse otherwise.\n  virtual Status DoDeallocateMemory(lldb::addr_t ptr) {\n    Status error;\n    error.SetErrorStringWithFormat(\n        \"error: %s does not support deallocating in the debug process\",\n        GetPluginName().GetCString());\n    return error;\n  }\n\n  /// The public interface to deallocating memory in the process.\n  ///\n  /// This function will deallocate memory in the process's address space that\n  /// was allocated with AllocateMemory.\n  ///\n  /// \\param[in] ptr\n  ///     A return value from AllocateMemory, pointing to the memory you\n  ///     want to deallocate.\n  ///\n  /// \\return\n  ///     \\btrue if the memory was deallocated, \\bfalse otherwise.\n  Status DeallocateMemory(lldb::addr_t ptr);\n\n  /// Get any available STDOUT.\n  ///\n  /// Calling this method is a valid operation only if all of the following\n  /// conditions are true: 1) The process was launched, and not attached to.\n  /// 2) The process was not launched with eLaunchFlagDisableSTDIO. 3) The\n  /// process was launched without supplying a valid file path\n  ///    for STDOUT.\n  ///\n  /// Note that the implementation will probably need to start a read thread\n  /// in the background to make sure that the pipe is drained and the STDOUT\n  /// buffered appropriately, to prevent the process from deadlocking trying\n  /// to write to a full buffer.\n  ///\n  /// Events will be queued indicating that there is STDOUT available that can\n  /// be retrieved using this function.\n  ///\n  /// \\param[out] buf\n  ///     A buffer that will receive any STDOUT bytes that are\n  ///     currently available.\n  ///\n  /// \\param[in] buf_size\n  ///     The size in bytes for the buffer \\a buf.\n  ///\n  /// \\return\n  ///     The number of bytes written into \\a buf. If this value is\n  ///     equal to \\a buf_size, another call to this function should\n  ///     be made to retrieve more STDOUT data.\n  virtual size_t GetSTDOUT(char *buf, size_t buf_size, Status &error);\n\n  /// Get any available STDERR.\n  ///\n  /// Calling this method is a valid operation only if all of the following\n  /// conditions are true: 1) The process was launched, and not attached to.\n  /// 2) The process was not launched with eLaunchFlagDisableSTDIO. 3) The\n  /// process was launched without supplying a valid file path\n  ///    for STDERR.\n  ///\n  /// Note that the implementation will probably need to start a read thread\n  /// in the background to make sure that the pipe is drained and the STDERR\n  /// buffered appropriately, to prevent the process from deadlocking trying\n  /// to write to a full buffer.\n  ///\n  /// Events will be queued indicating that there is STDERR available that can\n  /// be retrieved using this function.\n  ///\n  /// \\param[in] buf\n  ///     A buffer that will receive any STDERR bytes that are\n  ///     currently available.\n  ///\n  /// \\param[out] buf_size\n  ///     The size in bytes for the buffer \\a buf.\n  ///\n  /// \\return\n  ///     The number of bytes written into \\a buf. If this value is\n  ///     equal to \\a buf_size, another call to this function should\n  ///     be made to retrieve more STDERR data.\n  virtual size_t GetSTDERR(char *buf, size_t buf_size, Status &error);\n\n  /// Puts data into this process's STDIN.\n  ///\n  /// Calling this method is a valid operation only if all of the following\n  /// conditions are true: 1) The process was launched, and not attached to.\n  /// 2) The process was not launched with eLaunchFlagDisableSTDIO. 3) The\n  /// process was launched without supplying a valid file path\n  ///    for STDIN.\n  ///\n  /// \\param[in] buf\n  ///     A buffer that contains the data to write to the process's STDIN.\n  ///\n  /// \\param[in] buf_size\n  ///     The size in bytes for the buffer \\a buf.\n  ///\n  /// \\return\n  ///     The number of bytes written into \\a buf. If this value is\n  ///     less than \\a buf_size, another call to this function should\n  ///     be made to write the rest of the data.\n  virtual size_t PutSTDIN(const char *buf, size_t buf_size, Status &error) {\n    error.SetErrorString(\"stdin unsupported\");\n    return 0;\n  }\n\n  /// Get any available profile data.\n  ///\n  /// \\param[out] buf\n  ///     A buffer that will receive any profile data bytes that are\n  ///     currently available.\n  ///\n  /// \\param[out] buf_size\n  ///     The size in bytes for the buffer \\a buf.\n  ///\n  /// \\return\n  ///     The number of bytes written into \\a buf. If this value is\n  ///     equal to \\a buf_size, another call to this function should\n  ///     be made to retrieve more profile data.\n  virtual size_t GetAsyncProfileData(char *buf, size_t buf_size, Status &error);\n\n  // Process Breakpoints\n  size_t GetSoftwareBreakpointTrapOpcode(BreakpointSite *bp_site);\n\n  virtual Status EnableBreakpointSite(BreakpointSite *bp_site) {\n    Status error;\n    error.SetErrorStringWithFormat(\n        \"error: %s does not support enabling breakpoints\",\n        GetPluginName().GetCString());\n    return error;\n  }\n\n  virtual Status DisableBreakpointSite(BreakpointSite *bp_site) {\n    Status error;\n    error.SetErrorStringWithFormat(\n        \"error: %s does not support disabling breakpoints\",\n        GetPluginName().GetCString());\n    return error;\n  }\n\n  // This is implemented completely using the lldb::Process API. Subclasses\n  // don't need to implement this function unless the standard flow of read\n  // existing opcode, write breakpoint opcode, verify breakpoint opcode doesn't\n  // work for a specific process plug-in.\n  virtual Status EnableSoftwareBreakpoint(BreakpointSite *bp_site);\n\n  // This is implemented completely using the lldb::Process API. Subclasses\n  // don't need to implement this function unless the standard flow of\n  // restoring original opcode in memory and verifying the restored opcode\n  // doesn't work for a specific process plug-in.\n  virtual Status DisableSoftwareBreakpoint(BreakpointSite *bp_site);\n\n  BreakpointSiteList &GetBreakpointSiteList();\n\n  const BreakpointSiteList &GetBreakpointSiteList() const;\n\n  void DisableAllBreakpointSites();\n\n  Status ClearBreakpointSiteByID(lldb::user_id_t break_id);\n\n  lldb::break_id_t CreateBreakpointSite(const lldb::BreakpointLocationSP &owner,\n                                        bool use_hardware);\n\n  Status DisableBreakpointSiteByID(lldb::user_id_t break_id);\n\n  Status EnableBreakpointSiteByID(lldb::user_id_t break_id);\n\n  // BreakpointLocations use RemoveOwnerFromBreakpointSite to remove themselves\n  // from the owner's list of this breakpoint sites.\n  void RemoveOwnerFromBreakpointSite(lldb::user_id_t owner_id,\n                                     lldb::user_id_t owner_loc_id,\n                                     lldb::BreakpointSiteSP &bp_site_sp);\n\n  // Process Watchpoints (optional)\n  virtual Status EnableWatchpoint(Watchpoint *wp, bool notify = true);\n\n  virtual Status DisableWatchpoint(Watchpoint *wp, bool notify = true);\n\n  // Thread Queries\n\n  /// Update the thread list.\n  ///\n  /// This method performs some general clean up before invoking\n  /// \\a DoUpdateThreadList, which should be implemented by each\n  /// process plugin.\n  ///\n  /// \\return\n  ///     \\b true if the new thread list could be generated, \\b false otherwise.\n  bool UpdateThreadList(ThreadList &old_thread_list,\n                        ThreadList &new_thread_list);\n\n  void UpdateThreadListIfNeeded();\n\n  ThreadList &GetThreadList() { return m_thread_list; }\n\n  // When ExtendedBacktraces are requested, the HistoryThreads that are created\n  // need an owner -- they're saved here in the Process.  The threads in this\n  // list are not iterated over - driver programs need to request the extended\n  // backtrace calls starting from a root concrete thread one by one.\n  ThreadList &GetExtendedThreadList() { return m_extended_thread_list; }\n\n  ThreadList::ThreadIterable Threads() { return m_thread_list.Threads(); }\n\n  uint32_t GetNextThreadIndexID(uint64_t thread_id);\n\n  lldb::ThreadSP CreateOSPluginThread(lldb::tid_t tid, lldb::addr_t context);\n\n  // Returns true if an index id has been assigned to a thread.\n  bool HasAssignedIndexIDToThread(uint64_t sb_thread_id);\n\n  // Given a thread_id, it will assign a more reasonable index id for display\n  // to the user. If the thread_id has previously been assigned, the same index\n  // id will be used.\n  uint32_t AssignIndexIDToThread(uint64_t thread_id);\n\n  // Queue Queries\n\n  void UpdateQueueListIfNeeded();\n\n  QueueList &GetQueueList() {\n    UpdateQueueListIfNeeded();\n    return m_queue_list;\n  }\n\n  QueueList::QueueIterable Queues() {\n    UpdateQueueListIfNeeded();\n    return m_queue_list.Queues();\n  }\n\n  // Event Handling\n  lldb::StateType GetNextEvent(lldb::EventSP &event_sp);\n\n  // Returns the process state when it is stopped. If specified, event_sp_ptr\n  // is set to the event which triggered the stop. If wait_always = false, and\n  // the process is already stopped, this function returns immediately. If the\n  // process is hijacked and use_run_lock is true (the default), then this\n  // function releases the run lock after the stop. Setting use_run_lock to\n  // false will avoid this behavior.\n  lldb::StateType\n  WaitForProcessToStop(const Timeout<std::micro> &timeout,\n                       lldb::EventSP *event_sp_ptr = nullptr,\n                       bool wait_always = true,\n                       lldb::ListenerSP hijack_listener = lldb::ListenerSP(),\n                       Stream *stream = nullptr, bool use_run_lock = true);\n\n  uint32_t GetIOHandlerID() const { return m_iohandler_sync.GetValue(); }\n\n  /// Waits for the process state to be running within a given msec timeout.\n  ///\n  /// The main purpose of this is to implement an interlock waiting for\n  /// HandlePrivateEvent to push an IOHandler.\n  ///\n  /// \\param[in] timeout\n  ///     The maximum time length to wait for the process to transition to the\n  ///     eStateRunning state.\n  void SyncIOHandler(uint32_t iohandler_id, const Timeout<std::micro> &timeout);\n\n  lldb::StateType GetStateChangedEvents(\n      lldb::EventSP &event_sp, const Timeout<std::micro> &timeout,\n      lldb::ListenerSP\n          hijack_listener); // Pass an empty ListenerSP to use builtin listener\n\n  /// Centralize the code that handles and prints descriptions for process\n  /// state changes.\n  ///\n  /// \\param[in] event_sp\n  ///     The process state changed event\n  ///\n  /// \\param[in] stream\n  ///     The output stream to get the state change description\n  ///\n  /// \\param[in,out] pop_process_io_handler\n  ///     If this value comes in set to \\b true, then pop the Process IOHandler\n  ///     if needed.\n  ///     Else this variable will be set to \\b true or \\b false to indicate if\n  ///     the process\n  ///     needs to have its process IOHandler popped.\n  ///\n  /// \\return\n  ///     \\b true if the event describes a process state changed event, \\b false\n  ///     otherwise.\n  static bool HandleProcessStateChangedEvent(const lldb::EventSP &event_sp,\n                                             Stream *stream,\n                                             bool &pop_process_io_handler);\n\n  Event *PeekAtStateChangedEvents();\n\n  class ProcessEventHijacker {\n  public:\n    ProcessEventHijacker(Process &process, lldb::ListenerSP listener_sp)\n        : m_process(process) {\n      m_process.HijackProcessEvents(std::move(listener_sp));\n    }\n\n    ~ProcessEventHijacker() { m_process.RestoreProcessEvents(); }\n\n  private:\n    Process &m_process;\n  };\n\n  friend class ProcessEventHijacker;\n  friend class ProcessProperties;\n  /// If you need to ensure that you and only you will hear about some public\n  /// event, then make a new listener, set to listen to process events, and\n  /// then call this with that listener.  Then you will have to wait on that\n  /// listener explicitly for events (rather than using the GetNextEvent &\n  /// WaitFor* calls above.  Be sure to call RestoreProcessEvents when you are\n  /// done.\n  ///\n  /// \\param[in] listener_sp\n  ///     This is the new listener to whom all process events will be delivered.\n  ///\n  /// \\return\n  ///     Returns \\b true if the new listener could be installed,\n  ///     \\b false otherwise.\n  bool HijackProcessEvents(lldb::ListenerSP listener_sp);\n\n  /// Restores the process event broadcasting to its normal state.\n  ///\n  void RestoreProcessEvents();\n\n  bool StateChangedIsHijackedForSynchronousResume();\n\n  bool StateChangedIsExternallyHijacked();\n\n  const lldb::ABISP &GetABI();\n\n  OperatingSystem *GetOperatingSystem() { return m_os_up.get(); }\n\n  std::vector<LanguageRuntime *> GetLanguageRuntimes();\n\n  LanguageRuntime *GetLanguageRuntime(lldb::LanguageType language);\n\n  bool IsPossibleDynamicValue(ValueObject &in_value);\n\n  bool IsRunning() const;\n\n  DynamicCheckerFunctions *GetDynamicCheckers() {\n    return m_dynamic_checkers_up.get();\n  }\n\n  void SetDynamicCheckers(DynamicCheckerFunctions *dynamic_checkers);\n\n/// Prune ThreadPlanStacks for unreported threads.\n///\n/// \\param[in] tid\n///     The tid whose Plan Stack we are seeking to prune.\n///\n/// \\return\n///     \\b true if the TID is found or \\b false if not.\nbool PruneThreadPlansForTID(lldb::tid_t tid);\n\n/// Prune ThreadPlanStacks for all unreported threads.\nvoid PruneThreadPlans();\n\n  /// Find the thread plan stack associated with thread with \\a tid.\n  ///\n  /// \\param[in] tid\n  ///     The tid whose Plan Stack we are seeking.\n  ///\n  /// \\return\n  ///     Returns a ThreadPlan if the TID is found or nullptr if not.\n  ThreadPlanStack *FindThreadPlans(lldb::tid_t tid);\n\n  /// Dump the thread plans associated with thread with \\a tid.\n  ///\n  /// \\param[in,out] strm\n  ///     The stream to which to dump the output\n  ///\n  /// \\param[in] tid\n  ///     The tid whose Plan Stack we are dumping\n  ///\n  /// \\param[in] desc_level\n  ///     How much detail to dump\n  ///\n  /// \\param[in] internal\n  ///     If \\b true dump all plans, if false only user initiated plans\n  ///\n  /// \\param[in] condense_trivial\n  ///     If true, only dump a header if the plan stack is just the base plan.\n  ///\n  /// \\param[in] skip_unreported_plans\n  ///     If true, only dump a plan if it is currently backed by an\n  ///     lldb_private::Thread *.\n  ///\n  /// \\return\n  ///     Returns \\b true if TID was found, \\b false otherwise\n  bool DumpThreadPlansForTID(Stream &strm, lldb::tid_t tid,\n                             lldb::DescriptionLevel desc_level, bool internal,\n                             bool condense_trivial, bool skip_unreported_plans);\n\n  /// Dump all the thread plans for this process.\n  ///\n  /// \\param[in,out] strm\n  ///     The stream to which to dump the output\n  ///\n  /// \\param[in] desc_level\n  ///     How much detail to dump\n  ///\n  /// \\param[in] internal\n  ///     If \\b true dump all plans, if false only user initiated plans\n  ///\n  /// \\param[in] condense_trivial\n  ///     If true, only dump a header if the plan stack is just the base plan.\n  ///\n  /// \\param[in] skip_unreported_plans\n  ///     If true, skip printing all thread plan stacks that don't currently\n  ///     have a backing lldb_private::Thread *.\n  void DumpThreadPlans(Stream &strm, lldb::DescriptionLevel desc_level,\n                       bool internal, bool condense_trivial,\n                       bool skip_unreported_plans);\n\n  /// Call this to set the lldb in the mode where it breaks on new thread\n  /// creations, and then auto-restarts.  This is useful when you are trying\n  /// to run only one thread, but either that thread or the kernel is creating\n  /// new threads in the process.  If you stop when the thread is created, you\n  /// can immediately suspend it, and keep executing only the one thread you\n  /// intend.\n  ///\n  /// \\return\n  ///     Returns \\b true if we were able to start up the notification\n  ///     \\b false otherwise.\n  virtual bool StartNoticingNewThreads() { return true; }\n\n  /// Call this to turn off the stop & notice new threads mode.\n  ///\n  /// \\return\n  ///     Returns \\b true if we were able to start up the notification\n  ///     \\b false otherwise.\n  virtual bool StopNoticingNewThreads() { return true; }\n\n  void SetRunningUserExpression(bool on);\n  void SetRunningUtilityFunction(bool on);\n\n  // lldb::ExecutionContextScope pure virtual functions\n  lldb::TargetSP CalculateTarget() override;\n\n  lldb::ProcessSP CalculateProcess() override { return shared_from_this(); }\n\n  lldb::ThreadSP CalculateThread() override { return lldb::ThreadSP(); }\n\n  lldb::StackFrameSP CalculateStackFrame() override {\n    return lldb::StackFrameSP();\n  }\n\n  void CalculateExecutionContext(ExecutionContext &exe_ctx) override;\n\n  void SetSTDIOFileDescriptor(int file_descriptor);\n\n  // Add a permanent region of memory that should never be read or written to.\n  // This can be used to ensure that memory reads or writes to certain areas of\n  // memory never end up being sent to the DoReadMemory or DoWriteMemory\n  // functions which can improve performance.\n  void AddInvalidMemoryRegion(const LoadRange &region);\n\n  // Remove a permanent region of memory that should never be read or written\n  // to that was previously added with AddInvalidMemoryRegion.\n  bool RemoveInvalidMemoryRange(const LoadRange &region);\n\n  // If the setup code of a thread plan needs to do work that might involve\n  // calling a function in the target, it should not do that work directly in\n  // one of the thread plan functions (DidPush/WillResume) because such work\n  // needs to be handled carefully.  Instead, put that work in a\n  // PreResumeAction callback, and register it with the process.  It will get\n  // done before the actual \"DoResume\" gets called.\n\n  typedef bool(PreResumeActionCallback)(void *);\n\n  void AddPreResumeAction(PreResumeActionCallback callback, void *baton);\n\n  bool RunPreResumeActions();\n\n  void ClearPreResumeActions();\n\n  void ClearPreResumeAction(PreResumeActionCallback callback, void *baton);\n\n  ProcessRunLock &GetRunLock();\n\n  bool CurrentThreadIsPrivateStateThread();\n\n  virtual Status SendEventData(const char *data) {\n    Status return_error(\"Sending an event is not supported for this process.\");\n    return return_error;\n  }\n\n  lldb::ThreadCollectionSP GetHistoryThreads(lldb::addr_t addr);\n\n  lldb::InstrumentationRuntimeSP\n  GetInstrumentationRuntime(lldb::InstrumentationRuntimeType type);\n\n  /// Try to fetch the module specification for a module with the given file\n  /// name and architecture. Process sub-classes have to override this method\n  /// if they support platforms where the Platform object can't get the module\n  /// spec for all module.\n  ///\n  /// \\param[in] module_file_spec\n  ///     The file name of the module to get specification for.\n  ///\n  /// \\param[in] arch\n  ///     The architecture of the module to get specification for.\n  ///\n  /// \\param[out] module_spec\n  ///     The fetched module specification if the return value is\n  ///     \\b true, unchanged otherwise.\n  ///\n  /// \\return\n  ///     Returns \\b true if the module spec fetched successfully,\n  ///     \\b false otherwise.\n  virtual bool GetModuleSpec(const FileSpec &module_file_spec,\n                             const ArchSpec &arch, ModuleSpec &module_spec);\n\n  virtual void PrefetchModuleSpecs(llvm::ArrayRef<FileSpec> module_file_specs,\n                                   const llvm::Triple &triple) {}\n\n  /// Try to find the load address of a file.\n  /// The load address is defined as the address of the first memory region\n  /// what contains data mapped from the specified file.\n  ///\n  /// \\param[in] file\n  ///     The name of the file whose load address we are looking for\n  ///\n  /// \\param[out] is_loaded\n  ///     \\b True if the file is loaded into the memory and false\n  ///     otherwise.\n  ///\n  /// \\param[out] load_addr\n  ///     The load address of the file if it is loaded into the\n  ///     processes address space, LLDB_INVALID_ADDRESS otherwise.\n  virtual Status GetFileLoadAddress(const FileSpec &file, bool &is_loaded,\n                                    lldb::addr_t &load_addr) {\n    return Status(\"Not supported\");\n  }\n\n  size_t AddImageToken(lldb::addr_t image_ptr);\n\n  lldb::addr_t GetImagePtrFromToken(size_t token) const;\n\n  void ResetImageToken(size_t token);\n\n  /// Find the next branch instruction to set a breakpoint on\n  ///\n  /// When instruction stepping through a source line, instead of stepping\n  /// through each instruction, we can put a breakpoint on the next branch\n  /// instruction (within the range of instructions we are stepping through)\n  /// and continue the process to there, yielding significant performance\n  /// benefits over instruction stepping.\n  ///\n  /// \\param[in] default_stop_addr\n  ///     The address of the instruction where lldb would put a\n  ///     breakpoint normally.\n  ///\n  /// \\param[in] range_bounds\n  ///     The range which the breakpoint must be contained within.\n  ///     Typically a source line.\n  ///\n  /// \\return\n  ///     The address of the next branch instruction, or the end of\n  ///     the range provided in range_bounds.  If there are any\n  ///     problems with the disassembly or getting the instructions,\n  ///     the original default_stop_addr will be returned.\n  Address AdvanceAddressToNextBranchInstruction(Address default_stop_addr,\n                                                AddressRange range_bounds);\n\n  /// Configure asynchronous structured data feature.\n  ///\n  /// Each Process type that supports using an asynchronous StructuredData\n  /// feature should implement this to enable/disable/configure the feature.\n  /// The default implementation here will always return an error indiciating\n  /// the feature is unsupported.\n  ///\n  /// StructuredDataPlugin implementations will call this to configure a\n  /// feature that has been reported as being supported.\n  ///\n  /// \\param[in] type_name\n  ///     The StructuredData type name as previously discovered by\n  ///     the Process-derived instance.\n  ///\n  /// \\param[in] config_sp\n  ///     Configuration data for the feature being enabled.  This config\n  ///     data, which may be null, will be passed along to the feature\n  ///     to process.  The feature will dictate whether this is a dictionary,\n  ///     an array or some other object.  If the feature needs to be\n  ///     set up properly before it can be enabled, then the config should\n  ///     also take an enable/disable flag.\n  ///\n  /// \\return\n  ///     Returns the result of attempting to configure the feature.\n  virtual Status\n  ConfigureStructuredData(ConstString type_name,\n                          const StructuredData::ObjectSP &config_sp);\n\n  /// Broadcasts the given structured data object from the given plugin.\n  ///\n  /// StructuredDataPlugin instances can use this to optionally broadcast any\n  /// of their data if they want to make it available for clients.  The data\n  /// will come in on the structured data event bit\n  /// (eBroadcastBitStructuredData).\n  ///\n  /// \\param[in] object_sp\n  ///     The structured data object to broadcast.\n  ///\n  /// \\param[in] plugin_sp\n  ///     The plugin that will be reported in the event's plugin\n  ///     parameter.\n  void BroadcastStructuredData(const StructuredData::ObjectSP &object_sp,\n                               const lldb::StructuredDataPluginSP &plugin_sp);\n\n  /// Returns the StructuredDataPlugin associated with a given type name, if\n  /// there is one.\n  ///\n  /// There will only be a plugin for a given StructuredDataType if the\n  /// debugged process monitor claims that the feature is supported. This is\n  /// one way to tell whether a feature is available.\n  ///\n  /// \\return\n  ///     The plugin if one is available for the specified feature;\n  ///     otherwise, returns an empty shared pointer.\n  lldb::StructuredDataPluginSP\n  GetStructuredDataPlugin(ConstString type_name) const;\n\n  /// Starts tracing with the configuration provided in options. To enable\n  /// tracing on the complete process the thread_id in the options should be\n  /// set to LLDB_INVALID_THREAD_ID. The API returns a user_id which is needed\n  /// by other API's that manipulate the trace instance. The handling of\n  /// erroneous or unsupported configuration is left to the trace technology\n  /// implementations in the server, as they could be returned as an error, or\n  /// rounded to a valid configuration to start tracing. In the later case the\n  /// GetTraceConfig should supply the actual used trace configuration.\n  virtual lldb::user_id_t StartTrace(const TraceOptions &options,\n                                     Status &error) {\n    error.SetErrorString(\"Not implemented\");\n    return LLDB_INVALID_UID;\n  }\n\n  /// Stops the tracing instance leading to deletion of the trace data. The\n  /// tracing instance is identified by the user_id which is obtained when\n  /// tracing was started from the StartTrace. In case tracing of the complete\n  /// process needs to be stopped the thread_id should be set to\n  /// LLDB_INVALID_THREAD_ID. In the other case that tracing on an individual\n  /// thread needs to be stopped a thread_id can be supplied.\n  virtual Status StopTrace(lldb::user_id_t uid, lldb::tid_t thread_id) {\n    return Status(\"Not implemented\");\n  }\n\n  /// Provides the trace data as raw bytes. A buffer needs to be supplied to\n  /// copy the trace data. The exact behavior of this API may vary across\n  /// trace technology, as some may support partial reading of the trace data\n  /// from a specified offset while some may not. The thread_id should be used\n  /// to select a particular thread for trace extraction.\n  virtual Status GetData(lldb::user_id_t uid, lldb::tid_t thread_id,\n                         llvm::MutableArrayRef<uint8_t> &buffer,\n                         size_t offset = 0) {\n    return Status(\"Not implemented\");\n  }\n\n  /// Similar API as above except for obtaining meta data\n  virtual Status GetMetaData(lldb::user_id_t uid, lldb::tid_t thread_id,\n                             llvm::MutableArrayRef<uint8_t> &buffer,\n                             size_t offset = 0) {\n    return Status(\"Not implemented\");\n  }\n\n  /// API to obtain the trace configuration used by a trace instance.\n  /// Configurations that may be specific to some trace technology should be\n  /// stored in the custom parameters. The options are transported to the\n  /// server, which shall interpret accordingly. The thread_id can be\n  /// specified in the options to obtain the configuration used by a specific\n  /// thread. The thread_id specified should also match the uid otherwise an\n  /// error will be returned.\n  virtual Status GetTraceConfig(lldb::user_id_t uid, TraceOptions &options) {\n    return Status(\"Not implemented\");\n  }\n\n  ///  Get the processor tracing type supported for this process.\n  ///  Responses might be different depending on the architecture and\n  ///  capabilities of the underlying OS.\n  ///\n  ///  \\return\n  ///     The supported trace type or an \\a llvm::Error if tracing is\n  ///     not supported for the inferior.\n  virtual llvm::Expected<TraceTypeInfo> GetSupportedTraceType();\n\n  // This calls a function of the form \"void * (*)(void)\".\n  bool CallVoidArgVoidPtrReturn(const Address *address,\n                                lldb::addr_t &returned_func,\n                                bool trap_exceptions = false);\n\nprotected:\n  /// Update the thread list following process plug-in's specific logic.\n  ///\n  /// This method should only be invoked by \\a UpdateThreadList.\n  ///\n  /// \\return\n  ///     \\b true if the new thread list could be generated, \\b false otherwise.\n  virtual bool DoUpdateThreadList(ThreadList &old_thread_list,\n                                  ThreadList &new_thread_list) = 0;\n\n  /// Actually do the reading of memory from a process.\n  ///\n  /// Subclasses must override this function and can return fewer bytes than\n  /// requested when memory requests are too large. This class will break up\n  /// the memory requests and keep advancing the arguments along as needed.\n  ///\n  /// \\param[in] vm_addr\n  ///     A virtual load address that indicates where to start reading\n  ///     memory from.\n  ///\n  /// \\param[in] size\n  ///     The number of bytes to read.\n  ///\n  /// \\param[out] buf\n  ///     A byte buffer that is at least \\a size bytes long that\n  ///     will receive the memory bytes.\n  ///\n  /// \\param[out] error\n  ///     An error that indicates the success or failure of this\n  ///     operation. If error indicates success (error.Success()),\n  ///     then the value returned can be trusted, otherwise zero\n  ///     will be returned.\n  ///\n  /// \\return\n  ///     The number of bytes that were actually read into \\a buf.\n  ///     Zero is returned in the case of an error.\n  virtual size_t DoReadMemory(lldb::addr_t vm_addr, void *buf, size_t size,\n                              Status &error) = 0;\n\n  void SetState(lldb::EventSP &event_sp);\n\n  lldb::StateType GetPrivateState();\n\n  /// The \"private\" side of resuming a process.  This doesn't alter the state\n  /// of m_run_lock, but just causes the process to resume.\n  ///\n  /// \\return\n  ///     An Status object describing the success or failure of the resume.\n  Status PrivateResume();\n\n  // Called internally\n  void CompleteAttach();\n\n  /// Print a user-visible warning one time per Process\n  ///\n  /// A facility for printing a warning to the user once per repeat_key.\n  ///\n  /// warning_type is from the Process::Warnings enums. repeat_key is a\n  /// pointer value that will be used to ensure that the warning message is\n  /// not printed multiple times.  For instance, with a warning about a\n  /// function being optimized, you can pass the CompileUnit pointer to have\n  /// the warning issued for only the first function in a CU, or the Function\n  /// pointer to have it issued once for every function, or a Module pointer\n  /// to have it issued once per Module.\n  ///\n  /// Classes outside Process should call a specific PrintWarning method so\n  /// that the warning strings are all centralized in Process, instead of\n  /// calling PrintWarning() directly.\n  ///\n  /// \\param [in] warning_type\n  ///     One of the types defined in Process::Warnings.\n  ///\n  /// \\param [in] repeat_key\n  ///     A pointer value used to ensure that the warning is only printed once.\n  ///     May be nullptr, indicating that the warning is printed unconditionally\n  ///     every time.\n  ///\n  /// \\param [in] fmt\n  ///     printf style format string\n  void PrintWarning(uint64_t warning_type, const void *repeat_key,\n                    const char *fmt, ...) __attribute__((format(printf, 4, 5)));\n\n  // NextEventAction provides a way to register an action on the next event\n  // that is delivered to this process.  There is currently only one next event\n  // action allowed in the process at one time.  If a new \"NextEventAction\" is\n  // added while one is already present, the old action will be discarded (with\n  // HandleBeingUnshipped called after it is discarded.)\n  //\n  // If you want to resume the process as a result of a resume action, call\n  // RequestResume, don't call Resume directly.\n  class NextEventAction {\n  public:\n    enum EventActionResult {\n      eEventActionSuccess,\n      eEventActionRetry,\n      eEventActionExit\n    };\n\n    NextEventAction(Process *process) : m_process(process) {}\n\n    virtual ~NextEventAction() = default;\n\n    virtual EventActionResult PerformAction(lldb::EventSP &event_sp) = 0;\n    virtual void HandleBeingUnshipped() {}\n    virtual EventActionResult HandleBeingInterrupted() = 0;\n    virtual const char *GetExitString() = 0;\n    void RequestResume() { m_process->m_resume_requested = true; }\n\n  protected:\n    Process *m_process;\n  };\n\n  void SetNextEventAction(Process::NextEventAction *next_event_action) {\n    if (m_next_event_action_up.get())\n      m_next_event_action_up->HandleBeingUnshipped();\n\n    m_next_event_action_up.reset(next_event_action);\n  }\n\n  // This is the completer for Attaching:\n  class AttachCompletionHandler : public NextEventAction {\n  public:\n    AttachCompletionHandler(Process *process, uint32_t exec_count);\n\n    ~AttachCompletionHandler() override = default;\n\n    EventActionResult PerformAction(lldb::EventSP &event_sp) override;\n    EventActionResult HandleBeingInterrupted() override;\n    const char *GetExitString() override;\n\n  private:\n    uint32_t m_exec_count;\n    std::string m_exit_string;\n  };\n\n  bool PrivateStateThreadIsValid() const {\n    lldb::StateType state = m_private_state.GetValue();\n    return state != lldb::eStateInvalid && state != lldb::eStateDetached &&\n           state != lldb::eStateExited && m_private_state_thread.IsJoinable();\n  }\n\n  void ForceNextEventDelivery() { m_force_next_event_delivery = true; }\n\n  /// Loads any plugins associated with asynchronous structured data and maps\n  /// the relevant supported type name to the plugin.\n  ///\n  /// Processes can receive asynchronous structured data from the process\n  /// monitor.  This method will load and map any structured data plugins that\n  /// support the given set of supported type names. Later, if any of these\n  /// features are enabled, the process monitor is free to generate\n  /// asynchronous structured data.  The data must come in as a single \\b\n  /// StructuredData::Dictionary.  That dictionary must have a string field\n  /// named 'type', with a value that equals the relevant type name string\n  /// (one of the values in \\b supported_type_names).\n  ///\n  /// \\param[in] supported_type_names\n  ///     An array of zero or more type names.  Each must be unique.\n  ///     For each entry in the list, a StructuredDataPlugin will be\n  ///     searched for that supports the structured data type name.\n  void MapSupportedStructuredDataPlugins(\n      const StructuredData::Array &supported_type_names);\n\n  /// Route the incoming structured data dictionary to the right plugin.\n  ///\n  /// The incoming structured data must be a dictionary, and it must have a\n  /// key named 'type' that stores a string value.  The string value must be\n  /// the name of the structured data feature that knows how to handle it.\n  ///\n  /// \\param[in] object_sp\n  ///     When non-null and pointing to a dictionary, the 'type'\n  ///     key's string value is used to look up the plugin that\n  ///     was registered for that structured data type.  It then\n  ///     calls the following method on the StructuredDataPlugin\n  ///     instance:\n  ///\n  ///     virtual void\n  ///     HandleArrivalOfStructuredData(Process &process,\n  ///                                   ConstString type_name,\n  ///                                   const StructuredData::ObjectSP\n  ///                                   &object_sp)\n  ///\n  /// \\return\n  ///     True if the structured data was routed to a plugin; otherwise,\n  ///     false.\n  bool RouteAsyncStructuredData(const StructuredData::ObjectSP object_sp);\n\n  // Type definitions\n  typedef std::map<lldb::LanguageType, lldb::LanguageRuntimeSP>\n      LanguageRuntimeCollection;\n  typedef std::unordered_set<const void *> WarningsPointerSet;\n  typedef std::map<uint64_t, WarningsPointerSet> WarningsCollection;\n\n  struct PreResumeCallbackAndBaton {\n    bool (*callback)(void *);\n    void *baton;\n    PreResumeCallbackAndBaton(PreResumeActionCallback in_callback,\n                              void *in_baton)\n        : callback(in_callback), baton(in_baton) {}\n    bool operator== (const PreResumeCallbackAndBaton &rhs) {\n      return callback == rhs.callback && baton == rhs.baton;\n    }\n  };\n\n  using StructuredDataPluginMap =\n      std::map<ConstString, lldb::StructuredDataPluginSP>;\n\n  // Member variables\n  std::weak_ptr<Target> m_target_wp; ///< The target that owns this process.\n  lldb::pid_t m_pid = LLDB_INVALID_PROCESS_ID;\n  ThreadSafeValue<lldb::StateType> m_public_state;\n  ThreadSafeValue<lldb::StateType>\n      m_private_state;                     // The actual state of our process\n  Broadcaster m_private_state_broadcaster; // This broadcaster feeds state\n                                           // changed events into the private\n                                           // state thread's listener.\n  Broadcaster m_private_state_control_broadcaster; // This is the control\n                                                   // broadcaster, used to\n                                                   // pause, resume & stop the\n                                                   // private state thread.\n  lldb::ListenerSP m_private_state_listener_sp; // This is the listener for the\n                                                // private state thread.\n  HostThread m_private_state_thread; ///< Thread ID for the thread that watches\n                                     ///internal state events\n  ProcessModID m_mod_id; ///< Tracks the state of the process over stops and\n                         ///other alterations.\n  uint32_t m_process_unique_id; ///< Each lldb_private::Process class that is\n                                ///created gets a unique integer ID that\n                                ///increments with each new instance\n  uint32_t m_thread_index_id;   ///< Each thread is created with a 1 based index\n                                ///that won't get re-used.\n  std::map<uint64_t, uint32_t> m_thread_id_to_index_id_map;\n  int m_exit_status; ///< The exit status of the process, or -1 if not set.\n  std::string m_exit_string; ///< A textual description of why a process exited.\n  std::mutex m_exit_status_mutex; ///< Mutex so m_exit_status m_exit_string can\n                                  ///be safely accessed from multiple threads\n  std::recursive_mutex m_thread_mutex;\n  ThreadList m_thread_list_real; ///< The threads for this process as are known\n                                 ///to the protocol we are debugging with\n  ThreadList m_thread_list; ///< The threads for this process as the user will\n                            ///see them. This is usually the same as\n  ///< m_thread_list_real, but might be different if there is an OS plug-in\n  ///creating memory threads\n  ThreadPlanStackMap m_thread_plans; ///< This is the list of thread plans for\n                                     /// threads in m_thread_list, as well as\n                                     /// threads we knew existed, but haven't\n                                     /// determined that they have died yet.\n  ThreadList m_extended_thread_list; ///< Owner for extended threads that may be\n                                     ///generated, cleared on natural stops\n  uint32_t m_extended_thread_stop_id; ///< The natural stop id when\n                                      ///extended_thread_list was last updated\n  QueueList\n      m_queue_list; ///< The list of libdispatch queues at a given stop point\n  uint32_t m_queue_list_stop_id; ///< The natural stop id when queue list was\n                                 ///last fetched\n  std::vector<Notifications> m_notifications; ///< The list of notifications\n                                              ///that this process can deliver.\n  std::vector<lldb::addr_t> m_image_tokens;\n  lldb::ListenerSP m_listener_sp; ///< Shared pointer to the listener used for\n                                  ///public events.  Can not be empty.\n  BreakpointSiteList m_breakpoint_site_list; ///< This is the list of breakpoint\n                                             ///locations we intend to insert in\n                                             ///the target.\n  lldb::DynamicLoaderUP m_dyld_up;\n  lldb::JITLoaderListUP m_jit_loaders_up;\n  lldb::DynamicCheckerFunctionsUP m_dynamic_checkers_up; ///< The functions used\n                                                         /// by the expression\n                                                         /// parser to validate\n                                                         /// data that\n                                                         /// expressions use.\n  lldb::OperatingSystemUP m_os_up;\n  lldb::SystemRuntimeUP m_system_runtime_up;\n  lldb::UnixSignalsSP\n      m_unix_signals_sp; /// This is the current signal set for this process.\n  lldb::ABISP m_abi_sp;\n  lldb::IOHandlerSP m_process_input_reader;\n  Communication m_stdio_communication;\n  std::recursive_mutex m_stdio_communication_mutex;\n  bool m_stdin_forward; /// Remember if stdin must be forwarded to remote debug\n                        /// server\n  std::string m_stdout_data;\n  std::string m_stderr_data;\n  std::recursive_mutex m_profile_data_comm_mutex;\n  std::vector<std::string> m_profile_data;\n  Predicate<uint32_t> m_iohandler_sync;\n  MemoryCache m_memory_cache;\n  AllocatedMemoryCache m_allocated_memory_cache;\n  bool m_should_detach; /// Should we detach if the process object goes away\n                        /// with an explicit call to Kill or Detach?\n  LanguageRuntimeCollection m_language_runtimes;\n  std::recursive_mutex m_language_runtimes_mutex;\n  InstrumentationRuntimeCollection m_instrumentation_runtimes;\n  std::unique_ptr<NextEventAction> m_next_event_action_up;\n  std::vector<PreResumeCallbackAndBaton> m_pre_resume_actions;\n  ProcessRunLock m_public_run_lock;\n  ProcessRunLock m_private_run_lock;\n  bool m_currently_handling_do_on_removals;\n  bool m_resume_requested; // If m_currently_handling_event or\n                           // m_currently_handling_do_on_removals are true,\n                           // Resume will only request a resume, using this\n                           // flag to check.\n\n  /// This is set at the beginning of Process::Finalize() to stop functions\n  /// from looking up or creating things during or after a finalize call.\n  std::atomic<bool> m_finalizing;\n\n  bool m_clear_thread_plans_on_stop;\n  bool m_force_next_event_delivery;\n  lldb::StateType m_last_broadcast_state; /// This helps with the Public event\n                                          /// coalescing in\n                                          /// ShouldBroadcastEvent.\n  std::map<lldb::addr_t, lldb::addr_t> m_resolved_indirect_addresses;\n  bool m_destroy_in_process;\n  bool m_can_interpret_function_calls;  // Some targets, e.g the OSX kernel,\n                                        // don't support the ability to modify\n                                        // the stack.\n  WarningsCollection m_warnings_issued; // A set of object pointers which have\n                                        // already had warnings printed\n  std::mutex m_run_thread_plan_lock;\n  StructuredDataPluginMap m_structured_data_plugin_map;\n\n  enum { eCanJITDontKnow = 0, eCanJITYes, eCanJITNo } m_can_jit;\n\n  std::unique_ptr<UtilityFunction> m_dlopen_utility_func_up;\n  llvm::once_flag m_dlopen_utility_func_flag_once;\n\n  size_t RemoveBreakpointOpcodesFromBuffer(lldb::addr_t addr, size_t size,\n                                           uint8_t *buf) const;\n\n  void SynchronouslyNotifyStateChanged(lldb::StateType state);\n\n  void SetPublicState(lldb::StateType new_state, bool restarted);\n\n  void SetPrivateState(lldb::StateType state);\n\n  bool StartPrivateStateThread(bool is_secondary_thread = false);\n\n  void StopPrivateStateThread();\n\n  void PausePrivateStateThread();\n\n  void ResumePrivateStateThread();\n\nprivate:\n  struct PrivateStateThreadArgs {\n    PrivateStateThreadArgs(Process *p, bool s)\n        : process(p), is_secondary_thread(s){};\n    Process *process;\n    bool is_secondary_thread;\n  };\n\n  // arg is a pointer to a new'ed PrivateStateThreadArgs structure.\n  // PrivateStateThread will free it for you.\n  static lldb::thread_result_t PrivateStateThread(void *arg);\n\n  // The starts up the private state thread that will watch for events from the\n  // debugee. Pass true for is_secondary_thread in the case where you have to\n  // temporarily spin up a secondary state thread to handle events from a hand-\n  // called function on the primary private state thread.\n\n  lldb::thread_result_t RunPrivateStateThread(bool is_secondary_thread);\n\nprotected:\n  void HandlePrivateEvent(lldb::EventSP &event_sp);\n\n  Status HaltPrivate();\n\n  lldb::StateType WaitForProcessStopPrivate(lldb::EventSP &event_sp,\n                                            const Timeout<std::micro> &timeout);\n\n  // This waits for both the state change broadcaster, and the control\n  // broadcaster. If control_only, it only waits for the control broadcaster.\n\n  bool GetEventsPrivate(lldb::EventSP &event_sp,\n                        const Timeout<std::micro> &timeout, bool control_only);\n\n  lldb::StateType\n  GetStateChangedEventsPrivate(lldb::EventSP &event_sp,\n                               const Timeout<std::micro> &timeout);\n\n  size_t WriteMemoryPrivate(lldb::addr_t addr, const void *buf, size_t size,\n                            Status &error);\n\n  void AppendSTDOUT(const char *s, size_t len);\n\n  void AppendSTDERR(const char *s, size_t len);\n\n  void BroadcastAsyncProfileData(const std::string &one_profile_data);\n\n  static void STDIOReadThreadBytesReceived(void *baton, const void *src,\n                                           size_t src_len);\n\n  bool PushProcessIOHandler();\n\n  bool PopProcessIOHandler();\n\n  bool ProcessIOHandlerIsActive();\n\n  bool ProcessIOHandlerExists() const {\n    return static_cast<bool>(m_process_input_reader);\n  }\n\n  Status StopForDestroyOrDetach(lldb::EventSP &exit_event_sp);\n\n  virtual Status UpdateAutomaticSignalFiltering();\n\n  void LoadOperatingSystemPlugin(bool flush);\n\nprivate:\n  Status DestroyImpl(bool force_kill);\n\n  /// This is the part of the event handling that for a process event. It\n  /// decides what to do with the event and returns true if the event needs to\n  /// be propagated to the user, and false otherwise. If the event is not\n  /// propagated, this call will most likely set the target to executing\n  /// again. There is only one place where this call should be called,\n  /// HandlePrivateEvent. Don't call it from anywhere else...\n  ///\n  /// \\param[in] event_ptr\n  ///     This is the event we are handling.\n  ///\n  /// \\return\n  ///     Returns \\b true if the event should be reported to the\n  ///     user, \\b false otherwise.\n  bool ShouldBroadcastEvent(Event *event_ptr);\n\n  void ControlPrivateStateThread(uint32_t signal);\n\n  Process(const Process &) = delete;\n  const Process &operator=(const Process &) = delete;\n};\n\n/// RAII guard that should be acquired when an utility function is called within\n/// a given process.\nclass UtilityFunctionScope {\n  Process *m_process;\n\npublic:\n  UtilityFunctionScope(Process *p) : m_process(p) {\n    if (m_process)\n      m_process->SetRunningUtilityFunction(true);\n  }\n  ~UtilityFunctionScope() {\n    if (m_process)\n      m_process->SetRunningUtilityFunction(false);\n  }\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_TARGET_PROCESS_H\n"}, "14": {"id": 14, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Target/StackID.h", "content": "//===-- StackID.h -----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_TARGET_STACKID_H\n#define LLDB_TARGET_STACKID_H\n\n#include \"lldb/Core/AddressRange.h\"\n#include \"lldb/lldb-private.h\"\n\nnamespace lldb_private {\n\nclass StackID {\npublic:\n  // Constructors and Destructors\n  StackID()\n      : m_pc(LLDB_INVALID_ADDRESS), m_cfa(LLDB_INVALID_ADDRESS),\n        m_symbol_scope(nullptr) {}\n\n  explicit StackID(lldb::addr_t pc, lldb::addr_t cfa,\n                   SymbolContextScope *symbol_scope)\n      : m_pc(pc), m_cfa(cfa), m_symbol_scope(symbol_scope) {}\n\n  StackID(const StackID &rhs)\n      : m_pc(rhs.m_pc), m_cfa(rhs.m_cfa), m_symbol_scope(rhs.m_symbol_scope) {}\n\n  ~StackID() = default;\n\n  lldb::addr_t GetPC() const { return m_pc; }\n\n  lldb::addr_t GetCallFrameAddress() const { return m_cfa; }\n\n  SymbolContextScope *GetSymbolContextScope() const { return m_symbol_scope; }\n\n  void SetSymbolContextScope(SymbolContextScope *symbol_scope) {\n    m_symbol_scope = symbol_scope;\n  }\n\n  void Clear() {\n    m_pc = LLDB_INVALID_ADDRESS;\n    m_cfa = LLDB_INVALID_ADDRESS;\n    m_symbol_scope = nullptr;\n  }\n\n  bool IsValid() const {\n    return m_pc != LLDB_INVALID_ADDRESS || m_cfa != LLDB_INVALID_ADDRESS;\n  }\n\n  void Dump(Stream *s);\n\n  // Operators\n  const StackID &operator=(const StackID &rhs) {\n    if (this != &rhs) {\n      m_pc = rhs.m_pc;\n      m_cfa = rhs.m_cfa;\n      m_symbol_scope = rhs.m_symbol_scope;\n    }\n    return *this;\n  }\n\nprotected:\n  friend class StackFrame;\n\n  void SetPC(lldb::addr_t pc) { m_pc = pc; }\n\n  void SetCFA(lldb::addr_t cfa) { m_cfa = cfa; }\n\n  lldb::addr_t\n      m_pc; // The pc value for the function/symbol for this frame. This will\n  // only get used if the symbol scope is nullptr (the code where we are\n  // stopped is not represented by any function or symbol in any shared\n  // library).\n  lldb::addr_t m_cfa; // The call frame address (stack pointer) value\n                      // at the beginning of the function that uniquely\n                      // identifies this frame (along with m_symbol_scope\n                      // below)\n  SymbolContextScope *\n      m_symbol_scope; // If nullptr, there is no block or symbol for this frame.\n                      // If not nullptr, this will either be the scope for the\n                      // lexical block for the frame, or the scope for the\n                      // symbol. Symbol context scopes are always be unique\n                      // pointers since the are part of the Block and Symbol\n                      // objects and can easily be used to tell if a stack ID\n                      // is the same as another.\n};\n\nbool operator==(const StackID &lhs, const StackID &rhs);\nbool operator!=(const StackID &lhs, const StackID &rhs);\n\n// frame_id_1 < frame_id_2 means \"frame_id_1 is YOUNGER than frame_id_2\"\nbool operator<(const StackID &lhs, const StackID &rhs);\n\n} // namespace lldb_private\n\n#endif // LLDB_TARGET_STACKID_H\n"}, "15": {"id": 15, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/ArchSpec.h", "content": "//===-- ArchSpec.h ----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_ARCHSPEC_H\n#define LLDB_UTILITY_ARCHSPEC_H\n\n#include \"lldb/Utility/CompletionRequest.h\"\n#include \"lldb/Utility/ConstString.h\"\n#include \"lldb/lldb-enumerations.h\"\n#include \"lldb/lldb-forward.h\"\n#include \"lldb/lldb-private-enumerations.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/Support/YAMLTraits.h\"\n#include <cstddef>\n#include <cstdint>\n#include <string>\n\nnamespace lldb_private {\n\n/// \\class ArchSpec ArchSpec.h \"lldb/Utility/ArchSpec.h\" An architecture\n/// specification class.\n///\n/// A class designed to be created from a cpu type and subtype, a\n/// string representation, or an llvm::Triple.  Keeping all of the conversions\n/// of strings to architecture enumeration values confined to this class\n/// allows new architecture support to be added easily.\nclass ArchSpec {\npublic:\n  enum MIPSSubType {\n    eMIPSSubType_unknown,\n    eMIPSSubType_mips32,\n    eMIPSSubType_mips32r2,\n    eMIPSSubType_mips32r6,\n    eMIPSSubType_mips32el,\n    eMIPSSubType_mips32r2el,\n    eMIPSSubType_mips32r6el,\n    eMIPSSubType_mips64,\n    eMIPSSubType_mips64r2,\n    eMIPSSubType_mips64r6,\n    eMIPSSubType_mips64el,\n    eMIPSSubType_mips64r2el,\n    eMIPSSubType_mips64r6el,\n  };\n\n  // Masks for the ases word of an ABI flags structure.\n  enum MIPSASE {\n    eMIPSAse_dsp = 0x00000001,       // DSP ASE\n    eMIPSAse_dspr2 = 0x00000002,     // DSP R2 ASE\n    eMIPSAse_eva = 0x00000004,       // Enhanced VA Scheme\n    eMIPSAse_mcu = 0x00000008,       // MCU (MicroController) ASE\n    eMIPSAse_mdmx = 0x00000010,      // MDMX ASE\n    eMIPSAse_mips3d = 0x00000020,    // MIPS-3D ASE\n    eMIPSAse_mt = 0x00000040,        // MT ASE\n    eMIPSAse_smartmips = 0x00000080, // SmartMIPS ASE\n    eMIPSAse_virt = 0x00000100,      // VZ ASE\n    eMIPSAse_msa = 0x00000200,       // MSA ASE\n    eMIPSAse_mips16 = 0x00000400,    // MIPS16 ASE\n    eMIPSAse_micromips = 0x00000800, // MICROMIPS ASE\n    eMIPSAse_xpa = 0x00001000,       // XPA ASE\n    eMIPSAse_mask = 0x00001fff,\n    eMIPSABI_O32 = 0x00002000,\n    eMIPSABI_N32 = 0x00004000,\n    eMIPSABI_N64 = 0x00008000,\n    eMIPSABI_O64 = 0x00020000,\n    eMIPSABI_EABI32 = 0x00040000,\n    eMIPSABI_EABI64 = 0x00080000,\n    eMIPSABI_mask = 0x000ff000\n  };\n\n  // MIPS Floating point ABI Values\n  enum MIPS_ABI_FP {\n    eMIPS_ABI_FP_ANY = 0x00000000,\n    eMIPS_ABI_FP_DOUBLE = 0x00100000, // hard float / -mdouble-float\n    eMIPS_ABI_FP_SINGLE = 0x00200000, // hard float / -msingle-float\n    eMIPS_ABI_FP_SOFT = 0x00300000,   // soft float\n    eMIPS_ABI_FP_OLD_64 = 0x00400000, // -mips32r2 -mfp64\n    eMIPS_ABI_FP_XX = 0x00500000,     // -mfpxx\n    eMIPS_ABI_FP_64 = 0x00600000,     // -mips32r2 -mfp64\n    eMIPS_ABI_FP_64A = 0x00700000,    // -mips32r2 -mfp64 -mno-odd-spreg\n    eMIPS_ABI_FP_mask = 0x00700000\n  };\n\n  // ARM specific e_flags\n  enum ARMeflags {\n    eARM_abi_soft_float = 0x00000200,\n    eARM_abi_hard_float = 0x00000400\n  };\n\n  enum RISCVSubType {\n    eRISCVSubType_unknown,\n    eRISCVSubType_riscv32,\n    eRISCVSubType_riscv64,\n  };\n\n  enum Core {\n    eCore_arm_generic,\n    eCore_arm_armv4,\n    eCore_arm_armv4t,\n    eCore_arm_armv5,\n    eCore_arm_armv5e,\n    eCore_arm_armv5t,\n    eCore_arm_armv6,\n    eCore_arm_armv6m,\n    eCore_arm_armv7,\n    eCore_arm_armv7l,\n    eCore_arm_armv7f,\n    eCore_arm_armv7s,\n    eCore_arm_armv7k,\n    eCore_arm_armv7m,\n    eCore_arm_armv7em,\n    eCore_arm_xscale,\n\n    eCore_thumb,\n    eCore_thumbv4t,\n    eCore_thumbv5,\n    eCore_thumbv5e,\n    eCore_thumbv6,\n    eCore_thumbv6m,\n    eCore_thumbv7,\n    eCore_thumbv7s,\n    eCore_thumbv7k,\n    eCore_thumbv7f,\n    eCore_thumbv7m,\n    eCore_thumbv7em,\n    eCore_arm_arm64,\n    eCore_arm_armv8,\n    eCore_arm_armv8l,\n    eCore_arm_arm64e,\n    eCore_arm_arm64_32,\n    eCore_arm_aarch64,\n\n    eCore_mips32,\n    eCore_mips32r2,\n    eCore_mips32r3,\n    eCore_mips32r5,\n    eCore_mips32r6,\n    eCore_mips32el,\n    eCore_mips32r2el,\n    eCore_mips32r3el,\n    eCore_mips32r5el,\n    eCore_mips32r6el,\n    eCore_mips64,\n    eCore_mips64r2,\n    eCore_mips64r3,\n    eCore_mips64r5,\n    eCore_mips64r6,\n    eCore_mips64el,\n    eCore_mips64r2el,\n    eCore_mips64r3el,\n    eCore_mips64r5el,\n    eCore_mips64r6el,\n\n    eCore_ppc_generic,\n    eCore_ppc_ppc601,\n    eCore_ppc_ppc602,\n    eCore_ppc_ppc603,\n    eCore_ppc_ppc603e,\n    eCore_ppc_ppc603ev,\n    eCore_ppc_ppc604,\n    eCore_ppc_ppc604e,\n    eCore_ppc_ppc620,\n    eCore_ppc_ppc750,\n    eCore_ppc_ppc7400,\n    eCore_ppc_ppc7450,\n    eCore_ppc_ppc970,\n\n    eCore_ppc64le_generic,\n    eCore_ppc64_generic,\n    eCore_ppc64_ppc970_64,\n\n    eCore_s390x_generic,\n\n    eCore_sparc_generic,\n\n    eCore_sparc9_generic,\n\n    eCore_x86_32_i386,\n    eCore_x86_32_i486,\n    eCore_x86_32_i486sx,\n    eCore_x86_32_i686,\n\n    eCore_x86_64_x86_64,\n    eCore_x86_64_x86_64h, // Haswell enabled x86_64\n    eCore_hexagon_generic,\n    eCore_hexagon_hexagonv4,\n    eCore_hexagon_hexagonv5,\n\n    eCore_riscv32,\n    eCore_riscv64,\n\n    eCore_uknownMach32,\n    eCore_uknownMach64,\n\n    eCore_arc, // little endian ARC\n\n    eCore_avr,\n\n    eCore_wasm32,\n\n    kNumCores,\n\n    kCore_invalid,\n    // The following constants are used for wildcard matching only\n    kCore_any,\n    kCore_arm_any,\n    kCore_ppc_any,\n    kCore_ppc64_any,\n    kCore_x86_32_any,\n    kCore_x86_64_any,\n    kCore_hexagon_any,\n\n    kCore_arm_first = eCore_arm_generic,\n    kCore_arm_last = eCore_arm_xscale,\n\n    kCore_thumb_first = eCore_thumb,\n    kCore_thumb_last = eCore_thumbv7em,\n\n    kCore_ppc_first = eCore_ppc_generic,\n    kCore_ppc_last = eCore_ppc_ppc970,\n\n    kCore_ppc64_first = eCore_ppc64_generic,\n    kCore_ppc64_last = eCore_ppc64_ppc970_64,\n\n    kCore_x86_32_first = eCore_x86_32_i386,\n    kCore_x86_32_last = eCore_x86_32_i686,\n\n    kCore_x86_64_first = eCore_x86_64_x86_64,\n    kCore_x86_64_last = eCore_x86_64_x86_64h,\n\n    kCore_hexagon_first = eCore_hexagon_generic,\n    kCore_hexagon_last = eCore_hexagon_hexagonv5,\n\n    kCore_mips32_first = eCore_mips32,\n    kCore_mips32_last = eCore_mips32r6,\n\n    kCore_mips32el_first = eCore_mips32el,\n    kCore_mips32el_last = eCore_mips32r6el,\n\n    kCore_mips64_first = eCore_mips64,\n    kCore_mips64_last = eCore_mips64r6,\n\n    kCore_mips64el_first = eCore_mips64el,\n    kCore_mips64el_last = eCore_mips64r6el,\n\n    kCore_mips_first = eCore_mips32,\n    kCore_mips_last = eCore_mips64r6el\n\n  };\n\n  /// Default constructor.\n  ///\n  /// Default constructor that initializes the object with invalid cpu type\n  /// and subtype values.\n  ArchSpec();\n\n  /// Constructor over triple.\n  ///\n  /// Constructs an ArchSpec with properties consistent with the given Triple.\n  explicit ArchSpec(const llvm::Triple &triple);\n  explicit ArchSpec(const char *triple_cstr);\n  explicit ArchSpec(llvm::StringRef triple_str);\n  /// Constructor over architecture name.\n  ///\n  /// Constructs an ArchSpec with properties consistent with the given object\n  /// type and architecture name.\n  explicit ArchSpec(ArchitectureType arch_type, uint32_t cpu_type,\n                    uint32_t cpu_subtype);\n\n  /// Destructor.\n  ~ArchSpec();\n\n  /// Returns true if the OS, vendor and environment fields of the triple are\n  /// unset. The triple is expected to be normalized\n  /// (llvm::Triple::normalize).\n  static bool ContainsOnlyArch(const llvm::Triple &normalized_triple);\n\n  static void ListSupportedArchNames(StringList &list);\n  static void AutoComplete(CompletionRequest &request);\n\n  /// Returns a static string representing the current architecture.\n  ///\n  /// \\return A static string corresponding to the current\n  ///         architecture.\n  const char *GetArchitectureName() const;\n\n  /// if MIPS architecture return true.\n  ///\n  ///  \\return a boolean value.\n  bool IsMIPS() const;\n\n  /// Returns a string representing current architecture as a target CPU for\n  /// tools like compiler, disassembler etc.\n  ///\n  /// \\return A string representing target CPU for the current\n  ///         architecture.\n  std::string GetClangTargetCPU() const;\n\n  /// Return a string representing target application ABI.\n  ///\n  /// \\return A string representing target application ABI.\n  std::string GetTargetABI() const;\n\n  /// Clears the object state.\n  ///\n  /// Clears the object state back to a default invalid state.\n  void Clear();\n\n  /// Returns the size in bytes of an address of the current architecture.\n  ///\n  /// \\return The byte size of an address of the current architecture.\n  uint32_t GetAddressByteSize() const;\n\n  /// Returns a machine family for the current architecture.\n  ///\n  /// \\return An LLVM arch type.\n  llvm::Triple::ArchType GetMachine() const;\n\n  /// Returns the distribution id of the architecture.\n  ///\n  /// This will be something like \"ubuntu\", \"fedora\", etc. on Linux.\n  ///\n  /// \\return A ConstString ref containing the distribution id,\n  ///         potentially empty.\n  ConstString GetDistributionId() const;\n\n  /// Set the distribution id of the architecture.\n  ///\n  /// This will be something like \"ubuntu\", \"fedora\", etc. on Linux. This\n  /// should be the same value returned by HostInfo::GetDistributionId ().\n  void SetDistributionId(const char *distribution_id);\n\n  /// Tests if this ArchSpec is valid.\n  ///\n  /// \\return True if the current architecture is valid, false\n  ///         otherwise.\n  bool IsValid() const {\n    return m_core >= eCore_arm_generic && m_core < kNumCores;\n  }\n  explicit operator bool() const { return IsValid(); }\n\n  bool TripleVendorWasSpecified() const {\n    return !m_triple.getVendorName().empty();\n  }\n\n  bool TripleOSWasSpecified() const { return !m_triple.getOSName().empty(); }\n\n  bool TripleEnvironmentWasSpecified() const {\n    return m_triple.hasEnvironment();\n  }\n\n  /// Merges fields from another ArchSpec into this ArchSpec.\n  ///\n  /// This will use the supplied ArchSpec to fill in any fields of the triple\n  /// in this ArchSpec which were unspecified.  This can be used to refine a\n  /// generic ArchSpec with a more specific one. For example, if this\n  /// ArchSpec's triple is something like i386-unknown-unknown-unknown, and we\n  /// have a triple which is x64-pc-windows-msvc, then merging that triple\n  /// into this one will result in the triple i386-pc-windows-msvc.\n  ///\n  void MergeFrom(const ArchSpec &other);\n\n  /// Change the architecture object type, CPU type and OS type.\n  ///\n  /// \\param[in] arch_type The object type of this ArchSpec.\n  ///\n  /// \\param[in] cpu The required CPU type.\n  ///\n  /// \\param[in] os The optional OS type\n  /// The default value of 0 was chosen to from the ELF spec value\n  /// ELFOSABI_NONE.  ELF is the only one using this parameter.  If another\n  /// format uses this parameter and 0 does not work, use a value over\n  /// 255 because in the ELF header this is value is only a byte.\n  ///\n  /// \\return True if the object, and CPU were successfully set.\n  ///\n  /// As a side effect, the vendor value is usually set to unknown. The\n  /// exceptions are\n  ///   aarch64-apple-ios\n  ///   arm-apple-ios\n  ///   thumb-apple-ios\n  ///   x86-apple-\n  ///   x86_64-apple-\n  ///\n  /// As a side effect, the os value is usually set to unknown The exceptions\n  /// are\n  ///   *-*-aix\n  ///   aarch64-apple-ios\n  ///   arm-apple-ios\n  ///   thumb-apple-ios\n  ///   powerpc-apple-darwin\n  ///   *-*-freebsd\n  ///   *-*-linux\n  ///   *-*-netbsd\n  ///   *-*-openbsd\n  ///   *-*-solaris\n  bool SetArchitecture(ArchitectureType arch_type, uint32_t cpu, uint32_t sub,\n                       uint32_t os = 0);\n\n  /// Returns the byte order for the architecture specification.\n  ///\n  /// \\return The endian enumeration for the current endianness of\n  ///     the architecture specification\n  lldb::ByteOrder GetByteOrder() const;\n\n  /// Sets this ArchSpec's byte order.\n  ///\n  /// In the common case there is no need to call this method as the byte\n  /// order can almost always be determined by the architecture. However, many\n  /// CPU's are bi-endian (ARM, Alpha, PowerPC, etc) and the default/assumed\n  /// byte order may be incorrect.\n  void SetByteOrder(lldb::ByteOrder byte_order) { m_byte_order = byte_order; }\n\n  uint32_t GetMinimumOpcodeByteSize() const;\n\n  uint32_t GetMaximumOpcodeByteSize() const;\n\n  Core GetCore() const { return m_core; }\n\n  uint32_t GetMachOCPUType() const;\n\n  uint32_t GetMachOCPUSubType() const;\n\n  /// Architecture data byte width accessor\n  ///\n  /// \\return the size in 8-bit (host) bytes of a minimum addressable unit\n  /// from the Architecture's data bus\n  uint32_t GetDataByteSize() const;\n\n  /// Architecture code byte width accessor\n  ///\n  /// \\return the size in 8-bit (host) bytes of a minimum addressable unit\n  /// from the Architecture's code bus\n  uint32_t GetCodeByteSize() const;\n\n  /// Architecture triple accessor.\n  ///\n  /// \\return A triple describing this ArchSpec.\n  llvm::Triple &GetTriple() { return m_triple; }\n\n  /// Architecture triple accessor.\n  ///\n  /// \\return A triple describing this ArchSpec.\n  const llvm::Triple &GetTriple() const { return m_triple; }\n\n  void DumpTriple(llvm::raw_ostream &s) const;\n\n  /// Architecture triple setter.\n  ///\n  /// Configures this ArchSpec according to the given triple.  If the triple\n  /// has unknown components in all of the vendor, OS, and the optional\n  /// environment field (i.e. \"i386-unknown-unknown\") then default values are\n  /// taken from the host.  Architecture and environment components are used\n  /// to further resolve the CPU type and subtype, endian characteristics,\n  /// etc.\n  ///\n  /// \\return A triple describing this ArchSpec.\n  bool SetTriple(const llvm::Triple &triple);\n\n  bool SetTriple(llvm::StringRef triple_str);\n\n  /// Returns the default endianness of the architecture.\n  ///\n  /// \\return The endian enumeration for the default endianness of\n  ///         the architecture.\n  lldb::ByteOrder GetDefaultEndian() const;\n\n  /// Returns true if 'char' is a signed type by default in the architecture\n  /// false otherwise\n  ///\n  /// \\return True if 'char' is a signed type by default on the\n  ///         architecture and false otherwise.\n  bool CharIsSignedByDefault() const;\n\n  /// Compare an ArchSpec to another ArchSpec, requiring an exact cpu type\n  /// match between them. e.g. armv7s is not an exact match with armv7 - this\n  /// would return false\n  ///\n  /// \\return true if the two ArchSpecs match.\n  bool IsExactMatch(const ArchSpec &rhs) const;\n\n  /// Compare an ArchSpec to another ArchSpec, requiring a compatible cpu type\n  /// match between them. e.g. armv7s is compatible with armv7 - this method\n  /// would return true\n  ///\n  /// \\return true if the two ArchSpecs are compatible\n  bool IsCompatibleMatch(const ArchSpec &rhs) const;\n\n  bool IsFullySpecifiedTriple() const;\n\n  void PiecewiseTripleCompare(const ArchSpec &other, bool &arch_different,\n                              bool &vendor_different, bool &os_different,\n                              bool &os_version_different,\n                              bool &env_different) const;\n\n  /// Detect whether this architecture uses thumb code exclusively\n  ///\n  /// Some embedded ARM chips (e.g. the ARM Cortex M0-7 line) can only execute\n  /// the Thumb instructions, never Arm.  We should normally pick up\n  /// arm/thumbness from their the processor status bits (cpsr/xpsr) or hints\n  /// on each function - but when doing bare-boards low level debugging\n  /// (especially common with these embedded processors), we may not have\n  /// those things easily accessible.\n  ///\n  /// \\return true if this is an arm ArchSpec which can only execute Thumb\n  ///         instructions\n  bool IsAlwaysThumbInstructions() const;\n\n  uint32_t GetFlags() const { return m_flags; }\n\n  void SetFlags(uint32_t flags) { m_flags = flags; }\n\n  void SetFlags(const std::string &elf_abi);\n\nprotected:\n  bool IsEqualTo(const ArchSpec &rhs, bool exact_match) const;\n  void UpdateCore();\n\n  llvm::Triple m_triple;\n  Core m_core = kCore_invalid;\n  lldb::ByteOrder m_byte_order = lldb::eByteOrderInvalid;\n\n  // Additional arch flags which we cannot get from triple and core For MIPS\n  // these are application specific extensions like micromips, mips16 etc.\n  uint32_t m_flags = 0;\n\n  ConstString m_distribution_id;\n\n  // Called when m_def or m_entry are changed.  Fills in all remaining members\n  // with default values.\n  void CoreUpdated(bool update_triple);\n};\n\n/// \\fn bool operator< (const ArchSpec& lhs, const ArchSpec& rhs) Less than\n/// operator.\n///\n/// Tests two ArchSpec objects to see if \\a lhs is less than \\a rhs.\n///\n/// \\param[in] lhs The Left Hand Side ArchSpec object to compare. \\param[in]\n/// rhs The Left Hand Side ArchSpec object to compare.\n///\n/// \\return true if \\a lhs is less than \\a rhs\nbool operator<(const ArchSpec &lhs, const ArchSpec &rhs);\nbool operator==(const ArchSpec &lhs, const ArchSpec &rhs);\n\nbool ParseMachCPUDashSubtypeTriple(llvm::StringRef triple_str, ArchSpec &arch);\n\n} // namespace lldb_private\n\nnamespace llvm {\nnamespace yaml {\ntemplate <> struct ScalarTraits<lldb_private::ArchSpec> {\n  static void output(const lldb_private::ArchSpec &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, lldb_private::ArchSpec &);\n  static QuotingType mustQuote(StringRef S) { return QuotingType::Double; }\n};\n} // namespace yaml\n} // namespace llvm\n\nLLVM_YAML_IS_SEQUENCE_VECTOR(lldb_private::ArchSpec)\n\n#endif // LLDB_UTILITY_ARCHSPEC_H\n"}, "16": {"id": 16, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Broadcaster.h", "content": "//===-- Broadcaster.h -------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_BROADCASTER_H\n#define LLDB_UTILITY_BROADCASTER_H\n\n#include \"lldb/Utility/ConstString.h\"\n#include \"lldb/lldb-defines.h\"\n#include \"lldb/lldb-forward.h\"\n\n#include \"llvm/ADT/SmallVector.h\"\n\n#include <cstdint>\n#include <map>\n#include <memory>\n#include <mutex>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace lldb_private {\nclass Broadcaster;\nclass EventData;\nclass Listener;\nclass Stream;\n} // namespace lldb_private\n\nnamespace lldb_private {\n\n/// lldb::BroadcastEventSpec\n///\n/// This class is used to specify a kind of event to register for.  The\n/// Debugger maintains a list of BroadcastEventSpec's and when it is made\nclass BroadcastEventSpec {\npublic:\n  BroadcastEventSpec(const ConstString &broadcaster_class, uint32_t event_bits)\n      : m_broadcaster_class(broadcaster_class), m_event_bits(event_bits) {}\n\n  ~BroadcastEventSpec() = default;\n\n  ConstString GetBroadcasterClass() const { return m_broadcaster_class; }\n\n  uint32_t GetEventBits() const { return m_event_bits; }\n\n  /// Tell whether this BroadcastEventSpec is contained in in_spec. That is:\n  /// (a) the two spec's share the same broadcaster class (b) the event bits of\n  /// this spec are wholly contained in those of in_spec.\n  bool IsContainedIn(const BroadcastEventSpec &in_spec) const {\n    if (m_broadcaster_class != in_spec.GetBroadcasterClass())\n      return false;\n    uint32_t in_bits = in_spec.GetEventBits();\n    if (in_bits == m_event_bits)\n      return true;\n\n    if ((m_event_bits & in_bits) != 0 && (m_event_bits & ~in_bits) == 0)\n      return true;\n\n    return false;\n  }\n\n  bool operator<(const BroadcastEventSpec &rhs) const;\n\nprivate:\n  ConstString m_broadcaster_class;\n  uint32_t m_event_bits;\n};\n\nclass BroadcasterManager\n    : public std::enable_shared_from_this<BroadcasterManager> {\npublic:\n  friend class Listener;\n\nprotected:\n  BroadcasterManager();\n\npublic:\n  /// Listeners hold onto weak pointers to their broadcaster managers.  So they\n  /// must be made into shared pointers, which you do with\n  /// MakeBroadcasterManager.\n  static lldb::BroadcasterManagerSP MakeBroadcasterManager();\n\n  ~BroadcasterManager() = default;\n\n  uint32_t RegisterListenerForEvents(const lldb::ListenerSP &listener_sp,\n                                     const BroadcastEventSpec &event_spec);\n\n  bool UnregisterListenerForEvents(const lldb::ListenerSP &listener_sp,\n                                   const BroadcastEventSpec &event_spec);\n\n  lldb::ListenerSP\n  GetListenerForEventSpec(const BroadcastEventSpec &event_spec) const;\n\n  void SignUpListenersForBroadcaster(Broadcaster &broadcaster);\n\n  void RemoveListener(const lldb::ListenerSP &listener_sp);\n\n  void RemoveListener(Listener *listener);\n\n  void Clear();\n\nprivate:\n  typedef std::pair<BroadcastEventSpec, lldb::ListenerSP> event_listener_key;\n  typedef std::map<BroadcastEventSpec, lldb::ListenerSP> collection;\n  typedef std::set<lldb::ListenerSP> listener_collection;\n  collection m_event_map;\n  listener_collection m_listeners;\n\n  mutable std::recursive_mutex m_manager_mutex;\n\n  // A couple of comparator classes for find_if:\n\n  class BroadcasterClassMatches {\n  public:\n    BroadcasterClassMatches(const ConstString &broadcaster_class)\n        : m_broadcaster_class(broadcaster_class) {}\n\n    ~BroadcasterClassMatches() = default;\n\n    bool operator()(const event_listener_key &input) const {\n      return (input.first.GetBroadcasterClass() == m_broadcaster_class);\n    }\n\n  private:\n    ConstString m_broadcaster_class;\n  };\n\n  class BroadcastEventSpecMatches {\n  public:\n    BroadcastEventSpecMatches(const BroadcastEventSpec &broadcaster_spec)\n        : m_broadcaster_spec(broadcaster_spec) {}\n\n    ~BroadcastEventSpecMatches() = default;\n\n    bool operator()(const event_listener_key &input) const {\n      return (input.first.IsContainedIn(m_broadcaster_spec));\n    }\n\n  private:\n    BroadcastEventSpec m_broadcaster_spec;\n  };\n\n  class ListenerMatchesAndSharedBits {\n  public:\n    explicit ListenerMatchesAndSharedBits(\n        const BroadcastEventSpec &broadcaster_spec,\n        const lldb::ListenerSP &listener_sp)\n        : m_broadcaster_spec(broadcaster_spec), m_listener_sp(listener_sp) {}\n\n    ~ListenerMatchesAndSharedBits() = default;\n\n    bool operator()(const event_listener_key &input) const {\n      return (input.first.GetBroadcasterClass() ==\n                  m_broadcaster_spec.GetBroadcasterClass() &&\n              (input.first.GetEventBits() &\n               m_broadcaster_spec.GetEventBits()) != 0 &&\n              input.second == m_listener_sp);\n    }\n\n  private:\n    BroadcastEventSpec m_broadcaster_spec;\n    const lldb::ListenerSP m_listener_sp;\n  };\n\n  class ListenerMatches {\n  public:\n    explicit ListenerMatches(const lldb::ListenerSP &in_listener_sp)\n        : m_listener_sp(in_listener_sp) {}\n\n    ~ListenerMatches() = default;\n\n    bool operator()(const event_listener_key &input) const {\n      if (input.second == m_listener_sp)\n        return true;\n\n      return false;\n    }\n\n  private:\n    const lldb::ListenerSP m_listener_sp;\n  };\n\n  class ListenerMatchesPointer {\n  public:\n    ListenerMatchesPointer(const Listener *in_listener)\n        : m_listener(in_listener) {}\n\n    ~ListenerMatchesPointer() = default;\n\n    bool operator()(const event_listener_key &input) const {\n      if (input.second.get() == m_listener)\n        return true;\n\n      return false;\n    }\n\n    bool operator()(const lldb::ListenerSP &input) const {\n      if (input.get() == m_listener)\n        return true;\n\n      return false;\n    }\n\n  private:\n    const Listener *m_listener;\n  };\n};\n\n/// \\class Broadcaster Broadcaster.h \"lldb/Utility/Broadcaster.h\" An event\n/// broadcasting class.\n///\n/// The Broadcaster class is designed to be subclassed by objects that wish to\n/// vend events in a multi-threaded environment. Broadcaster objects can each\n/// vend 32 events. Each event is represented by a bit in a 32 bit value and\n/// these bits can be set:\n///     \\see Broadcaster::SetEventBits(uint32_t)\n/// or cleared:\n///     \\see Broadcaster::ResetEventBits(uint32_t)\n/// When an event gets set the Broadcaster object will notify the Listener\n/// object that is listening for the event (if there is one).\n///\n/// Subclasses should provide broadcast bit definitions for any events they\n/// vend, typically using an enumeration:\n///     \\code\n///         class Foo : public Broadcaster\n///         {\n///         public:\n///         // Broadcaster event bits definitions.\n///         enum\n///         {\n///             eBroadcastBitOne   = (1 << 0),\n///             eBroadcastBitTwo   = (1 << 1),\n///             eBroadcastBitThree = (1 << 2),\n///             ...\n///         };\n///     \\endcode\nclass Broadcaster {\n  friend class Listener;\n  friend class Event;\n\npublic:\n  /// Construct with a broadcaster with a name.\n  ///\n  /// \\param[in] name\n  ///     A NULL terminated C string that contains the name of the\n  ///     broadcaster object.\n  Broadcaster(lldb::BroadcasterManagerSP manager_sp, const char *name);\n\n  /// Destructor.\n  ///\n  /// The destructor is virtual since this class gets subclassed.\n  virtual ~Broadcaster();\n\n  void CheckInWithManager();\n\n  /// Broadcast an event which has no associated data.\n  void BroadcastEvent(lldb::EventSP &event_sp) {\n    m_broadcaster_sp->BroadcastEvent(event_sp);\n  }\n\n  void BroadcastEventIfUnique(lldb::EventSP &event_sp) {\n    m_broadcaster_sp->BroadcastEventIfUnique(event_sp);\n  }\n\n  void BroadcastEvent(uint32_t event_type,\n                      const lldb::EventDataSP &event_data_sp) {\n    m_broadcaster_sp->BroadcastEvent(event_type, event_data_sp);\n  }\n\n  void BroadcastEvent(uint32_t event_type, EventData *event_data = nullptr) {\n    m_broadcaster_sp->BroadcastEvent(event_type, event_data);\n  }\n\n  void BroadcastEventIfUnique(uint32_t event_type,\n                              EventData *event_data = nullptr) {\n    m_broadcaster_sp->BroadcastEventIfUnique(event_type, event_data);\n  }\n\n  void Clear() { m_broadcaster_sp->Clear(); }\n\n  virtual void AddInitialEventsToListener(const lldb::ListenerSP &listener_sp,\n                                          uint32_t requested_events);\n\n  /// Listen for any events specified by \\a event_mask.\n  ///\n  /// Only one listener can listen to each event bit in a given Broadcaster.\n  /// Once a listener has acquired an event bit, no other broadcaster will\n  /// have access to it until it is relinquished by the first listener that\n  /// gets it. The actual event bits that get acquired by \\a listener may be\n  /// different from what is requested in \\a event_mask, and to track this the\n  /// actual event bits that are acquired get returned.\n  ///\n  /// \\param[in] listener_sp\n  ///     The Listener object that wants to monitor the events that\n  ///     get broadcast by this object.\n  ///\n  /// \\param[in] event_mask\n  ///     A bit mask that indicates which events the listener is\n  ///     asking to monitor.\n  ///\n  /// \\return\n  ///     The actual event bits that were acquired by \\a listener.\n  uint32_t AddListener(const lldb::ListenerSP &listener_sp,\n                       uint32_t event_mask) {\n    return m_broadcaster_sp->AddListener(listener_sp, event_mask);\n  }\n\n  /// Get the NULL terminated C string name of this Broadcaster object.\n  ///\n  /// \\return\n  ///     The NULL terminated C string name of this Broadcaster.\n  ConstString GetBroadcasterName() { return m_broadcaster_name; }\n\n  /// Get the event name(s) for one or more event bits.\n  ///\n  /// \\param[in] event_mask\n  ///     A bit mask that indicates which events to get names for.\n  ///\n  /// \\return\n  ///     The NULL terminated C string name of this Broadcaster.\n  bool GetEventNames(Stream &s, const uint32_t event_mask,\n                     bool prefix_with_broadcaster_name) const {\n    return m_broadcaster_sp->GetEventNames(s, event_mask,\n                                           prefix_with_broadcaster_name);\n  }\n\n  /// Set the name for an event bit.\n  ///\n  /// \\param[in] event_mask\n  ///     A bit mask that indicates which events the listener is\n  ///     asking to monitor.\n  void SetEventName(uint32_t event_mask, const char *name) {\n    m_broadcaster_sp->SetEventName(event_mask, name);\n  }\n\n  const char *GetEventName(uint32_t event_mask) const {\n    return m_broadcaster_sp->GetEventName(event_mask);\n  }\n\n  bool EventTypeHasListeners(uint32_t event_type) {\n    return m_broadcaster_sp->EventTypeHasListeners(event_type);\n  }\n\n  /// Removes a Listener from this broadcasters list and frees the event bits\n  /// specified by \\a event_mask that were previously acquired by \\a listener\n  /// (assuming \\a listener was listening to this object) for other listener\n  /// objects to use.\n  ///\n  /// \\param[in] listener_sp\n  ///     A Listener object that previously called AddListener.\n  ///\n  /// \\param[in] event_mask\n  ///     The event bits \\a listener wishes to relinquish.\n  ///\n  /// \\return\n  ///     \\b True if the listener was listening to this broadcaster\n  ///     and was removed, \\b false otherwise.\n  ///\n  /// \\see uint32_t Broadcaster::AddListener (Listener*, uint32_t)\n  bool RemoveListener(const lldb::ListenerSP &listener_sp,\n                      uint32_t event_mask = UINT32_MAX) {\n    return m_broadcaster_sp->RemoveListener(listener_sp, event_mask);\n  }\n\n  /// Provides a simple mechanism to temporarily redirect events from\n  /// broadcaster.  When you call this function passing in a listener and\n  /// event type mask, all events from the broadcaster matching the mask will\n  /// now go to the hijacking listener. Only one hijack can occur at a time.\n  /// If we need more than this we will have to implement a Listener stack.\n  ///\n  /// \\param[in] listener_sp\n  ///     A Listener object.  You do not need to call StartListeningForEvents\n  ///     for this broadcaster (that would fail anyway since the event bits\n  ///     would most likely be taken by the listener(s) you are usurping.\n  ///\n  /// \\param[in] event_mask\n  ///     The event bits \\a listener wishes to hijack.\n  ///\n  /// \\return\n  ///     \\b True if the event mask could be hijacked, \\b false otherwise.\n  ///\n  /// \\see uint32_t Broadcaster::AddListener (Listener*, uint32_t)\n  bool HijackBroadcaster(const lldb::ListenerSP &listener_sp,\n                         uint32_t event_mask = UINT32_MAX) {\n    return m_broadcaster_sp->HijackBroadcaster(listener_sp, event_mask);\n  }\n\n  bool IsHijackedForEvent(uint32_t event_mask) {\n    return m_broadcaster_sp->IsHijackedForEvent(event_mask);\n  }\n\n  /// Restore the state of the Broadcaster from a previous hijack attempt.\n  void RestoreBroadcaster() { m_broadcaster_sp->RestoreBroadcaster(); }\n\n  /// This needs to be filled in if you are going to register the broadcaster\n  /// with the broadcaster manager and do broadcaster class matching.\n  /// FIXME: Probably should make a ManagedBroadcaster subclass with all the\n  /// bits needed to work with the BroadcasterManager, so that it is clearer\n  /// how to add one.\n  virtual ConstString &GetBroadcasterClass() const;\n\n  lldb::BroadcasterManagerSP GetManager();\n\nprotected:\n  /// BroadcasterImpl contains the actual Broadcaster implementation.  The\n  /// Broadcaster makes a BroadcasterImpl which lives as long as it does.  The\n  /// Listeners & the Events hold a weak pointer to the BroadcasterImpl, so\n  /// that they can survive if a Broadcaster they were listening to is\n  /// destroyed w/o their being able to unregister from it (which can happen if\n  /// the Broadcasters & Listeners are being destroyed on separate threads\n  /// simultaneously. The Broadcaster itself can't be shared out as a weak\n  /// pointer, because some things that are broadcasters (e.g. the Target and\n  /// the Process) are shared in their own right.\n  ///\n  /// For the most part, the Broadcaster functions dispatch to the\n  /// BroadcasterImpl, and are documented in the public Broadcaster API above.\n  class BroadcasterImpl {\n    friend class Listener;\n    friend class Broadcaster;\n\n  public:\n    BroadcasterImpl(Broadcaster &broadcaster);\n\n    ~BroadcasterImpl() = default;\n\n    void BroadcastEvent(lldb::EventSP &event_sp);\n\n    void BroadcastEventIfUnique(lldb::EventSP &event_sp);\n\n    void BroadcastEvent(uint32_t event_type, EventData *event_data = nullptr);\n\n    void BroadcastEvent(uint32_t event_type,\n                        const lldb::EventDataSP &event_data_sp);\n\n    void BroadcastEventIfUnique(uint32_t event_type,\n                                EventData *event_data = nullptr);\n\n    void Clear();\n\n    uint32_t AddListener(const lldb::ListenerSP &listener_sp,\n                         uint32_t event_mask);\n\n    const char *GetBroadcasterName() const {\n      return m_broadcaster.GetBroadcasterName().AsCString();\n    }\n\n    Broadcaster *GetBroadcaster();\n\n    bool GetEventNames(Stream &s, const uint32_t event_mask,\n                       bool prefix_with_broadcaster_name) const;\n\n    void SetEventName(uint32_t event_mask, const char *name) {\n      m_event_names[event_mask] = name;\n    }\n\n    const char *GetEventName(uint32_t event_mask) const {\n      const auto pos = m_event_names.find(event_mask);\n      if (pos != m_event_names.end())\n        return pos->second.c_str();\n      return nullptr;\n    }\n\n    bool EventTypeHasListeners(uint32_t event_type);\n\n    bool RemoveListener(lldb_private::Listener *listener,\n                        uint32_t event_mask = UINT32_MAX);\n\n    bool RemoveListener(const lldb::ListenerSP &listener_sp,\n                        uint32_t event_mask = UINT32_MAX);\n\n    bool HijackBroadcaster(const lldb::ListenerSP &listener_sp,\n                           uint32_t event_mask = UINT32_MAX);\n\n    bool IsHijackedForEvent(uint32_t event_mask);\n\n    void RestoreBroadcaster();\n\n  protected:\n    void PrivateBroadcastEvent(lldb::EventSP &event_sp, bool unique);\n\n    const char *GetHijackingListenerName();\n\n    typedef llvm::SmallVector<std::pair<lldb::ListenerWP, uint32_t>, 4>\n        collection;\n    typedef std::map<uint32_t, std::string> event_names_map;\n\n    llvm::SmallVector<std::pair<lldb::ListenerSP, uint32_t &>, 4>\n    GetListeners();\n\n    /// The broadcaster that this implements.\n    Broadcaster &m_broadcaster;\n\n    /// Optionally define event names for readability and logging for each\n    /// event bit.\n    event_names_map m_event_names;\n\n    /// A list of Listener / event_mask pairs that are listening to this\n    /// broadcaster.\n    collection m_listeners;\n\n    /// A mutex that protects \\a m_listeners.\n    std::recursive_mutex m_listeners_mutex;\n\n    /// A simple mechanism to intercept events from a broadcaster\n    std::vector<lldb::ListenerSP> m_hijacking_listeners;\n\n    /// At some point we may want to have a stack or Listener collections, but\n    /// for now this is just for private hijacking.\n    std::vector<uint32_t> m_hijacking_masks;\n\n  private:\n    BroadcasterImpl(const BroadcasterImpl &) = delete;\n    const BroadcasterImpl &operator=(const BroadcasterImpl &) = delete;\n  };\n\n  typedef std::shared_ptr<BroadcasterImpl> BroadcasterImplSP;\n  typedef std::weak_ptr<BroadcasterImpl> BroadcasterImplWP;\n\n  BroadcasterImplSP GetBroadcasterImpl() { return m_broadcaster_sp; }\n\n  const char *GetHijackingListenerName() {\n    return m_broadcaster_sp->GetHijackingListenerName();\n  }\n\nprivate:\n  BroadcasterImplSP m_broadcaster_sp;\n  lldb::BroadcasterManagerSP m_manager_sp;\n\n  /// The name of this broadcaster object.\n  const ConstString m_broadcaster_name;\n\n  Broadcaster(const Broadcaster &) = delete;\n  const Broadcaster &operator=(const Broadcaster &) = delete;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_UTILITY_BROADCASTER_H\n"}, "17": {"id": 17, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/ConstString.h", "content": "//===-- ConstString.h -------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_CONSTSTRING_H\n#define LLDB_UTILITY_CONSTSTRING_H\n\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/FormatVariadic.h\"\n#include \"llvm/Support/YAMLTraits.h\"\n\n#include <stddef.h>\n\nnamespace lldb_private {\nclass Stream;\n}\nnamespace llvm {\nclass raw_ostream;\n}\n\nnamespace lldb_private {\n\n/// \\class ConstString ConstString.h \"lldb/Utility/ConstString.h\"\n/// A uniqued constant string class.\n///\n/// Provides an efficient way to store strings as uniqued strings. After the\n/// strings are uniqued, finding strings that are equal to one another is very\n/// fast as just the pointers need to be compared. It also allows for many\n/// common strings from many different sources to be shared to keep the memory\n/// footprint low.\n///\n/// No reference counting is done on strings that are added to the string\n/// pool, once strings are added they are in the string pool for the life of\n/// the program.\nclass ConstString {\npublic:\n  /// Default constructor\n  ///\n  /// Initializes the string to an empty string.\n  ConstString() = default;\n\n  explicit ConstString(const llvm::StringRef &s);\n\n  /// Construct with C String value\n  ///\n  /// Constructs this object with a C string by looking to see if the\n  /// C string already exists in the global string pool. If it doesn't\n  /// exist, it is added to the string pool.\n  ///\n  /// \\param[in] cstr\n  ///     A NULL terminated C string to add to the string pool.\n  explicit ConstString(const char *cstr);\n\n  /// Construct with C String value with max length\n  ///\n  /// Constructs this object with a C string with a length. If \\a max_cstr_len\n  /// is greater than the actual length of the string, the string length will\n  /// be truncated. This allows substrings to be created without the need to\n  /// NULL terminate the string as it is passed into this function.\n  ///\n  /// \\param[in] cstr\n  ///     A pointer to the first character in the C string. The C\n  ///     string can be NULL terminated in a buffer that contains\n  ///     more characters than the length of the string, or the\n  ///     string can be part of another string and a new substring\n  ///     can be created.\n  ///\n  /// \\param[in] max_cstr_len\n  ///     The max length of \\a cstr. If the string length of \\a cstr\n  ///     is less than \\a max_cstr_len, then the string will be\n  ///     truncated. If the string length of \\a cstr is greater than\n  ///     \\a max_cstr_len, then only max_cstr_len bytes will be used\n  ///     from \\a cstr.\n  explicit ConstString(const char *cstr, size_t max_cstr_len);\n\n  /// C string equality binary predicate function object for ConstString\n  /// objects.\n  struct StringIsEqual {\n    /// C equality test.\n    ///\n    /// Two C strings are equal when they are contained in ConstString objects\n    /// when their pointer values are equal to each other.\n    ///\n    /// \\return\n    ///     Returns \\b true if the C string in \\a lhs is equal to\n    ///     the C string value in \\a rhs, \\b false otherwise.\n    bool operator()(const char *lhs, const char *rhs) const {\n      return lhs == rhs;\n    }\n  };\n\n  /// Convert to bool operator.\n  ///\n  /// This allows code to check a ConstString object to see if it contains a\n  /// valid string using code such as:\n  ///\n  /// \\code\n  /// ConstString str(...);\n  /// if (str)\n  /// { ...\n  /// \\endcode\n  ///\n  /// \\return\n  ///     /b True this object contains a valid non-empty C string, \\b\n  ///     false otherwise.\n  explicit operator bool() const { return !IsEmpty(); }\n\n  /// Equal to operator\n  ///\n  /// Returns true if this string is equal to the string in \\a rhs. This\n  /// operation is very fast as it results in a pointer comparison since all\n  /// strings are in a uniqued in a global string pool.\n  ///\n  /// \\param[in] rhs\n  ///     Another string object to compare this object to.\n  ///\n  /// \\return\n  ///     true if this object is equal to \\a rhs.\n  ///     false if this object is not equal to \\a rhs.\n  bool operator==(ConstString rhs) const {\n    // We can do a pointer compare to compare these strings since they must\n    // come from the same pool in order to be equal.\n    return m_string == rhs.m_string;\n  }\n\n  /// Equal to operator against a non-ConstString value.\n  ///\n  /// Returns true if this string is equal to the string in \\a rhs. This\n  /// overload is usually slower than comparing against a ConstString value.\n  /// However, if the rhs string not already a ConstString and it is impractical\n  /// to turn it into a non-temporary variable, then this overload is faster.\n  ///\n  /// \\param[in] rhs\n  ///     Another string object to compare this object to.\n  ///\n  /// \\return\n  ///     \\b true if this object is equal to \\a rhs.\n  ///     \\b false if this object is not equal to \\a rhs.\n  bool operator==(const char *rhs) const {\n    // ConstString differentiates between empty strings and nullptr strings, but\n    // StringRef doesn't. Therefore we have to do this check manually now.\n    if (m_string == nullptr && rhs != nullptr)\n      return false;\n    if (m_string != nullptr && rhs == nullptr)\n      return false;\n\n    return GetStringRef() == rhs;\n  }\n\n  /// Not equal to operator\n  ///\n  /// Returns true if this string is not equal to the string in \\a rhs. This\n  /// operation is very fast as it results in a pointer comparison since all\n  /// strings are in a uniqued in a global string pool.\n  ///\n  /// \\param[in] rhs\n  ///     Another string object to compare this object to.\n  ///\n  /// \\return\n  ///     \\b true if this object is not equal to \\a rhs.\n  ///     \\b false if this object is equal to \\a rhs.\n  bool operator!=(ConstString rhs) const { return m_string != rhs.m_string; }\n\n  /// Not equal to operator against a non-ConstString value.\n  ///\n  /// Returns true if this string is not equal to the string in \\a rhs. This\n  /// overload is usually slower than comparing against a ConstString value.\n  /// However, if the rhs string not already a ConstString and it is impractical\n  /// to turn it into a non-temporary variable, then this overload is faster.\n  ///\n  /// \\param[in] rhs\n  ///     Another string object to compare this object to.\n  ///\n  /// \\return \\b true if this object is not equal to \\a rhs, false otherwise.\n  bool operator!=(const char *rhs) const { return !(*this == rhs); }\n\n  bool operator<(ConstString rhs) const;\n\n  /// Get the string value as a C string.\n  ///\n  /// Get the value of the contained string as a NULL terminated C string\n  /// value.\n  ///\n  /// If \\a value_if_empty is nullptr, then nullptr will be returned.\n  ///\n  /// \\return Returns \\a value_if_empty if the string is empty, otherwise\n  ///     the C string value contained in this object.\n  const char *AsCString(const char *value_if_empty = nullptr) const {\n    return (IsEmpty() ? value_if_empty : m_string);\n  }\n\n  /// Get the string value as a llvm::StringRef\n  ///\n  /// \\return\n  ///     Returns a new llvm::StringRef object filled in with the\n  ///     needed data.\n  llvm::StringRef GetStringRef() const {\n    return llvm::StringRef(m_string, GetLength());\n  }\n\n  /// Get the string value as a C string.\n  ///\n  /// Get the value of the contained string as a NULL terminated C string\n  /// value. Similar to the ConstString::AsCString() function, yet this\n  /// function will always return nullptr if the string is not valid. So this\n  /// function is a direct accessor to the string pointer value.\n  ///\n  /// \\return\n  ///     Returns nullptr the string is invalid, otherwise the C string\n  ///     value contained in this object.\n  const char *GetCString() const { return m_string; }\n\n  /// Get the length in bytes of string value.\n  ///\n  /// The string pool stores the length of the string, so we can avoid calling\n  /// strlen() on the pointer value with this function.\n  ///\n  /// \\return\n  ///     Returns the number of bytes that this string occupies in\n  ///     memory, not including the NULL termination byte.\n  size_t GetLength() const;\n\n  /// Clear this object's state.\n  ///\n  /// Clear any contained string and reset the value to the empty string\n  /// value.\n  void Clear() { m_string = nullptr; }\n\n  /// Equal to operator\n  ///\n  /// Returns true if this string is equal to the string in \\a rhs. If case\n  /// sensitive equality is tested, this operation is very fast as it results\n  /// in a pointer comparison since all strings are in a uniqued in a global\n  /// string pool.\n  ///\n  /// \\param[in] lhs\n  ///     The Left Hand Side const ConstString object reference.\n  ///\n  /// \\param[in] rhs\n  ///     The Right Hand Side const ConstString object reference.\n  ///\n  /// \\param[in] case_sensitive\n  ///     Case sensitivity. If true, case sensitive equality\n  ///     will be tested, otherwise character case will be ignored\n  ///\n  /// \\return \\b true if this object is equal to \\a rhs, \\b false otherwise.\n  static bool Equals(ConstString lhs, ConstString rhs,\n                     const bool case_sensitive = true);\n\n  /// Compare two string objects.\n  ///\n  /// Compares the C string values contained in \\a lhs and \\a rhs and returns\n  /// an integer result.\n  ///\n  /// NOTE: only call this function when you want a true string\n  /// comparison. If you want string equality use the, use the == operator as\n  /// it is much more efficient. Also if you want string inequality, use the\n  /// != operator for the same reasons.\n  ///\n  /// \\param[in] lhs\n  ///     The Left Hand Side const ConstString object reference.\n  ///\n  /// \\param[in] rhs\n  ///     The Right Hand Side const ConstString object reference.\n  ///\n  /// \\param[in] case_sensitive\n  ///     Case sensitivity of compare. If true, case sensitive compare\n  ///     will be performed, otherwise character case will be ignored\n  ///\n  /// \\return -1 if lhs < rhs, 0 if lhs == rhs, 1 if lhs > rhs\n  static int Compare(ConstString lhs, ConstString rhs,\n                     const bool case_sensitive = true);\n\n  /// Dump the object description to a stream.\n  ///\n  /// Dump the string value to the stream \\a s. If the contained string is\n  /// empty, print \\a value_if_empty to the stream instead. If \\a\n  /// value_if_empty is nullptr, then nothing will be dumped to the stream.\n  ///\n  /// \\param[in] s\n  ///     The stream that will be used to dump the object description.\n  ///\n  /// \\param[in] value_if_empty\n  ///     The value to dump if the string is empty. If nullptr, nothing\n  ///     will be output to the stream.\n  void Dump(Stream *s, const char *value_if_empty = nullptr) const;\n\n  /// Dump the object debug description to a stream.\n  ///\n  /// \\param[in] s\n  ///     The stream that will be used to dump the object description.\n  void DumpDebug(Stream *s) const;\n\n  /// Test for empty string.\n  ///\n  /// \\return\n  ///     \\b true if the contained string is empty.\n  ///     \\b false if the contained string is not empty.\n  bool IsEmpty() const { return m_string == nullptr || m_string[0] == '\\0'; }\n\n  /// Test for null string.\n  ///\n  /// \\return\n  ///     \\b true if there is no string associated with this instance.\n  ///     \\b false if there is a string associated with this instance.\n  bool IsNull() const { return m_string == nullptr; }\n\n  /// Set the C string value.\n  ///\n  /// Set the string value in the object by uniquing the \\a cstr string value\n  /// in our global string pool.\n  ///\n  /// If the C string already exists in the global string pool, it finds the\n  /// current entry and returns the existing value. If it doesn't exist, it is\n  /// added to the string pool.\n  ///\n  /// \\param[in] cstr\n  ///     A NULL terminated C string to add to the string pool.\n  void SetCString(const char *cstr);\n\n  void SetString(const llvm::StringRef &s);\n\n  /// Set the C string value and its mangled counterpart.\n  ///\n  /// Object files and debug symbols often use mangled string to represent the\n  /// linkage name for a symbol, function or global. The string pool can\n  /// efficiently store these values and their counterparts so when we run\n  /// into another instance of a mangled name, we can avoid calling the name\n  /// demangler over and over on the same strings and then trying to unique\n  /// them.\n  ///\n  /// \\param[in] demangled\n  ///     The demangled string to correlate with the \\a mangled name.\n  ///\n  /// \\param[in] mangled\n  ///     The already uniqued mangled ConstString to correlate the\n  ///     soon to be uniqued version of \\a demangled.\n  void SetStringWithMangledCounterpart(llvm::StringRef demangled,\n                                       ConstString mangled);\n\n  /// Retrieve the mangled or demangled counterpart for a mangled or demangled\n  /// ConstString.\n  ///\n  /// Object files and debug symbols often use mangled string to represent the\n  /// linkage name for a symbol, function or global. The string pool can\n  /// efficiently store these values and their counterparts so when we run\n  /// into another instance of a mangled name, we can avoid calling the name\n  /// demangler over and over on the same strings and then trying to unique\n  /// them.\n  ///\n  /// \\param[in] counterpart\n  ///     A reference to a ConstString object that might get filled in\n  ///     with the demangled/mangled counterpart.\n  ///\n  /// \\return\n  ///     /b True if \\a counterpart was filled in with the counterpart\n  ///     /b false otherwise.\n  bool GetMangledCounterpart(ConstString &counterpart) const;\n\n  /// Set the C string value with length.\n  ///\n  /// Set the string value in the object by uniquing \\a cstr_len bytes\n  /// starting at the \\a cstr string value in our global string pool. If trim\n  /// is true, then \\a cstr_len indicates a maximum length of the CString and\n  /// if the actual length of the string is less, then it will be trimmed.\n  ///\n  /// If the C string already exists in the global string pool, it finds the\n  /// current entry and returns the existing value. If it doesn't exist, it is\n  /// added to the string pool.\n  ///\n  /// \\param[in] cstr\n  ///     A NULL terminated C string to add to the string pool.\n  ///\n  /// \\param[in] cstr_len\n  ///     The maximum length of the C string.\n  void SetCStringWithLength(const char *cstr, size_t cstr_len);\n\n  /// Set the C string value with the minimum length between \\a fixed_cstr_len\n  /// and the actual length of the C string. This can be used for data\n  /// structures that have a fixed length to store a C string where the string\n  /// might not be NULL terminated if the string takes the entire buffer.\n  void SetTrimmedCStringWithLength(const char *cstr, size_t fixed_cstr_len);\n\n  /// Get the memory cost of this object.\n  ///\n  /// Return the size in bytes that this object takes in memory. This returns\n  /// the size in bytes of this object, which does not include any the shared\n  /// string values it may refer to.\n  ///\n  /// \\return\n  ///     The number of bytes that this object occupies in memory.\n  ///\n  /// \\see ConstString::StaticMemorySize ()\n  size_t MemorySize() const { return sizeof(ConstString); }\n\n  /// Get the size in bytes of the current global string pool.\n  ///\n  /// Reports the size in bytes of all shared C string values, containers and\n  /// any other values as a byte size for the entire string pool.\n  ///\n  /// \\return\n  ///     The number of bytes that the global string pool occupies\n  ///     in memory.\n  static size_t StaticMemorySize();\n\nprotected:\n  template <typename T> friend struct ::llvm::DenseMapInfo;\n  /// Only used by DenseMapInfo.\n  static ConstString FromStringPoolPointer(const char *ptr) {\n    ConstString s;\n    s.m_string = ptr;\n    return s;\n  };\n\n  const char *m_string = nullptr;\n};\n\n/// Stream the string value \\a str to the stream \\a s\nStream &operator<<(Stream &s, ConstString str);\n\n} // namespace lldb_private\n\nnamespace llvm {\ntemplate <> struct format_provider<lldb_private::ConstString> {\n  static void format(const lldb_private::ConstString &CS, llvm::raw_ostream &OS,\n                     llvm::StringRef Options);\n};\n\n/// DenseMapInfo implementation.\n/// \\{\ntemplate <> struct DenseMapInfo<lldb_private::ConstString> {\n  static inline lldb_private::ConstString getEmptyKey() {\n    return lldb_private::ConstString::FromStringPoolPointer(\n        DenseMapInfo<const char *>::getEmptyKey());\n  }\n  static inline lldb_private::ConstString getTombstoneKey() {\n    return lldb_private::ConstString::FromStringPoolPointer(\n        DenseMapInfo<const char *>::getTombstoneKey());\n  }\n  static unsigned getHashValue(lldb_private::ConstString val) {\n    return DenseMapInfo<const char *>::getHashValue(val.m_string);\n  }\n  static bool isEqual(lldb_private::ConstString LHS,\n                      lldb_private::ConstString RHS) {\n    return LHS == RHS;\n  }\n};\n/// \\}\n\nnamespace yaml {\ntemplate <> struct ScalarTraits<lldb_private::ConstString> {\n  static void output(const lldb_private::ConstString &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, lldb_private::ConstString &);\n  static QuotingType mustQuote(StringRef S) { return QuotingType::Double; }\n};\n} // namespace yaml\n\ninline raw_ostream &operator<<(raw_ostream &os, lldb_private::ConstString s) {\n  os << s.GetStringRef();\n  return os;\n}\n} // namespace llvm\n\nLLVM_YAML_IS_SEQUENCE_VECTOR(lldb_private::ConstString)\n\n#endif // LLDB_UTILITY_CONSTSTRING_H\n"}, "18": {"id": 18, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/FileSpec.h", "content": "//===-- FileSpec.h ----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_FILESPEC_H\n#define LLDB_UTILITY_FILESPEC_H\n\n#include <functional>\n#include <string>\n\n#include \"lldb/Utility/ConstString.h\"\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/FileSystem.h\"\n#include \"llvm/Support/FormatVariadic.h\"\n#include \"llvm/Support/Path.h\"\n#include \"llvm/Support/YAMLTraits.h\"\n\n#include <stddef.h>\n#include <stdint.h>\n\nnamespace lldb_private {\nclass Stream;\n}\nnamespace llvm {\nclass Triple;\n}\nnamespace llvm {\nclass raw_ostream;\n}\nnamespace llvm {\ntemplate <typename T> class SmallVectorImpl;\n}\n\nnamespace lldb_private {\n\n/// \\class FileSpec FileSpec.h \"lldb/Host/FileSpec.h\"\n/// A file utility class.\n///\n/// A file specification class that divides paths up into a directory\n/// and basename. These string values of the paths are put into uniqued string\n/// pools for fast comparisons and efficient memory usage.\n///\n/// Another reason the paths are split into the directory and basename is to\n/// allow efficient debugger searching. Often in a debugger the user types in\n/// the basename of the file, for example setting a breakpoint by file and\n/// line, or specifying a module (shared library) to limit the scope in which\n/// to execute a command. The user rarely types in a full path. When the paths\n/// are already split up, it makes it easy for us to compare only the\n/// basenames of a lot of file specifications without having to split up the\n/// file path each time to get to the basename.\nclass FileSpec {\npublic:\n  using Style = llvm::sys::path::Style;\n\n  FileSpec();\n\n  /// Constructor with path.\n  ///\n  /// Takes a path to a file which can be just a filename, or a full path. If\n  /// \\a path is not nullptr or empty, this function will call\n  /// FileSpec::SetFile (const char *path).\n  ///\n  /// \\param[in] path\n  ///     The full or partial path to a file.\n  ///\n  /// \\param[in] style\n  ///     The style of the path\n  ///\n  /// \\see FileSpec::SetFile (const char *path)\n  explicit FileSpec(llvm::StringRef path, Style style = Style::native);\n\n  explicit FileSpec(llvm::StringRef path, const llvm::Triple &triple);\n\n  bool DirectoryEquals(const FileSpec &other) const;\n\n  bool FileEquals(const FileSpec &other) const;\n\n  /// Equal to operator\n  ///\n  /// Tests if this object is equal to \\a rhs.\n  ///\n  /// \\param[in] rhs\n  ///     A const FileSpec object reference to compare this object\n  ///     to.\n  ///\n  /// \\return\n  ///     \\b true if this object is equal to \\a rhs, \\b false\n  ///     otherwise.\n  bool operator==(const FileSpec &rhs) const;\n\n  /// Not equal to operator\n  ///\n  /// Tests if this object is not equal to \\a rhs.\n  ///\n  /// \\param[in] rhs\n  ///     A const FileSpec object reference to compare this object\n  ///     to.\n  ///\n  /// \\return\n  ///     \\b true if this object is equal to \\a rhs, \\b false\n  ///     otherwise.\n  bool operator!=(const FileSpec &rhs) const;\n\n  /// Less than to operator\n  ///\n  /// Tests if this object is less than \\a rhs.\n  ///\n  /// \\param[in] rhs\n  ///     A const FileSpec object reference to compare this object\n  ///     to.\n  ///\n  /// \\return\n  ///     \\b true if this object is less than \\a rhs, \\b false\n  ///     otherwise.\n  bool operator<(const FileSpec &rhs) const;\n\n  /// Convert to pointer operator.\n  ///\n  /// This allows code to check a FileSpec object to see if it contains\n  /// anything valid using code such as:\n  ///\n  /// \\code\n  /// FileSpec file_spec(...);\n  /// if (file_spec)\n  /// { ...\n  /// \\endcode\n  ///\n  /// \\return\n  ///     A pointer to this object if either the directory or filename\n  ///     is valid, nullptr otherwise.\n  explicit operator bool() const;\n\n  /// Logical NOT operator.\n  ///\n  /// This allows code to check a FileSpec object to see if it is invalid\n  /// using code such as:\n  ///\n  /// \\code\n  /// FileSpec file_spec(...);\n  /// if (!file_spec)\n  /// { ...\n  /// \\endcode\n  ///\n  /// \\return\n  ///     Returns \\b true if the object has an empty directory and\n  ///     filename, \\b false otherwise.\n  bool operator!() const;\n\n  /// Clears the object state.\n  ///\n  /// Clear this object by releasing both the directory and filename string\n  /// values and reverting them to empty strings.\n  void Clear();\n\n  /// Compare two FileSpec objects.\n  ///\n  /// If \\a full is true, then both the directory and the filename must match.\n  /// If \\a full is false, then the directory names for \\a lhs and \\a rhs are\n  /// only compared if they are both not empty. This allows a FileSpec object\n  /// to only contain a filename and it can match FileSpec objects that have\n  /// matching filenames with different paths.\n  ///\n  /// \\param[in] lhs\n  ///     A const reference to the Left Hand Side object to compare.\n  ///\n  /// \\param[in] rhs\n  ///     A const reference to the Right Hand Side object to compare.\n  ///\n  /// \\param[in] full\n  ///     If true, then both the directory and filenames will have to\n  ///     match for a compare to return zero (equal to). If false\n  ///     and either directory from \\a lhs or \\a rhs is empty, then\n  ///     only the filename will be compared, else a full comparison\n  ///     is done.\n  ///\n  /// \\return -1 if \\a lhs is less than \\a rhs, 0 if \\a lhs is equal to \\a rhs,\n  ///     1 if \\a lhs is greater than \\a rhs\n  static int Compare(const FileSpec &lhs, const FileSpec &rhs, bool full);\n\n  static bool Equal(const FileSpec &a, const FileSpec &b, bool full);\n\n  /// Match FileSpec \\a pattern against FileSpec \\a file. If \\a pattern has a\n  /// directory component, then the \\a file must have the same directory\n  /// component. Otherwise, just it matches just the filename. An empty \\a\n  /// pattern matches everything.\n  static bool Match(const FileSpec &pattern, const FileSpec &file);\n\n  /// Attempt to guess path style for a given path string. It returns a style,\n  /// if it was able to make a reasonable guess, or None if it wasn't. The guess\n  /// will be correct if the input path was a valid absolute path on the system\n  /// which produced it. On other paths the result of this function is\n  /// unreliable (e.g. \"c:\\foo.txt\" is a valid relative posix path).\n  static llvm::Optional<Style> GuessPathStyle(llvm::StringRef absolute_path);\n\n  /// Case sensitivity of path.\n  ///\n  /// \\return\n  ///     \\b true if the file path is case sensitive (POSIX), false\n  ///\t\tif case insensitive (Windows).\n  bool IsCaseSensitive() const { return m_style != Style::windows; }\n\n  /// Dump this object to a Stream.\n  ///\n  /// Dump the object to the supplied stream \\a s. If the object contains a\n  /// valid directory name, it will be displayed followed by a directory\n  /// delimiter, and the filename.\n  ///\n  /// \\param[in] s\n  ///     The stream to which to dump the object description.\n  void Dump(llvm::raw_ostream &s) const;\n\n  Style GetPathStyle() const;\n\n  /// Directory string get accessor.\n  ///\n  /// \\return\n  ///     A reference to the directory string object.\n  ConstString &GetDirectory();\n\n  /// Directory string const get accessor.\n  ///\n  /// \\return\n  ///     A const reference to the directory string object.\n  ConstString GetDirectory() const;\n\n  /// Filename string get accessor.\n  ///\n  /// \\return\n  ///     A reference to the filename string object.\n  ConstString &GetFilename();\n\n  /// Filename string const get accessor.\n  ///\n  /// \\return\n  ///     A const reference to the filename string object.\n  ConstString GetFilename() const;\n\n  /// Returns true if the filespec represents an implementation source file\n  /// (files with a \".c\", \".cpp\", \".m\", \".mm\" (many more) extension).\n  ///\n  /// \\return\n  ///     \\b true if the filespec represents an implementation source\n  ///     file, \\b false otherwise.\n  bool IsSourceImplementationFile() const;\n\n  /// Returns true if the filespec represents a relative path.\n  ///\n  /// \\return\n  ///     \\b true if the filespec represents a relative path,\n  ///     \\b false otherwise.\n  bool IsRelative() const;\n\n  /// Returns true if the filespec represents an absolute path.\n  ///\n  /// \\return\n  ///     \\b true if the filespec represents an absolute path,\n  ///     \\b false otherwise.\n  bool IsAbsolute() const;\n\n  /// Make the FileSpec absolute by treating it relative to \\a dir. Absolute\n  /// FileSpecs are never changed by this function.\n  void MakeAbsolute(const FileSpec &dir);\n\n  /// Temporary helper for FileSystem change.\n  void SetPath(llvm::StringRef p) { SetFile(p); }\n\n  /// Extract the full path to the file.\n  ///\n  /// Extract the directory and path into a fixed buffer. This is needed as\n  /// the directory and path are stored in separate string values.\n  ///\n  /// \\param[out] path\n  ///     The buffer in which to place the extracted full path.\n  ///\n  /// \\param[in] max_path_length\n  ///     The maximum length of \\a path.\n  ///\n  /// \\return\n  ///     Returns the number of characters that would be needed to\n  ///     properly copy the full path into \\a path. If the returned\n  ///     number is less than \\a max_path_length, then the path is\n  ///     properly copied and terminated. If the return value is\n  ///     >= \\a max_path_length, then the path was truncated (but is\n  ///     still NULL terminated).\n  size_t GetPath(char *path, size_t max_path_length,\n                 bool denormalize = true) const;\n\n  /// Extract the full path to the file.\n  ///\n  /// Extract the directory and path into a std::string, which is returned.\n  ///\n  /// \\return\n  ///     Returns a std::string with the directory and filename\n  ///     concatenated.\n  std::string GetPath(bool denormalize = true) const;\n\n  const char *GetCString(bool denormalize = true) const;\n\n  /// Extract the full path to the file.\n  ///\n  /// Extract the directory and path into an llvm::SmallVectorImpl<>\n  void GetPath(llvm::SmallVectorImpl<char> &path,\n               bool denormalize = true) const;\n\n  /// Extract the extension of the file.\n  ///\n  /// Returns a ConstString that represents the extension of the filename for\n  /// this FileSpec object. If this object does not represent a file, or the\n  /// filename has no extension, ConstString(nullptr) is returned. The dot\n  /// ('.') character is not returned as part of the extension\n  ///\n  /// \\return Returns the extension of the file as a ConstString object.\n  ConstString GetFileNameExtension() const;\n\n  /// Return the filename without the extension part\n  ///\n  /// Returns a ConstString that represents the filename of this object\n  /// without the extension part (e.g. for a file named \"foo.bar\", \"foo\" is\n  /// returned)\n  ///\n  /// \\return Returns the filename without extension as a ConstString object.\n  ConstString GetFileNameStrippingExtension() const;\n\n  /// Get the memory cost of this object.\n  ///\n  /// Return the size in bytes that this object takes in memory. This returns\n  /// the size in bytes of this object, not any shared string values it may\n  /// refer to.\n  ///\n  /// \\return\n  ///     The number of bytes that this object occupies in memory.\n  ///\n  /// \\see ConstString::StaticMemorySize ()\n  size_t MemorySize() const;\n\n  /// Change the file specified with a new path.\n  ///\n  /// Update the contents of this object with a new path. The path will be\n  /// split up into a directory and filename and stored as uniqued string\n  /// values for quick comparison and efficient memory usage.\n  ///\n  /// \\param[in] path\n  ///     A full, partial, or relative path to a file.\n  ///\n  /// \\param[in] style\n  ///     The style for the given path.\n  void SetFile(llvm::StringRef path, Style style);\n\n  /// Change the file specified with a new path.\n  ///\n  /// Update the contents of this object with a new path. The path will be\n  /// split up into a directory and filename and stored as uniqued string\n  /// values for quick comparison and efficient memory usage.\n  ///\n  /// \\param[in] path\n  ///     A full, partial, or relative path to a file.\n  ///\n  /// \\param[in] triple\n  ///     The triple which is used to set the Path style.\n  void SetFile(llvm::StringRef path, const llvm::Triple &triple);\n\n  bool IsResolved() const { return m_is_resolved; }\n\n  /// Set if the file path has been resolved or not.\n  ///\n  /// If you know a file path is already resolved and avoided passing a \\b\n  /// true parameter for any functions that take a \"bool resolve_path\"\n  /// parameter, you can set the value manually using this call to make sure\n  /// we don't try and resolve it later, or try and resolve a path that has\n  /// already been resolved.\n  ///\n  /// \\param[in] is_resolved\n  ///     A boolean value that will replace the current value that\n  ///     indicates if the paths in this object have been resolved.\n  void SetIsResolved(bool is_resolved) { m_is_resolved = is_resolved; }\n\n  FileSpec CopyByAppendingPathComponent(llvm::StringRef component) const;\n  FileSpec CopyByRemovingLastPathComponent() const;\n\n  void PrependPathComponent(llvm::StringRef component);\n  void PrependPathComponent(const FileSpec &new_path);\n\n  void AppendPathComponent(llvm::StringRef component);\n  void AppendPathComponent(const FileSpec &new_path);\n\n  /// Removes the last path component by replacing the current path with its\n  /// parent. When the current path has no parent, this is a no-op.\n  ///\n  /// \\return\n  ///     A boolean value indicating whether the path was updated.\n  bool RemoveLastPathComponent();\n\n  ConstString GetLastPathComponent() const;\n\nprotected:\n  friend struct llvm::yaml::MappingTraits<FileSpec>;\n\n  // Convenience method for setting the file without changing the style.\n  void SetFile(llvm::StringRef path);\n\n  // Member variables\n  ConstString m_directory;            ///< The uniqued directory path\n  ConstString m_filename;             ///< The uniqued filename path\n  mutable bool m_is_resolved = false; ///< True if this path has been resolved.\n  Style m_style; ///< The syntax that this path uses (e.g. Windows / Posix)\n};\n\n/// Dump a FileSpec object to a stream\nStream &operator<<(Stream &s, const FileSpec &f);\n\n/// Prevent ODR violations with traits for llvm::sys::path::Style.\nLLVM_YAML_STRONG_TYPEDEF(FileSpec::Style, FileSpecStyle)\n} // namespace lldb_private\n\nnamespace llvm {\n\n/// Implementation of format_provider<T> for FileSpec.\n///\n/// The options string of a FileSpec has the grammar:\n///\n///   file_spec_options   :: (empty) | F | D\n///\n///   =======================================================\n///   |  style  |     Meaning          |      Example       |\n///   -------------------------------------------------------\n///   |         |                      |  Input   |  Output |\n///   =======================================================\n///   |    F    | Only print filename  | /foo/bar |   bar   |\n///   |    D    | Only print directory | /foo/bar |  /foo/  |\n///   | (empty) | Print file and dir   |          |         |\n///   =======================================================\n///\n/// Any other value is considered an invalid format string.\n///\ntemplate <> struct format_provider<lldb_private::FileSpec> {\n  static void format(const lldb_private::FileSpec &F, llvm::raw_ostream &Stream,\n                     StringRef Style);\n};\n\nnamespace yaml {\ntemplate <> struct ScalarEnumerationTraits<lldb_private::FileSpecStyle> {\n  static void enumeration(IO &io, lldb_private::FileSpecStyle &style);\n};\n\ntemplate <> struct MappingTraits<lldb_private::FileSpec> {\n  static void mapping(IO &io, lldb_private::FileSpec &f);\n};\n} // namespace yaml\n} // namespace llvm\n\n#endif // LLDB_UTILITY_FILESPEC_H\n"}, "19": {"id": 19, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLTraits.h", "content": "//===- llvm/Support/YAMLTraits.h --------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_YAMLTRAITS_H\n#define LLVM_SUPPORT_YAMLTRAITS_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/Regex.h\"\n#include \"llvm/Support/SMLoc.h\"\n#include \"llvm/Support/SourceMgr.h\"\n#include \"llvm/Support/VersionTuple.h\"\n#include \"llvm/Support/YAMLParser.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cassert>\n#include <cctype>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <map>\n#include <memory>\n#include <new>\n#include <string>\n#include <system_error>\n#include <type_traits>\n#include <vector>\n\nnamespace llvm {\nnamespace yaml {\n\nenum class NodeKind : uint8_t {\n  Scalar,\n  Map,\n  Sequence,\n};\n\nstruct EmptyContext {};\n\n/// This class should be specialized by any type that needs to be converted\n/// to/from a YAML mapping.  For example:\n///\n///     struct MappingTraits<MyStruct> {\n///       static void mapping(IO &io, MyStruct &s) {\n///         io.mapRequired(\"name\", s.name);\n///         io.mapRequired(\"size\", s.size);\n///         io.mapOptional(\"age\",  s.age);\n///       }\n///     };\ntemplate<class T>\nstruct MappingTraits {\n  // Must provide:\n  // static void mapping(IO &io, T &fields);\n  // Optionally may provide:\n  // static std::string validate(IO &io, T &fields);\n  //\n  // The optional flow flag will cause generated YAML to use a flow mapping\n  // (e.g. { a: 0, b: 1 }):\n  // static const bool flow = true;\n};\n\n/// This class is similar to MappingTraits<T> but allows you to pass in\n/// additional context for each map operation.  For example:\n///\n///     struct MappingContextTraits<MyStruct, MyContext> {\n///       static void mapping(IO &io, MyStruct &s, MyContext &c) {\n///         io.mapRequired(\"name\", s.name);\n///         io.mapRequired(\"size\", s.size);\n///         io.mapOptional(\"age\",  s.age);\n///         ++c.TimesMapped;\n///       }\n///     };\ntemplate <class T, class Context> struct MappingContextTraits {\n  // Must provide:\n  // static void mapping(IO &io, T &fields, Context &Ctx);\n  // Optionally may provide:\n  // static std::string validate(IO &io, T &fields, Context &Ctx);\n  //\n  // The optional flow flag will cause generated YAML to use a flow mapping\n  // (e.g. { a: 0, b: 1 }):\n  // static const bool flow = true;\n};\n\n/// This class should be specialized by any integral type that converts\n/// to/from a YAML scalar where there is a one-to-one mapping between\n/// in-memory values and a string in YAML.  For example:\n///\n///     struct ScalarEnumerationTraits<Colors> {\n///         static void enumeration(IO &io, Colors &value) {\n///           io.enumCase(value, \"red\",   cRed);\n///           io.enumCase(value, \"blue\",  cBlue);\n///           io.enumCase(value, \"green\", cGreen);\n///         }\n///       };\ntemplate <typename T, typename Enable = void> struct ScalarEnumerationTraits {\n  // Must provide:\n  // static void enumeration(IO &io, T &value);\n};\n\n/// This class should be specialized by any integer type that is a union\n/// of bit values and the YAML representation is a flow sequence of\n/// strings.  For example:\n///\n///      struct ScalarBitSetTraits<MyFlags> {\n///        static void bitset(IO &io, MyFlags &value) {\n///          io.bitSetCase(value, \"big\",   flagBig);\n///          io.bitSetCase(value, \"flat\",  flagFlat);\n///          io.bitSetCase(value, \"round\", flagRound);\n///        }\n///      };\ntemplate <typename T, typename Enable = void> struct ScalarBitSetTraits {\n  // Must provide:\n  // static void bitset(IO &io, T &value);\n};\n\n/// Describe which type of quotes should be used when quoting is necessary.\n/// Some non-printable characters need to be double-quoted, while some others\n/// are fine with simple-quoting, and some don't need any quoting.\nenum class QuotingType { None, Single, Double };\n\n/// This class should be specialized by type that requires custom conversion\n/// to/from a yaml scalar.  For example:\n///\n///    template<>\n///    struct ScalarTraits<MyType> {\n///      static void output(const MyType &val, void*, llvm::raw_ostream &out) {\n///        // stream out custom formatting\n///        out << llvm::format(\"%x\", val);\n///      }\n///      static StringRef input(StringRef scalar, void*, MyType &value) {\n///        // parse scalar and set `value`\n///        // return empty string on success, or error string\n///        return StringRef();\n///      }\n///      static QuotingType mustQuote(StringRef) { return QuotingType::Single; }\n///    };\ntemplate <typename T, typename Enable = void> struct ScalarTraits {\n  // Must provide:\n  //\n  // Function to write the value as a string:\n  // static void output(const T &value, void *ctxt, llvm::raw_ostream &out);\n  //\n  // Function to convert a string to a value.  Returns the empty\n  // StringRef on success or an error string if string is malformed:\n  // static StringRef input(StringRef scalar, void *ctxt, T &value);\n  //\n  // Function to determine if the value should be quoted.\n  // static QuotingType mustQuote(StringRef);\n};\n\n/// This class should be specialized by type that requires custom conversion\n/// to/from a YAML literal block scalar. For example:\n///\n///    template <>\n///    struct BlockScalarTraits<MyType> {\n///      static void output(const MyType &Value, void*, llvm::raw_ostream &Out)\n///      {\n///        // stream out custom formatting\n///        Out << Value;\n///      }\n///      static StringRef input(StringRef Scalar, void*, MyType &Value) {\n///        // parse scalar and set `value`\n///        // return empty string on success, or error string\n///        return StringRef();\n///      }\n///    };\ntemplate <typename T>\nstruct BlockScalarTraits {\n  // Must provide:\n  //\n  // Function to write the value as a string:\n  // static void output(const T &Value, void *ctx, llvm::raw_ostream &Out);\n  //\n  // Function to convert a string to a value.  Returns the empty\n  // StringRef on success or an error string if string is malformed:\n  // static StringRef input(StringRef Scalar, void *ctxt, T &Value);\n  //\n  // Optional:\n  // static StringRef inputTag(T &Val, std::string Tag)\n  // static void outputTag(const T &Val, raw_ostream &Out)\n};\n\n/// This class should be specialized by type that requires custom conversion\n/// to/from a YAML scalar with optional tags. For example:\n///\n///    template <>\n///    struct TaggedScalarTraits<MyType> {\n///      static void output(const MyType &Value, void*, llvm::raw_ostream\n///      &ScalarOut, llvm::raw_ostream &TagOut)\n///      {\n///        // stream out custom formatting including optional Tag\n///        Out << Value;\n///      }\n///      static StringRef input(StringRef Scalar, StringRef Tag, void*, MyType\n///      &Value) {\n///        // parse scalar and set `value`\n///        // return empty string on success, or error string\n///        return StringRef();\n///      }\n///      static QuotingType mustQuote(const MyType &Value, StringRef) {\n///        return QuotingType::Single;\n///      }\n///    };\ntemplate <typename T> struct TaggedScalarTraits {\n  // Must provide:\n  //\n  // Function to write the value and tag as strings:\n  // static void output(const T &Value, void *ctx, llvm::raw_ostream &ScalarOut,\n  // llvm::raw_ostream &TagOut);\n  //\n  // Function to convert a string to a value.  Returns the empty\n  // StringRef on success or an error string if string is malformed:\n  // static StringRef input(StringRef Scalar, StringRef Tag, void *ctxt, T\n  // &Value);\n  //\n  // Function to determine if the value should be quoted.\n  // static QuotingType mustQuote(const T &Value, StringRef Scalar);\n};\n\n/// This class should be specialized by any type that needs to be converted\n/// to/from a YAML sequence.  For example:\n///\n///    template<>\n///    struct SequenceTraits<MyContainer> {\n///      static size_t size(IO &io, MyContainer &seq) {\n///        return seq.size();\n///      }\n///      static MyType& element(IO &, MyContainer &seq, size_t index) {\n///        if ( index >= seq.size() )\n///          seq.resize(index+1);\n///        return seq[index];\n///      }\n///    };\ntemplate<typename T, typename EnableIf = void>\nstruct SequenceTraits {\n  // Must provide:\n  // static size_t size(IO &io, T &seq);\n  // static T::value_type& element(IO &io, T &seq, size_t index);\n  //\n  // The following is option and will cause generated YAML to use\n  // a flow sequence (e.g. [a,b,c]).\n  // static const bool flow = true;\n};\n\n/// This class should be specialized by any type for which vectors of that\n/// type need to be converted to/from a YAML sequence.\ntemplate<typename T, typename EnableIf = void>\nstruct SequenceElementTraits {\n  // Must provide:\n  // static const bool flow;\n};\n\n/// This class should be specialized by any type that needs to be converted\n/// to/from a list of YAML documents.\ntemplate<typename T>\nstruct DocumentListTraits {\n  // Must provide:\n  // static size_t size(IO &io, T &seq);\n  // static T::value_type& element(IO &io, T &seq, size_t index);\n};\n\n/// This class should be specialized by any type that needs to be converted\n/// to/from a YAML mapping in the case where the names of the keys are not known\n/// in advance, e.g. a string map.\ntemplate <typename T>\nstruct CustomMappingTraits {\n  // static void inputOne(IO &io, StringRef key, T &elem);\n  // static void output(IO &io, T &elem);\n};\n\n/// This class should be specialized by any type that can be represented as\n/// a scalar, map, or sequence, decided dynamically. For example:\n///\n///    typedef std::unique_ptr<MyBase> MyPoly;\n///\n///    template<>\n///    struct PolymorphicTraits<MyPoly> {\n///      static NodeKind getKind(const MyPoly &poly) {\n///        return poly->getKind();\n///      }\n///      static MyScalar& getAsScalar(MyPoly &poly) {\n///        if (!poly || !isa<MyScalar>(poly))\n///          poly.reset(new MyScalar());\n///        return *cast<MyScalar>(poly.get());\n///      }\n///      // ...\n///    };\ntemplate <typename T> struct PolymorphicTraits {\n  // Must provide:\n  // static NodeKind getKind(const T &poly);\n  // static scalar_type &getAsScalar(T &poly);\n  // static map_type &getAsMap(T &poly);\n  // static sequence_type &getAsSequence(T &poly);\n};\n\n// Only used for better diagnostics of missing traits\ntemplate <typename T>\nstruct MissingTrait;\n\n// Test if ScalarEnumerationTraits<T> is defined on type T.\ntemplate <class T>\nstruct has_ScalarEnumerationTraits\n{\n  using Signature_enumeration = void (*)(class IO&, T&);\n\n  template <typename U>\n  static char test(SameType<Signature_enumeration, &U::enumeration>*);\n\n  template <typename U>\n  static double test(...);\n\n  static bool const value =\n    (sizeof(test<ScalarEnumerationTraits<T>>(nullptr)) == 1);\n};\n\n// Test if ScalarBitSetTraits<T> is defined on type T.\ntemplate <class T>\nstruct has_ScalarBitSetTraits\n{\n  using Signature_bitset = void (*)(class IO&, T&);\n\n  template <typename U>\n  static char test(SameType<Signature_bitset, &U::bitset>*);\n\n  template <typename U>\n  static double test(...);\n\n  static bool const value = (sizeof(test<ScalarBitSetTraits<T>>(nullptr)) == 1);\n};\n\n// Test if ScalarTraits<T> is defined on type T.\ntemplate <class T>\nstruct has_ScalarTraits\n{\n  using Signature_input = StringRef (*)(StringRef, void*, T&);\n  using Signature_output = void (*)(const T&, void*, raw_ostream&);\n  using Signature_mustQuote = QuotingType (*)(StringRef);\n\n  template <typename U>\n  static char test(SameType<Signature_input, &U::input> *,\n                   SameType<Signature_output, &U::output> *,\n                   SameType<Signature_mustQuote, &U::mustQuote> *);\n\n  template <typename U>\n  static double test(...);\n\n  static bool const value =\n      (sizeof(test<ScalarTraits<T>>(nullptr, nullptr, nullptr)) == 1);\n};\n\n// Test if BlockScalarTraits<T> is defined on type T.\ntemplate <class T>\nstruct has_BlockScalarTraits\n{\n  using Signature_input = StringRef (*)(StringRef, void *, T &);\n  using Signature_output = void (*)(const T &, void *, raw_ostream &);\n\n  template <typename U>\n  static char test(SameType<Signature_input, &U::input> *,\n                   SameType<Signature_output, &U::output> *);\n\n  template <typename U>\n  static double test(...);\n\n  static bool const value =\n      (sizeof(test<BlockScalarTraits<T>>(nullptr, nullptr)) == 1);\n};\n\n// Test if TaggedScalarTraits<T> is defined on type T.\ntemplate <class T> struct has_TaggedScalarTraits {\n  using Signature_input = StringRef (*)(StringRef, StringRef, void *, T &);\n  using Signature_output = void (*)(const T &, void *, raw_ostream &,\n                                    raw_ostream &);\n  using Signature_mustQuote = QuotingType (*)(const T &, StringRef);\n\n  template <typename U>\n  static char test(SameType<Signature_input, &U::input> *,\n                   SameType<Signature_output, &U::output> *,\n                   SameType<Signature_mustQuote, &U::mustQuote> *);\n\n  template <typename U> static double test(...);\n\n  static bool const value =\n      (sizeof(test<TaggedScalarTraits<T>>(nullptr, nullptr, nullptr)) == 1);\n};\n\n// Test if MappingContextTraits<T> is defined on type T.\ntemplate <class T, class Context> struct has_MappingTraits {\n  using Signature_mapping = void (*)(class IO &, T &, Context &);\n\n  template <typename U>\n  static char test(SameType<Signature_mapping, &U::mapping>*);\n\n  template <typename U>\n  static double test(...);\n\n  static bool const value =\n      (sizeof(test<MappingContextTraits<T, Context>>(nullptr)) == 1);\n};\n\n// Test if MappingTraits<T> is defined on type T.\ntemplate <class T> struct has_MappingTraits<T, EmptyContext> {\n  using Signature_mapping = void (*)(class IO &, T &);\n\n  template <typename U>\n  static char test(SameType<Signature_mapping, &U::mapping> *);\n\n  template <typename U> static double test(...);\n\n  static bool const value = (sizeof(test<MappingTraits<T>>(nullptr)) == 1);\n};\n\n// Test if MappingContextTraits<T>::validate() is defined on type T.\ntemplate <class T, class Context> struct has_MappingValidateTraits {\n  using Signature_validate = std::string (*)(class IO &, T &, Context &);\n\n  template <typename U>\n  static char test(SameType<Signature_validate, &U::validate>*);\n\n  template <typename U>\n  static double test(...);\n\n  static bool const value =\n      (sizeof(test<MappingContextTraits<T, Context>>(nullptr)) == 1);\n};\n\n// Test if MappingTraits<T>::validate() is defined on type T.\ntemplate <class T> struct has_MappingValidateTraits<T, EmptyContext> {\n  using Signature_validate = std::string (*)(class IO &, T &);\n\n  template <typename U>\n  static char test(SameType<Signature_validate, &U::validate> *);\n\n  template <typename U> static double test(...);\n\n  static bool const value = (sizeof(test<MappingTraits<T>>(nullptr)) == 1);\n};\n\n// Test if SequenceTraits<T> is defined on type T.\ntemplate <class T>\nstruct has_SequenceMethodTraits\n{\n  using Signature_size = size_t (*)(class IO&, T&);\n\n  template <typename U>\n  static char test(SameType<Signature_size, &U::size>*);\n\n  template <typename U>\n  static double test(...);\n\n  static bool const value =  (sizeof(test<SequenceTraits<T>>(nullptr)) == 1);\n};\n\n// Test if CustomMappingTraits<T> is defined on type T.\ntemplate <class T>\nstruct has_CustomMappingTraits\n{\n  using Signature_input = void (*)(IO &io, StringRef key, T &v);\n\n  template <typename U>\n  static char test(SameType<Signature_input, &U::inputOne>*);\n\n  template <typename U>\n  static double test(...);\n\n  static bool const value =\n      (sizeof(test<CustomMappingTraits<T>>(nullptr)) == 1);\n};\n\n// has_FlowTraits<int> will cause an error with some compilers because\n// it subclasses int.  Using this wrapper only instantiates the\n// real has_FlowTraits only if the template type is a class.\ntemplate <typename T, bool Enabled = std::is_class<T>::value>\nclass has_FlowTraits\n{\npublic:\n   static const bool value = false;\n};\n\n// Some older gcc compilers don't support straight forward tests\n// for members, so test for ambiguity cause by the base and derived\n// classes both defining the member.\ntemplate <class T>\nstruct has_FlowTraits<T, true>\n{\n  struct Fallback { bool flow; };\n  struct Derived : T, Fallback { };\n\n  template<typename C>\n  static char (&f(SameType<bool Fallback::*, &C::flow>*))[1];\n\n  template<typename C>\n  static char (&f(...))[2];\n\n  static bool const value = sizeof(f<Derived>(nullptr)) == 2;\n};\n\n// Test if SequenceTraits<T> is defined on type T\ntemplate<typename T>\nstruct has_SequenceTraits : public std::integral_constant<bool,\n                                      has_SequenceMethodTraits<T>::value > { };\n\n// Test if DocumentListTraits<T> is defined on type T\ntemplate <class T>\nstruct has_DocumentListTraits\n{\n  using Signature_size = size_t (*)(class IO &, T &);\n\n  template <typename U>\n  static char test(SameType<Signature_size, &U::size>*);\n\n  template <typename U>\n  static double test(...);\n\n  static bool const value = (sizeof(test<DocumentListTraits<T>>(nullptr))==1);\n};\n\ntemplate <class T> struct has_PolymorphicTraits {\n  using Signature_getKind = NodeKind (*)(const T &);\n\n  template <typename U>\n  static char test(SameType<Signature_getKind, &U::getKind> *);\n\n  template <typename U> static double test(...);\n\n  static bool const value = (sizeof(test<PolymorphicTraits<T>>(nullptr)) == 1);\n};\n\ninline bool isNumeric(StringRef S) {\n  const static auto skipDigits = [](StringRef Input) {\n    return Input.drop_front(\n        std::min(Input.find_first_not_of(\"0123456789\"), Input.size()));\n  };\n\n  // Make S.front() and S.drop_front().front() (if S.front() is [+-]) calls\n  // safe.\n  if (S.empty() || S.equals(\"+\") || S.equals(\"-\"))\n    return false;\n\n  if (S.equals(\".nan\") || S.equals(\".NaN\") || S.equals(\".NAN\"))\n    return true;\n\n  // Infinity and decimal numbers can be prefixed with sign.\n  StringRef Tail = (S.front() == '-' || S.front() == '+') ? S.drop_front() : S;\n\n  // Check for infinity first, because checking for hex and oct numbers is more\n  // expensive.\n  if (Tail.equals(\".inf\") || Tail.equals(\".Inf\") || Tail.equals(\".INF\"))\n    return true;\n\n  // Section 10.3.2 Tag Resolution\n  // YAML 1.2 Specification prohibits Base 8 and Base 16 numbers prefixed with\n  // [-+], so S should be used instead of Tail.\n  if (S.startswith(\"0o\"))\n    return S.size() > 2 &&\n           S.drop_front(2).find_first_not_of(\"01234567\") == StringRef::npos;\n\n  if (S.startswith(\"0x\"))\n    return S.size() > 2 && S.drop_front(2).find_first_not_of(\n                               \"0123456789abcdefABCDEF\") == StringRef::npos;\n\n  // Parse float: [-+]? (\\. [0-9]+ | [0-9]+ (\\. [0-9]* )?) ([eE] [-+]? [0-9]+)?\n  S = Tail;\n\n  // Handle cases when the number starts with '.' and hence needs at least one\n  // digit after dot (as opposed by number which has digits before the dot), but\n  // doesn't have one.\n  if (S.startswith(\".\") &&\n      (S.equals(\".\") ||\n       (S.size() > 1 && std::strchr(\"0123456789\", S[1]) == nullptr)))\n    return false;\n\n  if (S.startswith(\"E\") || S.startswith(\"e\"))\n    return false;\n\n  enum ParseState {\n    Default,\n    FoundDot,\n    FoundExponent,\n  };\n  ParseState State = Default;\n\n  S = skipDigits(S);\n\n  // Accept decimal integer.\n  if (S.empty())\n    return true;\n\n  if (S.front() == '.') {\n    State = FoundDot;\n    S = S.drop_front();\n  } else if (S.front() == 'e' || S.front() == 'E') {\n    State = FoundExponent;\n    S = S.drop_front();\n  } else {\n    return false;\n  }\n\n  if (State == FoundDot) {\n    S = skipDigits(S);\n    if (S.empty())\n      return true;\n\n    if (S.front() == 'e' || S.front() == 'E') {\n      State = FoundExponent;\n      S = S.drop_front();\n    } else {\n      return false;\n    }\n  }\n\n  assert(State == FoundExponent && \"Should have found exponent at this point.\");\n  if (S.empty())\n    return false;\n\n  if (S.front() == '+' || S.front() == '-') {\n    S = S.drop_front();\n    if (S.empty())\n      return false;\n  }\n\n  return skipDigits(S).empty();\n}\n\ninline bool isNull(StringRef S) {\n  return S.equals(\"null\") || S.equals(\"Null\") || S.equals(\"NULL\") ||\n         S.equals(\"~\");\n}\n\ninline bool isBool(StringRef S) {\n  // FIXME: using parseBool is causing multiple tests to fail.\n  return S.equals(\"true\") || S.equals(\"True\") || S.equals(\"TRUE\") ||\n         S.equals(\"false\") || S.equals(\"False\") || S.equals(\"FALSE\");\n}\n\n// 5.1. Character Set\n// The allowed character range explicitly excludes the C0 control block #x0-#x1F\n// (except for TAB #x9, LF #xA, and CR #xD which are allowed), DEL #x7F, the C1\n// control block #x80-#x9F (except for NEL #x85 which is allowed), the surrogate\n// block #xD800-#xDFFF, #xFFFE, and #xFFFF.\ninline QuotingType needsQuotes(StringRef S) {\n  if (S.empty())\n    return QuotingType::Single;\n\n  QuotingType MaxQuotingNeeded = QuotingType::None;\n  if (isSpace(static_cast<unsigned char>(S.front())) ||\n      isSpace(static_cast<unsigned char>(S.back())))\n    MaxQuotingNeeded = QuotingType::Single;\n  if (isNull(S))\n    MaxQuotingNeeded = QuotingType::Single;\n  if (isBool(S))\n    MaxQuotingNeeded = QuotingType::Single;\n  if (isNumeric(S))\n    MaxQuotingNeeded = QuotingType::Single;\n\n  // 7.3.3 Plain Style\n  // Plain scalars must not begin with most indicators, as this would cause\n  // ambiguity with other YAML constructs.\n  static constexpr char Indicators[] = R\"(-?:\\,[]{}#&*!|>'\"%@`)\";\n  if (S.find_first_of(Indicators) == 0)\n    MaxQuotingNeeded = QuotingType::Single;\n\n  for (unsigned char C : S) {\n    // Alphanum is safe.\n    if (isAlnum(C))\n      continue;\n\n    switch (C) {\n    // Safe scalar characters.\n    case '_':\n    case '-':\n    case '^':\n    case '.':\n    case ',':\n    case ' ':\n    // TAB (0x9) is allowed in unquoted strings.\n    case 0x9:\n      continue;\n    // LF(0xA) and CR(0xD) may delimit values and so require at least single\n    // quotes. LLVM YAML parser cannot handle single quoted multiline so use\n    // double quoting to produce valid YAML.\n    case 0xA:\n    case 0xD:\n      return QuotingType::Double;\n    // DEL (0x7F) are excluded from the allowed character range.\n    case 0x7F:\n      return QuotingType::Double;\n    // Forward slash is allowed to be unquoted, but we quote it anyway.  We have\n    // many tests that use FileCheck against YAML output, and this output often\n    // contains paths.  If we quote backslashes but not forward slashes then\n    // paths will come out either quoted or unquoted depending on which platform\n    // the test is run on, making FileCheck comparisons difficult.\n    case '/':\n    default: {\n      // C0 control block (0x0 - 0x1F) is excluded from the allowed character\n      // range.\n      if (C <= 0x1F)\n        return QuotingType::Double;\n\n      // Always double quote UTF-8.\n      if ((C & 0x80) != 0)\n        return QuotingType::Double;\n\n      // The character is not safe, at least simple quoting needed.\n      MaxQuotingNeeded = QuotingType::Single;\n    }\n    }\n  }\n\n  return MaxQuotingNeeded;\n}\n\ntemplate <typename T, typename Context>\nstruct missingTraits\n    : public std::integral_constant<bool,\n                                    !has_ScalarEnumerationTraits<T>::value &&\n                                        !has_ScalarBitSetTraits<T>::value &&\n                                        !has_ScalarTraits<T>::value &&\n                                        !has_BlockScalarTraits<T>::value &&\n                                        !has_TaggedScalarTraits<T>::value &&\n                                        !has_MappingTraits<T, Context>::value &&\n                                        !has_SequenceTraits<T>::value &&\n                                        !has_CustomMappingTraits<T>::value &&\n                                        !has_DocumentListTraits<T>::value &&\n                                        !has_PolymorphicTraits<T>::value> {};\n\ntemplate <typename T, typename Context>\nstruct validatedMappingTraits\n    : public std::integral_constant<\n          bool, has_MappingTraits<T, Context>::value &&\n                    has_MappingValidateTraits<T, Context>::value> {};\n\ntemplate <typename T, typename Context>\nstruct unvalidatedMappingTraits\n    : public std::integral_constant<\n          bool, has_MappingTraits<T, Context>::value &&\n                    !has_MappingValidateTraits<T, Context>::value> {};\n\n// Base class for Input and Output.\nclass IO {\npublic:\n  IO(void *Ctxt = nullptr);\n  virtual ~IO();\n\n  virtual bool outputting() const = 0;\n\n  virtual unsigned beginSequence() = 0;\n  virtual bool preflightElement(unsigned, void *&) = 0;\n  virtual void postflightElement(void*) = 0;\n  virtual void endSequence() = 0;\n  virtual bool canElideEmptySequence() = 0;\n\n  virtual unsigned beginFlowSequence() = 0;\n  virtual bool preflightFlowElement(unsigned, void *&) = 0;\n  virtual void postflightFlowElement(void*) = 0;\n  virtual void endFlowSequence() = 0;\n\n  virtual bool mapTag(StringRef Tag, bool Default=false) = 0;\n  virtual void beginMapping() = 0;\n  virtual void endMapping() = 0;\n  virtual bool preflightKey(const char*, bool, bool, bool &, void *&) = 0;\n  virtual void postflightKey(void*) = 0;\n  virtual std::vector<StringRef> keys() = 0;\n\n  virtual void beginFlowMapping() = 0;\n  virtual void endFlowMapping() = 0;\n\n  virtual void beginEnumScalar() = 0;\n  virtual bool matchEnumScalar(const char*, bool) = 0;\n  virtual bool matchEnumFallback() = 0;\n  virtual void endEnumScalar() = 0;\n\n  virtual bool beginBitSetScalar(bool &) = 0;\n  virtual bool bitSetMatch(const char*, bool) = 0;\n  virtual void endBitSetScalar() = 0;\n\n  virtual void scalarString(StringRef &, QuotingType) = 0;\n  virtual void blockScalarString(StringRef &) = 0;\n  virtual void scalarTag(std::string &) = 0;\n\n  virtual NodeKind getNodeKind() = 0;\n\n  virtual void setError(const Twine &) = 0;\n  virtual void setAllowUnknownKeys(bool Allow);\n\n  template <typename T>\n  void enumCase(T &Val, const char* Str, const T ConstVal) {\n    if ( matchEnumScalar(Str, outputting() && Val == ConstVal) ) {\n      Val = ConstVal;\n    }\n  }\n\n  // allow anonymous enum values to be used with LLVM_YAML_STRONG_TYPEDEF\n  template <typename T>\n  void enumCase(T &Val, const char* Str, const uint32_t ConstVal) {\n    if ( matchEnumScalar(Str, outputting() && Val == static_cast<T>(ConstVal)) ) {\n      Val = ConstVal;\n    }\n  }\n\n  template <typename FBT, typename T>\n  void enumFallback(T &Val) {\n    if (matchEnumFallback()) {\n      EmptyContext Context;\n      // FIXME: Force integral conversion to allow strong typedefs to convert.\n      FBT Res = static_cast<typename FBT::BaseType>(Val);\n      yamlize(*this, Res, true, Context);\n      Val = static_cast<T>(static_cast<typename FBT::BaseType>(Res));\n    }\n  }\n\n  template <typename T>\n  void bitSetCase(T &Val, const char* Str, const T ConstVal) {\n    if ( bitSetMatch(Str, outputting() && (Val & ConstVal) == ConstVal) ) {\n      Val = static_cast<T>(Val | ConstVal);\n    }\n  }\n\n  // allow anonymous enum values to be used with LLVM_YAML_STRONG_TYPEDEF\n  template <typename T>\n  void bitSetCase(T &Val, const char* Str, const uint32_t ConstVal) {\n    if ( bitSetMatch(Str, outputting() && (Val & ConstVal) == ConstVal) ) {\n      Val = static_cast<T>(Val | ConstVal);\n    }\n  }\n\n  template <typename T>\n  void maskedBitSetCase(T &Val, const char *Str, T ConstVal, T Mask) {\n    if (bitSetMatch(Str, outputting() && (Val & Mask) == ConstVal))\n      Val = Val | ConstVal;\n  }\n\n  template <typename T>\n  void maskedBitSetCase(T &Val, const char *Str, uint32_t ConstVal,\n                        uint32_t Mask) {\n    if (bitSetMatch(Str, outputting() && (Val & Mask) == ConstVal))\n      Val = Val | ConstVal;\n  }\n\n  void *getContext() const;\n  void setContext(void *);\n\n  template <typename T> void mapRequired(const char *Key, T &Val) {\n    EmptyContext Ctx;\n    this->processKey(Key, Val, true, Ctx);\n  }\n\n  template <typename T, typename Context>\n  void mapRequired(const char *Key, T &Val, Context &Ctx) {\n    this->processKey(Key, Val, true, Ctx);\n  }\n\n  template <typename T> void mapOptional(const char *Key, T &Val) {\n    EmptyContext Ctx;\n    mapOptionalWithContext(Key, Val, Ctx);\n  }\n\n  template <typename T, typename DefaultT>\n  void mapOptional(const char *Key, T &Val, const DefaultT &Default) {\n    EmptyContext Ctx;\n    mapOptionalWithContext(Key, Val, Default, Ctx);\n  }\n\n  template <typename T, typename Context>\n  std::enable_if_t<has_SequenceTraits<T>::value, void>\n  mapOptionalWithContext(const char *Key, T &Val, Context &Ctx) {\n    // omit key/value instead of outputting empty sequence\n    if (this->canElideEmptySequence() && !(Val.begin() != Val.end()))\n      return;\n    this->processKey(Key, Val, false, Ctx);\n  }\n\n  template <typename T, typename Context>\n  void mapOptionalWithContext(const char *Key, Optional<T> &Val, Context &Ctx) {\n    this->processKeyWithDefault(Key, Val, Optional<T>(), /*Required=*/false,\n                                Ctx);\n  }\n\n  template <typename T, typename Context>\n  std::enable_if_t<!has_SequenceTraits<T>::value, void>\n  mapOptionalWithContext(const char *Key, T &Val, Context &Ctx) {\n    this->processKey(Key, Val, false, Ctx);\n  }\n\n  template <typename T, typename Context, typename DefaultT>\n  void mapOptionalWithContext(const char *Key, T &Val, const DefaultT &Default,\n                              Context &Ctx) {\n    static_assert(std::is_convertible<DefaultT, T>::value,\n                  \"Default type must be implicitly convertible to value type!\");\n    this->processKeyWithDefault(Key, Val, static_cast<const T &>(Default),\n                                false, Ctx);\n  }\n\nprivate:\n  template <typename T, typename Context>\n  void processKeyWithDefault(const char *Key, Optional<T> &Val,\n                             const Optional<T> &DefaultValue, bool Required,\n                             Context &Ctx);\n\n  template <typename T, typename Context>\n  void processKeyWithDefault(const char *Key, T &Val, const T &DefaultValue,\n                             bool Required, Context &Ctx) {\n    void *SaveInfo;\n    bool UseDefault;\n    const bool sameAsDefault = outputting() && Val == DefaultValue;\n    if ( this->preflightKey(Key, Required, sameAsDefault, UseDefault,\n                                                                  SaveInfo) ) {\n      yamlize(*this, Val, Required, Ctx);\n      this->postflightKey(SaveInfo);\n    }\n    else {\n      if ( UseDefault )\n        Val = DefaultValue;\n    }\n  }\n\n  template <typename T, typename Context>\n  void processKey(const char *Key, T &Val, bool Required, Context &Ctx) {\n    void *SaveInfo;\n    bool UseDefault;\n    if ( this->preflightKey(Key, Required, false, UseDefault, SaveInfo) ) {\n      yamlize(*this, Val, Required, Ctx);\n      this->postflightKey(SaveInfo);\n    }\n  }\n\nprivate:\n  void *Ctxt;\n};\n\nnamespace detail {\n\ntemplate <typename T, typename Context>\nvoid doMapping(IO &io, T &Val, Context &Ctx) {\n  MappingContextTraits<T, Context>::mapping(io, Val, Ctx);\n}\n\ntemplate <typename T> void doMapping(IO &io, T &Val, EmptyContext &Ctx) {\n  MappingTraits<T>::mapping(io, Val);\n}\n\n} // end namespace detail\n\ntemplate <typename T>\nstd::enable_if_t<has_ScalarEnumerationTraits<T>::value, void>\nyamlize(IO &io, T &Val, bool, EmptyContext &Ctx) {\n  io.beginEnumScalar();\n  ScalarEnumerationTraits<T>::enumeration(io, Val);\n  io.endEnumScalar();\n}\n\ntemplate <typename T>\nstd::enable_if_t<has_ScalarBitSetTraits<T>::value, void>\nyamlize(IO &io, T &Val, bool, EmptyContext &Ctx) {\n  bool DoClear;\n  if ( io.beginBitSetScalar(DoClear) ) {\n    if ( DoClear )\n      Val = T();\n    ScalarBitSetTraits<T>::bitset(io, Val);\n    io.endBitSetScalar();\n  }\n}\n\ntemplate <typename T>\nstd::enable_if_t<has_ScalarTraits<T>::value, void> yamlize(IO &io, T &Val, bool,\n                                                           EmptyContext &Ctx) {\n  if ( io.outputting() ) {\n    std::string Storage;\n    raw_string_ostream Buffer(Storage);\n    ScalarTraits<T>::output(Val, io.getContext(), Buffer);\n    StringRef Str = Buffer.str();\n    io.scalarString(Str, ScalarTraits<T>::mustQuote(Str));\n  }\n  else {\n    StringRef Str;\n    io.scalarString(Str, ScalarTraits<T>::mustQuote(Str));\n    StringRef Result = ScalarTraits<T>::input(Str, io.getContext(), Val);\n    if ( !Result.empty() ) {\n      io.setError(Twine(Result));\n    }\n  }\n}\n\ntemplate <typename T>\nstd::enable_if_t<has_BlockScalarTraits<T>::value, void>\nyamlize(IO &YamlIO, T &Val, bool, EmptyContext &Ctx) {\n  if (YamlIO.outputting()) {\n    std::string Storage;\n    raw_string_ostream Buffer(Storage);\n    BlockScalarTraits<T>::output(Val, YamlIO.getContext(), Buffer);\n    StringRef Str = Buffer.str();\n    YamlIO.blockScalarString(Str);\n  } else {\n    StringRef Str;\n    YamlIO.blockScalarString(Str);\n    StringRef Result =\n        BlockScalarTraits<T>::input(Str, YamlIO.getContext(), Val);\n    if (!Result.empty())\n      YamlIO.setError(Twine(Result));\n  }\n}\n\ntemplate <typename T>\nstd::enable_if_t<has_TaggedScalarTraits<T>::value, void>\nyamlize(IO &io, T &Val, bool, EmptyContext &Ctx) {\n  if (io.outputting()) {\n    std::string ScalarStorage, TagStorage;\n    raw_string_ostream ScalarBuffer(ScalarStorage), TagBuffer(TagStorage);\n    TaggedScalarTraits<T>::output(Val, io.getContext(), ScalarBuffer,\n                                  TagBuffer);\n    io.scalarTag(TagBuffer.str());\n    StringRef ScalarStr = ScalarBuffer.str();\n    io.scalarString(ScalarStr,\n                    TaggedScalarTraits<T>::mustQuote(Val, ScalarStr));\n  } else {\n    std::string Tag;\n    io.scalarTag(Tag);\n    StringRef Str;\n    io.scalarString(Str, QuotingType::None);\n    StringRef Result =\n        TaggedScalarTraits<T>::input(Str, Tag, io.getContext(), Val);\n    if (!Result.empty()) {\n      io.setError(Twine(Result));\n    }\n  }\n}\n\ntemplate <typename T, typename Context>\nstd::enable_if_t<validatedMappingTraits<T, Context>::value, void>\nyamlize(IO &io, T &Val, bool, Context &Ctx) {\n  if (has_FlowTraits<MappingTraits<T>>::value)\n    io.beginFlowMapping();\n  else\n    io.beginMapping();\n  if (io.outputting()) {\n    std::string Err = MappingTraits<T>::validate(io, Val);\n    if (!Err.empty()) {\n      errs() << Err << \"\\n\";\n      assert(Err.empty() && \"invalid struct trying to be written as yaml\");\n    }\n  }\n  detail::doMapping(io, Val, Ctx);\n  if (!io.outputting()) {\n    std::string Err = MappingTraits<T>::validate(io, Val);\n    if (!Err.empty())\n      io.setError(Err);\n  }\n  if (has_FlowTraits<MappingTraits<T>>::value)\n    io.endFlowMapping();\n  else\n    io.endMapping();\n}\n\ntemplate <typename T, typename Context>\nstd::enable_if_t<unvalidatedMappingTraits<T, Context>::value, void>\nyamlize(IO &io, T &Val, bool, Context &Ctx) {\n  if (has_FlowTraits<MappingTraits<T>>::value) {\n    io.beginFlowMapping();\n    detail::doMapping(io, Val, Ctx);\n    io.endFlowMapping();\n  } else {\n    io.beginMapping();\n    detail::doMapping(io, Val, Ctx);\n    io.endMapping();\n  }\n}\n\ntemplate <typename T>\nstd::enable_if_t<has_CustomMappingTraits<T>::value, void>\nyamlize(IO &io, T &Val, bool, EmptyContext &Ctx) {\n  if ( io.outputting() ) {\n    io.beginMapping();\n    CustomMappingTraits<T>::output(io, Val);\n    io.endMapping();\n  } else {\n    io.beginMapping();\n    for (StringRef key : io.keys())\n      CustomMappingTraits<T>::inputOne(io, key, Val);\n    io.endMapping();\n  }\n}\n\ntemplate <typename T>\nstd::enable_if_t<has_PolymorphicTraits<T>::value, void>\nyamlize(IO &io, T &Val, bool, EmptyContext &Ctx) {\n  switch (io.outputting() ? PolymorphicTraits<T>::getKind(Val)\n                          : io.getNodeKind()) {\n  case NodeKind::Scalar:\n    return yamlize(io, PolymorphicTraits<T>::getAsScalar(Val), true, Ctx);\n  case NodeKind::Map:\n    return yamlize(io, PolymorphicTraits<T>::getAsMap(Val), true, Ctx);\n  case NodeKind::Sequence:\n    return yamlize(io, PolymorphicTraits<T>::getAsSequence(Val), true, Ctx);\n  }\n}\n\ntemplate <typename T>\nstd::enable_if_t<missingTraits<T, EmptyContext>::value, void>\nyamlize(IO &io, T &Val, bool, EmptyContext &Ctx) {\n  char missing_yaml_trait_for_type[sizeof(MissingTrait<T>)];\n}\n\ntemplate <typename T, typename Context>\nstd::enable_if_t<has_SequenceTraits<T>::value, void>\nyamlize(IO &io, T &Seq, bool, Context &Ctx) {\n  if ( has_FlowTraits< SequenceTraits<T>>::value ) {\n    unsigned incnt = io.beginFlowSequence();\n    unsigned count = io.outputting() ? SequenceTraits<T>::size(io, Seq) : incnt;\n    for(unsigned i=0; i < count; ++i) {\n      void *SaveInfo;\n      if ( io.preflightFlowElement(i, SaveInfo) ) {\n        yamlize(io, SequenceTraits<T>::element(io, Seq, i), true, Ctx);\n        io.postflightFlowElement(SaveInfo);\n      }\n    }\n    io.endFlowSequence();\n  }\n  else {\n    unsigned incnt = io.beginSequence();\n    unsigned count = io.outputting() ? SequenceTraits<T>::size(io, Seq) : incnt;\n    for(unsigned i=0; i < count; ++i) {\n      void *SaveInfo;\n      if ( io.preflightElement(i, SaveInfo) ) {\n        yamlize(io, SequenceTraits<T>::element(io, Seq, i), true, Ctx);\n        io.postflightElement(SaveInfo);\n      }\n    }\n    io.endSequence();\n  }\n}\n\ntemplate<>\nstruct ScalarTraits<bool> {\n  static void output(const bool &, void* , raw_ostream &);\n  static StringRef input(StringRef, void *, bool &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<StringRef> {\n  static void output(const StringRef &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, StringRef &);\n  static QuotingType mustQuote(StringRef S) { return needsQuotes(S); }\n};\n\ntemplate<>\nstruct ScalarTraits<std::string> {\n  static void output(const std::string &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, std::string &);\n  static QuotingType mustQuote(StringRef S) { return needsQuotes(S); }\n};\n\ntemplate<>\nstruct ScalarTraits<uint8_t> {\n  static void output(const uint8_t &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, uint8_t &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<uint16_t> {\n  static void output(const uint16_t &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, uint16_t &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<uint32_t> {\n  static void output(const uint32_t &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, uint32_t &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<uint64_t> {\n  static void output(const uint64_t &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, uint64_t &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<int8_t> {\n  static void output(const int8_t &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, int8_t &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<int16_t> {\n  static void output(const int16_t &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, int16_t &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<int32_t> {\n  static void output(const int32_t &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, int32_t &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<int64_t> {\n  static void output(const int64_t &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, int64_t &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<float> {\n  static void output(const float &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, float &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<double> {\n  static void output(const double &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, double &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\n// For endian types, we use existing scalar Traits class for the underlying\n// type.  This way endian aware types are supported whenever the traits are\n// defined for the underlying type.\ntemplate <typename value_type, support::endianness endian, size_t alignment>\nstruct ScalarTraits<support::detail::packed_endian_specific_integral<\n                        value_type, endian, alignment>,\n                    std::enable_if_t<has_ScalarTraits<value_type>::value>> {\n  using endian_type =\n      support::detail::packed_endian_specific_integral<value_type, endian,\n                                                       alignment>;\n\n  static void output(const endian_type &E, void *Ctx, raw_ostream &Stream) {\n    ScalarTraits<value_type>::output(static_cast<value_type>(E), Ctx, Stream);\n  }\n\n  static StringRef input(StringRef Str, void *Ctx, endian_type &E) {\n    value_type V;\n    auto R = ScalarTraits<value_type>::input(Str, Ctx, V);\n    E = static_cast<endian_type>(V);\n    return R;\n  }\n\n  static QuotingType mustQuote(StringRef Str) {\n    return ScalarTraits<value_type>::mustQuote(Str);\n  }\n};\n\ntemplate <typename value_type, support::endianness endian, size_t alignment>\nstruct ScalarEnumerationTraits<\n    support::detail::packed_endian_specific_integral<value_type, endian,\n                                                     alignment>,\n    std::enable_if_t<has_ScalarEnumerationTraits<value_type>::value>> {\n  using endian_type =\n      support::detail::packed_endian_specific_integral<value_type, endian,\n                                                       alignment>;\n\n  static void enumeration(IO &io, endian_type &E) {\n    value_type V = E;\n    ScalarEnumerationTraits<value_type>::enumeration(io, V);\n    E = V;\n  }\n};\n\ntemplate <typename value_type, support::endianness endian, size_t alignment>\nstruct ScalarBitSetTraits<\n    support::detail::packed_endian_specific_integral<value_type, endian,\n                                                     alignment>,\n    std::enable_if_t<has_ScalarBitSetTraits<value_type>::value>> {\n  using endian_type =\n      support::detail::packed_endian_specific_integral<value_type, endian,\n                                                       alignment>;\n  static void bitset(IO &io, endian_type &E) {\n    value_type V = E;\n    ScalarBitSetTraits<value_type>::bitset(io, V);\n    E = V;\n  }\n};\n\n// Utility for use within MappingTraits<>::mapping() method\n// to [de]normalize an object for use with YAML conversion.\ntemplate <typename TNorm, typename TFinal>\nstruct MappingNormalization {\n  MappingNormalization(IO &i_o, TFinal &Obj)\n      : io(i_o), BufPtr(nullptr), Result(Obj) {\n    if ( io.outputting() ) {\n      BufPtr = new (&Buffer) TNorm(io, Obj);\n    }\n    else {\n      BufPtr = new (&Buffer) TNorm(io);\n    }\n  }\n\n  ~MappingNormalization() {\n    if ( ! io.outputting() ) {\n      Result = BufPtr->denormalize(io);\n    }\n    BufPtr->~TNorm();\n  }\n\n  TNorm* operator->() { return BufPtr; }\n\nprivate:\n  using Storage = AlignedCharArrayUnion<TNorm>;\n\n  Storage       Buffer;\n  IO           &io;\n  TNorm        *BufPtr;\n  TFinal       &Result;\n};\n\n// Utility for use within MappingTraits<>::mapping() method\n// to [de]normalize an object for use with YAML conversion.\ntemplate <typename TNorm, typename TFinal>\nstruct MappingNormalizationHeap {\n  MappingNormalizationHeap(IO &i_o, TFinal &Obj, BumpPtrAllocator *allocator)\n    : io(i_o), Result(Obj) {\n    if ( io.outputting() ) {\n      BufPtr = new (&Buffer) TNorm(io, Obj);\n    }\n    else if (allocator) {\n      BufPtr = allocator->Allocate<TNorm>();\n      new (BufPtr) TNorm(io);\n    } else {\n      BufPtr = new TNorm(io);\n    }\n  }\n\n  ~MappingNormalizationHeap() {\n    if ( io.outputting() ) {\n      BufPtr->~TNorm();\n    }\n    else {\n      Result = BufPtr->denormalize(io);\n    }\n  }\n\n  TNorm* operator->() { return BufPtr; }\n\nprivate:\n  using Storage = AlignedCharArrayUnion<TNorm>;\n\n  Storage       Buffer;\n  IO           &io;\n  TNorm        *BufPtr = nullptr;\n  TFinal       &Result;\n};\n\n///\n/// The Input class is used to parse a yaml document into in-memory structs\n/// and vectors.\n///\n/// It works by using YAMLParser to do a syntax parse of the entire yaml\n/// document, then the Input class builds a graph of HNodes which wraps\n/// each yaml Node.  The extra layer is buffering.  The low level yaml\n/// parser only lets you look at each node once.  The buffering layer lets\n/// you search and interate multiple times.  This is necessary because\n/// the mapRequired() method calls may not be in the same order\n/// as the keys in the document.\n///\nclass Input : public IO {\npublic:\n  // Construct a yaml Input object from a StringRef and optional\n  // user-data. The DiagHandler can be specified to provide\n  // alternative error reporting.\n  Input(StringRef InputContent,\n        void *Ctxt = nullptr,\n        SourceMgr::DiagHandlerTy DiagHandler = nullptr,\n        void *DiagHandlerCtxt = nullptr);\n  Input(MemoryBufferRef Input,\n        void *Ctxt = nullptr,\n        SourceMgr::DiagHandlerTy DiagHandler = nullptr,\n        void *DiagHandlerCtxt = nullptr);\n  ~Input() override;\n\n  // Check if there was an syntax or semantic error during parsing.\n  std::error_code error();\n\nprivate:\n  bool outputting() const override;\n  bool mapTag(StringRef, bool) override;\n  void beginMapping() override;\n  void endMapping() override;\n  bool preflightKey(const char *, bool, bool, bool &, void *&) override;\n  void postflightKey(void *) override;\n  std::vector<StringRef> keys() override;\n  void beginFlowMapping() override;\n  void endFlowMapping() override;\n  unsigned beginSequence() override;\n  void endSequence() override;\n  bool preflightElement(unsigned index, void *&) override;\n  void postflightElement(void *) override;\n  unsigned beginFlowSequence() override;\n  bool preflightFlowElement(unsigned , void *&) override;\n  void postflightFlowElement(void *) override;\n  void endFlowSequence() override;\n  void beginEnumScalar() override;\n  bool matchEnumScalar(const char*, bool) override;\n  bool matchEnumFallback() override;\n  void endEnumScalar() override;\n  bool beginBitSetScalar(bool &) override;\n  bool bitSetMatch(const char *, bool ) override;\n  void endBitSetScalar() override;\n  void scalarString(StringRef &, QuotingType) override;\n  void blockScalarString(StringRef &) override;\n  void scalarTag(std::string &) override;\n  NodeKind getNodeKind() override;\n  void setError(const Twine &message) override;\n  bool canElideEmptySequence() override;\n\n  class HNode {\n    virtual void anchor();\n\n  public:\n    HNode(Node *n) : _node(n) { }\n    virtual ~HNode() = default;\n\n    static bool classof(const HNode *) { return true; }\n\n    Node *_node;\n  };\n\n  class EmptyHNode : public HNode {\n    void anchor() override;\n\n  public:\n    EmptyHNode(Node *n) : HNode(n) { }\n\n    static bool classof(const HNode *n) { return NullNode::classof(n->_node); }\n\n    static bool classof(const EmptyHNode *) { return true; }\n  };\n\n  class ScalarHNode : public HNode {\n    void anchor() override;\n\n  public:\n    ScalarHNode(Node *n, StringRef s) : HNode(n), _value(s) { }\n\n    StringRef value() const { return _value; }\n\n    static bool classof(const HNode *n) {\n      return ScalarNode::classof(n->_node) ||\n             BlockScalarNode::classof(n->_node);\n    }\n\n    static bool classof(const ScalarHNode *) { return true; }\n\n  protected:\n    StringRef _value;\n  };\n\n  class MapHNode : public HNode {\n    void anchor() override;\n\n  public:\n    MapHNode(Node *n) : HNode(n) { }\n\n    static bool classof(const HNode *n) {\n      return MappingNode::classof(n->_node);\n    }\n\n    static bool classof(const MapHNode *) { return true; }\n\n    using NameToNodeAndLoc =\n        StringMap<std::pair<std::unique_ptr<HNode>, SMRange>>;\n\n    NameToNodeAndLoc Mapping;\n    SmallVector<std::string, 6> ValidKeys;\n  };\n\n  class SequenceHNode : public HNode {\n    void anchor() override;\n\n  public:\n    SequenceHNode(Node *n) : HNode(n) { }\n\n    static bool classof(const HNode *n) {\n      return SequenceNode::classof(n->_node);\n    }\n\n    static bool classof(const SequenceHNode *) { return true; }\n\n    std::vector<std::unique_ptr<HNode>> Entries;\n  };\n\n  std::unique_ptr<Input::HNode> createHNodes(Node *node);\n  void setError(HNode *hnode, const Twine &message);\n  void setError(Node *node, const Twine &message);\n  void setError(const SMRange &Range, const Twine &message);\n\n  void reportWarning(HNode *hnode, const Twine &message);\n  void reportWarning(Node *hnode, const Twine &message);\n  void reportWarning(const SMRange &Range, const Twine &message);\n\npublic:\n  // These are only used by operator>>. They could be private\n  // if those templated things could be made friends.\n  bool setCurrentDocument();\n  bool nextDocument();\n\n  /// Returns the current node that's being parsed by the YAML Parser.\n  const Node *getCurrentNode() const;\n\n  void setAllowUnknownKeys(bool Allow) override;\n\nprivate:\n  SourceMgr                           SrcMgr; // must be before Strm\n  std::unique_ptr<llvm::yaml::Stream> Strm;\n  std::unique_ptr<HNode>              TopNode;\n  std::error_code                     EC;\n  BumpPtrAllocator                    StringAllocator;\n  document_iterator                   DocIterator;\n  std::vector<bool>                   BitValuesUsed;\n  HNode *CurrentNode = nullptr;\n  bool                                ScalarMatchFound = false;\n  bool AllowUnknownKeys = false;\n};\n\n///\n/// The Output class is used to generate a yaml document from in-memory structs\n/// and vectors.\n///\nclass Output : public IO {\npublic:\n  Output(raw_ostream &, void *Ctxt = nullptr, int WrapColumn = 70);\n  ~Output() override;\n\n  /// Set whether or not to output optional values which are equal\n  /// to the default value.  By default, when outputting if you attempt\n  /// to write a value that is equal to the default, the value gets ignored.\n  /// Sometimes, it is useful to be able to see these in the resulting YAML\n  /// anyway.\n  void setWriteDefaultValues(bool Write) { WriteDefaultValues = Write; }\n\n  bool outputting() const override;\n  bool mapTag(StringRef, bool) override;\n  void beginMapping() override;\n  void endMapping() override;\n  bool preflightKey(const char *key, bool, bool, bool &, void *&) override;\n  void postflightKey(void *) override;\n  std::vector<StringRef> keys() override;\n  void beginFlowMapping() override;\n  void endFlowMapping() override;\n  unsigned beginSequence() override;\n  void endSequence() override;\n  bool preflightElement(unsigned, void *&) override;\n  void postflightElement(void *) override;\n  unsigned beginFlowSequence() override;\n  bool preflightFlowElement(unsigned, void *&) override;\n  void postflightFlowElement(void *) override;\n  void endFlowSequence() override;\n  void beginEnumScalar() override;\n  bool matchEnumScalar(const char*, bool) override;\n  bool matchEnumFallback() override;\n  void endEnumScalar() override;\n  bool beginBitSetScalar(bool &) override;\n  bool bitSetMatch(const char *, bool ) override;\n  void endBitSetScalar() override;\n  void scalarString(StringRef &, QuotingType) override;\n  void blockScalarString(StringRef &) override;\n  void scalarTag(std::string &) override;\n  NodeKind getNodeKind() override;\n  void setError(const Twine &message) override;\n  bool canElideEmptySequence() override;\n\n  // These are only used by operator<<. They could be private\n  // if that templated operator could be made a friend.\n  void beginDocuments();\n  bool preflightDocument(unsigned);\n  void postflightDocument();\n  void endDocuments();\n\nprivate:\n  void output(StringRef s);\n  void outputUpToEndOfLine(StringRef s);\n  void newLineCheck(bool EmptySequence = false);\n  void outputNewLine();\n  void paddedKey(StringRef key);\n  void flowKey(StringRef Key);\n\n  enum InState {\n    inSeqFirstElement,\n    inSeqOtherElement,\n    inFlowSeqFirstElement,\n    inFlowSeqOtherElement,\n    inMapFirstKey,\n    inMapOtherKey,\n    inFlowMapFirstKey,\n    inFlowMapOtherKey\n  };\n\n  static bool inSeqAnyElement(InState State);\n  static bool inFlowSeqAnyElement(InState State);\n  static bool inMapAnyKey(InState State);\n  static bool inFlowMapAnyKey(InState State);\n\n  raw_ostream &Out;\n  int WrapColumn;\n  SmallVector<InState, 8> StateStack;\n  int Column = 0;\n  int ColumnAtFlowStart = 0;\n  int ColumnAtMapFlowStart = 0;\n  bool NeedBitValueComma = false;\n  bool NeedFlowSequenceComma = false;\n  bool EnumerationMatchFound = false;\n  bool WriteDefaultValues = false;\n  StringRef Padding;\n  StringRef PaddingBeforeContainer;\n};\n\ntemplate <typename T, typename Context>\nvoid IO::processKeyWithDefault(const char *Key, Optional<T> &Val,\n                               const Optional<T> &DefaultValue, bool Required,\n                               Context &Ctx) {\n  assert(DefaultValue.hasValue() == false &&\n         \"Optional<T> shouldn't have a value!\");\n  void *SaveInfo;\n  bool UseDefault = true;\n  const bool sameAsDefault = outputting() && !Val.hasValue();\n  if (!outputting() && !Val.hasValue())\n    Val = T();\n  if (Val.hasValue() &&\n      this->preflightKey(Key, Required, sameAsDefault, UseDefault, SaveInfo)) {\n\n    // When reading an Optional<X> key from a YAML description, we allow the\n    // special \"<none>\" value, which can be used to specify that no value was\n    // requested, i.e. the DefaultValue will be assigned. The DefaultValue is\n    // usually None.\n    bool IsNone = false;\n    if (!outputting())\n      if (auto *Node = dyn_cast<ScalarNode>(((Input *)this)->getCurrentNode()))\n        // We use rtrim to ignore possible white spaces that might exist when a\n        // comment is present on the same line.\n        IsNone = Node->getRawValue().rtrim(' ') == \"<none>\";\n\n    if (IsNone)\n      Val = DefaultValue;\n    else\n      yamlize(*this, Val.getValue(), Required, Ctx);\n    this->postflightKey(SaveInfo);\n  } else {\n    if (UseDefault)\n      Val = DefaultValue;\n  }\n}\n\n/// YAML I/O does conversion based on types. But often native data types\n/// are just a typedef of built in intergral types (e.g. int).  But the C++\n/// type matching system sees through the typedef and all the typedefed types\n/// look like a built in type. This will cause the generic YAML I/O conversion\n/// to be used. To provide better control over the YAML conversion, you can\n/// use this macro instead of typedef.  It will create a class with one field\n/// and automatic conversion operators to and from the base type.\n/// Based on BOOST_STRONG_TYPEDEF\n#define LLVM_YAML_STRONG_TYPEDEF(_base, _type)                                 \\\n    struct _type {                                                             \\\n        _type() = default;                                                     \\\n        _type(const _base v) : value(v) {}                                     \\\n        _type(const _type &v) = default;                                       \\\n        _type &operator=(const _type &rhs) = default;                          \\\n        _type &operator=(const _base &rhs) { value = rhs; return *this; }      \\\n        operator const _base & () const { return value; }                      \\\n        bool operator==(const _type &rhs) const { return value == rhs.value; } \\\n        bool operator==(const _base &rhs) const { return value == rhs; }       \\\n        bool operator<(const _type &rhs) const { return value < rhs.value; }   \\\n        _base value;                                                           \\\n        using BaseType = _base;                                                \\\n    };\n\n///\n/// Use these types instead of uintXX_t in any mapping to have\n/// its yaml output formatted as hexadecimal.\n///\nLLVM_YAML_STRONG_TYPEDEF(uint8_t, Hex8)\nLLVM_YAML_STRONG_TYPEDEF(uint16_t, Hex16)\nLLVM_YAML_STRONG_TYPEDEF(uint32_t, Hex32)\nLLVM_YAML_STRONG_TYPEDEF(uint64_t, Hex64)\n\ntemplate<>\nstruct ScalarTraits<Hex8> {\n  static void output(const Hex8 &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, Hex8 &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<Hex16> {\n  static void output(const Hex16 &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, Hex16 &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<Hex32> {\n  static void output(const Hex32 &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, Hex32 &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<Hex64> {\n  static void output(const Hex64 &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, Hex64 &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate <> struct ScalarTraits<VersionTuple> {\n  static void output(const VersionTuple &Value, void *, llvm::raw_ostream &Out);\n  static StringRef input(StringRef, void *, VersionTuple &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\n// Define non-member operator>> so that Input can stream in a document list.\ntemplate <typename T>\ninline std::enable_if_t<has_DocumentListTraits<T>::value, Input &>\noperator>>(Input &yin, T &docList) {\n  int i = 0;\n  EmptyContext Ctx;\n  while ( yin.setCurrentDocument() ) {\n    yamlize(yin, DocumentListTraits<T>::element(yin, docList, i), true, Ctx);\n    if ( yin.error() )\n      return yin;\n    yin.nextDocument();\n    ++i;\n  }\n  return yin;\n}\n\n// Define non-member operator>> so that Input can stream in a map as a document.\ntemplate <typename T>\ninline std::enable_if_t<has_MappingTraits<T, EmptyContext>::value, Input &>\noperator>>(Input &yin, T &docMap) {\n  EmptyContext Ctx;\n  yin.setCurrentDocument();\n  yamlize(yin, docMap, true, Ctx);\n  return yin;\n}\n\n// Define non-member operator>> so that Input can stream in a sequence as\n// a document.\ntemplate <typename T>\ninline std::enable_if_t<has_SequenceTraits<T>::value, Input &>\noperator>>(Input &yin, T &docSeq) {\n  EmptyContext Ctx;\n  if (yin.setCurrentDocument())\n    yamlize(yin, docSeq, true, Ctx);\n  return yin;\n}\n\n// Define non-member operator>> so that Input can stream in a block scalar.\ntemplate <typename T>\ninline std::enable_if_t<has_BlockScalarTraits<T>::value, Input &>\noperator>>(Input &In, T &Val) {\n  EmptyContext Ctx;\n  if (In.setCurrentDocument())\n    yamlize(In, Val, true, Ctx);\n  return In;\n}\n\n// Define non-member operator>> so that Input can stream in a string map.\ntemplate <typename T>\ninline std::enable_if_t<has_CustomMappingTraits<T>::value, Input &>\noperator>>(Input &In, T &Val) {\n  EmptyContext Ctx;\n  if (In.setCurrentDocument())\n    yamlize(In, Val, true, Ctx);\n  return In;\n}\n\n// Define non-member operator>> so that Input can stream in a polymorphic type.\ntemplate <typename T>\ninline std::enable_if_t<has_PolymorphicTraits<T>::value, Input &>\noperator>>(Input &In, T &Val) {\n  EmptyContext Ctx;\n  if (In.setCurrentDocument())\n    yamlize(In, Val, true, Ctx);\n  return In;\n}\n\n// Provide better error message about types missing a trait specialization\ntemplate <typename T>\ninline std::enable_if_t<missingTraits<T, EmptyContext>::value, Input &>\noperator>>(Input &yin, T &docSeq) {\n  char missing_yaml_trait_for_type[sizeof(MissingTrait<T>)];\n  return yin;\n}\n\n// Define non-member operator<< so that Output can stream out document list.\ntemplate <typename T>\ninline std::enable_if_t<has_DocumentListTraits<T>::value, Output &>\noperator<<(Output &yout, T &docList) {\n  EmptyContext Ctx;\n  yout.beginDocuments();\n  const size_t count = DocumentListTraits<T>::size(yout, docList);\n  for(size_t i=0; i < count; ++i) {\n    if ( yout.preflightDocument(i) ) {\n      yamlize(yout, DocumentListTraits<T>::element(yout, docList, i), true,\n              Ctx);\n      yout.postflightDocument();\n    }\n  }\n  yout.endDocuments();\n  return yout;\n}\n\n// Define non-member operator<< so that Output can stream out a map.\ntemplate <typename T>\ninline std::enable_if_t<has_MappingTraits<T, EmptyContext>::value, Output &>\noperator<<(Output &yout, T &map) {\n  EmptyContext Ctx;\n  yout.beginDocuments();\n  if ( yout.preflightDocument(0) ) {\n    yamlize(yout, map, true, Ctx);\n    yout.postflightDocument();\n  }\n  yout.endDocuments();\n  return yout;\n}\n\n// Define non-member operator<< so that Output can stream out a sequence.\ntemplate <typename T>\ninline std::enable_if_t<has_SequenceTraits<T>::value, Output &>\noperator<<(Output &yout, T &seq) {\n  EmptyContext Ctx;\n  yout.beginDocuments();\n  if ( yout.preflightDocument(0) ) {\n    yamlize(yout, seq, true, Ctx);\n    yout.postflightDocument();\n  }\n  yout.endDocuments();\n  return yout;\n}\n\n// Define non-member operator<< so that Output can stream out a block scalar.\ntemplate <typename T>\ninline std::enable_if_t<has_BlockScalarTraits<T>::value, Output &>\noperator<<(Output &Out, T &Val) {\n  EmptyContext Ctx;\n  Out.beginDocuments();\n  if (Out.preflightDocument(0)) {\n    yamlize(Out, Val, true, Ctx);\n    Out.postflightDocument();\n  }\n  Out.endDocuments();\n  return Out;\n}\n\n// Define non-member operator<< so that Output can stream out a string map.\ntemplate <typename T>\ninline std::enable_if_t<has_CustomMappingTraits<T>::value, Output &>\noperator<<(Output &Out, T &Val) {\n  EmptyContext Ctx;\n  Out.beginDocuments();\n  if (Out.preflightDocument(0)) {\n    yamlize(Out, Val, true, Ctx);\n    Out.postflightDocument();\n  }\n  Out.endDocuments();\n  return Out;\n}\n\n// Define non-member operator<< so that Output can stream out a polymorphic\n// type.\ntemplate <typename T>\ninline std::enable_if_t<has_PolymorphicTraits<T>::value, Output &>\noperator<<(Output &Out, T &Val) {\n  EmptyContext Ctx;\n  Out.beginDocuments();\n  if (Out.preflightDocument(0)) {\n    // FIXME: The parser does not support explicit documents terminated with a\n    // plain scalar; the end-marker is included as part of the scalar token.\n    assert(PolymorphicTraits<T>::getKind(Val) != NodeKind::Scalar && \"plain scalar documents are not supported\");\n    yamlize(Out, Val, true, Ctx);\n    Out.postflightDocument();\n  }\n  Out.endDocuments();\n  return Out;\n}\n\n// Provide better error message about types missing a trait specialization\ntemplate <typename T>\ninline std::enable_if_t<missingTraits<T, EmptyContext>::value, Output &>\noperator<<(Output &yout, T &seq) {\n  char missing_yaml_trait_for_type[sizeof(MissingTrait<T>)];\n  return yout;\n}\n\ntemplate <bool B> struct IsFlowSequenceBase {};\ntemplate <> struct IsFlowSequenceBase<true> { static const bool flow = true; };\n\ntemplate <typename T, bool Flow>\nstruct SequenceTraitsImpl : IsFlowSequenceBase<Flow> {\nprivate:\n  using type = typename T::value_type;\n\npublic:\n  static size_t size(IO &io, T &seq) { return seq.size(); }\n\n  static type &element(IO &io, T &seq, size_t index) {\n    if (index >= seq.size())\n      seq.resize(index + 1);\n    return seq[index];\n  }\n};\n\n// Simple helper to check an expression can be used as a bool-valued template\n// argument.\ntemplate <bool> struct CheckIsBool { static const bool value = true; };\n\n// If T has SequenceElementTraits, then vector<T> and SmallVector<T, N> have\n// SequenceTraits that do the obvious thing.\ntemplate <typename T>\nstruct SequenceTraits<\n    std::vector<T>,\n    std::enable_if_t<CheckIsBool<SequenceElementTraits<T>::flow>::value>>\n    : SequenceTraitsImpl<std::vector<T>, SequenceElementTraits<T>::flow> {};\ntemplate <typename T, unsigned N>\nstruct SequenceTraits<\n    SmallVector<T, N>,\n    std::enable_if_t<CheckIsBool<SequenceElementTraits<T>::flow>::value>>\n    : SequenceTraitsImpl<SmallVector<T, N>, SequenceElementTraits<T>::flow> {};\ntemplate <typename T>\nstruct SequenceTraits<\n    SmallVectorImpl<T>,\n    std::enable_if_t<CheckIsBool<SequenceElementTraits<T>::flow>::value>>\n    : SequenceTraitsImpl<SmallVectorImpl<T>, SequenceElementTraits<T>::flow> {};\n\n// Sequences of fundamental types use flow formatting.\ntemplate <typename T>\nstruct SequenceElementTraits<T,\n                             std::enable_if_t<std::is_fundamental<T>::value>> {\n  static const bool flow = true;\n};\n\n// Sequences of strings use block formatting.\ntemplate<> struct SequenceElementTraits<std::string> {\n  static const bool flow = false;\n};\ntemplate<> struct SequenceElementTraits<StringRef> {\n  static const bool flow = false;\n};\ntemplate<> struct SequenceElementTraits<std::pair<std::string, std::string>> {\n  static const bool flow = false;\n};\n\n/// Implementation of CustomMappingTraits for std::map<std::string, T>.\ntemplate <typename T> struct StdMapStringCustomMappingTraitsImpl {\n  using map_type = std::map<std::string, T>;\n\n  static void inputOne(IO &io, StringRef key, map_type &v) {\n    io.mapRequired(key.str().c_str(), v[std::string(key)]);\n  }\n\n  static void output(IO &io, map_type &v) {\n    for (auto &p : v)\n      io.mapRequired(p.first.c_str(), p.second);\n  }\n};\n\n} // end namespace yaml\n} // end namespace llvm\n\n#define LLVM_YAML_IS_SEQUENCE_VECTOR_IMPL(TYPE, FLOW)                          \\\n  namespace llvm {                                                             \\\n  namespace yaml {                                                             \\\n  static_assert(                                                               \\\n      !std::is_fundamental<TYPE>::value &&                                     \\\n      !std::is_same<TYPE, std::string>::value &&                               \\\n      !std::is_same<TYPE, llvm::StringRef>::value,                             \\\n      \"only use LLVM_YAML_IS_SEQUENCE_VECTOR for types you control\");          \\\n  template <> struct SequenceElementTraits<TYPE> {                             \\\n    static const bool flow = FLOW;                                             \\\n  };                                                                           \\\n  }                                                                            \\\n  }\n\n/// Utility for declaring that a std::vector of a particular type\n/// should be considered a YAML sequence.\n#define LLVM_YAML_IS_SEQUENCE_VECTOR(type)                                     \\\n  LLVM_YAML_IS_SEQUENCE_VECTOR_IMPL(type, false)\n\n/// Utility for declaring that a std::vector of a particular type\n/// should be considered a YAML flow sequence.\n#define LLVM_YAML_IS_FLOW_SEQUENCE_VECTOR(type)                                \\\n  LLVM_YAML_IS_SEQUENCE_VECTOR_IMPL(type, true)\n\n#define LLVM_YAML_DECLARE_MAPPING_TRAITS(Type)                                 \\\n  namespace llvm {                                                             \\\n  namespace yaml {                                                             \\\n  template <> struct MappingTraits<Type> {                                     \\\n    static void mapping(IO &IO, Type &Obj);                                    \\\n  };                                                                           \\\n  }                                                                            \\\n  }\n\n#define LLVM_YAML_DECLARE_ENUM_TRAITS(Type)                                    \\\n  namespace llvm {                                                             \\\n  namespace yaml {                                                             \\\n  template <> struct ScalarEnumerationTraits<Type> {                           \\\n    static void enumeration(IO &io, Type &Value);                              \\\n  };                                                                           \\\n  }                                                                            \\\n  }\n\n#define LLVM_YAML_DECLARE_BITSET_TRAITS(Type)                                  \\\n  namespace llvm {                                                             \\\n  namespace yaml {                                                             \\\n  template <> struct ScalarBitSetTraits<Type> {                                \\\n    static void bitset(IO &IO, Type &Options);                                 \\\n  };                                                                           \\\n  }                                                                            \\\n  }\n\n#define LLVM_YAML_DECLARE_SCALAR_TRAITS(Type, MustQuote)                       \\\n  namespace llvm {                                                             \\\n  namespace yaml {                                                             \\\n  template <> struct ScalarTraits<Type> {                                      \\\n    static void output(const Type &Value, void *ctx, raw_ostream &Out);        \\\n    static StringRef input(StringRef Scalar, void *ctxt, Type &Value);         \\\n    static QuotingType mustQuote(StringRef) { return MustQuote; }              \\\n  };                                                                           \\\n  }                                                                            \\\n  }\n\n/// Utility for declaring that a std::vector of a particular type\n/// should be considered a YAML document list.\n#define LLVM_YAML_IS_DOCUMENT_LIST_VECTOR(_type)                               \\\n  namespace llvm {                                                             \\\n  namespace yaml {                                                             \\\n  template <unsigned N>                                                        \\\n  struct DocumentListTraits<SmallVector<_type, N>>                             \\\n      : public SequenceTraitsImpl<SmallVector<_type, N>, false> {};            \\\n  template <>                                                                  \\\n  struct DocumentListTraits<std::vector<_type>>                                \\\n      : public SequenceTraitsImpl<std::vector<_type>, false> {};               \\\n  }                                                                            \\\n  }\n\n/// Utility for declaring that std::map<std::string, _type> should be considered\n/// a YAML map.\n#define LLVM_YAML_IS_STRING_MAP(_type)                                         \\\n  namespace llvm {                                                             \\\n  namespace yaml {                                                             \\\n  template <>                                                                  \\\n  struct CustomMappingTraits<std::map<std::string, _type>>                     \\\n      : public StdMapStringCustomMappingTraitsImpl<_type> {};                  \\\n  }                                                                            \\\n  }\n\nLLVM_YAML_IS_FLOW_SEQUENCE_VECTOR(llvm::yaml::Hex64)\nLLVM_YAML_IS_FLOW_SEQUENCE_VECTOR(llvm::yaml::Hex32)\nLLVM_YAML_IS_FLOW_SEQUENCE_VECTOR(llvm::yaml::Hex16)\nLLVM_YAML_IS_FLOW_SEQUENCE_VECTOR(llvm::yaml::Hex8)\n\n#endif // LLVM_SUPPORT_YAMLTRAITS_H\n"}, "20": {"id": 20, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Iterable.h", "content": "//===-- Iterable.h ----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_ITERABLE_H\n#define LLDB_UTILITY_ITERABLE_H\n\n#include <utility>\n\n\nnamespace lldb_private {\n\ntemplate <typename I, typename E> E map_adapter(I &iter) {\n  return iter->second;\n}\n\ntemplate <typename I, typename E> E vector_adapter(I &iter) { return *iter; }\n\ntemplate <typename I, typename E> E list_adapter(I &iter) { return *iter; }\n\ntemplate <typename C, typename E, E (*A)(typename C::const_iterator &)>\nclass AdaptedConstIterator {\npublic:\n  typedef typename C::const_iterator BackingIterator;\n\n  // Wrapping constructor\n  AdaptedConstIterator(BackingIterator backing_iterator)\n      : m_iter(backing_iterator) {}\n\n  // Default-constructible\n  AdaptedConstIterator() : m_iter() {}\n\n  // Copy-constructible\n  AdaptedConstIterator(const AdaptedConstIterator &rhs) : m_iter(rhs.m_iter) {}\n\n  // Copy-assignable\n  AdaptedConstIterator &operator=(const AdaptedConstIterator &rhs) {\n    m_iter = rhs.m_iter;\n    return *this;\n  }\n\n  // Destructible\n  ~AdaptedConstIterator() = default;\n\n  // Comparable\n  bool operator==(const AdaptedConstIterator &rhs) {\n    return m_iter == rhs.m_iter;\n  }\n\n  bool operator!=(const AdaptedConstIterator &rhs) {\n    return m_iter != rhs.m_iter;\n  }\n\n  // Rvalue dereferenceable\n  E operator*() { return (*A)(m_iter); }\n\n  E operator->() { return (*A)(m_iter); }\n\n  // Offset dereferenceable\n  E operator[](typename BackingIterator::difference_type offset) {\n    return AdaptedConstIterator(m_iter + offset);\n  }\n\n  // Incrementable\n  AdaptedConstIterator &operator++() {\n    m_iter++;\n    return *this;\n  }\n\n  // Decrementable\n  AdaptedConstIterator &operator--() {\n    m_iter--;\n    return *this;\n  }\n\n  // Compound assignment\n  AdaptedConstIterator &\n  operator+=(typename BackingIterator::difference_type offset) {\n    m_iter += offset;\n    return *this;\n  }\n\n  AdaptedConstIterator &\n  operator-=(typename BackingIterator::difference_type offset) {\n    m_iter -= offset;\n    return *this;\n  }\n\n  // Arithmetic\n  AdaptedConstIterator\n  operator+(typename BackingIterator::difference_type offset) {\n    return AdaptedConstIterator(m_iter + offset);\n  }\n\n  AdaptedConstIterator\n  operator-(typename BackingIterator::difference_type offset) {\n    return AdaptedConstIterator(m_iter - offset);\n  }\n\n  // Comparable\n  bool operator<(AdaptedConstIterator &rhs) { return m_iter < rhs.m_iter; }\n\n  bool operator<=(AdaptedConstIterator &rhs) { return m_iter <= rhs.m_iter; }\n\n  bool operator>(AdaptedConstIterator &rhs) { return m_iter > rhs.m_iter; }\n\n  bool operator>=(AdaptedConstIterator &rhs) { return m_iter >= rhs.m_iter; }\n\n  template <typename C1, typename E1, E1 (*A1)(typename C1::const_iterator &)>\n  friend AdaptedConstIterator<C1, E1, A1>\n  operator+(typename C1::const_iterator::difference_type,\n            AdaptedConstIterator<C1, E1, A1> &);\n\n  template <typename C1, typename E1, E1 (*A1)(typename C1::const_iterator &)>\n  friend typename C1::const_iterator::difference_type\n  operator-(AdaptedConstIterator<C1, E1, A1> &,\n            AdaptedConstIterator<C1, E1, A1> &);\n\n  template <typename C1, typename E1, E1 (*A1)(typename C1::const_iterator &)>\n  friend void swap(AdaptedConstIterator<C1, E1, A1> &,\n                   AdaptedConstIterator<C1, E1, A1> &);\n\nprivate:\n  BackingIterator m_iter;\n};\n\ntemplate <typename C, typename E, E (*A)(typename C::const_iterator &)>\nAdaptedConstIterator<C, E, A> operator+(\n    typename AdaptedConstIterator<C, E, A>::BackingIterator::difference_type\n        offset,\n    AdaptedConstIterator<C, E, A> &rhs) {\n  return rhs.operator+(offset);\n}\n\ntemplate <typename C, typename E, E (*A)(typename C::const_iterator &)>\ntypename AdaptedConstIterator<C, E, A>::BackingIterator::difference_type\noperator-(AdaptedConstIterator<C, E, A> &lhs,\n          AdaptedConstIterator<C, E, A> &rhs) {\n  return (lhs.m_iter - rhs.m_iter);\n}\n\ntemplate <typename C, typename E, E (*A)(typename C::const_iterator &)>\nvoid swap(AdaptedConstIterator<C, E, A> &lhs,\n          AdaptedConstIterator<C, E, A> &rhs) {\n  std::swap(lhs.m_iter, rhs.m_iter);\n}\n\ntemplate <typename C, typename E, E (*A)(typename C::const_iterator &)>\nclass AdaptedIterable {\nprivate:\n  const C &m_container;\n\npublic:\n  AdaptedIterable(const C &container) : m_container(container) {}\n\n  AdaptedConstIterator<C, E, A> begin() {\n    return AdaptedConstIterator<C, E, A>(m_container.begin());\n  }\n\n  AdaptedConstIterator<C, E, A> end() {\n    return AdaptedConstIterator<C, E, A>(m_container.end());\n  }\n};\n\ntemplate <typename C, typename E, E (*A)(typename C::const_iterator &),\n          typename MutexType>\nclass LockingAdaptedIterable : public AdaptedIterable<C, E, A> {\npublic:\n  LockingAdaptedIterable(const C &container, MutexType &mutex)\n      : AdaptedIterable<C, E, A>(container), m_mutex(&mutex) {\n    m_mutex->lock();\n  }\n\n  LockingAdaptedIterable(LockingAdaptedIterable &&rhs)\n      : AdaptedIterable<C, E, A>(rhs), m_mutex(rhs.m_mutex) {\n    rhs.m_mutex = nullptr;\n  }\n\n  ~LockingAdaptedIterable() {\n    if (m_mutex)\n      m_mutex->unlock();\n  }\n\nprivate:\n  MutexType *m_mutex = nullptr;\n\n  LockingAdaptedIterable(const LockingAdaptedIterable &) = delete;\n  LockingAdaptedIterable &operator=(const LockingAdaptedIterable &) = delete;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_UTILITY_ITERABLE_H\n"}, "21": {"id": 21, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/RangeMap.h", "content": "//===-- RangeMap.h ----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_RANGEMAP_H\n#define LLDB_UTILITY_RANGEMAP_H\n\n#include <algorithm>\n#include <vector>\n\n#include \"llvm/ADT/SmallVector.h\"\n\n#include \"lldb/lldb-private.h\"\n\n// Uncomment to make sure all Range objects are sorted when needed\n//#define ASSERT_RANGEMAP_ARE_SORTED\n\nnamespace lldb_private {\n\n// Templatized classes for dealing with generic ranges and also collections of\n// ranges, or collections of ranges that have associated data.\n\n// A simple range class where you get to define the type of the range\n// base \"B\", and the type used for the range byte size \"S\".\ntemplate <typename B, typename S> struct Range {\n  typedef B BaseType;\n  typedef S SizeType;\n\n  BaseType base;\n  SizeType size;\n\n  Range() : base(0), size(0) {}\n\n  Range(BaseType b, SizeType s) : base(b), size(s) {}\n\n  void Clear(BaseType b = 0) {\n    base = b;\n    size = 0;\n  }\n\n  // Set the start value for the range, and keep the same size\n  BaseType GetRangeBase() const { return base; }\n\n  void SetRangeBase(BaseType b) { base = b; }\n\n  void Slide(BaseType slide) { base += slide; }\n\n  bool Union(const Range &rhs) {\n    if (DoesAdjoinOrIntersect(rhs)) {\n      auto new_end = std::max<BaseType>(GetRangeEnd(), rhs.GetRangeEnd());\n      base = std::min<BaseType>(base, rhs.base);\n      size = new_end - base;\n      return true;\n    }\n    return false;\n  }\n\n  BaseType GetRangeEnd() const { return base + size; }\n\n  void SetRangeEnd(BaseType end) {\n    if (end > base)\n      size = end - base;\n    else\n      size = 0;\n  }\n\n  SizeType GetByteSize() const { return size; }\n\n  void SetByteSize(SizeType s) { size = s; }\n\n  bool IsValid() const { return size > 0; }\n\n  bool Contains(BaseType r) const {\n    return (GetRangeBase() <= r) && (r < GetRangeEnd());\n  }\n\n  bool ContainsEndInclusive(BaseType r) const {\n    return (GetRangeBase() <= r) && (r <= GetRangeEnd());\n  }\n\n  bool Contains(const Range &range) const {\n    return Contains(range.GetRangeBase()) &&\n           ContainsEndInclusive(range.GetRangeEnd());\n  }\n\n  // Returns true if the two ranges adjoing or intersect\n  bool DoesAdjoinOrIntersect(const Range &rhs) const {\n    const BaseType lhs_base = this->GetRangeBase();\n    const BaseType rhs_base = rhs.GetRangeBase();\n    const BaseType lhs_end = this->GetRangeEnd();\n    const BaseType rhs_end = rhs.GetRangeEnd();\n    bool result = (lhs_base <= rhs_end) && (lhs_end >= rhs_base);\n    return result;\n  }\n\n  // Returns true if the two ranges intersect\n  bool DoesIntersect(const Range &rhs) const {\n    const BaseType lhs_base = this->GetRangeBase();\n    const BaseType rhs_base = rhs.GetRangeBase();\n    const BaseType lhs_end = this->GetRangeEnd();\n    const BaseType rhs_end = rhs.GetRangeEnd();\n    bool result = (lhs_base < rhs_end) && (lhs_end > rhs_base);\n    return result;\n  }\n\n  bool operator<(const Range &rhs) const {\n    if (base == rhs.base)\n      return size < rhs.size;\n    return base < rhs.base;\n  }\n\n  bool operator==(const Range &rhs) const {\n    return base == rhs.base && size == rhs.size;\n  }\n\n  bool operator!=(const Range &rhs) const {\n    return base != rhs.base || size != rhs.size;\n  }\n};\n\ntemplate <typename B, typename S, unsigned N = 0> class RangeVector {\npublic:\n  typedef B BaseType;\n  typedef S SizeType;\n  typedef Range<B, S> Entry;\n  typedef llvm::SmallVector<Entry, N> Collection;\n\n  RangeVector() = default;\n\n  ~RangeVector() = default;\n\n  void Append(const Entry &entry) { m_entries.push_back(entry); }\n\n  void Append(B base, S size) { m_entries.emplace_back(base, size); }\n\n  // Insert an item into a sorted list and optionally combine it with any\n  // adjacent blocks if requested.\n  void Insert(const Entry &entry, bool combine) {\n    if (m_entries.empty()) {\n      m_entries.push_back(entry);\n      return;\n    }\n    auto begin = m_entries.begin();\n    auto end = m_entries.end();\n    auto pos = std::lower_bound(begin, end, entry);\n    if (combine) {\n      if (pos != end && pos->Union(entry)) {\n        CombinePrevAndNext(pos);\n        return;\n      }\n      if (pos != begin) {\n        auto prev = pos - 1;\n        if (prev->Union(entry)) {\n          CombinePrevAndNext(prev);\n          return;\n        }\n      }\n    }\n    m_entries.insert(pos, entry);\n  }\n\n  bool RemoveEntryAtIndex(uint32_t idx) {\n    if (idx < m_entries.size()) {\n      m_entries.erase(m_entries.begin() + idx);\n      return true;\n    }\n    return false;\n  }\n\n  void Sort() {\n    if (m_entries.size() > 1)\n      std::stable_sort(m_entries.begin(), m_entries.end());\n  }\n\n#ifdef ASSERT_RANGEMAP_ARE_SORTED\n  bool IsSorted() const {\n    typename Collection::const_iterator pos, end, prev;\n    // First we determine if we can combine any of the Entry objects so we\n    // don't end up allocating and making a new collection for no reason\n    for (pos = m_entries.begin(), end = m_entries.end(), prev = end; pos != end;\n         prev = pos++) {\n      if (prev != end && *pos < *prev)\n        return false;\n    }\n    return true;\n  }\n#endif\n\n  void CombineConsecutiveRanges() {\n#ifdef ASSERT_RANGEMAP_ARE_SORTED\n    assert(IsSorted());\n#endif\n    auto first_intersect = std::adjacent_find(\n        m_entries.begin(), m_entries.end(), [](const Entry &a, const Entry &b) {\n          return a.DoesAdjoinOrIntersect(b);\n        });\n    if (first_intersect == m_entries.end())\n      return;\n\n    // We we can combine at least one entry, then we make a new collection and\n    // populate it accordingly, and then swap it into place.\n    auto pos = std::next(first_intersect);\n    Collection minimal_ranges(m_entries.begin(), pos);\n    for (; pos != m_entries.end(); ++pos) {\n      Entry &back = minimal_ranges.back();\n      if (back.DoesAdjoinOrIntersect(*pos))\n        back.SetRangeEnd(std::max(back.GetRangeEnd(), pos->GetRangeEnd()));\n      else\n        minimal_ranges.push_back(*pos);\n    }\n    m_entries.swap(minimal_ranges);\n  }\n\n  BaseType GetMinRangeBase(BaseType fail_value) const {\n#ifdef ASSERT_RANGEMAP_ARE_SORTED\n    assert(IsSorted());\n#endif\n    if (m_entries.empty())\n      return fail_value;\n    // m_entries must be sorted, so if we aren't empty, we grab the first\n    // range's base\n    return m_entries.front().GetRangeBase();\n  }\n\n  BaseType GetMaxRangeEnd(BaseType fail_value) const {\n#ifdef ASSERT_RANGEMAP_ARE_SORTED\n    assert(IsSorted());\n#endif\n    if (m_entries.empty())\n      return fail_value;\n    // m_entries must be sorted, so if we aren't empty, we grab the last\n    // range's end\n    return m_entries.back().GetRangeEnd();\n  }\n\n  void Slide(BaseType slide) {\n    typename Collection::iterator pos, end;\n    for (pos = m_entries.begin(), end = m_entries.end(); pos != end; ++pos)\n      pos->Slide(slide);\n  }\n\n  void Clear() { m_entries.clear(); }\n\n  void Reserve(typename Collection::size_type size) { m_entries.reserve(size); }\n\n  bool IsEmpty() const { return m_entries.empty(); }\n\n  size_t GetSize() const { return m_entries.size(); }\n\n  const Entry *GetEntryAtIndex(size_t i) const {\n    return ((i < m_entries.size()) ? &m_entries[i] : nullptr);\n  }\n\n  // Clients must ensure that \"i\" is a valid index prior to calling this\n  // function\n  Entry &GetEntryRef(size_t i) { return m_entries[i]; }\n  const Entry &GetEntryRef(size_t i) const { return m_entries[i]; }\n\n  Entry *Back() { return (m_entries.empty() ? nullptr : &m_entries.back()); }\n\n  const Entry *Back() const {\n    return (m_entries.empty() ? nullptr : &m_entries.back());\n  }\n\n  static bool BaseLessThan(const Entry &lhs, const Entry &rhs) {\n    return lhs.GetRangeBase() < rhs.GetRangeBase();\n  }\n\n  uint32_t FindEntryIndexThatContains(B addr) const {\n#ifdef ASSERT_RANGEMAP_ARE_SORTED\n    assert(IsSorted());\n#endif\n    if (!m_entries.empty()) {\n      Entry entry(addr, 1);\n      typename Collection::const_iterator begin = m_entries.begin();\n      typename Collection::const_iterator end = m_entries.end();\n      typename Collection::const_iterator pos =\n          std::lower_bound(begin, end, entry, BaseLessThan);\n\n      if (pos != end && pos->Contains(addr)) {\n        return std::distance(begin, pos);\n      } else if (pos != begin) {\n        --pos;\n        if (pos->Contains(addr))\n          return std::distance(begin, pos);\n      }\n    }\n    return UINT32_MAX;\n  }\n\n  const Entry *FindEntryThatContains(B addr) const {\n#ifdef ASSERT_RANGEMAP_ARE_SORTED\n    assert(IsSorted());\n#endif\n    if (!m_entries.empty()) {\n      Entry entry(addr, 1);\n      typename Collection::const_iterator begin = m_entries.begin();\n      typename Collection::const_iterator end = m_entries.end();\n      typename Collection::const_iterator pos =\n          std::lower_bound(begin, end, entry, BaseLessThan);\n\n      if (pos != end && pos->Contains(addr)) {\n        return &(*pos);\n      } else if (pos != begin) {\n        --pos;\n        if (pos->Contains(addr)) {\n          return &(*pos);\n        }\n      }\n    }\n    return nullptr;\n  }\n\n  const Entry *FindEntryThatContains(const Entry &range) const {\n#ifdef ASSERT_RANGEMAP_ARE_SORTED\n    assert(IsSorted());\n#endif\n    if (!m_entries.empty()) {\n      typename Collection::const_iterator begin = m_entries.begin();\n      typename Collection::const_iterator end = m_entries.end();\n      typename Collection::const_iterator pos =\n          std::lower_bound(begin, end, range, BaseLessThan);\n\n      if (pos != end && pos->Contains(range)) {\n        return &(*pos);\n      } else if (pos != begin) {\n        --pos;\n        if (pos->Contains(range)) {\n          return &(*pos);\n        }\n      }\n    }\n    return nullptr;\n  }\n\n  using const_iterator = typename Collection::const_iterator;\n  const_iterator begin() const { return m_entries.begin(); }\n  const_iterator end() const { return m_entries.end(); }\n\nprotected:\n  void CombinePrevAndNext(typename Collection::iterator pos) {\n    // Check if the prev or next entries in case they need to be unioned with\n    // the entry pointed to by \"pos\".\n    if (pos != m_entries.begin()) {\n      auto prev = pos - 1;\n      if (prev->Union(*pos))\n        m_entries.erase(pos);\n      pos = prev;\n    }\n\n    auto end = m_entries.end();\n    if (pos != end) {\n      auto next = pos + 1;\n      if (next != end) {\n        if (pos->Union(*next))\n          m_entries.erase(next);\n      }\n    }\n    return;\n  }\n\n  Collection m_entries;\n};\n\n// A simple range  with data class where you get to define the type of\n// the range base \"B\", the type used for the range byte size \"S\", and the type\n// for the associated data \"T\".\ntemplate <typename B, typename S, typename T>\nstruct RangeData : public Range<B, S> {\n  typedef T DataType;\n\n  DataType data;\n\n  RangeData() : Range<B, S>(), data() {}\n\n  RangeData(B base, S size) : Range<B, S>(base, size), data() {}\n\n  RangeData(B base, S size, DataType d) : Range<B, S>(base, size), data(d) {}\n};\n\n// We can treat the vector as a flattened Binary Search Tree, augmenting it\n// with upper bounds (max of range endpoints) for every index allows us to\n// query for range containment quicker.\ntemplate <typename B, typename S, typename T>\nstruct AugmentedRangeData : public RangeData<B, S, T> {\n  B upper_bound;\n\n  AugmentedRangeData(const RangeData<B, S, T> &rd)\n      : RangeData<B, S, T>(rd), upper_bound() {}\n};\n\ntemplate <typename B, typename S, typename T, unsigned N = 0,\n          class Compare = std::less<T>>\nclass RangeDataVector {\npublic:\n  typedef lldb_private::Range<B, S> Range;\n  typedef RangeData<B, S, T> Entry;\n  typedef AugmentedRangeData<B, S, T> AugmentedEntry;\n  typedef llvm::SmallVector<AugmentedEntry, N> Collection;\n\n  RangeDataVector(Compare compare = Compare()) : m_compare(compare) {}\n\n  ~RangeDataVector() = default;\n\n  void Append(const Entry &entry) { m_entries.emplace_back(entry); }\n\n  void Sort() {\n    if (m_entries.size() > 1)\n      std::stable_sort(m_entries.begin(), m_entries.end(),\n                       [&compare = m_compare](const Entry &a, const Entry &b) {\n                         if (a.base != b.base)\n                           return a.base < b.base;\n                         if (a.size != b.size)\n                           return a.size < b.size;\n                         return compare(a.data, b.data);\n                       });\n    if (!m_entries.empty())\n      ComputeUpperBounds(0, m_entries.size());\n  }\n\n#ifdef ASSERT_RANGEMAP_ARE_SORTED\n  bool IsSorted() const {\n    typename Collection::const_iterator pos, end, prev;\n    for (pos = m_entries.begin(), end = m_entries.end(), prev = end; pos != end;\n         prev = pos++) {\n      if (prev != end && *pos < *prev)\n        return false;\n    }\n    return true;\n  }\n#endif\n\n  void CombineConsecutiveEntriesWithEqualData() {\n#ifdef ASSERT_RANGEMAP_ARE_SORTED\n    assert(IsSorted());\n#endif\n    typename Collection::iterator pos;\n    typename Collection::iterator end;\n    typename Collection::iterator prev;\n    bool can_combine = false;\n    // First we determine if we can combine any of the Entry objects so we\n    // don't end up allocating and making a new collection for no reason\n    for (pos = m_entries.begin(), end = m_entries.end(), prev = end; pos != end;\n         prev = pos++) {\n      if (prev != end && prev->data == pos->data) {\n        can_combine = true;\n        break;\n      }\n    }\n\n    // We we can combine at least one entry, then we make a new collection and\n    // populate it accordingly, and then swap it into place.\n    if (can_combine) {\n      Collection minimal_ranges;\n      for (pos = m_entries.begin(), end = m_entries.end(), prev = end;\n           pos != end; prev = pos++) {\n        if (prev != end && prev->data == pos->data)\n          minimal_ranges.back().SetRangeEnd(pos->GetRangeEnd());\n        else\n          minimal_ranges.push_back(*pos);\n      }\n      // Use the swap technique in case our new vector is much smaller. We must\n      // swap when using the STL because std::vector objects never release or\n      // reduce the memory once it has been allocated/reserved.\n      m_entries.swap(minimal_ranges);\n    }\n  }\n\n  void Clear() { m_entries.clear(); }\n\n  bool IsEmpty() const { return m_entries.empty(); }\n\n  size_t GetSize() const { return m_entries.size(); }\n\n  const Entry *GetEntryAtIndex(size_t i) const {\n    return ((i < m_entries.size()) ? &m_entries[i] : nullptr);\n  }\n\n  Entry *GetMutableEntryAtIndex(size_t i) {\n    return ((i < m_entries.size()) ? &m_entries[i] : nullptr);\n  }\n\n  // Clients must ensure that \"i\" is a valid index prior to calling this\n  // function\n  Entry &GetEntryRef(size_t i) { return m_entries[i]; }\n  const Entry &GetEntryRef(size_t i) const { return m_entries[i]; }\n\n  static bool BaseLessThan(const Entry &lhs, const Entry &rhs) {\n    return lhs.GetRangeBase() < rhs.GetRangeBase();\n  }\n\n  uint32_t FindEntryIndexThatContains(B addr) const {\n    const AugmentedEntry *entry =\n        static_cast<const AugmentedEntry *>(FindEntryThatContains(addr));\n    if (entry)\n      return std::distance(m_entries.begin(), entry);\n    return UINT32_MAX;\n  }\n\n  uint32_t FindEntryIndexesThatContain(B addr, std::vector<uint32_t> &indexes) {\n#ifdef ASSERT_RANGEMAP_ARE_SORTED\n    assert(IsSorted());\n#endif\n    if (!m_entries.empty())\n      FindEntryIndexesThatContain(addr, 0, m_entries.size(), indexes);\n\n    return indexes.size();\n  }\n\n  Entry *FindEntryThatContains(B addr) {\n    return const_cast<Entry *>(\n        static_cast<const RangeDataVector *>(this)->FindEntryThatContains(\n            addr));\n  }\n\n  const Entry *FindEntryThatContains(B addr) const {\n    return FindEntryThatContains(Entry(addr, 1));\n  }\n\n  const Entry *FindEntryThatContains(const Entry &range) const {\n#ifdef ASSERT_RANGEMAP_ARE_SORTED\n    assert(IsSorted());\n#endif\n    if (!m_entries.empty()) {\n      typename Collection::const_iterator begin = m_entries.begin();\n      typename Collection::const_iterator end = m_entries.end();\n      typename Collection::const_iterator pos =\n          std::lower_bound(begin, end, range, BaseLessThan);\n\n      while (pos != begin && pos[-1].Contains(range))\n        --pos;\n\n      if (pos != end && pos->Contains(range))\n        return &(*pos);\n    }\n    return nullptr;\n  }\n\n  const Entry *FindEntryStartsAt(B addr) const {\n#ifdef ASSERT_RANGEMAP_ARE_SORTED\n    assert(IsSorted());\n#endif\n    if (!m_entries.empty()) {\n      auto begin = m_entries.begin(), end = m_entries.end();\n      auto pos = std::lower_bound(begin, end, Entry(addr, 1), BaseLessThan);\n      if (pos != end && pos->base == addr)\n        return &(*pos);\n    }\n    return nullptr;\n  }\n\n  // This method will return the entry that contains the given address, or the\n  // entry following that address.  If you give it an address of 0 and the\n  // first entry starts at address 0x100, you will get the entry at 0x100.\n  //\n  // For most uses, FindEntryThatContains is the correct one to use, this is a\n  // less commonly needed behavior.  It was added for core file memory regions,\n  // where we want to present a gap in the memory regions as a distinct region,\n  // so we need to know the start address of the next memory section that\n  // exists.\n  const Entry *FindEntryThatContainsOrFollows(B addr) const {\n#ifdef ASSERT_RANGEMAP_ARE_SORTED\n    assert(IsSorted());\n#endif\n    if (!m_entries.empty()) {\n      typename Collection::const_iterator begin = m_entries.begin();\n      typename Collection::const_iterator end = m_entries.end();\n      typename Collection::const_iterator pos =\n          std::lower_bound(m_entries.begin(), end, addr,\n                           [](const Entry &lhs, B rhs_base) -> bool {\n                             return lhs.GetRangeEnd() <= rhs_base;\n                           });\n\n      while (pos != begin && pos[-1].Contains(addr))\n        --pos;\n\n      if (pos != end)\n        return &(*pos);\n    }\n    return nullptr;\n  }\n\n  Entry *Back() { return (m_entries.empty() ? nullptr : &m_entries.back()); }\n\n  const Entry *Back() const {\n    return (m_entries.empty() ? nullptr : &m_entries.back());\n  }\n\nprotected:\n  Collection m_entries;\n  Compare m_compare;\n\nprivate:\n  // Compute extra information needed for search\n  B ComputeUpperBounds(size_t lo, size_t hi) {\n    size_t mid = (lo + hi) / 2;\n    AugmentedEntry &entry = m_entries[mid];\n\n    entry.upper_bound = entry.base + entry.size;\n\n    if (lo < mid)\n      entry.upper_bound =\n          std::max(entry.upper_bound, ComputeUpperBounds(lo, mid));\n\n    if (mid + 1 < hi)\n      entry.upper_bound =\n          std::max(entry.upper_bound, ComputeUpperBounds(mid + 1, hi));\n\n    return entry.upper_bound;\n  }\n\n  // This is based on the augmented tree implementation found at\n  // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n  void FindEntryIndexesThatContain(B addr, size_t lo, size_t hi,\n                                   std::vector<uint32_t> &indexes) {\n    size_t mid = (lo + hi) / 2;\n    const AugmentedEntry &entry = m_entries[mid];\n\n    // addr is greater than the rightmost point of any interval below mid\n    // so there are cannot be any matches.\n    if (addr > entry.upper_bound)\n      return;\n\n    // Recursively search left subtree\n    if (lo < mid)\n      FindEntryIndexesThatContain(addr, lo, mid, indexes);\n\n    // If addr is smaller than the start of the current interval it\n    // cannot contain it nor can any of its right subtree.\n    if (addr < entry.base)\n      return;\n\n    if (entry.Contains(addr))\n      indexes.push_back(entry.data);\n\n    // Recursively search right subtree\n    if (mid + 1 < hi)\n      FindEntryIndexesThatContain(addr, mid + 1, hi, indexes);\n  }\n};\n\n// A simple range  with data class where you get to define the type of\n// the range base \"B\", the type used for the range byte size \"S\", and the type\n// for the associated data \"T\".\ntemplate <typename B, typename T> struct AddressData {\n  typedef B BaseType;\n  typedef T DataType;\n\n  BaseType addr;\n  DataType data;\n\n  AddressData() : addr(), data() {}\n\n  AddressData(B a, DataType d) : addr(a), data(d) {}\n\n  bool operator<(const AddressData &rhs) const {\n    if (this->addr == rhs.addr)\n      return this->data < rhs.data;\n    return this->addr < rhs.addr;\n  }\n\n  bool operator==(const AddressData &rhs) const {\n    return this->addr == rhs.addr && this->data == rhs.data;\n  }\n\n  bool operator!=(const AddressData &rhs) const {\n    return this->addr != rhs.addr || this->data == rhs.data;\n  }\n};\n\ntemplate <typename B, typename T, unsigned N> class AddressDataArray {\npublic:\n  typedef AddressData<B, T> Entry;\n  typedef llvm::SmallVector<Entry, N> Collection;\n\n  AddressDataArray() = default;\n\n  ~AddressDataArray() = default;\n\n  void Append(const Entry &entry) { m_entries.push_back(entry); }\n\n  void Sort() {\n    if (m_entries.size() > 1)\n      std::stable_sort(m_entries.begin(), m_entries.end());\n  }\n\n#ifdef ASSERT_RANGEMAP_ARE_SORTED\n  bool IsSorted() const {\n    typename Collection::const_iterator pos, end, prev;\n    // First we determine if we can combine any of the Entry objects so we\n    // don't end up allocating and making a new collection for no reason\n    for (pos = m_entries.begin(), end = m_entries.end(), prev = end; pos != end;\n         prev = pos++) {\n      if (prev != end && *pos < *prev)\n        return false;\n    }\n    return true;\n  }\n#endif\n\n  void Clear() { m_entries.clear(); }\n\n  bool IsEmpty() const { return m_entries.empty(); }\n\n  size_t GetSize() const { return m_entries.size(); }\n\n  const Entry *GetEntryAtIndex(size_t i) const {\n    return ((i < m_entries.size()) ? &m_entries[i] : nullptr);\n  }\n\n  // Clients must ensure that \"i\" is a valid index prior to calling this\n  // function\n  const Entry &GetEntryRef(size_t i) const { return m_entries[i]; }\n\n  static bool BaseLessThan(const Entry &lhs, const Entry &rhs) {\n    return lhs.addr < rhs.addr;\n  }\n\n  Entry *FindEntry(B addr, bool exact_match_only) {\n#ifdef ASSERT_RANGEMAP_ARE_SORTED\n    assert(IsSorted());\n#endif\n    if (!m_entries.empty()) {\n      Entry entry;\n      entry.addr = addr;\n      typename Collection::iterator begin = m_entries.begin();\n      typename Collection::iterator end = m_entries.end();\n      typename Collection::iterator pos =\n          std::lower_bound(begin, end, entry, BaseLessThan);\n\n      while (pos != begin && pos[-1].addr == addr)\n        --pos;\n\n      if (pos != end) {\n        if (pos->addr == addr || !exact_match_only)\n          return &(*pos);\n      }\n    }\n    return nullptr;\n  }\n\n  const Entry *FindNextEntry(const Entry *entry) {\n    if (entry >= &*m_entries.begin() && entry + 1 < &*m_entries.end())\n      return entry + 1;\n    return nullptr;\n  }\n\n  Entry *Back() { return (m_entries.empty() ? nullptr : &m_entries.back()); }\n\n  const Entry *Back() const {\n    return (m_entries.empty() ? nullptr : &m_entries.back());\n  }\n\nprotected:\n  Collection m_entries;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_UTILITY_RANGEMAP_H\n"}, "22": {"id": 22, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/RegularExpression.h", "content": "//===-- RegularExpression.h -------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_REGULAREXPRESSION_H\n#define LLDB_UTILITY_REGULAREXPRESSION_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/Regex.h\"\n\nnamespace lldb_private {\n\nclass RegularExpression {\npublic:\n  /// The default constructor that initializes the object state such that it\n  /// contains no compiled regular expression.\n  RegularExpression() = default;\n\n  /// Constructor for a regular expression.\n  ///\n  /// Compile a regular expression using the supplied regular expression text.\n  /// The compiled regular expression lives in this object so that it can be\n  /// readily used for regular expression matches. Execute() can be called\n  /// after the regular expression is compiled.\n  ///\n  /// \\param[in] string\n  ///     An llvm::StringRef that represents the regular expression to compile.\n  //      String is not referenced anymore after the object is constructed.\n  explicit RegularExpression(llvm::StringRef string);\n\n  ~RegularExpression() = default;\n\n  RegularExpression(const RegularExpression &rhs);\n  RegularExpression(RegularExpression &&rhs) = default;\n\n  RegularExpression &operator=(RegularExpression &&rhs) = default;\n  RegularExpression &operator=(const RegularExpression &rhs) = default;\n\n  /// Execute a regular expression match using the compiled regular expression\n  /// that is already in this object against the given \\a string. If any parens\n  /// are used for regular expression matches.\n  ///\n  /// \\param[in] string\n  ///     The string to match against the compile regular expression.\n  ///\n  /// \\param[out] matches\n  ///     A pointer to a SmallVector to hold the matches.\n  ///\n  /// \\return\n  ///     true if \\a string matches the compiled regular expression, false\n  ///     otherwise incl. the case regular exression failed to compile.\n  bool Execute(llvm::StringRef string,\n               llvm::SmallVectorImpl<llvm::StringRef> *matches = nullptr) const;\n\n  /// Access the regular expression text.\n  ///\n  /// \\return\n  ///     The NULL terminated C string that was used to compile the\n  ///     current regular expression\n  llvm::StringRef GetText() const;\n\n  /// Test if this object contains a valid regular expression.\n  ///\n  /// \\return\n  ///     true if the regular expression compiled and is ready for execution,\n  ///     false otherwise.\n  bool IsValid() const;\n\n  /// Return an error if the regular expression failed to compile.\n  ///\n  /// \\return\n  ///     A string error if the regular expression failed to compile, success\n  ///     otherwise.\n  llvm::Error GetError() const;\n\n  bool operator==(const RegularExpression &rhs) const {\n    return GetText() == rhs.GetText();\n  }\n\nprivate:\n  /// A copy of the original regular expression text.\n  std::string m_regex_text;\n  /// The compiled regular expression.\n  mutable llvm::Regex m_regex;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_UTILITY_REGULAREXPRESSION_H\n"}, "23": {"id": 23, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Scalar.h", "content": "//===-- Scalar.h ------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_SCALAR_H\n#define LLDB_UTILITY_SCALAR_H\n\n#include \"lldb/Utility/LLDBAssert.h\"\n#include \"lldb/Utility/Status.h\"\n#include \"lldb/lldb-enumerations.h\"\n#include \"lldb/lldb-private-types.h\"\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include <cstddef>\n#include <cstdint>\n#include <utility>\n\nnamespace lldb_private {\n\nclass DataExtractor;\nclass Stream;\n\n#define NUM_OF_WORDS_INT128 2\n#define BITWIDTH_INT128 128\n\n// A class designed to hold onto values and their corresponding types.\n// Operators are defined and Scalar objects will correctly promote their types\n// and values before performing these operations. Type promotion currently\n// follows the ANSI C type promotion rules.\nclass Scalar {\n  template<typename T>\n  static llvm::APSInt MakeAPSInt(T v) {\n    static_assert(std::is_integral<T>::value, \"\");\n    static_assert(sizeof(T) <= sizeof(uint64_t), \"Conversion loses precision!\");\n    return llvm::APSInt(\n        llvm::APInt(sizeof(T) * 8, uint64_t(v), std::is_signed<T>::value),\n        std::is_unsigned<T>::value);\n  }\n\npublic:\n  enum Type {\n    e_void = 0,\n    e_int,\n    e_float,\n  };\n\n  // Constructors and Destructors\n  Scalar() : m_type(e_void), m_float(0.0f) {}\n  Scalar(int v) : m_type(e_int), m_integer(MakeAPSInt(v)), m_float(0.0f) {}\n  Scalar(unsigned int v)\n      : m_type(e_int), m_integer(MakeAPSInt(v)), m_float(0.0f) {}\n  Scalar(long v) : m_type(e_int), m_integer(MakeAPSInt(v)), m_float(0.0f) {}\n  Scalar(unsigned long v)\n      : m_type(e_int), m_integer(MakeAPSInt(v)), m_float(0.0f) {}\n  Scalar(long long v)\n      : m_type(e_int), m_integer(MakeAPSInt(v)), m_float(0.0f) {}\n  Scalar(unsigned long long v)\n      : m_type(e_int), m_integer(MakeAPSInt(v)), m_float(0.0f) {}\n  Scalar(float v) : m_type(e_float), m_float(v) {}\n  Scalar(double v) : m_type(e_float), m_float(v) {}\n  Scalar(long double v) : m_type(e_float), m_float(double(v)) {\n    bool ignore;\n    m_float.convert(llvm::APFloat::x87DoubleExtended(),\n                    llvm::APFloat::rmNearestTiesToEven, &ignore);\n  }\n  Scalar(llvm::APInt v)\n      : m_type(e_int), m_integer(std::move(v), false), m_float(0.0f) {}\n  Scalar(llvm::APSInt v)\n      : m_type(e_int), m_integer(std::move(v)), m_float(0.0f) {}\n\n  bool SignExtend(uint32_t bit_pos);\n\n  bool ExtractBitfield(uint32_t bit_size, uint32_t bit_offset);\n\n  bool SetBit(uint32_t bit);\n\n  bool ClearBit(uint32_t bit);\n\n  /// Store the binary representation of this value into the given storage.\n  /// Exactly GetByteSize() bytes will be stored, and the buffer must be large\n  /// enough to hold this data.\n  void GetBytes(llvm::MutableArrayRef<uint8_t> storage) const;\n\n  size_t GetByteSize() const;\n\n  bool GetData(DataExtractor &data, size_t limit_byte_size = UINT32_MAX) const;\n\n  size_t GetAsMemoryData(void *dst, size_t dst_len,\n                         lldb::ByteOrder dst_byte_order, Status &error) const;\n\n  bool IsZero() const;\n\n  void Clear() {\n    m_type = e_void;\n    m_integer.clearAllBits();\n  }\n\n  const char *GetTypeAsCString() const { return GetValueTypeAsCString(m_type); }\n\n  void GetValue(Stream *s, bool show_type) const;\n\n  bool IsValid() const { return (m_type >= e_int) && (m_type <= e_float); }\n\n  /// Convert to an integer with \\p bits and the given signedness.\n  void TruncOrExtendTo(uint16_t bits, bool sign);\n\n  bool IntegralPromote(uint16_t bits, bool sign);\n  bool FloatPromote(const llvm::fltSemantics &semantics);\n\n  bool IsSigned() const;\n  bool MakeSigned();\n\n  bool MakeUnsigned();\n\n  static const char *GetValueTypeAsCString(Scalar::Type value_type);\n\n  // All operators can benefits from the implicit conversions that will happen\n  // automagically by the compiler, so no temporary objects will need to be\n  // created. As a result, we currently don't need a variety of overloaded set\n  // value accessors.\n  Scalar &operator+=(Scalar rhs);\n  Scalar &operator<<=(const Scalar &rhs); // Shift left\n  Scalar &operator>>=(const Scalar &rhs); // Shift right (arithmetic)\n  Scalar &operator&=(const Scalar &rhs);\n\n  // Shifts the current value to the right without maintaining the current sign\n  // of the value (if it is signed).\n  bool ShiftRightLogical(const Scalar &rhs); // Returns true on success\n\n  // Takes the absolute value of the current value if it is signed, else the\n  // value remains unchanged. Returns false if the contained value has a void\n  // type.\n  bool AbsoluteValue(); // Returns true on success\n  // Negates the current value (even for unsigned values). Returns false if the\n  // contained value has a void type.\n  bool UnaryNegate(); // Returns true on success\n  // Inverts all bits in the current value as long as it isn't void or a\n  // float/double/long double type. Returns false if the contained value has a\n  // void/float/double/long double type, else the value is inverted and true is\n  // returned.\n  bool OnesComplement(); // Returns true on success\n\n  // Access the type of the current value.\n  Scalar::Type GetType() const { return m_type; }\n\n  // Returns a casted value of the current contained data without modifying the\n  // current value. FAIL_VALUE will be returned if the type of the value is\n  // void or invalid.\n  int SInt(int fail_value = 0) const;\n\n  unsigned char UChar(unsigned char fail_value = 0) const;\n\n  signed char SChar(signed char fail_value = 0) const;\n\n  unsigned short UShort(unsigned short fail_value = 0) const;\n\n  short SShort(short fail_value = 0) const;\n\n  unsigned int UInt(unsigned int fail_value = 0) const;\n\n  long SLong(long fail_value = 0) const;\n\n  unsigned long ULong(unsigned long fail_value = 0) const;\n\n  long long SLongLong(long long fail_value = 0) const;\n\n  unsigned long long ULongLong(unsigned long long fail_value = 0) const;\n\n  llvm::APInt SInt128(const llvm::APInt &fail_value) const;\n\n  llvm::APInt UInt128(const llvm::APInt &fail_value) const;\n\n  float Float(float fail_value = 0.0f) const;\n\n  double Double(double fail_value = 0.0) const;\n\n  long double LongDouble(long double fail_value = 0.0) const;\n\n  Status SetValueFromCString(const char *s, lldb::Encoding encoding,\n                             size_t byte_size);\n\n  Status SetValueFromData(const DataExtractor &data, lldb::Encoding encoding,\n                          size_t byte_size);\n\nprotected:\n  Scalar::Type m_type;\n  llvm::APSInt m_integer;\n  llvm::APFloat m_float;\n\n  template <typename T> T GetAs(T fail_value) const;\n\n  static Type PromoteToMaxType(Scalar &lhs, Scalar &rhs);\n\n  using PromotionKey = std::tuple<Type, unsigned, bool>;\n  PromotionKey GetPromoKey() const;\n\n  static PromotionKey GetFloatPromoKey(const llvm::fltSemantics &semantics);\n\nprivate:\n  friend const Scalar operator+(const Scalar &lhs, const Scalar &rhs);\n  friend const Scalar operator-(Scalar lhs, Scalar rhs);\n  friend const Scalar operator/(Scalar lhs, Scalar rhs);\n  friend const Scalar operator*(Scalar lhs, Scalar rhs);\n  friend const Scalar operator&(Scalar lhs, Scalar rhs);\n  friend const Scalar operator|(Scalar lhs, Scalar rhs);\n  friend const Scalar operator%(Scalar lhs, Scalar rhs);\n  friend const Scalar operator^(Scalar lhs, Scalar rhs);\n  friend const Scalar operator<<(const Scalar &lhs, const Scalar &rhs);\n  friend const Scalar operator>>(const Scalar &lhs, const Scalar &rhs);\n  friend bool operator==(Scalar lhs, Scalar rhs);\n  friend bool operator!=(const Scalar &lhs, const Scalar &rhs);\n  friend bool operator<(Scalar lhs, Scalar rhs);\n  friend bool operator<=(const Scalar &lhs, const Scalar &rhs);\n  friend bool operator>(const Scalar &lhs, const Scalar &rhs);\n  friend bool operator>=(const Scalar &lhs, const Scalar &rhs);\n};\n\n// Split out the operators into a format where the compiler will be able to\n// implicitly convert numbers into Scalar objects.\n//\n// This allows code like:\n//      Scalar two(2);\n//      Scalar four = two * 2;\n//      Scalar eight = 2 * four;    // This would cause an error if the\n//                                  // operator* was implemented as a\n//                                  // member function.\n// SEE:\n//  Item 19 of \"Effective C++ Second Edition\" by Scott Meyers\n//  Differentiate among members functions, non-member functions, and\n//  friend functions\nconst Scalar operator+(const Scalar &lhs, const Scalar &rhs);\nconst Scalar operator-(Scalar lhs, Scalar rhs);\nconst Scalar operator/(Scalar lhs, Scalar rhs);\nconst Scalar operator*(Scalar lhs, Scalar rhs);\nconst Scalar operator&(Scalar lhs, Scalar rhs);\nconst Scalar operator|(Scalar lhs, Scalar rhs);\nconst Scalar operator%(Scalar lhs, Scalar rhs);\nconst Scalar operator^(Scalar lhs, Scalar rhs);\nconst Scalar operator<<(const Scalar &lhs, const Scalar &rhs);\nconst Scalar operator>>(const Scalar &lhs, const Scalar &rhs);\nbool operator==(Scalar lhs, Scalar rhs);\nbool operator!=(const Scalar &lhs, const Scalar &rhs);\nbool operator<(Scalar lhs, Scalar rhs);\nbool operator<=(const Scalar &lhs, const Scalar &rhs);\nbool operator>(const Scalar &lhs, const Scalar &rhs);\nbool operator>=(const Scalar &lhs, const Scalar &rhs);\n\nllvm::raw_ostream &operator<<(llvm::raw_ostream &os, const Scalar &scalar);\n\n} // namespace lldb_private\n\n#endif // LLDB_UTILITY_SCALAR_H\n"}, "24": {"id": 24, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/UUID.h", "content": "//===-- UUID.h --------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_UUID_H\n#define LLDB_UTILITY_UUID_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Endian.h\"\n#include <stddef.h>\n#include <stdint.h>\n#include <string>\n\nnamespace lldb_private {\n\n  class Stream;\n\nclass UUID {\npublic:\n  UUID() = default;\n\n  // Reference:\n  // https://crashpad.chromium.org/doxygen/structcrashpad_1_1CodeViewRecordPDB70.html\n  struct CvRecordPdb70 {\n    struct {\n      llvm::support::ulittle32_t Data1;\n      llvm::support::ulittle16_t Data2;\n      llvm::support::ulittle16_t Data3;\n      uint8_t Data4[8];\n    } Uuid;\n    llvm::support::ulittle32_t Age;\n    // char PDBFileName[];\n  };\n\n  /// Create a UUID from CvRecordPdb70.\n  static UUID fromCvRecord(CvRecordPdb70 debug_info);\n\n  /// Creates a UUID from the data pointed to by the bytes argument. No special\n  /// significance is attached to any of the values.\n  static UUID fromData(const void *bytes, uint32_t num_bytes) {\n    if (bytes)\n      return fromData({reinterpret_cast<const uint8_t *>(bytes), num_bytes});\n    return UUID();\n  }\n\n  /// Creates a uuid from the data pointed to by the bytes argument. No special\n  /// significance is attached to any of the values.\n  static UUID fromData(llvm::ArrayRef<uint8_t> bytes) { return UUID(bytes); }\n\n  /// Creates a UUID from the data pointed to by the bytes argument. Data\n  /// consisting purely of zero bytes is treated as an invalid UUID.\n  static UUID fromOptionalData(const void *bytes, uint32_t num_bytes) {\n    if (bytes)\n      return fromOptionalData(\n          {reinterpret_cast<const uint8_t *>(bytes), num_bytes});\n    return UUID();\n  }\n\n  /// Creates a UUID from the data pointed to by the bytes argument. Data\n  /// consisting purely of zero bytes is treated as an invalid UUID.\n  static UUID fromOptionalData(llvm::ArrayRef<uint8_t> bytes) {\n    if (llvm::all_of(bytes, [](uint8_t b) { return b == 0; }))\n      return UUID();\n    return UUID(bytes);\n  }\n\n  void Clear() { m_bytes.clear(); }\n\n  void Dump(Stream *s) const;\n\n  llvm::ArrayRef<uint8_t> GetBytes() const { return m_bytes; }\n\n  explicit operator bool() const { return IsValid(); }\n  bool IsValid() const { return !m_bytes.empty(); }\n\n  std::string GetAsString(llvm::StringRef separator = \"-\") const;\n\n  bool SetFromStringRef(llvm::StringRef str);\n\n  // Same as SetFromStringRef, but if the resultant UUID is all 0 bytes, set the\n  // UUID to invalid.\n  bool SetFromOptionalStringRef(llvm::StringRef str);\n\n  /// Decode as many UUID bytes as possible from the C string \\a cstr.\n  ///\n  /// \\param[in] str\n  ///     An llvm::StringRef that points at a UUID string value (no leading\n  ///     spaces). The string must contain only hex characters and optionally\n  ///     can contain the '-' sepearators.\n  ///\n  /// \\param[in] uuid_bytes\n  ///     A buffer of bytes that will contain a full or partially decoded UUID.\n  ///\n  /// \\return\n  ///     The original string, with all decoded bytes removed.\n  static llvm::StringRef\n  DecodeUUIDBytesFromString(llvm::StringRef str,\n                            llvm::SmallVectorImpl<uint8_t> &uuid_bytes);\n\nprivate:\n  UUID(llvm::ArrayRef<uint8_t> bytes) : m_bytes(bytes.begin(), bytes.end()) {}\n\n  // GNU ld generates 20-byte build-ids. Size chosen to avoid heap allocations\n  // for this case.\n  llvm::SmallVector<uint8_t, 20> m_bytes;\n\n  friend bool operator==(const UUID &LHS, const UUID &RHS) {\n    return LHS.m_bytes == RHS.m_bytes;\n  }\n  friend bool operator!=(const UUID &LHS, const UUID &RHS) {\n    return !(LHS == RHS);\n  }\n  friend bool operator<(const UUID &LHS, const UUID &RHS) {\n    return LHS.m_bytes < RHS.m_bytes;\n  }\n  friend bool operator<=(const UUID &LHS, const UUID &RHS) {\n    return !(RHS < LHS);\n  }\n  friend bool operator>(const UUID &LHS, const UUID &RHS) { return RHS < LHS; }\n  friend bool operator>=(const UUID &LHS, const UUID &RHS) {\n    return !(LHS < RHS);\n  }\n};\n} // namespace lldb_private\n\n#endif // LLDB_UTILITY_UUID_H\n"}, "25": {"id": 25, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/UserID.h", "content": "//===-- UserID.h ------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_USERID_H\n#define LLDB_UTILITY_USERID_H\n\n#include \"lldb/lldb-defines.h\"\n#include \"lldb/lldb-types.h\"\n\nnamespace lldb_private {\nclass Stream;\n\n/// \\class UserID UserID.h \"lldb/Core/UserID.h\"\n/// A mix in class that contains a generic user ID.\n///\n/// UserID is designed as a mix in class that can contain an integer based\n/// unique identifier for a variety of objects in lldb.\n///\n/// The value for this identifier is chosen by each parser plug-in. A value\n/// should be chosen that makes sense for each kind of object and should allow\n/// quick access to further and more in depth parsing.\n///\n/// Symbol table entries can use this to store the original symbol table\n/// index, functions can use it to store the symbol table index or the\n/// DWARF offset.\nstruct UserID {\n  /// Construct with optional user ID.\n  UserID(lldb::user_id_t uid = LLDB_INVALID_UID) : m_uid(uid) {}\n\n  /// Destructor.\n  ~UserID() {}\n\n  /// Clears the object state.\n  ///\n  /// Clears the object contents back to a default invalid state.\n  void Clear() { m_uid = LLDB_INVALID_UID; }\n\n  /// Get accessor for the user ID.\n  ///\n  /// \\return\n  ///     The user ID.\n  lldb::user_id_t GetID() const { return m_uid; }\n\n  /// Set accessor for the user ID.\n  ///\n  /// \\param[in] uid\n  ///     The new user ID.\n  void SetID(lldb::user_id_t uid) { m_uid = uid; }\n\n  /// Unary predicate function object that can search for a matching user ID.\n  ///\n  /// Function object that can be used on any class that inherits from UserID:\n  /// \\code\n  /// iterator pos;\n  /// pos = std::find_if (coll.begin(), coll.end(), UserID::IDMatches(blockID));\n  /// \\endcode\n  class IDMatches {\n  public:\n    /// Construct with the user ID to look for.\n    IDMatches(lldb::user_id_t uid) : m_uid(uid) {}\n\n    /// Unary predicate function object callback.\n    bool operator()(const UserID &rhs) const { return m_uid == rhs.GetID(); }\n\n  private:\n    // Member variables.\n    const lldb::user_id_t m_uid; ///< The user ID we are looking for\n  };\n\nprotected:\n  // Member variables.\n  lldb::user_id_t m_uid; ///< The user ID that uniquely identifies an object.\n};\n\ninline bool operator==(const UserID &lhs, const UserID &rhs) {\n  return lhs.GetID() == rhs.GetID();\n}\n\ninline bool operator!=(const UserID &lhs, const UserID &rhs) {\n  return lhs.GetID() != rhs.GetID();\n}\n\n/// Stream the UserID object to a Stream.\nStream &operator<<(Stream &strm, const UserID &uid);\n\n} // namespace lldb_private\n\n#endif // LLDB_UTILITY_USERID_H\n"}, "31": {"id": 31, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "content": "//===- llvm/ADT/DenseMap.h - Dense probed hash table ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the DenseMap class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_DENSEMAP_H\n#define LLVM_ADT_DENSEMAP_H\n\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/EpochTracker.h\"\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/MemAlloc.h\"\n#include \"llvm/Support/ReverseIteration.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstring>\n#include <initializer_list>\n#include <iterator>\n#include <new>\n#include <type_traits>\n#include <utility>\n\nnamespace llvm {\n\nnamespace detail {\n\n// We extend a pair to allow users to override the bucket type with their own\n// implementation without requiring two members.\ntemplate <typename KeyT, typename ValueT>\nstruct DenseMapPair : public std::pair<KeyT, ValueT> {\n  using std::pair<KeyT, ValueT>::pair;\n\n  KeyT &getFirst() { return std::pair<KeyT, ValueT>::first; }\n  const KeyT &getFirst() const { return std::pair<KeyT, ValueT>::first; }\n  ValueT &getSecond() { return std::pair<KeyT, ValueT>::second; }\n  const ValueT &getSecond() const { return std::pair<KeyT, ValueT>::second; }\n};\n\n} // end namespace detail\n\ntemplate <typename KeyT, typename ValueT,\n          typename KeyInfoT = DenseMapInfo<KeyT>,\n          typename Bucket = llvm::detail::DenseMapPair<KeyT, ValueT>,\n          bool IsConst = false>\nclass DenseMapIterator;\n\ntemplate <typename DerivedT, typename KeyT, typename ValueT, typename KeyInfoT,\n          typename BucketT>\nclass DenseMapBase : public DebugEpochBase {\n  template <typename T>\n  using const_arg_type_t = typename const_pointer_or_const_ref<T>::type;\n\npublic:\n  using size_type = unsigned;\n  using key_type = KeyT;\n  using mapped_type = ValueT;\n  using value_type = BucketT;\n\n  using iterator = DenseMapIterator<KeyT, ValueT, KeyInfoT, BucketT>;\n  using const_iterator =\n      DenseMapIterator<KeyT, ValueT, KeyInfoT, BucketT, true>;\n\n  inline iterator begin() {\n    // When the map is empty, avoid the overhead of advancing/retreating past\n    // empty buckets.\n    if (empty())\n      return end();\n    if (shouldReverseIterate<KeyT>())\n      return makeIterator(getBucketsEnd() - 1, getBuckets(), *this);\n    return makeIterator(getBuckets(), getBucketsEnd(), *this);\n  }\n  inline iterator end() {\n    return makeIterator(getBucketsEnd(), getBucketsEnd(), *this, true);\n  }\n  inline const_iterator begin() const {\n    if (empty())\n      return end();\n    if (shouldReverseIterate<KeyT>())\n      return makeConstIterator(getBucketsEnd() - 1, getBuckets(), *this);\n    return makeConstIterator(getBuckets(), getBucketsEnd(), *this);\n  }\n  inline const_iterator end() const {\n    return makeConstIterator(getBucketsEnd(), getBucketsEnd(), *this, true);\n  }\n\n  LLVM_NODISCARD bool empty() const {\n    return getNumEntries() == 0;\n  }\n  unsigned size() const { return getNumEntries(); }\n\n  /// Grow the densemap so that it can contain at least \\p NumEntries items\n  /// before resizing again.\n  void reserve(size_type NumEntries) {\n    auto NumBuckets = getMinBucketToReserveForEntries(NumEntries);\n    incrementEpoch();\n    if (NumBuckets > getNumBuckets())\n      grow(NumBuckets);\n  }\n\n  void clear() {\n    incrementEpoch();\n    if (getNumEntries() == 0 && getNumTombstones() == 0) return;\n\n    // If the capacity of the array is huge, and the # elements used is small,\n    // shrink the array.\n    if (getNumEntries() * 4 < getNumBuckets() && getNumBuckets() > 64) {\n      shrink_and_clear();\n      return;\n    }\n\n    const KeyT EmptyKey = getEmptyKey(), TombstoneKey = getTombstoneKey();\n    if (std::is_trivially_destructible<ValueT>::value) {\n      // Use a simpler loop when values don't need destruction.\n      for (BucketT *P = getBuckets(), *E = getBucketsEnd(); P != E; ++P)\n        P->getFirst() = EmptyKey;\n    } else {\n      unsigned NumEntries = getNumEntries();\n      for (BucketT *P = getBuckets(), *E = getBucketsEnd(); P != E; ++P) {\n        if (!KeyInfoT::isEqual(P->getFirst(), EmptyKey)) {\n          if (!KeyInfoT::isEqual(P->getFirst(), TombstoneKey)) {\n            P->getSecond().~ValueT();\n            --NumEntries;\n          }\n          P->getFirst() = EmptyKey;\n        }\n      }\n      assert(NumEntries == 0 && \"Node count imbalance!\");\n    }\n    setNumEntries(0);\n    setNumTombstones(0);\n  }\n\n  /// Return 1 if the specified key is in the map, 0 otherwise.\n  size_type count(const_arg_type_t<KeyT> Val) const {\n    const BucketT *TheBucket;\n    return LookupBucketFor(Val, TheBucket) ? 1 : 0;\n  }\n\n  iterator find(const_arg_type_t<KeyT> Val) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeIterator(TheBucket,\n                          shouldReverseIterate<KeyT>() ? getBuckets()\n                                                       : getBucketsEnd(),\n                          *this, true);\n    return end();\n  }\n  const_iterator find(const_arg_type_t<KeyT> Val) const {\n    const BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeConstIterator(TheBucket,\n                               shouldReverseIterate<KeyT>() ? getBuckets()\n                                                            : getBucketsEnd(),\n                               *this, true);\n    return end();\n  }\n\n  /// Alternate version of find() which allows a different, and possibly\n  /// less expensive, key type.\n  /// The DenseMapInfo is responsible for supplying methods\n  /// getHashValue(LookupKeyT) and isEqual(LookupKeyT, KeyT) for each key\n  /// type used.\n  template<class LookupKeyT>\n  iterator find_as(const LookupKeyT &Val) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeIterator(TheBucket,\n                          shouldReverseIterate<KeyT>() ? getBuckets()\n                                                       : getBucketsEnd(),\n                          *this, true);\n    return end();\n  }\n  template<class LookupKeyT>\n  const_iterator find_as(const LookupKeyT &Val) const {\n    const BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeConstIterator(TheBucket,\n                               shouldReverseIterate<KeyT>() ? getBuckets()\n                                                            : getBucketsEnd(),\n                               *this, true);\n    return end();\n  }\n\n  /// lookup - Return the entry for the specified key, or a default\n  /// constructed value if no such entry exists.\n  ValueT lookup(const_arg_type_t<KeyT> Val) const {\n    const BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return TheBucket->getSecond();\n    return ValueT();\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // If the key is already in the map, it returns false and doesn't update the\n  // value.\n  std::pair<iterator, bool> insert(const std::pair<KeyT, ValueT> &KV) {\n    return try_emplace(KV.first, KV.second);\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // If the key is already in the map, it returns false and doesn't update the\n  // value.\n  std::pair<iterator, bool> insert(std::pair<KeyT, ValueT> &&KV) {\n    return try_emplace(std::move(KV.first), std::move(KV.second));\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // The value is constructed in-place if the key is not in the map, otherwise\n  // it is not moved.\n  template <typename... Ts>\n  std::pair<iterator, bool> try_emplace(KeyT &&Key, Ts &&... Args) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return std::make_pair(makeIterator(TheBucket,\n                                         shouldReverseIterate<KeyT>()\n                                             ? getBuckets()\n                                             : getBucketsEnd(),\n                                         *this, true),\n                            false); // Already in map.\n\n    // Otherwise, insert the new element.\n    TheBucket =\n        InsertIntoBucket(TheBucket, std::move(Key), std::forward<Ts>(Args)...);\n    return std::make_pair(makeIterator(TheBucket,\n                                       shouldReverseIterate<KeyT>()\n                                           ? getBuckets()\n                                           : getBucketsEnd(),\n                                       *this, true),\n                          true);\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // The value is constructed in-place if the key is not in the map, otherwise\n  // it is not moved.\n  template <typename... Ts>\n  std::pair<iterator, bool> try_emplace(const KeyT &Key, Ts &&... Args) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return std::make_pair(makeIterator(TheBucket,\n                                         shouldReverseIterate<KeyT>()\n                                             ? getBuckets()\n                                             : getBucketsEnd(),\n                                         *this, true),\n                            false); // Already in map.\n\n    // Otherwise, insert the new element.\n    TheBucket = InsertIntoBucket(TheBucket, Key, std::forward<Ts>(Args)...);\n    return std::make_pair(makeIterator(TheBucket,\n                                       shouldReverseIterate<KeyT>()\n                                           ? getBuckets()\n                                           : getBucketsEnd(),\n                                       *this, true),\n                          true);\n  }\n\n  /// Alternate version of insert() which allows a different, and possibly\n  /// less expensive, key type.\n  /// The DenseMapInfo is responsible for supplying methods\n  /// getHashValue(LookupKeyT) and isEqual(LookupKeyT, KeyT) for each key\n  /// type used.\n  template <typename LookupKeyT>\n  std::pair<iterator, bool> insert_as(std::pair<KeyT, ValueT> &&KV,\n                                      const LookupKeyT &Val) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return std::make_pair(makeIterator(TheBucket,\n                                         shouldReverseIterate<KeyT>()\n                                             ? getBuckets()\n                                             : getBucketsEnd(),\n                                         *this, true),\n                            false); // Already in map.\n\n    // Otherwise, insert the new element.\n    TheBucket = InsertIntoBucketWithLookup(TheBucket, std::move(KV.first),\n                                           std::move(KV.second), Val);\n    return std::make_pair(makeIterator(TheBucket,\n                                       shouldReverseIterate<KeyT>()\n                                           ? getBuckets()\n                                           : getBucketsEnd(),\n                                       *this, true),\n                          true);\n  }\n\n  /// insert - Range insertion of pairs.\n  template<typename InputIt>\n  void insert(InputIt I, InputIt E) {\n    for (; I != E; ++I)\n      insert(*I);\n  }\n\n  bool erase(const KeyT &Val) {\n    BucketT *TheBucket;\n    if (!LookupBucketFor(Val, TheBucket))\n      return false; // not in map.\n\n    TheBucket->getSecond().~ValueT();\n    TheBucket->getFirst() = getTombstoneKey();\n    decrementNumEntries();\n    incrementNumTombstones();\n    return true;\n  }\n  void erase(iterator I) {\n    BucketT *TheBucket = &*I;\n    TheBucket->getSecond().~ValueT();\n    TheBucket->getFirst() = getTombstoneKey();\n    decrementNumEntries();\n    incrementNumTombstones();\n  }\n\n  value_type& FindAndConstruct(const KeyT &Key) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return *TheBucket;\n\n    return *InsertIntoBucket(TheBucket, Key);\n  }\n\n  ValueT &operator[](const KeyT &Key) {\n    return FindAndConstruct(Key).second;\n  }\n\n  value_type& FindAndConstruct(KeyT &&Key) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return *TheBucket;\n\n    return *InsertIntoBucket(TheBucket, std::move(Key));\n  }\n\n  ValueT &operator[](KeyT &&Key) {\n    return FindAndConstruct(std::move(Key)).second;\n  }\n\n  /// isPointerIntoBucketsArray - Return true if the specified pointer points\n  /// somewhere into the DenseMap's array of buckets (i.e. either to a key or\n  /// value in the DenseMap).\n  bool isPointerIntoBucketsArray(const void *Ptr) const {\n    return Ptr >= getBuckets() && Ptr < getBucketsEnd();\n  }\n\n  /// getPointerIntoBucketsArray() - Return an opaque pointer into the buckets\n  /// array.  In conjunction with the previous method, this can be used to\n  /// determine whether an insertion caused the DenseMap to reallocate.\n  const void *getPointerIntoBucketsArray() const { return getBuckets(); }\n\nprotected:\n  DenseMapBase() = default;\n\n  void destroyAll() {\n    if (getNumBuckets() == 0) // Nothing to do.\n      return;\n\n    const KeyT EmptyKey = getEmptyKey(), TombstoneKey = getTombstoneKey();\n    for (BucketT *P = getBuckets(), *E = getBucketsEnd(); P != E; ++P) {\n      if (!KeyInfoT::isEqual(P->getFirst(), EmptyKey) &&\n          !KeyInfoT::isEqual(P->getFirst(), TombstoneKey))\n        P->getSecond().~ValueT();\n      P->getFirst().~KeyT();\n    }\n  }\n\n  void initEmpty() {\n    setNumEntries(0);\n    setNumTombstones(0);\n\n    assert((getNumBuckets() & (getNumBuckets()-1)) == 0 &&\n           \"# initial buckets must be a power of two!\");\n    const KeyT EmptyKey = getEmptyKey();\n    for (BucketT *B = getBuckets(), *E = getBucketsEnd(); B != E; ++B)\n      ::new (&B->getFirst()) KeyT(EmptyKey);\n  }\n\n  /// Returns the number of buckets to allocate to ensure that the DenseMap can\n  /// accommodate \\p NumEntries without need to grow().\n  unsigned getMinBucketToReserveForEntries(unsigned NumEntries) {\n    // Ensure that \"NumEntries * 4 < NumBuckets * 3\"\n    if (NumEntries == 0)\n      return 0;\n    // +1 is required because of the strict equality.\n    // For example if NumEntries is 48, we need to return 401.\n    return NextPowerOf2(NumEntries * 4 / 3 + 1);\n  }\n\n  void moveFromOldBuckets(BucketT *OldBucketsBegin, BucketT *OldBucketsEnd) {\n    initEmpty();\n\n    // Insert all the old elements.\n    const KeyT EmptyKey = getEmptyKey();\n    const KeyT TombstoneKey = getTombstoneKey();\n    for (BucketT *B = OldBucketsBegin, *E = OldBucketsEnd; B != E; ++B) {\n      if (!KeyInfoT::isEqual(B->getFirst(), EmptyKey) &&\n          !KeyInfoT::isEqual(B->getFirst(), TombstoneKey)) {\n        // Insert the key/value into the new table.\n        BucketT *DestBucket;\n        bool FoundVal = LookupBucketFor(B->getFirst(), DestBucket);\n        (void)FoundVal; // silence warning.\n        assert(!FoundVal && \"Key already in new map?\");\n        DestBucket->getFirst() = std::move(B->getFirst());\n        ::new (&DestBucket->getSecond()) ValueT(std::move(B->getSecond()));\n        incrementNumEntries();\n\n        // Free the value.\n        B->getSecond().~ValueT();\n      }\n      B->getFirst().~KeyT();\n    }\n  }\n\n  template <typename OtherBaseT>\n  void copyFrom(\n      const DenseMapBase<OtherBaseT, KeyT, ValueT, KeyInfoT, BucketT> &other) {\n    assert(&other != this);\n    assert(getNumBuckets() == other.getNumBuckets());\n\n    setNumEntries(other.getNumEntries());\n    setNumTombstones(other.getNumTombstones());\n\n    if (std::is_trivially_copyable<KeyT>::value &&\n        std::is_trivially_copyable<ValueT>::value)\n      memcpy(reinterpret_cast<void *>(getBuckets()), other.getBuckets(),\n             getNumBuckets() * sizeof(BucketT));\n    else\n      for (size_t i = 0; i < getNumBuckets(); ++i) {\n        ::new (&getBuckets()[i].getFirst())\n            KeyT(other.getBuckets()[i].getFirst());\n        if (!KeyInfoT::isEqual(getBuckets()[i].getFirst(), getEmptyKey()) &&\n            !KeyInfoT::isEqual(getBuckets()[i].getFirst(), getTombstoneKey()))\n          ::new (&getBuckets()[i].getSecond())\n              ValueT(other.getBuckets()[i].getSecond());\n      }\n  }\n\n  static unsigned getHashValue(const KeyT &Val) {\n    return KeyInfoT::getHashValue(Val);\n  }\n\n  template<typename LookupKeyT>\n  static unsigned getHashValue(const LookupKeyT &Val) {\n    return KeyInfoT::getHashValue(Val);\n  }\n\n  static const KeyT getEmptyKey() {\n    static_assert(std::is_base_of<DenseMapBase, DerivedT>::value,\n                  \"Must pass the derived type to this template!\");\n    return KeyInfoT::getEmptyKey();\n  }\n\n  static const KeyT getTombstoneKey() {\n    return KeyInfoT::getTombstoneKey();\n  }\n\nprivate:\n  iterator makeIterator(BucketT *P, BucketT *E,\n                        DebugEpochBase &Epoch,\n                        bool NoAdvance=false) {\n    if (shouldReverseIterate<KeyT>()) {\n      BucketT *B = P == getBucketsEnd() ? getBuckets() : P + 1;\n      return iterator(B, E, Epoch, NoAdvance);\n    }\n    return iterator(P, E, Epoch, NoAdvance);\n  }\n\n  const_iterator makeConstIterator(const BucketT *P, const BucketT *E,\n                                   const DebugEpochBase &Epoch,\n                                   const bool NoAdvance=false) const {\n    if (shouldReverseIterate<KeyT>()) {\n      const BucketT *B = P == getBucketsEnd() ? getBuckets() : P + 1;\n      return const_iterator(B, E, Epoch, NoAdvance);\n    }\n    return const_iterator(P, E, Epoch, NoAdvance);\n  }\n\n  unsigned getNumEntries() const {\n    return static_cast<const DerivedT *>(this)->getNumEntries();\n  }\n\n  void setNumEntries(unsigned Num) {\n    static_cast<DerivedT *>(this)->setNumEntries(Num);\n  }\n\n  void incrementNumEntries() {\n    setNumEntries(getNumEntries() + 1);\n  }\n\n  void decrementNumEntries() {\n    setNumEntries(getNumEntries() - 1);\n  }\n\n  unsigned getNumTombstones() const {\n    return static_cast<const DerivedT *>(this)->getNumTombstones();\n  }\n\n  void setNumTombstones(unsigned Num) {\n    static_cast<DerivedT *>(this)->setNumTombstones(Num);\n  }\n\n  void incrementNumTombstones() {\n    setNumTombstones(getNumTombstones() + 1);\n  }\n\n  void decrementNumTombstones() {\n    setNumTombstones(getNumTombstones() - 1);\n  }\n\n  const BucketT *getBuckets() const {\n    return static_cast<const DerivedT *>(this)->getBuckets();\n  }\n\n  BucketT *getBuckets() {\n    return static_cast<DerivedT *>(this)->getBuckets();\n  }\n\n  unsigned getNumBuckets() const {\n    return static_cast<const DerivedT *>(this)->getNumBuckets();\n  }\n\n  BucketT *getBucketsEnd() {\n    return getBuckets() + getNumBuckets();\n  }\n\n  const BucketT *getBucketsEnd() const {\n    return getBuckets() + getNumBuckets();\n  }\n\n  void grow(unsigned AtLeast) {\n    static_cast<DerivedT *>(this)->grow(AtLeast);\n  }\n\n  void shrink_and_clear() {\n    static_cast<DerivedT *>(this)->shrink_and_clear();\n  }\n\n  template <typename KeyArg, typename... ValueArgs>\n  BucketT *InsertIntoBucket(BucketT *TheBucket, KeyArg &&Key,\n                            ValueArgs &&... Values) {\n    TheBucket = InsertIntoBucketImpl(Key, Key, TheBucket);\n\n    TheBucket->getFirst() = std::forward<KeyArg>(Key);\n    ::new (&TheBucket->getSecond()) ValueT(std::forward<ValueArgs>(Values)...);\n    return TheBucket;\n  }\n\n  template <typename LookupKeyT>\n  BucketT *InsertIntoBucketWithLookup(BucketT *TheBucket, KeyT &&Key,\n                                      ValueT &&Value, LookupKeyT &Lookup) {\n    TheBucket = InsertIntoBucketImpl(Key, Lookup, TheBucket);\n\n    TheBucket->getFirst() = std::move(Key);\n    ::new (&TheBucket->getSecond()) ValueT(std::move(Value));\n    return TheBucket;\n  }\n\n  template <typename LookupKeyT>\n  BucketT *InsertIntoBucketImpl(const KeyT &Key, const LookupKeyT &Lookup,\n                                BucketT *TheBucket) {\n    incrementEpoch();\n\n    // If the load of the hash table is more than 3/4, or if fewer than 1/8 of\n    // the buckets are empty (meaning that many are filled with tombstones),\n    // grow the table.\n    //\n    // The later case is tricky.  For example, if we had one empty bucket with\n    // tons of tombstones, failing lookups (e.g. for insertion) would have to\n    // probe almost the entire table until it found the empty bucket.  If the\n    // table completely filled with tombstones, no lookup would ever succeed,\n    // causing infinite loops in lookup.\n    unsigned NewNumEntries = getNumEntries() + 1;\n    unsigned NumBuckets = getNumBuckets();\n    if (LLVM_UNLIKELY(NewNumEntries * 4 >= NumBuckets * 3)) {\n      this->grow(NumBuckets * 2);\n      LookupBucketFor(Lookup, TheBucket);\n      NumBuckets = getNumBuckets();\n    } else if (LLVM_UNLIKELY(NumBuckets-(NewNumEntries+getNumTombstones()) <=\n                             NumBuckets/8)) {\n      this->grow(NumBuckets);\n      LookupBucketFor(Lookup, TheBucket);\n    }\n    assert(TheBucket);\n\n    // Only update the state after we've grown our bucket space appropriately\n    // so that when growing buckets we have self-consistent entry count.\n    incrementNumEntries();\n\n    // If we are writing over a tombstone, remember this.\n    const KeyT EmptyKey = getEmptyKey();\n    if (!KeyInfoT::isEqual(TheBucket->getFirst(), EmptyKey))\n      decrementNumTombstones();\n\n    return TheBucket;\n  }\n\n  /// LookupBucketFor - Lookup the appropriate bucket for Val, returning it in\n  /// FoundBucket.  If the bucket contains the key and a value, this returns\n  /// true, otherwise it returns a bucket with an empty marker or tombstone and\n  /// returns false.\n  template<typename LookupKeyT>\n  bool LookupBucketFor(const LookupKeyT &Val,\n                       const BucketT *&FoundBucket) const {\n    const BucketT *BucketsPtr = getBuckets();\n    const unsigned NumBuckets = getNumBuckets();\n\n    if (NumBuckets == 0) {\n      FoundBucket = nullptr;\n      return false;\n    }\n\n    // FoundTombstone - Keep track of whether we find a tombstone while probing.\n    const BucketT *FoundTombstone = nullptr;\n    const KeyT EmptyKey = getEmptyKey();\n    const KeyT TombstoneKey = getTombstoneKey();\n    assert(!KeyInfoT::isEqual(Val, EmptyKey) &&\n           !KeyInfoT::isEqual(Val, TombstoneKey) &&\n           \"Empty/Tombstone value shouldn't be inserted into map!\");\n\n    unsigned BucketNo = getHashValue(Val) & (NumBuckets-1);\n    unsigned ProbeAmt = 1;\n    while (true) {\n      const BucketT *ThisBucket = BucketsPtr + BucketNo;\n      // Found Val's bucket?  If so, return it.\n      if (LLVM_LIKELY(KeyInfoT::isEqual(Val, ThisBucket->getFirst()))) {\n        FoundBucket = ThisBucket;\n        return true;\n      }\n\n      // If we found an empty bucket, the key doesn't exist in the set.\n      // Insert it and return the default value.\n      if (LLVM_LIKELY(KeyInfoT::isEqual(ThisBucket->getFirst(), EmptyKey))) {\n        // If we've already seen a tombstone while probing, fill it in instead\n        // of the empty bucket we eventually probed to.\n        FoundBucket = FoundTombstone ? FoundTombstone : ThisBucket;\n        return false;\n      }\n\n      // If this is a tombstone, remember it.  If Val ends up not in the map, we\n      // prefer to return it than something that would require more probing.\n      if (KeyInfoT::isEqual(ThisBucket->getFirst(), TombstoneKey) &&\n          !FoundTombstone)\n        FoundTombstone = ThisBucket;  // Remember the first tombstone found.\n\n      // Otherwise, it's a hash collision or a tombstone, continue quadratic\n      // probing.\n      BucketNo += ProbeAmt++;\n      BucketNo &= (NumBuckets-1);\n    }\n  }\n\n  template <typename LookupKeyT>\n  bool LookupBucketFor(const LookupKeyT &Val, BucketT *&FoundBucket) {\n    const BucketT *ConstFoundBucket;\n    bool Result = const_cast<const DenseMapBase *>(this)\n      ->LookupBucketFor(Val, ConstFoundBucket);\n    FoundBucket = const_cast<BucketT *>(ConstFoundBucket);\n    return Result;\n  }\n\npublic:\n  /// Return the approximate size (in bytes) of the actual map.\n  /// This is just the raw memory used by DenseMap.\n  /// If entries are pointers to objects, the size of the referenced objects\n  /// are not included.\n  size_t getMemorySize() const {\n    return getNumBuckets() * sizeof(BucketT);\n  }\n};\n\n/// Equality comparison for DenseMap.\n///\n/// Iterates over elements of LHS confirming that each (key, value) pair in LHS\n/// is also in RHS, and that no additional pairs are in RHS.\n/// Equivalent to N calls to RHS.find and N value comparisons. Amortized\n/// complexity is linear, worst case is O(N^2) (if every hash collides).\ntemplate <typename DerivedT, typename KeyT, typename ValueT, typename KeyInfoT,\n          typename BucketT>\nbool operator==(\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &LHS,\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &RHS) {\n  if (LHS.size() != RHS.size())\n    return false;\n\n  for (auto &KV : LHS) {\n    auto I = RHS.find(KV.first);\n    if (I == RHS.end() || I->second != KV.second)\n      return false;\n  }\n\n  return true;\n}\n\n/// Inequality comparison for DenseMap.\n///\n/// Equivalent to !(LHS == RHS). See operator== for performance notes.\ntemplate <typename DerivedT, typename KeyT, typename ValueT, typename KeyInfoT,\n          typename BucketT>\nbool operator!=(\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &LHS,\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &RHS) {\n  return !(LHS == RHS);\n}\n\ntemplate <typename KeyT, typename ValueT,\n          typename KeyInfoT = DenseMapInfo<KeyT>,\n          typename BucketT = llvm::detail::DenseMapPair<KeyT, ValueT>>\nclass DenseMap : public DenseMapBase<DenseMap<KeyT, ValueT, KeyInfoT, BucketT>,\n                                     KeyT, ValueT, KeyInfoT, BucketT> {\n  friend class DenseMapBase<DenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  // Lift some types from the dependent base class into this class for\n  // simplicity of referring to them.\n  using BaseT = DenseMapBase<DenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  BucketT *Buckets;\n  unsigned NumEntries;\n  unsigned NumTombstones;\n  unsigned NumBuckets;\n\npublic:\n  /// Create a DenseMap with an optional \\p InitialReserve that guarantee that\n  /// this number of elements can be inserted in the map without grow()\n  explicit DenseMap(unsigned InitialReserve = 0) { init(InitialReserve); }\n\n  DenseMap(const DenseMap &other) : BaseT() {\n    init(0);\n    copyFrom(other);\n  }\n\n  DenseMap(DenseMap &&other) : BaseT() {\n    init(0);\n    swap(other);\n  }\n\n  template<typename InputIt>\n  DenseMap(const InputIt &I, const InputIt &E) {\n    init(std::distance(I, E));\n    this->insert(I, E);\n  }\n\n  DenseMap(std::initializer_list<typename BaseT::value_type> Vals) {\n    init(Vals.size());\n    this->insert(Vals.begin(), Vals.end());\n  }\n\n  ~DenseMap() {\n    this->destroyAll();\n    deallocate_buffer(Buckets, sizeof(BucketT) * NumBuckets, alignof(BucketT));\n  }\n\n  void swap(DenseMap& RHS) {\n    this->incrementEpoch();\n    RHS.incrementEpoch();\n    std::swap(Buckets, RHS.Buckets);\n    std::swap(NumEntries, RHS.NumEntries);\n    std::swap(NumTombstones, RHS.NumTombstones);\n    std::swap(NumBuckets, RHS.NumBuckets);\n  }\n\n  DenseMap& operator=(const DenseMap& other) {\n    if (&other != this)\n      copyFrom(other);\n    return *this;\n  }\n\n  DenseMap& operator=(DenseMap &&other) {\n    this->destroyAll();\n    deallocate_buffer(Buckets, sizeof(BucketT) * NumBuckets, alignof(BucketT));\n    init(0);\n    swap(other);\n    return *this;\n  }\n\n  void copyFrom(const DenseMap& other) {\n    this->destroyAll();\n    deallocate_buffer(Buckets, sizeof(BucketT) * NumBuckets, alignof(BucketT));\n    if (allocateBuckets(other.NumBuckets)) {\n      this->BaseT::copyFrom(other);\n    } else {\n      NumEntries = 0;\n      NumTombstones = 0;\n    }\n  }\n\n  void init(unsigned InitNumEntries) {\n    auto InitBuckets = BaseT::getMinBucketToReserveForEntries(InitNumEntries);\n    if (allocateBuckets(InitBuckets)) {\n      this->BaseT::initEmpty();\n    } else {\n      NumEntries = 0;\n      NumTombstones = 0;\n    }\n  }\n\n  void grow(unsigned AtLeast) {\n    unsigned OldNumBuckets = NumBuckets;\n    BucketT *OldBuckets = Buckets;\n\n    allocateBuckets(std::max<unsigned>(64, static_cast<unsigned>(NextPowerOf2(AtLeast-1))));\n    assert(Buckets);\n    if (!OldBuckets) {\n      this->BaseT::initEmpty();\n      return;\n    }\n\n    this->moveFromOldBuckets(OldBuckets, OldBuckets+OldNumBuckets);\n\n    // Free the old table.\n    deallocate_buffer(OldBuckets, sizeof(BucketT) * OldNumBuckets,\n                      alignof(BucketT));\n  }\n\n  void shrink_and_clear() {\n    unsigned OldNumBuckets = NumBuckets;\n    unsigned OldNumEntries = NumEntries;\n    this->destroyAll();\n\n    // Reduce the number of buckets.\n    unsigned NewNumBuckets = 0;\n    if (OldNumEntries)\n      NewNumBuckets = std::max(64, 1 << (Log2_32_Ceil(OldNumEntries) + 1));\n    if (NewNumBuckets == NumBuckets) {\n      this->BaseT::initEmpty();\n      return;\n    }\n\n    deallocate_buffer(Buckets, sizeof(BucketT) * OldNumBuckets,\n                      alignof(BucketT));\n    init(NewNumBuckets);\n  }\n\nprivate:\n  unsigned getNumEntries() const {\n    return NumEntries;\n  }\n\n  void setNumEntries(unsigned Num) {\n    NumEntries = Num;\n  }\n\n  unsigned getNumTombstones() const {\n    return NumTombstones;\n  }\n\n  void setNumTombstones(unsigned Num) {\n    NumTombstones = Num;\n  }\n\n  BucketT *getBuckets() const {\n    return Buckets;\n  }\n\n  unsigned getNumBuckets() const {\n    return NumBuckets;\n  }\n\n  bool allocateBuckets(unsigned Num) {\n    NumBuckets = Num;\n    if (NumBuckets == 0) {\n      Buckets = nullptr;\n      return false;\n    }\n\n    Buckets = static_cast<BucketT *>(\n        allocate_buffer(sizeof(BucketT) * NumBuckets, alignof(BucketT)));\n    return true;\n  }\n};\n\ntemplate <typename KeyT, typename ValueT, unsigned InlineBuckets = 4,\n          typename KeyInfoT = DenseMapInfo<KeyT>,\n          typename BucketT = llvm::detail::DenseMapPair<KeyT, ValueT>>\nclass SmallDenseMap\n    : public DenseMapBase<\n          SmallDenseMap<KeyT, ValueT, InlineBuckets, KeyInfoT, BucketT>, KeyT,\n          ValueT, KeyInfoT, BucketT> {\n  friend class DenseMapBase<SmallDenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  // Lift some types from the dependent base class into this class for\n  // simplicity of referring to them.\n  using BaseT = DenseMapBase<SmallDenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  static_assert(isPowerOf2_64(InlineBuckets),\n                \"InlineBuckets must be a power of 2.\");\n\n  unsigned Small : 1;\n  unsigned NumEntries : 31;\n  unsigned NumTombstones;\n\n  struct LargeRep {\n    BucketT *Buckets;\n    unsigned NumBuckets;\n  };\n\n  /// A \"union\" of an inline bucket array and the struct representing\n  /// a large bucket. This union will be discriminated by the 'Small' bit.\n  AlignedCharArrayUnion<BucketT[InlineBuckets], LargeRep> storage;\n\npublic:\n  explicit SmallDenseMap(unsigned NumInitBuckets = 0) {\n    init(NumInitBuckets);\n  }\n\n  SmallDenseMap(const SmallDenseMap &other) : BaseT() {\n    init(0);\n    copyFrom(other);\n  }\n\n  SmallDenseMap(SmallDenseMap &&other) : BaseT() {\n    init(0);\n    swap(other);\n  }\n\n  template<typename InputIt>\n  SmallDenseMap(const InputIt &I, const InputIt &E) {\n    init(NextPowerOf2(std::distance(I, E)));\n    this->insert(I, E);\n  }\n\n  ~SmallDenseMap() {\n    this->destroyAll();\n    deallocateBuckets();\n  }\n\n  void swap(SmallDenseMap& RHS) {\n    unsigned TmpNumEntries = RHS.NumEntries;\n    RHS.NumEntries = NumEntries;\n    NumEntries = TmpNumEntries;\n    std::swap(NumTombstones, RHS.NumTombstones);\n\n    const KeyT EmptyKey = this->getEmptyKey();\n    const KeyT TombstoneKey = this->getTombstoneKey();\n    if (Small && RHS.Small) {\n      // If we're swapping inline bucket arrays, we have to cope with some of\n      // the tricky bits of DenseMap's storage system: the buckets are not\n      // fully initialized. Thus we swap every key, but we may have\n      // a one-directional move of the value.\n      for (unsigned i = 0, e = InlineBuckets; i != e; ++i) {\n        BucketT *LHSB = &getInlineBuckets()[i],\n                *RHSB = &RHS.getInlineBuckets()[i];\n        bool hasLHSValue = (!KeyInfoT::isEqual(LHSB->getFirst(), EmptyKey) &&\n                            !KeyInfoT::isEqual(LHSB->getFirst(), TombstoneKey));\n        bool hasRHSValue = (!KeyInfoT::isEqual(RHSB->getFirst(), EmptyKey) &&\n                            !KeyInfoT::isEqual(RHSB->getFirst(), TombstoneKey));\n        if (hasLHSValue && hasRHSValue) {\n          // Swap together if we can...\n          std::swap(*LHSB, *RHSB);\n          continue;\n        }\n        // Swap separately and handle any asymmetry.\n        std::swap(LHSB->getFirst(), RHSB->getFirst());\n        if (hasLHSValue) {\n          ::new (&RHSB->getSecond()) ValueT(std::move(LHSB->getSecond()));\n          LHSB->getSecond().~ValueT();\n        } else if (hasRHSValue) {\n          ::new (&LHSB->getSecond()) ValueT(std::move(RHSB->getSecond()));\n          RHSB->getSecond().~ValueT();\n        }\n      }\n      return;\n    }\n    if (!Small && !RHS.Small) {\n      std::swap(getLargeRep()->Buckets, RHS.getLargeRep()->Buckets);\n      std::swap(getLargeRep()->NumBuckets, RHS.getLargeRep()->NumBuckets);\n      return;\n    }\n\n    SmallDenseMap &SmallSide = Small ? *this : RHS;\n    SmallDenseMap &LargeSide = Small ? RHS : *this;\n\n    // First stash the large side's rep and move the small side across.\n    LargeRep TmpRep = std::move(*LargeSide.getLargeRep());\n    LargeSide.getLargeRep()->~LargeRep();\n    LargeSide.Small = true;\n    // This is similar to the standard move-from-old-buckets, but the bucket\n    // count hasn't actually rotated in this case. So we have to carefully\n    // move construct the keys and values into their new locations, but there\n    // is no need to re-hash things.\n    for (unsigned i = 0, e = InlineBuckets; i != e; ++i) {\n      BucketT *NewB = &LargeSide.getInlineBuckets()[i],\n              *OldB = &SmallSide.getInlineBuckets()[i];\n      ::new (&NewB->getFirst()) KeyT(std::move(OldB->getFirst()));\n      OldB->getFirst().~KeyT();\n      if (!KeyInfoT::isEqual(NewB->getFirst(), EmptyKey) &&\n          !KeyInfoT::isEqual(NewB->getFirst(), TombstoneKey)) {\n        ::new (&NewB->getSecond()) ValueT(std::move(OldB->getSecond()));\n        OldB->getSecond().~ValueT();\n      }\n    }\n\n    // The hard part of moving the small buckets across is done, just move\n    // the TmpRep into its new home.\n    SmallSide.Small = false;\n    new (SmallSide.getLargeRep()) LargeRep(std::move(TmpRep));\n  }\n\n  SmallDenseMap& operator=(const SmallDenseMap& other) {\n    if (&other != this)\n      copyFrom(other);\n    return *this;\n  }\n\n  SmallDenseMap& operator=(SmallDenseMap &&other) {\n    this->destroyAll();\n    deallocateBuckets();\n    init(0);\n    swap(other);\n    return *this;\n  }\n\n  void copyFrom(const SmallDenseMap& other) {\n    this->destroyAll();\n    deallocateBuckets();\n    Small = true;\n    if (other.getNumBuckets() > InlineBuckets) {\n      Small = false;\n      new (getLargeRep()) LargeRep(allocateBuckets(other.getNumBuckets()));\n    }\n    this->BaseT::copyFrom(other);\n  }\n\n  void init(unsigned InitBuckets) {\n    Small = true;\n    if (InitBuckets > InlineBuckets) {\n      Small = false;\n      new (getLargeRep()) LargeRep(allocateBuckets(InitBuckets));\n    }\n    this->BaseT::initEmpty();\n  }\n\n  void grow(unsigned AtLeast) {\n    if (AtLeast > InlineBuckets)\n      AtLeast = std::max<unsigned>(64, NextPowerOf2(AtLeast-1));\n\n    if (Small) {\n      // First move the inline buckets into a temporary storage.\n      AlignedCharArrayUnion<BucketT[InlineBuckets]> TmpStorage;\n      BucketT *TmpBegin = reinterpret_cast<BucketT *>(&TmpStorage);\n      BucketT *TmpEnd = TmpBegin;\n\n      // Loop over the buckets, moving non-empty, non-tombstones into the\n      // temporary storage. Have the loop move the TmpEnd forward as it goes.\n      const KeyT EmptyKey = this->getEmptyKey();\n      const KeyT TombstoneKey = this->getTombstoneKey();\n      for (BucketT *P = getBuckets(), *E = P + InlineBuckets; P != E; ++P) {\n        if (!KeyInfoT::isEqual(P->getFirst(), EmptyKey) &&\n            !KeyInfoT::isEqual(P->getFirst(), TombstoneKey)) {\n          assert(size_t(TmpEnd - TmpBegin) < InlineBuckets &&\n                 \"Too many inline buckets!\");\n          ::new (&TmpEnd->getFirst()) KeyT(std::move(P->getFirst()));\n          ::new (&TmpEnd->getSecond()) ValueT(std::move(P->getSecond()));\n          ++TmpEnd;\n          P->getSecond().~ValueT();\n        }\n        P->getFirst().~KeyT();\n      }\n\n      // AtLeast == InlineBuckets can happen if there are many tombstones,\n      // and grow() is used to remove them. Usually we always switch to the\n      // large rep here.\n      if (AtLeast > InlineBuckets) {\n        Small = false;\n        new (getLargeRep()) LargeRep(allocateBuckets(AtLeast));\n      }\n      this->moveFromOldBuckets(TmpBegin, TmpEnd);\n      return;\n    }\n\n    LargeRep OldRep = std::move(*getLargeRep());\n    getLargeRep()->~LargeRep();\n    if (AtLeast <= InlineBuckets) {\n      Small = true;\n    } else {\n      new (getLargeRep()) LargeRep(allocateBuckets(AtLeast));\n    }\n\n    this->moveFromOldBuckets(OldRep.Buckets, OldRep.Buckets+OldRep.NumBuckets);\n\n    // Free the old table.\n    deallocate_buffer(OldRep.Buckets, sizeof(BucketT) * OldRep.NumBuckets,\n                      alignof(BucketT));\n  }\n\n  void shrink_and_clear() {\n    unsigned OldSize = this->size();\n    this->destroyAll();\n\n    // Reduce the number of buckets.\n    unsigned NewNumBuckets = 0;\n    if (OldSize) {\n      NewNumBuckets = 1 << (Log2_32_Ceil(OldSize) + 1);\n      if (NewNumBuckets > InlineBuckets && NewNumBuckets < 64u)\n        NewNumBuckets = 64;\n    }\n    if ((Small && NewNumBuckets <= InlineBuckets) ||\n        (!Small && NewNumBuckets == getLargeRep()->NumBuckets)) {\n      this->BaseT::initEmpty();\n      return;\n    }\n\n    deallocateBuckets();\n    init(NewNumBuckets);\n  }\n\nprivate:\n  unsigned getNumEntries() const {\n    return NumEntries;\n  }\n\n  void setNumEntries(unsigned Num) {\n    // NumEntries is hardcoded to be 31 bits wide.\n    assert(Num < (1U << 31) && \"Cannot support more than 1<<31 entries\");\n    NumEntries = Num;\n  }\n\n  unsigned getNumTombstones() const {\n    return NumTombstones;\n  }\n\n  void setNumTombstones(unsigned Num) {\n    NumTombstones = Num;\n  }\n\n  const BucketT *getInlineBuckets() const {\n    assert(Small);\n    // Note that this cast does not violate aliasing rules as we assert that\n    // the memory's dynamic type is the small, inline bucket buffer, and the\n    // 'storage' is a POD containing a char buffer.\n    return reinterpret_cast<const BucketT *>(&storage);\n  }\n\n  BucketT *getInlineBuckets() {\n    return const_cast<BucketT *>(\n      const_cast<const SmallDenseMap *>(this)->getInlineBuckets());\n  }\n\n  const LargeRep *getLargeRep() const {\n    assert(!Small);\n    // Note, same rule about aliasing as with getInlineBuckets.\n    return reinterpret_cast<const LargeRep *>(&storage);\n  }\n\n  LargeRep *getLargeRep() {\n    return const_cast<LargeRep *>(\n      const_cast<const SmallDenseMap *>(this)->getLargeRep());\n  }\n\n  const BucketT *getBuckets() const {\n    return Small ? getInlineBuckets() : getLargeRep()->Buckets;\n  }\n\n  BucketT *getBuckets() {\n    return const_cast<BucketT *>(\n      const_cast<const SmallDenseMap *>(this)->getBuckets());\n  }\n\n  unsigned getNumBuckets() const {\n    return Small ? InlineBuckets : getLargeRep()->NumBuckets;\n  }\n\n  void deallocateBuckets() {\n    if (Small)\n      return;\n\n    deallocate_buffer(getLargeRep()->Buckets,\n                      sizeof(BucketT) * getLargeRep()->NumBuckets,\n                      alignof(BucketT));\n    getLargeRep()->~LargeRep();\n  }\n\n  LargeRep allocateBuckets(unsigned Num) {\n    assert(Num > InlineBuckets && \"Must allocate more buckets than are inline\");\n    LargeRep Rep = {static_cast<BucketT *>(allocate_buffer(\n                        sizeof(BucketT) * Num, alignof(BucketT))),\n                    Num};\n    return Rep;\n  }\n};\n\ntemplate <typename KeyT, typename ValueT, typename KeyInfoT, typename Bucket,\n          bool IsConst>\nclass DenseMapIterator : DebugEpochBase::HandleBase {\n  friend class DenseMapIterator<KeyT, ValueT, KeyInfoT, Bucket, true>;\n  friend class DenseMapIterator<KeyT, ValueT, KeyInfoT, Bucket, false>;\n\npublic:\n  using difference_type = ptrdiff_t;\n  using value_type =\n      typename std::conditional<IsConst, const Bucket, Bucket>::type;\n  using pointer = value_type *;\n  using reference = value_type &;\n  using iterator_category = std::forward_iterator_tag;\n\nprivate:\n  pointer Ptr = nullptr;\n  pointer End = nullptr;\n\npublic:\n  DenseMapIterator() = default;\n\n  DenseMapIterator(pointer Pos, pointer E, const DebugEpochBase &Epoch,\n                   bool NoAdvance = false)\n      : DebugEpochBase::HandleBase(&Epoch), Ptr(Pos), End(E) {\n    assert(isHandleInSync() && \"invalid construction!\");\n\n    if (NoAdvance) return;\n    if (shouldReverseIterate<KeyT>()) {\n      RetreatPastEmptyBuckets();\n      return;\n    }\n    AdvancePastEmptyBuckets();\n  }\n\n  // Converting ctor from non-const iterators to const iterators. SFINAE'd out\n  // for const iterator destinations so it doesn't end up as a user defined copy\n  // constructor.\n  template <bool IsConstSrc,\n            typename = std::enable_if_t<!IsConstSrc && IsConst>>\n  DenseMapIterator(\n      const DenseMapIterator<KeyT, ValueT, KeyInfoT, Bucket, IsConstSrc> &I)\n      : DebugEpochBase::HandleBase(I), Ptr(I.Ptr), End(I.End) {}\n\n  reference operator*() const {\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    assert(Ptr != End && \"dereferencing end() iterator\");\n    if (shouldReverseIterate<KeyT>())\n      return Ptr[-1];\n    return *Ptr;\n  }\n  pointer operator->() const {\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    assert(Ptr != End && \"dereferencing end() iterator\");\n    if (shouldReverseIterate<KeyT>())\n      return &(Ptr[-1]);\n    return Ptr;\n  }\n\n  friend bool operator==(const DenseMapIterator &LHS,\n                         const DenseMapIterator &RHS) {\n    assert((!LHS.Ptr || LHS.isHandleInSync()) && \"handle not in sync!\");\n    assert((!RHS.Ptr || RHS.isHandleInSync()) && \"handle not in sync!\");\n    assert(LHS.getEpochAddress() == RHS.getEpochAddress() &&\n           \"comparing incomparable iterators!\");\n    return LHS.Ptr == RHS.Ptr;\n  }\n\n  friend bool operator!=(const DenseMapIterator &LHS,\n                         const DenseMapIterator &RHS) {\n    return !(LHS == RHS);\n  }\n\n  inline DenseMapIterator& operator++() {  // Preincrement\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    assert(Ptr != End && \"incrementing end() iterator\");\n    if (shouldReverseIterate<KeyT>()) {\n      --Ptr;\n      RetreatPastEmptyBuckets();\n      return *this;\n    }\n    ++Ptr;\n    AdvancePastEmptyBuckets();\n    return *this;\n  }\n  DenseMapIterator operator++(int) {  // Postincrement\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    DenseMapIterator tmp = *this; ++*this; return tmp;\n  }\n\nprivate:\n  void AdvancePastEmptyBuckets() {\n    assert(Ptr <= End);\n    const KeyT Empty = KeyInfoT::getEmptyKey();\n    const KeyT Tombstone = KeyInfoT::getTombstoneKey();\n\n    while (Ptr != End && (KeyInfoT::isEqual(Ptr->getFirst(), Empty) ||\n                          KeyInfoT::isEqual(Ptr->getFirst(), Tombstone)))\n      ++Ptr;\n  }\n\n  void RetreatPastEmptyBuckets() {\n    assert(Ptr >= End);\n    const KeyT Empty = KeyInfoT::getEmptyKey();\n    const KeyT Tombstone = KeyInfoT::getTombstoneKey();\n\n    while (Ptr != End && (KeyInfoT::isEqual(Ptr[-1].getFirst(), Empty) ||\n                          KeyInfoT::isEqual(Ptr[-1].getFirst(), Tombstone)))\n      --Ptr;\n  }\n};\n\ntemplate <typename KeyT, typename ValueT, typename KeyInfoT>\ninline size_t capacity_in_bytes(const DenseMap<KeyT, ValueT, KeyInfoT> &X) {\n  return X.getMemorySize();\n}\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_DENSEMAP_H\n"}, "36": {"id": 36, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "content": "//===- Optional.h - Simple variant for passing optional values --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file provides Optional, a template class modeled in the spirit of\n//  OCaml's 'opt' variant.  The idea is to strongly type whether or not\n//  a value can be optional.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_OPTIONAL_H\n#define LLVM_ADT_OPTIONAL_H\n\n#include \"llvm/ADT/Hashing.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <cassert>\n#include <memory>\n#include <new>\n#include <utility>\n\nnamespace llvm {\n\nclass raw_ostream;\n\nnamespace optional_detail {\n\nstruct in_place_t {};\n\n/// Storage for any type.\n//\n// The specialization condition intentionally uses\n// llvm::is_trivially_copy_constructible instead of\n// std::is_trivially_copy_constructible.  GCC versions prior to 7.4 may\n// instantiate the copy constructor of `T` when\n// std::is_trivially_copy_constructible is instantiated.  This causes\n// compilation to fail if we query the trivially copy constructible property of\n// a class which is not copy constructible.\n//\n// The current implementation of OptionalStorage insists that in order to use\n// the trivial specialization, the value_type must be trivially copy\n// constructible and trivially copy assignable due to =default implementations\n// of the copy/move constructor/assignment.  It does not follow that this is\n// necessarily the case std::is_trivially_copyable is true (hence the expanded\n// specialization condition).\n//\n// The move constructible / assignable conditions emulate the remaining behavior\n// of std::is_trivially_copyable.\ntemplate <typename T, bool = (llvm::is_trivially_copy_constructible<T>::value &&\n                              std::is_trivially_copy_assignable<T>::value &&\n                              (std::is_trivially_move_constructible<T>::value ||\n                               !std::is_move_constructible<T>::value) &&\n                              (std::is_trivially_move_assignable<T>::value ||\n                               !std::is_move_assignable<T>::value))>\nclass OptionalStorage {\n  union {\n    char empty;\n    T value;\n  };\n  bool hasVal;\n\npublic:\n  ~OptionalStorage() { reset(); }\n\n  constexpr OptionalStorage() noexcept : empty(), hasVal(false) {}\n\n  constexpr OptionalStorage(OptionalStorage const &other) : OptionalStorage() {\n    if (other.hasValue()) {\n      emplace(other.value);\n    }\n  }\n  constexpr OptionalStorage(OptionalStorage &&other) : OptionalStorage() {\n    if (other.hasValue()) {\n      emplace(std::move(other.value));\n    }\n  }\n\n  template <class... Args>\n  constexpr explicit OptionalStorage(in_place_t, Args &&... args)\n      : value(std::forward<Args>(args)...), hasVal(true) {}\n\n  void reset() noexcept {\n    if (hasVal) {\n      value.~T();\n      hasVal = false;\n    }\n  }\n\n  constexpr bool hasValue() const noexcept { return hasVal; }\n\n  T &getValue() LLVM_LVALUE_FUNCTION noexcept {\n    assert(hasVal);\n    return value;\n  }\n  constexpr T const &getValue() const LLVM_LVALUE_FUNCTION noexcept {\n    assert(hasVal);\n    return value;\n  }\n#if LLVM_HAS_RVALUE_REFERENCE_THIS\n  T &&getValue() && noexcept {\n    assert(hasVal);\n    return std::move(value);\n  }\n#endif\n\n  template <class... Args> void emplace(Args &&... args) {\n    reset();\n    ::new ((void *)std::addressof(value)) T(std::forward<Args>(args)...);\n    hasVal = true;\n  }\n\n  OptionalStorage &operator=(T const &y) {\n    if (hasValue()) {\n      value = y;\n    } else {\n      ::new ((void *)std::addressof(value)) T(y);\n      hasVal = true;\n    }\n    return *this;\n  }\n  OptionalStorage &operator=(T &&y) {\n    if (hasValue()) {\n      value = std::move(y);\n    } else {\n      ::new ((void *)std::addressof(value)) T(std::move(y));\n      hasVal = true;\n    }\n    return *this;\n  }\n\n  OptionalStorage &operator=(OptionalStorage const &other) {\n    if (other.hasValue()) {\n      if (hasValue()) {\n        value = other.value;\n      } else {\n        ::new ((void *)std::addressof(value)) T(other.value);\n        hasVal = true;\n      }\n    } else {\n      reset();\n    }\n    return *this;\n  }\n\n  OptionalStorage &operator=(OptionalStorage &&other) {\n    if (other.hasValue()) {\n      if (hasValue()) {\n        value = std::move(other.value);\n      } else {\n        ::new ((void *)std::addressof(value)) T(std::move(other.value));\n        hasVal = true;\n      }\n    } else {\n      reset();\n    }\n    return *this;\n  }\n};\n\ntemplate <typename T> class OptionalStorage<T, true> {\n  union {\n    char empty;\n    T value;\n  };\n  bool hasVal = false;\n\npublic:\n  ~OptionalStorage() = default;\n\n  constexpr OptionalStorage() noexcept : empty{} {}\n\n  constexpr OptionalStorage(OptionalStorage const &other) = default;\n  constexpr OptionalStorage(OptionalStorage &&other) = default;\n\n  OptionalStorage &operator=(OptionalStorage const &other) = default;\n  OptionalStorage &operator=(OptionalStorage &&other) = default;\n\n  template <class... Args>\n  constexpr explicit OptionalStorage(in_place_t, Args &&... args)\n      : value(std::forward<Args>(args)...), hasVal(true) {}\n\n  void reset() noexcept {\n    if (hasVal) {\n      value.~T();\n      hasVal = false;\n    }\n  }\n\n  constexpr bool hasValue() const noexcept { return hasVal; }\n\n  T &getValue() LLVM_LVALUE_FUNCTION noexcept {\n    assert(hasVal);\n    return value;\n  }\n  constexpr T const &getValue() const LLVM_LVALUE_FUNCTION noexcept {\n    assert(hasVal);\n    return value;\n  }\n#if LLVM_HAS_RVALUE_REFERENCE_THIS\n  T &&getValue() && noexcept {\n    assert(hasVal);\n    return std::move(value);\n  }\n#endif\n\n  template <class... Args> void emplace(Args &&... args) {\n    reset();\n    ::new ((void *)std::addressof(value)) T(std::forward<Args>(args)...);\n    hasVal = true;\n  }\n\n  OptionalStorage &operator=(T const &y) {\n    if (hasValue()) {\n      value = y;\n    } else {\n      ::new ((void *)std::addressof(value)) T(y);\n      hasVal = true;\n    }\n    return *this;\n  }\n  OptionalStorage &operator=(T &&y) {\n    if (hasValue()) {\n      value = std::move(y);\n    } else {\n      ::new ((void *)std::addressof(value)) T(std::move(y));\n      hasVal = true;\n    }\n    return *this;\n  }\n};\n\n} // namespace optional_detail\n\ntemplate <typename T> class Optional {\n  optional_detail::OptionalStorage<T> Storage;\n\npublic:\n  using value_type = T;\n\n  constexpr Optional() {}\n  constexpr Optional(NoneType) {}\n\n  constexpr Optional(const T &y) : Storage(optional_detail::in_place_t{}, y) {}\n  constexpr Optional(const Optional &O) = default;\n\n  constexpr Optional(T &&y)\n      : Storage(optional_detail::in_place_t{}, std::move(y)) {}\n  constexpr Optional(Optional &&O) = default;\n\n  Optional &operator=(T &&y) {\n    Storage = std::move(y);\n    return *this;\n  }\n  Optional &operator=(Optional &&O) = default;\n\n  /// Create a new object by constructing it in place with the given arguments.\n  template <typename... ArgTypes> void emplace(ArgTypes &&... Args) {\n    Storage.emplace(std::forward<ArgTypes>(Args)...);\n  }\n\n  static constexpr Optional create(const T *y) {\n    return y ? Optional(*y) : Optional();\n  }\n\n  Optional &operator=(const T &y) {\n    Storage = y;\n    return *this;\n  }\n  Optional &operator=(const Optional &O) = default;\n\n  void reset() { Storage.reset(); }\n\n  constexpr const T *getPointer() const { return &Storage.getValue(); }\n  T *getPointer() { return &Storage.getValue(); }\n  constexpr const T &getValue() const LLVM_LVALUE_FUNCTION {\n    return Storage.getValue();\n  }\n  T &getValue() LLVM_LVALUE_FUNCTION { return Storage.getValue(); }\n\n  constexpr explicit operator bool() const { return hasValue(); }\n  constexpr bool hasValue() const { return Storage.hasValue(); }\n  constexpr const T *operator->() const { return getPointer(); }\n  T *operator->() { return getPointer(); }\n  constexpr const T &operator*() const LLVM_LVALUE_FUNCTION {\n    return getValue();\n  }\n  T &operator*() LLVM_LVALUE_FUNCTION { return getValue(); }\n\n  template <typename U>\n  constexpr T getValueOr(U &&value) const LLVM_LVALUE_FUNCTION {\n    return hasValue() ? getValue() : std::forward<U>(value);\n  }\n\n  /// Apply a function to the value if present; otherwise return None.\n  template <class Function>\n  auto map(const Function &F) const LLVM_LVALUE_FUNCTION\n      -> Optional<decltype(F(getValue()))> {\n    if (*this) return F(getValue());\n    return None;\n  }\n\n#if LLVM_HAS_RVALUE_REFERENCE_THIS\n  T &&getValue() && { return std::move(Storage.getValue()); }\n  T &&operator*() && { return std::move(Storage.getValue()); }\n\n  template <typename U>\n  T getValueOr(U &&value) && {\n    return hasValue() ? std::move(getValue()) : std::forward<U>(value);\n  }\n\n  /// Apply a function to the value if present; otherwise return None.\n  template <class Function>\n  auto map(const Function &F) &&\n      -> Optional<decltype(F(std::move(*this).getValue()))> {\n    if (*this) return F(std::move(*this).getValue());\n    return None;\n  }\n#endif\n};\n\ntemplate <class T> llvm::hash_code hash_value(const Optional<T> &O) {\n  return O ? hash_combine(true, *O) : hash_value(false);\n}\n\ntemplate <typename T, typename U>\nconstexpr bool operator==(const Optional<T> &X, const Optional<U> &Y) {\n  if (X && Y)\n    return *X == *Y;\n  return X.hasValue() == Y.hasValue();\n}\n\ntemplate <typename T, typename U>\nconstexpr bool operator!=(const Optional<T> &X, const Optional<U> &Y) {\n  return !(X == Y);\n}\n\ntemplate <typename T, typename U>\nconstexpr bool operator<(const Optional<T> &X, const Optional<U> &Y) {\n  if (X && Y)\n    return *X < *Y;\n  return X.hasValue() < Y.hasValue();\n}\n\ntemplate <typename T, typename U>\nconstexpr bool operator<=(const Optional<T> &X, const Optional<U> &Y) {\n  return !(Y < X);\n}\n\ntemplate <typename T, typename U>\nconstexpr bool operator>(const Optional<T> &X, const Optional<U> &Y) {\n  return Y < X;\n}\n\ntemplate <typename T, typename U>\nconstexpr bool operator>=(const Optional<T> &X, const Optional<U> &Y) {\n  return !(X < Y);\n}\n\ntemplate <typename T>\nconstexpr bool operator==(const Optional<T> &X, NoneType) {\n  return !X;\n}\n\ntemplate <typename T>\nconstexpr bool operator==(NoneType, const Optional<T> &X) {\n  return X == None;\n}\n\ntemplate <typename T>\nconstexpr bool operator!=(const Optional<T> &X, NoneType) {\n  return !(X == None);\n}\n\ntemplate <typename T>\nconstexpr bool operator!=(NoneType, const Optional<T> &X) {\n  return X != None;\n}\n\ntemplate <typename T> constexpr bool operator<(const Optional<T> &, NoneType) {\n  return false;\n}\n\ntemplate <typename T> constexpr bool operator<(NoneType, const Optional<T> &X) {\n  return X.hasValue();\n}\n\ntemplate <typename T>\nconstexpr bool operator<=(const Optional<T> &X, NoneType) {\n  return !(None < X);\n}\n\ntemplate <typename T>\nconstexpr bool operator<=(NoneType, const Optional<T> &X) {\n  return !(X < None);\n}\n\ntemplate <typename T> constexpr bool operator>(const Optional<T> &X, NoneType) {\n  return None < X;\n}\n\ntemplate <typename T> constexpr bool operator>(NoneType, const Optional<T> &X) {\n  return X < None;\n}\n\ntemplate <typename T>\nconstexpr bool operator>=(const Optional<T> &X, NoneType) {\n  return None <= X;\n}\n\ntemplate <typename T>\nconstexpr bool operator>=(NoneType, const Optional<T> &X) {\n  return X <= None;\n}\n\ntemplate <typename T>\nconstexpr bool operator==(const Optional<T> &X, const T &Y) {\n  return X && *X == Y;\n}\n\ntemplate <typename T>\nconstexpr bool operator==(const T &X, const Optional<T> &Y) {\n  return Y && X == *Y;\n}\n\ntemplate <typename T>\nconstexpr bool operator!=(const Optional<T> &X, const T &Y) {\n  return !(X == Y);\n}\n\ntemplate <typename T>\nconstexpr bool operator!=(const T &X, const Optional<T> &Y) {\n  return !(X == Y);\n}\n\ntemplate <typename T>\nconstexpr bool operator<(const Optional<T> &X, const T &Y) {\n  return !X || *X < Y;\n}\n\ntemplate <typename T>\nconstexpr bool operator<(const T &X, const Optional<T> &Y) {\n  return Y && X < *Y;\n}\n\ntemplate <typename T>\nconstexpr bool operator<=(const Optional<T> &X, const T &Y) {\n  return !(Y < X);\n}\n\ntemplate <typename T>\nconstexpr bool operator<=(const T &X, const Optional<T> &Y) {\n  return !(Y < X);\n}\n\ntemplate <typename T>\nconstexpr bool operator>(const Optional<T> &X, const T &Y) {\n  return Y < X;\n}\n\ntemplate <typename T>\nconstexpr bool operator>(const T &X, const Optional<T> &Y) {\n  return Y < X;\n}\n\ntemplate <typename T>\nconstexpr bool operator>=(const Optional<T> &X, const T &Y) {\n  return !(X < Y);\n}\n\ntemplate <typename T>\nconstexpr bool operator>=(const T &X, const Optional<T> &Y) {\n  return !(X < Y);\n}\n\nraw_ostream &operator<<(raw_ostream &OS, NoneType);\n\ntemplate <typename T, typename = decltype(std::declval<raw_ostream &>()\n                                          << std::declval<const T &>())>\nraw_ostream &operator<<(raw_ostream &OS, const Optional<T> &O) {\n  if (O)\n    OS << *O;\n  else\n    OS << None;\n  return OS;\n}\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_OPTIONAL_H\n"}, "40": {"id": 40, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h", "content": "//===- llvm/ADT/SmallBitVector.h - 'Normally small' bit vectors -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements the SmallBitVector class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_SMALLBITVECTOR_H\n#define LLVM_ADT_SMALLBITVECTOR_H\n\n#include \"llvm/ADT/BitVector.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cstddef>\n#include <cstdint>\n#include <limits>\n#include <utility>\n\nnamespace llvm {\n\n/// This is a 'bitvector' (really, a variable-sized bit array), optimized for\n/// the case when the array is small. It contains one pointer-sized field, which\n/// is directly used as a plain collection of bits when possible, or as a\n/// pointer to a larger heap-allocated array when necessary. This allows normal\n/// \"small\" cases to be fast without losing generality for large inputs.\nclass SmallBitVector {\n  // TODO: In \"large\" mode, a pointer to a BitVector is used, leading to an\n  // unnecessary level of indirection. It would be more efficient to use a\n  // pointer to memory containing size, allocation size, and the array of bits.\n  uintptr_t X = 1;\n\n  enum {\n    // The number of bits in this class.\n    NumBaseBits = sizeof(uintptr_t) * CHAR_BIT,\n\n    // One bit is used to discriminate between small and large mode. The\n    // remaining bits are used for the small-mode representation.\n    SmallNumRawBits = NumBaseBits - 1,\n\n    // A few more bits are used to store the size of the bit set in small mode.\n    // Theoretically this is a ceil-log2. These bits are encoded in the most\n    // significant bits of the raw bits.\n    SmallNumSizeBits = (NumBaseBits == 32 ? 5 :\n                        NumBaseBits == 64 ? 6 :\n                        SmallNumRawBits),\n\n    // The remaining bits are used to store the actual set in small mode.\n    SmallNumDataBits = SmallNumRawBits - SmallNumSizeBits\n  };\n\n  static_assert(NumBaseBits == 64 || NumBaseBits == 32,\n                \"Unsupported word size\");\n\npublic:\n  using size_type = unsigned;\n\n  // Encapsulation of a single bit.\n  class reference {\n    SmallBitVector &TheVector;\n    unsigned BitPos;\n\n  public:\n    reference(SmallBitVector &b, unsigned Idx) : TheVector(b), BitPos(Idx) {}\n\n    reference(const reference&) = default;\n\n    reference& operator=(reference t) {\n      *this = bool(t);\n      return *this;\n    }\n\n    reference& operator=(bool t) {\n      if (t)\n        TheVector.set(BitPos);\n      else\n        TheVector.reset(BitPos);\n      return *this;\n    }\n\n    operator bool() const {\n      return const_cast<const SmallBitVector &>(TheVector).operator[](BitPos);\n    }\n  };\n\nprivate:\n  BitVector *getPointer() const {\n    assert(!isSmall());\n    return reinterpret_cast<BitVector *>(X);\n  }\n\n  void switchToSmall(uintptr_t NewSmallBits, size_t NewSize) {\n    X = 1;\n    setSmallSize(NewSize);\n    setSmallBits(NewSmallBits);\n  }\n\n  void switchToLarge(BitVector *BV) {\n    X = reinterpret_cast<uintptr_t>(BV);\n    assert(!isSmall() && \"Tried to use an unaligned pointer\");\n  }\n\n  // Return all the bits used for the \"small\" representation; this includes\n  // bits for the size as well as the element bits.\n  uintptr_t getSmallRawBits() const {\n    assert(isSmall());\n    return X >> 1;\n  }\n\n  void setSmallRawBits(uintptr_t NewRawBits) {\n    assert(isSmall());\n    X = (NewRawBits << 1) | uintptr_t(1);\n  }\n\n  // Return the size.\n  size_t getSmallSize() const { return getSmallRawBits() >> SmallNumDataBits; }\n\n  void setSmallSize(size_t Size) {\n    setSmallRawBits(getSmallBits() | (Size << SmallNumDataBits));\n  }\n\n  // Return the element bits.\n  uintptr_t getSmallBits() const {\n    return getSmallRawBits() & ~(~uintptr_t(0) << getSmallSize());\n  }\n\n  void setSmallBits(uintptr_t NewBits) {\n    setSmallRawBits((NewBits & ~(~uintptr_t(0) << getSmallSize())) |\n                    (getSmallSize() << SmallNumDataBits));\n  }\n\npublic:\n  /// Creates an empty bitvector.\n  SmallBitVector() = default;\n\n  /// Creates a bitvector of specified number of bits. All bits are initialized\n  /// to the specified value.\n  explicit SmallBitVector(unsigned s, bool t = false) {\n    if (s <= SmallNumDataBits)\n      switchToSmall(t ? ~uintptr_t(0) : 0, s);\n    else\n      switchToLarge(new BitVector(s, t));\n  }\n\n  /// SmallBitVector copy ctor.\n  SmallBitVector(const SmallBitVector &RHS) {\n    if (RHS.isSmall())\n      X = RHS.X;\n    else\n      switchToLarge(new BitVector(*RHS.getPointer()));\n  }\n\n  SmallBitVector(SmallBitVector &&RHS) : X(RHS.X) {\n    RHS.X = 1;\n  }\n\n  ~SmallBitVector() {\n    if (!isSmall())\n      delete getPointer();\n  }\n\n  using const_set_bits_iterator = const_set_bits_iterator_impl<SmallBitVector>;\n  using set_iterator = const_set_bits_iterator;\n\n  const_set_bits_iterator set_bits_begin() const {\n    return const_set_bits_iterator(*this);\n  }\n\n  const_set_bits_iterator set_bits_end() const {\n    return const_set_bits_iterator(*this, -1);\n  }\n\n  iterator_range<const_set_bits_iterator> set_bits() const {\n    return make_range(set_bits_begin(), set_bits_end());\n  }\n\n  bool isSmall() const { return X & uintptr_t(1); }\n\n  /// Tests whether there are no bits in this bitvector.\n  bool empty() const {\n    return isSmall() ? getSmallSize() == 0 : getPointer()->empty();\n  }\n\n  /// Returns the number of bits in this bitvector.\n  size_t size() const {\n    return isSmall() ? getSmallSize() : getPointer()->size();\n  }\n\n  /// Returns the number of bits which are set.\n  size_type count() const {\n    if (isSmall()) {\n      uintptr_t Bits = getSmallBits();\n      return countPopulation(Bits);\n    }\n    return getPointer()->count();\n  }\n\n  /// Returns true if any bit is set.\n  bool any() const {\n    if (isSmall())\n      return getSmallBits() != 0;\n    return getPointer()->any();\n  }\n\n  /// Returns true if all bits are set.\n  bool all() const {\n    if (isSmall())\n      return getSmallBits() == (uintptr_t(1) << getSmallSize()) - 1;\n    return getPointer()->all();\n  }\n\n  /// Returns true if none of the bits are set.\n  bool none() const {\n    if (isSmall())\n      return getSmallBits() == 0;\n    return getPointer()->none();\n  }\n\n  /// Returns the index of the first set bit, -1 if none of the bits are set.\n  int find_first() const {\n    if (isSmall()) {\n      uintptr_t Bits = getSmallBits();\n      if (Bits == 0)\n        return -1;\n      return countTrailingZeros(Bits);\n    }\n    return getPointer()->find_first();\n  }\n\n  int find_last() const {\n    if (isSmall()) {\n      uintptr_t Bits = getSmallBits();\n      if (Bits == 0)\n        return -1;\n      return NumBaseBits - countLeadingZeros(Bits) - 1;\n    }\n    return getPointer()->find_last();\n  }\n\n  /// Returns the index of the first unset bit, -1 if all of the bits are set.\n  int find_first_unset() const {\n    if (isSmall()) {\n      if (count() == getSmallSize())\n        return -1;\n\n      uintptr_t Bits = getSmallBits();\n      return countTrailingOnes(Bits);\n    }\n    return getPointer()->find_first_unset();\n  }\n\n  int find_last_unset() const {\n    if (isSmall()) {\n      if (count() == getSmallSize())\n        return -1;\n\n      uintptr_t Bits = getSmallBits();\n      // Set unused bits.\n      Bits |= ~uintptr_t(0) << getSmallSize();\n      return NumBaseBits - countLeadingOnes(Bits) - 1;\n    }\n    return getPointer()->find_last_unset();\n  }\n\n  /// Returns the index of the next set bit following the \"Prev\" bit.\n  /// Returns -1 if the next set bit is not found.\n  int find_next(unsigned Prev) const {\n    if (isSmall()) {\n      uintptr_t Bits = getSmallBits();\n      // Mask off previous bits.\n      Bits &= ~uintptr_t(0) << (Prev + 1);\n      if (Bits == 0 || Prev + 1 >= getSmallSize())\n        return -1;\n      return countTrailingZeros(Bits);\n    }\n    return getPointer()->find_next(Prev);\n  }\n\n  /// Returns the index of the next unset bit following the \"Prev\" bit.\n  /// Returns -1 if the next unset bit is not found.\n  int find_next_unset(unsigned Prev) const {\n    if (isSmall()) {\n      uintptr_t Bits = getSmallBits();\n      // Mask in previous bits.\n      Bits |= (uintptr_t(1) << (Prev + 1)) - 1;\n      // Mask in unused bits.\n      Bits |= ~uintptr_t(0) << getSmallSize();\n\n      if (Bits == ~uintptr_t(0) || Prev + 1 >= getSmallSize())\n        return -1;\n      return countTrailingOnes(Bits);\n    }\n    return getPointer()->find_next_unset(Prev);\n  }\n\n  /// find_prev - Returns the index of the first set bit that precedes the\n  /// the bit at \\p PriorTo.  Returns -1 if all previous bits are unset.\n  int find_prev(unsigned PriorTo) const {\n    if (isSmall()) {\n      if (PriorTo == 0)\n        return -1;\n\n      --PriorTo;\n      uintptr_t Bits = getSmallBits();\n      Bits &= maskTrailingOnes<uintptr_t>(PriorTo + 1);\n      if (Bits == 0)\n        return -1;\n\n      return NumBaseBits - countLeadingZeros(Bits) - 1;\n    }\n    return getPointer()->find_prev(PriorTo);\n  }\n\n  /// Clear all bits.\n  void clear() {\n    if (!isSmall())\n      delete getPointer();\n    switchToSmall(0, 0);\n  }\n\n  /// Grow or shrink the bitvector.\n  void resize(unsigned N, bool t = false) {\n    if (!isSmall()) {\n      getPointer()->resize(N, t);\n    } else if (SmallNumDataBits >= N) {\n      uintptr_t NewBits = t ? ~uintptr_t(0) << getSmallSize() : 0;\n      setSmallSize(N);\n      setSmallBits(NewBits | getSmallBits());\n    } else {\n      BitVector *BV = new BitVector(N, t);\n      uintptr_t OldBits = getSmallBits();\n      for (size_t i = 0, e = getSmallSize(); i != e; ++i)\n        (*BV)[i] = (OldBits >> i) & 1;\n      switchToLarge(BV);\n    }\n  }\n\n  void reserve(unsigned N) {\n    if (isSmall()) {\n      if (N > SmallNumDataBits) {\n        uintptr_t OldBits = getSmallRawBits();\n        size_t SmallSize = getSmallSize();\n        BitVector *BV = new BitVector(SmallSize);\n        for (size_t i = 0; i < SmallSize; ++i)\n          if ((OldBits >> i) & 1)\n            BV->set(i);\n        BV->reserve(N);\n        switchToLarge(BV);\n      }\n    } else {\n      getPointer()->reserve(N);\n    }\n  }\n\n  // Set, reset, flip\n  SmallBitVector &set() {\n    if (isSmall())\n      setSmallBits(~uintptr_t(0));\n    else\n      getPointer()->set();\n    return *this;\n  }\n\n  SmallBitVector &set(unsigned Idx) {\n    if (isSmall()) {\n      assert(Idx <= static_cast<unsigned>(\n                        std::numeric_limits<uintptr_t>::digits) &&\n             \"undefined behavior\");\n      setSmallBits(getSmallBits() | (uintptr_t(1) << Idx));\n    }\n    else\n      getPointer()->set(Idx);\n    return *this;\n  }\n\n  /// Efficiently set a range of bits in [I, E)\n  SmallBitVector &set(unsigned I, unsigned E) {\n    assert(I <= E && \"Attempted to set backwards range!\");\n    assert(E <= size() && \"Attempted to set out-of-bounds range!\");\n    if (I == E) return *this;\n    if (isSmall()) {\n      uintptr_t EMask = ((uintptr_t)1) << E;\n      uintptr_t IMask = ((uintptr_t)1) << I;\n      uintptr_t Mask = EMask - IMask;\n      setSmallBits(getSmallBits() | Mask);\n    } else\n      getPointer()->set(I, E);\n    return *this;\n  }\n\n  SmallBitVector &reset() {\n    if (isSmall())\n      setSmallBits(0);\n    else\n      getPointer()->reset();\n    return *this;\n  }\n\n  SmallBitVector &reset(unsigned Idx) {\n    if (isSmall())\n      setSmallBits(getSmallBits() & ~(uintptr_t(1) << Idx));\n    else\n      getPointer()->reset(Idx);\n    return *this;\n  }\n\n  /// Efficiently reset a range of bits in [I, E)\n  SmallBitVector &reset(unsigned I, unsigned E) {\n    assert(I <= E && \"Attempted to reset backwards range!\");\n    assert(E <= size() && \"Attempted to reset out-of-bounds range!\");\n    if (I == E) return *this;\n    if (isSmall()) {\n      uintptr_t EMask = ((uintptr_t)1) << E;\n      uintptr_t IMask = ((uintptr_t)1) << I;\n      uintptr_t Mask = EMask - IMask;\n      setSmallBits(getSmallBits() & ~Mask);\n    } else\n      getPointer()->reset(I, E);\n    return *this;\n  }\n\n  SmallBitVector &flip() {\n    if (isSmall())\n      setSmallBits(~getSmallBits());\n    else\n      getPointer()->flip();\n    return *this;\n  }\n\n  SmallBitVector &flip(unsigned Idx) {\n    if (isSmall())\n      setSmallBits(getSmallBits() ^ (uintptr_t(1) << Idx));\n    else\n      getPointer()->flip(Idx);\n    return *this;\n  }\n\n  // No argument flip.\n  SmallBitVector operator~() const {\n    return SmallBitVector(*this).flip();\n  }\n\n  // Indexing.\n  reference operator[](unsigned Idx) {\n    assert(Idx < size() && \"Out-of-bounds Bit access.\");\n    return reference(*this, Idx);\n  }\n\n  bool operator[](unsigned Idx) const {\n    assert(Idx < size() && \"Out-of-bounds Bit access.\");\n    if (isSmall())\n      return ((getSmallBits() >> Idx) & 1) != 0;\n    return getPointer()->operator[](Idx);\n  }\n\n  bool test(unsigned Idx) const {\n    return (*this)[Idx];\n  }\n\n  // Push single bit to end of vector.\n  void push_back(bool Val) {\n    resize(size() + 1, Val);\n  }\n\n  /// Test if any common bits are set.\n  bool anyCommon(const SmallBitVector &RHS) const {\n    if (isSmall() && RHS.isSmall())\n      return (getSmallBits() & RHS.getSmallBits()) != 0;\n    if (!isSmall() && !RHS.isSmall())\n      return getPointer()->anyCommon(*RHS.getPointer());\n\n    for (unsigned i = 0, e = std::min(size(), RHS.size()); i != e; ++i)\n      if (test(i) && RHS.test(i))\n        return true;\n    return false;\n  }\n\n  // Comparison operators.\n  bool operator==(const SmallBitVector &RHS) const {\n    if (size() != RHS.size())\n      return false;\n    if (isSmall() && RHS.isSmall())\n      return getSmallBits() == RHS.getSmallBits();\n    else if (!isSmall() && !RHS.isSmall())\n      return *getPointer() == *RHS.getPointer();\n    else {\n      for (size_t i = 0, e = size(); i != e; ++i) {\n        if ((*this)[i] != RHS[i])\n          return false;\n      }\n      return true;\n    }\n  }\n\n  bool operator!=(const SmallBitVector &RHS) const {\n    return !(*this == RHS);\n  }\n\n  // Intersection, union, disjoint union.\n  // FIXME BitVector::operator&= does not resize the LHS but this does\n  SmallBitVector &operator&=(const SmallBitVector &RHS) {\n    resize(std::max(size(), RHS.size()));\n    if (isSmall() && RHS.isSmall())\n      setSmallBits(getSmallBits() & RHS.getSmallBits());\n    else if (!isSmall() && !RHS.isSmall())\n      getPointer()->operator&=(*RHS.getPointer());\n    else {\n      size_t i, e;\n      for (i = 0, e = std::min(size(), RHS.size()); i != e; ++i)\n        (*this)[i] = test(i) && RHS.test(i);\n      for (e = size(); i != e; ++i)\n        reset(i);\n    }\n    return *this;\n  }\n\n  /// Reset bits that are set in RHS. Same as *this &= ~RHS.\n  SmallBitVector &reset(const SmallBitVector &RHS) {\n    if (isSmall() && RHS.isSmall())\n      setSmallBits(getSmallBits() & ~RHS.getSmallBits());\n    else if (!isSmall() && !RHS.isSmall())\n      getPointer()->reset(*RHS.getPointer());\n    else\n      for (unsigned i = 0, e = std::min(size(), RHS.size()); i != e; ++i)\n        if (RHS.test(i))\n          reset(i);\n\n    return *this;\n  }\n\n  /// Check if (This - RHS) is zero. This is the same as reset(RHS) and any().\n  bool test(const SmallBitVector &RHS) const {\n    if (isSmall() && RHS.isSmall())\n      return (getSmallBits() & ~RHS.getSmallBits()) != 0;\n    if (!isSmall() && !RHS.isSmall())\n      return getPointer()->test(*RHS.getPointer());\n\n    unsigned i, e;\n    for (i = 0, e = std::min(size(), RHS.size()); i != e; ++i)\n      if (test(i) && !RHS.test(i))\n        return true;\n\n    for (e = size(); i != e; ++i)\n      if (test(i))\n        return true;\n\n    return false;\n  }\n\n  SmallBitVector &operator|=(const SmallBitVector &RHS) {\n    resize(std::max(size(), RHS.size()));\n    if (isSmall() && RHS.isSmall())\n      setSmallBits(getSmallBits() | RHS.getSmallBits());\n    else if (!isSmall() && !RHS.isSmall())\n      getPointer()->operator|=(*RHS.getPointer());\n    else {\n      for (size_t i = 0, e = RHS.size(); i != e; ++i)\n        (*this)[i] = test(i) || RHS.test(i);\n    }\n    return *this;\n  }\n\n  SmallBitVector &operator^=(const SmallBitVector &RHS) {\n    resize(std::max(size(), RHS.size()));\n    if (isSmall() && RHS.isSmall())\n      setSmallBits(getSmallBits() ^ RHS.getSmallBits());\n    else if (!isSmall() && !RHS.isSmall())\n      getPointer()->operator^=(*RHS.getPointer());\n    else {\n      for (size_t i = 0, e = RHS.size(); i != e; ++i)\n        (*this)[i] = test(i) != RHS.test(i);\n    }\n    return *this;\n  }\n\n  SmallBitVector &operator<<=(unsigned N) {\n    if (isSmall())\n      setSmallBits(getSmallBits() << N);\n    else\n      getPointer()->operator<<=(N);\n    return *this;\n  }\n\n  SmallBitVector &operator>>=(unsigned N) {\n    if (isSmall())\n      setSmallBits(getSmallBits() >> N);\n    else\n      getPointer()->operator>>=(N);\n    return *this;\n  }\n\n  // Assignment operator.\n  const SmallBitVector &operator=(const SmallBitVector &RHS) {\n    if (isSmall()) {\n      if (RHS.isSmall())\n        X = RHS.X;\n      else\n        switchToLarge(new BitVector(*RHS.getPointer()));\n    } else {\n      if (!RHS.isSmall())\n        *getPointer() = *RHS.getPointer();\n      else {\n        delete getPointer();\n        X = RHS.X;\n      }\n    }\n    return *this;\n  }\n\n  const SmallBitVector &operator=(SmallBitVector &&RHS) {\n    if (this != &RHS) {\n      clear();\n      swap(RHS);\n    }\n    return *this;\n  }\n\n  void swap(SmallBitVector &RHS) {\n    std::swap(X, RHS.X);\n  }\n\n  /// Add '1' bits from Mask to this vector. Don't resize.\n  /// This computes \"*this |= Mask\".\n  void setBitsInMask(const uint32_t *Mask, unsigned MaskWords = ~0u) {\n    if (isSmall())\n      applyMask<true, false>(Mask, MaskWords);\n    else\n      getPointer()->setBitsInMask(Mask, MaskWords);\n  }\n\n  /// Clear any bits in this vector that are set in Mask. Don't resize.\n  /// This computes \"*this &= ~Mask\".\n  void clearBitsInMask(const uint32_t *Mask, unsigned MaskWords = ~0u) {\n    if (isSmall())\n      applyMask<false, false>(Mask, MaskWords);\n    else\n      getPointer()->clearBitsInMask(Mask, MaskWords);\n  }\n\n  /// Add a bit to this vector for every '0' bit in Mask. Don't resize.\n  /// This computes \"*this |= ~Mask\".\n  void setBitsNotInMask(const uint32_t *Mask, unsigned MaskWords = ~0u) {\n    if (isSmall())\n      applyMask<true, true>(Mask, MaskWords);\n    else\n      getPointer()->setBitsNotInMask(Mask, MaskWords);\n  }\n\n  /// Clear a bit in this vector for every '0' bit in Mask. Don't resize.\n  /// This computes \"*this &= Mask\".\n  void clearBitsNotInMask(const uint32_t *Mask, unsigned MaskWords = ~0u) {\n    if (isSmall())\n      applyMask<false, true>(Mask, MaskWords);\n    else\n      getPointer()->clearBitsNotInMask(Mask, MaskWords);\n  }\n\n  void invalid() {\n    assert(empty());\n    X = (uintptr_t)-1;\n  }\n  bool isInvalid() const { return X == (uintptr_t)-1; }\n\n  ArrayRef<uintptr_t> getData(uintptr_t &Store) const {\n    if (!isSmall())\n      return getPointer()->getData();\n    Store = getSmallBits();\n    return makeArrayRef(Store);\n  }\n\nprivate:\n  template <bool AddBits, bool InvertMask>\n  void applyMask(const uint32_t *Mask, unsigned MaskWords) {\n    assert(MaskWords <= sizeof(uintptr_t) && \"Mask is larger than base!\");\n    uintptr_t M = Mask[0];\n    if (NumBaseBits == 64)\n      M |= uint64_t(Mask[1]) << 32;\n    if (InvertMask)\n      M = ~M;\n    if (AddBits)\n      setSmallBits(getSmallBits() | M);\n    else\n      setSmallBits(getSmallBits() & ~M);\n  }\n};\n\ninline SmallBitVector\noperator&(const SmallBitVector &LHS, const SmallBitVector &RHS) {\n  SmallBitVector Result(LHS);\n  Result &= RHS;\n  return Result;\n}\n\ninline SmallBitVector\noperator|(const SmallBitVector &LHS, const SmallBitVector &RHS) {\n  SmallBitVector Result(LHS);\n  Result |= RHS;\n  return Result;\n}\n\ninline SmallBitVector\noperator^(const SmallBitVector &LHS, const SmallBitVector &RHS) {\n  SmallBitVector Result(LHS);\n  Result ^= RHS;\n  return Result;\n}\n\ntemplate <> struct DenseMapInfo<SmallBitVector> {\n  static inline SmallBitVector getEmptyKey() { return SmallBitVector(); }\n  static inline SmallBitVector getTombstoneKey() {\n    SmallBitVector V;\n    V.invalid();\n    return V;\n  }\n  static unsigned getHashValue(const SmallBitVector &V) {\n    uintptr_t Store;\n    return DenseMapInfo<std::pair<unsigned, ArrayRef<uintptr_t>>>::getHashValue(\n        std::make_pair(V.size(), V.getData(Store)));\n  }\n  static bool isEqual(const SmallBitVector &LHS, const SmallBitVector &RHS) {\n    if (LHS.isInvalid() || RHS.isInvalid())\n      return LHS.isInvalid() == RHS.isInvalid();\n    return LHS == RHS;\n  }\n};\n} // end namespace llvm\n\nnamespace std {\n\n/// Implement std::swap in terms of BitVector swap.\ninline void\nswap(llvm::SmallBitVector &LHS, llvm::SmallBitVector &RHS) {\n  LHS.swap(RHS);\n}\n\n} // end namespace std\n\n#endif // LLVM_ADT_SMALLBITVECTOR_H\n"}, "42": {"id": 42, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringMap.h", "content": "//===- StringMap.h - String Hash table map interface ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the StringMap class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_STRINGMAP_H\n#define LLVM_ADT_STRINGMAP_H\n\n#include \"llvm/ADT/StringMapEntry.h\"\n#include \"llvm/Support/AllocatorBase.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include <initializer_list>\n#include <iterator>\n\nnamespace llvm {\n\ntemplate <typename ValueTy> class StringMapConstIterator;\ntemplate <typename ValueTy> class StringMapIterator;\ntemplate <typename ValueTy> class StringMapKeyIterator;\n\n/// StringMapImpl - This is the base class of StringMap that is shared among\n/// all of its instantiations.\nclass StringMapImpl {\nprotected:\n  // Array of NumBuckets pointers to entries, null pointers are holes.\n  // TheTable[NumBuckets] contains a sentinel value for easy iteration. Followed\n  // by an array of the actual hash values as unsigned integers.\n  StringMapEntryBase **TheTable = nullptr;\n  unsigned NumBuckets = 0;\n  unsigned NumItems = 0;\n  unsigned NumTombstones = 0;\n  unsigned ItemSize;\n\nprotected:\n  explicit StringMapImpl(unsigned itemSize) : ItemSize(itemSize) {}\n  StringMapImpl(StringMapImpl &&RHS)\n      : TheTable(RHS.TheTable), NumBuckets(RHS.NumBuckets),\n        NumItems(RHS.NumItems), NumTombstones(RHS.NumTombstones),\n        ItemSize(RHS.ItemSize) {\n    RHS.TheTable = nullptr;\n    RHS.NumBuckets = 0;\n    RHS.NumItems = 0;\n    RHS.NumTombstones = 0;\n  }\n\n  StringMapImpl(unsigned InitSize, unsigned ItemSize);\n  unsigned RehashTable(unsigned BucketNo = 0);\n\n  /// LookupBucketFor - Look up the bucket that the specified string should end\n  /// up in.  If it already exists as a key in the map, the Item pointer for the\n  /// specified bucket will be non-null.  Otherwise, it will be null.  In either\n  /// case, the FullHashValue field of the bucket will be set to the hash value\n  /// of the string.\n  unsigned LookupBucketFor(StringRef Key);\n\n  /// FindKey - Look up the bucket that contains the specified key. If it exists\n  /// in the map, return the bucket number of the key.  Otherwise return -1.\n  /// This does not modify the map.\n  int FindKey(StringRef Key) const;\n\n  /// RemoveKey - Remove the specified StringMapEntry from the table, but do not\n  /// delete it.  This aborts if the value isn't in the table.\n  void RemoveKey(StringMapEntryBase *V);\n\n  /// RemoveKey - Remove the StringMapEntry for the specified key from the\n  /// table, returning it.  If the key is not in the table, this returns null.\n  StringMapEntryBase *RemoveKey(StringRef Key);\n\n  /// Allocate the table with the specified number of buckets and otherwise\n  /// setup the map as empty.\n  void init(unsigned Size);\n\npublic:\n  static constexpr uintptr_t TombstoneIntVal =\n      static_cast<uintptr_t>(-1)\n      << PointerLikeTypeTraits<StringMapEntryBase *>::NumLowBitsAvailable;\n\n  static StringMapEntryBase *getTombstoneVal() {\n    return reinterpret_cast<StringMapEntryBase *>(TombstoneIntVal);\n  }\n\n  unsigned getNumBuckets() const { return NumBuckets; }\n  unsigned getNumItems() const { return NumItems; }\n\n  bool empty() const { return NumItems == 0; }\n  unsigned size() const { return NumItems; }\n\n  void swap(StringMapImpl &Other) {\n    std::swap(TheTable, Other.TheTable);\n    std::swap(NumBuckets, Other.NumBuckets);\n    std::swap(NumItems, Other.NumItems);\n    std::swap(NumTombstones, Other.NumTombstones);\n  }\n};\n\n/// StringMap - This is an unconventional map that is specialized for handling\n/// keys that are \"strings\", which are basically ranges of bytes. This does some\n/// funky memory allocation and hashing things to make it extremely efficient,\n/// storing the string data *after* the value in the map.\ntemplate <typename ValueTy, typename AllocatorTy = MallocAllocator>\nclass StringMap : public StringMapImpl {\n  AllocatorTy Allocator;\n\npublic:\n  using MapEntryTy = StringMapEntry<ValueTy>;\n\n  StringMap() : StringMapImpl(static_cast<unsigned>(sizeof(MapEntryTy))) {}\n\n  explicit StringMap(unsigned InitialSize)\n      : StringMapImpl(InitialSize, static_cast<unsigned>(sizeof(MapEntryTy))) {}\n\n  explicit StringMap(AllocatorTy A)\n      : StringMapImpl(static_cast<unsigned>(sizeof(MapEntryTy))), Allocator(A) {\n  }\n\n  StringMap(unsigned InitialSize, AllocatorTy A)\n      : StringMapImpl(InitialSize, static_cast<unsigned>(sizeof(MapEntryTy))),\n        Allocator(A) {}\n\n  StringMap(std::initializer_list<std::pair<StringRef, ValueTy>> List)\n      : StringMapImpl(List.size(), static_cast<unsigned>(sizeof(MapEntryTy))) {\n    for (const auto &P : List) {\n      insert(P);\n    }\n  }\n\n  StringMap(StringMap &&RHS)\n      : StringMapImpl(std::move(RHS)), Allocator(std::move(RHS.Allocator)) {}\n\n  StringMap(const StringMap &RHS)\n      : StringMapImpl(static_cast<unsigned>(sizeof(MapEntryTy))),\n        Allocator(RHS.Allocator) {\n    if (RHS.empty())\n      return;\n\n    // Allocate TheTable of the same size as RHS's TheTable, and set the\n    // sentinel appropriately (and NumBuckets).\n    init(RHS.NumBuckets);\n    unsigned *HashTable = (unsigned *)(TheTable + NumBuckets + 1),\n             *RHSHashTable = (unsigned *)(RHS.TheTable + NumBuckets + 1);\n\n    NumItems = RHS.NumItems;\n    NumTombstones = RHS.NumTombstones;\n    for (unsigned I = 0, E = NumBuckets; I != E; ++I) {\n      StringMapEntryBase *Bucket = RHS.TheTable[I];\n      if (!Bucket || Bucket == getTombstoneVal()) {\n        TheTable[I] = Bucket;\n        continue;\n      }\n\n      TheTable[I] = MapEntryTy::Create(\n          static_cast<MapEntryTy *>(Bucket)->getKey(), Allocator,\n          static_cast<MapEntryTy *>(Bucket)->getValue());\n      HashTable[I] = RHSHashTable[I];\n    }\n\n    // Note that here we've copied everything from the RHS into this object,\n    // tombstones included. We could, instead, have re-probed for each key to\n    // instantiate this new object without any tombstone buckets. The\n    // assumption here is that items are rarely deleted from most StringMaps,\n    // and so tombstones are rare, so the cost of re-probing for all inputs is\n    // not worthwhile.\n  }\n\n  StringMap &operator=(StringMap RHS) {\n    StringMapImpl::swap(RHS);\n    std::swap(Allocator, RHS.Allocator);\n    return *this;\n  }\n\n  ~StringMap() {\n    // Delete all the elements in the map, but don't reset the elements\n    // to default values.  This is a copy of clear(), but avoids unnecessary\n    // work not required in the destructor.\n    if (!empty()) {\n      for (unsigned I = 0, E = NumBuckets; I != E; ++I) {\n        StringMapEntryBase *Bucket = TheTable[I];\n        if (Bucket && Bucket != getTombstoneVal()) {\n          static_cast<MapEntryTy *>(Bucket)->Destroy(Allocator);\n        }\n      }\n    }\n    free(TheTable);\n  }\n\n  AllocatorTy &getAllocator() { return Allocator; }\n  const AllocatorTy &getAllocator() const { return Allocator; }\n\n  using key_type = const char *;\n  using mapped_type = ValueTy;\n  using value_type = StringMapEntry<ValueTy>;\n  using size_type = size_t;\n\n  using const_iterator = StringMapConstIterator<ValueTy>;\n  using iterator = StringMapIterator<ValueTy>;\n\n  iterator begin() { return iterator(TheTable, NumBuckets == 0); }\n  iterator end() { return iterator(TheTable + NumBuckets, true); }\n  const_iterator begin() const {\n    return const_iterator(TheTable, NumBuckets == 0);\n  }\n  const_iterator end() const {\n    return const_iterator(TheTable + NumBuckets, true);\n  }\n\n  iterator_range<StringMapKeyIterator<ValueTy>> keys() const {\n    return make_range(StringMapKeyIterator<ValueTy>(begin()),\n                      StringMapKeyIterator<ValueTy>(end()));\n  }\n\n  iterator find(StringRef Key) {\n    int Bucket = FindKey(Key);\n    if (Bucket == -1)\n      return end();\n    return iterator(TheTable + Bucket, true);\n  }\n\n  const_iterator find(StringRef Key) const {\n    int Bucket = FindKey(Key);\n    if (Bucket == -1)\n      return end();\n    return const_iterator(TheTable + Bucket, true);\n  }\n\n  /// lookup - Return the entry for the specified key, or a default\n  /// constructed value if no such entry exists.\n  ValueTy lookup(StringRef Key) const {\n    const_iterator it = find(Key);\n    if (it != end())\n      return it->second;\n    return ValueTy();\n  }\n\n  /// Lookup the ValueTy for the \\p Key, or create a default constructed value\n  /// if the key is not in the map.\n  ValueTy &operator[](StringRef Key) { return try_emplace(Key).first->second; }\n\n  /// count - Return 1 if the element is in the map, 0 otherwise.\n  size_type count(StringRef Key) const { return find(Key) == end() ? 0 : 1; }\n\n  template <typename InputTy>\n  size_type count(const StringMapEntry<InputTy> &MapEntry) const {\n    return count(MapEntry.getKey());\n  }\n\n  /// equal - check whether both of the containers are equal.\n  bool operator==(const StringMap &RHS) const {\n    if (size() != RHS.size())\n      return false;\n\n    for (const auto &KeyValue : *this) {\n      auto FindInRHS = RHS.find(KeyValue.getKey());\n\n      if (FindInRHS == RHS.end())\n        return false;\n\n      if (!(KeyValue.getValue() == FindInRHS->getValue()))\n        return false;\n    }\n\n    return true;\n  }\n\n  bool operator!=(const StringMap &RHS) const { return !(*this == RHS); }\n\n  /// insert - Insert the specified key/value pair into the map.  If the key\n  /// already exists in the map, return false and ignore the request, otherwise\n  /// insert it and return true.\n  bool insert(MapEntryTy *KeyValue) {\n    unsigned BucketNo = LookupBucketFor(KeyValue->getKey());\n    StringMapEntryBase *&Bucket = TheTable[BucketNo];\n    if (Bucket && Bucket != getTombstoneVal())\n      return false; // Already exists in map.\n\n    if (Bucket == getTombstoneVal())\n      --NumTombstones;\n    Bucket = KeyValue;\n    ++NumItems;\n    assert(NumItems + NumTombstones <= NumBuckets);\n\n    RehashTable();\n    return true;\n  }\n\n  /// insert - Inserts the specified key/value pair into the map if the key\n  /// isn't already in the map. The bool component of the returned pair is true\n  /// if and only if the insertion takes place, and the iterator component of\n  /// the pair points to the element with key equivalent to the key of the pair.\n  std::pair<iterator, bool> insert(std::pair<StringRef, ValueTy> KV) {\n    return try_emplace(KV.first, std::move(KV.second));\n  }\n\n  /// Inserts an element or assigns to the current element if the key already\n  /// exists. The return type is the same as try_emplace.\n  template <typename V>\n  std::pair<iterator, bool> insert_or_assign(StringRef Key, V &&Val) {\n    auto Ret = try_emplace(Key, std::forward<V>(Val));\n    if (!Ret.second)\n      Ret.first->second = std::forward<V>(Val);\n    return Ret;\n  }\n\n  /// Emplace a new element for the specified key into the map if the key isn't\n  /// already in the map. The bool component of the returned pair is true\n  /// if and only if the insertion takes place, and the iterator component of\n  /// the pair points to the element with key equivalent to the key of the pair.\n  template <typename... ArgsTy>\n  std::pair<iterator, bool> try_emplace(StringRef Key, ArgsTy &&... Args) {\n    unsigned BucketNo = LookupBucketFor(Key);\n    StringMapEntryBase *&Bucket = TheTable[BucketNo];\n    if (Bucket && Bucket != getTombstoneVal())\n      return std::make_pair(iterator(TheTable + BucketNo, false),\n                            false); // Already exists in map.\n\n    if (Bucket == getTombstoneVal())\n      --NumTombstones;\n    Bucket = MapEntryTy::Create(Key, Allocator, std::forward<ArgsTy>(Args)...);\n    ++NumItems;\n    assert(NumItems + NumTombstones <= NumBuckets);\n\n    BucketNo = RehashTable(BucketNo);\n    return std::make_pair(iterator(TheTable + BucketNo, false), true);\n  }\n\n  // clear - Empties out the StringMap\n  void clear() {\n    if (empty())\n      return;\n\n    // Zap all values, resetting the keys back to non-present (not tombstone),\n    // which is safe because we're removing all elements.\n    for (unsigned I = 0, E = NumBuckets; I != E; ++I) {\n      StringMapEntryBase *&Bucket = TheTable[I];\n      if (Bucket && Bucket != getTombstoneVal()) {\n        static_cast<MapEntryTy *>(Bucket)->Destroy(Allocator);\n      }\n      Bucket = nullptr;\n    }\n\n    NumItems = 0;\n    NumTombstones = 0;\n  }\n\n  /// remove - Remove the specified key/value pair from the map, but do not\n  /// erase it.  This aborts if the key is not in the map.\n  void remove(MapEntryTy *KeyValue) { RemoveKey(KeyValue); }\n\n  void erase(iterator I) {\n    MapEntryTy &V = *I;\n    remove(&V);\n    V.Destroy(Allocator);\n  }\n\n  bool erase(StringRef Key) {\n    iterator I = find(Key);\n    if (I == end())\n      return false;\n    erase(I);\n    return true;\n  }\n};\n\ntemplate <typename DerivedTy, typename ValueTy>\nclass StringMapIterBase\n    : public iterator_facade_base<DerivedTy, std::forward_iterator_tag,\n                                  ValueTy> {\nprotected:\n  StringMapEntryBase **Ptr = nullptr;\n\npublic:\n  StringMapIterBase() = default;\n\n  explicit StringMapIterBase(StringMapEntryBase **Bucket,\n                             bool NoAdvance = false)\n      : Ptr(Bucket) {\n    if (!NoAdvance)\n      AdvancePastEmptyBuckets();\n  }\n\n  DerivedTy &operator=(const DerivedTy &Other) {\n    Ptr = Other.Ptr;\n    return static_cast<DerivedTy &>(*this);\n  }\n\n  friend bool operator==(const DerivedTy &LHS, const DerivedTy &RHS) {\n    return LHS.Ptr == RHS.Ptr;\n  }\n\n  DerivedTy &operator++() { // Preincrement\n    ++Ptr;\n    AdvancePastEmptyBuckets();\n    return static_cast<DerivedTy &>(*this);\n  }\n\n  DerivedTy operator++(int) { // Post-increment\n    DerivedTy Tmp(Ptr);\n    ++*this;\n    return Tmp;\n  }\n\nprivate:\n  void AdvancePastEmptyBuckets() {\n    while (*Ptr == nullptr || *Ptr == StringMapImpl::getTombstoneVal())\n      ++Ptr;\n  }\n};\n\ntemplate <typename ValueTy>\nclass StringMapConstIterator\n    : public StringMapIterBase<StringMapConstIterator<ValueTy>,\n                               const StringMapEntry<ValueTy>> {\n  using base = StringMapIterBase<StringMapConstIterator<ValueTy>,\n                                 const StringMapEntry<ValueTy>>;\n\npublic:\n  StringMapConstIterator() = default;\n  explicit StringMapConstIterator(StringMapEntryBase **Bucket,\n                                  bool NoAdvance = false)\n      : base(Bucket, NoAdvance) {}\n\n  const StringMapEntry<ValueTy> &operator*() const {\n    return *static_cast<const StringMapEntry<ValueTy> *>(*this->Ptr);\n  }\n};\n\ntemplate <typename ValueTy>\nclass StringMapIterator : public StringMapIterBase<StringMapIterator<ValueTy>,\n                                                   StringMapEntry<ValueTy>> {\n  using base =\n      StringMapIterBase<StringMapIterator<ValueTy>, StringMapEntry<ValueTy>>;\n\npublic:\n  StringMapIterator() = default;\n  explicit StringMapIterator(StringMapEntryBase **Bucket,\n                             bool NoAdvance = false)\n      : base(Bucket, NoAdvance) {}\n\n  StringMapEntry<ValueTy> &operator*() const {\n    return *static_cast<StringMapEntry<ValueTy> *>(*this->Ptr);\n  }\n\n  operator StringMapConstIterator<ValueTy>() const {\n    return StringMapConstIterator<ValueTy>(this->Ptr, true);\n  }\n};\n\ntemplate <typename ValueTy>\nclass StringMapKeyIterator\n    : public iterator_adaptor_base<StringMapKeyIterator<ValueTy>,\n                                   StringMapConstIterator<ValueTy>,\n                                   std::forward_iterator_tag, StringRef> {\n  using base = iterator_adaptor_base<StringMapKeyIterator<ValueTy>,\n                                     StringMapConstIterator<ValueTy>,\n                                     std::forward_iterator_tag, StringRef>;\n\npublic:\n  StringMapKeyIterator() = default;\n  explicit StringMapKeyIterator(StringMapConstIterator<ValueTy> Iter)\n      : base(std::move(Iter)) {}\n\n  StringRef &operator*() {\n    Key = this->wrapped()->getKey();\n    return Key;\n  }\n\nprivate:\n  StringRef Key;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_STRINGMAP_H\n"}, "50": {"id": 50, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "content": "//===--- JSON.h - JSON values, parsing and serialization -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===---------------------------------------------------------------------===//\n///\n/// \\file\n/// This file supports working with JSON data.\n///\n/// It comprises:\n///\n/// - classes which hold dynamically-typed parsed JSON structures\n///   These are value types that can be composed, inspected, and modified.\n///   See json::Value, and the related types json::Object and json::Array.\n///\n/// - functions to parse JSON text into Values, and to serialize Values to text.\n///   See parse(), operator<<, and format_provider.\n///\n/// - a convention and helpers for mapping between json::Value and user-defined\n///   types. See fromJSON(), ObjectMapper, and the class comment on Value.\n///\n/// - an output API json::OStream which can emit JSON without materializing\n///   all structures as json::Value.\n///\n/// Typically, JSON data would be read from an external source, parsed into\n/// a Value, and then converted into some native data structure before doing\n/// real work on it. (And vice versa when writing).\n///\n/// Other serialization mechanisms you may consider:\n///\n/// - YAML is also text-based, and more human-readable than JSON. It's a more\n///   complex format and data model, and YAML parsers aren't ubiquitous.\n///   YAMLParser.h is a streaming parser suitable for parsing large documents\n///   (including JSON, as YAML is a superset). It can be awkward to use\n///   directly. YAML I/O (YAMLTraits.h) provides data mapping that is more\n///   declarative than the toJSON/fromJSON conventions here.\n///\n/// - LLVM bitstream is a space- and CPU- efficient binary format. Typically it\n///   encodes LLVM IR (\"bitcode\"), but it can be a container for other data.\n///   Low-level reader/writer libraries are in Bitstream/Bitstream*.h\n///\n//===---------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_JSON_H\n#define LLVM_SUPPORT_JSON_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/FormatVariadic.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <map>\n\nnamespace llvm {\nnamespace json {\n\n// === String encodings ===\n//\n// JSON strings are character sequences (not byte sequences like std::string).\n// We need to know the encoding, and for simplicity only support UTF-8.\n//\n//   - When parsing, invalid UTF-8 is a syntax error like any other\n//\n//   - When creating Values from strings, callers must ensure they are UTF-8.\n//        with asserts on, invalid UTF-8 will crash the program\n//        with asserts off, we'll substitute the replacement character (U+FFFD)\n//     Callers can use json::isUTF8() and json::fixUTF8() for validation.\n//\n//   - When retrieving strings from Values (e.g. asString()), the result will\n//     always be valid UTF-8.\n\n/// Returns true if \\p S is valid UTF-8, which is required for use as JSON.\n/// If it returns false, \\p Offset is set to a byte offset near the first error.\nbool isUTF8(llvm::StringRef S, size_t *ErrOffset = nullptr);\n/// Replaces invalid UTF-8 sequences in \\p S with the replacement character\n/// (U+FFFD). The returned string is valid UTF-8.\n/// This is much slower than isUTF8, so test that first.\nstd::string fixUTF8(llvm::StringRef S);\n\nclass Array;\nclass ObjectKey;\nclass Value;\ntemplate <typename T> Value toJSON(const llvm::Optional<T> &Opt);\n\n/// An Object is a JSON object, which maps strings to heterogenous JSON values.\n/// It simulates DenseMap<ObjectKey, Value>. ObjectKey is a maybe-owned string.\nclass Object {\n  using Storage = DenseMap<ObjectKey, Value, llvm::DenseMapInfo<StringRef>>;\n  Storage M;\n\npublic:\n  using key_type = ObjectKey;\n  using mapped_type = Value;\n  using value_type = Storage::value_type;\n  using iterator = Storage::iterator;\n  using const_iterator = Storage::const_iterator;\n\n  Object() = default;\n  // KV is a trivial key-value struct for list-initialization.\n  // (using std::pair forces extra copies).\n  struct KV;\n  explicit Object(std::initializer_list<KV> Properties);\n\n  iterator begin() { return M.begin(); }\n  const_iterator begin() const { return M.begin(); }\n  iterator end() { return M.end(); }\n  const_iterator end() const { return M.end(); }\n\n  bool empty() const { return M.empty(); }\n  size_t size() const { return M.size(); }\n\n  void clear() { M.clear(); }\n  std::pair<iterator, bool> insert(KV E);\n  template <typename... Ts>\n  std::pair<iterator, bool> try_emplace(const ObjectKey &K, Ts &&... Args) {\n    return M.try_emplace(K, std::forward<Ts>(Args)...);\n  }\n  template <typename... Ts>\n  std::pair<iterator, bool> try_emplace(ObjectKey &&K, Ts &&... Args) {\n    return M.try_emplace(std::move(K), std::forward<Ts>(Args)...);\n  }\n  bool erase(StringRef K);\n  void erase(iterator I) { M.erase(I); }\n\n  iterator find(StringRef K) { return M.find_as(K); }\n  const_iterator find(StringRef K) const { return M.find_as(K); }\n  // operator[] acts as if Value was default-constructible as null.\n  Value &operator[](const ObjectKey &K);\n  Value &operator[](ObjectKey &&K);\n  // Look up a property, returning nullptr if it doesn't exist.\n  Value *get(StringRef K);\n  const Value *get(StringRef K) const;\n  // Typed accessors return None/nullptr if\n  //   - the property doesn't exist\n  //   - or it has the wrong type\n  llvm::Optional<std::nullptr_t> getNull(StringRef K) const;\n  llvm::Optional<bool> getBoolean(StringRef K) const;\n  llvm::Optional<double> getNumber(StringRef K) const;\n  llvm::Optional<int64_t> getInteger(StringRef K) const;\n  llvm::Optional<llvm::StringRef> getString(StringRef K) const;\n  const json::Object *getObject(StringRef K) const;\n  json::Object *getObject(StringRef K);\n  const json::Array *getArray(StringRef K) const;\n  json::Array *getArray(StringRef K);\n};\nbool operator==(const Object &LHS, const Object &RHS);\ninline bool operator!=(const Object &LHS, const Object &RHS) {\n  return !(LHS == RHS);\n}\n\n/// An Array is a JSON array, which contains heterogeneous JSON values.\n/// It simulates std::vector<Value>.\nclass Array {\n  std::vector<Value> V;\n\npublic:\n  using value_type = Value;\n  using iterator = std::vector<Value>::iterator;\n  using const_iterator = std::vector<Value>::const_iterator;\n\n  Array() = default;\n  explicit Array(std::initializer_list<Value> Elements);\n  template <typename Collection> explicit Array(const Collection &C) {\n    for (const auto &V : C)\n      emplace_back(V);\n  }\n\n  Value &operator[](size_t I) { return V[I]; }\n  const Value &operator[](size_t I) const { return V[I]; }\n  Value &front() { return V.front(); }\n  const Value &front() const { return V.front(); }\n  Value &back() { return V.back(); }\n  const Value &back() const { return V.back(); }\n  Value *data() { return V.data(); }\n  const Value *data() const { return V.data(); }\n\n  iterator begin() { return V.begin(); }\n  const_iterator begin() const { return V.begin(); }\n  iterator end() { return V.end(); }\n  const_iterator end() const { return V.end(); }\n\n  bool empty() const { return V.empty(); }\n  size_t size() const { return V.size(); }\n  void reserve(size_t S) { V.reserve(S); }\n\n  void clear() { V.clear(); }\n  void push_back(const Value &E) { V.push_back(E); }\n  void push_back(Value &&E) { V.push_back(std::move(E)); }\n  template <typename... Args> void emplace_back(Args &&... A) {\n    V.emplace_back(std::forward<Args>(A)...);\n  }\n  void pop_back() { V.pop_back(); }\n  // FIXME: insert() takes const_iterator since C++11, old libstdc++ disagrees.\n  iterator insert(iterator P, const Value &E) { return V.insert(P, E); }\n  iterator insert(iterator P, Value &&E) {\n    return V.insert(P, std::move(E));\n  }\n  template <typename It> iterator insert(iterator P, It A, It Z) {\n    return V.insert(P, A, Z);\n  }\n  template <typename... Args> iterator emplace(const_iterator P, Args &&... A) {\n    return V.emplace(P, std::forward<Args>(A)...);\n  }\n\n  friend bool operator==(const Array &L, const Array &R) { return L.V == R.V; }\n};\ninline bool operator!=(const Array &L, const Array &R) { return !(L == R); }\n\n/// A Value is an JSON value of unknown type.\n/// They can be copied, but should generally be moved.\n///\n/// === Composing values ===\n///\n/// You can implicitly construct Values from:\n///   - strings: std::string, SmallString, formatv, StringRef, char*\n///              (char*, and StringRef are references, not copies!)\n///   - numbers\n///   - booleans\n///   - null: nullptr\n///   - arrays: {\"foo\", 42.0, false}\n///   - serializable things: types with toJSON(const T&)->Value, found by ADL\n///\n/// They can also be constructed from object/array helpers:\n///   - json::Object is a type like map<ObjectKey, Value>\n///   - json::Array is a type like vector<Value>\n/// These can be list-initialized, or used to build up collections in a loop.\n/// json::ary(Collection) converts all items in a collection to Values.\n///\n/// === Inspecting values ===\n///\n/// Each Value is one of the JSON kinds:\n///   null    (nullptr_t)\n///   boolean (bool)\n///   number  (double or int64)\n///   string  (StringRef)\n///   array   (json::Array)\n///   object  (json::Object)\n///\n/// The kind can be queried directly, or implicitly via the typed accessors:\n///   if (Optional<StringRef> S = E.getAsString()\n///     assert(E.kind() == Value::String);\n///\n/// Array and Object also have typed indexing accessors for easy traversal:\n///   Expected<Value> E = parse(R\"( {\"options\": {\"font\": \"sans-serif\"}} )\");\n///   if (Object* O = E->getAsObject())\n///     if (Object* Opts = O->getObject(\"options\"))\n///       if (Optional<StringRef> Font = Opts->getString(\"font\"))\n///         assert(Opts->at(\"font\").kind() == Value::String);\n///\n/// === Converting JSON values to C++ types ===\n///\n/// The convention is to have a deserializer function findable via ADL:\n///     fromJSON(const json::Value&, T&, Path) -> bool\n///\n/// The return value indicates overall success, and Path is used for precise\n/// error reporting. (The Path::Root passed in at the top level fromJSON call\n/// captures any nested error and can render it in context).\n/// If conversion fails, fromJSON calls Path::report() and immediately returns.\n/// This ensures that the first fatal error survives.\n///\n/// Deserializers are provided for:\n///   - bool\n///   - int and int64_t\n///   - double\n///   - std::string\n///   - vector<T>, where T is deserializable\n///   - map<string, T>, where T is deserializable\n///   - Optional<T>, where T is deserializable\n/// ObjectMapper can help writing fromJSON() functions for object types.\n///\n/// For conversion in the other direction, the serializer function is:\n///    toJSON(const T&) -> json::Value\n/// If this exists, then it also allows constructing Value from T, and can\n/// be used to serialize vector<T>, map<string, T>, and Optional<T>.\n///\n/// === Serialization ===\n///\n/// Values can be serialized to JSON:\n///   1) raw_ostream << Value                    // Basic formatting.\n///   2) raw_ostream << formatv(\"{0}\", Value)    // Basic formatting.\n///   3) raw_ostream << formatv(\"{0:2}\", Value)  // Pretty-print with indent 2.\n///\n/// And parsed:\n///   Expected<Value> E = json::parse(\"[1, 2, null]\");\n///   assert(E && E->kind() == Value::Array);\nclass Value {\npublic:\n  enum Kind {\n    Null,\n    Boolean,\n    /// Number values can store both int64s and doubles at full precision,\n    /// depending on what they were constructed/parsed from.\n    Number,\n    String,\n    Array,\n    Object,\n  };\n\n  // It would be nice to have Value() be null. But that would make {} null too.\n  Value(const Value &M) { copyFrom(M); }\n  Value(Value &&M) { moveFrom(std::move(M)); }\n  Value(std::initializer_list<Value> Elements);\n  Value(json::Array &&Elements) : Type(T_Array) {\n    create<json::Array>(std::move(Elements));\n  }\n  template <typename Elt>\n  Value(const std::vector<Elt> &C) : Value(json::Array(C)) {}\n  Value(json::Object &&Properties) : Type(T_Object) {\n    create<json::Object>(std::move(Properties));\n  }\n  template <typename Elt>\n  Value(const std::map<std::string, Elt> &C) : Value(json::Object(C)) {}\n  // Strings: types with value semantics. Must be valid UTF-8.\n  Value(std::string V) : Type(T_String) {\n    if (LLVM_UNLIKELY(!isUTF8(V))) {\n      assert(false && \"Invalid UTF-8 in value used as JSON\");\n      V = fixUTF8(std::move(V));\n    }\n    create<std::string>(std::move(V));\n  }\n  Value(const llvm::SmallVectorImpl<char> &V)\n      : Value(std::string(V.begin(), V.end())) {}\n  Value(const llvm::formatv_object_base &V) : Value(V.str()) {}\n  // Strings: types with reference semantics. Must be valid UTF-8.\n  Value(StringRef V) : Type(T_StringRef) {\n    create<llvm::StringRef>(V);\n    if (LLVM_UNLIKELY(!isUTF8(V))) {\n      assert(false && \"Invalid UTF-8 in value used as JSON\");\n      *this = Value(fixUTF8(V));\n    }\n  }\n  Value(const char *V) : Value(StringRef(V)) {}\n  Value(std::nullptr_t) : Type(T_Null) {}\n  // Boolean (disallow implicit conversions).\n  // (The last template parameter is a dummy to keep templates distinct.)\n  template <typename T,\n            typename = std::enable_if_t<std::is_same<T, bool>::value>,\n            bool = false>\n  Value(T B) : Type(T_Boolean) {\n    create<bool>(B);\n  }\n  // Integers (except boolean). Must be non-narrowing convertible to int64_t.\n  template <typename T, typename = std::enable_if_t<std::is_integral<T>::value>,\n            typename = std::enable_if_t<!std::is_same<T, bool>::value>>\n  Value(T I) : Type(T_Integer) {\n    create<int64_t>(int64_t{I});\n  }\n  // Floating point. Must be non-narrowing convertible to double.\n  template <typename T,\n            typename = std::enable_if_t<std::is_floating_point<T>::value>,\n            double * = nullptr>\n  Value(T D) : Type(T_Double) {\n    create<double>(double{D});\n  }\n  // Serializable types: with a toJSON(const T&)->Value function, found by ADL.\n  template <typename T,\n            typename = std::enable_if_t<std::is_same<\n                Value, decltype(toJSON(*(const T *)nullptr))>::value>,\n            Value * = nullptr>\n  Value(const T &V) : Value(toJSON(V)) {}\n\n  Value &operator=(const Value &M) {\n    destroy();\n    copyFrom(M);\n    return *this;\n  }\n  Value &operator=(Value &&M) {\n    destroy();\n    moveFrom(std::move(M));\n    return *this;\n  }\n  ~Value() { destroy(); }\n\n  Kind kind() const {\n    switch (Type) {\n    case T_Null:\n      return Null;\n    case T_Boolean:\n      return Boolean;\n    case T_Double:\n    case T_Integer:\n      return Number;\n    case T_String:\n    case T_StringRef:\n      return String;\n    case T_Object:\n      return Object;\n    case T_Array:\n      return Array;\n    }\n    llvm_unreachable(\"Unknown kind\");\n  }\n\n  // Typed accessors return None/nullptr if the Value is not of this type.\n  llvm::Optional<std::nullptr_t> getAsNull() const {\n    if (LLVM_LIKELY(Type == T_Null))\n      return nullptr;\n    return llvm::None;\n  }\n  llvm::Optional<bool> getAsBoolean() const {\n    if (LLVM_LIKELY(Type == T_Boolean))\n      return as<bool>();\n    return llvm::None;\n  }\n  llvm::Optional<double> getAsNumber() const {\n    if (LLVM_LIKELY(Type == T_Double))\n      return as<double>();\n    if (LLVM_LIKELY(Type == T_Integer))\n      return as<int64_t>();\n    return llvm::None;\n  }\n  // Succeeds if the Value is a Number, and exactly representable as int64_t.\n  llvm::Optional<int64_t> getAsInteger() const {\n    if (LLVM_LIKELY(Type == T_Integer))\n      return as<int64_t>();\n    if (LLVM_LIKELY(Type == T_Double)) {\n      double D = as<double>();\n      if (LLVM_LIKELY(std::modf(D, &D) == 0.0 &&\n                      D >= double(std::numeric_limits<int64_t>::min()) &&\n                      D <= double(std::numeric_limits<int64_t>::max())))\n        return D;\n    }\n    return llvm::None;\n  }\n  llvm::Optional<llvm::StringRef> getAsString() const {\n    if (Type == T_String)\n      return llvm::StringRef(as<std::string>());\n    if (LLVM_LIKELY(Type == T_StringRef))\n      return as<llvm::StringRef>();\n    return llvm::None;\n  }\n  const json::Object *getAsObject() const {\n    return LLVM_LIKELY(Type == T_Object) ? &as<json::Object>() : nullptr;\n  }\n  json::Object *getAsObject() {\n    return LLVM_LIKELY(Type == T_Object) ? &as<json::Object>() : nullptr;\n  }\n  const json::Array *getAsArray() const {\n    return LLVM_LIKELY(Type == T_Array) ? &as<json::Array>() : nullptr;\n  }\n  json::Array *getAsArray() {\n    return LLVM_LIKELY(Type == T_Array) ? &as<json::Array>() : nullptr;\n  }\n\nprivate:\n  void destroy();\n  void copyFrom(const Value &M);\n  // We allow moving from *const* Values, by marking all members as mutable!\n  // This hack is needed to support initializer-list syntax efficiently.\n  // (std::initializer_list<T> is a container of const T).\n  void moveFrom(const Value &&M);\n  friend class Array;\n  friend class Object;\n\n  template <typename T, typename... U> void create(U &&... V) {\n    new (reinterpret_cast<T *>(&Union)) T(std::forward<U>(V)...);\n  }\n  template <typename T> T &as() const {\n    // Using this two-step static_cast via void * instead of reinterpret_cast\n    // silences a -Wstrict-aliasing false positive from GCC6 and earlier.\n    void *Storage = static_cast<void *>(&Union);\n    return *static_cast<T *>(Storage);\n  }\n\n  friend class OStream;\n\n  enum ValueType : char {\n    T_Null,\n    T_Boolean,\n    T_Double,\n    T_Integer,\n    T_StringRef,\n    T_String,\n    T_Object,\n    T_Array,\n  };\n  // All members mutable, see moveFrom().\n  mutable ValueType Type;\n  mutable llvm::AlignedCharArrayUnion<bool, double, int64_t, llvm::StringRef,\n                                      std::string, json::Array, json::Object>\n      Union;\n  friend bool operator==(const Value &, const Value &);\n};\n\nbool operator==(const Value &, const Value &);\ninline bool operator!=(const Value &L, const Value &R) { return !(L == R); }\n\n/// ObjectKey is a used to capture keys in Object. Like Value but:\n///   - only strings are allowed\n///   - it's optimized for the string literal case (Owned == nullptr)\n/// Like Value, strings must be UTF-8. See isUTF8 documentation for details.\nclass ObjectKey {\npublic:\n  ObjectKey(const char *S) : ObjectKey(StringRef(S)) {}\n  ObjectKey(std::string S) : Owned(new std::string(std::move(S))) {\n    if (LLVM_UNLIKELY(!isUTF8(*Owned))) {\n      assert(false && \"Invalid UTF-8 in value used as JSON\");\n      *Owned = fixUTF8(std::move(*Owned));\n    }\n    Data = *Owned;\n  }\n  ObjectKey(llvm::StringRef S) : Data(S) {\n    if (LLVM_UNLIKELY(!isUTF8(Data))) {\n      assert(false && \"Invalid UTF-8 in value used as JSON\");\n      *this = ObjectKey(fixUTF8(S));\n    }\n  }\n  ObjectKey(const llvm::SmallVectorImpl<char> &V)\n      : ObjectKey(std::string(V.begin(), V.end())) {}\n  ObjectKey(const llvm::formatv_object_base &V) : ObjectKey(V.str()) {}\n\n  ObjectKey(const ObjectKey &C) { *this = C; }\n  ObjectKey(ObjectKey &&C) : ObjectKey(static_cast<const ObjectKey &&>(C)) {}\n  ObjectKey &operator=(const ObjectKey &C) {\n    if (C.Owned) {\n      Owned.reset(new std::string(*C.Owned));\n      Data = *Owned;\n    } else {\n      Data = C.Data;\n    }\n    return *this;\n  }\n  ObjectKey &operator=(ObjectKey &&) = default;\n\n  operator llvm::StringRef() const { return Data; }\n  std::string str() const { return Data.str(); }\n\nprivate:\n  // FIXME: this is unneccesarily large (3 pointers). Pointer + length + owned\n  // could be 2 pointers at most.\n  std::unique_ptr<std::string> Owned;\n  llvm::StringRef Data;\n};\n\ninline bool operator==(const ObjectKey &L, const ObjectKey &R) {\n  return llvm::StringRef(L) == llvm::StringRef(R);\n}\ninline bool operator!=(const ObjectKey &L, const ObjectKey &R) {\n  return !(L == R);\n}\ninline bool operator<(const ObjectKey &L, const ObjectKey &R) {\n  return StringRef(L) < StringRef(R);\n}\n\nstruct Object::KV {\n  ObjectKey K;\n  Value V;\n};\n\ninline Object::Object(std::initializer_list<KV> Properties) {\n  for (const auto &P : Properties) {\n    auto R = try_emplace(P.K, nullptr);\n    if (R.second)\n      R.first->getSecond().moveFrom(std::move(P.V));\n  }\n}\ninline std::pair<Object::iterator, bool> Object::insert(KV E) {\n  return try_emplace(std::move(E.K), std::move(E.V));\n}\ninline bool Object::erase(StringRef K) {\n  return M.erase(ObjectKey(K));\n}\n\n/// A \"cursor\" marking a position within a Value.\n/// The Value is a tree, and this is the path from the root to the current node.\n/// This is used to associate errors with particular subobjects.\nclass Path {\npublic:\n  class Root;\n\n  /// Records that the value at the current path is invalid.\n  /// Message is e.g. \"expected number\" and becomes part of the final error.\n  /// This overwrites any previously written error message in the root.\n  void report(llvm::StringLiteral Message);\n\n  /// The root may be treated as a Path.\n  Path(Root &R) : Parent(nullptr), Seg(&R) {}\n  /// Derives a path for an array element: this[Index]\n  Path index(unsigned Index) const { return Path(this, Segment(Index)); }\n  /// Derives a path for an object field: this.Field\n  Path field(StringRef Field) const { return Path(this, Segment(Field)); }\n\nprivate:\n  /// One element in a JSON path: an object field (.foo) or array index [27].\n  /// Exception: the root Path encodes a pointer to the Path::Root.\n  class Segment {\n    uintptr_t Pointer;\n    unsigned Offset;\n\n  public:\n    Segment() = default;\n    Segment(Root *R) : Pointer(reinterpret_cast<uintptr_t>(R)) {}\n    Segment(llvm::StringRef Field)\n        : Pointer(reinterpret_cast<uintptr_t>(Field.data())),\n          Offset(static_cast<unsigned>(Field.size())) {}\n    Segment(unsigned Index) : Pointer(0), Offset(Index) {}\n\n    bool isField() const { return Pointer != 0; }\n    StringRef field() const {\n      return StringRef(reinterpret_cast<const char *>(Pointer), Offset);\n    }\n    unsigned index() const { return Offset; }\n    Root *root() const { return reinterpret_cast<Root *>(Pointer); }\n  };\n\n  const Path *Parent;\n  Segment Seg;\n\n  Path(const Path *Parent, Segment S) : Parent(Parent), Seg(S) {}\n};\n\n/// The root is the trivial Path to the root value.\n/// It also stores the latest reported error and the path where it occurred.\nclass Path::Root {\n  llvm::StringRef Name;\n  llvm::StringLiteral ErrorMessage;\n  std::vector<Path::Segment> ErrorPath; // Only valid in error state. Reversed.\n\n  friend void Path::report(llvm::StringLiteral Message);\n\npublic:\n  Root(llvm::StringRef Name = \"\") : Name(Name), ErrorMessage(\"\") {}\n  // No copy/move allowed as there are incoming pointers.\n  Root(Root &&) = delete;\n  Root &operator=(Root &&) = delete;\n  Root(const Root &) = delete;\n  Root &operator=(const Root &) = delete;\n\n  /// Returns the last error reported, or else a generic error.\n  Error getError() const;\n  /// Print the root value with the error shown inline as a comment.\n  /// Unrelated parts of the value are elided for brevity, e.g.\n  ///   {\n  ///      \"id\": 42,\n  ///      \"name\": /* expected string */ null,\n  ///      \"properties\": { ... }\n  ///   }\n  void printErrorContext(const Value &, llvm::raw_ostream &) const;\n};\n\n// Standard deserializers are provided for primitive types.\n// See comments on Value.\ninline bool fromJSON(const Value &E, std::string &Out, Path P) {\n  if (auto S = E.getAsString()) {\n    Out = std::string(*S);\n    return true;\n  }\n  P.report(\"expected string\");\n  return false;\n}\ninline bool fromJSON(const Value &E, int &Out, Path P) {\n  if (auto S = E.getAsInteger()) {\n    Out = *S;\n    return true;\n  }\n  P.report(\"expected integer\");\n  return false;\n}\ninline bool fromJSON(const Value &E, int64_t &Out, Path P) {\n  if (auto S = E.getAsInteger()) {\n    Out = *S;\n    return true;\n  }\n  P.report(\"expected integer\");\n  return false;\n}\ninline bool fromJSON(const Value &E, double &Out, Path P) {\n  if (auto S = E.getAsNumber()) {\n    Out = *S;\n    return true;\n  }\n  P.report(\"expected number\");\n  return false;\n}\ninline bool fromJSON(const Value &E, bool &Out, Path P) {\n  if (auto S = E.getAsBoolean()) {\n    Out = *S;\n    return true;\n  }\n  P.report(\"expected boolean\");\n  return false;\n}\ninline bool fromJSON(const Value &E, std::nullptr_t &Out, Path P) {\n  if (auto S = E.getAsNull()) {\n    Out = *S;\n    return true;\n  }\n  P.report(\"expected null\");\n  return false;\n}\ntemplate <typename T>\nbool fromJSON(const Value &E, llvm::Optional<T> &Out, Path P) {\n  if (E.getAsNull()) {\n    Out = llvm::None;\n    return true;\n  }\n  T Result;\n  if (!fromJSON(E, Result, P))\n    return false;\n  Out = std::move(Result);\n  return true;\n}\ntemplate <typename T>\nbool fromJSON(const Value &E, std::vector<T> &Out, Path P) {\n  if (auto *A = E.getAsArray()) {\n    Out.clear();\n    Out.resize(A->size());\n    for (size_t I = 0; I < A->size(); ++I)\n      if (!fromJSON((*A)[I], Out[I], P.index(I)))\n        return false;\n    return true;\n  }\n  P.report(\"expected array\");\n  return false;\n}\ntemplate <typename T>\nbool fromJSON(const Value &E, std::map<std::string, T> &Out, Path P) {\n  if (auto *O = E.getAsObject()) {\n    Out.clear();\n    for (const auto &KV : *O)\n      if (!fromJSON(KV.second, Out[std::string(llvm::StringRef(KV.first))],\n                    P.field(KV.first)))\n        return false;\n    return true;\n  }\n  P.report(\"expected object\");\n  return false;\n}\n\n// Allow serialization of Optional<T> for supported T.\ntemplate <typename T> Value toJSON(const llvm::Optional<T> &Opt) {\n  return Opt ? Value(*Opt) : Value(nullptr);\n}\n\n/// Helper for mapping JSON objects onto protocol structs.\n///\n/// Example:\n/// \\code\n///   bool fromJSON(const Value &E, MyStruct &R, Path P) {\n///     ObjectMapper O(E, P);\n///     // When returning false, error details were already reported.\n///     return O && O.map(\"mandatory_field\", R.MandatoryField) &&\n///         O.mapOptional(\"optional_field\", R.OptionalField);\n///   }\n/// \\endcode\nclass ObjectMapper {\npublic:\n  /// If O is not an object, this mapper is invalid and an error is reported.\n  ObjectMapper(const Value &E, Path P) : O(E.getAsObject()), P(P) {\n    if (!O)\n      P.report(\"expected object\");\n  }\n\n  /// True if the expression is an object.\n  /// Must be checked before calling map().\n  operator bool() const { return O; }\n\n  /// Maps a property to a field.\n  /// If the property is missing or invalid, reports an error.\n  template <typename T> bool map(StringLiteral Prop, T &Out) {\n    assert(*this && \"Must check this is an object before calling map()\");\n    if (const Value *E = O->get(Prop))\n      return fromJSON(*E, Out, P.field(Prop));\n    P.field(Prop).report(\"missing value\");\n    return false;\n  }\n\n  /// Maps a property to a field, if it exists.\n  /// If the property exists and is invalid, reports an error.\n  /// (Optional requires special handling, because missing keys are OK).\n  template <typename T> bool map(StringLiteral Prop, llvm::Optional<T> &Out) {\n    assert(*this && \"Must check this is an object before calling map()\");\n    if (const Value *E = O->get(Prop))\n      return fromJSON(*E, Out, P.field(Prop));\n    Out = llvm::None;\n    return true;\n  }\n\n  /// Maps a property to a field, if it exists.\n  /// If the property exists and is invalid, reports an error.\n  /// If the property does not exist, Out is unchanged.\n  template <typename T> bool mapOptional(StringLiteral Prop, T &Out) {\n    assert(*this && \"Must check this is an object before calling map()\");\n    if (const Value *E = O->get(Prop))\n      return fromJSON(*E, Out, P.field(Prop));\n    return true;\n  }\n\nprivate:\n  const Object *O;\n  Path P;\n};\n\n/// Parses the provided JSON source, or returns a ParseError.\n/// The returned Value is self-contained and owns its strings (they do not refer\n/// to the original source).\nllvm::Expected<Value> parse(llvm::StringRef JSON);\n\nclass ParseError : public llvm::ErrorInfo<ParseError> {\n  const char *Msg;\n  unsigned Line, Column, Offset;\n\npublic:\n  static char ID;\n  ParseError(const char *Msg, unsigned Line, unsigned Column, unsigned Offset)\n      : Msg(Msg), Line(Line), Column(Column), Offset(Offset) {}\n  void log(llvm::raw_ostream &OS) const override {\n    OS << llvm::formatv(\"[{0}:{1}, byte={2}]: {3}\", Line, Column, Offset, Msg);\n  }\n  std::error_code convertToErrorCode() const override {\n    return llvm::inconvertibleErrorCode();\n  }\n};\n\n/// Version of parse() that converts the parsed value to the type T.\n/// RootName describes the root object and is used in error messages.\ntemplate <typename T>\nExpected<T> parse(const llvm::StringRef &JSON, const char *RootName = \"\") {\n  auto V = parse(JSON);\n  if (!V)\n    return V.takeError();\n  Path::Root R(RootName);\n  T Result;\n  if (fromJSON(*V, Result, R))\n    return std::move(Result);\n  return R.getError();\n}\n\n/// json::OStream allows writing well-formed JSON without materializing\n/// all structures as json::Value ahead of time.\n/// It's faster, lower-level, and less safe than OS << json::Value.\n/// It also allows emitting more constructs, such as comments.\n///\n/// Only one \"top-level\" object can be written to a stream.\n/// Simplest usage involves passing lambdas (Blocks) to fill in containers:\n///\n///   json::OStream J(OS);\n///   J.array([&]{\n///     for (const Event &E : Events)\n///       J.object([&] {\n///         J.attribute(\"timestamp\", int64_t(E.Time));\n///         J.attributeArray(\"participants\", [&] {\n///           for (const Participant &P : E.Participants)\n///             J.value(P.toString());\n///         });\n///       });\n///   });\n///\n/// This would produce JSON like:\n///\n///   [\n///     {\n///       \"timestamp\": 19287398741,\n///       \"participants\": [\n///         \"King Kong\",\n///         \"Miley Cyrus\",\n///         \"Cleopatra\"\n///       ]\n///     },\n///     ...\n///   ]\n///\n/// The lower level begin/end methods (arrayBegin()) are more flexible but\n/// care must be taken to pair them correctly:\n///\n///   json::OStream J(OS);\n//    J.arrayBegin();\n///   for (const Event &E : Events) {\n///     J.objectBegin();\n///     J.attribute(\"timestamp\", int64_t(E.Time));\n///     J.attributeBegin(\"participants\");\n///     for (const Participant &P : E.Participants)\n///       J.value(P.toString());\n///     J.attributeEnd();\n///     J.objectEnd();\n///   }\n///   J.arrayEnd();\n///\n/// If the call sequence isn't valid JSON, asserts will fire in debug mode.\n/// This can be mismatched begin()/end() pairs, trying to emit attributes inside\n/// an array, and so on.\n/// With asserts disabled, this is undefined behavior.\nclass OStream {\n public:\n  using Block = llvm::function_ref<void()>;\n  // If IndentSize is nonzero, output is pretty-printed.\n  explicit OStream(llvm::raw_ostream &OS, unsigned IndentSize = 0)\n      : OS(OS), IndentSize(IndentSize) {\n    Stack.emplace_back();\n  }\n  ~OStream() {\n    assert(Stack.size() == 1 && \"Unmatched begin()/end()\");\n    assert(Stack.back().Ctx == Singleton);\n    assert(Stack.back().HasValue && \"Did not write top-level value\");\n  }\n\n  /// Flushes the underlying ostream. OStream does not buffer internally.\n  void flush() { OS.flush(); }\n\n  // High level functions to output a value.\n  // Valid at top-level (exactly once), in an attribute value (exactly once),\n  // or in an array (any number of times).\n\n  /// Emit a self-contained value (number, string, vector<string> etc).\n  void value(const Value &V);\n  /// Emit an array whose elements are emitted in the provided Block.\n  void array(Block Contents) {\n    arrayBegin();\n    Contents();\n    arrayEnd();\n  }\n  /// Emit an object whose elements are emitted in the provided Block.\n  void object(Block Contents) {\n    objectBegin();\n    Contents();\n    objectEnd();\n  }\n  /// Emit an externally-serialized value.\n  /// The caller must write exactly one valid JSON value to the provided stream.\n  /// No validation or formatting of this value occurs.\n  void rawValue(llvm::function_ref<void(raw_ostream &)> Contents) {\n    rawValueBegin();\n    Contents(OS);\n    rawValueEnd();\n  }\n  void rawValue(llvm::StringRef Contents) {\n    rawValue([&](raw_ostream &OS) { OS << Contents; });\n  }\n  /// Emit a JavaScript comment associated with the next printed value.\n  /// The string must be valid until the next attribute or value is emitted.\n  /// Comments are not part of standard JSON, and many parsers reject them!\n  void comment(llvm::StringRef);\n\n  // High level functions to output object attributes.\n  // Valid only within an object (any number of times).\n\n  /// Emit an attribute whose value is self-contained (number, vector<int> etc).\n  void attribute(llvm::StringRef Key, const Value& Contents) {\n    attributeImpl(Key, [&] { value(Contents); });\n  }\n  /// Emit an attribute whose value is an array with elements from the Block.\n  void attributeArray(llvm::StringRef Key, Block Contents) {\n    attributeImpl(Key, [&] { array(Contents); });\n  }\n  /// Emit an attribute whose value is an object with attributes from the Block.\n  void attributeObject(llvm::StringRef Key, Block Contents) {\n    attributeImpl(Key, [&] { object(Contents); });\n  }\n\n  // Low-level begin/end functions to output arrays, objects, and attributes.\n  // Must be correctly paired. Allowed contexts are as above.\n\n  void arrayBegin();\n  void arrayEnd();\n  void objectBegin();\n  void objectEnd();\n  void attributeBegin(llvm::StringRef Key);\n  void attributeEnd();\n  raw_ostream &rawValueBegin();\n  void rawValueEnd();\n\nprivate:\n  void attributeImpl(llvm::StringRef Key, Block Contents) {\n    attributeBegin(Key);\n    Contents();\n    attributeEnd();\n  }\n\n  void valueBegin();\n  void flushComment();\n  void newline();\n\n  enum Context {\n    Singleton, // Top level, or object attribute.\n    Array,\n    Object,\n    RawValue, // External code writing a value to OS directly.\n  };\n  struct State {\n    Context Ctx = Singleton;\n    bool HasValue = false;\n  };\n  llvm::SmallVector<State, 16> Stack; // Never empty.\n  llvm::StringRef PendingComment;\n  llvm::raw_ostream &OS;\n  unsigned IndentSize;\n  unsigned Indent = 0;\n};\n\n/// Serializes this Value to JSON, writing it to the provided stream.\n/// The formatting is compact (no extra whitespace) and deterministic.\n/// For pretty-printing, use the formatv() format_provider below.\ninline llvm::raw_ostream &operator<<(llvm::raw_ostream &OS, const Value &V) {\n  OStream(OS).value(V);\n  return OS;\n}\n} // namespace json\n\n/// Allow printing json::Value with formatv().\n/// The default style is basic/compact formatting, like operator<<.\n/// A format string like formatv(\"{0:2}\", Value) pretty-prints with indent 2.\ntemplate <> struct format_provider<llvm::json::Value> {\n  static void format(const llvm::json::Value &, raw_ostream &, StringRef);\n};\n} // namespace llvm\n\n#endif\n"}, "58": {"id": 58, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLParser.h", "content": "//===- YAMLParser.h - Simple YAML parser ------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This is a YAML 1.2 parser.\n//\n//  See http://www.yaml.org/spec/1.2/spec.html for the full standard.\n//\n//  This currently does not implement the following:\n//    * Multi-line literal folding.\n//    * Tag resolution.\n//    * UTF-16.\n//    * BOMs anywhere other than the first Unicode scalar value in the file.\n//\n//  The most important class here is Stream. This represents a YAML stream with\n//  0, 1, or many documents.\n//\n//  SourceMgr sm;\n//  StringRef input = getInput();\n//  yaml::Stream stream(input, sm);\n//\n//  for (yaml::document_iterator di = stream.begin(), de = stream.end();\n//       di != de; ++di) {\n//    yaml::Node *n = di->getRoot();\n//    if (n) {\n//      // Do something with n...\n//    } else\n//      break;\n//  }\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_YAMLPARSER_H\n#define LLVM_SUPPORT_YAMLPARSER_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/SMLoc.h\"\n#include \"llvm/Support/SourceMgr.h\"\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <map>\n#include <memory>\n#include <string>\n#include <system_error>\n\nnamespace llvm {\n\nclass MemoryBufferRef;\nclass raw_ostream;\nclass Twine;\n\nnamespace yaml {\n\nclass Document;\nclass document_iterator;\nclass Node;\nclass Scanner;\nstruct Token;\n\n/// Dump all the tokens in this stream to OS.\n/// \\returns true if there was an error, false otherwise.\nbool dumpTokens(StringRef Input, raw_ostream &);\n\n/// Scans all tokens in input without outputting anything. This is used\n///        for benchmarking the tokenizer.\n/// \\returns true if there was an error, false otherwise.\nbool scanTokens(StringRef Input);\n\n/// Escape \\a Input for a double quoted scalar; if \\p EscapePrintable\n/// is true, all UTF8 sequences will be escaped, if \\p EscapePrintable is\n/// false, those UTF8 sequences encoding printable unicode scalars will not be\n/// escaped, but emitted verbatim.\nstd::string escape(StringRef Input, bool EscapePrintable = true);\n\n/// Parse \\p S as a bool according to https://yaml.org/type/bool.html.\nllvm::Optional<bool> parseBool(StringRef S);\n\n/// This class represents a YAML stream potentially containing multiple\n///        documents.\nclass Stream {\npublic:\n  /// This keeps a reference to the string referenced by \\p Input.\n  Stream(StringRef Input, SourceMgr &, bool ShowColors = true,\n         std::error_code *EC = nullptr);\n\n  Stream(MemoryBufferRef InputBuffer, SourceMgr &, bool ShowColors = true,\n         std::error_code *EC = nullptr);\n  ~Stream();\n\n  document_iterator begin();\n  document_iterator end();\n  void skip();\n  bool failed();\n\n  bool validate() {\n    skip();\n    return !failed();\n  }\n\n  void printError(Node *N, const Twine &Msg,\n                  SourceMgr::DiagKind Kind = SourceMgr::DK_Error);\n  void printError(const SMRange &Range, const Twine &Msg,\n                  SourceMgr::DiagKind Kind = SourceMgr::DK_Error);\n\nprivate:\n  friend class Document;\n\n  std::unique_ptr<Scanner> scanner;\n  std::unique_ptr<Document> CurrentDoc;\n};\n\n/// Abstract base class for all Nodes.\nclass Node {\n  virtual void anchor();\n\npublic:\n  enum NodeKind {\n    NK_Null,\n    NK_Scalar,\n    NK_BlockScalar,\n    NK_KeyValue,\n    NK_Mapping,\n    NK_Sequence,\n    NK_Alias\n  };\n\n  Node(unsigned int Type, std::unique_ptr<Document> &, StringRef Anchor,\n       StringRef Tag);\n\n  // It's not safe to copy YAML nodes; the document is streamed and the position\n  // is part of the state.\n  Node(const Node &) = delete;\n  void operator=(const Node &) = delete;\n\n  void *operator new(size_t Size, BumpPtrAllocator &Alloc,\n                     size_t Alignment = 16) noexcept {\n    return Alloc.Allocate(Size, Alignment);\n  }\n\n  void operator delete(void *Ptr, BumpPtrAllocator &Alloc,\n                       size_t Size) noexcept {\n    Alloc.Deallocate(Ptr, Size, 0);\n  }\n\n  void operator delete(void *) noexcept = delete;\n\n  /// Get the value of the anchor attached to this node. If it does not\n  ///        have one, getAnchor().size() will be 0.\n  StringRef getAnchor() const { return Anchor; }\n\n  /// Get the tag as it was written in the document. This does not\n  ///   perform tag resolution.\n  StringRef getRawTag() const { return Tag; }\n\n  /// Get the verbatium tag for a given Node. This performs tag resoluton\n  ///   and substitution.\n  std::string getVerbatimTag() const;\n\n  SMRange getSourceRange() const { return SourceRange; }\n  void setSourceRange(SMRange SR) { SourceRange = SR; }\n\n  // These functions forward to Document and Scanner.\n  Token &peekNext();\n  Token getNext();\n  Node *parseBlockNode();\n  BumpPtrAllocator &getAllocator();\n  void setError(const Twine &Message, Token &Location) const;\n  bool failed() const;\n\n  virtual void skip() {}\n\n  unsigned int getType() const { return TypeID; }\n\nprotected:\n  std::unique_ptr<Document> &Doc;\n  SMRange SourceRange;\n\n  ~Node() = default;\n\nprivate:\n  unsigned int TypeID;\n  StringRef Anchor;\n  /// The tag as typed in the document.\n  StringRef Tag;\n};\n\n/// A null value.\n///\n/// Example:\n///   !!null null\nclass NullNode final : public Node {\n  void anchor() override;\n\npublic:\n  NullNode(std::unique_ptr<Document> &D)\n      : Node(NK_Null, D, StringRef(), StringRef()) {}\n\n  static bool classof(const Node *N) { return N->getType() == NK_Null; }\n};\n\n/// A scalar node is an opaque datum that can be presented as a\n///        series of zero or more Unicode scalar values.\n///\n/// Example:\n///   Adena\nclass ScalarNode final : public Node {\n  void anchor() override;\n\npublic:\n  ScalarNode(std::unique_ptr<Document> &D, StringRef Anchor, StringRef Tag,\n             StringRef Val)\n      : Node(NK_Scalar, D, Anchor, Tag), Value(Val) {\n    SMLoc Start = SMLoc::getFromPointer(Val.begin());\n    SMLoc End = SMLoc::getFromPointer(Val.end());\n    SourceRange = SMRange(Start, End);\n  }\n\n  // Return Value without any escaping or folding or other fun YAML stuff. This\n  // is the exact bytes that are contained in the file (after conversion to\n  // utf8).\n  StringRef getRawValue() const { return Value; }\n\n  /// Gets the value of this node as a StringRef.\n  ///\n  /// \\param Storage is used to store the content of the returned StringRef if\n  ///        it requires any modification from how it appeared in the source.\n  ///        This happens with escaped characters and multi-line literals.\n  StringRef getValue(SmallVectorImpl<char> &Storage) const;\n\n  static bool classof(const Node *N) {\n    return N->getType() == NK_Scalar;\n  }\n\nprivate:\n  StringRef Value;\n\n  StringRef unescapeDoubleQuoted(StringRef UnquotedValue,\n                                 StringRef::size_type Start,\n                                 SmallVectorImpl<char> &Storage) const;\n};\n\n/// A block scalar node is an opaque datum that can be presented as a\n///        series of zero or more Unicode scalar values.\n///\n/// Example:\n///   |\n///     Hello\n///     World\nclass BlockScalarNode final : public Node {\n  void anchor() override;\n\npublic:\n  BlockScalarNode(std::unique_ptr<Document> &D, StringRef Anchor, StringRef Tag,\n                  StringRef Value, StringRef RawVal)\n      : Node(NK_BlockScalar, D, Anchor, Tag), Value(Value) {\n    SMLoc Start = SMLoc::getFromPointer(RawVal.begin());\n    SMLoc End = SMLoc::getFromPointer(RawVal.end());\n    SourceRange = SMRange(Start, End);\n  }\n\n  /// Gets the value of this node as a StringRef.\n  StringRef getValue() const { return Value; }\n\n  static bool classof(const Node *N) {\n    return N->getType() == NK_BlockScalar;\n  }\n\nprivate:\n  StringRef Value;\n};\n\n/// A key and value pair. While not technically a Node under the YAML\n///        representation graph, it is easier to treat them this way.\n///\n/// TODO: Consider making this not a child of Node.\n///\n/// Example:\n///   Section: .text\nclass KeyValueNode final : public Node {\n  void anchor() override;\n\npublic:\n  KeyValueNode(std::unique_ptr<Document> &D)\n      : Node(NK_KeyValue, D, StringRef(), StringRef()) {}\n\n  /// Parse and return the key.\n  ///\n  /// This may be called multiple times.\n  ///\n  /// \\returns The key, or nullptr if failed() == true.\n  Node *getKey();\n\n  /// Parse and return the value.\n  ///\n  /// This may be called multiple times.\n  ///\n  /// \\returns The value, or nullptr if failed() == true.\n  Node *getValue();\n\n  void skip() override {\n    if (Node *Key = getKey()) {\n      Key->skip();\n      if (Node *Val = getValue())\n        Val->skip();\n    }\n  }\n\n  static bool classof(const Node *N) {\n    return N->getType() == NK_KeyValue;\n  }\n\nprivate:\n  Node *Key = nullptr;\n  Node *Value = nullptr;\n};\n\n/// This is an iterator abstraction over YAML collections shared by both\n///        sequences and maps.\n///\n/// BaseT must have a ValueT* member named CurrentEntry and a member function\n/// increment() which must set CurrentEntry to 0 to create an end iterator.\ntemplate <class BaseT, class ValueT>\nclass basic_collection_iterator\n    : public std::iterator<std::input_iterator_tag, ValueT> {\npublic:\n  basic_collection_iterator() = default;\n  basic_collection_iterator(BaseT *B) : Base(B) {}\n\n  ValueT *operator->() const {\n    assert(Base && Base->CurrentEntry && \"Attempted to access end iterator!\");\n    return Base->CurrentEntry;\n  }\n\n  ValueT &operator*() const {\n    assert(Base && Base->CurrentEntry &&\n           \"Attempted to dereference end iterator!\");\n    return *Base->CurrentEntry;\n  }\n\n  operator ValueT *() const {\n    assert(Base && Base->CurrentEntry && \"Attempted to access end iterator!\");\n    return Base->CurrentEntry;\n  }\n\n  /// Note on EqualityComparable:\n  ///\n  /// The iterator is not re-entrant,\n  /// it is meant to be used for parsing YAML on-demand\n  /// Once iteration started - it can point only to one entry at a time\n  /// hence Base.CurrentEntry and Other.Base.CurrentEntry are equal\n  /// iff Base and Other.Base are equal.\n  bool operator==(const basic_collection_iterator &Other) const {\n    if (Base && (Base == Other.Base)) {\n      assert((Base->CurrentEntry == Other.Base->CurrentEntry)\n             && \"Equal Bases expected to point to equal Entries\");\n    }\n\n    return Base == Other.Base;\n  }\n\n  bool operator!=(const basic_collection_iterator &Other) const {\n    return !(Base == Other.Base);\n  }\n\n  basic_collection_iterator &operator++() {\n    assert(Base && \"Attempted to advance iterator past end!\");\n    Base->increment();\n    // Create an end iterator.\n    if (!Base->CurrentEntry)\n      Base = nullptr;\n    return *this;\n  }\n\nprivate:\n  BaseT *Base = nullptr;\n};\n\n// The following two templates are used for both MappingNode and Sequence Node.\ntemplate <class CollectionType>\ntypename CollectionType::iterator begin(CollectionType &C) {\n  assert(C.IsAtBeginning && \"You may only iterate over a collection once!\");\n  C.IsAtBeginning = false;\n  typename CollectionType::iterator ret(&C);\n  ++ret;\n  return ret;\n}\n\ntemplate <class CollectionType> void skip(CollectionType &C) {\n  // TODO: support skipping from the middle of a parsed collection ;/\n  assert((C.IsAtBeginning || C.IsAtEnd) && \"Cannot skip mid parse!\");\n  if (C.IsAtBeginning)\n    for (typename CollectionType::iterator i = begin(C), e = C.end(); i != e;\n         ++i)\n      i->skip();\n}\n\n/// Represents a YAML map created from either a block map for a flow map.\n///\n/// This parses the YAML stream as increment() is called.\n///\n/// Example:\n///   Name: _main\n///   Scope: Global\nclass MappingNode final : public Node {\n  void anchor() override;\n\npublic:\n  enum MappingType {\n    MT_Block,\n    MT_Flow,\n    MT_Inline ///< An inline mapping node is used for \"[key: value]\".\n  };\n\n  MappingNode(std::unique_ptr<Document> &D, StringRef Anchor, StringRef Tag,\n              MappingType MT)\n      : Node(NK_Mapping, D, Anchor, Tag), Type(MT) {}\n\n  friend class basic_collection_iterator<MappingNode, KeyValueNode>;\n\n  using iterator = basic_collection_iterator<MappingNode, KeyValueNode>;\n\n  template <class T> friend typename T::iterator yaml::begin(T &);\n  template <class T> friend void yaml::skip(T &);\n\n  iterator begin() { return yaml::begin(*this); }\n\n  iterator end() { return iterator(); }\n\n  void skip() override { yaml::skip(*this); }\n\n  static bool classof(const Node *N) {\n    return N->getType() == NK_Mapping;\n  }\n\nprivate:\n  MappingType Type;\n  bool IsAtBeginning = true;\n  bool IsAtEnd = false;\n  KeyValueNode *CurrentEntry = nullptr;\n\n  void increment();\n};\n\n/// Represents a YAML sequence created from either a block sequence for a\n///        flow sequence.\n///\n/// This parses the YAML stream as increment() is called.\n///\n/// Example:\n///   - Hello\n///   - World\nclass SequenceNode final : public Node {\n  void anchor() override;\n\npublic:\n  enum SequenceType {\n    ST_Block,\n    ST_Flow,\n    // Use for:\n    //\n    // key:\n    // - val1\n    // - val2\n    //\n    // As a BlockMappingEntry and BlockEnd are not created in this case.\n    ST_Indentless\n  };\n\n  SequenceNode(std::unique_ptr<Document> &D, StringRef Anchor, StringRef Tag,\n               SequenceType ST)\n      : Node(NK_Sequence, D, Anchor, Tag), SeqType(ST) {}\n\n  friend class basic_collection_iterator<SequenceNode, Node>;\n\n  using iterator = basic_collection_iterator<SequenceNode, Node>;\n\n  template <class T> friend typename T::iterator yaml::begin(T &);\n  template <class T> friend void yaml::skip(T &);\n\n  void increment();\n\n  iterator begin() { return yaml::begin(*this); }\n\n  iterator end() { return iterator(); }\n\n  void skip() override { yaml::skip(*this); }\n\n  static bool classof(const Node *N) {\n    return N->getType() == NK_Sequence;\n  }\n\nprivate:\n  SequenceType SeqType;\n  bool IsAtBeginning = true;\n  bool IsAtEnd = false;\n  bool WasPreviousTokenFlowEntry = true; // Start with an imaginary ','.\n  Node *CurrentEntry = nullptr;\n};\n\n/// Represents an alias to a Node with an anchor.\n///\n/// Example:\n///   *AnchorName\nclass AliasNode final : public Node {\n  void anchor() override;\n\npublic:\n  AliasNode(std::unique_ptr<Document> &D, StringRef Val)\n      : Node(NK_Alias, D, StringRef(), StringRef()), Name(Val) {}\n\n  StringRef getName() const { return Name; }\n\n  static bool classof(const Node *N) { return N->getType() == NK_Alias; }\n\nprivate:\n  StringRef Name;\n};\n\n/// A YAML Stream is a sequence of Documents. A document contains a root\n///        node.\nclass Document {\npublic:\n  Document(Stream &ParentStream);\n\n  /// Root for parsing a node. Returns a single node.\n  Node *parseBlockNode();\n\n  /// Finish parsing the current document and return true if there are\n  ///        more. Return false otherwise.\n  bool skip();\n\n  /// Parse and return the root level node.\n  Node *getRoot() {\n    if (Root)\n      return Root;\n    return Root = parseBlockNode();\n  }\n\n  const std::map<StringRef, StringRef> &getTagMap() const { return TagMap; }\n\nprivate:\n  friend class Node;\n  friend class document_iterator;\n\n  /// Stream to read tokens from.\n  Stream &stream;\n\n  /// Used to allocate nodes to. All are destroyed without calling their\n  ///        destructor when the document is destroyed.\n  BumpPtrAllocator NodeAllocator;\n\n  /// The root node. Used to support skipping a partially parsed\n  ///        document.\n  Node *Root;\n\n  /// Maps tag prefixes to their expansion.\n  std::map<StringRef, StringRef> TagMap;\n\n  Token &peekNext();\n  Token getNext();\n  void setError(const Twine &Message, Token &Location) const;\n  bool failed() const;\n\n  /// Parse %BLAH directives and return true if any were encountered.\n  bool parseDirectives();\n\n  /// Parse %YAML\n  void parseYAMLDirective();\n\n  /// Parse %TAG\n  void parseTAGDirective();\n\n  /// Consume the next token and error if it is not \\a TK.\n  bool expectToken(int TK);\n};\n\n/// Iterator abstraction for Documents over a Stream.\nclass document_iterator {\npublic:\n  document_iterator() = default;\n  document_iterator(std::unique_ptr<Document> &D) : Doc(&D) {}\n\n  bool operator==(const document_iterator &Other) const {\n    if (isAtEnd() || Other.isAtEnd())\n      return isAtEnd() && Other.isAtEnd();\n\n    return Doc == Other.Doc;\n  }\n  bool operator!=(const document_iterator &Other) const {\n    return !(*this == Other);\n  }\n\n  document_iterator operator++() {\n    assert(Doc && \"incrementing iterator past the end.\");\n    if (!(*Doc)->skip()) {\n      Doc->reset(nullptr);\n    } else {\n      Stream &S = (*Doc)->stream;\n      Doc->reset(new Document(S));\n    }\n    return *this;\n  }\n\n  Document &operator*() { return *Doc->get(); }\n\n  std::unique_ptr<Document> &operator->() { return *Doc; }\n\nprivate:\n  bool isAtEnd() const { return !Doc || !*Doc; }\n\n  std::unique_ptr<Document> *Doc = nullptr;\n};\n\n} // end namespace yaml\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_YAMLPARSER_H\n"}}, "reports": [{"events": [{"location": {"col": 6, "file": 0, "line": 511}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 0, "line": 511}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Address.h", "reportHash": "94b9ea43fb7a5384f22750e41f777b59", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 0, "line": 512}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 0, "line": 512}, "message": "'operator>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Address.h", "reportHash": "e694f3ba3b04d27d9b09aeb6caafc511", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 0, "line": 513}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 0, "line": 513}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Address.h", "reportHash": "dc9bfd0b033a16dd12bbeb6582c75d1a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 0, "line": 514}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 0, "line": 514}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Address.h", "reportHash": "a75a0996a505a692b6e06ebde1417a34", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 1, "line": 459}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Disassembler.h", "reportHash": "aaab1ee94397aad0973249ce342fbd72", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 1, "line": 463}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Disassembler.h", "reportHash": "323a13d8f3742e3e72b326801c7fc8bd", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 2, "line": 147}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/FormatEntity.h", "reportHash": "c5d4f9cbbc0be08b9605adef2ec75078", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 3, "line": 85}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/LoadedModuleInfoList.h", "reportHash": "1076ac94d6883110869f79f1aff64a37", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 4, "line": 52}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 4, "line": 52}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Host/Host.h", "reportHash": "486d0723d12704d183e706c08db6980a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 4, "line": 56}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 4, "line": 56}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Host/Host.h", "reportHash": "3106b5f768cf07aba5b0f0b99fce9e19", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 5, "line": 44}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/CompilerDecl.h", "reportHash": "6009b239e57e7b4e7ec87a2674f16d87", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 5, "line": 92}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 5, "line": 92}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/CompilerDecl.h", "reportHash": "4e5354ed89e42814fee66ee8c845689d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 37, "file": 5, "line": 92}, "message": "'lhs' of type 'lldb_private::CompilerDecl' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/CompilerDecl.h", "reportHash": "4ecde9917f675dd219134f1e3d6a8ac7", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 62, "file": 5, "line": 92}, "message": "'rhs' of type 'lldb_private::CompilerDecl' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/CompilerDecl.h", "reportHash": "90dafe09e0350ff2c8cc7403c008e399", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 5, "line": 93}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 5, "line": 93}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/CompilerDecl.h", "reportHash": "31a8e02bfcd2c22207d6ed43be265bd7", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 37, "file": 5, "line": 93}, "message": "'lhs' of type 'lldb_private::CompilerDecl' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/CompilerDecl.h", "reportHash": "1a0d1448e161b78744bc46b76ca35d4c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 62, "file": 5, "line": 93}, "message": "'rhs' of type 'lldb_private::CompilerDecl' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/CompilerDecl.h", "reportHash": "33fc3332bff60fd1a6b5f58f6288f972", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 6, "line": 49}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/CompilerDeclContext.h", "reportHash": "9cf0d3577b8d6c0e26c5465226d6ba14", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 6, "line": 124}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 6, "line": 124}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/CompilerDeclContext.h", "reportHash": "5226b2b9eae5460982f415250967475c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 44, "file": 6, "line": 124}, "message": "'lhs' of type 'lldb_private::CompilerDeclContext' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/CompilerDeclContext.h", "reportHash": "2e8af160ee0e374fcaf5d0188d753f42", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 76, "file": 6, "line": 124}, "message": "'rhs' of type 'lldb_private::CompilerDeclContext' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/CompilerDeclContext.h", "reportHash": "154eb70e9a60d73d4a6eb37d8052ef72", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 6, "line": 125}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 6, "line": 125}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/CompilerDeclContext.h", "reportHash": "0911e95abdf0491952a631a6d07de09a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 44, "file": 6, "line": 125}, "message": "'lhs' of type 'lldb_private::CompilerDeclContext' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/CompilerDeclContext.h", "reportHash": "968110a5d6c6312c9af78fd1ec2e30a7", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 76, "file": 6, "line": 125}, "message": "'rhs' of type 'lldb_private::CompilerDeclContext' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/CompilerDeclContext.h", "reportHash": "f6ad25f49bee404baa24b30f319eae4a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 7, "line": 59}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/CompilerType.h", "reportHash": "eee60ba760b6532e5815eac37be0d082", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 7, "line": 412}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 7, "line": 412}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/CompilerType.h", "reportHash": "a631ed51348528123cca6b80ae020998", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 37, "file": 7, "line": 412}, "message": "'lhs' of type 'lldb_private::CompilerType' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/CompilerType.h", "reportHash": "114a00ae9608b54314e9c5f45f6fc165", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 62, "file": 7, "line": 412}, "message": "'rhs' of type 'lldb_private::CompilerType' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/CompilerType.h", "reportHash": "84636516d8bdd2f57fc0056c7dfcb7a0", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 7, "line": 413}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 7, "line": 413}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/CompilerType.h", "reportHash": "ee1326d59a5e2efa7795a27a917cf973", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 37, "file": 7, "line": 413}, "message": "'lhs' of type 'lldb_private::CompilerType' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/CompilerType.h", "reportHash": "dcfc70d5299ce2e210f0b0cb8c44e705", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 62, "file": 7, "line": 413}, "message": "'rhs' of type 'lldb_private::CompilerType' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/CompilerType.h", "reportHash": "9b74e55c92d77e7a324717c02eadb69f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 8, "line": 201}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 8, "line": 201}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/Declaration.h", "reportHash": "5bd97d7c3c8fb94e71f345636a285254", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 9, "line": 172}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 9, "line": 172}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/LineEntry.h", "reportHash": "da690831559819b5e7f33169974b9a6c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 10, "line": 478}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 10, "line": 478}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/SymbolContext.h", "reportHash": "ac29309de3ccb692081e1f270d948a12", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 10, "line": 479}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 10, "line": 479}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/SymbolContext.h", "reportHash": "5912af9ff4a8a73f1aaf6315bca43ee0", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 10, "line": 481}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 10, "line": 481}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/SymbolContext.h", "reportHash": "8acd412480eb221c24d4256e8f23710a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 10, "line": 482}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 10, "line": 482}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/SymbolContext.h", "reportHash": "7816bddf25593019b5dd0c68dec5e592", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 11, "line": 30}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/Type.h", "reportHash": "41b76f2724ff515a38ff8d94e5a4d409", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 11, "line": 33}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/Type.h", "reportHash": "68e2d8070201f468718bf0d359eeb1dd", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 11, "line": 260}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/Type.h", "reportHash": "47977e1e095077a672e6cfd50b8a6d93", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 11, "line": 262}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/Type.h", "reportHash": "1d67ed11abbbf7fd24b81baf1eb0691c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 11, "line": 403}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/Type.h", "reportHash": "5b6171df74527aa39a24e07cf1de04ea", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 11, "line": 405}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/Type.h", "reportHash": "a8cb714a2c0e8c5717d60b1f0039246f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 12, "line": 346}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Target/ExecutionContext.h", "reportHash": "a5a902c1c47b395e530851dae31c8322", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 12, "line": 348}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Target/ExecutionContext.h", "reportHash": "e8cff6ba737bd8f4d9bd6a01094c6882", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 13, "line": 218}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 13, "line": 218}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Target/Process.h", "reportHash": "02c9e7fe3d6cca5dacb4ae1ca027b236", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 13, "line": 325}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 13, "line": 325}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Target/Process.h", "reportHash": "63131ba03be0d45afc758615829b78ad", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 13, "line": 332}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 13, "line": 332}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Target/Process.h", "reportHash": "752c7e81674c8de1d6b533895e250614", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 13, "line": 2723}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Target/Process.h", "reportHash": "5739f20167345087903b9747a5e99093", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 14, "line": 91}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 14, "line": 91}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Target/StackID.h", "reportHash": "d70153293ea4dbf38496e24eefe3aa5d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 14, "line": 92}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 14, "line": 92}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Target/StackID.h", "reportHash": "87e4332fe6d41af3cac78c5e09dfa6b1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 14, "line": 95}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 14, "line": 95}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Target/StackID.h", "reportHash": "457b5d8f73262e1b7220a9b29f3edac7", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 15, "line": 548}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 15, "line": 548}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/ArchSpec.h", "reportHash": "b28b7c9e5a2760d249f94b8e5c1f8c4b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 15, "line": 549}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 15, "line": 549}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/ArchSpec.h", "reportHash": "e084946184846e6051b6c7feea14b24c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 16, "line": 67}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Broadcaster.h", "reportHash": "3427f06b9bcc84c7f55f05f24ad09c31", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 17, "line": 125}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/ConstString.h", "reportHash": "45e5d224dfd4c154a6654f46a3e3c468", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 17, "line": 144}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/ConstString.h", "reportHash": "5d35710227e80aba1b81c535a037cbf3", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 17, "line": 167}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/ConstString.h", "reportHash": "617c32c287beea1049913a61766738ed", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 17, "line": 180}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/ConstString.h", "reportHash": "ed61f6992ba382b6ba785a217f60a4dd", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 17, "line": 182}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/ConstString.h", "reportHash": "93a2e02f4d4bc4290f150f612d36c185", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 18, "line": 94}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/FileSpec.h", "reportHash": "5de3aa9ff1e717fb0e9c6c991275c056", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 18, "line": 107}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/FileSpec.h", "reportHash": "0bf38a938f16dcb5ecacc28653798318", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 18, "line": 120}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/FileSpec.h", "reportHash": "320ab0adcccb2d4dc994fb77f2af6385", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 19, "line": 1678}, "message": "expanded from macro 'LLVM_YAML_STRONG_TYPEDEF'"}, {"location": {"col": 1, "file": 18, "line": 417}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/FileSpec.h", "reportHash": "d8b4a09b755692a0cffa65cf8854b633", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 19, "line": 1676}, "message": "expanded from macro 'LLVM_YAML_STRONG_TYPEDEF'"}, {"location": {"col": 1, "file": 18, "line": 417}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/FileSpec.h", "reportHash": "25c645e09e195ab589a4f55dde2c788f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 50}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Iterable.h", "reportHash": "8224af0c267ed4842dc62b00f119efa4", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 54}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Iterable.h", "reportHash": "c4ff41a474620896ec5f320e552cb95d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 105}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Iterable.h", "reportHash": "e863f954c9338f960f5f9ff6e2d97c1a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 107}, "message": "'operator<=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Iterable.h", "reportHash": "ab24525852d10d7d50dcd9ed2cc054f2", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 109}, "message": "'operator>' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Iterable.h", "reportHash": "b21539ad9574c1e5b7049d2b46868a4d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 111}, "message": "'operator>=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Iterable.h", "reportHash": "9567ee955125737835e9bab4ab94cf29", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 21, "line": 110}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/RangeMap.h", "reportHash": "0b3a2b4b090103c46fd61b6f149e826f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 21, "line": 116}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/RangeMap.h", "reportHash": "6b09b403f135c36cc0a4ce5897c1d3b6", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 21, "line": 120}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/RangeMap.h", "reportHash": "1e95fbb933e65f64d73858f9079d0742", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 21, "line": 660}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/RangeMap.h", "reportHash": "aecfc5e2e5a97298bd7acd4af19bb3af", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 21, "line": 666}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/RangeMap.h", "reportHash": "554417bbe9c505b6e68e4b2b60953b48", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 21, "line": 670}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/RangeMap.h", "reportHash": "b7aeb2a8d9c3d278f2d83327c7c29732", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 22, "line": 81}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/RegularExpression.h", "reportHash": "71dd3738a9b576dcf88f90a6f62b38de", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 23, "line": 214}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 23, "line": 214}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Scalar.h", "reportHash": "e5018a9b14415e46e791432336f71737", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 33, "file": 23, "line": 214}, "message": "'lhs' of type 'lldb_private::Scalar' is expensive to copy, should be passed by reference to const"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Scalar.h", "reportHash": "5e159edf1e95155e270c0519f545f4ab", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 45, "file": 23, "line": 214}, "message": "'rhs' of type 'lldb_private::Scalar' is expensive to copy, should be passed by reference to const"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Scalar.h", "reportHash": "5d74d1b8e5b0331cc1138d4291a34d52", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 23, "line": 215}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 23, "line": 215}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Scalar.h", "reportHash": "f3a9526c3bab5432272773677a826d69", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 23, "line": 216}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 23, "line": 216}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Scalar.h", "reportHash": "42de3256b09d8e27f59575bdcc0fa9d5", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 32, "file": 23, "line": 216}, "message": "'lhs' of type 'lldb_private::Scalar' is expensive to copy, should be passed by reference to const"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Scalar.h", "reportHash": "6e8cdae172d3ca96f140fffd0cc69f53", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 44, "file": 23, "line": 216}, "message": "'rhs' of type 'lldb_private::Scalar' is expensive to copy, should be passed by reference to const"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Scalar.h", "reportHash": "9c9b589f01755277f34ff697a7c909d9", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 23, "line": 217}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 23, "line": 217}, "message": "'operator<=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Scalar.h", "reportHash": "ac1d6e084049163686185c5f3312d73f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 23, "line": 218}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 23, "line": 218}, "message": "'operator>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Scalar.h", "reportHash": "e34030ea59340d1d054cdb8f84a3382f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 23, "line": 219}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 23, "line": 219}, "message": "'operator>=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Scalar.h", "reportHash": "d1f448a82071a42d558fce140b0ef5a6", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 23, "line": 245}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 23, "line": 245}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Scalar.h", "reportHash": "9356b94ddb73af8d14626bff0643b3bd", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 23, "line": 245}, "message": "'lhs' of type 'lldb_private::Scalar' is expensive to copy, should be passed by reference to const"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Scalar.h", "reportHash": "90a064642406166c969eec7ef4263b16", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 36, "file": 23, "line": 245}, "message": "'rhs' of type 'lldb_private::Scalar' is expensive to copy, should be passed by reference to const"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Scalar.h", "reportHash": "fbdd6101a6a91d1b076042c0b41729ab", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 23, "line": 246}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 23, "line": 246}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Scalar.h", "reportHash": "21745db26a487fe72f5aa0b6783be5fe", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 23, "line": 247}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 23, "line": 247}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Scalar.h", "reportHash": "46c60c094efa3df5ba9b2c7462c601c9", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 23, "file": 23, "line": 247}, "message": "'lhs' of type 'lldb_private::Scalar' is expensive to copy, should be passed by reference to const"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Scalar.h", "reportHash": "830f7cc3b36dbbf83facc1bcd16bd425", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 35, "file": 23, "line": 247}, "message": "'rhs' of type 'lldb_private::Scalar' is expensive to copy, should be passed by reference to const"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Scalar.h", "reportHash": "0cfea1d1d48000c1523baa753edcfeb0", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 23, "line": 248}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 23, "line": 248}, "message": "'operator<=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Scalar.h", "reportHash": "8a59bc51d69242d52b694cfd4f14c6e0", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 23, "line": 249}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 23, "line": 249}, "message": "'operator>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Scalar.h", "reportHash": "e6bc2eee9d80d9e5f4fded4cdc2641db", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 23, "line": 250}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 23, "line": 250}, "message": "'operator>=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Scalar.h", "reportHash": "c61ff22b49ca87ccc99c8113f1f6cdcd", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 24, "line": 112}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 24, "line": 112}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/UUID.h", "reportHash": "1592b706d192871878e2c8be3f2a76b3", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 24, "line": 115}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 24, "line": 115}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/UUID.h", "reportHash": "7f93f33de5613ba1ed2ef4d4b9b5018d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 24, "line": 118}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 24, "line": 118}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/UUID.h", "reportHash": "69ea26c2df6c53ae51fcfe0955fcb755", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 24, "line": 121}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 24, "line": 121}, "message": "'operator<=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/UUID.h", "reportHash": "18034063c3bb54e0d503253dc9d9bd31", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 24, "line": 124}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 24, "line": 124}, "message": "'operator>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/UUID.h", "reportHash": "d12068ede64d606cf3da152e14efc644", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 24, "line": 125}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 24, "line": 125}, "message": "'operator>=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/UUID.h", "reportHash": "3c89a21b17e6b8326ba8868b450fb97f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 25, "line": 80}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 25, "line": 80}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/UserID.h", "reportHash": "ef01d1b901b437b989ff5c16dcad0509", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 38, "file": 25, "line": 80}, "message": "'lhs' of type 'lldb_private::UserID' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/UserID.h", "reportHash": "ca7c9926aa5cfdda75e80f31a76598d7", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 57, "file": 25, "line": 80}, "message": "'rhs' of type 'lldb_private::UserID' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/UserID.h", "reportHash": "41b4d865a70295336c6f2923b062bad6", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 25, "line": 84}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 25, "line": 84}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/UserID.h", "reportHash": "960497fbbe7b8a784ebde4d7581bc92a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 38, "file": 25, "line": 84}, "message": "'lhs' of type 'lldb_private::UserID' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/UserID.h", "reportHash": "fd6d42b2213c42c38eead3f62726e37b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 57, "file": 25, "line": 84}, "message": "'rhs' of type 'lldb_private::UserID' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/UserID.h", "reportHash": "d9213e68c300359ba4bc2e3b12cff7fa", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 50, "file": 31, "line": 1245}, "message": "'LHS' of type 'llvm::DenseMapIterator<llvm::json::ObjectKey, llvm::json::Value, llvm::DenseMapInfo<llvm::StringRef>, llvm::detail::DenseMapPair<llvm::json::ObjectKey, llvm::json::Value>, false>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "d44916fb6f06094767de0ea60305e14c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 50, "file": 31, "line": 1245}, "message": "'LHS' of type 'llvm::DenseMapIterator<llvm::json::ObjectKey, llvm::json::Value, llvm::DenseMapInfo<llvm::StringRef>, llvm::detail::DenseMapPair<llvm::json::ObjectKey, llvm::json::Value>, true>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "21ed6e818b6decf6002df3930069038b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 50, "file": 31, "line": 1246}, "message": "'RHS' of type 'llvm::DenseMapIterator<llvm::json::ObjectKey, llvm::json::Value, llvm::DenseMapInfo<llvm::StringRef>, llvm::detail::DenseMapPair<llvm::json::ObjectKey, llvm::json::Value>, false>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "7ec1e2be78623ab870e61d64a8e5c37a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 50, "file": 31, "line": 1246}, "message": "'RHS' of type 'llvm::DenseMapIterator<llvm::json::ObjectKey, llvm::json::Value, llvm::DenseMapInfo<llvm::StringRef>, llvm::detail::DenseMapPair<llvm::json::ObjectKey, llvm::json::Value>, true>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "17867856df345ad7a84373bc5e6736b5", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 50, "file": 31, "line": 1254}, "message": "'LHS' of type 'llvm::DenseMapIterator<llvm::json::ObjectKey, llvm::json::Value, llvm::DenseMapInfo<llvm::StringRef>, llvm::detail::DenseMapPair<llvm::json::ObjectKey, llvm::json::Value>, false>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "1fea597148d8f783c43c1e349652704f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 50, "file": 31, "line": 1254}, "message": "'LHS' of type 'llvm::DenseMapIterator<llvm::json::ObjectKey, llvm::json::Value, llvm::DenseMapInfo<llvm::StringRef>, llvm::detail::DenseMapPair<llvm::json::ObjectKey, llvm::json::Value>, true>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "6e19eba7fdd7d6f1c96bb1ff5596ca5d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 50, "file": 31, "line": 1255}, "message": "'RHS' of type 'llvm::DenseMapIterator<llvm::json::ObjectKey, llvm::json::Value, llvm::DenseMapInfo<llvm::StringRef>, llvm::detail::DenseMapPair<llvm::json::ObjectKey, llvm::json::Value>, false>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "7ec1e2be78623ab870e61d64a8e5c37a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 50, "file": 31, "line": 1255}, "message": "'RHS' of type 'llvm::DenseMapIterator<llvm::json::ObjectKey, llvm::json::Value, llvm::DenseMapInfo<llvm::StringRef>, llvm::detail::DenseMapPair<llvm::json::ObjectKey, llvm::json::Value>, true>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "17867856df345ad7a84373bc5e6736b5", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 36, "line": 365}, "message": "mark 'noexcept'"}, {"location": {"col": 16, "file": 36, "line": 365}, "message": "'operator==<bool>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "f3b33ab60f41cade1e41152dbbae1762", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 36, "line": 365}, "message": "'operator==<bool>' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "77f49d71f3b6e463ad0acc10154f433e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 46, "file": 36, "line": 365}, "message": "'X' of type 'Optional<bool>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "20ce431c8c18ea5e5359d0a2ac9a9252", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 36, "line": 375}, "message": "mark 'noexcept'"}, {"location": {"col": 16, "file": 36, "line": 375}, "message": "'operator!=<bool>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "1164a230519065693c13e1d8dfe09f73", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 36, "line": 375}, "message": "'operator!=<bool>' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "18f32867937562f1de554122620e04fd", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 46, "file": 36, "line": 375}, "message": "'X' of type 'Optional<bool>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "a18ce128a5972db5bfff5a8a496a404b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 40, "line": 486}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h", "reportHash": "7b79005d391a09350655586249fc888d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 40, "line": 502}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h", "reportHash": "8d535648612148cc5d81631f87f55b8a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 43, "file": 42, "line": 392}, "message": "'LHS' of type 'llvm::StringMapConstIterator<llvm::NoneType>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringMap.h", "reportHash": "2216b9463761ea89f100f2421ce51c57", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 43, "file": 42, "line": 392}, "message": "'LHS' of type 'llvm::StringMapConstIterator<std::basic_string<char>>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringMap.h", "reportHash": "87b4db1bdce8f94d2e231f3b79a5aa07", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 43, "file": 42, "line": 392}, "message": "'LHS' of type 'llvm::StringMapIterator<llvm::NoneType>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringMap.h", "reportHash": "4264803207c4d035e3c0cf21c02dc370", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 43, "file": 42, "line": 392}, "message": "'LHS' of type 'llvm::StringMapIterator<std::basic_string<char>>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringMap.h", "reportHash": "fe28d68603c0633b0ffb8bef35bdaff4", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 65, "file": 42, "line": 392}, "message": "'RHS' of type 'llvm::StringMapConstIterator<llvm::NoneType>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringMap.h", "reportHash": "6dd182ab3915e12a9f9b7bac74582f57", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 65, "file": 42, "line": 392}, "message": "'RHS' of type 'llvm::StringMapConstIterator<std::basic_string<char>>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringMap.h", "reportHash": "82bfb145391dc907623a2799fdcd41a1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 65, "file": 42, "line": 392}, "message": "'RHS' of type 'llvm::StringMapIterator<llvm::NoneType>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringMap.h", "reportHash": "1c7d41501333f97c4a7270534aed553d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 65, "file": 42, "line": 392}, "message": "'RHS' of type 'llvm::StringMapIterator<std::basic_string<char>>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringMap.h", "reportHash": "5b0281cb27d8cd5de7aa439dfb194fd7", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 50, "line": 149}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 50, "line": 149}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "1754fece1a3264458a98f6f626642a08", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 50, "line": 150}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 50, "line": 150}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "9397991fafd6bb3dce617a446e92cf09", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 50, "line": 208}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 50, "line": 208}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "706e17c654b2fd5784e50178e0d3fe37", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 50, "line": 210}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 50, "line": 210}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "2725fa2b092ef5a720206454ca75c813", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 50, "line": 485}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 50, "line": 485}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "0d3166cb9758b22f4f2ba9b5c7846bd2", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 50, "line": 488}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 50, "line": 488}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "e6f49f5fc642b0154fdaf6bf51b17ca3", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 50, "line": 489}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 50, "line": 489}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "c9b0416b48275b5cddcdf7f1a2560898", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 50, "line": 538}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 50, "line": 538}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "b374ccbd74a342175f69b36614e59f6d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 50, "line": 541}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 50, "line": 541}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "a2ef82ee3a31b9e23c9e8ae3c75774f1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 50, "line": 544}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 50, "line": 544}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "9dee1778717949062671bfda5d4b543c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 58, "line": 358}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLParser.h", "reportHash": "3796faeb078dd26e2d392a4c76af365b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 58, "line": 367}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLParser.h", "reportHash": "e0137e21aeb338f93d43673f508f5028", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 58, "line": 589}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLParser.h", "reportHash": "617f30d8431f4c8262ea432f2d159182", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 58, "line": 595}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLParser.h", "reportHash": "aa2efb1523dd5fa8113558fc40d81193", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 19, "line": 1678}, "message": "expanded from macro 'LLVM_YAML_STRONG_TYPEDEF'"}, {"location": {"col": 1, "file": 19, "line": 1687}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLTraits.h", "reportHash": "a5be79d4748ad5cbea79fb9c731494a2", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 19, "line": 1676}, "message": "expanded from macro 'LLVM_YAML_STRONG_TYPEDEF'"}, {"location": {"col": 1, "file": 19, "line": 1687}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLTraits.h", "reportHash": "0e31c5aa3ffdcd9ea8fcc4508ea56f76", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 19, "line": 1678}, "message": "expanded from macro 'LLVM_YAML_STRONG_TYPEDEF'"}, {"location": {"col": 1, "file": 19, "line": 1688}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLTraits.h", "reportHash": "b9f724781c854669bd90543e49b2a3fd", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 19, "line": 1676}, "message": "expanded from macro 'LLVM_YAML_STRONG_TYPEDEF'"}, {"location": {"col": 1, "file": 19, "line": 1688}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLTraits.h", "reportHash": "f4ec257a409d6348d86b64663e659107", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 19, "line": 1678}, "message": "expanded from macro 'LLVM_YAML_STRONG_TYPEDEF'"}, {"location": {"col": 1, "file": 19, "line": 1689}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLTraits.h", "reportHash": "23c7cd23d0d1ea814eca30e8699fd417", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 19, "line": 1676}, "message": "expanded from macro 'LLVM_YAML_STRONG_TYPEDEF'"}, {"location": {"col": 1, "file": 19, "line": 1689}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLTraits.h", "reportHash": "3708d3f95bd4c85efd6cf33d51a80546", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 19, "line": 1678}, "message": "expanded from macro 'LLVM_YAML_STRONG_TYPEDEF'"}, {"location": {"col": 1, "file": 19, "line": 1690}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLTraits.h", "reportHash": "e8919ab204ee0c29b784df546f7b8a74", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 19, "line": 1676}, "message": "expanded from macro 'LLVM_YAML_STRONG_TYPEDEF'"}, {"location": {"col": 1, "file": 19, "line": 1690}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLTraits.h", "reportHash": "92bc3d81d8d87985c4103ac9042358e1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
