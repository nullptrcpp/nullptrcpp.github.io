<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"79": {"id": 79, "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp", "content": "//===- CodeGenPrepare.cpp - Prepare a function for code generation --------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This pass munges the code in the input function to better prepare it for\n// SelectionDAG-based code generation. This works around limitations in it's\n// basic-block-at-a-time approach. It should eventually be removed.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/MapVector.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/Statistic.h\"\n#include \"llvm/Analysis/BlockFrequencyInfo.h\"\n#include \"llvm/Analysis/BranchProbabilityInfo.h\"\n#include \"llvm/Analysis/ConstantFolding.h\"\n#include \"llvm/Analysis/InstructionSimplify.h\"\n#include \"llvm/Analysis/LoopInfo.h\"\n#include \"llvm/Analysis/MemoryBuiltins.h\"\n#include \"llvm/Analysis/ProfileSummaryInfo.h\"\n#include \"llvm/Analysis/TargetLibraryInfo.h\"\n#include \"llvm/Analysis/TargetTransformInfo.h\"\n#include \"llvm/Analysis/ValueTracking.h\"\n#include \"llvm/Analysis/VectorUtils.h\"\n#include \"llvm/CodeGen/Analysis.h\"\n#include \"llvm/CodeGen/ISDOpcodes.h\"\n#include \"llvm/CodeGen/SelectionDAGNodes.h\"\n#include \"llvm/CodeGen/TargetLowering.h\"\n#include \"llvm/CodeGen/TargetPassConfig.h\"\n#include \"llvm/CodeGen/TargetSubtargetInfo.h\"\n#include \"llvm/CodeGen/ValueTypes.h\"\n#include \"llvm/Config/llvm-config.h\"\n#include \"llvm/IR/Argument.h\"\n#include \"llvm/IR/Attributes.h\"\n#include \"llvm/IR/BasicBlock.h\"\n#include \"llvm/IR/Constant.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/DataLayout.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/Dominators.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/GetElementPtrTypeIterator.h\"\n#include \"llvm/IR/GlobalValue.h\"\n#include \"llvm/IR/GlobalVariable.h\"\n#include \"llvm/IR/IRBuilder.h\"\n#include \"llvm/IR/InlineAsm.h\"\n#include \"llvm/IR/InstrTypes.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/IntrinsicInst.h\"\n#include \"llvm/IR/Intrinsics.h\"\n#include \"llvm/IR/IntrinsicsAArch64.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/MDBuilder.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/Operator.h\"\n#include \"llvm/IR/PatternMatch.h\"\n#include \"llvm/IR/Statepoint.h\"\n#include \"llvm/IR/Type.h\"\n#include \"llvm/IR/Use.h\"\n#include \"llvm/IR/User.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/IR/ValueHandle.h\"\n#include \"llvm/IR/ValueMap.h\"\n#include \"llvm/InitializePasses.h\"\n#include \"llvm/Pass.h\"\n#include \"llvm/Support/BlockFrequency.h\"\n#include \"llvm/Support/BranchProbability.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/MachineValueType.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include \"llvm/Target/TargetMachine.h\"\n#include \"llvm/Target/TargetOptions.h\"\n#include \"llvm/Transforms/Utils/BasicBlockUtils.h\"\n#include \"llvm/Transforms/Utils/BypassSlowDivision.h\"\n#include \"llvm/Transforms/Utils/Local.h\"\n#include \"llvm/Transforms/Utils/SimplifyLibCalls.h\"\n#include \"llvm/Transforms/Utils/SizeOpts.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <iterator>\n#include <limits>\n#include <memory>\n#include <utility>\n#include <vector>\n\nusing namespace llvm;\nusing namespace llvm::PatternMatch;\n\n#define DEBUG_TYPE \"codegenprepare\"\n\nSTATISTIC(NumBlocksElim, \"Number of blocks eliminated\");\nSTATISTIC(NumPHIsElim,   \"Number of trivial PHIs eliminated\");\nSTATISTIC(NumGEPsElim,   \"Number of GEPs converted to casts\");\nSTATISTIC(NumCmpUses, \"Number of uses of Cmp expressions replaced with uses of \"\n                      \"sunken Cmps\");\nSTATISTIC(NumCastUses, \"Number of uses of Cast expressions replaced with uses \"\n                       \"of sunken Casts\");\nSTATISTIC(NumMemoryInsts, \"Number of memory instructions whose address \"\n                          \"computations were sunk\");\nSTATISTIC(NumMemoryInstsPhiCreated,\n          \"Number of phis created when address \"\n          \"computations were sunk to memory instructions\");\nSTATISTIC(NumMemoryInstsSelectCreated,\n          \"Number of select created when address \"\n          \"computations were sunk to memory instructions\");\nSTATISTIC(NumExtsMoved,  \"Number of [s|z]ext instructions combined with loads\");\nSTATISTIC(NumExtUses,    \"Number of uses of [s|z]ext instructions optimized\");\nSTATISTIC(NumAndsAdded,\n          \"Number of and mask instructions added to form ext loads\");\nSTATISTIC(NumAndUses, \"Number of uses of and mask instructions optimized\");\nSTATISTIC(NumRetsDup,    \"Number of return instructions duplicated\");\nSTATISTIC(NumDbgValueMoved, \"Number of debug value instructions moved\");\nSTATISTIC(NumSelectsExpanded, \"Number of selects turned into branches\");\nSTATISTIC(NumStoreExtractExposed, \"Number of store(extractelement) exposed\");\n\nstatic cl::opt<bool> DisableBranchOpts(\n  \"disable-cgp-branch-opts\", cl::Hidden, cl::init(false),\n  cl::desc(\"Disable branch optimizations in CodeGenPrepare\"));\n\nstatic cl::opt<bool>\n    DisableGCOpts(\"disable-cgp-gc-opts\", cl::Hidden, cl::init(false),\n                  cl::desc(\"Disable GC optimizations in CodeGenPrepare\"));\n\nstatic cl::opt<bool> DisableSelectToBranch(\n  \"disable-cgp-select2branch\", cl::Hidden, cl::init(false),\n  cl::desc(\"Disable select to branch conversion.\"));\n\nstatic cl::opt<bool> AddrSinkUsingGEPs(\n  \"addr-sink-using-gep\", cl::Hidden, cl::init(true),\n  cl::desc(\"Address sinking in CGP using GEPs.\"));\n\nstatic cl::opt<bool> EnableAndCmpSinking(\n   \"enable-andcmp-sinking\", cl::Hidden, cl::init(true),\n   cl::desc(\"Enable sinkinig and/cmp into branches.\"));\n\nstatic cl::opt<bool> DisableStoreExtract(\n    \"disable-cgp-store-extract\", cl::Hidden, cl::init(false),\n    cl::desc(\"Disable store(extract) optimizations in CodeGenPrepare\"));\n\nstatic cl::opt<bool> StressStoreExtract(\n    \"stress-cgp-store-extract\", cl::Hidden, cl::init(false),\n    cl::desc(\"Stress test store(extract) optimizations in CodeGenPrepare\"));\n\nstatic cl::opt<bool> DisableExtLdPromotion(\n    \"disable-cgp-ext-ld-promotion\", cl::Hidden, cl::init(false),\n    cl::desc(\"Disable ext(promotable(ld)) -> promoted(ext(ld)) optimization in \"\n             \"CodeGenPrepare\"));\n\nstatic cl::opt<bool> StressExtLdPromotion(\n    \"stress-cgp-ext-ld-promotion\", cl::Hidden, cl::init(false),\n    cl::desc(\"Stress test ext(promotable(ld)) -> promoted(ext(ld)) \"\n             \"optimization in CodeGenPrepare\"));\n\nstatic cl::opt<bool> DisablePreheaderProtect(\n    \"disable-preheader-prot\", cl::Hidden, cl::init(false),\n    cl::desc(\"Disable protection against removing loop preheaders\"));\n\nstatic cl::opt<bool> ProfileGuidedSectionPrefix(\n    \"profile-guided-section-prefix\", cl::Hidden, cl::init(true), cl::ZeroOrMore,\n    cl::desc(\"Use profile info to add section prefix for hot/cold functions\"));\n\nstatic cl::opt<bool> ProfileUnknownInSpecialSection(\n    \"profile-unknown-in-special-section\", cl::Hidden, cl::init(false),\n    cl::ZeroOrMore,\n    cl::desc(\"In profiling mode like sampleFDO, if a function doesn't have \"\n             \"profile, we cannot tell the function is cold for sure because \"\n             \"it may be a function newly added without ever being sampled. \"\n             \"With the flag enabled, compiler can put such profile unknown \"\n             \"functions into a special section, so runtime system can choose \"\n             \"to handle it in a different way than .text section, to save \"\n             \"RAM for example. \"));\n\nstatic cl::opt<unsigned> FreqRatioToSkipMerge(\n    \"cgp-freq-ratio-to-skip-merge\", cl::Hidden, cl::init(2),\n    cl::desc(\"Skip merging empty blocks if (frequency of empty block) / \"\n             \"(frequency of destination block) is greater than this ratio\"));\n\nstatic cl::opt<bool> ForceSplitStore(\n    \"force-split-store\", cl::Hidden, cl::init(false),\n    cl::desc(\"Force store splitting no matter what the target query says.\"));\n\nstatic cl::opt<bool>\nEnableTypePromotionMerge(\"cgp-type-promotion-merge\", cl::Hidden,\n    cl::desc(\"Enable merging of redundant sexts when one is dominating\"\n    \" the other.\"), cl::init(true));\n\nstatic cl::opt<bool> DisableComplexAddrModes(\n    \"disable-complex-addr-modes\", cl::Hidden, cl::init(false),\n    cl::desc(\"Disables combining addressing modes with different parts \"\n             \"in optimizeMemoryInst.\"));\n\nstatic cl::opt<bool>\nAddrSinkNewPhis(\"addr-sink-new-phis\", cl::Hidden, cl::init(false),\n                cl::desc(\"Allow creation of Phis in Address sinking.\"));\n\nstatic cl::opt<bool>\nAddrSinkNewSelects(\"addr-sink-new-select\", cl::Hidden, cl::init(true),\n                   cl::desc(\"Allow creation of selects in Address sinking.\"));\n\nstatic cl::opt<bool> AddrSinkCombineBaseReg(\n    \"addr-sink-combine-base-reg\", cl::Hidden, cl::init(true),\n    cl::desc(\"Allow combining of BaseReg field in Address sinking.\"));\n\nstatic cl::opt<bool> AddrSinkCombineBaseGV(\n    \"addr-sink-combine-base-gv\", cl::Hidden, cl::init(true),\n    cl::desc(\"Allow combining of BaseGV field in Address sinking.\"));\n\nstatic cl::opt<bool> AddrSinkCombineBaseOffs(\n    \"addr-sink-combine-base-offs\", cl::Hidden, cl::init(true),\n    cl::desc(\"Allow combining of BaseOffs field in Address sinking.\"));\n\nstatic cl::opt<bool> AddrSinkCombineScaledReg(\n    \"addr-sink-combine-scaled-reg\", cl::Hidden, cl::init(true),\n    cl::desc(\"Allow combining of ScaledReg field in Address sinking.\"));\n\nstatic cl::opt<bool>\n    EnableGEPOffsetSplit(\"cgp-split-large-offset-gep\", cl::Hidden,\n                         cl::init(true),\n                         cl::desc(\"Enable splitting large offset of GEP.\"));\n\nstatic cl::opt<bool> EnableICMP_EQToICMP_ST(\n    \"cgp-icmp-eq2icmp-st\", cl::Hidden, cl::init(false),\n    cl::desc(\"Enable ICMP_EQ to ICMP_S(L|G)T conversion.\"));\n\nstatic cl::opt<bool>\n    VerifyBFIUpdates(\"cgp-verify-bfi-updates\", cl::Hidden, cl::init(false),\n                     cl::desc(\"Enable BFI update verification for \"\n                              \"CodeGenPrepare.\"));\n\nstatic cl::opt<bool> OptimizePhiTypes(\n    \"cgp-optimize-phi-types\", cl::Hidden, cl::init(false),\n    cl::desc(\"Enable converting phi types in CodeGenPrepare\"));\n\nnamespace {\n\nenum ExtType {\n  ZeroExtension,   // Zero extension has been seen.\n  SignExtension,   // Sign extension has been seen.\n  BothExtension    // This extension type is used if we saw sext after\n                   // ZeroExtension had been set, or if we saw zext after\n                   // SignExtension had been set. It makes the type\n                   // information of a promoted instruction invalid.\n};\n\nusing SetOfInstrs = SmallPtrSet<Instruction *, 16>;\nusing TypeIsSExt = PointerIntPair<Type *, 2, ExtType>;\nusing InstrToOrigTy = DenseMap<Instruction *, TypeIsSExt>;\nusing SExts = SmallVector<Instruction *, 16>;\nusing ValueToSExts = DenseMap<Value *, SExts>;\n\nclass TypePromotionTransaction;\n\n  class CodeGenPrepare : public FunctionPass {\n    const TargetMachine *TM = nullptr;\n    const TargetSubtargetInfo *SubtargetInfo;\n    const TargetLowering *TLI = nullptr;\n    const TargetRegisterInfo *TRI;\n    const TargetTransformInfo *TTI = nullptr;\n    const TargetLibraryInfo *TLInfo;\n    const LoopInfo *LI;\n    std::unique_ptr<BlockFrequencyInfo> BFI;\n    std::unique_ptr<BranchProbabilityInfo> BPI;\n    ProfileSummaryInfo *PSI;\n\n    /// As we scan instructions optimizing them, this is the next instruction\n    /// to optimize. Transforms that can invalidate this should update it.\n    BasicBlock::iterator CurInstIterator;\n\n    /// Keeps track of non-local addresses that have been sunk into a block.\n    /// This allows us to avoid inserting duplicate code for blocks with\n    /// multiple load/stores of the same address. The usage of WeakTrackingVH\n    /// enables SunkAddrs to be treated as a cache whose entries can be\n    /// invalidated if a sunken address computation has been erased.\n    ValueMap<Value*, WeakTrackingVH> SunkAddrs;\n\n    /// Keeps track of all instructions inserted for the current function.\n    SetOfInstrs InsertedInsts;\n\n    /// Keeps track of the type of the related instruction before their\n    /// promotion for the current function.\n    InstrToOrigTy PromotedInsts;\n\n    /// Keep track of instructions removed during promotion.\n    SetOfInstrs RemovedInsts;\n\n    /// Keep track of sext chains based on their initial value.\n    DenseMap<Value *, Instruction *> SeenChainsForSExt;\n\n    /// Keep track of GEPs accessing the same data structures such as structs or\n    /// arrays that are candidates to be split later because of their large\n    /// size.\n    MapVector<\n        AssertingVH<Value>,\n        SmallVector<std::pair<AssertingVH<GetElementPtrInst>, int64_t>, 32>>\n        LargeOffsetGEPMap;\n\n    /// Keep track of new GEP base after splitting the GEPs having large offset.\n    SmallSet<AssertingVH<Value>, 2> NewGEPBases;\n\n    /// Map serial numbers to Large offset GEPs.\n    DenseMap<AssertingVH<GetElementPtrInst>, int> LargeOffsetGEPID;\n\n    /// Keep track of SExt promoted.\n    ValueToSExts ValToSExtendedUses;\n\n    /// True if the function has the OptSize attribute.\n    bool OptSize;\n\n    /// DataLayout for the Function being processed.\n    const DataLayout *DL = nullptr;\n\n    /// Building the dominator tree can be expensive, so we only build it\n    /// lazily and update it when required.\n    std::unique_ptr<DominatorTree> DT;\n\n  public:\n    static char ID; // Pass identification, replacement for typeid\n\n    CodeGenPrepare() : FunctionPass(ID) {\n      initializeCodeGenPreparePass(*PassRegistry::getPassRegistry());\n    }\n\n    bool runOnFunction(Function &F) override;\n\n    StringRef getPassName() const override { return \"CodeGen Prepare\"; }\n\n    void getAnalysisUsage(AnalysisUsage &AU) const override {\n      // FIXME: When we can selectively preserve passes, preserve the domtree.\n      AU.addRequired<ProfileSummaryInfoWrapperPass>();\n      AU.addRequired<TargetLibraryInfoWrapperPass>();\n      AU.addRequired<TargetPassConfig>();\n      AU.addRequired<TargetTransformInfoWrapperPass>();\n      AU.addRequired<LoopInfoWrapperPass>();\n    }\n\n  private:\n    template <typename F>\n    void resetIteratorIfInvalidatedWhileCalling(BasicBlock *BB, F f) {\n      // Substituting can cause recursive simplifications, which can invalidate\n      // our iterator.  Use a WeakTrackingVH to hold onto it in case this\n      // happens.\n      Value *CurValue = &*CurInstIterator;\n      WeakTrackingVH IterHandle(CurValue);\n\n      f();\n\n      // If the iterator instruction was recursively deleted, start over at the\n      // start of the block.\n      if (IterHandle != CurValue) {\n        CurInstIterator = BB->begin();\n        SunkAddrs.clear();\n      }\n    }\n\n    // Get the DominatorTree, building if necessary.\n    DominatorTree &getDT(Function &F) {\n      if (!DT)\n        DT = std::make_unique<DominatorTree>(F);\n      return *DT;\n    }\n\n    void removeAllAssertingVHReferences(Value *V);\n    bool eliminateAssumptions(Function &F);\n    bool eliminateFallThrough(Function &F);\n    bool eliminateMostlyEmptyBlocks(Function &F);\n    BasicBlock *findDestBlockOfMergeableEmptyBlock(BasicBlock *BB);\n    bool canMergeBlocks(const BasicBlock *BB, const BasicBlock *DestBB) const;\n    void eliminateMostlyEmptyBlock(BasicBlock *BB);\n    bool isMergingEmptyBlockProfitable(BasicBlock *BB, BasicBlock *DestBB,\n                                       bool isPreheader);\n    bool makeBitReverse(Instruction &I);\n    bool optimizeBlock(BasicBlock &BB, bool &ModifiedDT);\n    bool optimizeInst(Instruction *I, bool &ModifiedDT);\n    bool optimizeMemoryInst(Instruction *MemoryInst, Value *Addr,\n                            Type *AccessTy, unsigned AddrSpace);\n    bool optimizeGatherScatterInst(Instruction *MemoryInst, Value *Ptr);\n    bool optimizeInlineAsmInst(CallInst *CS);\n    bool optimizeCallInst(CallInst *CI, bool &ModifiedDT);\n    bool optimizeExt(Instruction *&I);\n    bool optimizeExtUses(Instruction *I);\n    bool optimizeLoadExt(LoadInst *Load);\n    bool optimizeShiftInst(BinaryOperator *BO);\n    bool optimizeFunnelShift(IntrinsicInst *Fsh);\n    bool optimizeSelectInst(SelectInst *SI);\n    bool optimizeShuffleVectorInst(ShuffleVectorInst *SVI);\n    bool optimizeSwitchInst(SwitchInst *SI);\n    bool optimizeExtractElementInst(Instruction *Inst);\n    bool dupRetToEnableTailCallOpts(BasicBlock *BB, bool &ModifiedDT);\n    bool fixupDbgValue(Instruction *I);\n    bool placeDbgValues(Function &F);\n    bool canFormExtLd(const SmallVectorImpl<Instruction *> &MovedExts,\n                      LoadInst *&LI, Instruction *&Inst, bool HasPromoted);\n    bool tryToPromoteExts(TypePromotionTransaction &TPT,\n                          const SmallVectorImpl<Instruction *> &Exts,\n                          SmallVectorImpl<Instruction *> &ProfitablyMovedExts,\n                          unsigned CreatedInstsCost = 0);\n    bool mergeSExts(Function &F);\n    bool splitLargeGEPOffsets();\n    bool optimizePhiType(PHINode *Inst, SmallPtrSetImpl<PHINode *> &Visited,\n                         SmallPtrSetImpl<Instruction *> &DeletedInstrs);\n    bool optimizePhiTypes(Function &F);\n    bool performAddressTypePromotion(\n        Instruction *&Inst,\n        bool AllowPromotionWithoutCommonHeader,\n        bool HasPromoted, TypePromotionTransaction &TPT,\n        SmallVectorImpl<Instruction *> &SpeculativelyMovedExts);\n    bool splitBranchCondition(Function &F, bool &ModifiedDT);\n    bool simplifyOffsetableRelocate(GCStatepointInst &I);\n\n    bool tryToSinkFreeOperands(Instruction *I);\n    bool replaceMathCmpWithIntrinsic(BinaryOperator *BO, Value *Arg0,\n                                     Value *Arg1, CmpInst *Cmp,\n                                     Intrinsic::ID IID);\n    bool optimizeCmp(CmpInst *Cmp, bool &ModifiedDT);\n    bool combineToUSubWithOverflow(CmpInst *Cmp, bool &ModifiedDT);\n    bool combineToUAddWithOverflow(CmpInst *Cmp, bool &ModifiedDT);\n    void verifyBFIUpdates(Function &F);\n  };\n\n} // end anonymous namespace\n\nchar CodeGenPrepare::ID = 0;\n\nINITIALIZE_PASS_BEGIN(CodeGenPrepare, DEBUG_TYPE,\n                      \"Optimize for code generation\", false, false)\nINITIALIZE_PASS_DEPENDENCY(LoopInfoWrapperPass)\nINITIALIZE_PASS_DEPENDENCY(ProfileSummaryInfoWrapperPass)\nINITIALIZE_PASS_DEPENDENCY(TargetLibraryInfoWrapperPass)\nINITIALIZE_PASS_DEPENDENCY(TargetPassConfig)\nINITIALIZE_PASS_DEPENDENCY(TargetTransformInfoWrapperPass)\nINITIALIZE_PASS_END(CodeGenPrepare, DEBUG_TYPE,\n                    \"Optimize for code generation\", false, false)\n\nFunctionPass *llvm::createCodeGenPreparePass() { return new CodeGenPrepare(); }\n\nbool CodeGenPrepare::runOnFunction(Function &F) {\n  if (skipFunction(F))\n    return false;\n\n  DL = &F.getParent()->getDataLayout();\n\n  bool EverMadeChange = false;\n  // Clear per function information.\n  InsertedInsts.clear();\n  PromotedInsts.clear();\n\n  TM = &getAnalysis<TargetPassConfig>().getTM<TargetMachine>();\n  SubtargetInfo = TM->getSubtargetImpl(F);\n  TLI = SubtargetInfo->getTargetLowering();\n  TRI = SubtargetInfo->getRegisterInfo();\n  TLInfo = &getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(F);\n  TTI = &getAnalysis<TargetTransformInfoWrapperPass>().getTTI(F);\n  LI = &getAnalysis<LoopInfoWrapperPass>().getLoopInfo();\n  BPI.reset(new BranchProbabilityInfo(F, *LI));\n  BFI.reset(new BlockFrequencyInfo(F, *BPI, *LI));\n  PSI = &getAnalysis<ProfileSummaryInfoWrapperPass>().getPSI();\n  OptSize = F.hasOptSize();\n  if (ProfileGuidedSectionPrefix) {\n    // The hot attribute overwrites profile count based hotness while profile\n    // counts based hotness overwrite the cold attribute.\n    // This is a conservative behabvior.\n    if (F.hasFnAttribute(Attribute::Hot) ||\n        PSI->isFunctionHotInCallGraph(&F, *BFI))\n      F.setSectionPrefix(\"hot\");\n    // If PSI shows this function is not hot, we will placed the function\n    // into unlikely section if (1) PSI shows this is a cold function, or\n    // (2) the function has a attribute of cold.\n    else if (PSI->isFunctionColdInCallGraph(&F, *BFI) ||\n             F.hasFnAttribute(Attribute::Cold))\n      F.setSectionPrefix(\"unlikely\");\n    else if (ProfileUnknownInSpecialSection && PSI->hasPartialSampleProfile() &&\n             PSI->isFunctionHotnessUnknown(F))\n      F.setSectionPrefix(\"unknown\");\n  }\n\n  /// This optimization identifies DIV instructions that can be\n  /// profitably bypassed and carried out with a shorter, faster divide.\n  if (!OptSize && !PSI->hasHugeWorkingSetSize() && TLI->isSlowDivBypassed()) {\n    const DenseMap<unsigned int, unsigned int> &BypassWidths =\n        TLI->getBypassSlowDivWidths();\n    BasicBlock* BB = &*F.begin();\n    while (BB != nullptr) {\n      // bypassSlowDivision may create new BBs, but we don't want to reapply the\n      // optimization to those blocks.\n      BasicBlock* Next = BB->getNextNode();\n      // F.hasOptSize is already checked in the outer if statement.\n      if (!llvm::shouldOptimizeForSize(BB, PSI, BFI.get()))\n        EverMadeChange |= bypassSlowDivision(BB, BypassWidths);\n      BB = Next;\n    }\n  }\n\n  // Get rid of @llvm.assume builtins before attempting to eliminate empty\n  // blocks, since there might be blocks that only contain @llvm.assume calls\n  // (plus arguments that we can get rid of).\n  EverMadeChange |= eliminateAssumptions(F);\n\n  // Eliminate blocks that contain only PHI nodes and an\n  // unconditional branch.\n  EverMadeChange |= eliminateMostlyEmptyBlocks(F);\n\n  bool ModifiedDT = false;\n  if (!DisableBranchOpts)\n    EverMadeChange |= splitBranchCondition(F, ModifiedDT);\n\n  // Split some critical edges where one of the sources is an indirect branch,\n  // to help generate sane code for PHIs involving such edges.\n  EverMadeChange |= SplitIndirectBrCriticalEdges(F);\n\n  bool MadeChange = true;\n  while (MadeChange) {\n    MadeChange = false;\n    DT.reset();\n    for (Function::iterator I = F.begin(); I != F.end(); ) {\n      BasicBlock *BB = &*I++;\n      bool ModifiedDTOnIteration = false;\n      MadeChange |= optimizeBlock(*BB, ModifiedDTOnIteration);\n\n      // Restart BB iteration if the dominator tree of the Function was changed\n      if (ModifiedDTOnIteration)\n        break;\n    }\n    if (EnableTypePromotionMerge && !ValToSExtendedUses.empty())\n      MadeChange |= mergeSExts(F);\n    if (!LargeOffsetGEPMap.empty())\n      MadeChange |= splitLargeGEPOffsets();\n    MadeChange |= optimizePhiTypes(F);\n\n    if (MadeChange)\n      eliminateFallThrough(F);\n\n    // Really free removed instructions during promotion.\n    for (Instruction *I : RemovedInsts)\n      I->deleteValue();\n\n    EverMadeChange |= MadeChange;\n    SeenChainsForSExt.clear();\n    ValToSExtendedUses.clear();\n    RemovedInsts.clear();\n    LargeOffsetGEPMap.clear();\n    LargeOffsetGEPID.clear();\n  }\n\n  NewGEPBases.clear();\n  SunkAddrs.clear();\n\n  if (!DisableBranchOpts) {\n    MadeChange = false;\n    // Use a set vector to get deterministic iteration order. The order the\n    // blocks are removed may affect whether or not PHI nodes in successors\n    // are removed.\n    SmallSetVector<BasicBlock*, 8> WorkList;\n    for (BasicBlock &BB : F) {\n      SmallVector<BasicBlock *, 2> Successors(successors(&BB));\n      MadeChange |= ConstantFoldTerminator(&BB, true);\n      if (!MadeChange) continue;\n\n      for (BasicBlock *Succ : Successors)\n        if (pred_empty(Succ))\n          WorkList.insert(Succ);\n    }\n\n    // Delete the dead blocks and any of their dead successors.\n    MadeChange |= !WorkList.empty();\n    while (!WorkList.empty()) {\n      BasicBlock *BB = WorkList.pop_back_val();\n      SmallVector<BasicBlock*, 2> Successors(successors(BB));\n\n      DeleteDeadBlock(BB);\n\n      for (BasicBlock *Succ : Successors)\n        if (pred_empty(Succ))\n          WorkList.insert(Succ);\n    }\n\n    // Merge pairs of basic blocks with unconditional branches, connected by\n    // a single edge.\n    if (EverMadeChange || MadeChange)\n      MadeChange |= eliminateFallThrough(F);\n\n    EverMadeChange |= MadeChange;\n  }\n\n  if (!DisableGCOpts) {\n    SmallVector<GCStatepointInst *, 2> Statepoints;\n    for (BasicBlock &BB : F)\n      for (Instruction &I : BB)\n        if (auto *SP = dyn_cast<GCStatepointInst>(&I))\n          Statepoints.push_back(SP);\n    for (auto &I : Statepoints)\n      EverMadeChange |= simplifyOffsetableRelocate(*I);\n  }\n\n  // Do this last to clean up use-before-def scenarios introduced by other\n  // preparatory transforms.\n  EverMadeChange |= placeDbgValues(F);\n\n#ifndef NDEBUG\n  if (VerifyBFIUpdates)\n    verifyBFIUpdates(F);\n#endif\n\n  return EverMadeChange;\n}\n\nbool CodeGenPrepare::eliminateAssumptions(Function &F) {\n  bool MadeChange = false;\n  for (BasicBlock &BB : F) {\n    CurInstIterator = BB.begin();\n    while (CurInstIterator != BB.end()) {\n      Instruction *I = &*(CurInstIterator++);\n      if (IntrinsicInst *II = dyn_cast<IntrinsicInst>(I)) {\n        if (II->getIntrinsicID() != Intrinsic::assume)\n          continue;\n        MadeChange = true;\n        Value *Operand = II->getOperand(0);\n        II->eraseFromParent();\n\n        resetIteratorIfInvalidatedWhileCalling(&BB, [&]() {\n          RecursivelyDeleteTriviallyDeadInstructions(Operand, TLInfo, nullptr);\n        });\n      }\n    }\n  }\n  return MadeChange;\n}\n\n/// An instruction is about to be deleted, so remove all references to it in our\n/// GEP-tracking data strcutures.\nvoid CodeGenPrepare::removeAllAssertingVHReferences(Value *V) {\n  LargeOffsetGEPMap.erase(V);\n  NewGEPBases.erase(V);\n\n  auto GEP = dyn_cast<GetElementPtrInst>(V);\n  if (!GEP)\n    return;\n\n  LargeOffsetGEPID.erase(GEP);\n\n  auto VecI = LargeOffsetGEPMap.find(GEP->getPointerOperand());\n  if (VecI == LargeOffsetGEPMap.end())\n    return;\n\n  auto &GEPVector = VecI->second;\n  const auto &I =\n      llvm::find_if(GEPVector, [=](auto &Elt) { return Elt.first == GEP; });\n  if (I == GEPVector.end())\n    return;\n\n  GEPVector.erase(I);\n  if (GEPVector.empty())\n    LargeOffsetGEPMap.erase(VecI);\n}\n\n// Verify BFI has been updated correctly by recomputing BFI and comparing them.\nvoid LLVM_ATTRIBUTE_UNUSED CodeGenPrepare::verifyBFIUpdates(Function &F) {\n  DominatorTree NewDT(F);\n  LoopInfo NewLI(NewDT);\n  BranchProbabilityInfo NewBPI(F, NewLI, TLInfo);\n  BlockFrequencyInfo NewBFI(F, NewBPI, NewLI);\n  NewBFI.verifyMatch(*BFI);\n}\n\n/// Merge basic blocks which are connected by a single edge, where one of the\n/// basic blocks has a single successor pointing to the other basic block,\n/// which has a single predecessor.\nbool CodeGenPrepare::eliminateFallThrough(Function &F) {\n  bool Changed = false;\n  // Scan all of the blocks in the function, except for the entry block.\n  // Use a temporary array to avoid iterator being invalidated when\n  // deleting blocks.\n  SmallVector<WeakTrackingVH, 16> Blocks;\n  for (auto &Block : llvm::drop_begin(F))\n    Blocks.push_back(&Block);\n\n  SmallSet<WeakTrackingVH, 16> Preds;\n  for (auto &Block : Blocks) {\n    auto *BB = cast_or_null<BasicBlock>(Block);\n    if (!BB)\n      continue;\n    // If the destination block has a single pred, then this is a trivial\n    // edge, just collapse it.\n    BasicBlock *SinglePred = BB->getSinglePredecessor();\n\n    // Don't merge if BB's address is taken.\n    if (!SinglePred || SinglePred == BB || BB->hasAddressTaken()) continue;\n\n    BranchInst *Term = dyn_cast<BranchInst>(SinglePred->getTerminator());\n    if (Term && !Term->isConditional()) {\n      Changed = true;\n      LLVM_DEBUG(dbgs() << \"To merge:\\n\" << *BB << \"\\n\\n\\n\");\n\n      // Merge BB into SinglePred and delete it.\n      MergeBlockIntoPredecessor(BB);\n      Preds.insert(SinglePred);\n    }\n  }\n\n  // (Repeatedly) merging blocks into their predecessors can create redundant\n  // debug intrinsics.\n  for (auto &Pred : Preds)\n    if (auto *BB = cast_or_null<BasicBlock>(Pred))\n      RemoveRedundantDbgInstrs(BB);\n\n  return Changed;\n}\n\n/// Find a destination block from BB if BB is mergeable empty block.\nBasicBlock *CodeGenPrepare::findDestBlockOfMergeableEmptyBlock(BasicBlock *BB) {\n  // If this block doesn't end with an uncond branch, ignore it.\n  BranchInst *BI = dyn_cast<BranchInst>(BB->getTerminator());\n  if (!BI || !BI->isUnconditional())\n    return nullptr;\n\n  // If the instruction before the branch (skipping debug info) isn't a phi\n  // node, then other stuff is happening here.\n  BasicBlock::iterator BBI = BI->getIterator();\n  if (BBI != BB->begin()) {\n    --BBI;\n    while (isa<DbgInfoIntrinsic>(BBI)) {\n      if (BBI == BB->begin())\n        break;\n      --BBI;\n    }\n    if (!isa<DbgInfoIntrinsic>(BBI) && !isa<PHINode>(BBI))\n      return nullptr;\n  }\n\n  // Do not break infinite loops.\n  BasicBlock *DestBB = BI->getSuccessor(0);\n  if (DestBB == BB)\n    return nullptr;\n\n  if (!canMergeBlocks(BB, DestBB))\n    DestBB = nullptr;\n\n  return DestBB;\n}\n\n/// Eliminate blocks that contain only PHI nodes, debug info directives, and an\n/// unconditional branch. Passes before isel (e.g. LSR/loopsimplify) often split\n/// edges in ways that are non-optimal for isel. Start by eliminating these\n/// blocks so we can split them the way we want them.\nbool CodeGenPrepare::eliminateMostlyEmptyBlocks(Function &F) {\n  SmallPtrSet<BasicBlock *, 16> Preheaders;\n  SmallVector<Loop *, 16> LoopList(LI->begin(), LI->end());\n  while (!LoopList.empty()) {\n    Loop *L = LoopList.pop_back_val();\n    llvm::append_range(LoopList, *L);\n    if (BasicBlock *Preheader = L->getLoopPreheader())\n      Preheaders.insert(Preheader);\n  }\n\n  bool MadeChange = false;\n  // Copy blocks into a temporary array to avoid iterator invalidation issues\n  // as we remove them.\n  // Note that this intentionally skips the entry block.\n  SmallVector<WeakTrackingVH, 16> Blocks;\n  for (auto &Block : llvm::drop_begin(F))\n    Blocks.push_back(&Block);\n\n  for (auto &Block : Blocks) {\n    BasicBlock *BB = cast_or_null<BasicBlock>(Block);\n    if (!BB)\n      continue;\n    BasicBlock *DestBB = findDestBlockOfMergeableEmptyBlock(BB);\n    if (!DestBB ||\n        !isMergingEmptyBlockProfitable(BB, DestBB, Preheaders.count(BB)))\n      continue;\n\n    eliminateMostlyEmptyBlock(BB);\n    MadeChange = true;\n  }\n  return MadeChange;\n}\n\nbool CodeGenPrepare::isMergingEmptyBlockProfitable(BasicBlock *BB,\n                                                   BasicBlock *DestBB,\n                                                   bool isPreheader) {\n  // Do not delete loop preheaders if doing so would create a critical edge.\n  // Loop preheaders can be good locations to spill registers. If the\n  // preheader is deleted and we create a critical edge, registers may be\n  // spilled in the loop body instead.\n  if (!DisablePreheaderProtect && isPreheader &&\n      !(BB->getSinglePredecessor() &&\n        BB->getSinglePredecessor()->getSingleSuccessor()))\n    return false;\n\n  // Skip merging if the block's successor is also a successor to any callbr\n  // that leads to this block.\n  // FIXME: Is this really needed? Is this a correctness issue?\n  for (BasicBlock *Pred : predecessors(BB)) {\n    if (auto *CBI = dyn_cast<CallBrInst>((Pred)->getTerminator()))\n      for (unsigned i = 0, e = CBI->getNumSuccessors(); i != e; ++i)\n        if (DestBB == CBI->getSuccessor(i))\n          return false;\n  }\n\n  // Try to skip merging if the unique predecessor of BB is terminated by a\n  // switch or indirect branch instruction, and BB is used as an incoming block\n  // of PHIs in DestBB. In such case, merging BB and DestBB would cause ISel to\n  // add COPY instructions in the predecessor of BB instead of BB (if it is not\n  // merged). Note that the critical edge created by merging such blocks wont be\n  // split in MachineSink because the jump table is not analyzable. By keeping\n  // such empty block (BB), ISel will place COPY instructions in BB, not in the\n  // predecessor of BB.\n  BasicBlock *Pred = BB->getUniquePredecessor();\n  if (!Pred ||\n      !(isa<SwitchInst>(Pred->getTerminator()) ||\n        isa<IndirectBrInst>(Pred->getTerminator())))\n    return true;\n\n  if (BB->getTerminator() != BB->getFirstNonPHIOrDbg())\n    return true;\n\n  // We use a simple cost heuristic which determine skipping merging is\n  // profitable if the cost of skipping merging is less than the cost of\n  // merging : Cost(skipping merging) < Cost(merging BB), where the\n  // Cost(skipping merging) is Freq(BB) * (Cost(Copy) + Cost(Branch)), and\n  // the Cost(merging BB) is Freq(Pred) * Cost(Copy).\n  // Assuming Cost(Copy) == Cost(Branch), we could simplify it to :\n  //   Freq(Pred) / Freq(BB) > 2.\n  // Note that if there are multiple empty blocks sharing the same incoming\n  // value for the PHIs in the DestBB, we consider them together. In such\n  // case, Cost(merging BB) will be the sum of their frequencies.\n\n  if (!isa<PHINode>(DestBB->begin()))\n    return true;\n\n  SmallPtrSet<BasicBlock *, 16> SameIncomingValueBBs;\n\n  // Find all other incoming blocks from which incoming values of all PHIs in\n  // DestBB are the same as the ones from BB.\n  for (BasicBlock *DestBBPred : predecessors(DestBB)) {\n    if (DestBBPred == BB)\n      continue;\n\n    if (llvm::all_of(DestBB->phis(), [&](const PHINode &DestPN) {\n          return DestPN.getIncomingValueForBlock(BB) ==\n                 DestPN.getIncomingValueForBlock(DestBBPred);\n        }))\n      SameIncomingValueBBs.insert(DestBBPred);\n  }\n\n  // See if all BB's incoming values are same as the value from Pred. In this\n  // case, no reason to skip merging because COPYs are expected to be place in\n  // Pred already.\n  if (SameIncomingValueBBs.count(Pred))\n    return true;\n\n  BlockFrequency PredFreq = BFI->getBlockFreq(Pred);\n  BlockFrequency BBFreq = BFI->getBlockFreq(BB);\n\n  for (auto *SameValueBB : SameIncomingValueBBs)\n    if (SameValueBB->getUniquePredecessor() == Pred &&\n        DestBB == findDestBlockOfMergeableEmptyBlock(SameValueBB))\n      BBFreq += BFI->getBlockFreq(SameValueBB);\n\n  return PredFreq.getFrequency() <=\n         BBFreq.getFrequency() * FreqRatioToSkipMerge;\n}\n\n/// Return true if we can merge BB into DestBB if there is a single\n/// unconditional branch between them, and BB contains no other non-phi\n/// instructions.\nbool CodeGenPrepare::canMergeBlocks(const BasicBlock *BB,\n                                    const BasicBlock *DestBB) const {\n  // We only want to eliminate blocks whose phi nodes are used by phi nodes in\n  // the successor.  If there are more complex condition (e.g. preheaders),\n  // don't mess around with them.\n  for (const PHINode &PN : BB->phis()) {\n    for (const User *U : PN.users()) {\n      const Instruction *UI = cast<Instruction>(U);\n      if (UI->getParent() != DestBB || !isa<PHINode>(UI))\n        return false;\n      // If User is inside DestBB block and it is a PHINode then check\n      // incoming value. If incoming value is not from BB then this is\n      // a complex condition (e.g. preheaders) we want to avoid here.\n      if (UI->getParent() == DestBB) {\n        if (const PHINode *UPN = dyn_cast<PHINode>(UI))\n          for (unsigned I = 0, E = UPN->getNumIncomingValues(); I != E; ++I) {\n            Instruction *Insn = dyn_cast<Instruction>(UPN->getIncomingValue(I));\n            if (Insn && Insn->getParent() == BB &&\n                Insn->getParent() != UPN->getIncomingBlock(I))\n              return false;\n          }\n      }\n    }\n  }\n\n  // If BB and DestBB contain any common predecessors, then the phi nodes in BB\n  // and DestBB may have conflicting incoming values for the block.  If so, we\n  // can't merge the block.\n  const PHINode *DestBBPN = dyn_cast<PHINode>(DestBB->begin());\n  if (!DestBBPN) return true;  // no conflict.\n\n  // Collect the preds of BB.\n  SmallPtrSet<const BasicBlock*, 16> BBPreds;\n  if (const PHINode *BBPN = dyn_cast<PHINode>(BB->begin())) {\n    // It is faster to get preds from a PHI than with pred_iterator.\n    for (unsigned i = 0, e = BBPN->getNumIncomingValues(); i != e; ++i)\n      BBPreds.insert(BBPN->getIncomingBlock(i));\n  } else {\n    BBPreds.insert(pred_begin(BB), pred_end(BB));\n  }\n\n  // Walk the preds of DestBB.\n  for (unsigned i = 0, e = DestBBPN->getNumIncomingValues(); i != e; ++i) {\n    BasicBlock *Pred = DestBBPN->getIncomingBlock(i);\n    if (BBPreds.count(Pred)) {   // Common predecessor?\n      for (const PHINode &PN : DestBB->phis()) {\n        const Value *V1 = PN.getIncomingValueForBlock(Pred);\n        const Value *V2 = PN.getIncomingValueForBlock(BB);\n\n        // If V2 is a phi node in BB, look up what the mapped value will be.\n        if (const PHINode *V2PN = dyn_cast<PHINode>(V2))\n          if (V2PN->getParent() == BB)\n            V2 = V2PN->getIncomingValueForBlock(Pred);\n\n        // If there is a conflict, bail out.\n        if (V1 != V2) return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/// Eliminate a basic block that has only phi's and an unconditional branch in\n/// it.\nvoid CodeGenPrepare::eliminateMostlyEmptyBlock(BasicBlock *BB) {\n  BranchInst *BI = cast<BranchInst>(BB->getTerminator());\n  BasicBlock *DestBB = BI->getSuccessor(0);\n\n  LLVM_DEBUG(dbgs() << \"MERGING MOSTLY EMPTY BLOCKS - BEFORE:\\n\"\n                    << *BB << *DestBB);\n\n  // If the destination block has a single pred, then this is a trivial edge,\n  // just collapse it.\n  if (BasicBlock *SinglePred = DestBB->getSinglePredecessor()) {\n    if (SinglePred != DestBB) {\n      assert(SinglePred == BB &&\n             \"Single predecessor not the same as predecessor\");\n      // Merge DestBB into SinglePred/BB and delete it.\n      MergeBlockIntoPredecessor(DestBB);\n      // Note: BB(=SinglePred) will not be deleted on this path.\n      // DestBB(=its single successor) is the one that was deleted.\n      LLVM_DEBUG(dbgs() << \"AFTER:\\n\" << *SinglePred << \"\\n\\n\\n\");\n      return;\n    }\n  }\n\n  // Otherwise, we have multiple predecessors of BB.  Update the PHIs in DestBB\n  // to handle the new incoming edges it is about to have.\n  for (PHINode &PN : DestBB->phis()) {\n    // Remove the incoming value for BB, and remember it.\n    Value *InVal = PN.removeIncomingValue(BB, false);\n\n    // Two options: either the InVal is a phi node defined in BB or it is some\n    // value that dominates BB.\n    PHINode *InValPhi = dyn_cast<PHINode>(InVal);\n    if (InValPhi && InValPhi->getParent() == BB) {\n      // Add all of the input values of the input PHI as inputs of this phi.\n      for (unsigned i = 0, e = InValPhi->getNumIncomingValues(); i != e; ++i)\n        PN.addIncoming(InValPhi->getIncomingValue(i),\n                       InValPhi->getIncomingBlock(i));\n    } else {\n      // Otherwise, add one instance of the dominating value for each edge that\n      // we will be adding.\n      if (PHINode *BBPN = dyn_cast<PHINode>(BB->begin())) {\n        for (unsigned i = 0, e = BBPN->getNumIncomingValues(); i != e; ++i)\n          PN.addIncoming(InVal, BBPN->getIncomingBlock(i));\n      } else {\n        for (BasicBlock *Pred : predecessors(BB))\n          PN.addIncoming(InVal, Pred);\n      }\n    }\n  }\n\n  // The PHIs are now updated, change everything that refers to BB to use\n  // DestBB and remove BB.\n  BB->replaceAllUsesWith(DestBB);\n  BB->eraseFromParent();\n  ++NumBlocksElim;\n\n  LLVM_DEBUG(dbgs() << \"AFTER:\\n\" << *DestBB << \"\\n\\n\\n\");\n}\n\n// Computes a map of base pointer relocation instructions to corresponding\n// derived pointer relocation instructions given a vector of all relocate calls\nstatic void computeBaseDerivedRelocateMap(\n    const SmallVectorImpl<GCRelocateInst *> &AllRelocateCalls,\n    DenseMap<GCRelocateInst *, SmallVector<GCRelocateInst *, 2>>\n        &RelocateInstMap) {\n  // Collect information in two maps: one primarily for locating the base object\n  // while filling the second map; the second map is the final structure holding\n  // a mapping between Base and corresponding Derived relocate calls\n  DenseMap<std::pair<unsigned, unsigned>, GCRelocateInst *> RelocateIdxMap;\n  for (auto *ThisRelocate : AllRelocateCalls) {\n    auto K = std::make_pair(ThisRelocate->getBasePtrIndex(),\n                            ThisRelocate->getDerivedPtrIndex());\n    RelocateIdxMap.insert(std::make_pair(K, ThisRelocate));\n  }\n  for (auto &Item : RelocateIdxMap) {\n    std::pair<unsigned, unsigned> Key = Item.first;\n    if (Key.first == Key.second)\n      // Base relocation: nothing to insert\n      continue;\n\n    GCRelocateInst *I = Item.second;\n    auto BaseKey = std::make_pair(Key.first, Key.first);\n\n    // We're iterating over RelocateIdxMap so we cannot modify it.\n    auto MaybeBase = RelocateIdxMap.find(BaseKey);\n    if (MaybeBase == RelocateIdxMap.end())\n      // TODO: We might want to insert a new base object relocate and gep off\n      // that, if there are enough derived object relocates.\n      continue;\n\n    RelocateInstMap[MaybeBase->second].push_back(I);\n  }\n}\n\n// Accepts a GEP and extracts the operands into a vector provided they're all\n// small integer constants\nstatic bool getGEPSmallConstantIntOffsetV(GetElementPtrInst *GEP,\n                                          SmallVectorImpl<Value *> &OffsetV) {\n  for (unsigned i = 1; i < GEP->getNumOperands(); i++) {\n    // Only accept small constant integer operands\n    auto *Op = dyn_cast<ConstantInt>(GEP->getOperand(i));\n    if (!Op || Op->getZExtValue() > 20)\n      return false;\n  }\n\n  for (unsigned i = 1; i < GEP->getNumOperands(); i++)\n    OffsetV.push_back(GEP->getOperand(i));\n  return true;\n}\n\n// Takes a RelocatedBase (base pointer relocation instruction) and Targets to\n// replace, computes a replacement, and affects it.\nstatic bool\nsimplifyRelocatesOffABase(GCRelocateInst *RelocatedBase,\n                          const SmallVectorImpl<GCRelocateInst *> &Targets) {\n  bool MadeChange = false;\n  // We must ensure the relocation of derived pointer is defined after\n  // relocation of base pointer. If we find a relocation corresponding to base\n  // defined earlier than relocation of base then we move relocation of base\n  // right before found relocation. We consider only relocation in the same\n  // basic block as relocation of base. Relocations from other basic block will\n  // be skipped by optimization and we do not care about them.\n  for (auto R = RelocatedBase->getParent()->getFirstInsertionPt();\n       &*R != RelocatedBase; ++R)\n    if (auto *RI = dyn_cast<GCRelocateInst>(R))\n      if (RI->getStatepoint() == RelocatedBase->getStatepoint())\n        if (RI->getBasePtrIndex() == RelocatedBase->getBasePtrIndex()) {\n          RelocatedBase->moveBefore(RI);\n          break;\n        }\n\n  for (GCRelocateInst *ToReplace : Targets) {\n    assert(ToReplace->getBasePtrIndex() == RelocatedBase->getBasePtrIndex() &&\n           \"Not relocating a derived object of the original base object\");\n    if (ToReplace->getBasePtrIndex() == ToReplace->getDerivedPtrIndex()) {\n      // A duplicate relocate call. TODO: coalesce duplicates.\n      continue;\n    }\n\n    if (RelocatedBase->getParent() != ToReplace->getParent()) {\n      // Base and derived relocates are in different basic blocks.\n      // In this case transform is only valid when base dominates derived\n      // relocate. However it would be too expensive to check dominance\n      // for each such relocate, so we skip the whole transformation.\n      continue;\n    }\n\n    Value *Base = ToReplace->getBasePtr();\n    auto *Derived = dyn_cast<GetElementPtrInst>(ToReplace->getDerivedPtr());\n    if (!Derived || Derived->getPointerOperand() != Base)\n      continue;\n\n    SmallVector<Value *, 2> OffsetV;\n    if (!getGEPSmallConstantIntOffsetV(Derived, OffsetV))\n      continue;\n\n    // Create a Builder and replace the target callsite with a gep\n    assert(RelocatedBase->getNextNode() &&\n           \"Should always have one since it's not a terminator\");\n\n    // Insert after RelocatedBase\n    IRBuilder<> Builder(RelocatedBase->getNextNode());\n    Builder.SetCurrentDebugLocation(ToReplace->getDebugLoc());\n\n    // If gc_relocate does not match the actual type, cast it to the right type.\n    // In theory, there must be a bitcast after gc_relocate if the type does not\n    // match, and we should reuse it to get the derived pointer. But it could be\n    // cases like this:\n    // bb1:\n    //  ...\n    //  %g1 = call coldcc i8 addrspace(1)* @llvm.experimental.gc.relocate.p1i8(...)\n    //  br label %merge\n    //\n    // bb2:\n    //  ...\n    //  %g2 = call coldcc i8 addrspace(1)* @llvm.experimental.gc.relocate.p1i8(...)\n    //  br label %merge\n    //\n    // merge:\n    //  %p1 = phi i8 addrspace(1)* [ %g1, %bb1 ], [ %g2, %bb2 ]\n    //  %cast = bitcast i8 addrspace(1)* %p1 in to i32 addrspace(1)*\n    //\n    // In this case, we can not find the bitcast any more. So we insert a new bitcast\n    // no matter there is already one or not. In this way, we can handle all cases, and\n    // the extra bitcast should be optimized away in later passes.\n    Value *ActualRelocatedBase = RelocatedBase;\n    if (RelocatedBase->getType() != Base->getType()) {\n      ActualRelocatedBase =\n          Builder.CreateBitCast(RelocatedBase, Base->getType());\n    }\n    Value *Replacement = Builder.CreateGEP(\n        Derived->getSourceElementType(), ActualRelocatedBase, makeArrayRef(OffsetV));\n    Replacement->takeName(ToReplace);\n    // If the newly generated derived pointer's type does not match the original derived\n    // pointer's type, cast the new derived pointer to match it. Same reasoning as above.\n    Value *ActualReplacement = Replacement;\n    if (Replacement->getType() != ToReplace->getType()) {\n      ActualReplacement =\n          Builder.CreateBitCast(Replacement, ToReplace->getType());\n    }\n    ToReplace->replaceAllUsesWith(ActualReplacement);\n    ToReplace->eraseFromParent();\n\n    MadeChange = true;\n  }\n  return MadeChange;\n}\n\n// Turns this:\n//\n// %base = ...\n// %ptr = gep %base + 15\n// %tok = statepoint (%fun, i32 0, i32 0, i32 0, %base, %ptr)\n// %base' = relocate(%tok, i32 4, i32 4)\n// %ptr' = relocate(%tok, i32 4, i32 5)\n// %val = load %ptr'\n//\n// into this:\n//\n// %base = ...\n// %ptr = gep %base + 15\n// %tok = statepoint (%fun, i32 0, i32 0, i32 0, %base, %ptr)\n// %base' = gc.relocate(%tok, i32 4, i32 4)\n// %ptr' = gep %base' + 15\n// %val = load %ptr'\nbool CodeGenPrepare::simplifyOffsetableRelocate(GCStatepointInst &I) {\n  bool MadeChange = false;\n  SmallVector<GCRelocateInst *, 2> AllRelocateCalls;\n  for (auto *U : I.users())\n    if (GCRelocateInst *Relocate = dyn_cast<GCRelocateInst>(U))\n      // Collect all the relocate calls associated with a statepoint\n      AllRelocateCalls.push_back(Relocate);\n\n  // We need at least one base pointer relocation + one derived pointer\n  // relocation to mangle\n  if (AllRelocateCalls.size() < 2)\n    return false;\n\n  // RelocateInstMap is a mapping from the base relocate instruction to the\n  // corresponding derived relocate instructions\n  DenseMap<GCRelocateInst *, SmallVector<GCRelocateInst *, 2>> RelocateInstMap;\n  computeBaseDerivedRelocateMap(AllRelocateCalls, RelocateInstMap);\n  if (RelocateInstMap.empty())\n    return false;\n\n  for (auto &Item : RelocateInstMap)\n    // Item.first is the RelocatedBase to offset against\n    // Item.second is the vector of Targets to replace\n    MadeChange = simplifyRelocatesOffABase(Item.first, Item.second);\n  return MadeChange;\n}\n\n/// Sink the specified cast instruction into its user blocks.\nstatic bool SinkCast(CastInst *CI) {\n  BasicBlock *DefBB = CI->getParent();\n\n  /// InsertedCasts - Only insert a cast in each block once.\n  DenseMap<BasicBlock*, CastInst*> InsertedCasts;\n\n  bool MadeChange = false;\n  for (Value::user_iterator UI = CI->user_begin(), E = CI->user_end();\n       UI != E; ) {\n    Use &TheUse = UI.getUse();\n    Instruction *User = cast<Instruction>(*UI);\n\n    // Figure out which BB this cast is used in.  For PHI's this is the\n    // appropriate predecessor block.\n    BasicBlock *UserBB = User->getParent();\n    if (PHINode *PN = dyn_cast<PHINode>(User)) {\n      UserBB = PN->getIncomingBlock(TheUse);\n    }\n\n    // Preincrement use iterator so we don't invalidate it.\n    ++UI;\n\n    // The first insertion point of a block containing an EH pad is after the\n    // pad.  If the pad is the user, we cannot sink the cast past the pad.\n    if (User->isEHPad())\n      continue;\n\n    // If the block selected to receive the cast is an EH pad that does not\n    // allow non-PHI instructions before the terminator, we can't sink the\n    // cast.\n    if (UserBB->getTerminator()->isEHPad())\n      continue;\n\n    // If this user is in the same block as the cast, don't change the cast.\n    if (UserBB == DefBB) continue;\n\n    // If we have already inserted a cast into this block, use it.\n    CastInst *&InsertedCast = InsertedCasts[UserBB];\n\n    if (!InsertedCast) {\n      BasicBlock::iterator InsertPt = UserBB->getFirstInsertionPt();\n      assert(InsertPt != UserBB->end());\n      InsertedCast = CastInst::Create(CI->getOpcode(), CI->getOperand(0),\n                                      CI->getType(), \"\", &*InsertPt);\n      InsertedCast->setDebugLoc(CI->getDebugLoc());\n    }\n\n    // Replace a use of the cast with a use of the new cast.\n    TheUse = InsertedCast;\n    MadeChange = true;\n    ++NumCastUses;\n  }\n\n  // If we removed all uses, nuke the cast.\n  if (CI->use_empty()) {\n    salvageDebugInfo(*CI);\n    CI->eraseFromParent();\n    MadeChange = true;\n  }\n\n  return MadeChange;\n}\n\n/// If the specified cast instruction is a noop copy (e.g. it's casting from\n/// one pointer type to another, i32->i8 on PPC), sink it into user blocks to\n/// reduce the number of virtual registers that must be created and coalesced.\n///\n/// Return true if any changes are made.\nstatic bool OptimizeNoopCopyExpression(CastInst *CI, const TargetLowering &TLI,\n                                       const DataLayout &DL) {\n  // Sink only \"cheap\" (or nop) address-space casts.  This is a weaker condition\n  // than sinking only nop casts, but is helpful on some platforms.\n  if (auto *ASC = dyn_cast<AddrSpaceCastInst>(CI)) {\n    if (!TLI.isFreeAddrSpaceCast(ASC->getSrcAddressSpace(),\n                                 ASC->getDestAddressSpace()))\n      return false;\n  }\n\n  // If this is a noop copy,\n  EVT SrcVT = TLI.getValueType(DL, CI->getOperand(0)->getType());\n  EVT DstVT = TLI.getValueType(DL, CI->getType());\n\n  // This is an fp<->int conversion?\n  if (SrcVT.isInteger() != DstVT.isInteger())\n    return false;\n\n  // If this is an extension, it will be a zero or sign extension, which\n  // isn't a noop.\n  if (SrcVT.bitsLT(DstVT)) return false;\n\n  // If these values will be promoted, find out what they will be promoted\n  // to.  This helps us consider truncates on PPC as noop copies when they\n  // are.\n  if (TLI.getTypeAction(CI->getContext(), SrcVT) ==\n      TargetLowering::TypePromoteInteger)\n    SrcVT = TLI.getTypeToTransformTo(CI->getContext(), SrcVT);\n  if (TLI.getTypeAction(CI->getContext(), DstVT) ==\n      TargetLowering::TypePromoteInteger)\n    DstVT = TLI.getTypeToTransformTo(CI->getContext(), DstVT);\n\n  // If, after promotion, these are the same types, this is a noop copy.\n  if (SrcVT != DstVT)\n    return false;\n\n  return SinkCast(CI);\n}\n\n// Match a simple increment by constant operation.  Note that if a sub is\n// matched, the step is negated (as if the step had been canonicalized to\n// an add, even though we leave the instruction alone.)\nbool matchIncrement(const Instruction* IVInc, Instruction *&LHS,\n                    Constant *&Step) {\n  if (match(IVInc, m_Add(m_Instruction(LHS), m_Constant(Step))) ||\n      match(IVInc, m_ExtractValue<0>(m_Intrinsic<Intrinsic::uadd_with_overflow>(\n                       m_Instruction(LHS), m_Constant(Step)))))\n    return true;\n  if (match(IVInc, m_Sub(m_Instruction(LHS), m_Constant(Step))) ||\n      match(IVInc, m_ExtractValue<0>(m_Intrinsic<Intrinsic::usub_with_overflow>(\n                       m_Instruction(LHS), m_Constant(Step))))) {\n    Step = ConstantExpr::getNeg(Step);\n    return true;\n  }\n  return false;\n}\n\n/// If given \\p PN is an inductive variable with value IVInc coming from the\n/// backedge, and on each iteration it gets increased by Step, return pair\n/// <IVInc, Step>. Otherwise, return None.\nstatic Optional<std::pair<Instruction *, Constant *> >\ngetIVIncrement(const PHINode *PN, const LoopInfo *LI) {\n  const Loop *L = LI->getLoopFor(PN->getParent());\n  if (!L || L->getHeader() != PN->getParent() || !L->getLoopLatch())\n    return None;\n  auto *IVInc =\n      dyn_cast<Instruction>(PN->getIncomingValueForBlock(L->getLoopLatch()));\n  if (!IVInc || LI->getLoopFor(IVInc->getParent()) != L)\n    return None;\n  Instruction *LHS = nullptr;\n  Constant *Step = nullptr;\n  if (matchIncrement(IVInc, LHS, Step) && LHS == PN)\n    return std::make_pair(IVInc, Step);\n  return None;\n}\n\nstatic bool isIVIncrement(const Value *V, const LoopInfo *LI) {\n  auto *I = dyn_cast<Instruction>(V);\n  if (!I)\n    return false;\n  Instruction *LHS = nullptr;\n  Constant *Step = nullptr;\n  if (!matchIncrement(I, LHS, Step))\n    return false;\n  if (auto *PN = dyn_cast<PHINode>(LHS))\n    if (auto IVInc = getIVIncrement(PN, LI))\n      return IVInc->first == I;\n  return false;\n}\n\nbool CodeGenPrepare::replaceMathCmpWithIntrinsic(BinaryOperator *BO,\n                                                 Value *Arg0, Value *Arg1,\n                                                 CmpInst *Cmp,\n                                                 Intrinsic::ID IID) {\n  auto IsReplacableIVIncrement = [this, &Cmp](BinaryOperator *BO) {\n    if (!isIVIncrement(BO, LI))\n      return false;\n    const Loop *L = LI->getLoopFor(BO->getParent());\n    assert(L && \"L should not be null after isIVIncrement()\");\n    // Do not risk on moving increment into a child loop.\n    if (LI->getLoopFor(Cmp->getParent()) != L)\n      return false;\n\n    // Finally, we need to ensure that the insert point will dominate all\n    // existing uses of the increment.\n\n    auto &DT = getDT(*BO->getParent()->getParent());\n    if (DT.dominates(Cmp->getParent(), BO->getParent()))\n      // If we're moving up the dom tree, all uses are trivially dominated.\n      // (This is the common case for code produced by LSR.)\n      return true;\n\n    // Otherwise, special case the single use in the phi recurrence.\n    return BO->hasOneUse() && DT.dominates(Cmp->getParent(), L->getLoopLatch());\n  };\n  if (BO->getParent() != Cmp->getParent() && !IsReplacableIVIncrement(BO)) {\n    // We used to use a dominator tree here to allow multi-block optimization.\n    // But that was problematic because:\n    // 1. It could cause a perf regression by hoisting the math op into the\n    //    critical path.\n    // 2. It could cause a perf regression by creating a value that was live\n    //    across multiple blocks and increasing register pressure.\n    // 3. Use of a dominator tree could cause large compile-time regression.\n    //    This is because we recompute the DT on every change in the main CGP\n    //    run-loop. The recomputing is probably unnecessary in many cases, so if\n    //    that was fixed, using a DT here would be ok.\n    //\n    // There is one important particular case we still want to handle: if BO is\n    // the IV increment. Important properties that make it profitable:\n    // - We can speculate IV increment anywhere in the loop (as long as the\n    //   indvar Phi is its only user);\n    // - Upon computing Cmp, we effectively compute something equivalent to the\n    //   IV increment (despite it loops differently in the IR). So moving it up\n    //   to the cmp point does not really increase register pressure.\n    return false;\n  }\n\n  // We allow matching the canonical IR (add X, C) back to (usubo X, -C).\n  if (BO->getOpcode() == Instruction::Add &&\n      IID == Intrinsic::usub_with_overflow) {\n    assert(isa<Constant>(Arg1) && \"Unexpected input for usubo\");\n    Arg1 = ConstantExpr::getNeg(cast<Constant>(Arg1));\n  }\n\n  // Insert at the first instruction of the pair.\n  Instruction *InsertPt = nullptr;\n  for (Instruction &Iter : *Cmp->getParent()) {\n    // If BO is an XOR, it is not guaranteed that it comes after both inputs to\n    // the overflow intrinsic are defined.\n    if ((BO->getOpcode() != Instruction::Xor && &Iter == BO) || &Iter == Cmp) {\n      InsertPt = &Iter;\n      break;\n    }\n  }\n  assert(InsertPt != nullptr && \"Parent block did not contain cmp or binop\");\n\n  IRBuilder<> Builder(InsertPt);\n  Value *MathOV = Builder.CreateBinaryIntrinsic(IID, Arg0, Arg1);\n  if (BO->getOpcode() != Instruction::Xor) {\n    Value *Math = Builder.CreateExtractValue(MathOV, 0, \"math\");\n    BO->replaceAllUsesWith(Math);\n  } else\n    assert(BO->hasOneUse() &&\n           \"Patterns with XOr should use the BO only in the compare\");\n  Value *OV = Builder.CreateExtractValue(MathOV, 1, \"ov\");\n  Cmp->replaceAllUsesWith(OV);\n  Cmp->eraseFromParent();\n  BO->eraseFromParent();\n  return true;\n}\n\n/// Match special-case patterns that check for unsigned add overflow.\nstatic bool matchUAddWithOverflowConstantEdgeCases(CmpInst *Cmp,\n                                                   BinaryOperator *&Add) {\n  // Add = add A, 1; Cmp = icmp eq A,-1 (overflow if A is max val)\n  // Add = add A,-1; Cmp = icmp ne A, 0 (overflow if A is non-zero)\n  Value *A = Cmp->getOperand(0), *B = Cmp->getOperand(1);\n\n  // We are not expecting non-canonical/degenerate code. Just bail out.\n  if (isa<Constant>(A))\n    return false;\n\n  ICmpInst::Predicate Pred = Cmp->getPredicate();\n  if (Pred == ICmpInst::ICMP_EQ && match(B, m_AllOnes()))\n    B = ConstantInt::get(B->getType(), 1);\n  else if (Pred == ICmpInst::ICMP_NE && match(B, m_ZeroInt()))\n    B = ConstantInt::get(B->getType(), -1);\n  else\n    return false;\n\n  // Check the users of the variable operand of the compare looking for an add\n  // with the adjusted constant.\n  for (User *U : A->users()) {\n    if (match(U, m_Add(m_Specific(A), m_Specific(B)))) {\n      Add = cast<BinaryOperator>(U);\n      return true;\n    }\n  }\n  return false;\n}\n\n/// Try to combine the compare into a call to the llvm.uadd.with.overflow\n/// intrinsic. Return true if any changes were made.\nbool CodeGenPrepare::combineToUAddWithOverflow(CmpInst *Cmp,\n                                               bool &ModifiedDT) {\n  Value *A, *B;\n  BinaryOperator *Add;\n  if (!match(Cmp, m_UAddWithOverflow(m_Value(A), m_Value(B), m_BinOp(Add)))) {\n    if (!matchUAddWithOverflowConstantEdgeCases(Cmp, Add))\n      return false;\n    // Set A and B in case we match matchUAddWithOverflowConstantEdgeCases.\n    A = Add->getOperand(0);\n    B = Add->getOperand(1);\n  }\n\n  if (!TLI->shouldFormOverflowOp(ISD::UADDO,\n                                 TLI->getValueType(*DL, Add->getType()),\n                                 Add->hasNUsesOrMore(2)))\n    return false;\n\n  // We don't want to move around uses of condition values this late, so we\n  // check if it is legal to create the call to the intrinsic in the basic\n  // block containing the icmp.\n  if (Add->getParent() != Cmp->getParent() && !Add->hasOneUse())\n    return false;\n\n  if (!replaceMathCmpWithIntrinsic(Add, A, B, Cmp,\n                                   Intrinsic::uadd_with_overflow))\n    return false;\n\n  // Reset callers - do not crash by iterating over a dead instruction.\n  ModifiedDT = true;\n  return true;\n}\n\nbool CodeGenPrepare::combineToUSubWithOverflow(CmpInst *Cmp,\n                                               bool &ModifiedDT) {\n  // We are not expecting non-canonical/degenerate code. Just bail out.\n  Value *A = Cmp->getOperand(0), *B = Cmp->getOperand(1);\n  if (isa<Constant>(A) && isa<Constant>(B))\n    return false;\n\n  // Convert (A u> B) to (A u< B) to simplify pattern matching.\n  ICmpInst::Predicate Pred = Cmp->getPredicate();\n  if (Pred == ICmpInst::ICMP_UGT) {\n    std::swap(A, B);\n    Pred = ICmpInst::ICMP_ULT;\n  }\n  // Convert special-case: (A == 0) is the same as (A u< 1).\n  if (Pred == ICmpInst::ICMP_EQ && match(B, m_ZeroInt())) {\n    B = ConstantInt::get(B->getType(), 1);\n    Pred = ICmpInst::ICMP_ULT;\n  }\n  // Convert special-case: (A != 0) is the same as (0 u< A).\n  if (Pred == ICmpInst::ICMP_NE && match(B, m_ZeroInt())) {\n    std::swap(A, B);\n    Pred = ICmpInst::ICMP_ULT;\n  }\n  if (Pred != ICmpInst::ICMP_ULT)\n    return false;\n\n  // Walk the users of a variable operand of a compare looking for a subtract or\n  // add with that same operand. Also match the 2nd operand of the compare to\n  // the add/sub, but that may be a negated constant operand of an add.\n  Value *CmpVariableOperand = isa<Constant>(A) ? B : A;\n  BinaryOperator *Sub = nullptr;\n  for (User *U : CmpVariableOperand->users()) {\n    // A - B, A u< B --> usubo(A, B)\n    if (match(U, m_Sub(m_Specific(A), m_Specific(B)))) {\n      Sub = cast<BinaryOperator>(U);\n      break;\n    }\n\n    // A + (-C), A u< C (canonicalized form of (sub A, C))\n    const APInt *CmpC, *AddC;\n    if (match(U, m_Add(m_Specific(A), m_APInt(AddC))) &&\n        match(B, m_APInt(CmpC)) && *AddC == -(*CmpC)) {\n      Sub = cast<BinaryOperator>(U);\n      break;\n    }\n  }\n  if (!Sub)\n    return false;\n\n  if (!TLI->shouldFormOverflowOp(ISD::USUBO,\n                                 TLI->getValueType(*DL, Sub->getType()),\n                                 Sub->hasNUsesOrMore(2)))\n    return false;\n\n  if (!replaceMathCmpWithIntrinsic(Sub, Sub->getOperand(0), Sub->getOperand(1),\n                                   Cmp, Intrinsic::usub_with_overflow))\n    return false;\n\n  // Reset callers - do not crash by iterating over a dead instruction.\n  ModifiedDT = true;\n  return true;\n}\n\n/// Sink the given CmpInst into user blocks to reduce the number of virtual\n/// registers that must be created and coalesced. This is a clear win except on\n/// targets with multiple condition code registers (PowerPC), where it might\n/// lose; some adjustment may be wanted there.\n///\n/// Return true if any changes are made.\nstatic bool sinkCmpExpression(CmpInst *Cmp, const TargetLowering &TLI) {\n  if (TLI.hasMultipleConditionRegisters())\n    return false;\n\n  // Avoid sinking soft-FP comparisons, since this can move them into a loop.\n  if (TLI.useSoftFloat() && isa<FCmpInst>(Cmp))\n    return false;\n\n  // Only insert a cmp in each block once.\n  DenseMap<BasicBlock*, CmpInst*> InsertedCmps;\n\n  bool MadeChange = false;\n  for (Value::user_iterator UI = Cmp->user_begin(), E = Cmp->user_end();\n       UI != E; ) {\n    Use &TheUse = UI.getUse();\n    Instruction *User = cast<Instruction>(*UI);\n\n    // Preincrement use iterator so we don't invalidate it.\n    ++UI;\n\n    // Don't bother for PHI nodes.\n    if (isa<PHINode>(User))\n      continue;\n\n    // Figure out which BB this cmp is used in.\n    BasicBlock *UserBB = User->getParent();\n    BasicBlock *DefBB = Cmp->getParent();\n\n    // If this user is in the same block as the cmp, don't change the cmp.\n    if (UserBB == DefBB) continue;\n\n    // If we have already inserted a cmp into this block, use it.\n    CmpInst *&InsertedCmp = InsertedCmps[UserBB];\n\n    if (!InsertedCmp) {\n      BasicBlock::iterator InsertPt = UserBB->getFirstInsertionPt();\n      assert(InsertPt != UserBB->end());\n      InsertedCmp =\n          CmpInst::Create(Cmp->getOpcode(), Cmp->getPredicate(),\n                          Cmp->getOperand(0), Cmp->getOperand(1), \"\",\n                          &*InsertPt);\n      // Propagate the debug info.\n      InsertedCmp->setDebugLoc(Cmp->getDebugLoc());\n    }\n\n    // Replace a use of the cmp with a use of the new cmp.\n    TheUse = InsertedCmp;\n    MadeChange = true;\n    ++NumCmpUses;\n  }\n\n  // If we removed all uses, nuke the cmp.\n  if (Cmp->use_empty()) {\n    Cmp->eraseFromParent();\n    MadeChange = true;\n  }\n\n  return MadeChange;\n}\n\n/// For pattern like:\n///\n///   DomCond = icmp sgt/slt CmpOp0, CmpOp1 (might not be in DomBB)\n///   ...\n/// DomBB:\n///   ...\n///   br DomCond, TrueBB, CmpBB\n/// CmpBB: (with DomBB being the single predecessor)\n///   ...\n///   Cmp = icmp eq CmpOp0, CmpOp1\n///   ...\n///\n/// It would use two comparison on targets that lowering of icmp sgt/slt is\n/// different from lowering of icmp eq (PowerPC). This function try to convert\n/// 'Cmp = icmp eq CmpOp0, CmpOp1' to ' Cmp = icmp slt/sgt CmpOp0, CmpOp1'.\n/// After that, DomCond and Cmp can use the same comparison so reduce one\n/// comparison.\n///\n/// Return true if any changes are made.\nstatic bool foldICmpWithDominatingICmp(CmpInst *Cmp,\n                                       const TargetLowering &TLI) {\n  if (!EnableICMP_EQToICMP_ST && TLI.isEqualityCmpFoldedWithSignedCmp())\n    return false;\n\n  ICmpInst::Predicate Pred = Cmp->getPredicate();\n  if (Pred != ICmpInst::ICMP_EQ)\n    return false;\n\n  // If icmp eq has users other than BranchInst and SelectInst, converting it to\n  // icmp slt/sgt would introduce more redundant LLVM IR.\n  for (User *U : Cmp->users()) {\n    if (isa<BranchInst>(U))\n      continue;\n    if (isa<SelectInst>(U) && cast<SelectInst>(U)->getCondition() == Cmp)\n      continue;\n    return false;\n  }\n\n  // This is a cheap/incomplete check for dominance - just match a single\n  // predecessor with a conditional branch.\n  BasicBlock *CmpBB = Cmp->getParent();\n  BasicBlock *DomBB = CmpBB->getSinglePredecessor();\n  if (!DomBB)\n    return false;\n\n  // We want to ensure that the only way control gets to the comparison of\n  // interest is that a less/greater than comparison on the same operands is\n  // false.\n  Value *DomCond;\n  BasicBlock *TrueBB, *FalseBB;\n  if (!match(DomBB->getTerminator(), m_Br(m_Value(DomCond), TrueBB, FalseBB)))\n    return false;\n  if (CmpBB != FalseBB)\n    return false;\n\n  Value *CmpOp0 = Cmp->getOperand(0), *CmpOp1 = Cmp->getOperand(1);\n  ICmpInst::Predicate DomPred;\n  if (!match(DomCond, m_ICmp(DomPred, m_Specific(CmpOp0), m_Specific(CmpOp1))))\n    return false;\n  if (DomPred != ICmpInst::ICMP_SGT && DomPred != ICmpInst::ICMP_SLT)\n    return false;\n\n  // Convert the equality comparison to the opposite of the dominating\n  // comparison and swap the direction for all branch/select users.\n  // We have conceptually converted:\n  // Res = (a < b) ? <LT_RES> : (a == b) ? <EQ_RES> : <GT_RES>;\n  // to\n  // Res = (a < b) ? <LT_RES> : (a > b)  ? <GT_RES> : <EQ_RES>;\n  // And similarly for branches.\n  for (User *U : Cmp->users()) {\n    if (auto *BI = dyn_cast<BranchInst>(U)) {\n      assert(BI->isConditional() && \"Must be conditional\");\n      BI->swapSuccessors();\n      continue;\n    }\n    if (auto *SI = dyn_cast<SelectInst>(U)) {\n      // Swap operands\n      SI->swapValues();\n      SI->swapProfMetadata();\n      continue;\n    }\n    llvm_unreachable(\"Must be a branch or a select\");\n  }\n  Cmp->setPredicate(CmpInst::getSwappedPredicate(DomPred));\n  return true;\n}\n\nbool CodeGenPrepare::optimizeCmp(CmpInst *Cmp, bool &ModifiedDT) {\n  if (sinkCmpExpression(Cmp, *TLI))\n    return true;\n\n  if (combineToUAddWithOverflow(Cmp, ModifiedDT))\n    return true;\n\n  if (combineToUSubWithOverflow(Cmp, ModifiedDT))\n    return true;\n\n  if (foldICmpWithDominatingICmp(Cmp, *TLI))\n    return true;\n\n  return false;\n}\n\n/// Duplicate and sink the given 'and' instruction into user blocks where it is\n/// used in a compare to allow isel to generate better code for targets where\n/// this operation can be combined.\n///\n/// Return true if any changes are made.\nstatic bool sinkAndCmp0Expression(Instruction *AndI,\n                                  const TargetLowering &TLI,\n                                  SetOfInstrs &InsertedInsts) {\n  // Double-check that we're not trying to optimize an instruction that was\n  // already optimized by some other part of this pass.\n  assert(!InsertedInsts.count(AndI) &&\n         \"Attempting to optimize already optimized and instruction\");\n  (void) InsertedInsts;\n\n  // Nothing to do for single use in same basic block.\n  if (AndI->hasOneUse() &&\n      AndI->getParent() == cast<Instruction>(*AndI->user_begin())->getParent())\n    return false;\n\n  // Try to avoid cases where sinking/duplicating is likely to increase register\n  // pressure.\n  if (!isa<ConstantInt>(AndI->getOperand(0)) &&\n      !isa<ConstantInt>(AndI->getOperand(1)) &&\n      AndI->getOperand(0)->hasOneUse() && AndI->getOperand(1)->hasOneUse())\n    return false;\n\n  for (auto *U : AndI->users()) {\n    Instruction *User = cast<Instruction>(U);\n\n    // Only sink 'and' feeding icmp with 0.\n    if (!isa<ICmpInst>(User))\n      return false;\n\n    auto *CmpC = dyn_cast<ConstantInt>(User->getOperand(1));\n    if (!CmpC || !CmpC->isZero())\n      return false;\n  }\n\n  if (!TLI.isMaskAndCmp0FoldingBeneficial(*AndI))\n    return false;\n\n  LLVM_DEBUG(dbgs() << \"found 'and' feeding only icmp 0;\\n\");\n  LLVM_DEBUG(AndI->getParent()->dump());\n\n  // Push the 'and' into the same block as the icmp 0.  There should only be\n  // one (icmp (and, 0)) in each block, since CSE/GVN should have removed any\n  // others, so we don't need to keep track of which BBs we insert into.\n  for (Value::user_iterator UI = AndI->user_begin(), E = AndI->user_end();\n       UI != E; ) {\n    Use &TheUse = UI.getUse();\n    Instruction *User = cast<Instruction>(*UI);\n\n    // Preincrement use iterator so we don't invalidate it.\n    ++UI;\n\n    LLVM_DEBUG(dbgs() << \"sinking 'and' use: \" << *User << \"\\n\");\n\n    // Keep the 'and' in the same place if the use is already in the same block.\n    Instruction *InsertPt =\n        User->getParent() == AndI->getParent() ? AndI : User;\n    Instruction *InsertedAnd =\n        BinaryOperator::Create(Instruction::And, AndI->getOperand(0),\n                               AndI->getOperand(1), \"\", InsertPt);\n    // Propagate the debug info.\n    InsertedAnd->setDebugLoc(AndI->getDebugLoc());\n\n    // Replace a use of the 'and' with a use of the new 'and'.\n    TheUse = InsertedAnd;\n    ++NumAndUses;\n    LLVM_DEBUG(User->getParent()->dump());\n  }\n\n  // We removed all uses, nuke the and.\n  AndI->eraseFromParent();\n  return true;\n}\n\n/// Check if the candidates could be combined with a shift instruction, which\n/// includes:\n/// 1. Truncate instruction\n/// 2. And instruction and the imm is a mask of the low bits:\n/// imm & (imm+1) == 0\nstatic bool isExtractBitsCandidateUse(Instruction *User) {\n  if (!isa<TruncInst>(User)) {\n    if (User->getOpcode() != Instruction::And ||\n        !isa<ConstantInt>(User->getOperand(1)))\n      return false;\n\n    const APInt &Cimm = cast<ConstantInt>(User->getOperand(1))->getValue();\n\n    if ((Cimm & (Cimm + 1)).getBoolValue())\n      return false;\n  }\n  return true;\n}\n\n/// Sink both shift and truncate instruction to the use of truncate's BB.\nstatic bool\nSinkShiftAndTruncate(BinaryOperator *ShiftI, Instruction *User, ConstantInt *CI,\n                     DenseMap<BasicBlock *, BinaryOperator *> &InsertedShifts,\n                     const TargetLowering &TLI, const DataLayout &DL) {\n  BasicBlock *UserBB = User->getParent();\n  DenseMap<BasicBlock *, CastInst *> InsertedTruncs;\n  auto *TruncI = cast<TruncInst>(User);\n  bool MadeChange = false;\n\n  for (Value::user_iterator TruncUI = TruncI->user_begin(),\n                            TruncE = TruncI->user_end();\n       TruncUI != TruncE;) {\n\n    Use &TruncTheUse = TruncUI.getUse();\n    Instruction *TruncUser = cast<Instruction>(*TruncUI);\n    // Preincrement use iterator so we don't invalidate it.\n\n    ++TruncUI;\n\n    int ISDOpcode = TLI.InstructionOpcodeToISD(TruncUser->getOpcode());\n    if (!ISDOpcode)\n      continue;\n\n    // If the use is actually a legal node, there will not be an\n    // implicit truncate.\n    // FIXME: always querying the result type is just an\n    // approximation; some nodes' legality is determined by the\n    // operand or other means. There's no good way to find out though.\n    if (TLI.isOperationLegalOrCustom(\n            ISDOpcode, TLI.getValueType(DL, TruncUser->getType(), true)))\n      continue;\n\n    // Don't bother for PHI nodes.\n    if (isa<PHINode>(TruncUser))\n      continue;\n\n    BasicBlock *TruncUserBB = TruncUser->getParent();\n\n    if (UserBB == TruncUserBB)\n      continue;\n\n    BinaryOperator *&InsertedShift = InsertedShifts[TruncUserBB];\n    CastInst *&InsertedTrunc = InsertedTruncs[TruncUserBB];\n\n    if (!InsertedShift && !InsertedTrunc) {\n      BasicBlock::iterator InsertPt = TruncUserBB->getFirstInsertionPt();\n      assert(InsertPt != TruncUserBB->end());\n      // Sink the shift\n      if (ShiftI->getOpcode() == Instruction::AShr)\n        InsertedShift = BinaryOperator::CreateAShr(ShiftI->getOperand(0), CI,\n                                                   \"\", &*InsertPt);\n      else\n        InsertedShift = BinaryOperator::CreateLShr(ShiftI->getOperand(0), CI,\n                                                   \"\", &*InsertPt);\n      InsertedShift->setDebugLoc(ShiftI->getDebugLoc());\n\n      // Sink the trunc\n      BasicBlock::iterator TruncInsertPt = TruncUserBB->getFirstInsertionPt();\n      TruncInsertPt++;\n      assert(TruncInsertPt != TruncUserBB->end());\n\n      InsertedTrunc = CastInst::Create(TruncI->getOpcode(), InsertedShift,\n                                       TruncI->getType(), \"\", &*TruncInsertPt);\n      InsertedTrunc->setDebugLoc(TruncI->getDebugLoc());\n\n      MadeChange = true;\n\n      TruncTheUse = InsertedTrunc;\n    }\n  }\n  return MadeChange;\n}\n\n/// Sink the shift *right* instruction into user blocks if the uses could\n/// potentially be combined with this shift instruction and generate BitExtract\n/// instruction. It will only be applied if the architecture supports BitExtract\n/// instruction. Here is an example:\n/// BB1:\n///   %x.extract.shift = lshr i64 %arg1, 32\n/// BB2:\n///   %x.extract.trunc = trunc i64 %x.extract.shift to i16\n/// ==>\n///\n/// BB2:\n///   %x.extract.shift.1 = lshr i64 %arg1, 32\n///   %x.extract.trunc = trunc i64 %x.extract.shift.1 to i16\n///\n/// CodeGen will recognize the pattern in BB2 and generate BitExtract\n/// instruction.\n/// Return true if any changes are made.\nstatic bool OptimizeExtractBits(BinaryOperator *ShiftI, ConstantInt *CI,\n                                const TargetLowering &TLI,\n                                const DataLayout &DL) {\n  BasicBlock *DefBB = ShiftI->getParent();\n\n  /// Only insert instructions in each block once.\n  DenseMap<BasicBlock *, BinaryOperator *> InsertedShifts;\n\n  bool shiftIsLegal = TLI.isTypeLegal(TLI.getValueType(DL, ShiftI->getType()));\n\n  bool MadeChange = false;\n  for (Value::user_iterator UI = ShiftI->user_begin(), E = ShiftI->user_end();\n       UI != E;) {\n    Use &TheUse = UI.getUse();\n    Instruction *User = cast<Instruction>(*UI);\n    // Preincrement use iterator so we don't invalidate it.\n    ++UI;\n\n    // Don't bother for PHI nodes.\n    if (isa<PHINode>(User))\n      continue;\n\n    if (!isExtractBitsCandidateUse(User))\n      continue;\n\n    BasicBlock *UserBB = User->getParent();\n\n    if (UserBB == DefBB) {\n      // If the shift and truncate instruction are in the same BB. The use of\n      // the truncate(TruncUse) may still introduce another truncate if not\n      // legal. In this case, we would like to sink both shift and truncate\n      // instruction to the BB of TruncUse.\n      // for example:\n      // BB1:\n      // i64 shift.result = lshr i64 opnd, imm\n      // trunc.result = trunc shift.result to i16\n      //\n      // BB2:\n      //   ----> We will have an implicit truncate here if the architecture does\n      //   not have i16 compare.\n      // cmp i16 trunc.result, opnd2\n      //\n      if (isa<TruncInst>(User) && shiftIsLegal\n          // If the type of the truncate is legal, no truncate will be\n          // introduced in other basic blocks.\n          &&\n          (!TLI.isTypeLegal(TLI.getValueType(DL, User->getType()))))\n        MadeChange =\n            SinkShiftAndTruncate(ShiftI, User, CI, InsertedShifts, TLI, DL);\n\n      continue;\n    }\n    // If we have already inserted a shift into this block, use it.\n    BinaryOperator *&InsertedShift = InsertedShifts[UserBB];\n\n    if (!InsertedShift) {\n      BasicBlock::iterator InsertPt = UserBB->getFirstInsertionPt();\n      assert(InsertPt != UserBB->end());\n\n      if (ShiftI->getOpcode() == Instruction::AShr)\n        InsertedShift = BinaryOperator::CreateAShr(ShiftI->getOperand(0), CI,\n                                                   \"\", &*InsertPt);\n      else\n        InsertedShift = BinaryOperator::CreateLShr(ShiftI->getOperand(0), CI,\n                                                   \"\", &*InsertPt);\n      InsertedShift->setDebugLoc(ShiftI->getDebugLoc());\n\n      MadeChange = true;\n    }\n\n    // Replace a use of the shift with a use of the new shift.\n    TheUse = InsertedShift;\n  }\n\n  // If we removed all uses, or there are none, nuke the shift.\n  if (ShiftI->use_empty()) {\n    salvageDebugInfo(*ShiftI);\n    ShiftI->eraseFromParent();\n    MadeChange = true;\n  }\n\n  return MadeChange;\n}\n\n/// If counting leading or trailing zeros is an expensive operation and a zero\n/// input is defined, add a check for zero to avoid calling the intrinsic.\n///\n/// We want to transform:\n///     %z = call i64 @llvm.cttz.i64(i64 %A, i1 false)\n///\n/// into:\n///   entry:\n///     %cmpz = icmp eq i64 %A, 0\n///     br i1 %cmpz, label %cond.end, label %cond.false\n///   cond.false:\n///     %z = call i64 @llvm.cttz.i64(i64 %A, i1 true)\n///     br label %cond.end\n///   cond.end:\n///     %ctz = phi i64 [ 64, %entry ], [ %z, %cond.false ]\n///\n/// If the transform is performed, return true and set ModifiedDT to true.\nstatic bool despeculateCountZeros(IntrinsicInst *CountZeros,\n                                  const TargetLowering *TLI,\n                                  const DataLayout *DL,\n                                  bool &ModifiedDT) {\n  // If a zero input is undefined, it doesn't make sense to despeculate that.\n  if (match(CountZeros->getOperand(1), m_One()))\n    return false;\n\n  // If it's cheap to speculate, there's nothing to do.\n  auto IntrinsicID = CountZeros->getIntrinsicID();\n  if ((IntrinsicID == Intrinsic::cttz && TLI->isCheapToSpeculateCttz()) ||\n      (IntrinsicID == Intrinsic::ctlz && TLI->isCheapToSpeculateCtlz()))\n    return false;\n\n  // Only handle legal scalar cases. Anything else requires too much work.\n  Type *Ty = CountZeros->getType();\n  unsigned SizeInBits = Ty->getPrimitiveSizeInBits();\n  if (Ty->isVectorTy() || SizeInBits > DL->getLargestLegalIntTypeSizeInBits())\n    return false;\n\n  // The intrinsic will be sunk behind a compare against zero and branch.\n  BasicBlock *StartBlock = CountZeros->getParent();\n  BasicBlock *CallBlock = StartBlock->splitBasicBlock(CountZeros, \"cond.false\");\n\n  // Create another block after the count zero intrinsic. A PHI will be added\n  // in this block to select the result of the intrinsic or the bit-width\n  // constant if the input to the intrinsic is zero.\n  BasicBlock::iterator SplitPt = ++(BasicBlock::iterator(CountZeros));\n  BasicBlock *EndBlock = CallBlock->splitBasicBlock(SplitPt, \"cond.end\");\n\n  // Set up a builder to create a compare, conditional branch, and PHI.\n  IRBuilder<> Builder(CountZeros->getContext());\n  Builder.SetInsertPoint(StartBlock->getTerminator());\n  Builder.SetCurrentDebugLocation(CountZeros->getDebugLoc());\n\n  // Replace the unconditional branch that was created by the first split with\n  // a compare against zero and a conditional branch.\n  Value *Zero = Constant::getNullValue(Ty);\n  Value *Cmp = Builder.CreateICmpEQ(CountZeros->getOperand(0), Zero, \"cmpz\");\n  Builder.CreateCondBr(Cmp, EndBlock, CallBlock);\n  StartBlock->getTerminator()->eraseFromParent();\n\n  // Create a PHI in the end block to select either the output of the intrinsic\n  // or the bit width of the operand.\n  Builder.SetInsertPoint(&EndBlock->front());\n  PHINode *PN = Builder.CreatePHI(Ty, 2, \"ctz\");\n  CountZeros->replaceAllUsesWith(PN);\n  Value *BitWidth = Builder.getInt(APInt(SizeInBits, SizeInBits));\n  PN->addIncoming(BitWidth, StartBlock);\n  PN->addIncoming(CountZeros, CallBlock);\n\n  // We are explicitly handling the zero case, so we can set the intrinsic's\n  // undefined zero argument to 'true'. This will also prevent reprocessing the\n  // intrinsic; we only despeculate when a zero input is defined.\n  CountZeros->setArgOperand(1, Builder.getTrue());\n  ModifiedDT = true;\n  return true;\n}\n\nbool CodeGenPrepare::optimizeCallInst(CallInst *CI, bool &ModifiedDT) {\n  BasicBlock *BB = CI->getParent();\n\n  // Lower inline assembly if we can.\n  // If we found an inline asm expession, and if the target knows how to\n  // lower it to normal LLVM code, do so now.\n  if (CI->isInlineAsm()) {\n    if (TLI->ExpandInlineAsm(CI)) {\n      // Avoid invalidating the iterator.\n      CurInstIterator = BB->begin();\n      // Avoid processing instructions out of order, which could cause\n      // reuse before a value is defined.\n      SunkAddrs.clear();\n      return true;\n    }\n    // Sink address computing for memory operands into the block.\n    if (optimizeInlineAsmInst(CI))\n      return true;\n  }\n\n  // Align the pointer arguments to this call if the target thinks it's a good\n  // idea\n  unsigned MinSize, PrefAlign;\n  if (TLI->shouldAlignPointerArgs(CI, MinSize, PrefAlign)) {\n    for (auto &Arg : CI->arg_operands()) {\n      // We want to align both objects whose address is used directly and\n      // objects whose address is used in casts and GEPs, though it only makes\n      // sense for GEPs if the offset is a multiple of the desired alignment and\n      // if size - offset meets the size threshold.\n      if (!Arg->getType()->isPointerTy())\n        continue;\n      APInt Offset(DL->getIndexSizeInBits(\n                       cast<PointerType>(Arg->getType())->getAddressSpace()),\n                   0);\n      Value *Val = Arg->stripAndAccumulateInBoundsConstantOffsets(*DL, Offset);\n      uint64_t Offset2 = Offset.getLimitedValue();\n      if ((Offset2 & (PrefAlign-1)) != 0)\n        continue;\n      AllocaInst *AI;\n      if ((AI = dyn_cast<AllocaInst>(Val)) && AI->getAlignment() < PrefAlign &&\n          DL->getTypeAllocSize(AI->getAllocatedType()) >= MinSize + Offset2)\n        AI->setAlignment(Align(PrefAlign));\n      // Global variables can only be aligned if they are defined in this\n      // object (i.e. they are uniquely initialized in this object), and\n      // over-aligning global variables that have an explicit section is\n      // forbidden.\n      GlobalVariable *GV;\n      if ((GV = dyn_cast<GlobalVariable>(Val)) && GV->canIncreaseAlignment() &&\n          GV->getPointerAlignment(*DL) < PrefAlign &&\n          DL->getTypeAllocSize(GV->getValueType()) >=\n              MinSize + Offset2)\n        GV->setAlignment(MaybeAlign(PrefAlign));\n    }\n    // If this is a memcpy (or similar) then we may be able to improve the\n    // alignment\n    if (MemIntrinsic *MI = dyn_cast<MemIntrinsic>(CI)) {\n      Align DestAlign = getKnownAlignment(MI->getDest(), *DL);\n      MaybeAlign MIDestAlign = MI->getDestAlign();\n      if (!MIDestAlign || DestAlign > *MIDestAlign)\n        MI->setDestAlignment(DestAlign);\n      if (MemTransferInst *MTI = dyn_cast<MemTransferInst>(MI)) {\n        MaybeAlign MTISrcAlign = MTI->getSourceAlign();\n        Align SrcAlign = getKnownAlignment(MTI->getSource(), *DL);\n        if (!MTISrcAlign || SrcAlign > *MTISrcAlign)\n          MTI->setSourceAlignment(SrcAlign);\n      }\n    }\n  }\n\n  // If we have a cold call site, try to sink addressing computation into the\n  // cold block.  This interacts with our handling for loads and stores to\n  // ensure that we can fold all uses of a potential addressing computation\n  // into their uses.  TODO: generalize this to work over profiling data\n  if (CI->hasFnAttr(Attribute::Cold) &&\n      !OptSize && !llvm::shouldOptimizeForSize(BB, PSI, BFI.get()))\n    for (auto &Arg : CI->arg_operands()) {\n      if (!Arg->getType()->isPointerTy())\n        continue;\n      unsigned AS = Arg->getType()->getPointerAddressSpace();\n      return optimizeMemoryInst(CI, Arg, Arg->getType(), AS);\n    }\n\n  IntrinsicInst *II = dyn_cast<IntrinsicInst>(CI);\n  if (II) {\n    switch (II->getIntrinsicID()) {\n    default: break;\n    case Intrinsic::assume:\n      llvm_unreachable(\"llvm.assume should have been removed already\");\n    case Intrinsic::experimental_widenable_condition: {\n      // Give up on future widening oppurtunties so that we can fold away dead\n      // paths and merge blocks before going into block-local instruction\n      // selection.\n      if (II->use_empty()) {\n        II->eraseFromParent();\n        return true;\n      }\n      Constant *RetVal = ConstantInt::getTrue(II->getContext());\n      resetIteratorIfInvalidatedWhileCalling(BB, [&]() {\n        replaceAndRecursivelySimplify(CI, RetVal, TLInfo, nullptr);\n      });\n      return true;\n    }\n    case Intrinsic::objectsize:\n      llvm_unreachable(\"llvm.objectsize.* should have been lowered already\");\n    case Intrinsic::is_constant:\n      llvm_unreachable(\"llvm.is.constant.* should have been lowered already\");\n    case Intrinsic::aarch64_stlxr:\n    case Intrinsic::aarch64_stxr: {\n      ZExtInst *ExtVal = dyn_cast<ZExtInst>(CI->getArgOperand(0));\n      if (!ExtVal || !ExtVal->hasOneUse() ||\n          ExtVal->getParent() == CI->getParent())\n        return false;\n      // Sink a zext feeding stlxr/stxr before it, so it can be folded into it.\n      ExtVal->moveBefore(CI);\n      // Mark this instruction as \"inserted by CGP\", so that other\n      // optimizations don't touch it.\n      InsertedInsts.insert(ExtVal);\n      return true;\n    }\n\n    case Intrinsic::launder_invariant_group:\n    case Intrinsic::strip_invariant_group: {\n      Value *ArgVal = II->getArgOperand(0);\n      auto it = LargeOffsetGEPMap.find(II);\n      if (it != LargeOffsetGEPMap.end()) {\n          // Merge entries in LargeOffsetGEPMap to reflect the RAUW.\n          // Make sure not to have to deal with iterator invalidation\n          // after possibly adding ArgVal to LargeOffsetGEPMap.\n          auto GEPs = std::move(it->second);\n          LargeOffsetGEPMap[ArgVal].append(GEPs.begin(), GEPs.end());\n          LargeOffsetGEPMap.erase(II);\n      }\n\n      II->replaceAllUsesWith(ArgVal);\n      II->eraseFromParent();\n      return true;\n    }\n    case Intrinsic::cttz:\n    case Intrinsic::ctlz:\n      // If counting zeros is expensive, try to avoid it.\n      return despeculateCountZeros(II, TLI, DL, ModifiedDT);\n    case Intrinsic::fshl:\n    case Intrinsic::fshr:\n      return optimizeFunnelShift(II);\n    case Intrinsic::dbg_value:\n      return fixupDbgValue(II);\n    case Intrinsic::vscale: {\n      // If datalayout has no special restrictions on vector data layout,\n      // replace `llvm.vscale` by an equivalent constant expression\n      // to benefit from cheap constant propagation.\n      Type *ScalableVectorTy =\n          VectorType::get(Type::getInt8Ty(II->getContext()), 1, true);\n      if (DL->getTypeAllocSize(ScalableVectorTy).getKnownMinSize() == 8) {\n        auto *Null = Constant::getNullValue(ScalableVectorTy->getPointerTo());\n        auto *One = ConstantInt::getSigned(II->getType(), 1);\n        auto *CGep =\n            ConstantExpr::getGetElementPtr(ScalableVectorTy, Null, One);\n        II->replaceAllUsesWith(ConstantExpr::getPtrToInt(CGep, II->getType()));\n        II->eraseFromParent();\n        return true;\n      }\n      break;\n    }\n    case Intrinsic::masked_gather:\n      return optimizeGatherScatterInst(II, II->getArgOperand(0));\n    case Intrinsic::masked_scatter:\n      return optimizeGatherScatterInst(II, II->getArgOperand(1));\n    }\n\n    SmallVector<Value *, 2> PtrOps;\n    Type *AccessTy;\n    if (TLI->getAddrModeArguments(II, PtrOps, AccessTy))\n      while (!PtrOps.empty()) {\n        Value *PtrVal = PtrOps.pop_back_val();\n        unsigned AS = PtrVal->getType()->getPointerAddressSpace();\n        if (optimizeMemoryInst(II, PtrVal, AccessTy, AS))\n          return true;\n      }\n  }\n\n  // From here on out we're working with named functions.\n  if (!CI->getCalledFunction()) return false;\n\n  // Lower all default uses of _chk calls.  This is very similar\n  // to what InstCombineCalls does, but here we are only lowering calls\n  // to fortified library functions (e.g. __memcpy_chk) that have the default\n  // \"don't know\" as the objectsize.  Anything else should be left alone.\n  FortifiedLibCallSimplifier Simplifier(TLInfo, true);\n  IRBuilder<> Builder(CI);\n  if (Value *V = Simplifier.optimizeCall(CI, Builder)) {\n    CI->replaceAllUsesWith(V);\n    CI->eraseFromParent();\n    return true;\n  }\n\n  return false;\n}\n\n/// Look for opportunities to duplicate return instructions to the predecessor\n/// to enable tail call optimizations. The case it is currently looking for is:\n/// @code\n/// bb0:\n///   %tmp0 = tail call i32 @f0()\n///   br label %return\n/// bb1:\n///   %tmp1 = tail call i32 @f1()\n///   br label %return\n/// bb2:\n///   %tmp2 = tail call i32 @f2()\n///   br label %return\n/// return:\n///   %retval = phi i32 [ %tmp0, %bb0 ], [ %tmp1, %bb1 ], [ %tmp2, %bb2 ]\n///   ret i32 %retval\n/// @endcode\n///\n/// =>\n///\n/// @code\n/// bb0:\n///   %tmp0 = tail call i32 @f0()\n///   ret i32 %tmp0\n/// bb1:\n///   %tmp1 = tail call i32 @f1()\n///   ret i32 %tmp1\n/// bb2:\n///   %tmp2 = tail call i32 @f2()\n///   ret i32 %tmp2\n/// @endcode\nbool CodeGenPrepare::dupRetToEnableTailCallOpts(BasicBlock *BB, bool &ModifiedDT) {\n  ReturnInst *RetI = dyn_cast<ReturnInst>(BB->getTerminator());\n  if (!RetI)\n    return false;\n\n  PHINode *PN = nullptr;\n  ExtractValueInst *EVI = nullptr;\n  BitCastInst *BCI = nullptr;\n  Value *V = RetI->getReturnValue();\n  if (V) {\n    BCI = dyn_cast<BitCastInst>(V);\n    if (BCI)\n      V = BCI->getOperand(0);\n\n    EVI = dyn_cast<ExtractValueInst>(V);\n    if (EVI) {\n      V = EVI->getOperand(0);\n      if (!llvm::all_of(EVI->indices(), [](unsigned idx) { return idx == 0; }))\n        return false;\n    }\n\n    PN = dyn_cast<PHINode>(V);\n    if (!PN)\n      return false;\n  }\n\n  if (PN && PN->getParent() != BB)\n    return false;\n\n  auto isLifetimeEndOrBitCastFor = [](const Instruction *Inst) {\n    const BitCastInst *BC = dyn_cast<BitCastInst>(Inst);\n    if (BC && BC->hasOneUse())\n      Inst = BC->user_back();\n\n    if (const IntrinsicInst *II = dyn_cast<IntrinsicInst>(Inst))\n      return II->getIntrinsicID() == Intrinsic::lifetime_end;\n    return false;\n  };\n\n  // Make sure there are no instructions between the first instruction\n  // and return.\n  const Instruction *BI = BB->getFirstNonPHI();\n  // Skip over debug and the bitcast.\n  while (isa<DbgInfoIntrinsic>(BI) || BI == BCI || BI == EVI ||\n         isa<PseudoProbeInst>(BI) || isLifetimeEndOrBitCastFor(BI))\n    BI = BI->getNextNode();\n  if (BI != RetI)\n    return false;\n\n  /// Only dup the ReturnInst if the CallInst is likely to be emitted as a tail\n  /// call.\n  const Function *F = BB->getParent();\n  SmallVector<BasicBlock*, 4> TailCallBBs;\n  if (PN) {\n    for (unsigned I = 0, E = PN->getNumIncomingValues(); I != E; ++I) {\n      // Look through bitcasts.\n      Value *IncomingVal = PN->getIncomingValue(I)->stripPointerCasts();\n      CallInst *CI = dyn_cast<CallInst>(IncomingVal);\n      BasicBlock *PredBB = PN->getIncomingBlock(I);\n      // Make sure the phi value is indeed produced by the tail call.\n      if (CI && CI->hasOneUse() && CI->getParent() == PredBB &&\n          TLI->mayBeEmittedAsTailCall(CI) &&\n          attributesPermitTailCall(F, CI, RetI, *TLI))\n        TailCallBBs.push_back(PredBB);\n    }\n  } else {\n    SmallPtrSet<BasicBlock*, 4> VisitedBBs;\n    for (BasicBlock *Pred : predecessors(BB)) {\n      if (!VisitedBBs.insert(Pred).second)\n        continue;\n      if (Instruction *I = Pred->rbegin()->getPrevNonDebugInstruction(true)) {\n        CallInst *CI = dyn_cast<CallInst>(I);\n        if (CI && CI->use_empty() && TLI->mayBeEmittedAsTailCall(CI) &&\n            attributesPermitTailCall(F, CI, RetI, *TLI))\n          TailCallBBs.push_back(Pred);\n      }\n    }\n  }\n\n  bool Changed = false;\n  for (auto const &TailCallBB : TailCallBBs) {\n    // Make sure the call instruction is followed by an unconditional branch to\n    // the return block.\n    BranchInst *BI = dyn_cast<BranchInst>(TailCallBB->getTerminator());\n    if (!BI || !BI->isUnconditional() || BI->getSuccessor(0) != BB)\n      continue;\n\n    // Duplicate the return into TailCallBB.\n    (void)FoldReturnIntoUncondBranch(RetI, BB, TailCallBB);\n    assert(!VerifyBFIUpdates ||\n           BFI->getBlockFreq(BB) >= BFI->getBlockFreq(TailCallBB));\n    BFI->setBlockFreq(\n        BB,\n        (BFI->getBlockFreq(BB) - BFI->getBlockFreq(TailCallBB)).getFrequency());\n    ModifiedDT = Changed = true;\n    ++NumRetsDup;\n  }\n\n  // If we eliminated all predecessors of the block, delete the block now.\n  if (Changed && !BB->hasAddressTaken() && pred_empty(BB))\n    BB->eraseFromParent();\n\n  return Changed;\n}\n\n//===----------------------------------------------------------------------===//\n// Memory Optimization\n//===----------------------------------------------------------------------===//\n\nnamespace {\n\n/// This is an extended version of TargetLowering::AddrMode\n/// which holds actual Value*'s for register values.\nstruct ExtAddrMode : public TargetLowering::AddrMode {\n  Value *BaseReg = nullptr;\n  Value *ScaledReg = nullptr;\n  Value *OriginalValue = nullptr;\n  bool InBounds = true;\n\n  enum FieldName {\n    NoField        = 0x00,\n    BaseRegField   = 0x01,\n    BaseGVField    = 0x02,\n    BaseOffsField  = 0x04,\n    ScaledRegField = 0x08,\n    ScaleField     = 0x10,\n    MultipleFields = 0xff\n  };\n\n\n  ExtAddrMode() = default;\n\n  void print(raw_ostream &OS) const;\n  void dump() const;\n\n  FieldName compare(const ExtAddrMode &other) {\n    // First check that the types are the same on each field, as differing types\n    // is something we can't cope with later on.\n    if (BaseReg && other.BaseReg &&\n        BaseReg->getType() != other.BaseReg->getType())\n      return MultipleFields;\n    if (BaseGV && other.BaseGV &&\n        BaseGV->getType() != other.BaseGV->getType())\n      return MultipleFields;\n    if (ScaledReg && other.ScaledReg &&\n        ScaledReg->getType() != other.ScaledReg->getType())\n      return MultipleFields;\n\n    // Conservatively reject 'inbounds' mismatches.\n    if (InBounds != other.InBounds)\n      return MultipleFields;\n\n    // Check each field to see if it differs.\n    unsigned Result = NoField;\n    if (BaseReg != other.BaseReg)\n      Result |= BaseRegField;\n    if (BaseGV != other.BaseGV)\n      Result |= BaseGVField;\n    if (BaseOffs != other.BaseOffs)\n      Result |= BaseOffsField;\n    if (ScaledReg != other.ScaledReg)\n      Result |= ScaledRegField;\n    // Don't count 0 as being a different scale, because that actually means\n    // unscaled (which will already be counted by having no ScaledReg).\n    if (Scale && other.Scale && Scale != other.Scale)\n      Result |= ScaleField;\n\n    if (countPopulation(Result) > 1)\n      return MultipleFields;\n    else\n      return static_cast<FieldName>(Result);\n  }\n\n  // An AddrMode is trivial if it involves no calculation i.e. it is just a base\n  // with no offset.\n  bool isTrivial() {\n    // An AddrMode is (BaseGV + BaseReg + BaseOffs + ScaleReg * Scale) so it is\n    // trivial if at most one of these terms is nonzero, except that BaseGV and\n    // BaseReg both being zero actually means a null pointer value, which we\n    // consider to be 'non-zero' here.\n    return !BaseOffs && !Scale && !(BaseGV && BaseReg);\n  }\n\n  Value *GetFieldAsValue(FieldName Field, Type *IntPtrTy) {\n    switch (Field) {\n    default:\n      return nullptr;\n    case BaseRegField:\n      return BaseReg;\n    case BaseGVField:\n      return BaseGV;\n    case ScaledRegField:\n      return ScaledReg;\n    case BaseOffsField:\n      return ConstantInt::get(IntPtrTy, BaseOffs);\n    }\n  }\n\n  void SetCombinedField(FieldName Field, Value *V,\n                        const SmallVectorImpl<ExtAddrMode> &AddrModes) {\n    switch (Field) {\n    default:\n      llvm_unreachable(\"Unhandled fields are expected to be rejected earlier\");\n      break;\n    case ExtAddrMode::BaseRegField:\n      BaseReg = V;\n      break;\n    case ExtAddrMode::BaseGVField:\n      // A combined BaseGV is an Instruction, not a GlobalValue, so it goes\n      // in the BaseReg field.\n      assert(BaseReg == nullptr);\n      BaseReg = V;\n      BaseGV = nullptr;\n      break;\n    case ExtAddrMode::ScaledRegField:\n      ScaledReg = V;\n      // If we have a mix of scaled and unscaled addrmodes then we want scale\n      // to be the scale and not zero.\n      if (!Scale)\n        for (const ExtAddrMode &AM : AddrModes)\n          if (AM.Scale) {\n            Scale = AM.Scale;\n            break;\n          }\n      break;\n    case ExtAddrMode::BaseOffsField:\n      // The offset is no longer a constant, so it goes in ScaledReg with a\n      // scale of 1.\n      assert(ScaledReg == nullptr);\n      ScaledReg = V;\n      Scale = 1;\n      BaseOffs = 0;\n      break;\n    }\n  }\n};\n\n} // end anonymous namespace\n\n#ifndef NDEBUG\nstatic inline raw_ostream &operator<<(raw_ostream &OS, const ExtAddrMode &AM) {\n  AM.print(OS);\n  return OS;\n}\n#endif\n\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\nvoid ExtAddrMode::print(raw_ostream &OS) const {\n  bool NeedPlus = false;\n  OS << \"[\";\n  if (InBounds)\n    OS << \"inbounds \";\n  if (BaseGV) {\n    OS << (NeedPlus ? \" + \" : \"\")\n       << \"GV:\";\n    BaseGV->printAsOperand(OS, /*PrintType=*/false);\n    NeedPlus = true;\n  }\n\n  if (BaseOffs) {\n    OS << (NeedPlus ? \" + \" : \"\")\n       << BaseOffs;\n    NeedPlus = true;\n  }\n\n  if (BaseReg) {\n    OS << (NeedPlus ? \" + \" : \"\")\n       << \"Base:\";\n    BaseReg->printAsOperand(OS, /*PrintType=*/false);\n    NeedPlus = true;\n  }\n  if (Scale) {\n    OS << (NeedPlus ? \" + \" : \"\")\n       << Scale << \"*\";\n    ScaledReg->printAsOperand(OS, /*PrintType=*/false);\n  }\n\n  OS << ']';\n}\n\nLLVM_DUMP_METHOD void ExtAddrMode::dump() const {\n  print(dbgs());\n  dbgs() << '\\n';\n}\n#endif\n\nnamespace {\n\n/// This class provides transaction based operation on the IR.\n/// Every change made through this class is recorded in the internal state and\n/// can be undone (rollback) until commit is called.\n/// CGP does not check if instructions could be speculatively executed when\n/// moved. Preserving the original location would pessimize the debugging\n/// experience, as well as negatively impact the quality of sample PGO.\nclass TypePromotionTransaction {\n  /// This represents the common interface of the individual transaction.\n  /// Each class implements the logic for doing one specific modification on\n  /// the IR via the TypePromotionTransaction.\n  class TypePromotionAction {\n  protected:\n    /// The Instruction modified.\n    Instruction *Inst;\n\n  public:\n    /// Constructor of the action.\n    /// The constructor performs the related action on the IR.\n    TypePromotionAction(Instruction *Inst) : Inst(Inst) {}\n\n    virtual ~TypePromotionAction() = default;\n\n    /// Undo the modification done by this action.\n    /// When this method is called, the IR must be in the same state as it was\n    /// before this action was applied.\n    /// \\pre Undoing the action works if and only if the IR is in the exact same\n    /// state as it was directly after this action was applied.\n    virtual void undo() = 0;\n\n    /// Advocate every change made by this action.\n    /// When the results on the IR of the action are to be kept, it is important\n    /// to call this function, otherwise hidden information may be kept forever.\n    virtual void commit() {\n      // Nothing to be done, this action is not doing anything.\n    }\n  };\n\n  /// Utility to remember the position of an instruction.\n  class InsertionHandler {\n    /// Position of an instruction.\n    /// Either an instruction:\n    /// - Is the first in a basic block: BB is used.\n    /// - Has a previous instruction: PrevInst is used.\n    union {\n      Instruction *PrevInst;\n      BasicBlock *BB;\n    } Point;\n\n    /// Remember whether or not the instruction had a previous instruction.\n    bool HasPrevInstruction;\n\n  public:\n    /// Record the position of \\p Inst.\n    InsertionHandler(Instruction *Inst) {\n      BasicBlock::iterator It = Inst->getIterator();\n      HasPrevInstruction = (It != (Inst->getParent()->begin()));\n      if (HasPrevInstruction)\n        Point.PrevInst = &*--It;\n      else\n        Point.BB = Inst->getParent();\n    }\n\n    /// Insert \\p Inst at the recorded position.\n    void insert(Instruction *Inst) {\n      if (HasPrevInstruction) {\n        if (Inst->getParent())\n          Inst->removeFromParent();\n        Inst->insertAfter(Point.PrevInst);\n      } else {\n        Instruction *Position = &*Point.BB->getFirstInsertionPt();\n        if (Inst->getParent())\n          Inst->moveBefore(Position);\n        else\n          Inst->insertBefore(Position);\n      }\n    }\n  };\n\n  /// Move an instruction before another.\n  class InstructionMoveBefore : public TypePromotionAction {\n    /// Original position of the instruction.\n    InsertionHandler Position;\n\n  public:\n    /// Move \\p Inst before \\p Before.\n    InstructionMoveBefore(Instruction *Inst, Instruction *Before)\n        : TypePromotionAction(Inst), Position(Inst) {\n      LLVM_DEBUG(dbgs() << \"Do: move: \" << *Inst << \"\\nbefore: \" << *Before\n                        << \"\\n\");\n      Inst->moveBefore(Before);\n    }\n\n    /// Move the instruction back to its original position.\n    void undo() override {\n      LLVM_DEBUG(dbgs() << \"Undo: moveBefore: \" << *Inst << \"\\n\");\n      Position.insert(Inst);\n    }\n  };\n\n  /// Set the operand of an instruction with a new value.\n  class OperandSetter : public TypePromotionAction {\n    /// Original operand of the instruction.\n    Value *Origin;\n\n    /// Index of the modified instruction.\n    unsigned Idx;\n\n  public:\n    /// Set \\p Idx operand of \\p Inst with \\p NewVal.\n    OperandSetter(Instruction *Inst, unsigned Idx, Value *NewVal)\n        : TypePromotionAction(Inst), Idx(Idx) {\n      LLVM_DEBUG(dbgs() << \"Do: setOperand: \" << Idx << \"\\n\"\n                        << \"for:\" << *Inst << \"\\n\"\n                        << \"with:\" << *NewVal << \"\\n\");\n      Origin = Inst->getOperand(Idx);\n      Inst->setOperand(Idx, NewVal);\n    }\n\n    /// Restore the original value of the instruction.\n    void undo() override {\n      LLVM_DEBUG(dbgs() << \"Undo: setOperand:\" << Idx << \"\\n\"\n                        << \"for: \" << *Inst << \"\\n\"\n                        << \"with: \" << *Origin << \"\\n\");\n      Inst->setOperand(Idx, Origin);\n    }\n  };\n\n  /// Hide the operands of an instruction.\n  /// Do as if this instruction was not using any of its operands.\n  class OperandsHider : public TypePromotionAction {\n    /// The list of original operands.\n    SmallVector<Value *, 4> OriginalValues;\n\n  public:\n    /// Remove \\p Inst from the uses of the operands of \\p Inst.\n    OperandsHider(Instruction *Inst) : TypePromotionAction(Inst) {\n      LLVM_DEBUG(dbgs() << \"Do: OperandsHider: \" << *Inst << \"\\n\");\n      unsigned NumOpnds = Inst->getNumOperands();\n      OriginalValues.reserve(NumOpnds);\n      for (unsigned It = 0; It < NumOpnds; ++It) {\n        // Save the current operand.\n        Value *Val = Inst->getOperand(It);\n        OriginalValues.push_back(Val);\n        // Set a dummy one.\n        // We could use OperandSetter here, but that would imply an overhead\n        // that we are not willing to pay.\n        Inst->setOperand(It, UndefValue::get(Val->getType()));\n      }\n    }\n\n    /// Restore the original list of uses.\n    void undo() override {\n      LLVM_DEBUG(dbgs() << \"Undo: OperandsHider: \" << *Inst << \"\\n\");\n      for (unsigned It = 0, EndIt = OriginalValues.size(); It != EndIt; ++It)\n        Inst->setOperand(It, OriginalValues[It]);\n    }\n  };\n\n  /// Build a truncate instruction.\n  class TruncBuilder : public TypePromotionAction {\n    Value *Val;\n\n  public:\n    /// Build a truncate instruction of \\p Opnd producing a \\p Ty\n    /// result.\n    /// trunc Opnd to Ty.\n    TruncBuilder(Instruction *Opnd, Type *Ty) : TypePromotionAction(Opnd) {\n      IRBuilder<> Builder(Opnd);\n      Builder.SetCurrentDebugLocation(DebugLoc());\n      Val = Builder.CreateTrunc(Opnd, Ty, \"promoted\");\n      LLVM_DEBUG(dbgs() << \"Do: TruncBuilder: \" << *Val << \"\\n\");\n    }\n\n    /// Get the built value.\n    Value *getBuiltValue() { return Val; }\n\n    /// Remove the built instruction.\n    void undo() override {\n      LLVM_DEBUG(dbgs() << \"Undo: TruncBuilder: \" << *Val << \"\\n\");\n      if (Instruction *IVal = dyn_cast<Instruction>(Val))\n        IVal->eraseFromParent();\n    }\n  };\n\n  /// Build a sign extension instruction.\n  class SExtBuilder : public TypePromotionAction {\n    Value *Val;\n\n  public:\n    /// Build a sign extension instruction of \\p Opnd producing a \\p Ty\n    /// result.\n    /// sext Opnd to Ty.\n    SExtBuilder(Instruction *InsertPt, Value *Opnd, Type *Ty)\n        : TypePromotionAction(InsertPt) {\n      IRBuilder<> Builder(InsertPt);\n      Val = Builder.CreateSExt(Opnd, Ty, \"promoted\");\n      LLVM_DEBUG(dbgs() << \"Do: SExtBuilder: \" << *Val << \"\\n\");\n    }\n\n    /// Get the built value.\n    Value *getBuiltValue() { return Val; }\n\n    /// Remove the built instruction.\n    void undo() override {\n      LLVM_DEBUG(dbgs() << \"Undo: SExtBuilder: \" << *Val << \"\\n\");\n      if (Instruction *IVal = dyn_cast<Instruction>(Val))\n        IVal->eraseFromParent();\n    }\n  };\n\n  /// Build a zero extension instruction.\n  class ZExtBuilder : public TypePromotionAction {\n    Value *Val;\n\n  public:\n    /// Build a zero extension instruction of \\p Opnd producing a \\p Ty\n    /// result.\n    /// zext Opnd to Ty.\n    ZExtBuilder(Instruction *InsertPt, Value *Opnd, Type *Ty)\n        : TypePromotionAction(InsertPt) {\n      IRBuilder<> Builder(InsertPt);\n      Builder.SetCurrentDebugLocation(DebugLoc());\n      Val = Builder.CreateZExt(Opnd, Ty, \"promoted\");\n      LLVM_DEBUG(dbgs() << \"Do: ZExtBuilder: \" << *Val << \"\\n\");\n    }\n\n    /// Get the built value.\n    Value *getBuiltValue() { return Val; }\n\n    /// Remove the built instruction.\n    void undo() override {\n      LLVM_DEBUG(dbgs() << \"Undo: ZExtBuilder: \" << *Val << \"\\n\");\n      if (Instruction *IVal = dyn_cast<Instruction>(Val))\n        IVal->eraseFromParent();\n    }\n  };\n\n  /// Mutate an instruction to another type.\n  class TypeMutator : public TypePromotionAction {\n    /// Record the original type.\n    Type *OrigTy;\n\n  public:\n    /// Mutate the type of \\p Inst into \\p NewTy.\n    TypeMutator(Instruction *Inst, Type *NewTy)\n        : TypePromotionAction(Inst), OrigTy(Inst->getType()) {\n      LLVM_DEBUG(dbgs() << \"Do: MutateType: \" << *Inst << \" with \" << *NewTy\n                        << \"\\n\");\n      Inst->mutateType(NewTy);\n    }\n\n    /// Mutate the instruction back to its original type.\n    void undo() override {\n      LLVM_DEBUG(dbgs() << \"Undo: MutateType: \" << *Inst << \" with \" << *OrigTy\n                        << \"\\n\");\n      Inst->mutateType(OrigTy);\n    }\n  };\n\n  /// Replace the uses of an instruction by another instruction.\n  class UsesReplacer : public TypePromotionAction {\n    /// Helper structure to keep track of the replaced uses.\n    struct InstructionAndIdx {\n      /// The instruction using the instruction.\n      Instruction *Inst;\n\n      /// The index where this instruction is used for Inst.\n      unsigned Idx;\n\n      InstructionAndIdx(Instruction *Inst, unsigned Idx)\n          : Inst(Inst), Idx(Idx) {}\n    };\n\n    /// Keep track of the original uses (pair Instruction, Index).\n    SmallVector<InstructionAndIdx, 4> OriginalUses;\n    /// Keep track of the debug users.\n    SmallVector<DbgValueInst *, 1> DbgValues;\n\n    /// Keep track of the new value so that we can undo it by replacing\n    /// instances of the new value with the original value.\n    Value *New;\n\n    using use_iterator = SmallVectorImpl<InstructionAndIdx>::iterator;\n\n  public:\n    /// Replace all the use of \\p Inst by \\p New.\n    UsesReplacer(Instruction *Inst, Value *New)\n        : TypePromotionAction(Inst), New(New) {\n      LLVM_DEBUG(dbgs() << \"Do: UsersReplacer: \" << *Inst << \" with \" << *New\n                        << \"\\n\");\n      // Record the original uses.\n      for (Use &U : Inst->uses()) {\n        Instruction *UserI = cast<Instruction>(U.getUser());\n        OriginalUses.push_back(InstructionAndIdx(UserI, U.getOperandNo()));\n      }\n      // Record the debug uses separately. They are not in the instruction's\n      // use list, but they are replaced by RAUW.\n      findDbgValues(DbgValues, Inst);\n\n      // Now, we can replace the uses.\n      Inst->replaceAllUsesWith(New);\n    }\n\n    /// Reassign the original uses of Inst to Inst.\n    void undo() override {\n      LLVM_DEBUG(dbgs() << \"Undo: UsersReplacer: \" << *Inst << \"\\n\");\n      for (InstructionAndIdx &Use : OriginalUses)\n        Use.Inst->setOperand(Use.Idx, Inst);\n      // RAUW has replaced all original uses with references to the new value,\n      // including the debug uses. Since we are undoing the replacements,\n      // the original debug uses must also be reinstated to maintain the\n      // correctness and utility of debug value instructions.\n      for (auto *DVI : DbgValues)\n        DVI->replaceVariableLocationOp(New, Inst);\n    }\n  };\n\n  /// Remove an instruction from the IR.\n  class InstructionRemover : public TypePromotionAction {\n    /// Original position of the instruction.\n    InsertionHandler Inserter;\n\n    /// Helper structure to hide all the link to the instruction. In other\n    /// words, this helps to do as if the instruction was removed.\n    OperandsHider Hider;\n\n    /// Keep track of the uses replaced, if any.\n    UsesReplacer *Replacer = nullptr;\n\n    /// Keep track of instructions removed.\n    SetOfInstrs &RemovedInsts;\n\n  public:\n    /// Remove all reference of \\p Inst and optionally replace all its\n    /// uses with New.\n    /// \\p RemovedInsts Keep track of the instructions removed by this Action.\n    /// \\pre If !Inst->use_empty(), then New != nullptr\n    InstructionRemover(Instruction *Inst, SetOfInstrs &RemovedInsts,\n                       Value *New = nullptr)\n        : TypePromotionAction(Inst), Inserter(Inst), Hider(Inst),\n          RemovedInsts(RemovedInsts) {\n      if (New)\n        Replacer = new UsesReplacer(Inst, New);\n      LLVM_DEBUG(dbgs() << \"Do: InstructionRemover: \" << *Inst << \"\\n\");\n      RemovedInsts.insert(Inst);\n      /// The instructions removed here will be freed after completing\n      /// optimizeBlock() for all blocks as we need to keep track of the\n      /// removed instructions during promotion.\n      Inst->removeFromParent();\n    }\n\n    ~InstructionRemover() override { delete Replacer; }\n\n    /// Resurrect the instruction and reassign it to the proper uses if\n    /// new value was provided when build this action.\n    void undo() override {\n      LLVM_DEBUG(dbgs() << \"Undo: InstructionRemover: \" << *Inst << \"\\n\");\n      Inserter.insert(Inst);\n      if (Replacer)\n        Replacer->undo();\n      Hider.undo();\n      RemovedInsts.erase(Inst);\n    }\n  };\n\npublic:\n  /// Restoration point.\n  /// The restoration point is a pointer to an action instead of an iterator\n  /// because the iterator may be invalidated but not the pointer.\n  using ConstRestorationPt = const TypePromotionAction *;\n\n  TypePromotionTransaction(SetOfInstrs &RemovedInsts)\n      : RemovedInsts(RemovedInsts) {}\n\n  /// Advocate every changes made in that transaction. Return true if any change\n  /// happen.\n  bool commit();\n\n  /// Undo all the changes made after the given point.\n  void rollback(ConstRestorationPt Point);\n\n  /// Get the current restoration point.\n  ConstRestorationPt getRestorationPoint() const;\n\n  /// \\name API for IR modification with state keeping to support rollback.\n  /// @{\n  /// Same as Instruction::setOperand.\n  void setOperand(Instruction *Inst, unsigned Idx, Value *NewVal);\n\n  /// Same as Instruction::eraseFromParent.\n  void eraseInstruction(Instruction *Inst, Value *NewVal = nullptr);\n\n  /// Same as Value::replaceAllUsesWith.\n  void replaceAllUsesWith(Instruction *Inst, Value *New);\n\n  /// Same as Value::mutateType.\n  void mutateType(Instruction *Inst, Type *NewTy);\n\n  /// Same as IRBuilder::createTrunc.\n  Value *createTrunc(Instruction *Opnd, Type *Ty);\n\n  /// Same as IRBuilder::createSExt.\n  Value *createSExt(Instruction *Inst, Value *Opnd, Type *Ty);\n\n  /// Same as IRBuilder::createZExt.\n  Value *createZExt(Instruction *Inst, Value *Opnd, Type *Ty);\n\n  /// Same as Instruction::moveBefore.\n  void moveBefore(Instruction *Inst, Instruction *Before);\n  /// @}\n\nprivate:\n  /// The ordered list of actions made so far.\n  SmallVector<std::unique_ptr<TypePromotionAction>, 16> Actions;\n\n  using CommitPt = SmallVectorImpl<std::unique_ptr<TypePromotionAction>>::iterator;\n\n  SetOfInstrs &RemovedInsts;\n};\n\n} // end anonymous namespace\n\nvoid TypePromotionTransaction::setOperand(Instruction *Inst, unsigned Idx,\n                                          Value *NewVal) {\n  Actions.push_back(std::make_unique<TypePromotionTransaction::OperandSetter>(\n      Inst, Idx, NewVal));\n}\n\nvoid TypePromotionTransaction::eraseInstruction(Instruction *Inst,\n                                                Value *NewVal) {\n  Actions.push_back(\n      std::make_unique<TypePromotionTransaction::InstructionRemover>(\n          Inst, RemovedInsts, NewVal));\n}\n\nvoid TypePromotionTransaction::replaceAllUsesWith(Instruction *Inst,\n                                                  Value *New) {\n  Actions.push_back(\n      std::make_unique<TypePromotionTransaction::UsesReplacer>(Inst, New));\n}\n\nvoid TypePromotionTransaction::mutateType(Instruction *Inst, Type *NewTy) {\n  Actions.push_back(\n      std::make_unique<TypePromotionTransaction::TypeMutator>(Inst, NewTy));\n}\n\nValue *TypePromotionTransaction::createTrunc(Instruction *Opnd,\n                                             Type *Ty) {\n  std::unique_ptr<TruncBuilder> Ptr(new TruncBuilder(Opnd, Ty));\n  Value *Val = Ptr->getBuiltValue();\n  Actions.push_back(std::move(Ptr));\n  return Val;\n}\n\nValue *TypePromotionTransaction::createSExt(Instruction *Inst,\n                                            Value *Opnd, Type *Ty) {\n  std::unique_ptr<SExtBuilder> Ptr(new SExtBuilder(Inst, Opnd, Ty));\n  Value *Val = Ptr->getBuiltValue();\n  Actions.push_back(std::move(Ptr));\n  return Val;\n}\n\nValue *TypePromotionTransaction::createZExt(Instruction *Inst,\n                                            Value *Opnd, Type *Ty) {\n  std::unique_ptr<ZExtBuilder> Ptr(new ZExtBuilder(Inst, Opnd, Ty));\n  Value *Val = Ptr->getBuiltValue();\n  Actions.push_back(std::move(Ptr));\n  return Val;\n}\n\nvoid TypePromotionTransaction::moveBefore(Instruction *Inst,\n                                          Instruction *Before) {\n  Actions.push_back(\n      std::make_unique<TypePromotionTransaction::InstructionMoveBefore>(\n          Inst, Before));\n}\n\nTypePromotionTransaction::ConstRestorationPt\nTypePromotionTransaction::getRestorationPoint() const {\n  return !Actions.empty() ? Actions.back().get() : nullptr;\n}\n\nbool TypePromotionTransaction::commit() {\n  for (std::unique_ptr<TypePromotionAction> &Action : Actions)\n    Action->commit();\n  bool Modified = !Actions.empty();\n  Actions.clear();\n  return Modified;\n}\n\nvoid TypePromotionTransaction::rollback(\n    TypePromotionTransaction::ConstRestorationPt Point) {\n  while (!Actions.empty() && Point != Actions.back().get()) {\n    std::unique_ptr<TypePromotionAction> Curr = Actions.pop_back_val();\n    Curr->undo();\n  }\n}\n\nnamespace {\n\n/// A helper class for matching addressing modes.\n///\n/// This encapsulates the logic for matching the target-legal addressing modes.\nclass AddressingModeMatcher {\n  SmallVectorImpl<Instruction*> &AddrModeInsts;\n  const TargetLowering &TLI;\n  const TargetRegisterInfo &TRI;\n  const DataLayout &DL;\n  const LoopInfo &LI;\n  const std::function<const DominatorTree &()> getDTFn;\n\n  /// AccessTy/MemoryInst - This is the type for the access (e.g. double) and\n  /// the memory instruction that we're computing this address for.\n  Type *AccessTy;\n  unsigned AddrSpace;\n  Instruction *MemoryInst;\n\n  /// This is the addressing mode that we're building up. This is\n  /// part of the return value of this addressing mode matching stuff.\n  ExtAddrMode &AddrMode;\n\n  /// The instructions inserted by other CodeGenPrepare optimizations.\n  const SetOfInstrs &InsertedInsts;\n\n  /// A map from the instructions to their type before promotion.\n  InstrToOrigTy &PromotedInsts;\n\n  /// The ongoing transaction where every action should be registered.\n  TypePromotionTransaction &TPT;\n\n  // A GEP which has too large offset to be folded into the addressing mode.\n  std::pair<AssertingVH<GetElementPtrInst>, int64_t> &LargeOffsetGEP;\n\n  /// This is set to true when we should not do profitability checks.\n  /// When true, IsProfitableToFoldIntoAddressingMode always returns true.\n  bool IgnoreProfitability;\n\n  /// True if we are optimizing for size.\n  bool OptSize;\n\n  ProfileSummaryInfo *PSI;\n  BlockFrequencyInfo *BFI;\n\n  AddressingModeMatcher(\n      SmallVectorImpl<Instruction *> &AMI, const TargetLowering &TLI,\n      const TargetRegisterInfo &TRI, const LoopInfo &LI,\n      const std::function<const DominatorTree &()> getDTFn,\n      Type *AT, unsigned AS, Instruction *MI, ExtAddrMode &AM,\n      const SetOfInstrs &InsertedInsts, InstrToOrigTy &PromotedInsts,\n      TypePromotionTransaction &TPT,\n      std::pair<AssertingVH<GetElementPtrInst>, int64_t> &LargeOffsetGEP,\n      bool OptSize, ProfileSummaryInfo *PSI, BlockFrequencyInfo *BFI)\n      : AddrModeInsts(AMI), TLI(TLI), TRI(TRI),\n        DL(MI->getModule()->getDataLayout()), LI(LI), getDTFn(getDTFn),\n        AccessTy(AT), AddrSpace(AS), MemoryInst(MI), AddrMode(AM),\n        InsertedInsts(InsertedInsts), PromotedInsts(PromotedInsts), TPT(TPT),\n        LargeOffsetGEP(LargeOffsetGEP), OptSize(OptSize), PSI(PSI), BFI(BFI) {\n    IgnoreProfitability = false;\n  }\n\npublic:\n  /// Find the maximal addressing mode that a load/store of V can fold,\n  /// give an access type of AccessTy.  This returns a list of involved\n  /// instructions in AddrModeInsts.\n  /// \\p InsertedInsts The instructions inserted by other CodeGenPrepare\n  /// optimizations.\n  /// \\p PromotedInsts maps the instructions to their type before promotion.\n  /// \\p The ongoing transaction where every action should be registered.\n  static ExtAddrMode\n  Match(Value *V, Type *AccessTy, unsigned AS, Instruction *MemoryInst,\n        SmallVectorImpl<Instruction *> &AddrModeInsts,\n        const TargetLowering &TLI, const LoopInfo &LI,\n        const std::function<const DominatorTree &()> getDTFn,\n        const TargetRegisterInfo &TRI, const SetOfInstrs &InsertedInsts,\n        InstrToOrigTy &PromotedInsts, TypePromotionTransaction &TPT,\n        std::pair<AssertingVH<GetElementPtrInst>, int64_t> &LargeOffsetGEP,\n        bool OptSize, ProfileSummaryInfo *PSI, BlockFrequencyInfo *BFI) {\n    ExtAddrMode Result;\n\n    bool Success = AddressingModeMatcher(\n        AddrModeInsts, TLI, TRI, LI, getDTFn, AccessTy, AS, MemoryInst, Result,\n        InsertedInsts, PromotedInsts, TPT, LargeOffsetGEP, OptSize, PSI,\n        BFI).matchAddr(V, 0);\n    (void)Success; assert(Success && \"Couldn't select *anything*?\");\n    return Result;\n  }\n\nprivate:\n  bool matchScaledValue(Value *ScaleReg, int64_t Scale, unsigned Depth);\n  bool matchAddr(Value *Addr, unsigned Depth);\n  bool matchOperationAddr(User *AddrInst, unsigned Opcode, unsigned Depth,\n                          bool *MovedAway = nullptr);\n  bool isProfitableToFoldIntoAddressingMode(Instruction *I,\n                                            ExtAddrMode &AMBefore,\n                                            ExtAddrMode &AMAfter);\n  bool valueAlreadyLiveAtInst(Value *Val, Value *KnownLive1, Value *KnownLive2);\n  bool isPromotionProfitable(unsigned NewCost, unsigned OldCost,\n                             Value *PromotedOperand) const;\n};\n\nclass PhiNodeSet;\n\n/// An iterator for PhiNodeSet.\nclass PhiNodeSetIterator {\n  PhiNodeSet * const Set;\n  size_t CurrentIndex = 0;\n\npublic:\n  /// The constructor. Start should point to either a valid element, or be equal\n  /// to the size of the underlying SmallVector of the PhiNodeSet.\n  PhiNodeSetIterator(PhiNodeSet * const Set, size_t Start);\n  PHINode * operator*() const;\n  PhiNodeSetIterator& operator++();\n  bool operator==(const PhiNodeSetIterator &RHS) const;\n  bool operator!=(const PhiNodeSetIterator &RHS) const;\n};\n\n/// Keeps a set of PHINodes.\n///\n/// This is a minimal set implementation for a specific use case:\n/// It is very fast when there are very few elements, but also provides good\n/// performance when there are many. It is similar to SmallPtrSet, but also\n/// provides iteration by insertion order, which is deterministic and stable\n/// across runs. It is also similar to SmallSetVector, but provides removing\n/// elements in O(1) time. This is achieved by not actually removing the element\n/// from the underlying vector, so comes at the cost of using more memory, but\n/// that is fine, since PhiNodeSets are used as short lived objects.\nclass PhiNodeSet {\n  friend class PhiNodeSetIterator;\n\n  using MapType = SmallDenseMap<PHINode *, size_t, 32>;\n  using iterator =  PhiNodeSetIterator;\n\n  /// Keeps the elements in the order of their insertion in the underlying\n  /// vector. To achieve constant time removal, it never deletes any element.\n  SmallVector<PHINode *, 32> NodeList;\n\n  /// Keeps the elements in the underlying set implementation. This (and not the\n  /// NodeList defined above) is the source of truth on whether an element\n  /// is actually in the collection.\n  MapType NodeMap;\n\n  /// Points to the first valid (not deleted) element when the set is not empty\n  /// and the value is not zero. Equals to the size of the underlying vector\n  /// when the set is empty. When the value is 0, as in the beginning, the\n  /// first element may or may not be valid.\n  size_t FirstValidElement = 0;\n\npublic:\n  /// Inserts a new element to the collection.\n  /// \\returns true if the element is actually added, i.e. was not in the\n  /// collection before the operation.\n  bool insert(PHINode *Ptr) {\n    if (NodeMap.insert(std::make_pair(Ptr, NodeList.size())).second) {\n      NodeList.push_back(Ptr);\n      return true;\n    }\n    return false;\n  }\n\n  /// Removes the element from the collection.\n  /// \\returns whether the element is actually removed, i.e. was in the\n  /// collection before the operation.\n  bool erase(PHINode *Ptr) {\n    if (NodeMap.erase(Ptr)) {\n      SkipRemovedElements(FirstValidElement);\n      return true;\n    }\n    return false;\n  }\n\n  /// Removes all elements and clears the collection.\n  void clear() {\n    NodeMap.clear();\n    NodeList.clear();\n    FirstValidElement = 0;\n  }\n\n  /// \\returns an iterator that will iterate the elements in the order of\n  /// insertion.\n  iterator begin() {\n    if (FirstValidElement == 0)\n      SkipRemovedElements(FirstValidElement);\n    return PhiNodeSetIterator(this, FirstValidElement);\n  }\n\n  /// \\returns an iterator that points to the end of the collection.\n  iterator end() { return PhiNodeSetIterator(this, NodeList.size()); }\n\n  /// Returns the number of elements in the collection.\n  size_t size() const {\n    return NodeMap.size();\n  }\n\n  /// \\returns 1 if the given element is in the collection, and 0 if otherwise.\n  size_t count(PHINode *Ptr) const {\n    return NodeMap.count(Ptr);\n  }\n\nprivate:\n  /// Updates the CurrentIndex so that it will point to a valid element.\n  ///\n  /// If the element of NodeList at CurrentIndex is valid, it does not\n  /// change it. If there are no more valid elements, it updates CurrentIndex\n  /// to point to the end of the NodeList.\n  void SkipRemovedElements(size_t &CurrentIndex) {\n    while (CurrentIndex < NodeList.size()) {\n      auto it = NodeMap.find(NodeList[CurrentIndex]);\n      // If the element has been deleted and added again later, NodeMap will\n      // point to a different index, so CurrentIndex will still be invalid.\n      if (it != NodeMap.end() && it->second == CurrentIndex)\n        break;\n      ++CurrentIndex;\n    }\n  }\n};\n\nPhiNodeSetIterator::PhiNodeSetIterator(PhiNodeSet *const Set, size_t Start)\n    : Set(Set), CurrentIndex(Start) {}\n\nPHINode * PhiNodeSetIterator::operator*() const {\n  assert(CurrentIndex < Set->NodeList.size() &&\n         \"PhiNodeSet access out of range\");\n  return Set->NodeList[CurrentIndex];\n}\n\nPhiNodeSetIterator& PhiNodeSetIterator::operator++() {\n  assert(CurrentIndex < Set->NodeList.size() &&\n         \"PhiNodeSet access out of range\");\n  ++CurrentIndex;\n  Set->SkipRemovedElements(CurrentIndex);\n  return *this;\n}\n\nbool PhiNodeSetIterator::operator==(const PhiNodeSetIterator &RHS) const {\n  return CurrentIndex == RHS.CurrentIndex;\n}\n\nbool PhiNodeSetIterator::operator!=(const PhiNodeSetIterator &RHS) const {\n  return !((*this) == RHS);\n}\n\n/// Keep track of simplification of Phi nodes.\n/// Accept the set of all phi nodes and erase phi node from this set\n/// if it is simplified.\nclass SimplificationTracker {\n  DenseMap<Value *, Value *> Storage;\n  const SimplifyQuery &SQ;\n  // Tracks newly created Phi nodes. The elements are iterated by insertion\n  // order.\n  PhiNodeSet AllPhiNodes;\n  // Tracks newly created Select nodes.\n  SmallPtrSet<SelectInst *, 32> AllSelectNodes;\n\npublic:\n  SimplificationTracker(const SimplifyQuery &sq)\n      : SQ(sq) {}\n\n  Value *Get(Value *V) {\n    do {\n      auto SV = Storage.find(V);\n      if (SV == Storage.end())\n        return V;\n      V = SV->second;\n    } while (true);\n  }\n\n  Value *Simplify(Value *Val) {\n    SmallVector<Value *, 32> WorkList;\n    SmallPtrSet<Value *, 32> Visited;\n    WorkList.push_back(Val);\n    while (!WorkList.empty()) {\n      auto *P = WorkList.pop_back_val();\n      if (!Visited.insert(P).second)\n        continue;\n      if (auto *PI = dyn_cast<Instruction>(P))\n        if (Value *V = SimplifyInstruction(cast<Instruction>(PI), SQ)) {\n          for (auto *U : PI->users())\n            WorkList.push_back(cast<Value>(U));\n          Put(PI, V);\n          PI->replaceAllUsesWith(V);\n          if (auto *PHI = dyn_cast<PHINode>(PI))\n            AllPhiNodes.erase(PHI);\n          if (auto *Select = dyn_cast<SelectInst>(PI))\n            AllSelectNodes.erase(Select);\n          PI->eraseFromParent();\n        }\n    }\n    return Get(Val);\n  }\n\n  void Put(Value *From, Value *To) {\n    Storage.insert({ From, To });\n  }\n\n  void ReplacePhi(PHINode *From, PHINode *To) {\n    Value* OldReplacement = Get(From);\n    while (OldReplacement != From) {\n      From = To;\n      To = dyn_cast<PHINode>(OldReplacement);\n      OldReplacement = Get(From);\n    }\n    assert(To && Get(To) == To && \"Replacement PHI node is already replaced.\");\n    Put(From, To);\n    From->replaceAllUsesWith(To);\n    AllPhiNodes.erase(From);\n    From->eraseFromParent();\n  }\n\n  PhiNodeSet& newPhiNodes() { return AllPhiNodes; }\n\n  void insertNewPhi(PHINode *PN) { AllPhiNodes.insert(PN); }\n\n  void insertNewSelect(SelectInst *SI) { AllSelectNodes.insert(SI); }\n\n  unsigned countNewPhiNodes() const { return AllPhiNodes.size(); }\n\n  unsigned countNewSelectNodes() const { return AllSelectNodes.size(); }\n\n  void destroyNewNodes(Type *CommonType) {\n    // For safe erasing, replace the uses with dummy value first.\n    auto *Dummy = UndefValue::get(CommonType);\n    for (auto *I : AllPhiNodes) {\n      I->replaceAllUsesWith(Dummy);\n      I->eraseFromParent();\n    }\n    AllPhiNodes.clear();\n    for (auto *I : AllSelectNodes) {\n      I->replaceAllUsesWith(Dummy);\n      I->eraseFromParent();\n    }\n    AllSelectNodes.clear();\n  }\n};\n\n/// A helper class for combining addressing modes.\nclass AddressingModeCombiner {\n  typedef DenseMap<Value *, Value *> FoldAddrToValueMapping;\n  typedef std::pair<PHINode *, PHINode *> PHIPair;\n\nprivate:\n  /// The addressing modes we've collected.\n  SmallVector<ExtAddrMode, 16> AddrModes;\n\n  /// The field in which the AddrModes differ, when we have more than one.\n  ExtAddrMode::FieldName DifferentField = ExtAddrMode::NoField;\n\n  /// Are the AddrModes that we have all just equal to their original values?\n  bool AllAddrModesTrivial = true;\n\n  /// Common Type for all different fields in addressing modes.\n  Type *CommonType;\n\n  /// SimplifyQuery for simplifyInstruction utility.\n  const SimplifyQuery &SQ;\n\n  /// Original Address.\n  Value *Original;\n\npublic:\n  AddressingModeCombiner(const SimplifyQuery &_SQ, Value *OriginalValue)\n      : CommonType(nullptr), SQ(_SQ), Original(OriginalValue) {}\n\n  /// Get the combined AddrMode\n  const ExtAddrMode &getAddrMode() const {\n    return AddrModes[0];\n  }\n\n  /// Add a new AddrMode if it's compatible with the AddrModes we already\n  /// have.\n  /// \\return True iff we succeeded in doing so.\n  bool addNewAddrMode(ExtAddrMode &NewAddrMode) {\n    // Take note of if we have any non-trivial AddrModes, as we need to detect\n    // when all AddrModes are trivial as then we would introduce a phi or select\n    // which just duplicates what's already there.\n    AllAddrModesTrivial = AllAddrModesTrivial && NewAddrMode.isTrivial();\n\n    // If this is the first addrmode then everything is fine.\n    if (AddrModes.empty()) {\n      AddrModes.emplace_back(NewAddrMode);\n      return true;\n    }\n\n    // Figure out how different this is from the other address modes, which we\n    // can do just by comparing against the first one given that we only care\n    // about the cumulative difference.\n    ExtAddrMode::FieldName ThisDifferentField =\n      AddrModes[0].compare(NewAddrMode);\n    if (DifferentField == ExtAddrMode::NoField)\n      DifferentField = ThisDifferentField;\n    else if (DifferentField != ThisDifferentField)\n      DifferentField = ExtAddrMode::MultipleFields;\n\n    // If NewAddrMode differs in more than one dimension we cannot handle it.\n    bool CanHandle = DifferentField != ExtAddrMode::MultipleFields;\n\n    // If Scale Field is different then we reject.\n    CanHandle = CanHandle && DifferentField != ExtAddrMode::ScaleField;\n\n    // We also must reject the case when base offset is different and\n    // scale reg is not null, we cannot handle this case due to merge of\n    // different offsets will be used as ScaleReg.\n    CanHandle = CanHandle && (DifferentField != ExtAddrMode::BaseOffsField ||\n                              !NewAddrMode.ScaledReg);\n\n    // We also must reject the case when GV is different and BaseReg installed\n    // due to we want to use base reg as a merge of GV values.\n    CanHandle = CanHandle && (DifferentField != ExtAddrMode::BaseGVField ||\n                              !NewAddrMode.HasBaseReg);\n\n    // Even if NewAddMode is the same we still need to collect it due to\n    // original value is different. And later we will need all original values\n    // as anchors during finding the common Phi node.\n    if (CanHandle)\n      AddrModes.emplace_back(NewAddrMode);\n    else\n      AddrModes.clear();\n\n    return CanHandle;\n  }\n\n  /// Combine the addressing modes we've collected into a single\n  /// addressing mode.\n  /// \\return True iff we successfully combined them or we only had one so\n  /// didn't need to combine them anyway.\n  bool combineAddrModes() {\n    // If we have no AddrModes then they can't be combined.\n    if (AddrModes.size() == 0)\n      return false;\n\n    // A single AddrMode can trivially be combined.\n    if (AddrModes.size() == 1 || DifferentField == ExtAddrMode::NoField)\n      return true;\n\n    // If the AddrModes we collected are all just equal to the value they are\n    // derived from then combining them wouldn't do anything useful.\n    if (AllAddrModesTrivial)\n      return false;\n\n    if (!addrModeCombiningAllowed())\n      return false;\n\n    // Build a map between <original value, basic block where we saw it> to\n    // value of base register.\n    // Bail out if there is no common type.\n    FoldAddrToValueMapping Map;\n    if (!initializeMap(Map))\n      return false;\n\n    Value *CommonValue = findCommon(Map);\n    if (CommonValue)\n      AddrModes[0].SetCombinedField(DifferentField, CommonValue, AddrModes);\n    return CommonValue != nullptr;\n  }\n\nprivate:\n  /// Initialize Map with anchor values. For address seen\n  /// we set the value of different field saw in this address.\n  /// At the same time we find a common type for different field we will\n  /// use to create new Phi/Select nodes. Keep it in CommonType field.\n  /// Return false if there is no common type found.\n  bool initializeMap(FoldAddrToValueMapping &Map) {\n    // Keep track of keys where the value is null. We will need to replace it\n    // with constant null when we know the common type.\n    SmallVector<Value *, 2> NullValue;\n    Type *IntPtrTy = SQ.DL.getIntPtrType(AddrModes[0].OriginalValue->getType());\n    for (auto &AM : AddrModes) {\n      Value *DV = AM.GetFieldAsValue(DifferentField, IntPtrTy);\n      if (DV) {\n        auto *Type = DV->getType();\n        if (CommonType && CommonType != Type)\n          return false;\n        CommonType = Type;\n        Map[AM.OriginalValue] = DV;\n      } else {\n        NullValue.push_back(AM.OriginalValue);\n      }\n    }\n    assert(CommonType && \"At least one non-null value must be!\");\n    for (auto *V : NullValue)\n      Map[V] = Constant::getNullValue(CommonType);\n    return true;\n  }\n\n  /// We have mapping between value A and other value B where B was a field in\n  /// addressing mode represented by A. Also we have an original value C\n  /// representing an address we start with. Traversing from C through phi and\n  /// selects we ended up with A's in a map. This utility function tries to find\n  /// a value V which is a field in addressing mode C and traversing through phi\n  /// nodes and selects we will end up in corresponded values B in a map.\n  /// The utility will create a new Phi/Selects if needed.\n  // The simple example looks as follows:\n  // BB1:\n  //   p1 = b1 + 40\n  //   br cond BB2, BB3\n  // BB2:\n  //   p2 = b2 + 40\n  //   br BB3\n  // BB3:\n  //   p = phi [p1, BB1], [p2, BB2]\n  //   v = load p\n  // Map is\n  //   p1 -> b1\n  //   p2 -> b2\n  // Request is\n  //   p -> ?\n  // The function tries to find or build phi [b1, BB1], [b2, BB2] in BB3.\n  Value *findCommon(FoldAddrToValueMapping &Map) {\n    // Tracks the simplification of newly created phi nodes. The reason we use\n    // this mapping is because we will add new created Phi nodes in AddrToBase.\n    // Simplification of Phi nodes is recursive, so some Phi node may\n    // be simplified after we added it to AddrToBase. In reality this\n    // simplification is possible only if original phi/selects were not\n    // simplified yet.\n    // Using this mapping we can find the current value in AddrToBase.\n    SimplificationTracker ST(SQ);\n\n    // First step, DFS to create PHI nodes for all intermediate blocks.\n    // Also fill traverse order for the second step.\n    SmallVector<Value *, 32> TraverseOrder;\n    InsertPlaceholders(Map, TraverseOrder, ST);\n\n    // Second Step, fill new nodes by merged values and simplify if possible.\n    FillPlaceholders(Map, TraverseOrder, ST);\n\n    if (!AddrSinkNewSelects && ST.countNewSelectNodes() > 0) {\n      ST.destroyNewNodes(CommonType);\n      return nullptr;\n    }\n\n    // Now we'd like to match New Phi nodes to existed ones.\n    unsigned PhiNotMatchedCount = 0;\n    if (!MatchPhiSet(ST, AddrSinkNewPhis, PhiNotMatchedCount)) {\n      ST.destroyNewNodes(CommonType);\n      return nullptr;\n    }\n\n    auto *Result = ST.Get(Map.find(Original)->second);\n    if (Result) {\n      NumMemoryInstsPhiCreated += ST.countNewPhiNodes() + PhiNotMatchedCount;\n      NumMemoryInstsSelectCreated += ST.countNewSelectNodes();\n    }\n    return Result;\n  }\n\n  /// Try to match PHI node to Candidate.\n  /// Matcher tracks the matched Phi nodes.\n  bool MatchPhiNode(PHINode *PHI, PHINode *Candidate,\n                    SmallSetVector<PHIPair, 8> &Matcher,\n                    PhiNodeSet &PhiNodesToMatch) {\n    SmallVector<PHIPair, 8> WorkList;\n    Matcher.insert({ PHI, Candidate });\n    SmallSet<PHINode *, 8> MatchedPHIs;\n    MatchedPHIs.insert(PHI);\n    WorkList.push_back({ PHI, Candidate });\n    SmallSet<PHIPair, 8> Visited;\n    while (!WorkList.empty()) {\n      auto Item = WorkList.pop_back_val();\n      if (!Visited.insert(Item).second)\n        continue;\n      // We iterate over all incoming values to Phi to compare them.\n      // If values are different and both of them Phi and the first one is a\n      // Phi we added (subject to match) and both of them is in the same basic\n      // block then we can match our pair if values match. So we state that\n      // these values match and add it to work list to verify that.\n      for (auto B : Item.first->blocks()) {\n        Value *FirstValue = Item.first->getIncomingValueForBlock(B);\n        Value *SecondValue = Item.second->getIncomingValueForBlock(B);\n        if (FirstValue == SecondValue)\n          continue;\n\n        PHINode *FirstPhi = dyn_cast<PHINode>(FirstValue);\n        PHINode *SecondPhi = dyn_cast<PHINode>(SecondValue);\n\n        // One of them is not Phi or\n        // The first one is not Phi node from the set we'd like to match or\n        // Phi nodes from different basic blocks then\n        // we will not be able to match.\n        if (!FirstPhi || !SecondPhi || !PhiNodesToMatch.count(FirstPhi) ||\n            FirstPhi->getParent() != SecondPhi->getParent())\n          return false;\n\n        // If we already matched them then continue.\n        if (Matcher.count({ FirstPhi, SecondPhi }))\n          continue;\n        // So the values are different and does not match. So we need them to\n        // match. (But we register no more than one match per PHI node, so that\n        // we won't later try to replace them twice.)\n        if (MatchedPHIs.insert(FirstPhi).second)\n          Matcher.insert({ FirstPhi, SecondPhi });\n        // But me must check it.\n        WorkList.push_back({ FirstPhi, SecondPhi });\n      }\n    }\n    return true;\n  }\n\n  /// For the given set of PHI nodes (in the SimplificationTracker) try\n  /// to find their equivalents.\n  /// Returns false if this matching fails and creation of new Phi is disabled.\n  bool MatchPhiSet(SimplificationTracker &ST, bool AllowNewPhiNodes,\n                   unsigned &PhiNotMatchedCount) {\n    // Matched and PhiNodesToMatch iterate their elements in a deterministic\n    // order, so the replacements (ReplacePhi) are also done in a deterministic\n    // order.\n    SmallSetVector<PHIPair, 8> Matched;\n    SmallPtrSet<PHINode *, 8> WillNotMatch;\n    PhiNodeSet &PhiNodesToMatch = ST.newPhiNodes();\n    while (PhiNodesToMatch.size()) {\n      PHINode *PHI = *PhiNodesToMatch.begin();\n\n      // Add us, if no Phi nodes in the basic block we do not match.\n      WillNotMatch.clear();\n      WillNotMatch.insert(PHI);\n\n      // Traverse all Phis until we found equivalent or fail to do that.\n      bool IsMatched = false;\n      for (auto &P : PHI->getParent()->phis()) {\n        if (&P == PHI)\n          continue;\n        if ((IsMatched = MatchPhiNode(PHI, &P, Matched, PhiNodesToMatch)))\n          break;\n        // If it does not match, collect all Phi nodes from matcher.\n        // if we end up with no match, them all these Phi nodes will not match\n        // later.\n        for (auto M : Matched)\n          WillNotMatch.insert(M.first);\n        Matched.clear();\n      }\n      if (IsMatched) {\n        // Replace all matched values and erase them.\n        for (auto MV : Matched)\n          ST.ReplacePhi(MV.first, MV.second);\n        Matched.clear();\n        continue;\n      }\n      // If we are not allowed to create new nodes then bail out.\n      if (!AllowNewPhiNodes)\n        return false;\n      // Just remove all seen values in matcher. They will not match anything.\n      PhiNotMatchedCount += WillNotMatch.size();\n      for (auto *P : WillNotMatch)\n        PhiNodesToMatch.erase(P);\n    }\n    return true;\n  }\n  /// Fill the placeholders with values from predecessors and simplify them.\n  void FillPlaceholders(FoldAddrToValueMapping &Map,\n                        SmallVectorImpl<Value *> &TraverseOrder,\n                        SimplificationTracker &ST) {\n    while (!TraverseOrder.empty()) {\n      Value *Current = TraverseOrder.pop_back_val();\n      assert(Map.find(Current) != Map.end() && \"No node to fill!!!\");\n      Value *V = Map[Current];\n\n      if (SelectInst *Select = dyn_cast<SelectInst>(V)) {\n        // CurrentValue also must be Select.\n        auto *CurrentSelect = cast<SelectInst>(Current);\n        auto *TrueValue = CurrentSelect->getTrueValue();\n        assert(Map.find(TrueValue) != Map.end() && \"No True Value!\");\n        Select->setTrueValue(ST.Get(Map[TrueValue]));\n        auto *FalseValue = CurrentSelect->getFalseValue();\n        assert(Map.find(FalseValue) != Map.end() && \"No False Value!\");\n        Select->setFalseValue(ST.Get(Map[FalseValue]));\n      } else {\n        // Must be a Phi node then.\n        auto *PHI = cast<PHINode>(V);\n        // Fill the Phi node with values from predecessors.\n        for (auto *B : predecessors(PHI->getParent())) {\n          Value *PV = cast<PHINode>(Current)->getIncomingValueForBlock(B);\n          assert(Map.find(PV) != Map.end() && \"No predecessor Value!\");\n          PHI->addIncoming(ST.Get(Map[PV]), B);\n        }\n      }\n      Map[Current] = ST.Simplify(V);\n    }\n  }\n\n  /// Starting from original value recursively iterates over def-use chain up to\n  /// known ending values represented in a map. For each traversed phi/select\n  /// inserts a placeholder Phi or Select.\n  /// Reports all new created Phi/Select nodes by adding them to set.\n  /// Also reports and order in what values have been traversed.\n  void InsertPlaceholders(FoldAddrToValueMapping &Map,\n                          SmallVectorImpl<Value *> &TraverseOrder,\n                          SimplificationTracker &ST) {\n    SmallVector<Value *, 32> Worklist;\n    assert((isa<PHINode>(Original) || isa<SelectInst>(Original)) &&\n           \"Address must be a Phi or Select node\");\n    auto *Dummy = UndefValue::get(CommonType);\n    Worklist.push_back(Original);\n    while (!Worklist.empty()) {\n      Value *Current = Worklist.pop_back_val();\n      // if it is already visited or it is an ending value then skip it.\n      if (Map.find(Current) != Map.end())\n        continue;\n      TraverseOrder.push_back(Current);\n\n      // CurrentValue must be a Phi node or select. All others must be covered\n      // by anchors.\n      if (SelectInst *CurrentSelect = dyn_cast<SelectInst>(Current)) {\n        // Is it OK to get metadata from OrigSelect?!\n        // Create a Select placeholder with dummy value.\n        SelectInst *Select = SelectInst::Create(\n            CurrentSelect->getCondition(), Dummy, Dummy,\n            CurrentSelect->getName(), CurrentSelect, CurrentSelect);\n        Map[Current] = Select;\n        ST.insertNewSelect(Select);\n        // We are interested in True and False values.\n        Worklist.push_back(CurrentSelect->getTrueValue());\n        Worklist.push_back(CurrentSelect->getFalseValue());\n      } else {\n        // It must be a Phi node then.\n        PHINode *CurrentPhi = cast<PHINode>(Current);\n        unsigned PredCount = CurrentPhi->getNumIncomingValues();\n        PHINode *PHI =\n            PHINode::Create(CommonType, PredCount, \"sunk_phi\", CurrentPhi);\n        Map[Current] = PHI;\n        ST.insertNewPhi(PHI);\n        append_range(Worklist, CurrentPhi->incoming_values());\n      }\n    }\n  }\n\n  bool addrModeCombiningAllowed() {\n    if (DisableComplexAddrModes)\n      return false;\n    switch (DifferentField) {\n    default:\n      return false;\n    case ExtAddrMode::BaseRegField:\n      return AddrSinkCombineBaseReg;\n    case ExtAddrMode::BaseGVField:\n      return AddrSinkCombineBaseGV;\n    case ExtAddrMode::BaseOffsField:\n      return AddrSinkCombineBaseOffs;\n    case ExtAddrMode::ScaledRegField:\n      return AddrSinkCombineScaledReg;\n    }\n  }\n};\n} // end anonymous namespace\n\n/// Try adding ScaleReg*Scale to the current addressing mode.\n/// Return true and update AddrMode if this addr mode is legal for the target,\n/// false if not.\nbool AddressingModeMatcher::matchScaledValue(Value *ScaleReg, int64_t Scale,\n                                             unsigned Depth) {\n  // If Scale is 1, then this is the same as adding ScaleReg to the addressing\n  // mode.  Just process that directly.\n  if (Scale == 1)\n    return matchAddr(ScaleReg, Depth);\n\n  // If the scale is 0, it takes nothing to add this.\n  if (Scale == 0)\n    return true;\n\n  // If we already have a scale of this value, we can add to it, otherwise, we\n  // need an available scale field.\n  if (AddrMode.Scale != 0 && AddrMode.ScaledReg != ScaleReg)\n    return false;\n\n  ExtAddrMode TestAddrMode = AddrMode;\n\n  // Add scale to turn X*4+X*3 -> X*7.  This could also do things like\n  // [A+B + A*7] -> [B+A*8].\n  TestAddrMode.Scale += Scale;\n  TestAddrMode.ScaledReg = ScaleReg;\n\n  // If the new address isn't legal, bail out.\n  if (!TLI.isLegalAddressingMode(DL, TestAddrMode, AccessTy, AddrSpace))\n    return false;\n\n  // It was legal, so commit it.\n  AddrMode = TestAddrMode;\n\n  // Okay, we decided that we can add ScaleReg+Scale to AddrMode.  Check now\n  // to see if ScaleReg is actually X+C.  If so, we can turn this into adding\n  // X*Scale + C*Scale to addr mode. If we found available IV increment, do not\n  // go any further: we can reuse it and cannot eliminate it.\n  ConstantInt *CI = nullptr; Value *AddLHS = nullptr;\n  if (isa<Instruction>(ScaleReg) && // not a constant expr.\n      match(ScaleReg, m_Add(m_Value(AddLHS), m_ConstantInt(CI))) &&\n      !isIVIncrement(ScaleReg, &LI) && CI->getValue().isSignedIntN(64)) {\n    TestAddrMode.InBounds = false;\n    TestAddrMode.ScaledReg = AddLHS;\n    TestAddrMode.BaseOffs += CI->getSExtValue() * TestAddrMode.Scale;\n\n    // If this addressing mode is legal, commit it and remember that we folded\n    // this instruction.\n    if (TLI.isLegalAddressingMode(DL, TestAddrMode, AccessTy, AddrSpace)) {\n      AddrModeInsts.push_back(cast<Instruction>(ScaleReg));\n      AddrMode = TestAddrMode;\n      return true;\n    }\n    // Restore status quo.\n    TestAddrMode = AddrMode;\n  }\n\n  // If this is an add recurrence with a constant step, return the increment\n  // instruction and the canonicalized step.\n  auto GetConstantStep = [this](const Value * V)\n      ->Optional<std::pair<Instruction *, APInt> > {\n    auto *PN = dyn_cast<PHINode>(V);\n    if (!PN)\n      return None;\n    auto IVInc = getIVIncrement(PN, &LI);\n    if (!IVInc)\n      return None;\n    // TODO: The result of the intrinsics above is two-compliment. However when\n    // IV inc is expressed as add or sub, iv.next is potentially a poison value.\n    // If it has nuw or nsw flags, we need to make sure that these flags are\n    // inferrable at the point of memory instruction. Otherwise we are replacing\n    // well-defined two-compliment computation with poison. Currently, to avoid\n    // potentially complex analysis needed to prove this, we reject such cases.\n    if (auto *OIVInc = dyn_cast<OverflowingBinaryOperator>(IVInc->first))\n      if (OIVInc->hasNoSignedWrap() || OIVInc->hasNoUnsignedWrap())\n        return None;\n    if (auto *ConstantStep = dyn_cast<ConstantInt>(IVInc->second))\n      return std::make_pair(IVInc->first, ConstantStep->getValue());\n    return None;\n  };\n\n  // Try to account for the following special case:\n  // 1. ScaleReg is an inductive variable;\n  // 2. We use it with non-zero offset;\n  // 3. IV's increment is available at the point of memory instruction.\n  //\n  // In this case, we may reuse the IV increment instead of the IV Phi to\n  // achieve the following advantages:\n  // 1. If IV step matches the offset, we will have no need in the offset;\n  // 2. Even if they don't match, we will reduce the overlap of living IV\n  //    and IV increment, that will potentially lead to better register\n  //    assignment.\n  if (AddrMode.BaseOffs) {\n    if (auto IVStep = GetConstantStep(ScaleReg)) {\n      Instruction *IVInc = IVStep->first;\n      // The following assert is important to ensure a lack of infinite loops.\n      // This transforms is (intentionally) the inverse of the one just above.\n      // If they don't agree on the definition of an increment, we'd alternate\n      // back and forth indefinitely.\n      assert(isIVIncrement(IVInc, &LI) && \"implied by GetConstantStep\");\n      APInt Step = IVStep->second;\n      APInt Offset = Step * AddrMode.Scale;\n      if (Offset.isSignedIntN(64)) {\n        TestAddrMode.InBounds = false;\n        TestAddrMode.ScaledReg = IVInc;\n        TestAddrMode.BaseOffs -= Offset.getLimitedValue();\n        // If this addressing mode is legal, commit it..\n        // (Note that we defer the (expensive) domtree base legality check\n        // to the very last possible point.)\n        if (TLI.isLegalAddressingMode(DL, TestAddrMode, AccessTy, AddrSpace) &&\n            getDTFn().dominates(IVInc, MemoryInst)) {\n          AddrModeInsts.push_back(cast<Instruction>(IVInc));\n          AddrMode = TestAddrMode;\n          return true;\n        }\n        // Restore status quo.\n        TestAddrMode = AddrMode;\n      }\n    }\n  }\n\n  // Otherwise, just return what we have.\n  return true;\n}\n\n/// This is a little filter, which returns true if an addressing computation\n/// involving I might be folded into a load/store accessing it.\n/// This doesn't need to be perfect, but needs to accept at least\n/// the set of instructions that MatchOperationAddr can.\nstatic bool MightBeFoldableInst(Instruction *I) {\n  switch (I->getOpcode()) {\n  case Instruction::BitCast:\n  case Instruction::AddrSpaceCast:\n    // Don't touch identity bitcasts.\n    if (I->getType() == I->getOperand(0)->getType())\n      return false;\n    return I->getType()->isIntOrPtrTy();\n  case Instruction::PtrToInt:\n    // PtrToInt is always a noop, as we know that the int type is pointer sized.\n    return true;\n  case Instruction::IntToPtr:\n    // We know the input is intptr_t, so this is foldable.\n    return true;\n  case Instruction::Add:\n    return true;\n  case Instruction::Mul:\n  case Instruction::Shl:\n    // Can only handle X*C and X << C.\n    return isa<ConstantInt>(I->getOperand(1));\n  case Instruction::GetElementPtr:\n    return true;\n  default:\n    return false;\n  }\n}\n\n/// Check whether or not \\p Val is a legal instruction for \\p TLI.\n/// \\note \\p Val is assumed to be the product of some type promotion.\n/// Therefore if \\p Val has an undefined state in \\p TLI, this is assumed\n/// to be legal, as the non-promoted value would have had the same state.\nstatic bool isPromotedInstructionLegal(const TargetLowering &TLI,\n                                       const DataLayout &DL, Value *Val) {\n  Instruction *PromotedInst = dyn_cast<Instruction>(Val);\n  if (!PromotedInst)\n    return false;\n  int ISDOpcode = TLI.InstructionOpcodeToISD(PromotedInst->getOpcode());\n  // If the ISDOpcode is undefined, it was undefined before the promotion.\n  if (!ISDOpcode)\n    return true;\n  // Otherwise, check if the promoted instruction is legal or not.\n  return TLI.isOperationLegalOrCustom(\n      ISDOpcode, TLI.getValueType(DL, PromotedInst->getType()));\n}\n\nnamespace {\n\n/// Hepler class to perform type promotion.\nclass TypePromotionHelper {\n  /// Utility function to add a promoted instruction \\p ExtOpnd to\n  /// \\p PromotedInsts and record the type of extension we have seen.\n  static void addPromotedInst(InstrToOrigTy &PromotedInsts,\n                              Instruction *ExtOpnd,\n                              bool IsSExt) {\n    ExtType ExtTy = IsSExt ? SignExtension : ZeroExtension;\n    InstrToOrigTy::iterator It = PromotedInsts.find(ExtOpnd);\n    if (It != PromotedInsts.end()) {\n      // If the new extension is same as original, the information in\n      // PromotedInsts[ExtOpnd] is still correct.\n      if (It->second.getInt() == ExtTy)\n        return;\n\n      // Now the new extension is different from old extension, we make\n      // the type information invalid by setting extension type to\n      // BothExtension.\n      ExtTy = BothExtension;\n    }\n    PromotedInsts[ExtOpnd] = TypeIsSExt(ExtOpnd->getType(), ExtTy);\n  }\n\n  /// Utility function to query the original type of instruction \\p Opnd\n  /// with a matched extension type. If the extension doesn't match, we\n  /// cannot use the information we had on the original type.\n  /// BothExtension doesn't match any extension type.\n  static const Type *getOrigType(const InstrToOrigTy &PromotedInsts,\n                                 Instruction *Opnd,\n                                 bool IsSExt) {\n    ExtType ExtTy = IsSExt ? SignExtension : ZeroExtension;\n    InstrToOrigTy::const_iterator It = PromotedInsts.find(Opnd);\n    if (It != PromotedInsts.end() && It->second.getInt() == ExtTy)\n      return It->second.getPointer();\n    return nullptr;\n  }\n\n  /// Utility function to check whether or not a sign or zero extension\n  /// of \\p Inst with \\p ConsideredExtType can be moved through \\p Inst by\n  /// either using the operands of \\p Inst or promoting \\p Inst.\n  /// The type of the extension is defined by \\p IsSExt.\n  /// In other words, check if:\n  /// ext (Ty Inst opnd1 opnd2 ... opndN) to ConsideredExtType.\n  /// #1 Promotion applies:\n  /// ConsideredExtType Inst (ext opnd1 to ConsideredExtType, ...).\n  /// #2 Operand reuses:\n  /// ext opnd1 to ConsideredExtType.\n  /// \\p PromotedInsts maps the instructions to their type before promotion.\n  static bool canGetThrough(const Instruction *Inst, Type *ConsideredExtType,\n                            const InstrToOrigTy &PromotedInsts, bool IsSExt);\n\n  /// Utility function to determine if \\p OpIdx should be promoted when\n  /// promoting \\p Inst.\n  static bool shouldExtOperand(const Instruction *Inst, int OpIdx) {\n    return !(isa<SelectInst>(Inst) && OpIdx == 0);\n  }\n\n  /// Utility function to promote the operand of \\p Ext when this\n  /// operand is a promotable trunc or sext or zext.\n  /// \\p PromotedInsts maps the instructions to their type before promotion.\n  /// \\p CreatedInstsCost[out] contains the cost of all instructions\n  /// created to promote the operand of Ext.\n  /// Newly added extensions are inserted in \\p Exts.\n  /// Newly added truncates are inserted in \\p Truncs.\n  /// Should never be called directly.\n  /// \\return The promoted value which is used instead of Ext.\n  static Value *promoteOperandForTruncAndAnyExt(\n      Instruction *Ext, TypePromotionTransaction &TPT,\n      InstrToOrigTy &PromotedInsts, unsigned &CreatedInstsCost,\n      SmallVectorImpl<Instruction *> *Exts,\n      SmallVectorImpl<Instruction *> *Truncs, const TargetLowering &TLI);\n\n  /// Utility function to promote the operand of \\p Ext when this\n  /// operand is promotable and is not a supported trunc or sext.\n  /// \\p PromotedInsts maps the instructions to their type before promotion.\n  /// \\p CreatedInstsCost[out] contains the cost of all the instructions\n  /// created to promote the operand of Ext.\n  /// Newly added extensions are inserted in \\p Exts.\n  /// Newly added truncates are inserted in \\p Truncs.\n  /// Should never be called directly.\n  /// \\return The promoted value which is used instead of Ext.\n  static Value *promoteOperandForOther(Instruction *Ext,\n                                       TypePromotionTransaction &TPT,\n                                       InstrToOrigTy &PromotedInsts,\n                                       unsigned &CreatedInstsCost,\n                                       SmallVectorImpl<Instruction *> *Exts,\n                                       SmallVectorImpl<Instruction *> *Truncs,\n                                       const TargetLowering &TLI, bool IsSExt);\n\n  /// \\see promoteOperandForOther.\n  static Value *signExtendOperandForOther(\n      Instruction *Ext, TypePromotionTransaction &TPT,\n      InstrToOrigTy &PromotedInsts, unsigned &CreatedInstsCost,\n      SmallVectorImpl<Instruction *> *Exts,\n      SmallVectorImpl<Instruction *> *Truncs, const TargetLowering &TLI) {\n    return promoteOperandForOther(Ext, TPT, PromotedInsts, CreatedInstsCost,\n                                  Exts, Truncs, TLI, true);\n  }\n\n  /// \\see promoteOperandForOther.\n  static Value *zeroExtendOperandForOther(\n      Instruction *Ext, TypePromotionTransaction &TPT,\n      InstrToOrigTy &PromotedInsts, unsigned &CreatedInstsCost,\n      SmallVectorImpl<Instruction *> *Exts,\n      SmallVectorImpl<Instruction *> *Truncs, const TargetLowering &TLI) {\n    return promoteOperandForOther(Ext, TPT, PromotedInsts, CreatedInstsCost,\n                                  Exts, Truncs, TLI, false);\n  }\n\npublic:\n  /// Type for the utility function that promotes the operand of Ext.\n  using Action = Value *(*)(Instruction *Ext, TypePromotionTransaction &TPT,\n                            InstrToOrigTy &PromotedInsts,\n                            unsigned &CreatedInstsCost,\n                            SmallVectorImpl<Instruction *> *Exts,\n                            SmallVectorImpl<Instruction *> *Truncs,\n                            const TargetLowering &TLI);\n\n  /// Given a sign/zero extend instruction \\p Ext, return the appropriate\n  /// action to promote the operand of \\p Ext instead of using Ext.\n  /// \\return NULL if no promotable action is possible with the current\n  /// sign extension.\n  /// \\p InsertedInsts keeps track of all the instructions inserted by the\n  /// other CodeGenPrepare optimizations. This information is important\n  /// because we do not want to promote these instructions as CodeGenPrepare\n  /// will reinsert them later. Thus creating an infinite loop: create/remove.\n  /// \\p PromotedInsts maps the instructions to their type before promotion.\n  static Action getAction(Instruction *Ext, const SetOfInstrs &InsertedInsts,\n                          const TargetLowering &TLI,\n                          const InstrToOrigTy &PromotedInsts);\n};\n\n} // end anonymous namespace\n\nbool TypePromotionHelper::canGetThrough(const Instruction *Inst,\n                                        Type *ConsideredExtType,\n                                        const InstrToOrigTy &PromotedInsts,\n                                        bool IsSExt) {\n  // The promotion helper does not know how to deal with vector types yet.\n  // To be able to fix that, we would need to fix the places where we\n  // statically extend, e.g., constants and such.\n  if (Inst->getType()->isVectorTy())\n    return false;\n\n  // We can always get through zext.\n  if (isa<ZExtInst>(Inst))\n    return true;\n\n  // sext(sext) is ok too.\n  if (IsSExt && isa<SExtInst>(Inst))\n    return true;\n\n  // We can get through binary operator, if it is legal. In other words, the\n  // binary operator must have a nuw or nsw flag.\n  const BinaryOperator *BinOp = dyn_cast<BinaryOperator>(Inst);\n  if (isa_and_nonnull<OverflowingBinaryOperator>(BinOp) &&\n      ((!IsSExt && BinOp->hasNoUnsignedWrap()) ||\n       (IsSExt && BinOp->hasNoSignedWrap())))\n    return true;\n\n  // ext(and(opnd, cst)) --> and(ext(opnd), ext(cst))\n  if ((Inst->getOpcode() == Instruction::And ||\n       Inst->getOpcode() == Instruction::Or))\n    return true;\n\n  // ext(xor(opnd, cst)) --> xor(ext(opnd), ext(cst))\n  if (Inst->getOpcode() == Instruction::Xor) {\n    const ConstantInt *Cst = dyn_cast<ConstantInt>(Inst->getOperand(1));\n    // Make sure it is not a NOT.\n    if (Cst && !Cst->getValue().isAllOnesValue())\n      return true;\n  }\n\n  // zext(shrl(opnd, cst)) --> shrl(zext(opnd), zext(cst))\n  // It may change a poisoned value into a regular value, like\n  //     zext i32 (shrl i8 %val, 12)  -->  shrl i32 (zext i8 %val), 12\n  //          poisoned value                    regular value\n  // It should be OK since undef covers valid value.\n  if (Inst->getOpcode() == Instruction::LShr && !IsSExt)\n    return true;\n\n  // and(ext(shl(opnd, cst)), cst) --> and(shl(ext(opnd), ext(cst)), cst)\n  // It may change a poisoned value into a regular value, like\n  //     zext i32 (shl i8 %val, 12)  -->  shl i32 (zext i8 %val), 12\n  //          poisoned value                    regular value\n  // It should be OK since undef covers valid value.\n  if (Inst->getOpcode() == Instruction::Shl && Inst->hasOneUse()) {\n    const auto *ExtInst = cast<const Instruction>(*Inst->user_begin());\n    if (ExtInst->hasOneUse()) {\n      const auto *AndInst = dyn_cast<const Instruction>(*ExtInst->user_begin());\n      if (AndInst && AndInst->getOpcode() == Instruction::And) {\n        const auto *Cst = dyn_cast<ConstantInt>(AndInst->getOperand(1));\n        if (Cst &&\n            Cst->getValue().isIntN(Inst->getType()->getIntegerBitWidth()))\n          return true;\n      }\n    }\n  }\n\n  // Check if we can do the following simplification.\n  // ext(trunc(opnd)) --> ext(opnd)\n  if (!isa<TruncInst>(Inst))\n    return false;\n\n  Value *OpndVal = Inst->getOperand(0);\n  // Check if we can use this operand in the extension.\n  // If the type is larger than the result type of the extension, we cannot.\n  if (!OpndVal->getType()->isIntegerTy() ||\n      OpndVal->getType()->getIntegerBitWidth() >\n          ConsideredExtType->getIntegerBitWidth())\n    return false;\n\n  // If the operand of the truncate is not an instruction, we will not have\n  // any information on the dropped bits.\n  // (Actually we could for constant but it is not worth the extra logic).\n  Instruction *Opnd = dyn_cast<Instruction>(OpndVal);\n  if (!Opnd)\n    return false;\n\n  // Check if the source of the type is narrow enough.\n  // I.e., check that trunc just drops extended bits of the same kind of\n  // the extension.\n  // #1 get the type of the operand and check the kind of the extended bits.\n  const Type *OpndType = getOrigType(PromotedInsts, Opnd, IsSExt);\n  if (OpndType)\n    ;\n  else if ((IsSExt && isa<SExtInst>(Opnd)) || (!IsSExt && isa<ZExtInst>(Opnd)))\n    OpndType = Opnd->getOperand(0)->getType();\n  else\n    return false;\n\n  // #2 check that the truncate just drops extended bits.\n  return Inst->getType()->getIntegerBitWidth() >=\n         OpndType->getIntegerBitWidth();\n}\n\nTypePromotionHelper::Action TypePromotionHelper::getAction(\n    Instruction *Ext, const SetOfInstrs &InsertedInsts,\n    const TargetLowering &TLI, const InstrToOrigTy &PromotedInsts) {\n  assert((isa<SExtInst>(Ext) || isa<ZExtInst>(Ext)) &&\n         \"Unexpected instruction type\");\n  Instruction *ExtOpnd = dyn_cast<Instruction>(Ext->getOperand(0));\n  Type *ExtTy = Ext->getType();\n  bool IsSExt = isa<SExtInst>(Ext);\n  // If the operand of the extension is not an instruction, we cannot\n  // get through.\n  // If it, check we can get through.\n  if (!ExtOpnd || !canGetThrough(ExtOpnd, ExtTy, PromotedInsts, IsSExt))\n    return nullptr;\n\n  // Do not promote if the operand has been added by codegenprepare.\n  // Otherwise, it means we are undoing an optimization that is likely to be\n  // redone, thus causing potential infinite loop.\n  if (isa<TruncInst>(ExtOpnd) && InsertedInsts.count(ExtOpnd))\n    return nullptr;\n\n  // SExt or Trunc instructions.\n  // Return the related handler.\n  if (isa<SExtInst>(ExtOpnd) || isa<TruncInst>(ExtOpnd) ||\n      isa<ZExtInst>(ExtOpnd))\n    return promoteOperandForTruncAndAnyExt;\n\n  // Regular instruction.\n  // Abort early if we will have to insert non-free instructions.\n  if (!ExtOpnd->hasOneUse() && !TLI.isTruncateFree(ExtTy, ExtOpnd->getType()))\n    return nullptr;\n  return IsSExt ? signExtendOperandForOther : zeroExtendOperandForOther;\n}\n\nValue *TypePromotionHelper::promoteOperandForTruncAndAnyExt(\n    Instruction *SExt, TypePromotionTransaction &TPT,\n    InstrToOrigTy &PromotedInsts, unsigned &CreatedInstsCost,\n    SmallVectorImpl<Instruction *> *Exts,\n    SmallVectorImpl<Instruction *> *Truncs, const TargetLowering &TLI) {\n  // By construction, the operand of SExt is an instruction. Otherwise we cannot\n  // get through it and this method should not be called.\n  Instruction *SExtOpnd = cast<Instruction>(SExt->getOperand(0));\n  Value *ExtVal = SExt;\n  bool HasMergedNonFreeExt = false;\n  if (isa<ZExtInst>(SExtOpnd)) {\n    // Replace s|zext(zext(opnd))\n    // => zext(opnd).\n    HasMergedNonFreeExt = !TLI.isExtFree(SExtOpnd);\n    Value *ZExt =\n        TPT.createZExt(SExt, SExtOpnd->getOperand(0), SExt->getType());\n    TPT.replaceAllUsesWith(SExt, ZExt);\n    TPT.eraseInstruction(SExt);\n    ExtVal = ZExt;\n  } else {\n    // Replace z|sext(trunc(opnd)) or sext(sext(opnd))\n    // => z|sext(opnd).\n    TPT.setOperand(SExt, 0, SExtOpnd->getOperand(0));\n  }\n  CreatedInstsCost = 0;\n\n  // Remove dead code.\n  if (SExtOpnd->use_empty())\n    TPT.eraseInstruction(SExtOpnd);\n\n  // Check if the extension is still needed.\n  Instruction *ExtInst = dyn_cast<Instruction>(ExtVal);\n  if (!ExtInst || ExtInst->getType() != ExtInst->getOperand(0)->getType()) {\n    if (ExtInst) {\n      if (Exts)\n        Exts->push_back(ExtInst);\n      CreatedInstsCost = !TLI.isExtFree(ExtInst) && !HasMergedNonFreeExt;\n    }\n    return ExtVal;\n  }\n\n  // At this point we have: ext ty opnd to ty.\n  // Reassign the uses of ExtInst to the opnd and remove ExtInst.\n  Value *NextVal = ExtInst->getOperand(0);\n  TPT.eraseInstruction(ExtInst, NextVal);\n  return NextVal;\n}\n\nValue *TypePromotionHelper::promoteOperandForOther(\n    Instruction *Ext, TypePromotionTransaction &TPT,\n    InstrToOrigTy &PromotedInsts, unsigned &CreatedInstsCost,\n    SmallVectorImpl<Instruction *> *Exts,\n    SmallVectorImpl<Instruction *> *Truncs, const TargetLowering &TLI,\n    bool IsSExt) {\n  // By construction, the operand of Ext is an instruction. Otherwise we cannot\n  // get through it and this method should not be called.\n  Instruction *ExtOpnd = cast<Instruction>(Ext->getOperand(0));\n  CreatedInstsCost = 0;\n  if (!ExtOpnd->hasOneUse()) {\n    // ExtOpnd will be promoted.\n    // All its uses, but Ext, will need to use a truncated value of the\n    // promoted version.\n    // Create the truncate now.\n    Value *Trunc = TPT.createTrunc(Ext, ExtOpnd->getType());\n    if (Instruction *ITrunc = dyn_cast<Instruction>(Trunc)) {\n      // Insert it just after the definition.\n      ITrunc->moveAfter(ExtOpnd);\n      if (Truncs)\n        Truncs->push_back(ITrunc);\n    }\n\n    TPT.replaceAllUsesWith(ExtOpnd, Trunc);\n    // Restore the operand of Ext (which has been replaced by the previous call\n    // to replaceAllUsesWith) to avoid creating a cycle trunc <-> sext.\n    TPT.setOperand(Ext, 0, ExtOpnd);\n  }\n\n  // Get through the Instruction:\n  // 1. Update its type.\n  // 2. Replace the uses of Ext by Inst.\n  // 3. Extend each operand that needs to be extended.\n\n  // Remember the original type of the instruction before promotion.\n  // This is useful to know that the high bits are sign extended bits.\n  addPromotedInst(PromotedInsts, ExtOpnd, IsSExt);\n  // Step #1.\n  TPT.mutateType(ExtOpnd, Ext->getType());\n  // Step #2.\n  TPT.replaceAllUsesWith(Ext, ExtOpnd);\n  // Step #3.\n  Instruction *ExtForOpnd = Ext;\n\n  LLVM_DEBUG(dbgs() << \"Propagate Ext to operands\\n\");\n  for (int OpIdx = 0, EndOpIdx = ExtOpnd->getNumOperands(); OpIdx != EndOpIdx;\n       ++OpIdx) {\n    LLVM_DEBUG(dbgs() << \"Operand:\\n\" << *(ExtOpnd->getOperand(OpIdx)) << '\\n');\n    if (ExtOpnd->getOperand(OpIdx)->getType() == Ext->getType() ||\n        !shouldExtOperand(ExtOpnd, OpIdx)) {\n      LLVM_DEBUG(dbgs() << \"No need to propagate\\n\");\n      continue;\n    }\n    // Check if we can statically extend the operand.\n    Value *Opnd = ExtOpnd->getOperand(OpIdx);\n    if (const ConstantInt *Cst = dyn_cast<ConstantInt>(Opnd)) {\n      LLVM_DEBUG(dbgs() << \"Statically extend\\n\");\n      unsigned BitWidth = Ext->getType()->getIntegerBitWidth();\n      APInt CstVal = IsSExt ? Cst->getValue().sext(BitWidth)\n                            : Cst->getValue().zext(BitWidth);\n      TPT.setOperand(ExtOpnd, OpIdx, ConstantInt::get(Ext->getType(), CstVal));\n      continue;\n    }\n    // UndefValue are typed, so we have to statically sign extend them.\n    if (isa<UndefValue>(Opnd)) {\n      LLVM_DEBUG(dbgs() << \"Statically extend\\n\");\n      TPT.setOperand(ExtOpnd, OpIdx, UndefValue::get(Ext->getType()));\n      continue;\n    }\n\n    // Otherwise we have to explicitly sign extend the operand.\n    // Check if Ext was reused to extend an operand.\n    if (!ExtForOpnd) {\n      // If yes, create a new one.\n      LLVM_DEBUG(dbgs() << \"More operands to ext\\n\");\n      Value *ValForExtOpnd = IsSExt ? TPT.createSExt(Ext, Opnd, Ext->getType())\n        : TPT.createZExt(Ext, Opnd, Ext->getType());\n      if (!isa<Instruction>(ValForExtOpnd)) {\n        TPT.setOperand(ExtOpnd, OpIdx, ValForExtOpnd);\n        continue;\n      }\n      ExtForOpnd = cast<Instruction>(ValForExtOpnd);\n    }\n    if (Exts)\n      Exts->push_back(ExtForOpnd);\n    TPT.setOperand(ExtForOpnd, 0, Opnd);\n\n    // Move the sign extension before the insertion point.\n    TPT.moveBefore(ExtForOpnd, ExtOpnd);\n    TPT.setOperand(ExtOpnd, OpIdx, ExtForOpnd);\n    CreatedInstsCost += !TLI.isExtFree(ExtForOpnd);\n    // If more sext are required, new instructions will have to be created.\n    ExtForOpnd = nullptr;\n  }\n  if (ExtForOpnd == Ext) {\n    LLVM_DEBUG(dbgs() << \"Extension is useless now\\n\");\n    TPT.eraseInstruction(Ext);\n  }\n  return ExtOpnd;\n}\n\n/// Check whether or not promoting an instruction to a wider type is profitable.\n/// \\p NewCost gives the cost of extension instructions created by the\n/// promotion.\n/// \\p OldCost gives the cost of extension instructions before the promotion\n/// plus the number of instructions that have been\n/// matched in the addressing mode the promotion.\n/// \\p PromotedOperand is the value that has been promoted.\n/// \\return True if the promotion is profitable, false otherwise.\nbool AddressingModeMatcher::isPromotionProfitable(\n    unsigned NewCost, unsigned OldCost, Value *PromotedOperand) const {\n  LLVM_DEBUG(dbgs() << \"OldCost: \" << OldCost << \"\\tNewCost: \" << NewCost\n                    << '\\n');\n  // The cost of the new extensions is greater than the cost of the\n  // old extension plus what we folded.\n  // This is not profitable.\n  if (NewCost > OldCost)\n    return false;\n  if (NewCost < OldCost)\n    return true;\n  // The promotion is neutral but it may help folding the sign extension in\n  // loads for instance.\n  // Check that we did not create an illegal instruction.\n  return isPromotedInstructionLegal(TLI, DL, PromotedOperand);\n}\n\n/// Given an instruction or constant expr, see if we can fold the operation\n/// into the addressing mode. If so, update the addressing mode and return\n/// true, otherwise return false without modifying AddrMode.\n/// If \\p MovedAway is not NULL, it contains the information of whether or\n/// not AddrInst has to be folded into the addressing mode on success.\n/// If \\p MovedAway == true, \\p AddrInst will not be part of the addressing\n/// because it has been moved away.\n/// Thus AddrInst must not be added in the matched instructions.\n/// This state can happen when AddrInst is a sext, since it may be moved away.\n/// Therefore, AddrInst may not be valid when MovedAway is true and it must\n/// not be referenced anymore.\nbool AddressingModeMatcher::matchOperationAddr(User *AddrInst, unsigned Opcode,\n                                               unsigned Depth,\n                                               bool *MovedAway) {\n  // Avoid exponential behavior on extremely deep expression trees.\n  if (Depth >= 5) return false;\n\n  // By default, all matched instructions stay in place.\n  if (MovedAway)\n    *MovedAway = false;\n\n  switch (Opcode) {\n  case Instruction::PtrToInt:\n    // PtrToInt is always a noop, as we know that the int type is pointer sized.\n    return matchAddr(AddrInst->getOperand(0), Depth);\n  case Instruction::IntToPtr: {\n    auto AS = AddrInst->getType()->getPointerAddressSpace();\n    auto PtrTy = MVT::getIntegerVT(DL.getPointerSizeInBits(AS));\n    // This inttoptr is a no-op if the integer type is pointer sized.\n    if (TLI.getValueType(DL, AddrInst->getOperand(0)->getType()) == PtrTy)\n      return matchAddr(AddrInst->getOperand(0), Depth);\n    return false;\n  }\n  case Instruction::BitCast:\n    // BitCast is always a noop, and we can handle it as long as it is\n    // int->int or pointer->pointer (we don't want int<->fp or something).\n    if (AddrInst->getOperand(0)->getType()->isIntOrPtrTy() &&\n        // Don't touch identity bitcasts.  These were probably put here by LSR,\n        // and we don't want to mess around with them.  Assume it knows what it\n        // is doing.\n        AddrInst->getOperand(0)->getType() != AddrInst->getType())\n      return matchAddr(AddrInst->getOperand(0), Depth);\n    return false;\n  case Instruction::AddrSpaceCast: {\n    unsigned SrcAS\n      = AddrInst->getOperand(0)->getType()->getPointerAddressSpace();\n    unsigned DestAS = AddrInst->getType()->getPointerAddressSpace();\n    if (TLI.getTargetMachine().isNoopAddrSpaceCast(SrcAS, DestAS))\n      return matchAddr(AddrInst->getOperand(0), Depth);\n    return false;\n  }\n  case Instruction::Add: {\n    // Check to see if we can merge in the RHS then the LHS.  If so, we win.\n    ExtAddrMode BackupAddrMode = AddrMode;\n    unsigned OldSize = AddrModeInsts.size();\n    // Start a transaction at this point.\n    // The LHS may match but not the RHS.\n    // Therefore, we need a higher level restoration point to undo partially\n    // matched operation.\n    TypePromotionTransaction::ConstRestorationPt LastKnownGood =\n        TPT.getRestorationPoint();\n\n    AddrMode.InBounds = false;\n    if (matchAddr(AddrInst->getOperand(1), Depth+1) &&\n        matchAddr(AddrInst->getOperand(0), Depth+1))\n      return true;\n\n    // Restore the old addr mode info.\n    AddrMode = BackupAddrMode;\n    AddrModeInsts.resize(OldSize);\n    TPT.rollback(LastKnownGood);\n\n    // Otherwise this was over-aggressive.  Try merging in the LHS then the RHS.\n    if (matchAddr(AddrInst->getOperand(0), Depth+1) &&\n        matchAddr(AddrInst->getOperand(1), Depth+1))\n      return true;\n\n    // Otherwise we definitely can't merge the ADD in.\n    AddrMode = BackupAddrMode;\n    AddrModeInsts.resize(OldSize);\n    TPT.rollback(LastKnownGood);\n    break;\n  }\n  //case Instruction::Or:\n  // TODO: We can handle \"Or Val, Imm\" iff this OR is equivalent to an ADD.\n  //break;\n  case Instruction::Mul:\n  case Instruction::Shl: {\n    // Can only handle X*C and X << C.\n    AddrMode.InBounds = false;\n    ConstantInt *RHS = dyn_cast<ConstantInt>(AddrInst->getOperand(1));\n    if (!RHS || RHS->getBitWidth() > 64)\n      return false;\n    int64_t Scale = RHS->getSExtValue();\n    if (Opcode == Instruction::Shl)\n      Scale = 1LL << Scale;\n\n    return matchScaledValue(AddrInst->getOperand(0), Scale, Depth);\n  }\n  case Instruction::GetElementPtr: {\n    // Scan the GEP.  We check it if it contains constant offsets and at most\n    // one variable offset.\n    int VariableOperand = -1;\n    unsigned VariableScale = 0;\n\n    int64_t ConstantOffset = 0;\n    gep_type_iterator GTI = gep_type_begin(AddrInst);\n    for (unsigned i = 1, e = AddrInst->getNumOperands(); i != e; ++i, ++GTI) {\n      if (StructType *STy = GTI.getStructTypeOrNull()) {\n        const StructLayout *SL = DL.getStructLayout(STy);\n        unsigned Idx =\n          cast<ConstantInt>(AddrInst->getOperand(i))->getZExtValue();\n        ConstantOffset += SL->getElementOffset(Idx);\n      } else {\n        TypeSize TS = DL.getTypeAllocSize(GTI.getIndexedType());\n        if (TS.isNonZero()) {\n          // The optimisations below currently only work for fixed offsets.\n          if (TS.isScalable())\n            return false;\n          int64_t TypeSize = TS.getFixedSize();\n          if (ConstantInt *CI =\n                  dyn_cast<ConstantInt>(AddrInst->getOperand(i))) {\n            const APInt &CVal = CI->getValue();\n            if (CVal.getMinSignedBits() <= 64) {\n              ConstantOffset += CVal.getSExtValue() * TypeSize;\n              continue;\n            }\n          }\n          // We only allow one variable index at the moment.\n          if (VariableOperand != -1)\n            return false;\n\n          // Remember the variable index.\n          VariableOperand = i;\n          VariableScale = TypeSize;\n        }\n      }\n    }\n\n    // A common case is for the GEP to only do a constant offset.  In this case,\n    // just add it to the disp field and check validity.\n    if (VariableOperand == -1) {\n      AddrMode.BaseOffs += ConstantOffset;\n      if (ConstantOffset == 0 ||\n          TLI.isLegalAddressingMode(DL, AddrMode, AccessTy, AddrSpace)) {\n        // Check to see if we can fold the base pointer in too.\n        if (matchAddr(AddrInst->getOperand(0), Depth+1)) {\n          if (!cast<GEPOperator>(AddrInst)->isInBounds())\n            AddrMode.InBounds = false;\n          return true;\n        }\n      } else if (EnableGEPOffsetSplit && isa<GetElementPtrInst>(AddrInst) &&\n                 TLI.shouldConsiderGEPOffsetSplit() && Depth == 0 &&\n                 ConstantOffset > 0) {\n        // Record GEPs with non-zero offsets as candidates for splitting in the\n        // event that the offset cannot fit into the r+i addressing mode.\n        // Simple and common case that only one GEP is used in calculating the\n        // address for the memory access.\n        Value *Base = AddrInst->getOperand(0);\n        auto *BaseI = dyn_cast<Instruction>(Base);\n        auto *GEP = cast<GetElementPtrInst>(AddrInst);\n        if (isa<Argument>(Base) || isa<GlobalValue>(Base) ||\n            (BaseI && !isa<CastInst>(BaseI) &&\n             !isa<GetElementPtrInst>(BaseI))) {\n          // Make sure the parent block allows inserting non-PHI instructions\n          // before the terminator.\n          BasicBlock *Parent =\n              BaseI ? BaseI->getParent() : &GEP->getFunction()->getEntryBlock();\n          if (!Parent->getTerminator()->isEHPad())\n            LargeOffsetGEP = std::make_pair(GEP, ConstantOffset);\n        }\n      }\n      AddrMode.BaseOffs -= ConstantOffset;\n      return false;\n    }\n\n    // Save the valid addressing mode in case we can't match.\n    ExtAddrMode BackupAddrMode = AddrMode;\n    unsigned OldSize = AddrModeInsts.size();\n\n    // See if the scale and offset amount is valid for this target.\n    AddrMode.BaseOffs += ConstantOffset;\n    if (!cast<GEPOperator>(AddrInst)->isInBounds())\n      AddrMode.InBounds = false;\n\n    // Match the base operand of the GEP.\n    if (!matchAddr(AddrInst->getOperand(0), Depth+1)) {\n      // If it couldn't be matched, just stuff the value in a register.\n      if (AddrMode.HasBaseReg) {\n        AddrMode = BackupAddrMode;\n        AddrModeInsts.resize(OldSize);\n        return false;\n      }\n      AddrMode.HasBaseReg = true;\n      AddrMode.BaseReg = AddrInst->getOperand(0);\n    }\n\n    // Match the remaining variable portion of the GEP.\n    if (!matchScaledValue(AddrInst->getOperand(VariableOperand), VariableScale,\n                          Depth)) {\n      // If it couldn't be matched, try stuffing the base into a register\n      // instead of matching it, and retrying the match of the scale.\n      AddrMode = BackupAddrMode;\n      AddrModeInsts.resize(OldSize);\n      if (AddrMode.HasBaseReg)\n        return false;\n      AddrMode.HasBaseReg = true;\n      AddrMode.BaseReg = AddrInst->getOperand(0);\n      AddrMode.BaseOffs += ConstantOffset;\n      if (!matchScaledValue(AddrInst->getOperand(VariableOperand),\n                            VariableScale, Depth)) {\n        // If even that didn't work, bail.\n        AddrMode = BackupAddrMode;\n        AddrModeInsts.resize(OldSize);\n        return false;\n      }\n    }\n\n    return true;\n  }\n  case Instruction::SExt:\n  case Instruction::ZExt: {\n    Instruction *Ext = dyn_cast<Instruction>(AddrInst);\n    if (!Ext)\n      return false;\n\n    // Try to move this ext out of the way of the addressing mode.\n    // Ask for a method for doing so.\n    TypePromotionHelper::Action TPH =\n        TypePromotionHelper::getAction(Ext, InsertedInsts, TLI, PromotedInsts);\n    if (!TPH)\n      return false;\n\n    TypePromotionTransaction::ConstRestorationPt LastKnownGood =\n        TPT.getRestorationPoint();\n    unsigned CreatedInstsCost = 0;\n    unsigned ExtCost = !TLI.isExtFree(Ext);\n    Value *PromotedOperand =\n        TPH(Ext, TPT, PromotedInsts, CreatedInstsCost, nullptr, nullptr, TLI);\n    // SExt has been moved away.\n    // Thus either it will be rematched later in the recursive calls or it is\n    // gone. Anyway, we must not fold it into the addressing mode at this point.\n    // E.g.,\n    // op = add opnd, 1\n    // idx = ext op\n    // addr = gep base, idx\n    // is now:\n    // promotedOpnd = ext opnd            <- no match here\n    // op = promoted_add promotedOpnd, 1  <- match (later in recursive calls)\n    // addr = gep base, op                <- match\n    if (MovedAway)\n      *MovedAway = true;\n\n    assert(PromotedOperand &&\n           \"TypePromotionHelper should have filtered out those cases\");\n\n    ExtAddrMode BackupAddrMode = AddrMode;\n    unsigned OldSize = AddrModeInsts.size();\n\n    if (!matchAddr(PromotedOperand, Depth) ||\n        // The total of the new cost is equal to the cost of the created\n        // instructions.\n        // The total of the old cost is equal to the cost of the extension plus\n        // what we have saved in the addressing mode.\n        !isPromotionProfitable(CreatedInstsCost,\n                               ExtCost + (AddrModeInsts.size() - OldSize),\n                               PromotedOperand)) {\n      AddrMode = BackupAddrMode;\n      AddrModeInsts.resize(OldSize);\n      LLVM_DEBUG(dbgs() << \"Sign extension does not pay off: rollback\\n\");\n      TPT.rollback(LastKnownGood);\n      return false;\n    }\n    return true;\n  }\n  }\n  return false;\n}\n\n/// If we can, try to add the value of 'Addr' into the current addressing mode.\n/// If Addr can't be added to AddrMode this returns false and leaves AddrMode\n/// unmodified. This assumes that Addr is either a pointer type or intptr_t\n/// for the target.\n///\nbool AddressingModeMatcher::matchAddr(Value *Addr, unsigned Depth) {\n  // Start a transaction at this point that we will rollback if the matching\n  // fails.\n  TypePromotionTransaction::ConstRestorationPt LastKnownGood =\n      TPT.getRestorationPoint();\n  if (ConstantInt *CI = dyn_cast<ConstantInt>(Addr)) {\n    if (CI->getValue().isSignedIntN(64)) {\n      // Fold in immediates if legal for the target.\n      AddrMode.BaseOffs += CI->getSExtValue();\n      if (TLI.isLegalAddressingMode(DL, AddrMode, AccessTy, AddrSpace))\n        return true;\n      AddrMode.BaseOffs -= CI->getSExtValue();\n    }\n  } else if (GlobalValue *GV = dyn_cast<GlobalValue>(Addr)) {\n    // If this is a global variable, try to fold it into the addressing mode.\n    if (!AddrMode.BaseGV) {\n      AddrMode.BaseGV = GV;\n      if (TLI.isLegalAddressingMode(DL, AddrMode, AccessTy, AddrSpace))\n        return true;\n      AddrMode.BaseGV = nullptr;\n    }\n  } else if (Instruction *I = dyn_cast<Instruction>(Addr)) {\n    ExtAddrMode BackupAddrMode = AddrMode;\n    unsigned OldSize = AddrModeInsts.size();\n\n    // Check to see if it is possible to fold this operation.\n    bool MovedAway = false;\n    if (matchOperationAddr(I, I->getOpcode(), Depth, &MovedAway)) {\n      // This instruction may have been moved away. If so, there is nothing\n      // to check here.\n      if (MovedAway)\n        return true;\n      // Okay, it's possible to fold this.  Check to see if it is actually\n      // *profitable* to do so.  We use a simple cost model to avoid increasing\n      // register pressure too much.\n      if (I->hasOneUse() ||\n          isProfitableToFoldIntoAddressingMode(I, BackupAddrMode, AddrMode)) {\n        AddrModeInsts.push_back(I);\n        return true;\n      }\n\n      // It isn't profitable to do this, roll back.\n      //cerr << \"NOT FOLDING: \" << *I;\n      AddrMode = BackupAddrMode;\n      AddrModeInsts.resize(OldSize);\n      TPT.rollback(LastKnownGood);\n    }\n  } else if (ConstantExpr *CE = dyn_cast<ConstantExpr>(Addr)) {\n    if (matchOperationAddr(CE, CE->getOpcode(), Depth))\n      return true;\n    TPT.rollback(LastKnownGood);\n  } else if (isa<ConstantPointerNull>(Addr)) {\n    // Null pointer gets folded without affecting the addressing mode.\n    return true;\n  }\n\n  // Worse case, the target should support [reg] addressing modes. :)\n  if (!AddrMode.HasBaseReg) {\n    AddrMode.HasBaseReg = true;\n    AddrMode.BaseReg = Addr;\n    // Still check for legality in case the target supports [imm] but not [i+r].\n    if (TLI.isLegalAddressingMode(DL, AddrMode, AccessTy, AddrSpace))\n      return true;\n    AddrMode.HasBaseReg = false;\n    AddrMode.BaseReg = nullptr;\n  }\n\n  // If the base register is already taken, see if we can do [r+r].\n  if (AddrMode.Scale == 0) {\n    AddrMode.Scale = 1;\n    AddrMode.ScaledReg = Addr;\n    if (TLI.isLegalAddressingMode(DL, AddrMode, AccessTy, AddrSpace))\n      return true;\n    AddrMode.Scale = 0;\n    AddrMode.ScaledReg = nullptr;\n  }\n  // Couldn't match.\n  TPT.rollback(LastKnownGood);\n  return false;\n}\n\n/// Check to see if all uses of OpVal by the specified inline asm call are due\n/// to memory operands. If so, return true, otherwise return false.\nstatic bool IsOperandAMemoryOperand(CallInst *CI, InlineAsm *IA, Value *OpVal,\n                                    const TargetLowering &TLI,\n                                    const TargetRegisterInfo &TRI) {\n  const Function *F = CI->getFunction();\n  TargetLowering::AsmOperandInfoVector TargetConstraints =\n      TLI.ParseConstraints(F->getParent()->getDataLayout(), &TRI, *CI);\n\n  for (unsigned i = 0, e = TargetConstraints.size(); i != e; ++i) {\n    TargetLowering::AsmOperandInfo &OpInfo = TargetConstraints[i];\n\n    // Compute the constraint code and ConstraintType to use.\n    TLI.ComputeConstraintToUse(OpInfo, SDValue());\n\n    // If this asm operand is our Value*, and if it isn't an indirect memory\n    // operand, we can't fold it!\n    if (OpInfo.CallOperandVal == OpVal &&\n        (OpInfo.ConstraintType != TargetLowering::C_Memory ||\n         !OpInfo.isIndirect))\n      return false;\n  }\n\n  return true;\n}\n\n// Max number of memory uses to look at before aborting the search to conserve\n// compile time.\nstatic constexpr int MaxMemoryUsesToScan = 20;\n\n/// Recursively walk all the uses of I until we find a memory use.\n/// If we find an obviously non-foldable instruction, return true.\n/// Add the ultimately found memory instructions to MemoryUses.\nstatic bool FindAllMemoryUses(\n    Instruction *I,\n    SmallVectorImpl<std::pair<Instruction *, unsigned>> &MemoryUses,\n    SmallPtrSetImpl<Instruction *> &ConsideredInsts, const TargetLowering &TLI,\n    const TargetRegisterInfo &TRI, bool OptSize, ProfileSummaryInfo *PSI,\n    BlockFrequencyInfo *BFI, int SeenInsts = 0) {\n  // If we already considered this instruction, we're done.\n  if (!ConsideredInsts.insert(I).second)\n    return false;\n\n  // If this is an obviously unfoldable instruction, bail out.\n  if (!MightBeFoldableInst(I))\n    return true;\n\n  // Loop over all the uses, recursively processing them.\n  for (Use &U : I->uses()) {\n    // Conservatively return true if we're seeing a large number or a deep chain\n    // of users. This avoids excessive compilation times in pathological cases.\n    if (SeenInsts++ >= MaxMemoryUsesToScan)\n      return true;\n\n    Instruction *UserI = cast<Instruction>(U.getUser());\n    if (LoadInst *LI = dyn_cast<LoadInst>(UserI)) {\n      MemoryUses.push_back(std::make_pair(LI, U.getOperandNo()));\n      continue;\n    }\n\n    if (StoreInst *SI = dyn_cast<StoreInst>(UserI)) {\n      unsigned opNo = U.getOperandNo();\n      if (opNo != StoreInst::getPointerOperandIndex())\n        return true; // Storing addr, not into addr.\n      MemoryUses.push_back(std::make_pair(SI, opNo));\n      continue;\n    }\n\n    if (AtomicRMWInst *RMW = dyn_cast<AtomicRMWInst>(UserI)) {\n      unsigned opNo = U.getOperandNo();\n      if (opNo != AtomicRMWInst::getPointerOperandIndex())\n        return true; // Storing addr, not into addr.\n      MemoryUses.push_back(std::make_pair(RMW, opNo));\n      continue;\n    }\n\n    if (AtomicCmpXchgInst *CmpX = dyn_cast<AtomicCmpXchgInst>(UserI)) {\n      unsigned opNo = U.getOperandNo();\n      if (opNo != AtomicCmpXchgInst::getPointerOperandIndex())\n        return true; // Storing addr, not into addr.\n      MemoryUses.push_back(std::make_pair(CmpX, opNo));\n      continue;\n    }\n\n    if (CallInst *CI = dyn_cast<CallInst>(UserI)) {\n      if (CI->hasFnAttr(Attribute::Cold)) {\n        // If this is a cold call, we can sink the addressing calculation into\n        // the cold path.  See optimizeCallInst\n        bool OptForSize = OptSize ||\n          llvm::shouldOptimizeForSize(CI->getParent(), PSI, BFI);\n        if (!OptForSize)\n          continue;\n      }\n\n      InlineAsm *IA = dyn_cast<InlineAsm>(CI->getCalledOperand());\n      if (!IA) return true;\n\n      // If this is a memory operand, we're cool, otherwise bail out.\n      if (!IsOperandAMemoryOperand(CI, IA, I, TLI, TRI))\n        return true;\n      continue;\n    }\n\n    if (FindAllMemoryUses(UserI, MemoryUses, ConsideredInsts, TLI, TRI, OptSize,\n                          PSI, BFI, SeenInsts))\n      return true;\n  }\n\n  return false;\n}\n\n/// Return true if Val is already known to be live at the use site that we're\n/// folding it into. If so, there is no cost to include it in the addressing\n/// mode. KnownLive1 and KnownLive2 are two values that we know are live at the\n/// instruction already.\nbool AddressingModeMatcher::valueAlreadyLiveAtInst(Value *Val,Value *KnownLive1,\n                                                   Value *KnownLive2) {\n  // If Val is either of the known-live values, we know it is live!\n  if (Val == nullptr || Val == KnownLive1 || Val == KnownLive2)\n    return true;\n\n  // All values other than instructions and arguments (e.g. constants) are live.\n  if (!isa<Instruction>(Val) && !isa<Argument>(Val)) return true;\n\n  // If Val is a constant sized alloca in the entry block, it is live, this is\n  // true because it is just a reference to the stack/frame pointer, which is\n  // live for the whole function.\n  if (AllocaInst *AI = dyn_cast<AllocaInst>(Val))\n    if (AI->isStaticAlloca())\n      return true;\n\n  // Check to see if this value is already used in the memory instruction's\n  // block.  If so, it's already live into the block at the very least, so we\n  // can reasonably fold it.\n  return Val->isUsedInBasicBlock(MemoryInst->getParent());\n}\n\n/// It is possible for the addressing mode of the machine to fold the specified\n/// instruction into a load or store that ultimately uses it.\n/// However, the specified instruction has multiple uses.\n/// Given this, it may actually increase register pressure to fold it\n/// into the load. For example, consider this code:\n///\n///     X = ...\n///     Y = X+1\n///     use(Y)   -> nonload/store\n///     Z = Y+1\n///     load Z\n///\n/// In this case, Y has multiple uses, and can be folded into the load of Z\n/// (yielding load [X+2]).  However, doing this will cause both \"X\" and \"X+1\" to\n/// be live at the use(Y) line.  If we don't fold Y into load Z, we use one\n/// fewer register.  Since Y can't be folded into \"use(Y)\" we don't increase the\n/// number of computations either.\n///\n/// Note that this (like most of CodeGenPrepare) is just a rough heuristic.  If\n/// X was live across 'load Z' for other reasons, we actually *would* want to\n/// fold the addressing mode in the Z case.  This would make Y die earlier.\nbool AddressingModeMatcher::\nisProfitableToFoldIntoAddressingMode(Instruction *I, ExtAddrMode &AMBefore,\n                                     ExtAddrMode &AMAfter) {\n  if (IgnoreProfitability) return true;\n\n  // AMBefore is the addressing mode before this instruction was folded into it,\n  // and AMAfter is the addressing mode after the instruction was folded.  Get\n  // the set of registers referenced by AMAfter and subtract out those\n  // referenced by AMBefore: this is the set of values which folding in this\n  // address extends the lifetime of.\n  //\n  // Note that there are only two potential values being referenced here,\n  // BaseReg and ScaleReg (global addresses are always available, as are any\n  // folded immediates).\n  Value *BaseReg = AMAfter.BaseReg, *ScaledReg = AMAfter.ScaledReg;\n\n  // If the BaseReg or ScaledReg was referenced by the previous addrmode, their\n  // lifetime wasn't extended by adding this instruction.\n  if (valueAlreadyLiveAtInst(BaseReg, AMBefore.BaseReg, AMBefore.ScaledReg))\n    BaseReg = nullptr;\n  if (valueAlreadyLiveAtInst(ScaledReg, AMBefore.BaseReg, AMBefore.ScaledReg))\n    ScaledReg = nullptr;\n\n  // If folding this instruction (and it's subexprs) didn't extend any live\n  // ranges, we're ok with it.\n  if (!BaseReg && !ScaledReg)\n    return true;\n\n  // If all uses of this instruction can have the address mode sunk into them,\n  // we can remove the addressing mode and effectively trade one live register\n  // for another (at worst.)  In this context, folding an addressing mode into\n  // the use is just a particularly nice way of sinking it.\n  SmallVector<std::pair<Instruction*,unsigned>, 16> MemoryUses;\n  SmallPtrSet<Instruction*, 16> ConsideredInsts;\n  if (FindAllMemoryUses(I, MemoryUses, ConsideredInsts, TLI, TRI, OptSize,\n                        PSI, BFI))\n    return false;  // Has a non-memory, non-foldable use!\n\n  // Now that we know that all uses of this instruction are part of a chain of\n  // computation involving only operations that could theoretically be folded\n  // into a memory use, loop over each of these memory operation uses and see\n  // if they could  *actually* fold the instruction.  The assumption is that\n  // addressing modes are cheap and that duplicating the computation involved\n  // many times is worthwhile, even on a fastpath. For sinking candidates\n  // (i.e. cold call sites), this serves as a way to prevent excessive code\n  // growth since most architectures have some reasonable small and fast way to\n  // compute an effective address.  (i.e LEA on x86)\n  SmallVector<Instruction*, 32> MatchedAddrModeInsts;\n  for (unsigned i = 0, e = MemoryUses.size(); i != e; ++i) {\n    Instruction *User = MemoryUses[i].first;\n    unsigned OpNo = MemoryUses[i].second;\n\n    // Get the access type of this use.  If the use isn't a pointer, we don't\n    // know what it accesses.\n    Value *Address = User->getOperand(OpNo);\n    PointerType *AddrTy = dyn_cast<PointerType>(Address->getType());\n    if (!AddrTy)\n      return false;\n    Type *AddressAccessTy = AddrTy->getElementType();\n    unsigned AS = AddrTy->getAddressSpace();\n\n    // Do a match against the root of this address, ignoring profitability. This\n    // will tell us if the addressing mode for the memory operation will\n    // *actually* cover the shared instruction.\n    ExtAddrMode Result;\n    std::pair<AssertingVH<GetElementPtrInst>, int64_t> LargeOffsetGEP(nullptr,\n                                                                      0);\n    TypePromotionTransaction::ConstRestorationPt LastKnownGood =\n        TPT.getRestorationPoint();\n    AddressingModeMatcher Matcher(MatchedAddrModeInsts, TLI, TRI, LI, getDTFn,\n                                  AddressAccessTy, AS, MemoryInst, Result,\n                                  InsertedInsts, PromotedInsts, TPT,\n                                  LargeOffsetGEP, OptSize, PSI, BFI);\n    Matcher.IgnoreProfitability = true;\n    bool Success = Matcher.matchAddr(Address, 0);\n    (void)Success; assert(Success && \"Couldn't select *anything*?\");\n\n    // The match was to check the profitability, the changes made are not\n    // part of the original matcher. Therefore, they should be dropped\n    // otherwise the original matcher will not present the right state.\n    TPT.rollback(LastKnownGood);\n\n    // If the match didn't cover I, then it won't be shared by it.\n    if (!is_contained(MatchedAddrModeInsts, I))\n      return false;\n\n    MatchedAddrModeInsts.clear();\n  }\n\n  return true;\n}\n\n/// Return true if the specified values are defined in a\n/// different basic block than BB.\nstatic bool IsNonLocalValue(Value *V, BasicBlock *BB) {\n  if (Instruction *I = dyn_cast<Instruction>(V))\n    return I->getParent() != BB;\n  return false;\n}\n\n/// Sink addressing mode computation immediate before MemoryInst if doing so\n/// can be done without increasing register pressure.  The need for the\n/// register pressure constraint means this can end up being an all or nothing\n/// decision for all uses of the same addressing computation.\n///\n/// Load and Store Instructions often have addressing modes that can do\n/// significant amounts of computation. As such, instruction selection will try\n/// to get the load or store to do as much computation as possible for the\n/// program. The problem is that isel can only see within a single block. As\n/// such, we sink as much legal addressing mode work into the block as possible.\n///\n/// This method is used to optimize both load/store and inline asms with memory\n/// operands.  It's also used to sink addressing computations feeding into cold\n/// call sites into their (cold) basic block.\n///\n/// The motivation for handling sinking into cold blocks is that doing so can\n/// both enable other address mode sinking (by satisfying the register pressure\n/// constraint above), and reduce register pressure globally (by removing the\n/// addressing mode computation from the fast path entirely.).\nbool CodeGenPrepare::optimizeMemoryInst(Instruction *MemoryInst, Value *Addr,\n                                        Type *AccessTy, unsigned AddrSpace) {\n  Value *Repl = Addr;\n\n  // Try to collapse single-value PHI nodes.  This is necessary to undo\n  // unprofitable PRE transformations.\n  SmallVector<Value*, 8> worklist;\n  SmallPtrSet<Value*, 16> Visited;\n  worklist.push_back(Addr);\n\n  // Use a worklist to iteratively look through PHI and select nodes, and\n  // ensure that the addressing mode obtained from the non-PHI/select roots of\n  // the graph are compatible.\n  bool PhiOrSelectSeen = false;\n  SmallVector<Instruction*, 16> AddrModeInsts;\n  const SimplifyQuery SQ(*DL, TLInfo);\n  AddressingModeCombiner AddrModes(SQ, Addr);\n  TypePromotionTransaction TPT(RemovedInsts);\n  TypePromotionTransaction::ConstRestorationPt LastKnownGood =\n      TPT.getRestorationPoint();\n  while (!worklist.empty()) {\n    Value *V = worklist.back();\n    worklist.pop_back();\n\n    // We allow traversing cyclic Phi nodes.\n    // In case of success after this loop we ensure that traversing through\n    // Phi nodes ends up with all cases to compute address of the form\n    //    BaseGV + Base + Scale * Index + Offset\n    // where Scale and Offset are constans and BaseGV, Base and Index\n    // are exactly the same Values in all cases.\n    // It means that BaseGV, Scale and Offset dominate our memory instruction\n    // and have the same value as they had in address computation represented\n    // as Phi. So we can safely sink address computation to memory instruction.\n    if (!Visited.insert(V).second)\n      continue;\n\n    // For a PHI node, push all of its incoming values.\n    if (PHINode *P = dyn_cast<PHINode>(V)) {\n      append_range(worklist, P->incoming_values());\n      PhiOrSelectSeen = true;\n      continue;\n    }\n    // Similar for select.\n    if (SelectInst *SI = dyn_cast<SelectInst>(V)) {\n      worklist.push_back(SI->getFalseValue());\n      worklist.push_back(SI->getTrueValue());\n      PhiOrSelectSeen = true;\n      continue;\n    }\n\n    // For non-PHIs, determine the addressing mode being computed.  Note that\n    // the result may differ depending on what other uses our candidate\n    // addressing instructions might have.\n    AddrModeInsts.clear();\n    std::pair<AssertingVH<GetElementPtrInst>, int64_t> LargeOffsetGEP(nullptr,\n                                                                      0);\n    // Defer the query (and possible computation of) the dom tree to point of\n    // actual use.  It's expected that most address matches don't actually need\n    // the domtree.\n    auto getDTFn = [MemoryInst, this]() -> const DominatorTree & {\n      Function *F = MemoryInst->getParent()->getParent();\n      return this->getDT(*F);\n    };\n    ExtAddrMode NewAddrMode = AddressingModeMatcher::Match(\n        V, AccessTy, AddrSpace, MemoryInst, AddrModeInsts, *TLI, *LI, getDTFn,\n        *TRI, InsertedInsts, PromotedInsts, TPT, LargeOffsetGEP, OptSize, PSI,\n        BFI.get());\n\n    GetElementPtrInst *GEP = LargeOffsetGEP.first;\n    if (GEP && !NewGEPBases.count(GEP)) {\n      // If splitting the underlying data structure can reduce the offset of a\n      // GEP, collect the GEP.  Skip the GEPs that are the new bases of\n      // previously split data structures.\n      LargeOffsetGEPMap[GEP->getPointerOperand()].push_back(LargeOffsetGEP);\n      if (LargeOffsetGEPID.find(GEP) == LargeOffsetGEPID.end())\n        LargeOffsetGEPID[GEP] = LargeOffsetGEPID.size();\n    }\n\n    NewAddrMode.OriginalValue = V;\n    if (!AddrModes.addNewAddrMode(NewAddrMode))\n      break;\n  }\n\n  // Try to combine the AddrModes we've collected. If we couldn't collect any,\n  // or we have multiple but either couldn't combine them or combining them\n  // wouldn't do anything useful, bail out now.\n  if (!AddrModes.combineAddrModes()) {\n    TPT.rollback(LastKnownGood);\n    return false;\n  }\n  bool Modified = TPT.commit();\n\n  // Get the combined AddrMode (or the only AddrMode, if we only had one).\n  ExtAddrMode AddrMode = AddrModes.getAddrMode();\n\n  // If all the instructions matched are already in this BB, don't do anything.\n  // If we saw a Phi node then it is not local definitely, and if we saw a select\n  // then we want to push the address calculation past it even if it's already\n  // in this BB.\n  if (!PhiOrSelectSeen && none_of(AddrModeInsts, [&](Value *V) {\n        return IsNonLocalValue(V, MemoryInst->getParent());\n                  })) {\n    LLVM_DEBUG(dbgs() << \"CGP: Found      local addrmode: \" << AddrMode\n                      << \"\\n\");\n    return Modified;\n  }\n\n  // Insert this computation right after this user.  Since our caller is\n  // scanning from the top of the BB to the bottom, reuse of the expr are\n  // guaranteed to happen later.\n  IRBuilder<> Builder(MemoryInst);\n\n  // Now that we determined the addressing expression we want to use and know\n  // that we have to sink it into this block.  Check to see if we have already\n  // done this for some other load/store instr in this block.  If so, reuse\n  // the computation.  Before attempting reuse, check if the address is valid\n  // as it may have been erased.\n\n  WeakTrackingVH SunkAddrVH = SunkAddrs[Addr];\n\n  Value * SunkAddr = SunkAddrVH.pointsToAliveValue() ? SunkAddrVH : nullptr;\n  if (SunkAddr) {\n    LLVM_DEBUG(dbgs() << \"CGP: Reusing nonlocal addrmode: \" << AddrMode\n                      << \" for \" << *MemoryInst << \"\\n\");\n    if (SunkAddr->getType() != Addr->getType())\n      SunkAddr = Builder.CreatePointerCast(SunkAddr, Addr->getType());\n  } else if (AddrSinkUsingGEPs || (!AddrSinkUsingGEPs.getNumOccurrences() &&\n                                   SubtargetInfo->addrSinkUsingGEPs())) {\n    // By default, we use the GEP-based method when AA is used later. This\n    // prevents new inttoptr/ptrtoint pairs from degrading AA capabilities.\n    LLVM_DEBUG(dbgs() << \"CGP: SINKING nonlocal addrmode: \" << AddrMode\n                      << \" for \" << *MemoryInst << \"\\n\");\n    Type *IntPtrTy = DL->getIntPtrType(Addr->getType());\n    Value *ResultPtr = nullptr, *ResultIndex = nullptr;\n\n    // First, find the pointer.\n    if (AddrMode.BaseReg && AddrMode.BaseReg->getType()->isPointerTy()) {\n      ResultPtr = AddrMode.BaseReg;\n      AddrMode.BaseReg = nullptr;\n    }\n\n    if (AddrMode.Scale && AddrMode.ScaledReg->getType()->isPointerTy()) {\n      // We can't add more than one pointer together, nor can we scale a\n      // pointer (both of which seem meaningless).\n      if (ResultPtr || AddrMode.Scale != 1)\n        return Modified;\n\n      ResultPtr = AddrMode.ScaledReg;\n      AddrMode.Scale = 0;\n    }\n\n    // It is only safe to sign extend the BaseReg if we know that the math\n    // required to create it did not overflow before we extend it. Since\n    // the original IR value was tossed in favor of a constant back when\n    // the AddrMode was created we need to bail out gracefully if widths\n    // do not match instead of extending it.\n    //\n    // (See below for code to add the scale.)\n    if (AddrMode.Scale) {\n      Type *ScaledRegTy = AddrMode.ScaledReg->getType();\n      if (cast<IntegerType>(IntPtrTy)->getBitWidth() >\n          cast<IntegerType>(ScaledRegTy)->getBitWidth())\n        return Modified;\n    }\n\n    if (AddrMode.BaseGV) {\n      if (ResultPtr)\n        return Modified;\n\n      ResultPtr = AddrMode.BaseGV;\n    }\n\n    // If the real base value actually came from an inttoptr, then the matcher\n    // will look through it and provide only the integer value. In that case,\n    // use it here.\n    if (!DL->isNonIntegralPointerType(Addr->getType())) {\n      if (!ResultPtr && AddrMode.BaseReg) {\n        ResultPtr = Builder.CreateIntToPtr(AddrMode.BaseReg, Addr->getType(),\n                                           \"sunkaddr\");\n        AddrMode.BaseReg = nullptr;\n      } else if (!ResultPtr && AddrMode.Scale == 1) {\n        ResultPtr = Builder.CreateIntToPtr(AddrMode.ScaledReg, Addr->getType(),\n                                           \"sunkaddr\");\n        AddrMode.Scale = 0;\n      }\n    }\n\n    if (!ResultPtr &&\n        !AddrMode.BaseReg && !AddrMode.Scale && !AddrMode.BaseOffs) {\n      SunkAddr = Constant::getNullValue(Addr->getType());\n    } else if (!ResultPtr) {\n      return Modified;\n    } else {\n      Type *I8PtrTy =\n          Builder.getInt8PtrTy(Addr->getType()->getPointerAddressSpace());\n      Type *I8Ty = Builder.getInt8Ty();\n\n      // Start with the base register. Do this first so that subsequent address\n      // matching finds it last, which will prevent it from trying to match it\n      // as the scaled value in case it happens to be a mul. That would be\n      // problematic if we've sunk a different mul for the scale, because then\n      // we'd end up sinking both muls.\n      if (AddrMode.BaseReg) {\n        Value *V = AddrMode.BaseReg;\n        if (V->getType() != IntPtrTy)\n          V = Builder.CreateIntCast(V, IntPtrTy, /*isSigned=*/true, \"sunkaddr\");\n\n        ResultIndex = V;\n      }\n\n      // Add the scale value.\n      if (AddrMode.Scale) {\n        Value *V = AddrMode.ScaledReg;\n        if (V->getType() == IntPtrTy) {\n          // done.\n        } else {\n          assert(cast<IntegerType>(IntPtrTy)->getBitWidth() <\n                 cast<IntegerType>(V->getType())->getBitWidth() &&\n                 \"We can't transform if ScaledReg is too narrow\");\n          V = Builder.CreateTrunc(V, IntPtrTy, \"sunkaddr\");\n        }\n\n        if (AddrMode.Scale != 1)\n          V = Builder.CreateMul(V, ConstantInt::get(IntPtrTy, AddrMode.Scale),\n                                \"sunkaddr\");\n        if (ResultIndex)\n          ResultIndex = Builder.CreateAdd(ResultIndex, V, \"sunkaddr\");\n        else\n          ResultIndex = V;\n      }\n\n      // Add in the Base Offset if present.\n      if (AddrMode.BaseOffs) {\n        Value *V = ConstantInt::get(IntPtrTy, AddrMode.BaseOffs);\n        if (ResultIndex) {\n          // We need to add this separately from the scale above to help with\n          // SDAG consecutive load/store merging.\n          if (ResultPtr->getType() != I8PtrTy)\n            ResultPtr = Builder.CreatePointerCast(ResultPtr, I8PtrTy);\n          ResultPtr =\n              AddrMode.InBounds\n                  ? Builder.CreateInBoundsGEP(I8Ty, ResultPtr, ResultIndex,\n                                              \"sunkaddr\")\n                  : Builder.CreateGEP(I8Ty, ResultPtr, ResultIndex, \"sunkaddr\");\n        }\n\n        ResultIndex = V;\n      }\n\n      if (!ResultIndex) {\n        SunkAddr = ResultPtr;\n      } else {\n        if (ResultPtr->getType() != I8PtrTy)\n          ResultPtr = Builder.CreatePointerCast(ResultPtr, I8PtrTy);\n        SunkAddr =\n            AddrMode.InBounds\n                ? Builder.CreateInBoundsGEP(I8Ty, ResultPtr, ResultIndex,\n                                            \"sunkaddr\")\n                : Builder.CreateGEP(I8Ty, ResultPtr, ResultIndex, \"sunkaddr\");\n      }\n\n      if (SunkAddr->getType() != Addr->getType())\n        SunkAddr = Builder.CreatePointerCast(SunkAddr, Addr->getType());\n    }\n  } else {\n    // We'd require a ptrtoint/inttoptr down the line, which we can't do for\n    // non-integral pointers, so in that case bail out now.\n    Type *BaseTy = AddrMode.BaseReg ? AddrMode.BaseReg->getType() : nullptr;\n    Type *ScaleTy = AddrMode.Scale ? AddrMode.ScaledReg->getType() : nullptr;\n    PointerType *BasePtrTy = dyn_cast_or_null<PointerType>(BaseTy);\n    PointerType *ScalePtrTy = dyn_cast_or_null<PointerType>(ScaleTy);\n    if (DL->isNonIntegralPointerType(Addr->getType()) ||\n        (BasePtrTy && DL->isNonIntegralPointerType(BasePtrTy)) ||\n        (ScalePtrTy && DL->isNonIntegralPointerType(ScalePtrTy)) ||\n        (AddrMode.BaseGV &&\n         DL->isNonIntegralPointerType(AddrMode.BaseGV->getType())))\n      return Modified;\n\n    LLVM_DEBUG(dbgs() << \"CGP: SINKING nonlocal addrmode: \" << AddrMode\n                      << \" for \" << *MemoryInst << \"\\n\");\n    Type *IntPtrTy = DL->getIntPtrType(Addr->getType());\n    Value *Result = nullptr;\n\n    // Start with the base register. Do this first so that subsequent address\n    // matching finds it last, which will prevent it from trying to match it\n    // as the scaled value in case it happens to be a mul. That would be\n    // problematic if we've sunk a different mul for the scale, because then\n    // we'd end up sinking both muls.\n    if (AddrMode.BaseReg) {\n      Value *V = AddrMode.BaseReg;\n      if (V->getType()->isPointerTy())\n        V = Builder.CreatePtrToInt(V, IntPtrTy, \"sunkaddr\");\n      if (V->getType() != IntPtrTy)\n        V = Builder.CreateIntCast(V, IntPtrTy, /*isSigned=*/true, \"sunkaddr\");\n      Result = V;\n    }\n\n    // Add the scale value.\n    if (AddrMode.Scale) {\n      Value *V = AddrMode.ScaledReg;\n      if (V->getType() == IntPtrTy) {\n        // done.\n      } else if (V->getType()->isPointerTy()) {\n        V = Builder.CreatePtrToInt(V, IntPtrTy, \"sunkaddr\");\n      } else if (cast<IntegerType>(IntPtrTy)->getBitWidth() <\n                 cast<IntegerType>(V->getType())->getBitWidth()) {\n        V = Builder.CreateTrunc(V, IntPtrTy, \"sunkaddr\");\n      } else {\n        // It is only safe to sign extend the BaseReg if we know that the math\n        // required to create it did not overflow before we extend it. Since\n        // the original IR value was tossed in favor of a constant back when\n        // the AddrMode was created we need to bail out gracefully if widths\n        // do not match instead of extending it.\n        Instruction *I = dyn_cast_or_null<Instruction>(Result);\n        if (I && (Result != AddrMode.BaseReg))\n          I->eraseFromParent();\n        return Modified;\n      }\n      if (AddrMode.Scale != 1)\n        V = Builder.CreateMul(V, ConstantInt::get(IntPtrTy, AddrMode.Scale),\n                              \"sunkaddr\");\n      if (Result)\n        Result = Builder.CreateAdd(Result, V, \"sunkaddr\");\n      else\n        Result = V;\n    }\n\n    // Add in the BaseGV if present.\n    if (AddrMode.BaseGV) {\n      Value *V = Builder.CreatePtrToInt(AddrMode.BaseGV, IntPtrTy, \"sunkaddr\");\n      if (Result)\n        Result = Builder.CreateAdd(Result, V, \"sunkaddr\");\n      else\n        Result = V;\n    }\n\n    // Add in the Base Offset if present.\n    if (AddrMode.BaseOffs) {\n      Value *V = ConstantInt::get(IntPtrTy, AddrMode.BaseOffs);\n      if (Result)\n        Result = Builder.CreateAdd(Result, V, \"sunkaddr\");\n      else\n        Result = V;\n    }\n\n    if (!Result)\n      SunkAddr = Constant::getNullValue(Addr->getType());\n    else\n      SunkAddr = Builder.CreateIntToPtr(Result, Addr->getType(), \"sunkaddr\");\n  }\n\n  MemoryInst->replaceUsesOfWith(Repl, SunkAddr);\n  // Store the newly computed address into the cache. In the case we reused a\n  // value, this should be idempotent.\n  SunkAddrs[Addr] = WeakTrackingVH(SunkAddr);\n\n  // If we have no uses, recursively delete the value and all dead instructions\n  // using it.\n  if (Repl->use_empty()) {\n    resetIteratorIfInvalidatedWhileCalling(CurInstIterator->getParent(), [&]() {\n      RecursivelyDeleteTriviallyDeadInstructions(\n          Repl, TLInfo, nullptr,\n          [&](Value *V) { removeAllAssertingVHReferences(V); });\n    });\n  }\n  ++NumMemoryInsts;\n  return true;\n}\n\n/// Rewrite GEP input to gather/scatter to enable SelectionDAGBuilder to find\n/// a uniform base to use for ISD::MGATHER/MSCATTER. SelectionDAGBuilder can\n/// only handle a 2 operand GEP in the same basic block or a splat constant\n/// vector. The 2 operands to the GEP must have a scalar pointer and a vector\n/// index.\n///\n/// If the existing GEP has a vector base pointer that is splat, we can look\n/// through the splat to find the scalar pointer. If we can't find a scalar\n/// pointer there's nothing we can do.\n///\n/// If we have a GEP with more than 2 indices where the middle indices are all\n/// zeroes, we can replace it with 2 GEPs where the second has 2 operands.\n///\n/// If the final index isn't a vector or is a splat, we can emit a scalar GEP\n/// followed by a GEP with an all zeroes vector index. This will enable\n/// SelectionDAGBuilder to use the scalar GEP as the uniform base and have a\n/// zero index.\nbool CodeGenPrepare::optimizeGatherScatterInst(Instruction *MemoryInst,\n                                               Value *Ptr) {\n  Value *NewAddr;\n\n  if (const auto *GEP = dyn_cast<GetElementPtrInst>(Ptr)) {\n    // Don't optimize GEPs that don't have indices.\n    if (!GEP->hasIndices())\n      return false;\n\n    // If the GEP and the gather/scatter aren't in the same BB, don't optimize.\n    // FIXME: We should support this by sinking the GEP.\n    if (MemoryInst->getParent() != GEP->getParent())\n      return false;\n\n    SmallVector<Value *, 2> Ops(GEP->operands());\n\n    bool RewriteGEP = false;\n\n    if (Ops[0]->getType()->isVectorTy()) {\n      Ops[0] = getSplatValue(Ops[0]);\n      if (!Ops[0])\n        return false;\n      RewriteGEP = true;\n    }\n\n    unsigned FinalIndex = Ops.size() - 1;\n\n    // Ensure all but the last index is 0.\n    // FIXME: This isn't strictly required. All that's required is that they are\n    // all scalars or splats.\n    for (unsigned i = 1; i < FinalIndex; ++i) {\n      auto *C = dyn_cast<Constant>(Ops[i]);\n      if (!C)\n        return false;\n      if (isa<VectorType>(C->getType()))\n        C = C->getSplatValue();\n      auto *CI = dyn_cast_or_null<ConstantInt>(C);\n      if (!CI || !CI->isZero())\n        return false;\n      // Scalarize the index if needed.\n      Ops[i] = CI;\n    }\n\n    // Try to scalarize the final index.\n    if (Ops[FinalIndex]->getType()->isVectorTy()) {\n      if (Value *V = getSplatValue(Ops[FinalIndex])) {\n        auto *C = dyn_cast<ConstantInt>(V);\n        // Don't scalarize all zeros vector.\n        if (!C || !C->isZero()) {\n          Ops[FinalIndex] = V;\n          RewriteGEP = true;\n        }\n      }\n    }\n\n    // If we made any changes or the we have extra operands, we need to generate\n    // new instructions.\n    if (!RewriteGEP && Ops.size() == 2)\n      return false;\n\n    auto NumElts = cast<VectorType>(Ptr->getType())->getElementCount();\n\n    IRBuilder<> Builder(MemoryInst);\n\n    Type *SourceTy = GEP->getSourceElementType();\n    Type *ScalarIndexTy = DL->getIndexType(Ops[0]->getType()->getScalarType());\n\n    // If the final index isn't a vector, emit a scalar GEP containing all ops\n    // and a vector GEP with all zeroes final index.\n    if (!Ops[FinalIndex]->getType()->isVectorTy()) {\n      NewAddr = Builder.CreateGEP(SourceTy, Ops[0],\n                                  makeArrayRef(Ops).drop_front());\n      auto *IndexTy = VectorType::get(ScalarIndexTy, NumElts);\n      NewAddr = Builder.CreateGEP(NewAddr, Constant::getNullValue(IndexTy));\n    } else {\n      Value *Base = Ops[0];\n      Value *Index = Ops[FinalIndex];\n\n      // Create a scalar GEP if there are more than 2 operands.\n      if (Ops.size() != 2) {\n        // Replace the last index with 0.\n        Ops[FinalIndex] = Constant::getNullValue(ScalarIndexTy);\n        Base = Builder.CreateGEP(SourceTy, Base,\n                                 makeArrayRef(Ops).drop_front());\n      }\n\n      // Now create the GEP with scalar pointer and vector index.\n      NewAddr = Builder.CreateGEP(Base, Index);\n    }\n  } else if (!isa<Constant>(Ptr)) {\n    // Not a GEP, maybe its a splat and we can create a GEP to enable\n    // SelectionDAGBuilder to use it as a uniform base.\n    Value *V = getSplatValue(Ptr);\n    if (!V)\n      return false;\n\n    auto NumElts = cast<VectorType>(Ptr->getType())->getElementCount();\n\n    IRBuilder<> Builder(MemoryInst);\n\n    // Emit a vector GEP with a scalar pointer and all 0s vector index.\n    Type *ScalarIndexTy = DL->getIndexType(V->getType()->getScalarType());\n    auto *IndexTy = VectorType::get(ScalarIndexTy, NumElts);\n    NewAddr = Builder.CreateGEP(V, Constant::getNullValue(IndexTy));\n  } else {\n    // Constant, SelectionDAGBuilder knows to check if its a splat.\n    return false;\n  }\n\n  MemoryInst->replaceUsesOfWith(Ptr, NewAddr);\n\n  // If we have no uses, recursively delete the value and all dead instructions\n  // using it.\n  if (Ptr->use_empty())\n    RecursivelyDeleteTriviallyDeadInstructions(\n        Ptr, TLInfo, nullptr,\n        [&](Value *V) { removeAllAssertingVHReferences(V); });\n\n  return true;\n}\n\n/// If there are any memory operands, use OptimizeMemoryInst to sink their\n/// address computing into the block when possible / profitable.\nbool CodeGenPrepare::optimizeInlineAsmInst(CallInst *CS) {\n  bool MadeChange = false;\n\n  const TargetRegisterInfo *TRI =\n      TM->getSubtargetImpl(*CS->getFunction())->getRegisterInfo();\n  TargetLowering::AsmOperandInfoVector TargetConstraints =\n      TLI->ParseConstraints(*DL, TRI, *CS);\n  unsigned ArgNo = 0;\n  for (unsigned i = 0, e = TargetConstraints.size(); i != e; ++i) {\n    TargetLowering::AsmOperandInfo &OpInfo = TargetConstraints[i];\n\n    // Compute the constraint code and ConstraintType to use.\n    TLI->ComputeConstraintToUse(OpInfo, SDValue());\n\n    if (OpInfo.ConstraintType == TargetLowering::C_Memory &&\n        OpInfo.isIndirect) {\n      Value *OpVal = CS->getArgOperand(ArgNo++);\n      MadeChange |= optimizeMemoryInst(CS, OpVal, OpVal->getType(), ~0u);\n    } else if (OpInfo.Type == InlineAsm::isInput)\n      ArgNo++;\n  }\n\n  return MadeChange;\n}\n\n/// Check if all the uses of \\p Val are equivalent (or free) zero or\n/// sign extensions.\nstatic bool hasSameExtUse(Value *Val, const TargetLowering &TLI) {\n  assert(!Val->use_empty() && \"Input must have at least one use\");\n  const Instruction *FirstUser = cast<Instruction>(*Val->user_begin());\n  bool IsSExt = isa<SExtInst>(FirstUser);\n  Type *ExtTy = FirstUser->getType();\n  for (const User *U : Val->users()) {\n    const Instruction *UI = cast<Instruction>(U);\n    if ((IsSExt && !isa<SExtInst>(UI)) || (!IsSExt && !isa<ZExtInst>(UI)))\n      return false;\n    Type *CurTy = UI->getType();\n    // Same input and output types: Same instruction after CSE.\n    if (CurTy == ExtTy)\n      continue;\n\n    // If IsSExt is true, we are in this situation:\n    // a = Val\n    // b = sext ty1 a to ty2\n    // c = sext ty1 a to ty3\n    // Assuming ty2 is shorter than ty3, this could be turned into:\n    // a = Val\n    // b = sext ty1 a to ty2\n    // c = sext ty2 b to ty3\n    // However, the last sext is not free.\n    if (IsSExt)\n      return false;\n\n    // This is a ZExt, maybe this is free to extend from one type to another.\n    // In that case, we would not account for a different use.\n    Type *NarrowTy;\n    Type *LargeTy;\n    if (ExtTy->getScalarType()->getIntegerBitWidth() >\n        CurTy->getScalarType()->getIntegerBitWidth()) {\n      NarrowTy = CurTy;\n      LargeTy = ExtTy;\n    } else {\n      NarrowTy = ExtTy;\n      LargeTy = CurTy;\n    }\n\n    if (!TLI.isZExtFree(NarrowTy, LargeTy))\n      return false;\n  }\n  // All uses are the same or can be derived from one another for free.\n  return true;\n}\n\n/// Try to speculatively promote extensions in \\p Exts and continue\n/// promoting through newly promoted operands recursively as far as doing so is\n/// profitable. Save extensions profitably moved up, in \\p ProfitablyMovedExts.\n/// When some promotion happened, \\p TPT contains the proper state to revert\n/// them.\n///\n/// \\return true if some promotion happened, false otherwise.\nbool CodeGenPrepare::tryToPromoteExts(\n    TypePromotionTransaction &TPT, const SmallVectorImpl<Instruction *> &Exts,\n    SmallVectorImpl<Instruction *> &ProfitablyMovedExts,\n    unsigned CreatedInstsCost) {\n  bool Promoted = false;\n\n  // Iterate over all the extensions to try to promote them.\n  for (auto *I : Exts) {\n    // Early check if we directly have ext(load).\n    if (isa<LoadInst>(I->getOperand(0))) {\n      ProfitablyMovedExts.push_back(I);\n      continue;\n    }\n\n    // Check whether or not we want to do any promotion.  The reason we have\n    // this check inside the for loop is to catch the case where an extension\n    // is directly fed by a load because in such case the extension can be moved\n    // up without any promotion on its operands.\n    if (!TLI->enableExtLdPromotion() || DisableExtLdPromotion)\n      return false;\n\n    // Get the action to perform the promotion.\n    TypePromotionHelper::Action TPH =\n        TypePromotionHelper::getAction(I, InsertedInsts, *TLI, PromotedInsts);\n    // Check if we can promote.\n    if (!TPH) {\n      // Save the current extension as we cannot move up through its operand.\n      ProfitablyMovedExts.push_back(I);\n      continue;\n    }\n\n    // Save the current state.\n    TypePromotionTransaction::ConstRestorationPt LastKnownGood =\n        TPT.getRestorationPoint();\n    SmallVector<Instruction *, 4> NewExts;\n    unsigned NewCreatedInstsCost = 0;\n    unsigned ExtCost = !TLI->isExtFree(I);\n    // Promote.\n    Value *PromotedVal = TPH(I, TPT, PromotedInsts, NewCreatedInstsCost,\n                             &NewExts, nullptr, *TLI);\n    assert(PromotedVal &&\n           \"TypePromotionHelper should have filtered out those cases\");\n\n    // We would be able to merge only one extension in a load.\n    // Therefore, if we have more than 1 new extension we heuristically\n    // cut this search path, because it means we degrade the code quality.\n    // With exactly 2, the transformation is neutral, because we will merge\n    // one extension but leave one. However, we optimistically keep going,\n    // because the new extension may be removed too.\n    long long TotalCreatedInstsCost = CreatedInstsCost + NewCreatedInstsCost;\n    // FIXME: It would be possible to propagate a negative value instead of\n    // conservatively ceiling it to 0.\n    TotalCreatedInstsCost =\n        std::max((long long)0, (TotalCreatedInstsCost - ExtCost));\n    if (!StressExtLdPromotion &&\n        (TotalCreatedInstsCost > 1 ||\n         !isPromotedInstructionLegal(*TLI, *DL, PromotedVal))) {\n      // This promotion is not profitable, rollback to the previous state, and\n      // save the current extension in ProfitablyMovedExts as the latest\n      // speculative promotion turned out to be unprofitable.\n      TPT.rollback(LastKnownGood);\n      ProfitablyMovedExts.push_back(I);\n      continue;\n    }\n    // Continue promoting NewExts as far as doing so is profitable.\n    SmallVector<Instruction *, 2> NewlyMovedExts;\n    (void)tryToPromoteExts(TPT, NewExts, NewlyMovedExts, TotalCreatedInstsCost);\n    bool NewPromoted = false;\n    for (auto *ExtInst : NewlyMovedExts) {\n      Instruction *MovedExt = cast<Instruction>(ExtInst);\n      Value *ExtOperand = MovedExt->getOperand(0);\n      // If we have reached to a load, we need this extra profitability check\n      // as it could potentially be merged into an ext(load).\n      if (isa<LoadInst>(ExtOperand) &&\n          !(StressExtLdPromotion || NewCreatedInstsCost <= ExtCost ||\n            (ExtOperand->hasOneUse() || hasSameExtUse(ExtOperand, *TLI))))\n        continue;\n\n      ProfitablyMovedExts.push_back(MovedExt);\n      NewPromoted = true;\n    }\n\n    // If none of speculative promotions for NewExts is profitable, rollback\n    // and save the current extension (I) as the last profitable extension.\n    if (!NewPromoted) {\n      TPT.rollback(LastKnownGood);\n      ProfitablyMovedExts.push_back(I);\n      continue;\n    }\n    // The promotion is profitable.\n    Promoted = true;\n  }\n  return Promoted;\n}\n\n/// Merging redundant sexts when one is dominating the other.\nbool CodeGenPrepare::mergeSExts(Function &F) {\n  bool Changed = false;\n  for (auto &Entry : ValToSExtendedUses) {\n    SExts &Insts = Entry.second;\n    SExts CurPts;\n    for (Instruction *Inst : Insts) {\n      if (RemovedInsts.count(Inst) || !isa<SExtInst>(Inst) ||\n          Inst->getOperand(0) != Entry.first)\n        continue;\n      bool inserted = false;\n      for (auto &Pt : CurPts) {\n        if (getDT(F).dominates(Inst, Pt)) {\n          Pt->replaceAllUsesWith(Inst);\n          RemovedInsts.insert(Pt);\n          Pt->removeFromParent();\n          Pt = Inst;\n          inserted = true;\n          Changed = true;\n          break;\n        }\n        if (!getDT(F).dominates(Pt, Inst))\n          // Give up if we need to merge in a common dominator as the\n          // experiments show it is not profitable.\n          continue;\n        Inst->replaceAllUsesWith(Pt);\n        RemovedInsts.insert(Inst);\n        Inst->removeFromParent();\n        inserted = true;\n        Changed = true;\n        break;\n      }\n      if (!inserted)\n        CurPts.push_back(Inst);\n    }\n  }\n  return Changed;\n}\n\n// Splitting large data structures so that the GEPs accessing them can have\n// smaller offsets so that they can be sunk to the same blocks as their users.\n// For example, a large struct starting from %base is split into two parts\n// where the second part starts from %new_base.\n//\n// Before:\n// BB0:\n//   %base     =\n//\n// BB1:\n//   %gep0     = gep %base, off0\n//   %gep1     = gep %base, off1\n//   %gep2     = gep %base, off2\n//\n// BB2:\n//   %load1    = load %gep0\n//   %load2    = load %gep1\n//   %load3    = load %gep2\n//\n// After:\n// BB0:\n//   %base     =\n//   %new_base = gep %base, off0\n//\n// BB1:\n//   %new_gep0 = %new_base\n//   %new_gep1 = gep %new_base, off1 - off0\n//   %new_gep2 = gep %new_base, off2 - off0\n//\n// BB2:\n//   %load1    = load i32, i32* %new_gep0\n//   %load2    = load i32, i32* %new_gep1\n//   %load3    = load i32, i32* %new_gep2\n//\n// %new_gep1 and %new_gep2 can be sunk to BB2 now after the splitting because\n// their offsets are smaller enough to fit into the addressing mode.\nbool CodeGenPrepare::splitLargeGEPOffsets() {\n  bool Changed = false;\n  for (auto &Entry : LargeOffsetGEPMap) {\n    Value *OldBase = Entry.first;\n    SmallVectorImpl<std::pair<AssertingVH<GetElementPtrInst>, int64_t>>\n        &LargeOffsetGEPs = Entry.second;\n    auto compareGEPOffset =\n        [&](const std::pair<GetElementPtrInst *, int64_t> &LHS,\n            const std::pair<GetElementPtrInst *, int64_t> &RHS) {\n          if (LHS.first == RHS.first)\n            return false;\n          if (LHS.second != RHS.second)\n            return LHS.second < RHS.second;\n          return LargeOffsetGEPID[LHS.first] < LargeOffsetGEPID[RHS.first];\n        };\n    // Sorting all the GEPs of the same data structures based on the offsets.\n    llvm::sort(LargeOffsetGEPs, compareGEPOffset);\n    LargeOffsetGEPs.erase(\n        std::unique(LargeOffsetGEPs.begin(), LargeOffsetGEPs.end()),\n        LargeOffsetGEPs.end());\n    // Skip if all the GEPs have the same offsets.\n    if (LargeOffsetGEPs.front().second == LargeOffsetGEPs.back().second)\n      continue;\n    GetElementPtrInst *BaseGEP = LargeOffsetGEPs.begin()->first;\n    int64_t BaseOffset = LargeOffsetGEPs.begin()->second;\n    Value *NewBaseGEP = nullptr;\n\n    auto *LargeOffsetGEP = LargeOffsetGEPs.begin();\n    while (LargeOffsetGEP != LargeOffsetGEPs.end()) {\n      GetElementPtrInst *GEP = LargeOffsetGEP->first;\n      int64_t Offset = LargeOffsetGEP->second;\n      if (Offset != BaseOffset) {\n        TargetLowering::AddrMode AddrMode;\n        AddrMode.BaseOffs = Offset - BaseOffset;\n        // The result type of the GEP might not be the type of the memory\n        // access.\n        if (!TLI->isLegalAddressingMode(*DL, AddrMode,\n                                        GEP->getResultElementType(),\n                                        GEP->getAddressSpace())) {\n          // We need to create a new base if the offset to the current base is\n          // too large to fit into the addressing mode. So, a very large struct\n          // may be split into several parts.\n          BaseGEP = GEP;\n          BaseOffset = Offset;\n          NewBaseGEP = nullptr;\n        }\n      }\n\n      // Generate a new GEP to replace the current one.\n      LLVMContext &Ctx = GEP->getContext();\n      Type *IntPtrTy = DL->getIntPtrType(GEP->getType());\n      Type *I8PtrTy =\n          Type::getInt8PtrTy(Ctx, GEP->getType()->getPointerAddressSpace());\n      Type *I8Ty = Type::getInt8Ty(Ctx);\n\n      if (!NewBaseGEP) {\n        // Create a new base if we don't have one yet.  Find the insertion\n        // pointer for the new base first.\n        BasicBlock::iterator NewBaseInsertPt;\n        BasicBlock *NewBaseInsertBB;\n        if (auto *BaseI = dyn_cast<Instruction>(OldBase)) {\n          // If the base of the struct is an instruction, the new base will be\n          // inserted close to it.\n          NewBaseInsertBB = BaseI->getParent();\n          if (isa<PHINode>(BaseI))\n            NewBaseInsertPt = NewBaseInsertBB->getFirstInsertionPt();\n          else if (InvokeInst *Invoke = dyn_cast<InvokeInst>(BaseI)) {\n            NewBaseInsertBB =\n                SplitEdge(NewBaseInsertBB, Invoke->getNormalDest());\n            NewBaseInsertPt = NewBaseInsertBB->getFirstInsertionPt();\n          } else\n            NewBaseInsertPt = std::next(BaseI->getIterator());\n        } else {\n          // If the current base is an argument or global value, the new base\n          // will be inserted to the entry block.\n          NewBaseInsertBB = &BaseGEP->getFunction()->getEntryBlock();\n          NewBaseInsertPt = NewBaseInsertBB->getFirstInsertionPt();\n        }\n        IRBuilder<> NewBaseBuilder(NewBaseInsertBB, NewBaseInsertPt);\n        // Create a new base.\n        Value *BaseIndex = ConstantInt::get(IntPtrTy, BaseOffset);\n        NewBaseGEP = OldBase;\n        if (NewBaseGEP->getType() != I8PtrTy)\n          NewBaseGEP = NewBaseBuilder.CreatePointerCast(NewBaseGEP, I8PtrTy);\n        NewBaseGEP =\n            NewBaseBuilder.CreateGEP(I8Ty, NewBaseGEP, BaseIndex, \"splitgep\");\n        NewGEPBases.insert(NewBaseGEP);\n      }\n\n      IRBuilder<> Builder(GEP);\n      Value *NewGEP = NewBaseGEP;\n      if (Offset == BaseOffset) {\n        if (GEP->getType() != I8PtrTy)\n          NewGEP = Builder.CreatePointerCast(NewGEP, GEP->getType());\n      } else {\n        // Calculate the new offset for the new GEP.\n        Value *Index = ConstantInt::get(IntPtrTy, Offset - BaseOffset);\n        NewGEP = Builder.CreateGEP(I8Ty, NewBaseGEP, Index);\n\n        if (GEP->getType() != I8PtrTy)\n          NewGEP = Builder.CreatePointerCast(NewGEP, GEP->getType());\n      }\n      GEP->replaceAllUsesWith(NewGEP);\n      LargeOffsetGEPID.erase(GEP);\n      LargeOffsetGEP = LargeOffsetGEPs.erase(LargeOffsetGEP);\n      GEP->eraseFromParent();\n      Changed = true;\n    }\n  }\n  return Changed;\n}\n\nbool CodeGenPrepare::optimizePhiType(\n    PHINode *I, SmallPtrSetImpl<PHINode *> &Visited,\n    SmallPtrSetImpl<Instruction *> &DeletedInstrs) {\n  // We are looking for a collection on interconnected phi nodes that together\n  // only use loads/bitcasts and are used by stores/bitcasts, and the bitcasts\n  // are of the same type. Convert the whole set of nodes to the type of the\n  // bitcast.\n  Type *PhiTy = I->getType();\n  Type *ConvertTy = nullptr;\n  if (Visited.count(I) ||\n      (!I->getType()->isIntegerTy() && !I->getType()->isFloatingPointTy()))\n    return false;\n\n  SmallVector<Instruction *, 4> Worklist;\n  Worklist.push_back(cast<Instruction>(I));\n  SmallPtrSet<PHINode *, 4> PhiNodes;\n  PhiNodes.insert(I);\n  Visited.insert(I);\n  SmallPtrSet<Instruction *, 4> Defs;\n  SmallPtrSet<Instruction *, 4> Uses;\n  // This works by adding extra bitcasts between load/stores and removing\n  // existing bicasts. If we have a phi(bitcast(load)) or a store(bitcast(phi))\n  // we can get in the situation where we remove a bitcast in one iteration\n  // just to add it again in the next. We need to ensure that at least one\n  // bitcast we remove are anchored to something that will not change back.\n  bool AnyAnchored = false;\n\n  while (!Worklist.empty()) {\n    Instruction *II = Worklist.pop_back_val();\n\n    if (auto *Phi = dyn_cast<PHINode>(II)) {\n      // Handle Defs, which might also be PHI's\n      for (Value *V : Phi->incoming_values()) {\n        if (auto *OpPhi = dyn_cast<PHINode>(V)) {\n          if (!PhiNodes.count(OpPhi)) {\n            if (Visited.count(OpPhi))\n              return false;\n            PhiNodes.insert(OpPhi);\n            Visited.insert(OpPhi);\n            Worklist.push_back(OpPhi);\n          }\n        } else if (auto *OpLoad = dyn_cast<LoadInst>(V)) {\n          if (!OpLoad->isSimple())\n            return false;\n          if (!Defs.count(OpLoad)) {\n            Defs.insert(OpLoad);\n            Worklist.push_back(OpLoad);\n          }\n        } else if (auto *OpEx = dyn_cast<ExtractElementInst>(V)) {\n          if (!Defs.count(OpEx)) {\n            Defs.insert(OpEx);\n            Worklist.push_back(OpEx);\n          }\n        } else if (auto *OpBC = dyn_cast<BitCastInst>(V)) {\n          if (!ConvertTy)\n            ConvertTy = OpBC->getOperand(0)->getType();\n          if (OpBC->getOperand(0)->getType() != ConvertTy)\n            return false;\n          if (!Defs.count(OpBC)) {\n            Defs.insert(OpBC);\n            Worklist.push_back(OpBC);\n            AnyAnchored |= !isa<LoadInst>(OpBC->getOperand(0)) &&\n                           !isa<ExtractElementInst>(OpBC->getOperand(0));\n          }\n        } else if (!isa<UndefValue>(V)) {\n          return false;\n        }\n      }\n    }\n\n    // Handle uses which might also be phi's\n    for (User *V : II->users()) {\n      if (auto *OpPhi = dyn_cast<PHINode>(V)) {\n        if (!PhiNodes.count(OpPhi)) {\n          if (Visited.count(OpPhi))\n            return false;\n          PhiNodes.insert(OpPhi);\n          Visited.insert(OpPhi);\n          Worklist.push_back(OpPhi);\n        }\n      } else if (auto *OpStore = dyn_cast<StoreInst>(V)) {\n        if (!OpStore->isSimple() || OpStore->getOperand(0) != II)\n          return false;\n        Uses.insert(OpStore);\n      } else if (auto *OpBC = dyn_cast<BitCastInst>(V)) {\n        if (!ConvertTy)\n          ConvertTy = OpBC->getType();\n        if (OpBC->getType() != ConvertTy)\n          return false;\n        Uses.insert(OpBC);\n        AnyAnchored |=\n            any_of(OpBC->users(), [](User *U) { return !isa<StoreInst>(U); });\n      } else {\n        return false;\n      }\n    }\n  }\n\n  if (!ConvertTy || !AnyAnchored || !TLI->shouldConvertPhiType(PhiTy, ConvertTy))\n    return false;\n\n  LLVM_DEBUG(dbgs() << \"Converting \" << *I << \"\\n  and connected nodes to \"\n                    << *ConvertTy << \"\\n\");\n\n  // Create all the new phi nodes of the new type, and bitcast any loads to the\n  // correct type.\n  ValueToValueMap ValMap;\n  ValMap[UndefValue::get(PhiTy)] = UndefValue::get(ConvertTy);\n  for (Instruction *D : Defs) {\n    if (isa<BitCastInst>(D)) {\n      ValMap[D] = D->getOperand(0);\n      DeletedInstrs.insert(D);\n    } else {\n      ValMap[D] =\n          new BitCastInst(D, ConvertTy, D->getName() + \".bc\", D->getNextNode());\n    }\n  }\n  for (PHINode *Phi : PhiNodes)\n    ValMap[Phi] = PHINode::Create(ConvertTy, Phi->getNumIncomingValues(),\n                                  Phi->getName() + \".tc\", Phi);\n  // Pipe together all the PhiNodes.\n  for (PHINode *Phi : PhiNodes) {\n    PHINode *NewPhi = cast<PHINode>(ValMap[Phi]);\n    for (int i = 0, e = Phi->getNumIncomingValues(); i < e; i++)\n      NewPhi->addIncoming(ValMap[Phi->getIncomingValue(i)],\n                          Phi->getIncomingBlock(i));\n    Visited.insert(NewPhi);\n  }\n  // And finally pipe up the stores and bitcasts\n  for (Instruction *U : Uses) {\n    if (isa<BitCastInst>(U)) {\n      DeletedInstrs.insert(U);\n      U->replaceAllUsesWith(ValMap[U->getOperand(0)]);\n    } else {\n      U->setOperand(0,\n                    new BitCastInst(ValMap[U->getOperand(0)], PhiTy, \"bc\", U));\n    }\n  }\n\n  // Save the removed phis to be deleted later.\n  for (PHINode *Phi : PhiNodes)\n    DeletedInstrs.insert(Phi);\n  return true;\n}\n\nbool CodeGenPrepare::optimizePhiTypes(Function &F) {\n  if (!OptimizePhiTypes)\n    return false;\n\n  bool Changed = false;\n  SmallPtrSet<PHINode *, 4> Visited;\n  SmallPtrSet<Instruction *, 4> DeletedInstrs;\n\n  // Attempt to optimize all the phis in the functions to the correct type.\n  for (auto &BB : F)\n    for (auto &Phi : BB.phis())\n      Changed |= optimizePhiType(&Phi, Visited, DeletedInstrs);\n\n  // Remove any old phi's that have been converted.\n  for (auto *I : DeletedInstrs) {\n    I->replaceAllUsesWith(UndefValue::get(I->getType()));\n    I->eraseFromParent();\n  }\n\n  return Changed;\n}\n\n/// Return true, if an ext(load) can be formed from an extension in\n/// \\p MovedExts.\nbool CodeGenPrepare::canFormExtLd(\n    const SmallVectorImpl<Instruction *> &MovedExts, LoadInst *&LI,\n    Instruction *&Inst, bool HasPromoted) {\n  for (auto *MovedExtInst : MovedExts) {\n    if (isa<LoadInst>(MovedExtInst->getOperand(0))) {\n      LI = cast<LoadInst>(MovedExtInst->getOperand(0));\n      Inst = MovedExtInst;\n      break;\n    }\n  }\n  if (!LI)\n    return false;\n\n  // If they're already in the same block, there's nothing to do.\n  // Make the cheap checks first if we did not promote.\n  // If we promoted, we need to check if it is indeed profitable.\n  if (!HasPromoted && LI->getParent() == Inst->getParent())\n    return false;\n\n  return TLI->isExtLoad(LI, Inst, *DL);\n}\n\n/// Move a zext or sext fed by a load into the same basic block as the load,\n/// unless conditions are unfavorable. This allows SelectionDAG to fold the\n/// extend into the load.\n///\n/// E.g.,\n/// \\code\n/// %ld = load i32* %addr\n/// %add = add nuw i32 %ld, 4\n/// %zext = zext i32 %add to i64\n// \\endcode\n/// =>\n/// \\code\n/// %ld = load i32* %addr\n/// %zext = zext i32 %ld to i64\n/// %add = add nuw i64 %zext, 4\n/// \\encode\n/// Note that the promotion in %add to i64 is done in tryToPromoteExts(), which\n/// allow us to match zext(load i32*) to i64.\n///\n/// Also, try to promote the computations used to obtain a sign extended\n/// value used into memory accesses.\n/// E.g.,\n/// \\code\n/// a = add nsw i32 b, 3\n/// d = sext i32 a to i64\n/// e = getelementptr ..., i64 d\n/// \\endcode\n/// =>\n/// \\code\n/// f = sext i32 b to i64\n/// a = add nsw i64 f, 3\n/// e = getelementptr ..., i64 a\n/// \\endcode\n///\n/// \\p Inst[in/out] the extension may be modified during the process if some\n/// promotions apply.\nbool CodeGenPrepare::optimizeExt(Instruction *&Inst) {\n  bool AllowPromotionWithoutCommonHeader = false;\n  /// See if it is an interesting sext operations for the address type\n  /// promotion before trying to promote it, e.g., the ones with the right\n  /// type and used in memory accesses.\n  bool ATPConsiderable = TTI->shouldConsiderAddressTypePromotion(\n      *Inst, AllowPromotionWithoutCommonHeader);\n  TypePromotionTransaction TPT(RemovedInsts);\n  TypePromotionTransaction::ConstRestorationPt LastKnownGood =\n      TPT.getRestorationPoint();\n  SmallVector<Instruction *, 1> Exts;\n  SmallVector<Instruction *, 2> SpeculativelyMovedExts;\n  Exts.push_back(Inst);\n\n  bool HasPromoted = tryToPromoteExts(TPT, Exts, SpeculativelyMovedExts);\n\n  // Look for a load being extended.\n  LoadInst *LI = nullptr;\n  Instruction *ExtFedByLoad;\n\n  // Try to promote a chain of computation if it allows to form an extended\n  // load.\n  if (canFormExtLd(SpeculativelyMovedExts, LI, ExtFedByLoad, HasPromoted)) {\n    assert(LI && ExtFedByLoad && \"Expect a valid load and extension\");\n    TPT.commit();\n    // Move the extend into the same block as the load.\n    ExtFedByLoad->moveAfter(LI);\n    ++NumExtsMoved;\n    Inst = ExtFedByLoad;\n    return true;\n  }\n\n  // Continue promoting SExts if known as considerable depending on targets.\n  if (ATPConsiderable &&\n      performAddressTypePromotion(Inst, AllowPromotionWithoutCommonHeader,\n                                  HasPromoted, TPT, SpeculativelyMovedExts))\n    return true;\n\n  TPT.rollback(LastKnownGood);\n  return false;\n}\n\n// Perform address type promotion if doing so is profitable.\n// If AllowPromotionWithoutCommonHeader == false, we should find other sext\n// instructions that sign extended the same initial value. However, if\n// AllowPromotionWithoutCommonHeader == true, we expect promoting the\n// extension is just profitable.\nbool CodeGenPrepare::performAddressTypePromotion(\n    Instruction *&Inst, bool AllowPromotionWithoutCommonHeader,\n    bool HasPromoted, TypePromotionTransaction &TPT,\n    SmallVectorImpl<Instruction *> &SpeculativelyMovedExts) {\n  bool Promoted = false;\n  SmallPtrSet<Instruction *, 1> UnhandledExts;\n  bool AllSeenFirst = true;\n  for (auto *I : SpeculativelyMovedExts) {\n    Value *HeadOfChain = I->getOperand(0);\n    DenseMap<Value *, Instruction *>::iterator AlreadySeen =\n        SeenChainsForSExt.find(HeadOfChain);\n    // If there is an unhandled SExt which has the same header, try to promote\n    // it as well.\n    if (AlreadySeen != SeenChainsForSExt.end()) {\n      if (AlreadySeen->second != nullptr)\n        UnhandledExts.insert(AlreadySeen->second);\n      AllSeenFirst = false;\n    }\n  }\n\n  if (!AllSeenFirst || (AllowPromotionWithoutCommonHeader &&\n                        SpeculativelyMovedExts.size() == 1)) {\n    TPT.commit();\n    if (HasPromoted)\n      Promoted = true;\n    for (auto *I : SpeculativelyMovedExts) {\n      Value *HeadOfChain = I->getOperand(0);\n      SeenChainsForSExt[HeadOfChain] = nullptr;\n      ValToSExtendedUses[HeadOfChain].push_back(I);\n    }\n    // Update Inst as promotion happen.\n    Inst = SpeculativelyMovedExts.pop_back_val();\n  } else {\n    // This is the first chain visited from the header, keep the current chain\n    // as unhandled. Defer to promote this until we encounter another SExt\n    // chain derived from the same header.\n    for (auto *I : SpeculativelyMovedExts) {\n      Value *HeadOfChain = I->getOperand(0);\n      SeenChainsForSExt[HeadOfChain] = Inst;\n    }\n    return false;\n  }\n\n  if (!AllSeenFirst && !UnhandledExts.empty())\n    for (auto *VisitedSExt : UnhandledExts) {\n      if (RemovedInsts.count(VisitedSExt))\n        continue;\n      TypePromotionTransaction TPT(RemovedInsts);\n      SmallVector<Instruction *, 1> Exts;\n      SmallVector<Instruction *, 2> Chains;\n      Exts.push_back(VisitedSExt);\n      bool HasPromoted = tryToPromoteExts(TPT, Exts, Chains);\n      TPT.commit();\n      if (HasPromoted)\n        Promoted = true;\n      for (auto *I : Chains) {\n        Value *HeadOfChain = I->getOperand(0);\n        // Mark this as handled.\n        SeenChainsForSExt[HeadOfChain] = nullptr;\n        ValToSExtendedUses[HeadOfChain].push_back(I);\n      }\n    }\n  return Promoted;\n}\n\nbool CodeGenPrepare::optimizeExtUses(Instruction *I) {\n  BasicBlock *DefBB = I->getParent();\n\n  // If the result of a {s|z}ext and its source are both live out, rewrite all\n  // other uses of the source with result of extension.\n  Value *Src = I->getOperand(0);\n  if (Src->hasOneUse())\n    return false;\n\n  // Only do this xform if truncating is free.\n  if (!TLI->isTruncateFree(I->getType(), Src->getType()))\n    return false;\n\n  // Only safe to perform the optimization if the source is also defined in\n  // this block.\n  if (!isa<Instruction>(Src) || DefBB != cast<Instruction>(Src)->getParent())\n    return false;\n\n  bool DefIsLiveOut = false;\n  for (User *U : I->users()) {\n    Instruction *UI = cast<Instruction>(U);\n\n    // Figure out which BB this ext is used in.\n    BasicBlock *UserBB = UI->getParent();\n    if (UserBB == DefBB) continue;\n    DefIsLiveOut = true;\n    break;\n  }\n  if (!DefIsLiveOut)\n    return false;\n\n  // Make sure none of the uses are PHI nodes.\n  for (User *U : Src->users()) {\n    Instruction *UI = cast<Instruction>(U);\n    BasicBlock *UserBB = UI->getParent();\n    if (UserBB == DefBB) continue;\n    // Be conservative. We don't want this xform to end up introducing\n    // reloads just before load / store instructions.\n    if (isa<PHINode>(UI) || isa<LoadInst>(UI) || isa<StoreInst>(UI))\n      return false;\n  }\n\n  // InsertedTruncs - Only insert one trunc in each block once.\n  DenseMap<BasicBlock*, Instruction*> InsertedTruncs;\n\n  bool MadeChange = false;\n  for (Use &U : Src->uses()) {\n    Instruction *User = cast<Instruction>(U.getUser());\n\n    // Figure out which BB this ext is used in.\n    BasicBlock *UserBB = User->getParent();\n    if (UserBB == DefBB) continue;\n\n    // Both src and def are live in this block. Rewrite the use.\n    Instruction *&InsertedTrunc = InsertedTruncs[UserBB];\n\n    if (!InsertedTrunc) {\n      BasicBlock::iterator InsertPt = UserBB->getFirstInsertionPt();\n      assert(InsertPt != UserBB->end());\n      InsertedTrunc = new TruncInst(I, Src->getType(), \"\", &*InsertPt);\n      InsertedInsts.insert(InsertedTrunc);\n    }\n\n    // Replace a use of the {s|z}ext source with a use of the result.\n    U = InsertedTrunc;\n    ++NumExtUses;\n    MadeChange = true;\n  }\n\n  return MadeChange;\n}\n\n// Find loads whose uses only use some of the loaded value's bits.  Add an \"and\"\n// just after the load if the target can fold this into one extload instruction,\n// with the hope of eliminating some of the other later \"and\" instructions using\n// the loaded value.  \"and\"s that are made trivially redundant by the insertion\n// of the new \"and\" are removed by this function, while others (e.g. those whose\n// path from the load goes through a phi) are left for isel to potentially\n// remove.\n//\n// For example:\n//\n// b0:\n//   x = load i32\n//   ...\n// b1:\n//   y = and x, 0xff\n//   z = use y\n//\n// becomes:\n//\n// b0:\n//   x = load i32\n//   x' = and x, 0xff\n//   ...\n// b1:\n//   z = use x'\n//\n// whereas:\n//\n// b0:\n//   x1 = load i32\n//   ...\n// b1:\n//   x2 = load i32\n//   ...\n// b2:\n//   x = phi x1, x2\n//   y = and x, 0xff\n//\n// becomes (after a call to optimizeLoadExt for each load):\n//\n// b0:\n//   x1 = load i32\n//   x1' = and x1, 0xff\n//   ...\n// b1:\n//   x2 = load i32\n//   x2' = and x2, 0xff\n//   ...\n// b2:\n//   x = phi x1', x2'\n//   y = and x, 0xff\nbool CodeGenPrepare::optimizeLoadExt(LoadInst *Load) {\n  if (!Load->isSimple() || !Load->getType()->isIntOrPtrTy())\n    return false;\n\n  // Skip loads we've already transformed.\n  if (Load->hasOneUse() &&\n      InsertedInsts.count(cast<Instruction>(*Load->user_begin())))\n    return false;\n\n  // Look at all uses of Load, looking through phis, to determine how many bits\n  // of the loaded value are needed.\n  SmallVector<Instruction *, 8> WorkList;\n  SmallPtrSet<Instruction *, 16> Visited;\n  SmallVector<Instruction *, 8> AndsToMaybeRemove;\n  for (auto *U : Load->users())\n    WorkList.push_back(cast<Instruction>(U));\n\n  EVT LoadResultVT = TLI->getValueType(*DL, Load->getType());\n  unsigned BitWidth = LoadResultVT.getSizeInBits();\n  APInt DemandBits(BitWidth, 0);\n  APInt WidestAndBits(BitWidth, 0);\n\n  while (!WorkList.empty()) {\n    Instruction *I = WorkList.back();\n    WorkList.pop_back();\n\n    // Break use-def graph loops.\n    if (!Visited.insert(I).second)\n      continue;\n\n    // For a PHI node, push all of its users.\n    if (auto *Phi = dyn_cast<PHINode>(I)) {\n      for (auto *U : Phi->users())\n        WorkList.push_back(cast<Instruction>(U));\n      continue;\n    }\n\n    switch (I->getOpcode()) {\n    case Instruction::And: {\n      auto *AndC = dyn_cast<ConstantInt>(I->getOperand(1));\n      if (!AndC)\n        return false;\n      APInt AndBits = AndC->getValue();\n      DemandBits |= AndBits;\n      // Keep track of the widest and mask we see.\n      if (AndBits.ugt(WidestAndBits))\n        WidestAndBits = AndBits;\n      if (AndBits == WidestAndBits && I->getOperand(0) == Load)\n        AndsToMaybeRemove.push_back(I);\n      break;\n    }\n\n    case Instruction::Shl: {\n      auto *ShlC = dyn_cast<ConstantInt>(I->getOperand(1));\n      if (!ShlC)\n        return false;\n      uint64_t ShiftAmt = ShlC->getLimitedValue(BitWidth - 1);\n      DemandBits.setLowBits(BitWidth - ShiftAmt);\n      break;\n    }\n\n    case Instruction::Trunc: {\n      EVT TruncVT = TLI->getValueType(*DL, I->getType());\n      unsigned TruncBitWidth = TruncVT.getSizeInBits();\n      DemandBits.setLowBits(TruncBitWidth);\n      break;\n    }\n\n    default:\n      return false;\n    }\n  }\n\n  uint32_t ActiveBits = DemandBits.getActiveBits();\n  // Avoid hoisting (and (load x) 1) since it is unlikely to be folded by the\n  // target even if isLoadExtLegal says an i1 EXTLOAD is valid.  For example,\n  // for the AArch64 target isLoadExtLegal(ZEXTLOAD, i32, i1) returns true, but\n  // (and (load x) 1) is not matched as a single instruction, rather as a LDR\n  // followed by an AND.\n  // TODO: Look into removing this restriction by fixing backends to either\n  // return false for isLoadExtLegal for i1 or have them select this pattern to\n  // a single instruction.\n  //\n  // Also avoid hoisting if we didn't see any ands with the exact DemandBits\n  // mask, since these are the only ands that will be removed by isel.\n  if (ActiveBits <= 1 || !DemandBits.isMask(ActiveBits) ||\n      WidestAndBits != DemandBits)\n    return false;\n\n  LLVMContext &Ctx = Load->getType()->getContext();\n  Type *TruncTy = Type::getIntNTy(Ctx, ActiveBits);\n  EVT TruncVT = TLI->getValueType(*DL, TruncTy);\n\n  // Reject cases that won't be matched as extloads.\n  if (!LoadResultVT.bitsGT(TruncVT) || !TruncVT.isRound() ||\n      !TLI->isLoadExtLegal(ISD::ZEXTLOAD, LoadResultVT, TruncVT))\n    return false;\n\n  IRBuilder<> Builder(Load->getNextNode());\n  auto *NewAnd = cast<Instruction>(\n      Builder.CreateAnd(Load, ConstantInt::get(Ctx, DemandBits)));\n  // Mark this instruction as \"inserted by CGP\", so that other\n  // optimizations don't touch it.\n  InsertedInsts.insert(NewAnd);\n\n  // Replace all uses of load with new and (except for the use of load in the\n  // new and itself).\n  Load->replaceAllUsesWith(NewAnd);\n  NewAnd->setOperand(0, Load);\n\n  // Remove any and instructions that are now redundant.\n  for (auto *And : AndsToMaybeRemove)\n    // Check that the and mask is the same as the one we decided to put on the\n    // new and.\n    if (cast<ConstantInt>(And->getOperand(1))->getValue() == DemandBits) {\n      And->replaceAllUsesWith(NewAnd);\n      if (&*CurInstIterator == And)\n        CurInstIterator = std::next(And->getIterator());\n      And->eraseFromParent();\n      ++NumAndUses;\n    }\n\n  ++NumAndsAdded;\n  return true;\n}\n\n/// Check if V (an operand of a select instruction) is an expensive instruction\n/// that is only used once.\nstatic bool sinkSelectOperand(const TargetTransformInfo *TTI, Value *V) {\n  auto *I = dyn_cast<Instruction>(V);\n  // If it's safe to speculatively execute, then it should not have side\n  // effects; therefore, it's safe to sink and possibly *not* execute.\n  return I && I->hasOneUse() && isSafeToSpeculativelyExecute(I) &&\n         TTI->getUserCost(I, TargetTransformInfo::TCK_SizeAndLatency) >=\n         TargetTransformInfo::TCC_Expensive;\n}\n\n/// Returns true if a SelectInst should be turned into an explicit branch.\nstatic bool isFormingBranchFromSelectProfitable(const TargetTransformInfo *TTI,\n                                                const TargetLowering *TLI,\n                                                SelectInst *SI) {\n  // If even a predictable select is cheap, then a branch can't be cheaper.\n  if (!TLI->isPredictableSelectExpensive())\n    return false;\n\n  // FIXME: This should use the same heuristics as IfConversion to determine\n  // whether a select is better represented as a branch.\n\n  // If metadata tells us that the select condition is obviously predictable,\n  // then we want to replace the select with a branch.\n  uint64_t TrueWeight, FalseWeight;\n  if (SI->extractProfMetadata(TrueWeight, FalseWeight)) {\n    uint64_t Max = std::max(TrueWeight, FalseWeight);\n    uint64_t Sum = TrueWeight + FalseWeight;\n    if (Sum != 0) {\n      auto Probability = BranchProbability::getBranchProbability(Max, Sum);\n      if (Probability > TLI->getPredictableBranchThreshold())\n        return true;\n    }\n  }\n\n  CmpInst *Cmp = dyn_cast<CmpInst>(SI->getCondition());\n\n  // If a branch is predictable, an out-of-order CPU can avoid blocking on its\n  // comparison condition. If the compare has more than one use, there's\n  // probably another cmov or setcc around, so it's not worth emitting a branch.\n  if (!Cmp || !Cmp->hasOneUse())\n    return false;\n\n  // If either operand of the select is expensive and only needed on one side\n  // of the select, we should form a branch.\n  if (sinkSelectOperand(TTI, SI->getTrueValue()) ||\n      sinkSelectOperand(TTI, SI->getFalseValue()))\n    return true;\n\n  return false;\n}\n\n/// If \\p isTrue is true, return the true value of \\p SI, otherwise return\n/// false value of \\p SI. If the true/false value of \\p SI is defined by any\n/// select instructions in \\p Selects, look through the defining select\n/// instruction until the true/false value is not defined in \\p Selects.\nstatic Value *getTrueOrFalseValue(\n    SelectInst *SI, bool isTrue,\n    const SmallPtrSet<const Instruction *, 2> &Selects) {\n  Value *V = nullptr;\n\n  for (SelectInst *DefSI = SI; DefSI != nullptr && Selects.count(DefSI);\n       DefSI = dyn_cast<SelectInst>(V)) {\n    assert(DefSI->getCondition() == SI->getCondition() &&\n           \"The condition of DefSI does not match with SI\");\n    V = (isTrue ? DefSI->getTrueValue() : DefSI->getFalseValue());\n  }\n\n  assert(V && \"Failed to get select true/false value\");\n  return V;\n}\n\nbool CodeGenPrepare::optimizeShiftInst(BinaryOperator *Shift) {\n  assert(Shift->isShift() && \"Expected a shift\");\n\n  // If this is (1) a vector shift, (2) shifts by scalars are cheaper than\n  // general vector shifts, and (3) the shift amount is a select-of-splatted\n  // values, hoist the shifts before the select:\n  //   shift Op0, (select Cond, TVal, FVal) -->\n  //   select Cond, (shift Op0, TVal), (shift Op0, FVal)\n  //\n  // This is inverting a generic IR transform when we know that the cost of a\n  // general vector shift is more than the cost of 2 shift-by-scalars.\n  // We can't do this effectively in SDAG because we may not be able to\n  // determine if the select operands are splats from within a basic block.\n  Type *Ty = Shift->getType();\n  if (!Ty->isVectorTy() || !TLI->isVectorShiftByScalarCheap(Ty))\n    return false;\n  Value *Cond, *TVal, *FVal;\n  if (!match(Shift->getOperand(1),\n             m_OneUse(m_Select(m_Value(Cond), m_Value(TVal), m_Value(FVal)))))\n    return false;\n  if (!isSplatValue(TVal) || !isSplatValue(FVal))\n    return false;\n\n  IRBuilder<> Builder(Shift);\n  BinaryOperator::BinaryOps Opcode = Shift->getOpcode();\n  Value *NewTVal = Builder.CreateBinOp(Opcode, Shift->getOperand(0), TVal);\n  Value *NewFVal = Builder.CreateBinOp(Opcode, Shift->getOperand(0), FVal);\n  Value *NewSel = Builder.CreateSelect(Cond, NewTVal, NewFVal);\n  Shift->replaceAllUsesWith(NewSel);\n  Shift->eraseFromParent();\n  return true;\n}\n\nbool CodeGenPrepare::optimizeFunnelShift(IntrinsicInst *Fsh) {\n  Intrinsic::ID Opcode = Fsh->getIntrinsicID();\n  assert((Opcode == Intrinsic::fshl || Opcode == Intrinsic::fshr) &&\n         \"Expected a funnel shift\");\n\n  // If this is (1) a vector funnel shift, (2) shifts by scalars are cheaper\n  // than general vector shifts, and (3) the shift amount is select-of-splatted\n  // values, hoist the funnel shifts before the select:\n  //   fsh Op0, Op1, (select Cond, TVal, FVal) -->\n  //   select Cond, (fsh Op0, Op1, TVal), (fsh Op0, Op1, FVal)\n  //\n  // This is inverting a generic IR transform when we know that the cost of a\n  // general vector shift is more than the cost of 2 shift-by-scalars.\n  // We can't do this effectively in SDAG because we may not be able to\n  // determine if the select operands are splats from within a basic block.\n  Type *Ty = Fsh->getType();\n  if (!Ty->isVectorTy() || !TLI->isVectorShiftByScalarCheap(Ty))\n    return false;\n  Value *Cond, *TVal, *FVal;\n  if (!match(Fsh->getOperand(2),\n             m_OneUse(m_Select(m_Value(Cond), m_Value(TVal), m_Value(FVal)))))\n    return false;\n  if (!isSplatValue(TVal) || !isSplatValue(FVal))\n    return false;\n\n  IRBuilder<> Builder(Fsh);\n  Value *X = Fsh->getOperand(0), *Y = Fsh->getOperand(1);\n  Value *NewTVal = Builder.CreateIntrinsic(Opcode, Ty, { X, Y, TVal });\n  Value *NewFVal = Builder.CreateIntrinsic(Opcode, Ty, { X, Y, FVal });\n  Value *NewSel = Builder.CreateSelect(Cond, NewTVal, NewFVal);\n  Fsh->replaceAllUsesWith(NewSel);\n  Fsh->eraseFromParent();\n  return true;\n}\n\n/// If we have a SelectInst that will likely profit from branch prediction,\n/// turn it into a branch.\nbool CodeGenPrepare::optimizeSelectInst(SelectInst *SI) {\n  if (DisableSelectToBranch)\n    return false;\n\n  // Find all consecutive select instructions that share the same condition.\n  SmallVector<SelectInst *, 2> ASI;\n  ASI.push_back(SI);\n  for (BasicBlock::iterator It = ++BasicBlock::iterator(SI);\n       It != SI->getParent()->end(); ++It) {\n    SelectInst *I = dyn_cast<SelectInst>(&*It);\n    if (I && SI->getCondition() == I->getCondition()) {\n      ASI.push_back(I);\n    } else {\n      break;\n    }\n  }\n\n  SelectInst *LastSI = ASI.back();\n  // Increment the current iterator to skip all the rest of select instructions\n  // because they will be either \"not lowered\" or \"all lowered\" to branch.\n  CurInstIterator = std::next(LastSI->getIterator());\n\n  bool VectorCond = !SI->getCondition()->getType()->isIntegerTy(1);\n\n  // Can we convert the 'select' to CF ?\n  if (VectorCond || SI->getMetadata(LLVMContext::MD_unpredictable))\n    return false;\n\n  TargetLowering::SelectSupportKind SelectKind;\n  if (VectorCond)\n    SelectKind = TargetLowering::VectorMaskSelect;\n  else if (SI->getType()->isVectorTy())\n    SelectKind = TargetLowering::ScalarCondVectorVal;\n  else\n    SelectKind = TargetLowering::ScalarValSelect;\n\n  if (TLI->isSelectSupported(SelectKind) &&\n      (!isFormingBranchFromSelectProfitable(TTI, TLI, SI) || OptSize ||\n       llvm::shouldOptimizeForSize(SI->getParent(), PSI, BFI.get())))\n    return false;\n\n  // The DominatorTree needs to be rebuilt by any consumers after this\n  // transformation. We simply reset here rather than setting the ModifiedDT\n  // flag to avoid restarting the function walk in runOnFunction for each\n  // select optimized.\n  DT.reset();\n\n  // Transform a sequence like this:\n  //    start:\n  //       %cmp = cmp uge i32 %a, %b\n  //       %sel = select i1 %cmp, i32 %c, i32 %d\n  //\n  // Into:\n  //    start:\n  //       %cmp = cmp uge i32 %a, %b\n  //       %cmp.frozen = freeze %cmp\n  //       br i1 %cmp.frozen, label %select.true, label %select.false\n  //    select.true:\n  //       br label %select.end\n  //    select.false:\n  //       br label %select.end\n  //    select.end:\n  //       %sel = phi i32 [ %c, %select.true ], [ %d, %select.false ]\n  //\n  // %cmp should be frozen, otherwise it may introduce undefined behavior.\n  // In addition, we may sink instructions that produce %c or %d from\n  // the entry block into the destination(s) of the new branch.\n  // If the true or false blocks do not contain a sunken instruction, that\n  // block and its branch may be optimized away. In that case, one side of the\n  // first branch will point directly to select.end, and the corresponding PHI\n  // predecessor block will be the start block.\n\n  // First, we split the block containing the select into 2 blocks.\n  BasicBlock *StartBlock = SI->getParent();\n  BasicBlock::iterator SplitPt = ++(BasicBlock::iterator(LastSI));\n  BasicBlock *EndBlock = StartBlock->splitBasicBlock(SplitPt, \"select.end\");\n  BFI->setBlockFreq(EndBlock, BFI->getBlockFreq(StartBlock).getFrequency());\n\n  // Delete the unconditional branch that was just created by the split.\n  StartBlock->getTerminator()->eraseFromParent();\n\n  // These are the new basic blocks for the conditional branch.\n  // At least one will become an actual new basic block.\n  BasicBlock *TrueBlock = nullptr;\n  BasicBlock *FalseBlock = nullptr;\n  BranchInst *TrueBranch = nullptr;\n  BranchInst *FalseBranch = nullptr;\n\n  // Sink expensive instructions into the conditional blocks to avoid executing\n  // them speculatively.\n  for (SelectInst *SI : ASI) {\n    if (sinkSelectOperand(TTI, SI->getTrueValue())) {\n      if (TrueBlock == nullptr) {\n        TrueBlock = BasicBlock::Create(SI->getContext(), \"select.true.sink\",\n                                       EndBlock->getParent(), EndBlock);\n        TrueBranch = BranchInst::Create(EndBlock, TrueBlock);\n        TrueBranch->setDebugLoc(SI->getDebugLoc());\n      }\n      auto *TrueInst = cast<Instruction>(SI->getTrueValue());\n      TrueInst->moveBefore(TrueBranch);\n    }\n    if (sinkSelectOperand(TTI, SI->getFalseValue())) {\n      if (FalseBlock == nullptr) {\n        FalseBlock = BasicBlock::Create(SI->getContext(), \"select.false.sink\",\n                                        EndBlock->getParent(), EndBlock);\n        FalseBranch = BranchInst::Create(EndBlock, FalseBlock);\n        FalseBranch->setDebugLoc(SI->getDebugLoc());\n      }\n      auto *FalseInst = cast<Instruction>(SI->getFalseValue());\n      FalseInst->moveBefore(FalseBranch);\n    }\n  }\n\n  // If there was nothing to sink, then arbitrarily choose the 'false' side\n  // for a new input value to the PHI.\n  if (TrueBlock == FalseBlock) {\n    assert(TrueBlock == nullptr &&\n           \"Unexpected basic block transform while optimizing select\");\n\n    FalseBlock = BasicBlock::Create(SI->getContext(), \"select.false\",\n                                    EndBlock->getParent(), EndBlock);\n    auto *FalseBranch = BranchInst::Create(EndBlock, FalseBlock);\n    FalseBranch->setDebugLoc(SI->getDebugLoc());\n  }\n\n  // Insert the real conditional branch based on the original condition.\n  // If we did not create a new block for one of the 'true' or 'false' paths\n  // of the condition, it means that side of the branch goes to the end block\n  // directly and the path originates from the start block from the point of\n  // view of the new PHI.\n  BasicBlock *TT, *FT;\n  if (TrueBlock == nullptr) {\n    TT = EndBlock;\n    FT = FalseBlock;\n    TrueBlock = StartBlock;\n  } else if (FalseBlock == nullptr) {\n    TT = TrueBlock;\n    FT = EndBlock;\n    FalseBlock = StartBlock;\n  } else {\n    TT = TrueBlock;\n    FT = FalseBlock;\n  }\n  IRBuilder<> IB(SI);\n  auto *CondFr = IB.CreateFreeze(SI->getCondition(), SI->getName() + \".frozen\");\n  IB.CreateCondBr(CondFr, TT, FT, SI);\n\n  SmallPtrSet<const Instruction *, 2> INS;\n  INS.insert(ASI.begin(), ASI.end());\n  // Use reverse iterator because later select may use the value of the\n  // earlier select, and we need to propagate value through earlier select\n  // to get the PHI operand.\n  for (auto It = ASI.rbegin(); It != ASI.rend(); ++It) {\n    SelectInst *SI = *It;\n    // The select itself is replaced with a PHI Node.\n    PHINode *PN = PHINode::Create(SI->getType(), 2, \"\", &EndBlock->front());\n    PN->takeName(SI);\n    PN->addIncoming(getTrueOrFalseValue(SI, true, INS), TrueBlock);\n    PN->addIncoming(getTrueOrFalseValue(SI, false, INS), FalseBlock);\n    PN->setDebugLoc(SI->getDebugLoc());\n\n    SI->replaceAllUsesWith(PN);\n    SI->eraseFromParent();\n    INS.erase(SI);\n    ++NumSelectsExpanded;\n  }\n\n  // Instruct OptimizeBlock to skip to the next block.\n  CurInstIterator = StartBlock->end();\n  return true;\n}\n\n/// Some targets only accept certain types for splat inputs. For example a VDUP\n/// in MVE takes a GPR (integer) register, and the instruction that incorporate\n/// a VDUP (such as a VADD qd, qm, rm) also require a gpr register.\nbool CodeGenPrepare::optimizeShuffleVectorInst(ShuffleVectorInst *SVI) {\n  // Accept shuf(insertelem(undef/poison, val, 0), undef/poison, <0,0,..>) only\n  if (!match(SVI, m_Shuffle(m_InsertElt(m_Undef(), m_Value(), m_ZeroInt()),\n                            m_Undef(), m_ZeroMask())))\n    return false;\n  Type *NewType = TLI->shouldConvertSplatType(SVI);\n  if (!NewType)\n    return false;\n\n  auto *SVIVecType = cast<FixedVectorType>(SVI->getType());\n  assert(!NewType->isVectorTy() && \"Expected a scalar type!\");\n  assert(NewType->getScalarSizeInBits() == SVIVecType->getScalarSizeInBits() &&\n         \"Expected a type of the same size!\");\n  auto *NewVecType =\n      FixedVectorType::get(NewType, SVIVecType->getNumElements());\n\n  // Create a bitcast (shuffle (insert (bitcast(..))))\n  IRBuilder<> Builder(SVI->getContext());\n  Builder.SetInsertPoint(SVI);\n  Value *BC1 = Builder.CreateBitCast(\n      cast<Instruction>(SVI->getOperand(0))->getOperand(1), NewType);\n  Value *Shuffle = Builder.CreateVectorSplat(NewVecType->getNumElements(), BC1);\n  Value *BC2 = Builder.CreateBitCast(Shuffle, SVIVecType);\n\n  SVI->replaceAllUsesWith(BC2);\n  RecursivelyDeleteTriviallyDeadInstructions(\n      SVI, TLInfo, nullptr, [&](Value *V) { removeAllAssertingVHReferences(V); });\n\n  // Also hoist the bitcast up to its operand if it they are not in the same\n  // block.\n  if (auto *BCI = dyn_cast<Instruction>(BC1))\n    if (auto *Op = dyn_cast<Instruction>(BCI->getOperand(0)))\n      if (BCI->getParent() != Op->getParent() && !isa<PHINode>(Op) &&\n          !Op->isTerminator() && !Op->isEHPad())\n        BCI->moveAfter(Op);\n\n  return true;\n}\n\nbool CodeGenPrepare::tryToSinkFreeOperands(Instruction *I) {\n  // If the operands of I can be folded into a target instruction together with\n  // I, duplicate and sink them.\n  SmallVector<Use *, 4> OpsToSink;\n  if (!TLI->shouldSinkOperands(I, OpsToSink))\n    return false;\n\n  // OpsToSink can contain multiple uses in a use chain (e.g.\n  // (%u1 with %u1 = shufflevector), (%u2 with %u2 = zext %u1)). The dominating\n  // uses must come first, so we process the ops in reverse order so as to not\n  // create invalid IR.\n  BasicBlock *TargetBB = I->getParent();\n  bool Changed = false;\n  SmallVector<Use *, 4> ToReplace;\n  for (Use *U : reverse(OpsToSink)) {\n    auto *UI = cast<Instruction>(U->get());\n    if (UI->getParent() == TargetBB || isa<PHINode>(UI))\n      continue;\n    ToReplace.push_back(U);\n  }\n\n  SetVector<Instruction *> MaybeDead;\n  DenseMap<Instruction *, Instruction *> NewInstructions;\n  Instruction *InsertPoint = I;\n  for (Use *U : ToReplace) {\n    auto *UI = cast<Instruction>(U->get());\n    Instruction *NI = UI->clone();\n    NewInstructions[UI] = NI;\n    MaybeDead.insert(UI);\n    LLVM_DEBUG(dbgs() << \"Sinking \" << *UI << \" to user \" << *I << \"\\n\");\n    NI->insertBefore(InsertPoint);\n    InsertPoint = NI;\n    InsertedInsts.insert(NI);\n\n    // Update the use for the new instruction, making sure that we update the\n    // sunk instruction uses, if it is part of a chain that has already been\n    // sunk.\n    Instruction *OldI = cast<Instruction>(U->getUser());\n    if (NewInstructions.count(OldI))\n      NewInstructions[OldI]->setOperand(U->getOperandNo(), NI);\n    else\n      U->set(NI);\n    Changed = true;\n  }\n\n  // Remove instructions that are dead after sinking.\n  for (auto *I : MaybeDead) {\n    if (!I->hasNUsesOrMore(1)) {\n      LLVM_DEBUG(dbgs() << \"Removing dead instruction: \" << *I << \"\\n\");\n      I->eraseFromParent();\n    }\n  }\n\n  return Changed;\n}\n\nbool CodeGenPrepare::optimizeSwitchInst(SwitchInst *SI) {\n  Value *Cond = SI->getCondition();\n  Type *OldType = Cond->getType();\n  LLVMContext &Context = Cond->getContext();\n  MVT RegType = TLI->getRegisterType(Context, TLI->getValueType(*DL, OldType));\n  unsigned RegWidth = RegType.getSizeInBits();\n\n  if (RegWidth <= cast<IntegerType>(OldType)->getBitWidth())\n    return false;\n\n  // If the register width is greater than the type width, expand the condition\n  // of the switch instruction and each case constant to the width of the\n  // register. By widening the type of the switch condition, subsequent\n  // comparisons (for case comparisons) will not need to be extended to the\n  // preferred register width, so we will potentially eliminate N-1 extends,\n  // where N is the number of cases in the switch.\n  auto *NewType = Type::getIntNTy(Context, RegWidth);\n\n  // Zero-extend the switch condition and case constants unless the switch\n  // condition is a function argument that is already being sign-extended.\n  // In that case, we can avoid an unnecessary mask/extension by sign-extending\n  // everything instead.\n  Instruction::CastOps ExtType = Instruction::ZExt;\n  if (auto *Arg = dyn_cast<Argument>(Cond))\n    if (Arg->hasSExtAttr())\n      ExtType = Instruction::SExt;\n\n  auto *ExtInst = CastInst::Create(ExtType, Cond, NewType);\n  ExtInst->insertBefore(SI);\n  ExtInst->setDebugLoc(SI->getDebugLoc());\n  SI->setCondition(ExtInst);\n  for (auto Case : SI->cases()) {\n    APInt NarrowConst = Case.getCaseValue()->getValue();\n    APInt WideConst = (ExtType == Instruction::ZExt) ?\n                      NarrowConst.zext(RegWidth) : NarrowConst.sext(RegWidth);\n    Case.setValue(ConstantInt::get(Context, WideConst));\n  }\n\n  return true;\n}\n\n\nnamespace {\n\n/// Helper class to promote a scalar operation to a vector one.\n/// This class is used to move downward extractelement transition.\n/// E.g.,\n/// a = vector_op <2 x i32>\n/// b = extractelement <2 x i32> a, i32 0\n/// c = scalar_op b\n/// store c\n///\n/// =>\n/// a = vector_op <2 x i32>\n/// c = vector_op a (equivalent to scalar_op on the related lane)\n/// * d = extractelement <2 x i32> c, i32 0\n/// * store d\n/// Assuming both extractelement and store can be combine, we get rid of the\n/// transition.\nclass VectorPromoteHelper {\n  /// DataLayout associated with the current module.\n  const DataLayout &DL;\n\n  /// Used to perform some checks on the legality of vector operations.\n  const TargetLowering &TLI;\n\n  /// Used to estimated the cost of the promoted chain.\n  const TargetTransformInfo &TTI;\n\n  /// The transition being moved downwards.\n  Instruction *Transition;\n\n  /// The sequence of instructions to be promoted.\n  SmallVector<Instruction *, 4> InstsToBePromoted;\n\n  /// Cost of combining a store and an extract.\n  unsigned StoreExtractCombineCost;\n\n  /// Instruction that will be combined with the transition.\n  Instruction *CombineInst = nullptr;\n\n  /// The instruction that represents the current end of the transition.\n  /// Since we are faking the promotion until we reach the end of the chain\n  /// of computation, we need a way to get the current end of the transition.\n  Instruction *getEndOfTransition() const {\n    if (InstsToBePromoted.empty())\n      return Transition;\n    return InstsToBePromoted.back();\n  }\n\n  /// Return the index of the original value in the transition.\n  /// E.g., for \"extractelement <2 x i32> c, i32 1\" the original value,\n  /// c, is at index 0.\n  unsigned getTransitionOriginalValueIdx() const {\n    assert(isa<ExtractElementInst>(Transition) &&\n           \"Other kind of transitions are not supported yet\");\n    return 0;\n  }\n\n  /// Return the index of the index in the transition.\n  /// E.g., for \"extractelement <2 x i32> c, i32 0\" the index\n  /// is at index 1.\n  unsigned getTransitionIdx() const {\n    assert(isa<ExtractElementInst>(Transition) &&\n           \"Other kind of transitions are not supported yet\");\n    return 1;\n  }\n\n  /// Get the type of the transition.\n  /// This is the type of the original value.\n  /// E.g., for \"extractelement <2 x i32> c, i32 1\" the type of the\n  /// transition is <2 x i32>.\n  Type *getTransitionType() const {\n    return Transition->getOperand(getTransitionOriginalValueIdx())->getType();\n  }\n\n  /// Promote \\p ToBePromoted by moving \\p Def downward through.\n  /// I.e., we have the following sequence:\n  /// Def = Transition <ty1> a to <ty2>\n  /// b = ToBePromoted <ty2> Def, ...\n  /// =>\n  /// b = ToBePromoted <ty1> a, ...\n  /// Def = Transition <ty1> ToBePromoted to <ty2>\n  void promoteImpl(Instruction *ToBePromoted);\n\n  /// Check whether or not it is profitable to promote all the\n  /// instructions enqueued to be promoted.\n  bool isProfitableToPromote() {\n    Value *ValIdx = Transition->getOperand(getTransitionOriginalValueIdx());\n    unsigned Index = isa<ConstantInt>(ValIdx)\n                         ? cast<ConstantInt>(ValIdx)->getZExtValue()\n                         : -1;\n    Type *PromotedType = getTransitionType();\n\n    StoreInst *ST = cast<StoreInst>(CombineInst);\n    unsigned AS = ST->getPointerAddressSpace();\n    // Check if this store is supported.\n    if (!TLI.allowsMisalignedMemoryAccesses(\n            TLI.getValueType(DL, ST->getValueOperand()->getType()), AS,\n            ST->getAlign())) {\n      // If this is not supported, there is no way we can combine\n      // the extract with the store.\n      return false;\n    }\n\n    // The scalar chain of computation has to pay for the transition\n    // scalar to vector.\n    // The vector chain has to account for the combining cost.\n    InstructionCost ScalarCost =\n        TTI.getVectorInstrCost(Transition->getOpcode(), PromotedType, Index);\n    InstructionCost VectorCost = StoreExtractCombineCost;\n    enum TargetTransformInfo::TargetCostKind CostKind =\n      TargetTransformInfo::TCK_RecipThroughput;\n    for (const auto &Inst : InstsToBePromoted) {\n      // Compute the cost.\n      // By construction, all instructions being promoted are arithmetic ones.\n      // Moreover, one argument is a constant that can be viewed as a splat\n      // constant.\n      Value *Arg0 = Inst->getOperand(0);\n      bool IsArg0Constant = isa<UndefValue>(Arg0) || isa<ConstantInt>(Arg0) ||\n                            isa<ConstantFP>(Arg0);\n      TargetTransformInfo::OperandValueKind Arg0OVK =\n          IsArg0Constant ? TargetTransformInfo::OK_UniformConstantValue\n                         : TargetTransformInfo::OK_AnyValue;\n      TargetTransformInfo::OperandValueKind Arg1OVK =\n          !IsArg0Constant ? TargetTransformInfo::OK_UniformConstantValue\n                          : TargetTransformInfo::OK_AnyValue;\n      ScalarCost += TTI.getArithmeticInstrCost(\n          Inst->getOpcode(), Inst->getType(), CostKind, Arg0OVK, Arg1OVK);\n      VectorCost += TTI.getArithmeticInstrCost(Inst->getOpcode(), PromotedType,\n                                               CostKind,\n                                               Arg0OVK, Arg1OVK);\n    }\n    LLVM_DEBUG(\n        dbgs() << \"Estimated cost of computation to be promoted:\\nScalar: \"\n               << ScalarCost << \"\\nVector: \" << VectorCost << '\\n');\n    return ScalarCost > VectorCost;\n  }\n\n  /// Generate a constant vector with \\p Val with the same\n  /// number of elements as the transition.\n  /// \\p UseSplat defines whether or not \\p Val should be replicated\n  /// across the whole vector.\n  /// In other words, if UseSplat == true, we generate <Val, Val, ..., Val>,\n  /// otherwise we generate a vector with as many undef as possible:\n  /// <undef, ..., undef, Val, undef, ..., undef> where \\p Val is only\n  /// used at the index of the extract.\n  Value *getConstantVector(Constant *Val, bool UseSplat) const {\n    unsigned ExtractIdx = std::numeric_limits<unsigned>::max();\n    if (!UseSplat) {\n      // If we cannot determine where the constant must be, we have to\n      // use a splat constant.\n      Value *ValExtractIdx = Transition->getOperand(getTransitionIdx());\n      if (ConstantInt *CstVal = dyn_cast<ConstantInt>(ValExtractIdx))\n        ExtractIdx = CstVal->getSExtValue();\n      else\n        UseSplat = true;\n    }\n\n    ElementCount EC = cast<VectorType>(getTransitionType())->getElementCount();\n    if (UseSplat)\n      return ConstantVector::getSplat(EC, Val);\n\n    if (!EC.isScalable()) {\n      SmallVector<Constant *, 4> ConstVec;\n      UndefValue *UndefVal = UndefValue::get(Val->getType());\n      for (unsigned Idx = 0; Idx != EC.getKnownMinValue(); ++Idx) {\n        if (Idx == ExtractIdx)\n          ConstVec.push_back(Val);\n        else\n          ConstVec.push_back(UndefVal);\n      }\n      return ConstantVector::get(ConstVec);\n    } else\n      llvm_unreachable(\n          \"Generate scalable vector for non-splat is unimplemented\");\n  }\n\n  /// Check if promoting to a vector type an operand at \\p OperandIdx\n  /// in \\p Use can trigger undefined behavior.\n  static bool canCauseUndefinedBehavior(const Instruction *Use,\n                                        unsigned OperandIdx) {\n    // This is not safe to introduce undef when the operand is on\n    // the right hand side of a division-like instruction.\n    if (OperandIdx != 1)\n      return false;\n    switch (Use->getOpcode()) {\n    default:\n      return false;\n    case Instruction::SDiv:\n    case Instruction::UDiv:\n    case Instruction::SRem:\n    case Instruction::URem:\n      return true;\n    case Instruction::FDiv:\n    case Instruction::FRem:\n      return !Use->hasNoNaNs();\n    }\n    llvm_unreachable(nullptr);\n  }\n\npublic:\n  VectorPromoteHelper(const DataLayout &DL, const TargetLowering &TLI,\n                      const TargetTransformInfo &TTI, Instruction *Transition,\n                      unsigned CombineCost)\n      : DL(DL), TLI(TLI), TTI(TTI), Transition(Transition),\n        StoreExtractCombineCost(CombineCost) {\n    assert(Transition && \"Do not know how to promote null\");\n  }\n\n  /// Check if we can promote \\p ToBePromoted to \\p Type.\n  bool canPromote(const Instruction *ToBePromoted) const {\n    // We could support CastInst too.\n    return isa<BinaryOperator>(ToBePromoted);\n  }\n\n  /// Check if it is profitable to promote \\p ToBePromoted\n  /// by moving downward the transition through.\n  bool shouldPromote(const Instruction *ToBePromoted) const {\n    // Promote only if all the operands can be statically expanded.\n    // Indeed, we do not want to introduce any new kind of transitions.\n    for (const Use &U : ToBePromoted->operands()) {\n      const Value *Val = U.get();\n      if (Val == getEndOfTransition()) {\n        // If the use is a division and the transition is on the rhs,\n        // we cannot promote the operation, otherwise we may create a\n        // division by zero.\n        if (canCauseUndefinedBehavior(ToBePromoted, U.getOperandNo()))\n          return false;\n        continue;\n      }\n      if (!isa<ConstantInt>(Val) && !isa<UndefValue>(Val) &&\n          !isa<ConstantFP>(Val))\n        return false;\n    }\n    // Check that the resulting operation is legal.\n    int ISDOpcode = TLI.InstructionOpcodeToISD(ToBePromoted->getOpcode());\n    if (!ISDOpcode)\n      return false;\n    return StressStoreExtract ||\n           TLI.isOperationLegalOrCustom(\n               ISDOpcode, TLI.getValueType(DL, getTransitionType(), true));\n  }\n\n  /// Check whether or not \\p Use can be combined\n  /// with the transition.\n  /// I.e., is it possible to do Use(Transition) => AnotherUse?\n  bool canCombine(const Instruction *Use) { return isa<StoreInst>(Use); }\n\n  /// Record \\p ToBePromoted as part of the chain to be promoted.\n  void enqueueForPromotion(Instruction *ToBePromoted) {\n    InstsToBePromoted.push_back(ToBePromoted);\n  }\n\n  /// Set the instruction that will be combined with the transition.\n  void recordCombineInstruction(Instruction *ToBeCombined) {\n    assert(canCombine(ToBeCombined) && \"Unsupported instruction to combine\");\n    CombineInst = ToBeCombined;\n  }\n\n  /// Promote all the instructions enqueued for promotion if it is\n  /// is profitable.\n  /// \\return True if the promotion happened, false otherwise.\n  bool promote() {\n    // Check if there is something to promote.\n    // Right now, if we do not have anything to combine with,\n    // we assume the promotion is not profitable.\n    if (InstsToBePromoted.empty() || !CombineInst)\n      return false;\n\n    // Check cost.\n    if (!StressStoreExtract && !isProfitableToPromote())\n      return false;\n\n    // Promote.\n    for (auto &ToBePromoted : InstsToBePromoted)\n      promoteImpl(ToBePromoted);\n    InstsToBePromoted.clear();\n    return true;\n  }\n};\n\n} // end anonymous namespace\n\nvoid VectorPromoteHelper::promoteImpl(Instruction *ToBePromoted) {\n  // At this point, we know that all the operands of ToBePromoted but Def\n  // can be statically promoted.\n  // For Def, we need to use its parameter in ToBePromoted:\n  // b = ToBePromoted ty1 a\n  // Def = Transition ty1 b to ty2\n  // Move the transition down.\n  // 1. Replace all uses of the promoted operation by the transition.\n  // = ... b => = ... Def.\n  assert(ToBePromoted->getType() == Transition->getType() &&\n         \"The type of the result of the transition does not match \"\n         \"the final type\");\n  ToBePromoted->replaceAllUsesWith(Transition);\n  // 2. Update the type of the uses.\n  // b = ToBePromoted ty2 Def => b = ToBePromoted ty1 Def.\n  Type *TransitionTy = getTransitionType();\n  ToBePromoted->mutateType(TransitionTy);\n  // 3. Update all the operands of the promoted operation with promoted\n  // operands.\n  // b = ToBePromoted ty1 Def => b = ToBePromoted ty1 a.\n  for (Use &U : ToBePromoted->operands()) {\n    Value *Val = U.get();\n    Value *NewVal = nullptr;\n    if (Val == Transition)\n      NewVal = Transition->getOperand(getTransitionOriginalValueIdx());\n    else if (isa<UndefValue>(Val) || isa<ConstantInt>(Val) ||\n             isa<ConstantFP>(Val)) {\n      // Use a splat constant if it is not safe to use undef.\n      NewVal = getConstantVector(\n          cast<Constant>(Val),\n          isa<UndefValue>(Val) ||\n              canCauseUndefinedBehavior(ToBePromoted, U.getOperandNo()));\n    } else\n      llvm_unreachable(\"Did you modified shouldPromote and forgot to update \"\n                       \"this?\");\n    ToBePromoted->setOperand(U.getOperandNo(), NewVal);\n  }\n  Transition->moveAfter(ToBePromoted);\n  Transition->setOperand(getTransitionOriginalValueIdx(), ToBePromoted);\n}\n\n/// Some targets can do store(extractelement) with one instruction.\n/// Try to push the extractelement towards the stores when the target\n/// has this feature and this is profitable.\nbool CodeGenPrepare::optimizeExtractElementInst(Instruction *Inst) {\n  unsigned CombineCost = std::numeric_limits<unsigned>::max();\n  if (DisableStoreExtract ||\n      (!StressStoreExtract &&\n       !TLI->canCombineStoreAndExtract(Inst->getOperand(0)->getType(),\n                                       Inst->getOperand(1), CombineCost)))\n    return false;\n\n  // At this point we know that Inst is a vector to scalar transition.\n  // Try to move it down the def-use chain, until:\n  // - We can combine the transition with its single use\n  //   => we got rid of the transition.\n  // - We escape the current basic block\n  //   => we would need to check that we are moving it at a cheaper place and\n  //      we do not do that for now.\n  BasicBlock *Parent = Inst->getParent();\n  LLVM_DEBUG(dbgs() << \"Found an interesting transition: \" << *Inst << '\\n');\n  VectorPromoteHelper VPH(*DL, *TLI, *TTI, Inst, CombineCost);\n  // If the transition has more than one use, assume this is not going to be\n  // beneficial.\n  while (Inst->hasOneUse()) {\n    Instruction *ToBePromoted = cast<Instruction>(*Inst->user_begin());\n    LLVM_DEBUG(dbgs() << \"Use: \" << *ToBePromoted << '\\n');\n\n    if (ToBePromoted->getParent() != Parent) {\n      LLVM_DEBUG(dbgs() << \"Instruction to promote is in a different block (\"\n                        << ToBePromoted->getParent()->getName()\n                        << \") than the transition (\" << Parent->getName()\n                        << \").\\n\");\n      return false;\n    }\n\n    if (VPH.canCombine(ToBePromoted)) {\n      LLVM_DEBUG(dbgs() << \"Assume \" << *Inst << '\\n'\n                        << \"will be combined with: \" << *ToBePromoted << '\\n');\n      VPH.recordCombineInstruction(ToBePromoted);\n      bool Changed = VPH.promote();\n      NumStoreExtractExposed += Changed;\n      return Changed;\n    }\n\n    LLVM_DEBUG(dbgs() << \"Try promoting.\\n\");\n    if (!VPH.canPromote(ToBePromoted) || !VPH.shouldPromote(ToBePromoted))\n      return false;\n\n    LLVM_DEBUG(dbgs() << \"Promoting is possible... Enqueue for promotion!\\n\");\n\n    VPH.enqueueForPromotion(ToBePromoted);\n    Inst = ToBePromoted;\n  }\n  return false;\n}\n\n/// For the instruction sequence of store below, F and I values\n/// are bundled together as an i64 value before being stored into memory.\n/// Sometimes it is more efficient to generate separate stores for F and I,\n/// which can remove the bitwise instructions or sink them to colder places.\n///\n///   (store (or (zext (bitcast F to i32) to i64),\n///              (shl (zext I to i64), 32)), addr)  -->\n///   (store F, addr) and (store I, addr+4)\n///\n/// Similarly, splitting for other merged store can also be beneficial, like:\n/// For pair of {i32, i32}, i64 store --> two i32 stores.\n/// For pair of {i32, i16}, i64 store --> two i32 stores.\n/// For pair of {i16, i16}, i32 store --> two i16 stores.\n/// For pair of {i16, i8},  i32 store --> two i16 stores.\n/// For pair of {i8, i8},   i16 store --> two i8 stores.\n///\n/// We allow each target to determine specifically which kind of splitting is\n/// supported.\n///\n/// The store patterns are commonly seen from the simple code snippet below\n/// if only std::make_pair(...) is sroa transformed before inlined into hoo.\n///   void goo(const std::pair<int, float> &);\n///   hoo() {\n///     ...\n///     goo(std::make_pair(tmp, ftmp));\n///     ...\n///   }\n///\n/// Although we already have similar splitting in DAG Combine, we duplicate\n/// it in CodeGenPrepare to catch the case in which pattern is across\n/// multiple BBs. The logic in DAG Combine is kept to catch case generated\n/// during code expansion.\nstatic bool splitMergedValStore(StoreInst &SI, const DataLayout &DL,\n                                const TargetLowering &TLI) {\n  // Handle simple but common cases only.\n  Type *StoreType = SI.getValueOperand()->getType();\n\n  // The code below assumes shifting a value by <number of bits>,\n  // whereas scalable vectors would have to be shifted by\n  // <2log(vscale) + number of bits> in order to store the\n  // low/high parts. Bailing out for now.\n  if (isa<ScalableVectorType>(StoreType))\n    return false;\n\n  if (!DL.typeSizeEqualsStoreSize(StoreType) ||\n      DL.getTypeSizeInBits(StoreType) == 0)\n    return false;\n\n  unsigned HalfValBitSize = DL.getTypeSizeInBits(StoreType) / 2;\n  Type *SplitStoreType = Type::getIntNTy(SI.getContext(), HalfValBitSize);\n  if (!DL.typeSizeEqualsStoreSize(SplitStoreType))\n    return false;\n\n  // Don't split the store if it is volatile.\n  if (SI.isVolatile())\n    return false;\n\n  // Match the following patterns:\n  // (store (or (zext LValue to i64),\n  //            (shl (zext HValue to i64), 32)), HalfValBitSize)\n  //  or\n  // (store (or (shl (zext HValue to i64), 32)), HalfValBitSize)\n  //            (zext LValue to i64),\n  // Expect both operands of OR and the first operand of SHL have only\n  // one use.\n  Value *LValue, *HValue;\n  if (!match(SI.getValueOperand(),\n             m_c_Or(m_OneUse(m_ZExt(m_Value(LValue))),\n                    m_OneUse(m_Shl(m_OneUse(m_ZExt(m_Value(HValue))),\n                                   m_SpecificInt(HalfValBitSize))))))\n    return false;\n\n  // Check LValue and HValue are int with size less or equal than 32.\n  if (!LValue->getType()->isIntegerTy() ||\n      DL.getTypeSizeInBits(LValue->getType()) > HalfValBitSize ||\n      !HValue->getType()->isIntegerTy() ||\n      DL.getTypeSizeInBits(HValue->getType()) > HalfValBitSize)\n    return false;\n\n  // If LValue/HValue is a bitcast instruction, use the EVT before bitcast\n  // as the input of target query.\n  auto *LBC = dyn_cast<BitCastInst>(LValue);\n  auto *HBC = dyn_cast<BitCastInst>(HValue);\n  EVT LowTy = LBC ? EVT::getEVT(LBC->getOperand(0)->getType())\n                  : EVT::getEVT(LValue->getType());\n  EVT HighTy = HBC ? EVT::getEVT(HBC->getOperand(0)->getType())\n                   : EVT::getEVT(HValue->getType());\n  if (!ForceSplitStore && !TLI.isMultiStoresCheaperThanBitsMerge(LowTy, HighTy))\n    return false;\n\n  // Start to split store.\n  IRBuilder<> Builder(SI.getContext());\n  Builder.SetInsertPoint(&SI);\n\n  // If LValue/HValue is a bitcast in another BB, create a new one in current\n  // BB so it may be merged with the splitted stores by dag combiner.\n  if (LBC && LBC->getParent() != SI.getParent())\n    LValue = Builder.CreateBitCast(LBC->getOperand(0), LBC->getType());\n  if (HBC && HBC->getParent() != SI.getParent())\n    HValue = Builder.CreateBitCast(HBC->getOperand(0), HBC->getType());\n\n  bool IsLE = SI.getModule()->getDataLayout().isLittleEndian();\n  auto CreateSplitStore = [&](Value *V, bool Upper) {\n    V = Builder.CreateZExtOrBitCast(V, SplitStoreType);\n    Value *Addr = Builder.CreateBitCast(\n        SI.getOperand(1),\n        SplitStoreType->getPointerTo(SI.getPointerAddressSpace()));\n    Align Alignment = SI.getAlign();\n    const bool IsOffsetStore = (IsLE && Upper) || (!IsLE && !Upper);\n    if (IsOffsetStore) {\n      Addr = Builder.CreateGEP(\n          SplitStoreType, Addr,\n          ConstantInt::get(Type::getInt32Ty(SI.getContext()), 1));\n\n      // When splitting the store in half, naturally one half will retain the\n      // alignment of the original wider store, regardless of whether it was\n      // over-aligned or not, while the other will require adjustment.\n      Alignment = commonAlignment(Alignment, HalfValBitSize / 8);\n    }\n    Builder.CreateAlignedStore(V, Addr, Alignment);\n  };\n\n  CreateSplitStore(LValue, false);\n  CreateSplitStore(HValue, true);\n\n  // Delete the old store.\n  SI.eraseFromParent();\n  return true;\n}\n\n// Return true if the GEP has two operands, the first operand is of a sequential\n// type, and the second operand is a constant.\nstatic bool GEPSequentialConstIndexed(GetElementPtrInst *GEP) {\n  gep_type_iterator I = gep_type_begin(*GEP);\n  return GEP->getNumOperands() == 2 &&\n      I.isSequential() &&\n      isa<ConstantInt>(GEP->getOperand(1));\n}\n\n// Try unmerging GEPs to reduce liveness interference (register pressure) across\n// IndirectBr edges. Since IndirectBr edges tend to touch on many blocks,\n// reducing liveness interference across those edges benefits global register\n// allocation. Currently handles only certain cases.\n//\n// For example, unmerge %GEPI and %UGEPI as below.\n//\n// ---------- BEFORE ----------\n// SrcBlock:\n//   ...\n//   %GEPIOp = ...\n//   ...\n//   %GEPI = gep %GEPIOp, Idx\n//   ...\n//   indirectbr ... [ label %DstB0, label %DstB1, ... label %DstBi ... ]\n//   (* %GEPI is alive on the indirectbr edges due to other uses ahead)\n//   (* %GEPIOp is alive on the indirectbr edges only because of it's used by\n//   %UGEPI)\n//\n// DstB0: ... (there may be a gep similar to %UGEPI to be unmerged)\n// DstB1: ... (there may be a gep similar to %UGEPI to be unmerged)\n// ...\n//\n// DstBi:\n//   ...\n//   %UGEPI = gep %GEPIOp, UIdx\n// ...\n// ---------------------------\n//\n// ---------- AFTER ----------\n// SrcBlock:\n//   ... (same as above)\n//    (* %GEPI is still alive on the indirectbr edges)\n//    (* %GEPIOp is no longer alive on the indirectbr edges as a result of the\n//    unmerging)\n// ...\n//\n// DstBi:\n//   ...\n//   %UGEPI = gep %GEPI, (UIdx-Idx)\n//   ...\n// ---------------------------\n//\n// The register pressure on the IndirectBr edges is reduced because %GEPIOp is\n// no longer alive on them.\n//\n// We try to unmerge GEPs here in CodGenPrepare, as opposed to limiting merging\n// of GEPs in the first place in InstCombiner::visitGetElementPtrInst() so as\n// not to disable further simplications and optimizations as a result of GEP\n// merging.\n//\n// Note this unmerging may increase the length of the data flow critical path\n// (the path from %GEPIOp to %UGEPI would go through %GEPI), which is a tradeoff\n// between the register pressure and the length of data-flow critical\n// path. Restricting this to the uncommon IndirectBr case would minimize the\n// impact of potentially longer critical path, if any, and the impact on compile\n// time.\nstatic bool tryUnmergingGEPsAcrossIndirectBr(GetElementPtrInst *GEPI,\n                                             const TargetTransformInfo *TTI) {\n  BasicBlock *SrcBlock = GEPI->getParent();\n  // Check that SrcBlock ends with an IndirectBr. If not, give up. The common\n  // (non-IndirectBr) cases exit early here.\n  if (!isa<IndirectBrInst>(SrcBlock->getTerminator()))\n    return false;\n  // Check that GEPI is a simple gep with a single constant index.\n  if (!GEPSequentialConstIndexed(GEPI))\n    return false;\n  ConstantInt *GEPIIdx = cast<ConstantInt>(GEPI->getOperand(1));\n  // Check that GEPI is a cheap one.\n  if (TTI->getIntImmCost(GEPIIdx->getValue(), GEPIIdx->getType(),\n                         TargetTransformInfo::TCK_SizeAndLatency)\n      > TargetTransformInfo::TCC_Basic)\n    return false;\n  Value *GEPIOp = GEPI->getOperand(0);\n  // Check that GEPIOp is an instruction that's also defined in SrcBlock.\n  if (!isa<Instruction>(GEPIOp))\n    return false;\n  auto *GEPIOpI = cast<Instruction>(GEPIOp);\n  if (GEPIOpI->getParent() != SrcBlock)\n    return false;\n  // Check that GEP is used outside the block, meaning it's alive on the\n  // IndirectBr edge(s).\n  if (find_if(GEPI->users(), [&](User *Usr) {\n        if (auto *I = dyn_cast<Instruction>(Usr)) {\n          if (I->getParent() != SrcBlock) {\n            return true;\n          }\n        }\n        return false;\n      }) == GEPI->users().end())\n    return false;\n  // The second elements of the GEP chains to be unmerged.\n  std::vector<GetElementPtrInst *> UGEPIs;\n  // Check each user of GEPIOp to check if unmerging would make GEPIOp not alive\n  // on IndirectBr edges.\n  for (User *Usr : GEPIOp->users()) {\n    if (Usr == GEPI) continue;\n    // Check if Usr is an Instruction. If not, give up.\n    if (!isa<Instruction>(Usr))\n      return false;\n    auto *UI = cast<Instruction>(Usr);\n    // Check if Usr in the same block as GEPIOp, which is fine, skip.\n    if (UI->getParent() == SrcBlock)\n      continue;\n    // Check if Usr is a GEP. If not, give up.\n    if (!isa<GetElementPtrInst>(Usr))\n      return false;\n    auto *UGEPI = cast<GetElementPtrInst>(Usr);\n    // Check if UGEPI is a simple gep with a single constant index and GEPIOp is\n    // the pointer operand to it. If so, record it in the vector. If not, give\n    // up.\n    if (!GEPSequentialConstIndexed(UGEPI))\n      return false;\n    if (UGEPI->getOperand(0) != GEPIOp)\n      return false;\n    if (GEPIIdx->getType() !=\n        cast<ConstantInt>(UGEPI->getOperand(1))->getType())\n      return false;\n    ConstantInt *UGEPIIdx = cast<ConstantInt>(UGEPI->getOperand(1));\n    if (TTI->getIntImmCost(UGEPIIdx->getValue(), UGEPIIdx->getType(),\n                           TargetTransformInfo::TCK_SizeAndLatency)\n        > TargetTransformInfo::TCC_Basic)\n      return false;\n    UGEPIs.push_back(UGEPI);\n  }\n  if (UGEPIs.size() == 0)\n    return false;\n  // Check the materializing cost of (Uidx-Idx).\n  for (GetElementPtrInst *UGEPI : UGEPIs) {\n    ConstantInt *UGEPIIdx = cast<ConstantInt>(UGEPI->getOperand(1));\n    APInt NewIdx = UGEPIIdx->getValue() - GEPIIdx->getValue();\n    unsigned ImmCost =\n      TTI->getIntImmCost(NewIdx, GEPIIdx->getType(),\n                         TargetTransformInfo::TCK_SizeAndLatency);\n    if (ImmCost > TargetTransformInfo::TCC_Basic)\n      return false;\n  }\n  // Now unmerge between GEPI and UGEPIs.\n  for (GetElementPtrInst *UGEPI : UGEPIs) {\n    UGEPI->setOperand(0, GEPI);\n    ConstantInt *UGEPIIdx = cast<ConstantInt>(UGEPI->getOperand(1));\n    Constant *NewUGEPIIdx =\n        ConstantInt::get(GEPIIdx->getType(),\n                         UGEPIIdx->getValue() - GEPIIdx->getValue());\n    UGEPI->setOperand(1, NewUGEPIIdx);\n    // If GEPI is not inbounds but UGEPI is inbounds, change UGEPI to not\n    // inbounds to avoid UB.\n    if (!GEPI->isInBounds()) {\n      UGEPI->setIsInBounds(false);\n    }\n  }\n  // After unmerging, verify that GEPIOp is actually only used in SrcBlock (not\n  // alive on IndirectBr edges).\n  assert(find_if(GEPIOp->users(), [&](User *Usr) {\n        return cast<Instruction>(Usr)->getParent() != SrcBlock;\n      }) == GEPIOp->users().end() && \"GEPIOp is used outside SrcBlock\");\n  return true;\n}\n\nbool CodeGenPrepare::optimizeInst(Instruction *I, bool &ModifiedDT) {\n  // Bail out if we inserted the instruction to prevent optimizations from\n  // stepping on each other's toes.\n  if (InsertedInsts.count(I))\n    return false;\n\n  // TODO: Move into the switch on opcode below here.\n  if (PHINode *P = dyn_cast<PHINode>(I)) {\n    // It is possible for very late stage optimizations (such as SimplifyCFG)\n    // to introduce PHI nodes too late to be cleaned up.  If we detect such a\n    // trivial PHI, go ahead and zap it here.\n    if (Value *V = SimplifyInstruction(P, {*DL, TLInfo})) {\n      LargeOffsetGEPMap.erase(P);\n      P->replaceAllUsesWith(V);\n      P->eraseFromParent();\n      ++NumPHIsElim;\n      return true;\n    }\n    return false;\n  }\n\n  if (CastInst *CI = dyn_cast<CastInst>(I)) {\n    // If the source of the cast is a constant, then this should have\n    // already been constant folded.  The only reason NOT to constant fold\n    // it is if something (e.g. LSR) was careful to place the constant\n    // evaluation in a block other than then one that uses it (e.g. to hoist\n    // the address of globals out of a loop).  If this is the case, we don't\n    // want to forward-subst the cast.\n    if (isa<Constant>(CI->getOperand(0)))\n      return false;\n\n    if (OptimizeNoopCopyExpression(CI, *TLI, *DL))\n      return true;\n\n    if (isa<ZExtInst>(I) || isa<SExtInst>(I)) {\n      /// Sink a zext or sext into its user blocks if the target type doesn't\n      /// fit in one register\n      if (TLI->getTypeAction(CI->getContext(),\n                             TLI->getValueType(*DL, CI->getType())) ==\n          TargetLowering::TypeExpandInteger) {\n        return SinkCast(CI);\n      } else {\n        bool MadeChange = optimizeExt(I);\n        return MadeChange | optimizeExtUses(I);\n      }\n    }\n    return false;\n  }\n\n  if (auto *Cmp = dyn_cast<CmpInst>(I))\n    if (optimizeCmp(Cmp, ModifiedDT))\n      return true;\n\n  if (LoadInst *LI = dyn_cast<LoadInst>(I)) {\n    LI->setMetadata(LLVMContext::MD_invariant_group, nullptr);\n    bool Modified = optimizeLoadExt(LI);\n    unsigned AS = LI->getPointerAddressSpace();\n    Modified |= optimizeMemoryInst(I, I->getOperand(0), LI->getType(), AS);\n    return Modified;\n  }\n\n  if (StoreInst *SI = dyn_cast<StoreInst>(I)) {\n    if (splitMergedValStore(*SI, *DL, *TLI))\n      return true;\n    SI->setMetadata(LLVMContext::MD_invariant_group, nullptr);\n    unsigned AS = SI->getPointerAddressSpace();\n    return optimizeMemoryInst(I, SI->getOperand(1),\n                              SI->getOperand(0)->getType(), AS);\n  }\n\n  if (AtomicRMWInst *RMW = dyn_cast<AtomicRMWInst>(I)) {\n      unsigned AS = RMW->getPointerAddressSpace();\n      return optimizeMemoryInst(I, RMW->getPointerOperand(),\n                                RMW->getType(), AS);\n  }\n\n  if (AtomicCmpXchgInst *CmpX = dyn_cast<AtomicCmpXchgInst>(I)) {\n      unsigned AS = CmpX->getPointerAddressSpace();\n      return optimizeMemoryInst(I, CmpX->getPointerOperand(),\n                                CmpX->getCompareOperand()->getType(), AS);\n  }\n\n  BinaryOperator *BinOp = dyn_cast<BinaryOperator>(I);\n\n  if (BinOp && (BinOp->getOpcode() == Instruction::And) && EnableAndCmpSinking)\n    return sinkAndCmp0Expression(BinOp, *TLI, InsertedInsts);\n\n  // TODO: Move this into the switch on opcode - it handles shifts already.\n  if (BinOp && (BinOp->getOpcode() == Instruction::AShr ||\n                BinOp->getOpcode() == Instruction::LShr)) {\n    ConstantInt *CI = dyn_cast<ConstantInt>(BinOp->getOperand(1));\n    if (CI && TLI->hasExtractBitsInsn())\n      if (OptimizeExtractBits(BinOp, CI, *TLI, *DL))\n        return true;\n  }\n\n  if (GetElementPtrInst *GEPI = dyn_cast<GetElementPtrInst>(I)) {\n    if (GEPI->hasAllZeroIndices()) {\n      /// The GEP operand must be a pointer, so must its result -> BitCast\n      Instruction *NC = new BitCastInst(GEPI->getOperand(0), GEPI->getType(),\n                                        GEPI->getName(), GEPI);\n      NC->setDebugLoc(GEPI->getDebugLoc());\n      GEPI->replaceAllUsesWith(NC);\n      GEPI->eraseFromParent();\n      ++NumGEPsElim;\n      optimizeInst(NC, ModifiedDT);\n      return true;\n    }\n    if (tryUnmergingGEPsAcrossIndirectBr(GEPI, TTI)) {\n      return true;\n    }\n    return false;\n  }\n\n  if (FreezeInst *FI = dyn_cast<FreezeInst>(I)) {\n    // freeze(icmp a, const)) -> icmp (freeze a), const\n    // This helps generate efficient conditional jumps.\n    Instruction *CmpI = nullptr;\n    if (ICmpInst *II = dyn_cast<ICmpInst>(FI->getOperand(0)))\n      CmpI = II;\n    else if (FCmpInst *F = dyn_cast<FCmpInst>(FI->getOperand(0)))\n      CmpI = F->getFastMathFlags().none() ? F : nullptr;\n\n    if (CmpI && CmpI->hasOneUse()) {\n      auto Op0 = CmpI->getOperand(0), Op1 = CmpI->getOperand(1);\n      bool Const0 = isa<ConstantInt>(Op0) || isa<ConstantFP>(Op0) ||\n                    isa<ConstantPointerNull>(Op0);\n      bool Const1 = isa<ConstantInt>(Op1) || isa<ConstantFP>(Op1) ||\n                    isa<ConstantPointerNull>(Op1);\n      if (Const0 || Const1) {\n        if (!Const0 || !Const1) {\n          auto *F = new FreezeInst(Const0 ? Op1 : Op0, \"\", CmpI);\n          F->takeName(FI);\n          CmpI->setOperand(Const0 ? 1 : 0, F);\n        }\n        FI->replaceAllUsesWith(CmpI);\n        FI->eraseFromParent();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  if (tryToSinkFreeOperands(I))\n    return true;\n\n  switch (I->getOpcode()) {\n  case Instruction::Shl:\n  case Instruction::LShr:\n  case Instruction::AShr:\n    return optimizeShiftInst(cast<BinaryOperator>(I));\n  case Instruction::Call:\n    return optimizeCallInst(cast<CallInst>(I), ModifiedDT);\n  case Instruction::Select:\n    return optimizeSelectInst(cast<SelectInst>(I));\n  case Instruction::ShuffleVector:\n    return optimizeShuffleVectorInst(cast<ShuffleVectorInst>(I));\n  case Instruction::Switch:\n    return optimizeSwitchInst(cast<SwitchInst>(I));\n  case Instruction::ExtractElement:\n    return optimizeExtractElementInst(cast<ExtractElementInst>(I));\n  }\n\n  return false;\n}\n\n/// Given an OR instruction, check to see if this is a bitreverse\n/// idiom. If so, insert the new intrinsic and return true.\nbool CodeGenPrepare::makeBitReverse(Instruction &I) {\n  if (!I.getType()->isIntegerTy() ||\n      !TLI->isOperationLegalOrCustom(ISD::BITREVERSE,\n                                     TLI->getValueType(*DL, I.getType(), true)))\n    return false;\n\n  SmallVector<Instruction*, 4> Insts;\n  if (!recognizeBSwapOrBitReverseIdiom(&I, false, true, Insts))\n    return false;\n  Instruction *LastInst = Insts.back();\n  I.replaceAllUsesWith(LastInst);\n  RecursivelyDeleteTriviallyDeadInstructions(\n      &I, TLInfo, nullptr, [&](Value *V) { removeAllAssertingVHReferences(V); });\n  return true;\n}\n\n// In this pass we look for GEP and cast instructions that are used\n// across basic blocks and rewrite them to improve basic-block-at-a-time\n// selection.\nbool CodeGenPrepare::optimizeBlock(BasicBlock &BB, bool &ModifiedDT) {\n  SunkAddrs.clear();\n  bool MadeChange = false;\n\n  CurInstIterator = BB.begin();\n  while (CurInstIterator != BB.end()) {\n    MadeChange |= optimizeInst(&*CurInstIterator++, ModifiedDT);\n    if (ModifiedDT)\n      return true;\n  }\n\n  bool MadeBitReverse = true;\n  while (MadeBitReverse) {\n    MadeBitReverse = false;\n    for (auto &I : reverse(BB)) {\n      if (makeBitReverse(I)) {\n        MadeBitReverse = MadeChange = true;\n        break;\n      }\n    }\n  }\n  MadeChange |= dupRetToEnableTailCallOpts(&BB, ModifiedDT);\n\n  return MadeChange;\n}\n\n// Some CGP optimizations may move or alter what's computed in a block. Check\n// whether a dbg.value intrinsic could be pointed at a more appropriate operand.\nbool CodeGenPrepare::fixupDbgValue(Instruction *I) {\n  assert(isa<DbgValueInst>(I));\n  DbgValueInst &DVI = *cast<DbgValueInst>(I);\n\n  // Does this dbg.value refer to a sunk address calculation?\n  bool AnyChange = false;\n  for (Value *Location : DVI.getValues()) {\n    WeakTrackingVH SunkAddrVH = SunkAddrs[Location];\n    Value *SunkAddr = SunkAddrVH.pointsToAliveValue() ? SunkAddrVH : nullptr;\n    if (SunkAddr) {\n      // Point dbg.value at locally computed address, which should give the best\n      // opportunity to be accurately lowered. This update may change the type\n      // of pointer being referred to; however this makes no difference to\n      // debugging information, and we can't generate bitcasts that may affect\n      // codegen.\n      DVI.replaceVariableLocationOp(Location, SunkAddr);\n      AnyChange = true;\n    }\n  }\n  return AnyChange;\n}\n\n// A llvm.dbg.value may be using a value before its definition, due to\n// optimizations in this pass and others. Scan for such dbg.values, and rescue\n// them by moving the dbg.value to immediately after the value definition.\n// FIXME: Ideally this should never be necessary, and this has the potential\n// to re-order dbg.value intrinsics.\nbool CodeGenPrepare::placeDbgValues(Function &F) {\n  bool MadeChange = false;\n  DominatorTree DT(F);\n\n  for (BasicBlock &BB : F) {\n    for (BasicBlock::iterator BI = BB.begin(), BE = BB.end(); BI != BE;) {\n      Instruction *Insn = &*BI++;\n      DbgValueInst *DVI = dyn_cast<DbgValueInst>(Insn);\n      if (!DVI)\n        continue;\n\n      SmallVector<Instruction *, 4> VIs;\n      for (Value *V : DVI->getValues())\n        if (Instruction *VI = dyn_cast_or_null<Instruction>(V))\n          VIs.push_back(VI);\n\n      // This DVI may depend on multiple instructions, complicating any\n      // potential sink. This block takes the defensive approach, opting to\n      // \"undef\" the DVI if it has more than one instruction and any of them do\n      // not dominate DVI.\n      for (Instruction *VI : VIs) {\n        if (VI->isTerminator())\n          continue;\n\n        // If VI is a phi in a block with an EHPad terminator, we can't insert\n        // after it.\n        if (isa<PHINode>(VI) && VI->getParent()->getTerminator()->isEHPad())\n          continue;\n\n        // If the defining instruction dominates the dbg.value, we do not need\n        // to move the dbg.value.\n        if (DT.dominates(VI, DVI))\n          continue;\n\n        // If we depend on multiple instructions and any of them doesn't\n        // dominate this DVI, we probably can't salvage it: moving it to\n        // after any of the instructions could cause us to lose the others.\n        if (VIs.size() > 1) {\n          LLVM_DEBUG(\n              dbgs()\n              << \"Unable to find valid location for Debug Value, undefing:\\n\"\n              << *DVI);\n          DVI->setUndef();\n          break;\n        }\n\n        LLVM_DEBUG(dbgs() << \"Moving Debug Value before :\\n\"\n                          << *DVI << ' ' << *VI);\n        DVI->removeFromParent();\n        if (isa<PHINode>(VI))\n          DVI->insertBefore(&*VI->getParent()->getFirstInsertionPt());\n        else\n          DVI->insertAfter(VI);\n        MadeChange = true;\n        ++NumDbgValueMoved;\n      }\n    }\n  }\n  return MadeChange;\n}\n\n/// Scale down both weights to fit into uint32_t.\nstatic void scaleWeights(uint64_t &NewTrue, uint64_t &NewFalse) {\n  uint64_t NewMax = (NewTrue > NewFalse) ? NewTrue : NewFalse;\n  uint32_t Scale = (NewMax / std::numeric_limits<uint32_t>::max()) + 1;\n  NewTrue = NewTrue / Scale;\n  NewFalse = NewFalse / Scale;\n}\n\n/// Some targets prefer to split a conditional branch like:\n/// \\code\n///   %0 = icmp ne i32 %a, 0\n///   %1 = icmp ne i32 %b, 0\n///   %or.cond = or i1 %0, %1\n///   br i1 %or.cond, label %TrueBB, label %FalseBB\n/// \\endcode\n/// into multiple branch instructions like:\n/// \\code\n///   bb1:\n///     %0 = icmp ne i32 %a, 0\n///     br i1 %0, label %TrueBB, label %bb2\n///   bb2:\n///     %1 = icmp ne i32 %b, 0\n///     br i1 %1, label %TrueBB, label %FalseBB\n/// \\endcode\n/// This usually allows instruction selection to do even further optimizations\n/// and combine the compare with the branch instruction. Currently this is\n/// applied for targets which have \"cheap\" jump instructions.\n///\n/// FIXME: Remove the (equivalent?) implementation in SelectionDAG.\n///\nbool CodeGenPrepare::splitBranchCondition(Function &F, bool &ModifiedDT) {\n  if (!TM->Options.EnableFastISel || TLI->isJumpExpensive())\n    return false;\n\n  bool MadeChange = false;\n  for (auto &BB : F) {\n    // Does this BB end with the following?\n    //   %cond1 = icmp|fcmp|binary instruction ...\n    //   %cond2 = icmp|fcmp|binary instruction ...\n    //   %cond.or = or|and i1 %cond1, cond2\n    //   br i1 %cond.or label %dest1, label %dest2\"\n    Instruction *LogicOp;\n    BasicBlock *TBB, *FBB;\n    if (!match(BB.getTerminator(),\n               m_Br(m_OneUse(m_Instruction(LogicOp)), TBB, FBB)))\n      continue;\n\n    auto *Br1 = cast<BranchInst>(BB.getTerminator());\n    if (Br1->getMetadata(LLVMContext::MD_unpredictable))\n      continue;\n\n    // The merging of mostly empty BB can cause a degenerate branch.\n    if (TBB == FBB)\n      continue;\n\n    unsigned Opc;\n    Value *Cond1, *Cond2;\n    if (match(LogicOp,\n              m_LogicalAnd(m_OneUse(m_Value(Cond1)), m_OneUse(m_Value(Cond2)))))\n      Opc = Instruction::And;\n    else if (match(LogicOp, m_LogicalOr(m_OneUse(m_Value(Cond1)),\n                                        m_OneUse(m_Value(Cond2)))))\n      Opc = Instruction::Or;\n    else\n      continue;\n\n    auto IsGoodCond = [](Value *Cond) {\n      return match(\n          Cond,\n          m_CombineOr(m_Cmp(), m_CombineOr(m_LogicalAnd(m_Value(), m_Value()),\n                                           m_LogicalOr(m_Value(), m_Value()))));\n    };\n    if (!IsGoodCond(Cond1) || !IsGoodCond(Cond2))\n      continue;\n\n    LLVM_DEBUG(dbgs() << \"Before branch condition splitting\\n\"; BB.dump());\n\n    // Create a new BB.\n    auto *TmpBB =\n        BasicBlock::Create(BB.getContext(), BB.getName() + \".cond.split\",\n                           BB.getParent(), BB.getNextNode());\n\n    // Update original basic block by using the first condition directly by the\n    // branch instruction and removing the no longer needed and/or instruction.\n    Br1->setCondition(Cond1);\n    LogicOp->eraseFromParent();\n\n    // Depending on the condition we have to either replace the true or the\n    // false successor of the original branch instruction.\n    if (Opc == Instruction::And)\n      Br1->setSuccessor(0, TmpBB);\n    else\n      Br1->setSuccessor(1, TmpBB);\n\n    // Fill in the new basic block.\n    auto *Br2 = IRBuilder<>(TmpBB).CreateCondBr(Cond2, TBB, FBB);\n    if (auto *I = dyn_cast<Instruction>(Cond2)) {\n      I->removeFromParent();\n      I->insertBefore(Br2);\n    }\n\n    // Update PHI nodes in both successors. The original BB needs to be\n    // replaced in one successor's PHI nodes, because the branch comes now from\n    // the newly generated BB (NewBB). In the other successor we need to add one\n    // incoming edge to the PHI nodes, because both branch instructions target\n    // now the same successor. Depending on the original branch condition\n    // (and/or) we have to swap the successors (TrueDest, FalseDest), so that\n    // we perform the correct update for the PHI nodes.\n    // This doesn't change the successor order of the just created branch\n    // instruction (or any other instruction).\n    if (Opc == Instruction::Or)\n      std::swap(TBB, FBB);\n\n    // Replace the old BB with the new BB.\n    TBB->replacePhiUsesWith(&BB, TmpBB);\n\n    // Add another incoming edge form the new BB.\n    for (PHINode &PN : FBB->phis()) {\n      auto *Val = PN.getIncomingValueForBlock(&BB);\n      PN.addIncoming(Val, TmpBB);\n    }\n\n    // Update the branch weights (from SelectionDAGBuilder::\n    // FindMergedConditions).\n    if (Opc == Instruction::Or) {\n      // Codegen X | Y as:\n      // BB1:\n      //   jmp_if_X TBB\n      //   jmp TmpBB\n      // TmpBB:\n      //   jmp_if_Y TBB\n      //   jmp FBB\n      //\n\n      // We have flexibility in setting Prob for BB1 and Prob for NewBB.\n      // The requirement is that\n      //   TrueProb for BB1 + (FalseProb for BB1 * TrueProb for TmpBB)\n      //     = TrueProb for original BB.\n      // Assuming the original weights are A and B, one choice is to set BB1's\n      // weights to A and A+2B, and set TmpBB's weights to A and 2B. This choice\n      // assumes that\n      //   TrueProb for BB1 == FalseProb for BB1 * TrueProb for TmpBB.\n      // Another choice is to assume TrueProb for BB1 equals to TrueProb for\n      // TmpBB, but the math is more complicated.\n      uint64_t TrueWeight, FalseWeight;\n      if (Br1->extractProfMetadata(TrueWeight, FalseWeight)) {\n        uint64_t NewTrueWeight = TrueWeight;\n        uint64_t NewFalseWeight = TrueWeight + 2 * FalseWeight;\n        scaleWeights(NewTrueWeight, NewFalseWeight);\n        Br1->setMetadata(LLVMContext::MD_prof, MDBuilder(Br1->getContext())\n                         .createBranchWeights(TrueWeight, FalseWeight));\n\n        NewTrueWeight = TrueWeight;\n        NewFalseWeight = 2 * FalseWeight;\n        scaleWeights(NewTrueWeight, NewFalseWeight);\n        Br2->setMetadata(LLVMContext::MD_prof, MDBuilder(Br2->getContext())\n                         .createBranchWeights(TrueWeight, FalseWeight));\n      }\n    } else {\n      // Codegen X & Y as:\n      // BB1:\n      //   jmp_if_X TmpBB\n      //   jmp FBB\n      // TmpBB:\n      //   jmp_if_Y TBB\n      //   jmp FBB\n      //\n      //  This requires creation of TmpBB after CurBB.\n\n      // We have flexibility in setting Prob for BB1 and Prob for TmpBB.\n      // The requirement is that\n      //   FalseProb for BB1 + (TrueProb for BB1 * FalseProb for TmpBB)\n      //     = FalseProb for original BB.\n      // Assuming the original weights are A and B, one choice is to set BB1's\n      // weights to 2A+B and B, and set TmpBB's weights to 2A and B. This choice\n      // assumes that\n      //   FalseProb for BB1 == TrueProb for BB1 * FalseProb for TmpBB.\n      uint64_t TrueWeight, FalseWeight;\n      if (Br1->extractProfMetadata(TrueWeight, FalseWeight)) {\n        uint64_t NewTrueWeight = 2 * TrueWeight + FalseWeight;\n        uint64_t NewFalseWeight = FalseWeight;\n        scaleWeights(NewTrueWeight, NewFalseWeight);\n        Br1->setMetadata(LLVMContext::MD_prof, MDBuilder(Br1->getContext())\n                         .createBranchWeights(TrueWeight, FalseWeight));\n\n        NewTrueWeight = 2 * TrueWeight;\n        NewFalseWeight = FalseWeight;\n        scaleWeights(NewTrueWeight, NewFalseWeight);\n        Br2->setMetadata(LLVMContext::MD_prof, MDBuilder(Br2->getContext())\n                         .createBranchWeights(TrueWeight, FalseWeight));\n      }\n    }\n\n    ModifiedDT = true;\n    MadeChange = true;\n\n    LLVM_DEBUG(dbgs() << \"After branch condition splitting\\n\"; BB.dump();\n               TmpBB->dump());\n  }\n  return MadeChange;\n}\n"}}, "reports": [{"events": [{"location": {"col": 8, "file": 79, "line": 3211}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp", "reportHash": "b1ae70c2f97375ae8c1ad105c08e5ff8", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 79, "line": 3212}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp", "reportHash": "33b8e1cfb2a9816f1a181359a0e230f2", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 26, "file": 79, "line": 3332}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp", "reportHash": "fedc76663a8aa1f226a8f93c5e897833", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 26, "file": 79, "line": 3336}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp", "reportHash": "e8403cf47bc654e2f588361554f71a60", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
