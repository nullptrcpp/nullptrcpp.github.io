<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"5": {"id": 5, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "content": "//===- llvm/ADT/DenseMap.h - Dense probed hash table ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the DenseMap class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_DENSEMAP_H\n#define LLVM_ADT_DENSEMAP_H\n\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/EpochTracker.h\"\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/MemAlloc.h\"\n#include \"llvm/Support/ReverseIteration.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstring>\n#include <initializer_list>\n#include <iterator>\n#include <new>\n#include <type_traits>\n#include <utility>\n\nnamespace llvm {\n\nnamespace detail {\n\n// We extend a pair to allow users to override the bucket type with their own\n// implementation without requiring two members.\ntemplate <typename KeyT, typename ValueT>\nstruct DenseMapPair : public std::pair<KeyT, ValueT> {\n  using std::pair<KeyT, ValueT>::pair;\n\n  KeyT &getFirst() { return std::pair<KeyT, ValueT>::first; }\n  const KeyT &getFirst() const { return std::pair<KeyT, ValueT>::first; }\n  ValueT &getSecond() { return std::pair<KeyT, ValueT>::second; }\n  const ValueT &getSecond() const { return std::pair<KeyT, ValueT>::second; }\n};\n\n} // end namespace detail\n\ntemplate <typename KeyT, typename ValueT,\n          typename KeyInfoT = DenseMapInfo<KeyT>,\n          typename Bucket = llvm::detail::DenseMapPair<KeyT, ValueT>,\n          bool IsConst = false>\nclass DenseMapIterator;\n\ntemplate <typename DerivedT, typename KeyT, typename ValueT, typename KeyInfoT,\n          typename BucketT>\nclass DenseMapBase : public DebugEpochBase {\n  template <typename T>\n  using const_arg_type_t = typename const_pointer_or_const_ref<T>::type;\n\npublic:\n  using size_type = unsigned;\n  using key_type = KeyT;\n  using mapped_type = ValueT;\n  using value_type = BucketT;\n\n  using iterator = DenseMapIterator<KeyT, ValueT, KeyInfoT, BucketT>;\n  using const_iterator =\n      DenseMapIterator<KeyT, ValueT, KeyInfoT, BucketT, true>;\n\n  inline iterator begin() {\n    // When the map is empty, avoid the overhead of advancing/retreating past\n    // empty buckets.\n    if (empty())\n      return end();\n    if (shouldReverseIterate<KeyT>())\n      return makeIterator(getBucketsEnd() - 1, getBuckets(), *this);\n    return makeIterator(getBuckets(), getBucketsEnd(), *this);\n  }\n  inline iterator end() {\n    return makeIterator(getBucketsEnd(), getBucketsEnd(), *this, true);\n  }\n  inline const_iterator begin() const {\n    if (empty())\n      return end();\n    if (shouldReverseIterate<KeyT>())\n      return makeConstIterator(getBucketsEnd() - 1, getBuckets(), *this);\n    return makeConstIterator(getBuckets(), getBucketsEnd(), *this);\n  }\n  inline const_iterator end() const {\n    return makeConstIterator(getBucketsEnd(), getBucketsEnd(), *this, true);\n  }\n\n  LLVM_NODISCARD bool empty() const {\n    return getNumEntries() == 0;\n  }\n  unsigned size() const { return getNumEntries(); }\n\n  /// Grow the densemap so that it can contain at least \\p NumEntries items\n  /// before resizing again.\n  void reserve(size_type NumEntries) {\n    auto NumBuckets = getMinBucketToReserveForEntries(NumEntries);\n    incrementEpoch();\n    if (NumBuckets > getNumBuckets())\n      grow(NumBuckets);\n  }\n\n  void clear() {\n    incrementEpoch();\n    if (getNumEntries() == 0 && getNumTombstones() == 0) return;\n\n    // If the capacity of the array is huge, and the # elements used is small,\n    // shrink the array.\n    if (getNumEntries() * 4 < getNumBuckets() && getNumBuckets() > 64) {\n      shrink_and_clear();\n      return;\n    }\n\n    const KeyT EmptyKey = getEmptyKey(), TombstoneKey = getTombstoneKey();\n    if (std::is_trivially_destructible<ValueT>::value) {\n      // Use a simpler loop when values don't need destruction.\n      for (BucketT *P = getBuckets(), *E = getBucketsEnd(); P != E; ++P)\n        P->getFirst() = EmptyKey;\n    } else {\n      unsigned NumEntries = getNumEntries();\n      for (BucketT *P = getBuckets(), *E = getBucketsEnd(); P != E; ++P) {\n        if (!KeyInfoT::isEqual(P->getFirst(), EmptyKey)) {\n          if (!KeyInfoT::isEqual(P->getFirst(), TombstoneKey)) {\n            P->getSecond().~ValueT();\n            --NumEntries;\n          }\n          P->getFirst() = EmptyKey;\n        }\n      }\n      assert(NumEntries == 0 && \"Node count imbalance!\");\n    }\n    setNumEntries(0);\n    setNumTombstones(0);\n  }\n\n  /// Return 1 if the specified key is in the map, 0 otherwise.\n  size_type count(const_arg_type_t<KeyT> Val) const {\n    const BucketT *TheBucket;\n    return LookupBucketFor(Val, TheBucket) ? 1 : 0;\n  }\n\n  iterator find(const_arg_type_t<KeyT> Val) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeIterator(TheBucket,\n                          shouldReverseIterate<KeyT>() ? getBuckets()\n                                                       : getBucketsEnd(),\n                          *this, true);\n    return end();\n  }\n  const_iterator find(const_arg_type_t<KeyT> Val) const {\n    const BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeConstIterator(TheBucket,\n                               shouldReverseIterate<KeyT>() ? getBuckets()\n                                                            : getBucketsEnd(),\n                               *this, true);\n    return end();\n  }\n\n  /// Alternate version of find() which allows a different, and possibly\n  /// less expensive, key type.\n  /// The DenseMapInfo is responsible for supplying methods\n  /// getHashValue(LookupKeyT) and isEqual(LookupKeyT, KeyT) for each key\n  /// type used.\n  template<class LookupKeyT>\n  iterator find_as(const LookupKeyT &Val) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeIterator(TheBucket,\n                          shouldReverseIterate<KeyT>() ? getBuckets()\n                                                       : getBucketsEnd(),\n                          *this, true);\n    return end();\n  }\n  template<class LookupKeyT>\n  const_iterator find_as(const LookupKeyT &Val) const {\n    const BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeConstIterator(TheBucket,\n                               shouldReverseIterate<KeyT>() ? getBuckets()\n                                                            : getBucketsEnd(),\n                               *this, true);\n    return end();\n  }\n\n  /// lookup - Return the entry for the specified key, or a default\n  /// constructed value if no such entry exists.\n  ValueT lookup(const_arg_type_t<KeyT> Val) const {\n    const BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return TheBucket->getSecond();\n    return ValueT();\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // If the key is already in the map, it returns false and doesn't update the\n  // value.\n  std::pair<iterator, bool> insert(const std::pair<KeyT, ValueT> &KV) {\n    return try_emplace(KV.first, KV.second);\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // If the key is already in the map, it returns false and doesn't update the\n  // value.\n  std::pair<iterator, bool> insert(std::pair<KeyT, ValueT> &&KV) {\n    return try_emplace(std::move(KV.first), std::move(KV.second));\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // The value is constructed in-place if the key is not in the map, otherwise\n  // it is not moved.\n  template <typename... Ts>\n  std::pair<iterator, bool> try_emplace(KeyT &&Key, Ts &&... Args) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return std::make_pair(makeIterator(TheBucket,\n                                         shouldReverseIterate<KeyT>()\n                                             ? getBuckets()\n                                             : getBucketsEnd(),\n                                         *this, true),\n                            false); // Already in map.\n\n    // Otherwise, insert the new element.\n    TheBucket =\n        InsertIntoBucket(TheBucket, std::move(Key), std::forward<Ts>(Args)...);\n    return std::make_pair(makeIterator(TheBucket,\n                                       shouldReverseIterate<KeyT>()\n                                           ? getBuckets()\n                                           : getBucketsEnd(),\n                                       *this, true),\n                          true);\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // The value is constructed in-place if the key is not in the map, otherwise\n  // it is not moved.\n  template <typename... Ts>\n  std::pair<iterator, bool> try_emplace(const KeyT &Key, Ts &&... Args) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return std::make_pair(makeIterator(TheBucket,\n                                         shouldReverseIterate<KeyT>()\n                                             ? getBuckets()\n                                             : getBucketsEnd(),\n                                         *this, true),\n                            false); // Already in map.\n\n    // Otherwise, insert the new element.\n    TheBucket = InsertIntoBucket(TheBucket, Key, std::forward<Ts>(Args)...);\n    return std::make_pair(makeIterator(TheBucket,\n                                       shouldReverseIterate<KeyT>()\n                                           ? getBuckets()\n                                           : getBucketsEnd(),\n                                       *this, true),\n                          true);\n  }\n\n  /// Alternate version of insert() which allows a different, and possibly\n  /// less expensive, key type.\n  /// The DenseMapInfo is responsible for supplying methods\n  /// getHashValue(LookupKeyT) and isEqual(LookupKeyT, KeyT) for each key\n  /// type used.\n  template <typename LookupKeyT>\n  std::pair<iterator, bool> insert_as(std::pair<KeyT, ValueT> &&KV,\n                                      const LookupKeyT &Val) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return std::make_pair(makeIterator(TheBucket,\n                                         shouldReverseIterate<KeyT>()\n                                             ? getBuckets()\n                                             : getBucketsEnd(),\n                                         *this, true),\n                            false); // Already in map.\n\n    // Otherwise, insert the new element.\n    TheBucket = InsertIntoBucketWithLookup(TheBucket, std::move(KV.first),\n                                           std::move(KV.second), Val);\n    return std::make_pair(makeIterator(TheBucket,\n                                       shouldReverseIterate<KeyT>()\n                                           ? getBuckets()\n                                           : getBucketsEnd(),\n                                       *this, true),\n                          true);\n  }\n\n  /// insert - Range insertion of pairs.\n  template<typename InputIt>\n  void insert(InputIt I, InputIt E) {\n    for (; I != E; ++I)\n      insert(*I);\n  }\n\n  bool erase(const KeyT &Val) {\n    BucketT *TheBucket;\n    if (!LookupBucketFor(Val, TheBucket))\n      return false; // not in map.\n\n    TheBucket->getSecond().~ValueT();\n    TheBucket->getFirst() = getTombstoneKey();\n    decrementNumEntries();\n    incrementNumTombstones();\n    return true;\n  }\n  void erase(iterator I) {\n    BucketT *TheBucket = &*I;\n    TheBucket->getSecond().~ValueT();\n    TheBucket->getFirst() = getTombstoneKey();\n    decrementNumEntries();\n    incrementNumTombstones();\n  }\n\n  value_type& FindAndConstruct(const KeyT &Key) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return *TheBucket;\n\n    return *InsertIntoBucket(TheBucket, Key);\n  }\n\n  ValueT &operator[](const KeyT &Key) {\n    return FindAndConstruct(Key).second;\n  }\n\n  value_type& FindAndConstruct(KeyT &&Key) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return *TheBucket;\n\n    return *InsertIntoBucket(TheBucket, std::move(Key));\n  }\n\n  ValueT &operator[](KeyT &&Key) {\n    return FindAndConstruct(std::move(Key)).second;\n  }\n\n  /// isPointerIntoBucketsArray - Return true if the specified pointer points\n  /// somewhere into the DenseMap's array of buckets (i.e. either to a key or\n  /// value in the DenseMap).\n  bool isPointerIntoBucketsArray(const void *Ptr) const {\n    return Ptr >= getBuckets() && Ptr < getBucketsEnd();\n  }\n\n  /// getPointerIntoBucketsArray() - Return an opaque pointer into the buckets\n  /// array.  In conjunction with the previous method, this can be used to\n  /// determine whether an insertion caused the DenseMap to reallocate.\n  const void *getPointerIntoBucketsArray() const { return getBuckets(); }\n\nprotected:\n  DenseMapBase() = default;\n\n  void destroyAll() {\n    if (getNumBuckets() == 0) // Nothing to do.\n      return;\n\n    const KeyT EmptyKey = getEmptyKey(), TombstoneKey = getTombstoneKey();\n    for (BucketT *P = getBuckets(), *E = getBucketsEnd(); P != E; ++P) {\n      if (!KeyInfoT::isEqual(P->getFirst(), EmptyKey) &&\n          !KeyInfoT::isEqual(P->getFirst(), TombstoneKey))\n        P->getSecond().~ValueT();\n      P->getFirst().~KeyT();\n    }\n  }\n\n  void initEmpty() {\n    setNumEntries(0);\n    setNumTombstones(0);\n\n    assert((getNumBuckets() & (getNumBuckets()-1)) == 0 &&\n           \"# initial buckets must be a power of two!\");\n    const KeyT EmptyKey = getEmptyKey();\n    for (BucketT *B = getBuckets(), *E = getBucketsEnd(); B != E; ++B)\n      ::new (&B->getFirst()) KeyT(EmptyKey);\n  }\n\n  /// Returns the number of buckets to allocate to ensure that the DenseMap can\n  /// accommodate \\p NumEntries without need to grow().\n  unsigned getMinBucketToReserveForEntries(unsigned NumEntries) {\n    // Ensure that \"NumEntries * 4 < NumBuckets * 3\"\n    if (NumEntries == 0)\n      return 0;\n    // +1 is required because of the strict equality.\n    // For example if NumEntries is 48, we need to return 401.\n    return NextPowerOf2(NumEntries * 4 / 3 + 1);\n  }\n\n  void moveFromOldBuckets(BucketT *OldBucketsBegin, BucketT *OldBucketsEnd) {\n    initEmpty();\n\n    // Insert all the old elements.\n    const KeyT EmptyKey = getEmptyKey();\n    const KeyT TombstoneKey = getTombstoneKey();\n    for (BucketT *B = OldBucketsBegin, *E = OldBucketsEnd; B != E; ++B) {\n      if (!KeyInfoT::isEqual(B->getFirst(), EmptyKey) &&\n          !KeyInfoT::isEqual(B->getFirst(), TombstoneKey)) {\n        // Insert the key/value into the new table.\n        BucketT *DestBucket;\n        bool FoundVal = LookupBucketFor(B->getFirst(), DestBucket);\n        (void)FoundVal; // silence warning.\n        assert(!FoundVal && \"Key already in new map?\");\n        DestBucket->getFirst() = std::move(B->getFirst());\n        ::new (&DestBucket->getSecond()) ValueT(std::move(B->getSecond()));\n        incrementNumEntries();\n\n        // Free the value.\n        B->getSecond().~ValueT();\n      }\n      B->getFirst().~KeyT();\n    }\n  }\n\n  template <typename OtherBaseT>\n  void copyFrom(\n      const DenseMapBase<OtherBaseT, KeyT, ValueT, KeyInfoT, BucketT> &other) {\n    assert(&other != this);\n    assert(getNumBuckets() == other.getNumBuckets());\n\n    setNumEntries(other.getNumEntries());\n    setNumTombstones(other.getNumTombstones());\n\n    if (std::is_trivially_copyable<KeyT>::value &&\n        std::is_trivially_copyable<ValueT>::value)\n      memcpy(reinterpret_cast<void *>(getBuckets()), other.getBuckets(),\n             getNumBuckets() * sizeof(BucketT));\n    else\n      for (size_t i = 0; i < getNumBuckets(); ++i) {\n        ::new (&getBuckets()[i].getFirst())\n            KeyT(other.getBuckets()[i].getFirst());\n        if (!KeyInfoT::isEqual(getBuckets()[i].getFirst(), getEmptyKey()) &&\n            !KeyInfoT::isEqual(getBuckets()[i].getFirst(), getTombstoneKey()))\n          ::new (&getBuckets()[i].getSecond())\n              ValueT(other.getBuckets()[i].getSecond());\n      }\n  }\n\n  static unsigned getHashValue(const KeyT &Val) {\n    return KeyInfoT::getHashValue(Val);\n  }\n\n  template<typename LookupKeyT>\n  static unsigned getHashValue(const LookupKeyT &Val) {\n    return KeyInfoT::getHashValue(Val);\n  }\n\n  static const KeyT getEmptyKey() {\n    static_assert(std::is_base_of<DenseMapBase, DerivedT>::value,\n                  \"Must pass the derived type to this template!\");\n    return KeyInfoT::getEmptyKey();\n  }\n\n  static const KeyT getTombstoneKey() {\n    return KeyInfoT::getTombstoneKey();\n  }\n\nprivate:\n  iterator makeIterator(BucketT *P, BucketT *E,\n                        DebugEpochBase &Epoch,\n                        bool NoAdvance=false) {\n    if (shouldReverseIterate<KeyT>()) {\n      BucketT *B = P == getBucketsEnd() ? getBuckets() : P + 1;\n      return iterator(B, E, Epoch, NoAdvance);\n    }\n    return iterator(P, E, Epoch, NoAdvance);\n  }\n\n  const_iterator makeConstIterator(const BucketT *P, const BucketT *E,\n                                   const DebugEpochBase &Epoch,\n                                   const bool NoAdvance=false) const {\n    if (shouldReverseIterate<KeyT>()) {\n      const BucketT *B = P == getBucketsEnd() ? getBuckets() : P + 1;\n      return const_iterator(B, E, Epoch, NoAdvance);\n    }\n    return const_iterator(P, E, Epoch, NoAdvance);\n  }\n\n  unsigned getNumEntries() const {\n    return static_cast<const DerivedT *>(this)->getNumEntries();\n  }\n\n  void setNumEntries(unsigned Num) {\n    static_cast<DerivedT *>(this)->setNumEntries(Num);\n  }\n\n  void incrementNumEntries() {\n    setNumEntries(getNumEntries() + 1);\n  }\n\n  void decrementNumEntries() {\n    setNumEntries(getNumEntries() - 1);\n  }\n\n  unsigned getNumTombstones() const {\n    return static_cast<const DerivedT *>(this)->getNumTombstones();\n  }\n\n  void setNumTombstones(unsigned Num) {\n    static_cast<DerivedT *>(this)->setNumTombstones(Num);\n  }\n\n  void incrementNumTombstones() {\n    setNumTombstones(getNumTombstones() + 1);\n  }\n\n  void decrementNumTombstones() {\n    setNumTombstones(getNumTombstones() - 1);\n  }\n\n  const BucketT *getBuckets() const {\n    return static_cast<const DerivedT *>(this)->getBuckets();\n  }\n\n  BucketT *getBuckets() {\n    return static_cast<DerivedT *>(this)->getBuckets();\n  }\n\n  unsigned getNumBuckets() const {\n    return static_cast<const DerivedT *>(this)->getNumBuckets();\n  }\n\n  BucketT *getBucketsEnd() {\n    return getBuckets() + getNumBuckets();\n  }\n\n  const BucketT *getBucketsEnd() const {\n    return getBuckets() + getNumBuckets();\n  }\n\n  void grow(unsigned AtLeast) {\n    static_cast<DerivedT *>(this)->grow(AtLeast);\n  }\n\n  void shrink_and_clear() {\n    static_cast<DerivedT *>(this)->shrink_and_clear();\n  }\n\n  template <typename KeyArg, typename... ValueArgs>\n  BucketT *InsertIntoBucket(BucketT *TheBucket, KeyArg &&Key,\n                            ValueArgs &&... Values) {\n    TheBucket = InsertIntoBucketImpl(Key, Key, TheBucket);\n\n    TheBucket->getFirst() = std::forward<KeyArg>(Key);\n    ::new (&TheBucket->getSecond()) ValueT(std::forward<ValueArgs>(Values)...);\n    return TheBucket;\n  }\n\n  template <typename LookupKeyT>\n  BucketT *InsertIntoBucketWithLookup(BucketT *TheBucket, KeyT &&Key,\n                                      ValueT &&Value, LookupKeyT &Lookup) {\n    TheBucket = InsertIntoBucketImpl(Key, Lookup, TheBucket);\n\n    TheBucket->getFirst() = std::move(Key);\n    ::new (&TheBucket->getSecond()) ValueT(std::move(Value));\n    return TheBucket;\n  }\n\n  template <typename LookupKeyT>\n  BucketT *InsertIntoBucketImpl(const KeyT &Key, const LookupKeyT &Lookup,\n                                BucketT *TheBucket) {\n    incrementEpoch();\n\n    // If the load of the hash table is more than 3/4, or if fewer than 1/8 of\n    // the buckets are empty (meaning that many are filled with tombstones),\n    // grow the table.\n    //\n    // The later case is tricky.  For example, if we had one empty bucket with\n    // tons of tombstones, failing lookups (e.g. for insertion) would have to\n    // probe almost the entire table until it found the empty bucket.  If the\n    // table completely filled with tombstones, no lookup would ever succeed,\n    // causing infinite loops in lookup.\n    unsigned NewNumEntries = getNumEntries() + 1;\n    unsigned NumBuckets = getNumBuckets();\n    if (LLVM_UNLIKELY(NewNumEntries * 4 >= NumBuckets * 3)) {\n      this->grow(NumBuckets * 2);\n      LookupBucketFor(Lookup, TheBucket);\n      NumBuckets = getNumBuckets();\n    } else if (LLVM_UNLIKELY(NumBuckets-(NewNumEntries+getNumTombstones()) <=\n                             NumBuckets/8)) {\n      this->grow(NumBuckets);\n      LookupBucketFor(Lookup, TheBucket);\n    }\n    assert(TheBucket);\n\n    // Only update the state after we've grown our bucket space appropriately\n    // so that when growing buckets we have self-consistent entry count.\n    incrementNumEntries();\n\n    // If we are writing over a tombstone, remember this.\n    const KeyT EmptyKey = getEmptyKey();\n    if (!KeyInfoT::isEqual(TheBucket->getFirst(), EmptyKey))\n      decrementNumTombstones();\n\n    return TheBucket;\n  }\n\n  /// LookupBucketFor - Lookup the appropriate bucket for Val, returning it in\n  /// FoundBucket.  If the bucket contains the key and a value, this returns\n  /// true, otherwise it returns a bucket with an empty marker or tombstone and\n  /// returns false.\n  template<typename LookupKeyT>\n  bool LookupBucketFor(const LookupKeyT &Val,\n                       const BucketT *&FoundBucket) const {\n    const BucketT *BucketsPtr = getBuckets();\n    const unsigned NumBuckets = getNumBuckets();\n\n    if (NumBuckets == 0) {\n      FoundBucket = nullptr;\n      return false;\n    }\n\n    // FoundTombstone - Keep track of whether we find a tombstone while probing.\n    const BucketT *FoundTombstone = nullptr;\n    const KeyT EmptyKey = getEmptyKey();\n    const KeyT TombstoneKey = getTombstoneKey();\n    assert(!KeyInfoT::isEqual(Val, EmptyKey) &&\n           !KeyInfoT::isEqual(Val, TombstoneKey) &&\n           \"Empty/Tombstone value shouldn't be inserted into map!\");\n\n    unsigned BucketNo = getHashValue(Val) & (NumBuckets-1);\n    unsigned ProbeAmt = 1;\n    while (true) {\n      const BucketT *ThisBucket = BucketsPtr + BucketNo;\n      // Found Val's bucket?  If so, return it.\n      if (LLVM_LIKELY(KeyInfoT::isEqual(Val, ThisBucket->getFirst()))) {\n        FoundBucket = ThisBucket;\n        return true;\n      }\n\n      // If we found an empty bucket, the key doesn't exist in the set.\n      // Insert it and return the default value.\n      if (LLVM_LIKELY(KeyInfoT::isEqual(ThisBucket->getFirst(), EmptyKey))) {\n        // If we've already seen a tombstone while probing, fill it in instead\n        // of the empty bucket we eventually probed to.\n        FoundBucket = FoundTombstone ? FoundTombstone : ThisBucket;\n        return false;\n      }\n\n      // If this is a tombstone, remember it.  If Val ends up not in the map, we\n      // prefer to return it than something that would require more probing.\n      if (KeyInfoT::isEqual(ThisBucket->getFirst(), TombstoneKey) &&\n          !FoundTombstone)\n        FoundTombstone = ThisBucket;  // Remember the first tombstone found.\n\n      // Otherwise, it's a hash collision or a tombstone, continue quadratic\n      // probing.\n      BucketNo += ProbeAmt++;\n      BucketNo &= (NumBuckets-1);\n    }\n  }\n\n  template <typename LookupKeyT>\n  bool LookupBucketFor(const LookupKeyT &Val, BucketT *&FoundBucket) {\n    const BucketT *ConstFoundBucket;\n    bool Result = const_cast<const DenseMapBase *>(this)\n      ->LookupBucketFor(Val, ConstFoundBucket);\n    FoundBucket = const_cast<BucketT *>(ConstFoundBucket);\n    return Result;\n  }\n\npublic:\n  /// Return the approximate size (in bytes) of the actual map.\n  /// This is just the raw memory used by DenseMap.\n  /// If entries are pointers to objects, the size of the referenced objects\n  /// are not included.\n  size_t getMemorySize() const {\n    return getNumBuckets() * sizeof(BucketT);\n  }\n};\n\n/// Equality comparison for DenseMap.\n///\n/// Iterates over elements of LHS confirming that each (key, value) pair in LHS\n/// is also in RHS, and that no additional pairs are in RHS.\n/// Equivalent to N calls to RHS.find and N value comparisons. Amortized\n/// complexity is linear, worst case is O(N^2) (if every hash collides).\ntemplate <typename DerivedT, typename KeyT, typename ValueT, typename KeyInfoT,\n          typename BucketT>\nbool operator==(\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &LHS,\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &RHS) {\n  if (LHS.size() != RHS.size())\n    return false;\n\n  for (auto &KV : LHS) {\n    auto I = RHS.find(KV.first);\n    if (I == RHS.end() || I->second != KV.second)\n      return false;\n  }\n\n  return true;\n}\n\n/// Inequality comparison for DenseMap.\n///\n/// Equivalent to !(LHS == RHS). See operator== for performance notes.\ntemplate <typename DerivedT, typename KeyT, typename ValueT, typename KeyInfoT,\n          typename BucketT>\nbool operator!=(\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &LHS,\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &RHS) {\n  return !(LHS == RHS);\n}\n\ntemplate <typename KeyT, typename ValueT,\n          typename KeyInfoT = DenseMapInfo<KeyT>,\n          typename BucketT = llvm::detail::DenseMapPair<KeyT, ValueT>>\nclass DenseMap : public DenseMapBase<DenseMap<KeyT, ValueT, KeyInfoT, BucketT>,\n                                     KeyT, ValueT, KeyInfoT, BucketT> {\n  friend class DenseMapBase<DenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  // Lift some types from the dependent base class into this class for\n  // simplicity of referring to them.\n  using BaseT = DenseMapBase<DenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  BucketT *Buckets;\n  unsigned NumEntries;\n  unsigned NumTombstones;\n  unsigned NumBuckets;\n\npublic:\n  /// Create a DenseMap with an optional \\p InitialReserve that guarantee that\n  /// this number of elements can be inserted in the map without grow()\n  explicit DenseMap(unsigned InitialReserve = 0) { init(InitialReserve); }\n\n  DenseMap(const DenseMap &other) : BaseT() {\n    init(0);\n    copyFrom(other);\n  }\n\n  DenseMap(DenseMap &&other) : BaseT() {\n    init(0);\n    swap(other);\n  }\n\n  template<typename InputIt>\n  DenseMap(const InputIt &I, const InputIt &E) {\n    init(std::distance(I, E));\n    this->insert(I, E);\n  }\n\n  DenseMap(std::initializer_list<typename BaseT::value_type> Vals) {\n    init(Vals.size());\n    this->insert(Vals.begin(), Vals.end());\n  }\n\n  ~DenseMap() {\n    this->destroyAll();\n    deallocate_buffer(Buckets, sizeof(BucketT) * NumBuckets, alignof(BucketT));\n  }\n\n  void swap(DenseMap& RHS) {\n    this->incrementEpoch();\n    RHS.incrementEpoch();\n    std::swap(Buckets, RHS.Buckets);\n    std::swap(NumEntries, RHS.NumEntries);\n    std::swap(NumTombstones, RHS.NumTombstones);\n    std::swap(NumBuckets, RHS.NumBuckets);\n  }\n\n  DenseMap& operator=(const DenseMap& other) {\n    if (&other != this)\n      copyFrom(other);\n    return *this;\n  }\n\n  DenseMap& operator=(DenseMap &&other) {\n    this->destroyAll();\n    deallocate_buffer(Buckets, sizeof(BucketT) * NumBuckets, alignof(BucketT));\n    init(0);\n    swap(other);\n    return *this;\n  }\n\n  void copyFrom(const DenseMap& other) {\n    this->destroyAll();\n    deallocate_buffer(Buckets, sizeof(BucketT) * NumBuckets, alignof(BucketT));\n    if (allocateBuckets(other.NumBuckets)) {\n      this->BaseT::copyFrom(other);\n    } else {\n      NumEntries = 0;\n      NumTombstones = 0;\n    }\n  }\n\n  void init(unsigned InitNumEntries) {\n    auto InitBuckets = BaseT::getMinBucketToReserveForEntries(InitNumEntries);\n    if (allocateBuckets(InitBuckets)) {\n      this->BaseT::initEmpty();\n    } else {\n      NumEntries = 0;\n      NumTombstones = 0;\n    }\n  }\n\n  void grow(unsigned AtLeast) {\n    unsigned OldNumBuckets = NumBuckets;\n    BucketT *OldBuckets = Buckets;\n\n    allocateBuckets(std::max<unsigned>(64, static_cast<unsigned>(NextPowerOf2(AtLeast-1))));\n    assert(Buckets);\n    if (!OldBuckets) {\n      this->BaseT::initEmpty();\n      return;\n    }\n\n    this->moveFromOldBuckets(OldBuckets, OldBuckets+OldNumBuckets);\n\n    // Free the old table.\n    deallocate_buffer(OldBuckets, sizeof(BucketT) * OldNumBuckets,\n                      alignof(BucketT));\n  }\n\n  void shrink_and_clear() {\n    unsigned OldNumBuckets = NumBuckets;\n    unsigned OldNumEntries = NumEntries;\n    this->destroyAll();\n\n    // Reduce the number of buckets.\n    unsigned NewNumBuckets = 0;\n    if (OldNumEntries)\n      NewNumBuckets = std::max(64, 1 << (Log2_32_Ceil(OldNumEntries) + 1));\n    if (NewNumBuckets == NumBuckets) {\n      this->BaseT::initEmpty();\n      return;\n    }\n\n    deallocate_buffer(Buckets, sizeof(BucketT) * OldNumBuckets,\n                      alignof(BucketT));\n    init(NewNumBuckets);\n  }\n\nprivate:\n  unsigned getNumEntries() const {\n    return NumEntries;\n  }\n\n  void setNumEntries(unsigned Num) {\n    NumEntries = Num;\n  }\n\n  unsigned getNumTombstones() const {\n    return NumTombstones;\n  }\n\n  void setNumTombstones(unsigned Num) {\n    NumTombstones = Num;\n  }\n\n  BucketT *getBuckets() const {\n    return Buckets;\n  }\n\n  unsigned getNumBuckets() const {\n    return NumBuckets;\n  }\n\n  bool allocateBuckets(unsigned Num) {\n    NumBuckets = Num;\n    if (NumBuckets == 0) {\n      Buckets = nullptr;\n      return false;\n    }\n\n    Buckets = static_cast<BucketT *>(\n        allocate_buffer(sizeof(BucketT) * NumBuckets, alignof(BucketT)));\n    return true;\n  }\n};\n\ntemplate <typename KeyT, typename ValueT, unsigned InlineBuckets = 4,\n          typename KeyInfoT = DenseMapInfo<KeyT>,\n          typename BucketT = llvm::detail::DenseMapPair<KeyT, ValueT>>\nclass SmallDenseMap\n    : public DenseMapBase<\n          SmallDenseMap<KeyT, ValueT, InlineBuckets, KeyInfoT, BucketT>, KeyT,\n          ValueT, KeyInfoT, BucketT> {\n  friend class DenseMapBase<SmallDenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  // Lift some types from the dependent base class into this class for\n  // simplicity of referring to them.\n  using BaseT = DenseMapBase<SmallDenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  static_assert(isPowerOf2_64(InlineBuckets),\n                \"InlineBuckets must be a power of 2.\");\n\n  unsigned Small : 1;\n  unsigned NumEntries : 31;\n  unsigned NumTombstones;\n\n  struct LargeRep {\n    BucketT *Buckets;\n    unsigned NumBuckets;\n  };\n\n  /// A \"union\" of an inline bucket array and the struct representing\n  /// a large bucket. This union will be discriminated by the 'Small' bit.\n  AlignedCharArrayUnion<BucketT[InlineBuckets], LargeRep> storage;\n\npublic:\n  explicit SmallDenseMap(unsigned NumInitBuckets = 0) {\n    init(NumInitBuckets);\n  }\n\n  SmallDenseMap(const SmallDenseMap &other) : BaseT() {\n    init(0);\n    copyFrom(other);\n  }\n\n  SmallDenseMap(SmallDenseMap &&other) : BaseT() {\n    init(0);\n    swap(other);\n  }\n\n  template<typename InputIt>\n  SmallDenseMap(const InputIt &I, const InputIt &E) {\n    init(NextPowerOf2(std::distance(I, E)));\n    this->insert(I, E);\n  }\n\n  ~SmallDenseMap() {\n    this->destroyAll();\n    deallocateBuckets();\n  }\n\n  void swap(SmallDenseMap& RHS) {\n    unsigned TmpNumEntries = RHS.NumEntries;\n    RHS.NumEntries = NumEntries;\n    NumEntries = TmpNumEntries;\n    std::swap(NumTombstones, RHS.NumTombstones);\n\n    const KeyT EmptyKey = this->getEmptyKey();\n    const KeyT TombstoneKey = this->getTombstoneKey();\n    if (Small && RHS.Small) {\n      // If we're swapping inline bucket arrays, we have to cope with some of\n      // the tricky bits of DenseMap's storage system: the buckets are not\n      // fully initialized. Thus we swap every key, but we may have\n      // a one-directional move of the value.\n      for (unsigned i = 0, e = InlineBuckets; i != e; ++i) {\n        BucketT *LHSB = &getInlineBuckets()[i],\n                *RHSB = &RHS.getInlineBuckets()[i];\n        bool hasLHSValue = (!KeyInfoT::isEqual(LHSB->getFirst(), EmptyKey) &&\n                            !KeyInfoT::isEqual(LHSB->getFirst(), TombstoneKey));\n        bool hasRHSValue = (!KeyInfoT::isEqual(RHSB->getFirst(), EmptyKey) &&\n                            !KeyInfoT::isEqual(RHSB->getFirst(), TombstoneKey));\n        if (hasLHSValue && hasRHSValue) {\n          // Swap together if we can...\n          std::swap(*LHSB, *RHSB);\n          continue;\n        }\n        // Swap separately and handle any asymmetry.\n        std::swap(LHSB->getFirst(), RHSB->getFirst());\n        if (hasLHSValue) {\n          ::new (&RHSB->getSecond()) ValueT(std::move(LHSB->getSecond()));\n          LHSB->getSecond().~ValueT();\n        } else if (hasRHSValue) {\n          ::new (&LHSB->getSecond()) ValueT(std::move(RHSB->getSecond()));\n          RHSB->getSecond().~ValueT();\n        }\n      }\n      return;\n    }\n    if (!Small && !RHS.Small) {\n      std::swap(getLargeRep()->Buckets, RHS.getLargeRep()->Buckets);\n      std::swap(getLargeRep()->NumBuckets, RHS.getLargeRep()->NumBuckets);\n      return;\n    }\n\n    SmallDenseMap &SmallSide = Small ? *this : RHS;\n    SmallDenseMap &LargeSide = Small ? RHS : *this;\n\n    // First stash the large side's rep and move the small side across.\n    LargeRep TmpRep = std::move(*LargeSide.getLargeRep());\n    LargeSide.getLargeRep()->~LargeRep();\n    LargeSide.Small = true;\n    // This is similar to the standard move-from-old-buckets, but the bucket\n    // count hasn't actually rotated in this case. So we have to carefully\n    // move construct the keys and values into their new locations, but there\n    // is no need to re-hash things.\n    for (unsigned i = 0, e = InlineBuckets; i != e; ++i) {\n      BucketT *NewB = &LargeSide.getInlineBuckets()[i],\n              *OldB = &SmallSide.getInlineBuckets()[i];\n      ::new (&NewB->getFirst()) KeyT(std::move(OldB->getFirst()));\n      OldB->getFirst().~KeyT();\n      if (!KeyInfoT::isEqual(NewB->getFirst(), EmptyKey) &&\n          !KeyInfoT::isEqual(NewB->getFirst(), TombstoneKey)) {\n        ::new (&NewB->getSecond()) ValueT(std::move(OldB->getSecond()));\n        OldB->getSecond().~ValueT();\n      }\n    }\n\n    // The hard part of moving the small buckets across is done, just move\n    // the TmpRep into its new home.\n    SmallSide.Small = false;\n    new (SmallSide.getLargeRep()) LargeRep(std::move(TmpRep));\n  }\n\n  SmallDenseMap& operator=(const SmallDenseMap& other) {\n    if (&other != this)\n      copyFrom(other);\n    return *this;\n  }\n\n  SmallDenseMap& operator=(SmallDenseMap &&other) {\n    this->destroyAll();\n    deallocateBuckets();\n    init(0);\n    swap(other);\n    return *this;\n  }\n\n  void copyFrom(const SmallDenseMap& other) {\n    this->destroyAll();\n    deallocateBuckets();\n    Small = true;\n    if (other.getNumBuckets() > InlineBuckets) {\n      Small = false;\n      new (getLargeRep()) LargeRep(allocateBuckets(other.getNumBuckets()));\n    }\n    this->BaseT::copyFrom(other);\n  }\n\n  void init(unsigned InitBuckets) {\n    Small = true;\n    if (InitBuckets > InlineBuckets) {\n      Small = false;\n      new (getLargeRep()) LargeRep(allocateBuckets(InitBuckets));\n    }\n    this->BaseT::initEmpty();\n  }\n\n  void grow(unsigned AtLeast) {\n    if (AtLeast > InlineBuckets)\n      AtLeast = std::max<unsigned>(64, NextPowerOf2(AtLeast-1));\n\n    if (Small) {\n      // First move the inline buckets into a temporary storage.\n      AlignedCharArrayUnion<BucketT[InlineBuckets]> TmpStorage;\n      BucketT *TmpBegin = reinterpret_cast<BucketT *>(&TmpStorage);\n      BucketT *TmpEnd = TmpBegin;\n\n      // Loop over the buckets, moving non-empty, non-tombstones into the\n      // temporary storage. Have the loop move the TmpEnd forward as it goes.\n      const KeyT EmptyKey = this->getEmptyKey();\n      const KeyT TombstoneKey = this->getTombstoneKey();\n      for (BucketT *P = getBuckets(), *E = P + InlineBuckets; P != E; ++P) {\n        if (!KeyInfoT::isEqual(P->getFirst(), EmptyKey) &&\n            !KeyInfoT::isEqual(P->getFirst(), TombstoneKey)) {\n          assert(size_t(TmpEnd - TmpBegin) < InlineBuckets &&\n                 \"Too many inline buckets!\");\n          ::new (&TmpEnd->getFirst()) KeyT(std::move(P->getFirst()));\n          ::new (&TmpEnd->getSecond()) ValueT(std::move(P->getSecond()));\n          ++TmpEnd;\n          P->getSecond().~ValueT();\n        }\n        P->getFirst().~KeyT();\n      }\n\n      // AtLeast == InlineBuckets can happen if there are many tombstones,\n      // and grow() is used to remove them. Usually we always switch to the\n      // large rep here.\n      if (AtLeast > InlineBuckets) {\n        Small = false;\n        new (getLargeRep()) LargeRep(allocateBuckets(AtLeast));\n      }\n      this->moveFromOldBuckets(TmpBegin, TmpEnd);\n      return;\n    }\n\n    LargeRep OldRep = std::move(*getLargeRep());\n    getLargeRep()->~LargeRep();\n    if (AtLeast <= InlineBuckets) {\n      Small = true;\n    } else {\n      new (getLargeRep()) LargeRep(allocateBuckets(AtLeast));\n    }\n\n    this->moveFromOldBuckets(OldRep.Buckets, OldRep.Buckets+OldRep.NumBuckets);\n\n    // Free the old table.\n    deallocate_buffer(OldRep.Buckets, sizeof(BucketT) * OldRep.NumBuckets,\n                      alignof(BucketT));\n  }\n\n  void shrink_and_clear() {\n    unsigned OldSize = this->size();\n    this->destroyAll();\n\n    // Reduce the number of buckets.\n    unsigned NewNumBuckets = 0;\n    if (OldSize) {\n      NewNumBuckets = 1 << (Log2_32_Ceil(OldSize) + 1);\n      if (NewNumBuckets > InlineBuckets && NewNumBuckets < 64u)\n        NewNumBuckets = 64;\n    }\n    if ((Small && NewNumBuckets <= InlineBuckets) ||\n        (!Small && NewNumBuckets == getLargeRep()->NumBuckets)) {\n      this->BaseT::initEmpty();\n      return;\n    }\n\n    deallocateBuckets();\n    init(NewNumBuckets);\n  }\n\nprivate:\n  unsigned getNumEntries() const {\n    return NumEntries;\n  }\n\n  void setNumEntries(unsigned Num) {\n    // NumEntries is hardcoded to be 31 bits wide.\n    assert(Num < (1U << 31) && \"Cannot support more than 1<<31 entries\");\n    NumEntries = Num;\n  }\n\n  unsigned getNumTombstones() const {\n    return NumTombstones;\n  }\n\n  void setNumTombstones(unsigned Num) {\n    NumTombstones = Num;\n  }\n\n  const BucketT *getInlineBuckets() const {\n    assert(Small);\n    // Note that this cast does not violate aliasing rules as we assert that\n    // the memory's dynamic type is the small, inline bucket buffer, and the\n    // 'storage' is a POD containing a char buffer.\n    return reinterpret_cast<const BucketT *>(&storage);\n  }\n\n  BucketT *getInlineBuckets() {\n    return const_cast<BucketT *>(\n      const_cast<const SmallDenseMap *>(this)->getInlineBuckets());\n  }\n\n  const LargeRep *getLargeRep() const {\n    assert(!Small);\n    // Note, same rule about aliasing as with getInlineBuckets.\n    return reinterpret_cast<const LargeRep *>(&storage);\n  }\n\n  LargeRep *getLargeRep() {\n    return const_cast<LargeRep *>(\n      const_cast<const SmallDenseMap *>(this)->getLargeRep());\n  }\n\n  const BucketT *getBuckets() const {\n    return Small ? getInlineBuckets() : getLargeRep()->Buckets;\n  }\n\n  BucketT *getBuckets() {\n    return const_cast<BucketT *>(\n      const_cast<const SmallDenseMap *>(this)->getBuckets());\n  }\n\n  unsigned getNumBuckets() const {\n    return Small ? InlineBuckets : getLargeRep()->NumBuckets;\n  }\n\n  void deallocateBuckets() {\n    if (Small)\n      return;\n\n    deallocate_buffer(getLargeRep()->Buckets,\n                      sizeof(BucketT) * getLargeRep()->NumBuckets,\n                      alignof(BucketT));\n    getLargeRep()->~LargeRep();\n  }\n\n  LargeRep allocateBuckets(unsigned Num) {\n    assert(Num > InlineBuckets && \"Must allocate more buckets than are inline\");\n    LargeRep Rep = {static_cast<BucketT *>(allocate_buffer(\n                        sizeof(BucketT) * Num, alignof(BucketT))),\n                    Num};\n    return Rep;\n  }\n};\n\ntemplate <typename KeyT, typename ValueT, typename KeyInfoT, typename Bucket,\n          bool IsConst>\nclass DenseMapIterator : DebugEpochBase::HandleBase {\n  friend class DenseMapIterator<KeyT, ValueT, KeyInfoT, Bucket, true>;\n  friend class DenseMapIterator<KeyT, ValueT, KeyInfoT, Bucket, false>;\n\npublic:\n  using difference_type = ptrdiff_t;\n  using value_type =\n      typename std::conditional<IsConst, const Bucket, Bucket>::type;\n  using pointer = value_type *;\n  using reference = value_type &;\n  using iterator_category = std::forward_iterator_tag;\n\nprivate:\n  pointer Ptr = nullptr;\n  pointer End = nullptr;\n\npublic:\n  DenseMapIterator() = default;\n\n  DenseMapIterator(pointer Pos, pointer E, const DebugEpochBase &Epoch,\n                   bool NoAdvance = false)\n      : DebugEpochBase::HandleBase(&Epoch), Ptr(Pos), End(E) {\n    assert(isHandleInSync() && \"invalid construction!\");\n\n    if (NoAdvance) return;\n    if (shouldReverseIterate<KeyT>()) {\n      RetreatPastEmptyBuckets();\n      return;\n    }\n    AdvancePastEmptyBuckets();\n  }\n\n  // Converting ctor from non-const iterators to const iterators. SFINAE'd out\n  // for const iterator destinations so it doesn't end up as a user defined copy\n  // constructor.\n  template <bool IsConstSrc,\n            typename = std::enable_if_t<!IsConstSrc && IsConst>>\n  DenseMapIterator(\n      const DenseMapIterator<KeyT, ValueT, KeyInfoT, Bucket, IsConstSrc> &I)\n      : DebugEpochBase::HandleBase(I), Ptr(I.Ptr), End(I.End) {}\n\n  reference operator*() const {\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    assert(Ptr != End && \"dereferencing end() iterator\");\n    if (shouldReverseIterate<KeyT>())\n      return Ptr[-1];\n    return *Ptr;\n  }\n  pointer operator->() const {\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    assert(Ptr != End && \"dereferencing end() iterator\");\n    if (shouldReverseIterate<KeyT>())\n      return &(Ptr[-1]);\n    return Ptr;\n  }\n\n  friend bool operator==(const DenseMapIterator &LHS,\n                         const DenseMapIterator &RHS) {\n    assert((!LHS.Ptr || LHS.isHandleInSync()) && \"handle not in sync!\");\n    assert((!RHS.Ptr || RHS.isHandleInSync()) && \"handle not in sync!\");\n    assert(LHS.getEpochAddress() == RHS.getEpochAddress() &&\n           \"comparing incomparable iterators!\");\n    return LHS.Ptr == RHS.Ptr;\n  }\n\n  friend bool operator!=(const DenseMapIterator &LHS,\n                         const DenseMapIterator &RHS) {\n    return !(LHS == RHS);\n  }\n\n  inline DenseMapIterator& operator++() {  // Preincrement\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    assert(Ptr != End && \"incrementing end() iterator\");\n    if (shouldReverseIterate<KeyT>()) {\n      --Ptr;\n      RetreatPastEmptyBuckets();\n      return *this;\n    }\n    ++Ptr;\n    AdvancePastEmptyBuckets();\n    return *this;\n  }\n  DenseMapIterator operator++(int) {  // Postincrement\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    DenseMapIterator tmp = *this; ++*this; return tmp;\n  }\n\nprivate:\n  void AdvancePastEmptyBuckets() {\n    assert(Ptr <= End);\n    const KeyT Empty = KeyInfoT::getEmptyKey();\n    const KeyT Tombstone = KeyInfoT::getTombstoneKey();\n\n    while (Ptr != End && (KeyInfoT::isEqual(Ptr->getFirst(), Empty) ||\n                          KeyInfoT::isEqual(Ptr->getFirst(), Tombstone)))\n      ++Ptr;\n  }\n\n  void RetreatPastEmptyBuckets() {\n    assert(Ptr >= End);\n    const KeyT Empty = KeyInfoT::getEmptyKey();\n    const KeyT Tombstone = KeyInfoT::getTombstoneKey();\n\n    while (Ptr != End && (KeyInfoT::isEqual(Ptr[-1].getFirst(), Empty) ||\n                          KeyInfoT::isEqual(Ptr[-1].getFirst(), Tombstone)))\n      --Ptr;\n  }\n};\n\ntemplate <typename KeyT, typename ValueT, typename KeyInfoT>\ninline size_t capacity_in_bytes(const DenseMap<KeyT, ValueT, KeyInfoT> &X) {\n  return X.getMemorySize();\n}\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_DENSEMAP_H\n"}, "13": {"id": 13, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerSumType.h", "content": "//===- llvm/ADT/PointerSumType.h --------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_POINTERSUMTYPE_H\n#define LLVM_ADT_POINTERSUMTYPE_H\n\n#include \"llvm/ADT/bit.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include <cassert>\n#include <cstdint>\n#include <type_traits>\n\nnamespace llvm {\n\n/// A compile time pair of an integer tag and the pointer-like type which it\n/// indexes within a sum type. Also allows the user to specify a particular\n/// traits class for pointer types with custom behavior such as over-aligned\n/// allocation.\ntemplate <uintptr_t N, typename PointerArgT,\n          typename TraitsArgT = PointerLikeTypeTraits<PointerArgT>>\nstruct PointerSumTypeMember {\n  enum { Tag = N };\n  using PointerT = PointerArgT;\n  using TraitsT = TraitsArgT;\n};\n\nnamespace detail {\n\ntemplate <typename TagT, typename... MemberTs> struct PointerSumTypeHelper;\n\n} // end namespace detail\n\n/// A sum type over pointer-like types.\n///\n/// This is a normal tagged union across pointer-like types that uses the low\n/// bits of the pointers to store the tag.\n///\n/// Each member of the sum type is specified by passing a \\c\n/// PointerSumTypeMember specialization in the variadic member argument list.\n/// This allows the user to control the particular tag value associated with\n/// a particular type, use the same type for multiple different tags, and\n/// customize the pointer-like traits used for a particular member. Note that\n/// these *must* be specializations of \\c PointerSumTypeMember, no other type\n/// will suffice, even if it provides a compatible interface.\n///\n/// This type implements all of the comparison operators and even hash table\n/// support by comparing the underlying storage of the pointer values. It\n/// doesn't support delegating to particular members for comparisons.\n///\n/// It also default constructs to a zero tag with a null pointer, whatever that\n/// would be. This means that the zero value for the tag type is significant\n/// and may be desirable to set to a state that is particularly desirable to\n/// default construct.\n///\n/// Having a supported zero-valued tag also enables getting the address of a\n/// pointer stored with that tag provided it is stored in its natural bit\n/// representation. This works because in the case of a zero-valued tag, the\n/// pointer's value is directly stored into this object and we can expose the\n/// address of that internal storage. This is especially useful when building an\n/// `ArrayRef` of a single pointer stored in a sum type.\n///\n/// There is no support for constructing or accessing with a dynamic tag as\n/// that would fundamentally violate the type safety provided by the sum type.\ntemplate <typename TagT, typename... MemberTs> class PointerSumType {\n  using HelperT = detail::PointerSumTypeHelper<TagT, MemberTs...>;\n\n  // We keep both the raw value and the min tag value's pointer in a union. When\n  // the minimum tag value is zero, this allows code below to cleanly expose the\n  // address of the zero-tag pointer instead of just the zero-tag pointer\n  // itself. This is especially useful when building `ArrayRef`s out of a single\n  // pointer. However, we have to carefully access the union due to the active\n  // member potentially changing. When we *store* a new value, we directly\n  // access the union to allow us to store using the obvious types. However,\n  // when we *read* a value, we copy the underlying storage out to avoid relying\n  // on one member or the other being active.\n  union StorageT {\n    // Ensure we get a null default constructed value. We don't use a member\n    // initializer because some compilers seem to not implement those correctly\n    // for a union.\n    StorageT() : Value(0) {}\n\n    uintptr_t Value;\n\n    typename HelperT::template Lookup<HelperT::MinTag>::PointerT MinTagPointer;\n  };\n\n  StorageT Storage;\n\npublic:\n  constexpr PointerSumType() = default;\n\n  /// A typed setter to a given tagged member of the sum type.\n  template <TagT N>\n  void set(typename HelperT::template Lookup<N>::PointerT Pointer) {\n    void *V = HelperT::template Lookup<N>::TraitsT::getAsVoidPointer(Pointer);\n    assert((reinterpret_cast<uintptr_t>(V) & HelperT::TagMask) == 0 &&\n           \"Pointer is insufficiently aligned to store the discriminant!\");\n    Storage.Value = reinterpret_cast<uintptr_t>(V) | N;\n  }\n\n  /// A typed constructor for a specific tagged member of the sum type.\n  template <TagT N>\n  static PointerSumType\n  create(typename HelperT::template Lookup<N>::PointerT Pointer) {\n    PointerSumType Result;\n    Result.set<N>(Pointer);\n    return Result;\n  }\n\n  /// Clear the value to null with the min tag type.\n  void clear() { set<HelperT::MinTag>(nullptr); }\n\n  TagT getTag() const {\n    return static_cast<TagT>(getOpaqueValue() & HelperT::TagMask);\n  }\n\n  template <TagT N> bool is() const { return N == getTag(); }\n\n  template <TagT N> typename HelperT::template Lookup<N>::PointerT get() const {\n    void *P = is<N>() ? getVoidPtr() : nullptr;\n    return HelperT::template Lookup<N>::TraitsT::getFromVoidPointer(P);\n  }\n\n  template <TagT N>\n  typename HelperT::template Lookup<N>::PointerT cast() const {\n    assert(is<N>() && \"This instance has a different active member.\");\n    return HelperT::template Lookup<N>::TraitsT::getFromVoidPointer(\n        getVoidPtr());\n  }\n\n  /// If the tag is zero and the pointer's value isn't changed when being\n  /// stored, get the address of the stored value type-punned to the zero-tag's\n  /// pointer type.\n  typename HelperT::template Lookup<HelperT::MinTag>::PointerT const *\n  getAddrOfZeroTagPointer() const {\n    return const_cast<PointerSumType *>(this)->getAddrOfZeroTagPointer();\n  }\n\n  /// If the tag is zero and the pointer's value isn't changed when being\n  /// stored, get the address of the stored value type-punned to the zero-tag's\n  /// pointer type.\n  typename HelperT::template Lookup<HelperT::MinTag>::PointerT *\n  getAddrOfZeroTagPointer() {\n    static_assert(HelperT::MinTag == 0, \"Non-zero minimum tag value!\");\n    assert(is<HelperT::MinTag>() && \"The active tag is not zero!\");\n    // Store the initial value of the pointer when read out of our storage.\n    auto InitialPtr = get<HelperT::MinTag>();\n    // Now update the active member of the union to be the actual pointer-typed\n    // member so that accessing it indirectly through the returned address is\n    // valid.\n    Storage.MinTagPointer = InitialPtr;\n    // Finally, validate that this was a no-op as expected by reading it back\n    // out using the same underlying-storage read as above.\n    assert(InitialPtr == get<HelperT::MinTag>() &&\n           \"Switching to typed storage changed the pointer returned!\");\n    // Now we can correctly return an address to typed storage.\n    return &Storage.MinTagPointer;\n  }\n\n  explicit operator bool() const {\n    return getOpaqueValue() & HelperT::PointerMask;\n  }\n  bool operator==(const PointerSumType &R) const {\n    return getOpaqueValue() == R.getOpaqueValue();\n  }\n  bool operator!=(const PointerSumType &R) const {\n    return getOpaqueValue() != R.getOpaqueValue();\n  }\n  bool operator<(const PointerSumType &R) const {\n    return getOpaqueValue() < R.getOpaqueValue();\n  }\n  bool operator>(const PointerSumType &R) const {\n    return getOpaqueValue() > R.getOpaqueValue();\n  }\n  bool operator<=(const PointerSumType &R) const {\n    return getOpaqueValue() <= R.getOpaqueValue();\n  }\n  bool operator>=(const PointerSumType &R) const {\n    return getOpaqueValue() >= R.getOpaqueValue();\n  }\n\n  uintptr_t getOpaqueValue() const {\n    // Read the underlying storage of the union, regardless of the active\n    // member.\n    return bit_cast<uintptr_t>(Storage);\n  }\n\nprotected:\n  void *getVoidPtr() const {\n    return reinterpret_cast<void *>(getOpaqueValue() & HelperT::PointerMask);\n  }\n};\n\nnamespace detail {\n\n/// A helper template for implementing \\c PointerSumType. It provides fast\n/// compile-time lookup of the member from a particular tag value, along with\n/// useful constants and compile time checking infrastructure..\ntemplate <typename TagT, typename... MemberTs>\nstruct PointerSumTypeHelper : MemberTs... {\n  // First we use a trick to allow quickly looking up information about\n  // a particular member of the sum type. This works because we arranged to\n  // have this type derive from all of the member type templates. We can select\n  // the matching member for a tag using type deduction during overload\n  // resolution.\n  template <TagT N, typename PointerT, typename TraitsT>\n  static PointerSumTypeMember<N, PointerT, TraitsT>\n  LookupOverload(PointerSumTypeMember<N, PointerT, TraitsT> *);\n  template <TagT N> static void LookupOverload(...);\n  template <TagT N> struct Lookup {\n    // Compute a particular member type by resolving the lookup helper overload.\n    using MemberT = decltype(\n        LookupOverload<N>(static_cast<PointerSumTypeHelper *>(nullptr)));\n\n    /// The Nth member's pointer type.\n    using PointerT = typename MemberT::PointerT;\n\n    /// The Nth member's traits type.\n    using TraitsT = typename MemberT::TraitsT;\n  };\n\n  // Next we need to compute the number of bits available for the discriminant\n  // by taking the min of the bits available for each member. Much of this\n  // would be amazingly easier with good constexpr support.\n  template <uintptr_t V, uintptr_t... Vs>\n  struct Min : std::integral_constant<\n                   uintptr_t, (V < Min<Vs...>::value ? V : Min<Vs...>::value)> {\n  };\n  template <uintptr_t V>\n  struct Min<V> : std::integral_constant<uintptr_t, V> {};\n  enum { NumTagBits = Min<MemberTs::TraitsT::NumLowBitsAvailable...>::value };\n\n  // Also compute the smallest discriminant and various masks for convenience.\n  constexpr static TagT MinTag =\n      static_cast<TagT>(Min<MemberTs::Tag...>::value);\n  enum : uint64_t {\n    PointerMask = static_cast<uint64_t>(-1) << NumTagBits,\n    TagMask = ~PointerMask\n  };\n\n  // Finally we need a recursive template to do static checks of each\n  // member.\n  template <typename MemberT, typename... InnerMemberTs>\n  struct Checker : Checker<InnerMemberTs...> {\n    static_assert(MemberT::Tag < (1 << NumTagBits),\n                  \"This discriminant value requires too many bits!\");\n  };\n  template <typename MemberT> struct Checker<MemberT> : std::true_type {\n    static_assert(MemberT::Tag < (1 << NumTagBits),\n                  \"This discriminant value requires too many bits!\");\n  };\n  static_assert(Checker<MemberTs...>::value,\n                \"Each member must pass the checker.\");\n};\n\n} // end namespace detail\n\n// Teach DenseMap how to use PointerSumTypes as keys.\ntemplate <typename TagT, typename... MemberTs>\nstruct DenseMapInfo<PointerSumType<TagT, MemberTs...>> {\n  using SumType = PointerSumType<TagT, MemberTs...>;\n  using HelperT = detail::PointerSumTypeHelper<TagT, MemberTs...>;\n  enum { SomeTag = HelperT::MinTag };\n  using SomePointerT =\n      typename HelperT::template Lookup<HelperT::MinTag>::PointerT;\n  using SomePointerInfo = DenseMapInfo<SomePointerT>;\n\n  static inline SumType getEmptyKey() {\n    return SumType::create<SomeTag>(SomePointerInfo::getEmptyKey());\n  }\n\n  static inline SumType getTombstoneKey() {\n    return SumType::create<SomeTag>(SomePointerInfo::getTombstoneKey());\n  }\n\n  static unsigned getHashValue(const SumType &Arg) {\n    uintptr_t OpaqueValue = Arg.getOpaqueValue();\n    return DenseMapInfo<uintptr_t>::getHashValue(OpaqueValue);\n  }\n\n  static bool isEqual(const SumType &LHS, const SumType &RHS) {\n    return LHS == RHS;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_POINTERSUMTYPE_H\n"}, "16": {"id": 16, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SetVector.h", "content": "//===- llvm/ADT/SetVector.h - Set with insert order iteration ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements a set that has insertion order iteration\n// characteristics. This is useful for keeping a set of things that need to be\n// visited later but in a deterministic order (insertion order). The interface\n// is purposefully minimal.\n//\n// This file defines SetVector and SmallSetVector, which performs no allocations\n// if the SetVector has less than a certain number of elements.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_SETVECTOR_H\n#define LLVM_ADT_SETVECTOR_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/Support/Compiler.h\"\n#include <algorithm>\n#include <cassert>\n#include <iterator>\n#include <vector>\n\nnamespace llvm {\n\n/// A vector that has set insertion semantics.\n///\n/// This adapter class provides a way to keep a set of things that also has the\n/// property of a deterministic iteration order. The order of iteration is the\n/// order of insertion.\ntemplate <typename T, typename Vector = std::vector<T>,\n          typename Set = DenseSet<T>>\nclass SetVector {\npublic:\n  using value_type = T;\n  using key_type = T;\n  using reference = T&;\n  using const_reference = const T&;\n  using set_type = Set;\n  using vector_type = Vector;\n  using iterator = typename vector_type::const_iterator;\n  using const_iterator = typename vector_type::const_iterator;\n  using reverse_iterator = typename vector_type::const_reverse_iterator;\n  using const_reverse_iterator = typename vector_type::const_reverse_iterator;\n  using size_type = typename vector_type::size_type;\n\n  /// Construct an empty SetVector\n  SetVector() = default;\n\n  /// Initialize a SetVector with a range of elements\n  template<typename It>\n  SetVector(It Start, It End) {\n    insert(Start, End);\n  }\n\n  ArrayRef<T> getArrayRef() const { return vector_; }\n\n  /// Clear the SetVector and return the underlying vector.\n  Vector takeVector() {\n    set_.clear();\n    return std::move(vector_);\n  }\n\n  /// Determine if the SetVector is empty or not.\n  bool empty() const {\n    return vector_.empty();\n  }\n\n  /// Determine the number of elements in the SetVector.\n  size_type size() const {\n    return vector_.size();\n  }\n\n  /// Get an iterator to the beginning of the SetVector.\n  iterator begin() {\n    return vector_.begin();\n  }\n\n  /// Get a const_iterator to the beginning of the SetVector.\n  const_iterator begin() const {\n    return vector_.begin();\n  }\n\n  /// Get an iterator to the end of the SetVector.\n  iterator end() {\n    return vector_.end();\n  }\n\n  /// Get a const_iterator to the end of the SetVector.\n  const_iterator end() const {\n    return vector_.end();\n  }\n\n  /// Get an reverse_iterator to the end of the SetVector.\n  reverse_iterator rbegin() {\n    return vector_.rbegin();\n  }\n\n  /// Get a const_reverse_iterator to the end of the SetVector.\n  const_reverse_iterator rbegin() const {\n    return vector_.rbegin();\n  }\n\n  /// Get a reverse_iterator to the beginning of the SetVector.\n  reverse_iterator rend() {\n    return vector_.rend();\n  }\n\n  /// Get a const_reverse_iterator to the beginning of the SetVector.\n  const_reverse_iterator rend() const {\n    return vector_.rend();\n  }\n\n  /// Return the first element of the SetVector.\n  const T &front() const {\n    assert(!empty() && \"Cannot call front() on empty SetVector!\");\n    return vector_.front();\n  }\n\n  /// Return the last element of the SetVector.\n  const T &back() const {\n    assert(!empty() && \"Cannot call back() on empty SetVector!\");\n    return vector_.back();\n  }\n\n  /// Index into the SetVector.\n  const_reference operator[](size_type n) const {\n    assert(n < vector_.size() && \"SetVector access out of range!\");\n    return vector_[n];\n  }\n\n  /// Insert a new element into the SetVector.\n  /// \\returns true if the element was inserted into the SetVector.\n  bool insert(const value_type &X) {\n    bool result = set_.insert(X).second;\n    if (result)\n      vector_.push_back(X);\n    return result;\n  }\n\n  /// Insert a range of elements into the SetVector.\n  template<typename It>\n  void insert(It Start, It End) {\n    for (; Start != End; ++Start)\n      if (set_.insert(*Start).second)\n        vector_.push_back(*Start);\n  }\n\n  /// Remove an item from the set vector.\n  bool remove(const value_type& X) {\n    if (set_.erase(X)) {\n      typename vector_type::iterator I = find(vector_, X);\n      assert(I != vector_.end() && \"Corrupted SetVector instances!\");\n      vector_.erase(I);\n      return true;\n    }\n    return false;\n  }\n\n  /// Erase a single element from the set vector.\n  /// \\returns an iterator pointing to the next element that followed the\n  /// element erased. This is the end of the SetVector if the last element is\n  /// erased.\n  iterator erase(iterator I) {\n    const key_type &V = *I;\n    assert(set_.count(V) && \"Corrupted SetVector instances!\");\n    set_.erase(V);\n\n    // FIXME: No need to use the non-const iterator when built with\n    // std::vector.erase(const_iterator) as defined in C++11. This is for\n    // compatibility with non-standard libstdc++ up to 4.8 (fixed in 4.9).\n    auto NI = vector_.begin();\n    std::advance(NI, std::distance<iterator>(NI, I));\n\n    return vector_.erase(NI);\n  }\n\n  /// Remove items from the set vector based on a predicate function.\n  ///\n  /// This is intended to be equivalent to the following code, if we could\n  /// write it:\n  ///\n  /// \\code\n  ///   V.erase(remove_if(V, P), V.end());\n  /// \\endcode\n  ///\n  /// However, SetVector doesn't expose non-const iterators, making any\n  /// algorithm like remove_if impossible to use.\n  ///\n  /// \\returns true if any element is removed.\n  template <typename UnaryPredicate>\n  bool remove_if(UnaryPredicate P) {\n    typename vector_type::iterator I =\n        llvm::remove_if(vector_, TestAndEraseFromSet<UnaryPredicate>(P, set_));\n    if (I == vector_.end())\n      return false;\n    vector_.erase(I, vector_.end());\n    return true;\n  }\n\n  /// Check if the SetVector contains the given key.\n  bool contains(const key_type &key) const {\n    return set_.find(key) != set_.end();\n  }\n\n  /// Count the number of elements of a given key in the SetVector.\n  /// \\returns 0 if the element is not in the SetVector, 1 if it is.\n  size_type count(const key_type &key) const {\n    return set_.count(key);\n  }\n\n  /// Completely clear the SetVector\n  void clear() {\n    set_.clear();\n    vector_.clear();\n  }\n\n  /// Remove the last element of the SetVector.\n  void pop_back() {\n    assert(!empty() && \"Cannot remove an element from an empty SetVector!\");\n    set_.erase(back());\n    vector_.pop_back();\n  }\n\n  LLVM_NODISCARD T pop_back_val() {\n    T Ret = back();\n    pop_back();\n    return Ret;\n  }\n\n  bool operator==(const SetVector &that) const {\n    return vector_ == that.vector_;\n  }\n\n  bool operator!=(const SetVector &that) const {\n    return vector_ != that.vector_;\n  }\n\n  /// Compute This := This u S, return whether 'This' changed.\n  /// TODO: We should be able to use set_union from SetOperations.h, but\n  ///       SetVector interface is inconsistent with DenseSet.\n  template <class STy>\n  bool set_union(const STy &S) {\n    bool Changed = false;\n\n    for (typename STy::const_iterator SI = S.begin(), SE = S.end(); SI != SE;\n         ++SI)\n      if (insert(*SI))\n        Changed = true;\n\n    return Changed;\n  }\n\n  /// Compute This := This - B\n  /// TODO: We should be able to use set_subtract from SetOperations.h, but\n  ///       SetVector interface is inconsistent with DenseSet.\n  template <class STy>\n  void set_subtract(const STy &S) {\n    for (typename STy::const_iterator SI = S.begin(), SE = S.end(); SI != SE;\n         ++SI)\n      remove(*SI);\n  }\n\n  void swap(SetVector<T, Vector, Set> &RHS) {\n    set_.swap(RHS.set_);\n    vector_.swap(RHS.vector_);\n  }\n\nprivate:\n  /// A wrapper predicate designed for use with std::remove_if.\n  ///\n  /// This predicate wraps a predicate suitable for use with std::remove_if to\n  /// call set_.erase(x) on each element which is slated for removal.\n  template <typename UnaryPredicate>\n  class TestAndEraseFromSet {\n    UnaryPredicate P;\n    set_type &set_;\n\n  public:\n    TestAndEraseFromSet(UnaryPredicate P, set_type &set_)\n        : P(std::move(P)), set_(set_) {}\n\n    template <typename ArgumentT>\n    bool operator()(const ArgumentT &Arg) {\n      if (P(Arg)) {\n        set_.erase(Arg);\n        return true;\n      }\n      return false;\n    }\n  };\n\n  set_type set_;         ///< The set.\n  vector_type vector_;   ///< The vector.\n};\n\n/// A SetVector that performs no allocations if smaller than\n/// a certain size.\ntemplate <typename T, unsigned N>\nclass SmallSetVector\n    : public SetVector<T, SmallVector<T, N>, SmallDenseSet<T, N>> {\npublic:\n  SmallSetVector() = default;\n\n  /// Initialize a SmallSetVector with a range of elements\n  template<typename It>\n  SmallSetVector(It Start, It End) {\n    this->insert(Start, End);\n  }\n};\n\n} // end namespace llvm\n\nnamespace std {\n\n/// Implement std::swap in terms of SetVector swap.\ntemplate<typename T, typename V, typename S>\ninline void\nswap(llvm::SetVector<T, V, S> &LHS, llvm::SetVector<T, V, S> &RHS) {\n  LHS.swap(RHS);\n}\n\n/// Implement std::swap in terms of SmallSetVector swap.\ntemplate<typename T, unsigned N>\ninline void\nswap(llvm::SmallSetVector<T, N> &LHS, llvm::SmallSetVector<T, N> &RHS) {\n  LHS.swap(RHS);\n}\n\n} // end namespace std\n\n#endif // LLVM_ADT_SETVECTOR_H\n"}, "18": {"id": 18, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallSet.h", "content": "//===- llvm/ADT/SmallSet.h - 'Normally small' sets --------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the SmallSet class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_SMALLSET_H\n#define LLVM_ADT_SMALLSET_H\n\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <cstddef>\n#include <functional>\n#include <set>\n#include <type_traits>\n#include <utility>\n\nnamespace llvm {\n\n/// SmallSetIterator - This class implements a const_iterator for SmallSet by\n/// delegating to the underlying SmallVector or Set iterators.\ntemplate <typename T, unsigned N, typename C>\nclass SmallSetIterator\n    : public iterator_facade_base<SmallSetIterator<T, N, C>,\n                                  std::forward_iterator_tag, T> {\nprivate:\n  using SetIterTy = typename std::set<T, C>::const_iterator;\n  using VecIterTy = typename SmallVector<T, N>::const_iterator;\n  using SelfTy = SmallSetIterator<T, N, C>;\n\n  /// Iterators to the parts of the SmallSet containing the data. They are set\n  /// depending on isSmall.\n  union {\n    SetIterTy SetIter;\n    VecIterTy VecIter;\n  };\n\n  bool isSmall;\n\npublic:\n  SmallSetIterator(SetIterTy SetIter) : SetIter(SetIter), isSmall(false) {}\n\n  SmallSetIterator(VecIterTy VecIter) : VecIter(VecIter), isSmall(true) {}\n\n  // Spell out destructor, copy/move constructor and assignment operators for\n  // MSVC STL, where set<T>::const_iterator is not trivially copy constructible.\n  ~SmallSetIterator() {\n    if (isSmall)\n      VecIter.~VecIterTy();\n    else\n      SetIter.~SetIterTy();\n  }\n\n  SmallSetIterator(const SmallSetIterator &Other) : isSmall(Other.isSmall) {\n    if (isSmall)\n      VecIter = Other.VecIter;\n    else\n      // Use placement new, to make sure SetIter is properly constructed, even\n      // if it is not trivially copy-able (e.g. in MSVC).\n      new (&SetIter) SetIterTy(Other.SetIter);\n  }\n\n  SmallSetIterator(SmallSetIterator &&Other) : isSmall(Other.isSmall) {\n    if (isSmall)\n      VecIter = std::move(Other.VecIter);\n    else\n      // Use placement new, to make sure SetIter is properly constructed, even\n      // if it is not trivially copy-able (e.g. in MSVC).\n      new (&SetIter) SetIterTy(std::move(Other.SetIter));\n  }\n\n  SmallSetIterator& operator=(const SmallSetIterator& Other) {\n    // Call destructor for SetIter, so it gets properly destroyed if it is\n    // not trivially destructible in case we are setting VecIter.\n    if (!isSmall)\n      SetIter.~SetIterTy();\n\n    isSmall = Other.isSmall;\n    if (isSmall)\n      VecIter = Other.VecIter;\n    else\n      new (&SetIter) SetIterTy(Other.SetIter);\n    return *this;\n  }\n\n  SmallSetIterator& operator=(SmallSetIterator&& Other) {\n    // Call destructor for SetIter, so it gets properly destroyed if it is\n    // not trivially destructible in case we are setting VecIter.\n    if (!isSmall)\n      SetIter.~SetIterTy();\n\n    isSmall = Other.isSmall;\n    if (isSmall)\n      VecIter = std::move(Other.VecIter);\n    else\n      new (&SetIter) SetIterTy(std::move(Other.SetIter));\n    return *this;\n  }\n\n  bool operator==(const SmallSetIterator &RHS) const {\n    if (isSmall != RHS.isSmall)\n      return false;\n    if (isSmall)\n      return VecIter == RHS.VecIter;\n    return SetIter == RHS.SetIter;\n  }\n\n  SmallSetIterator &operator++() { // Preincrement\n    if (isSmall)\n      VecIter++;\n    else\n      SetIter++;\n    return *this;\n  }\n\n  const T &operator*() const { return isSmall ? *VecIter : *SetIter; }\n};\n\n/// SmallSet - This maintains a set of unique values, optimizing for the case\n/// when the set is small (less than N).  In this case, the set can be\n/// maintained with no mallocs.  If the set gets large, we expand to using an\n/// std::set to maintain reasonable lookup times.\ntemplate <typename T, unsigned N, typename C = std::less<T>>\nclass SmallSet {\n  /// Use a SmallVector to hold the elements here (even though it will never\n  /// reach its 'large' stage) to avoid calling the default ctors of elements\n  /// we will never use.\n  SmallVector<T, N> Vector;\n  std::set<T, C> Set;\n\n  using VIterator = typename SmallVector<T, N>::const_iterator;\n  using mutable_iterator = typename SmallVector<T, N>::iterator;\n\n  // In small mode SmallPtrSet uses linear search for the elements, so it is\n  // not a good idea to choose this value too high. You may consider using a\n  // DenseSet<> instead if you expect many elements in the set.\n  static_assert(N <= 32, \"N should be small\");\n\npublic:\n  using size_type = size_t;\n  using const_iterator = SmallSetIterator<T, N, C>;\n\n  SmallSet() = default;\n\n  LLVM_NODISCARD bool empty() const {\n    return Vector.empty() && Set.empty();\n  }\n\n  size_type size() const {\n    return isSmall() ? Vector.size() : Set.size();\n  }\n\n  /// count - Return 1 if the element is in the set, 0 otherwise.\n  size_type count(const T &V) const {\n    if (isSmall()) {\n      // Since the collection is small, just do a linear search.\n      return vfind(V) == Vector.end() ? 0 : 1;\n    } else {\n      return Set.count(V);\n    }\n  }\n\n  /// insert - Insert an element into the set if it isn't already there.\n  /// Returns true if the element is inserted (it was not in the set before).\n  /// The first value of the returned pair is unused and provided for\n  /// partial compatibility with the standard library self-associative container\n  /// concept.\n  // FIXME: Add iterators that abstract over the small and large form, and then\n  // return those here.\n  std::pair<NoneType, bool> insert(const T &V) {\n    if (!isSmall())\n      return std::make_pair(None, Set.insert(V).second);\n\n    VIterator I = vfind(V);\n    if (I != Vector.end())    // Don't reinsert if it already exists.\n      return std::make_pair(None, false);\n    if (Vector.size() < N) {\n      Vector.push_back(V);\n      return std::make_pair(None, true);\n    }\n\n    // Otherwise, grow from vector to set.\n    while (!Vector.empty()) {\n      Set.insert(Vector.back());\n      Vector.pop_back();\n    }\n    Set.insert(V);\n    return std::make_pair(None, true);\n  }\n\n  template <typename IterT>\n  void insert(IterT I, IterT E) {\n    for (; I != E; ++I)\n      insert(*I);\n  }\n\n  bool erase(const T &V) {\n    if (!isSmall())\n      return Set.erase(V);\n    for (mutable_iterator I = Vector.begin(), E = Vector.end(); I != E; ++I)\n      if (*I == V) {\n        Vector.erase(I);\n        return true;\n      }\n    return false;\n  }\n\n  void clear() {\n    Vector.clear();\n    Set.clear();\n  }\n\n  const_iterator begin() const {\n    if (isSmall())\n      return {Vector.begin()};\n    return {Set.begin()};\n  }\n\n  const_iterator end() const {\n    if (isSmall())\n      return {Vector.end()};\n    return {Set.end()};\n  }\n\n  /// Check if the SmallSet contains the given element.\n  bool contains(const T &V) const {\n    if (isSmall())\n      return vfind(V) != Vector.end();\n    return Set.find(V) != Set.end();\n  }\n\nprivate:\n  bool isSmall() const { return Set.empty(); }\n\n  VIterator vfind(const T &V) const {\n    for (VIterator I = Vector.begin(), E = Vector.end(); I != E; ++I)\n      if (*I == V)\n        return I;\n    return Vector.end();\n  }\n};\n\n/// If this set is of pointer values, transparently switch over to using\n/// SmallPtrSet for performance.\ntemplate <typename PointeeType, unsigned N>\nclass SmallSet<PointeeType*, N> : public SmallPtrSet<PointeeType*, N> {};\n\n/// Equality comparison for SmallSet.\n///\n/// Iterates over elements of LHS confirming that each element is also a member\n/// of RHS, and that RHS contains no additional values.\n/// Equivalent to N calls to RHS.count.\n/// For small-set mode amortized complexity is O(N^2)\n/// For large-set mode amortized complexity is linear, worst case is O(N^2) (if\n/// every hash collides).\ntemplate <typename T, unsigned LN, unsigned RN, typename C>\nbool operator==(const SmallSet<T, LN, C> &LHS, const SmallSet<T, RN, C> &RHS) {\n  if (LHS.size() != RHS.size())\n    return false;\n\n  // All elements in LHS must also be in RHS\n  return all_of(LHS, [&RHS](const T &E) { return RHS.count(E); });\n}\n\n/// Inequality comparison for SmallSet.\n///\n/// Equivalent to !(LHS == RHS). See operator== for performance notes.\ntemplate <typename T, unsigned LN, unsigned RN, typename C>\nbool operator!=(const SmallSet<T, LN, C> &LHS, const SmallSet<T, RN, C> &RHS) {\n  return !(LHS == RHS);\n}\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_SMALLSET_H\n"}, "20": {"id": 20, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h", "content": "//===- llvm/ADT/SparseBitVector.h - Efficient Sparse BitVector --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the SparseBitVector class.  See the doxygen comment for\n// SparseBitVector for more details on the algorithm used.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_SPARSEBITVECTOR_H\n#define LLVM_ADT_SPARSEBITVECTOR_H\n\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cassert>\n#include <climits>\n#include <cstring>\n#include <iterator>\n#include <list>\n\nnamespace llvm {\n\n/// SparseBitVector is an implementation of a bitvector that is sparse by only\n/// storing the elements that have non-zero bits set.  In order to make this\n/// fast for the most common cases, SparseBitVector is implemented as a linked\n/// list of SparseBitVectorElements.  We maintain a pointer to the last\n/// SparseBitVectorElement accessed (in the form of a list iterator), in order\n/// to make multiple in-order test/set constant time after the first one is\n/// executed.  Note that using vectors to store SparseBitVectorElement's does\n/// not work out very well because it causes insertion in the middle to take\n/// enormous amounts of time with a large amount of bits.  Other structures that\n/// have better worst cases for insertion in the middle (various balanced trees,\n/// etc) do not perform as well in practice as a linked list with this iterator\n/// kept up to date.  They are also significantly more memory intensive.\n\ntemplate <unsigned ElementSize = 128> struct SparseBitVectorElement {\npublic:\n  using BitWord = unsigned long;\n  using size_type = unsigned;\n  enum {\n    BITWORD_SIZE = sizeof(BitWord) * CHAR_BIT,\n    BITWORDS_PER_ELEMENT = (ElementSize + BITWORD_SIZE - 1) / BITWORD_SIZE,\n    BITS_PER_ELEMENT = ElementSize\n  };\n\nprivate:\n  // Index of Element in terms of where first bit starts.\n  unsigned ElementIndex;\n  BitWord Bits[BITWORDS_PER_ELEMENT];\n\n  SparseBitVectorElement() {\n    ElementIndex = ~0U;\n    memset(&Bits[0], 0, sizeof (BitWord) * BITWORDS_PER_ELEMENT);\n  }\n\npublic:\n  explicit SparseBitVectorElement(unsigned Idx) {\n    ElementIndex = Idx;\n    memset(&Bits[0], 0, sizeof (BitWord) * BITWORDS_PER_ELEMENT);\n  }\n\n  // Comparison.\n  bool operator==(const SparseBitVectorElement &RHS) const {\n    if (ElementIndex != RHS.ElementIndex)\n      return false;\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i)\n      if (Bits[i] != RHS.Bits[i])\n        return false;\n    return true;\n  }\n\n  bool operator!=(const SparseBitVectorElement &RHS) const {\n    return !(*this == RHS);\n  }\n\n  // Return the bits that make up word Idx in our element.\n  BitWord word(unsigned Idx) const {\n    assert(Idx < BITWORDS_PER_ELEMENT);\n    return Bits[Idx];\n  }\n\n  unsigned index() const {\n    return ElementIndex;\n  }\n\n  bool empty() const {\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i)\n      if (Bits[i])\n        return false;\n    return true;\n  }\n\n  void set(unsigned Idx) {\n    Bits[Idx / BITWORD_SIZE] |= 1L << (Idx % BITWORD_SIZE);\n  }\n\n  bool test_and_set(unsigned Idx) {\n    bool old = test(Idx);\n    if (!old) {\n      set(Idx);\n      return true;\n    }\n    return false;\n  }\n\n  void reset(unsigned Idx) {\n    Bits[Idx / BITWORD_SIZE] &= ~(1L << (Idx % BITWORD_SIZE));\n  }\n\n  bool test(unsigned Idx) const {\n    return Bits[Idx / BITWORD_SIZE] & (1L << (Idx % BITWORD_SIZE));\n  }\n\n  size_type count() const {\n    unsigned NumBits = 0;\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i)\n      NumBits += countPopulation(Bits[i]);\n    return NumBits;\n  }\n\n  /// find_first - Returns the index of the first set bit.\n  int find_first() const {\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i)\n      if (Bits[i] != 0)\n        return i * BITWORD_SIZE + countTrailingZeros(Bits[i]);\n    llvm_unreachable(\"Illegal empty element\");\n  }\n\n  /// find_last - Returns the index of the last set bit.\n  int find_last() const {\n    for (unsigned I = 0; I < BITWORDS_PER_ELEMENT; ++I) {\n      unsigned Idx = BITWORDS_PER_ELEMENT - I - 1;\n      if (Bits[Idx] != 0)\n        return Idx * BITWORD_SIZE + BITWORD_SIZE -\n               countLeadingZeros(Bits[Idx]) - 1;\n    }\n    llvm_unreachable(\"Illegal empty element\");\n  }\n\n  /// find_next - Returns the index of the next set bit starting from the\n  /// \"Curr\" bit. Returns -1 if the next set bit is not found.\n  int find_next(unsigned Curr) const {\n    if (Curr >= BITS_PER_ELEMENT)\n      return -1;\n\n    unsigned WordPos = Curr / BITWORD_SIZE;\n    unsigned BitPos = Curr % BITWORD_SIZE;\n    BitWord Copy = Bits[WordPos];\n    assert(WordPos <= BITWORDS_PER_ELEMENT\n           && \"Word Position outside of element\");\n\n    // Mask off previous bits.\n    Copy &= ~0UL << BitPos;\n\n    if (Copy != 0)\n      return WordPos * BITWORD_SIZE + countTrailingZeros(Copy);\n\n    // Check subsequent words.\n    for (unsigned i = WordPos+1; i < BITWORDS_PER_ELEMENT; ++i)\n      if (Bits[i] != 0)\n        return i * BITWORD_SIZE + countTrailingZeros(Bits[i]);\n    return -1;\n  }\n\n  // Union this element with RHS and return true if this one changed.\n  bool unionWith(const SparseBitVectorElement &RHS) {\n    bool changed = false;\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i) {\n      BitWord old = changed ? 0 : Bits[i];\n\n      Bits[i] |= RHS.Bits[i];\n      if (!changed && old != Bits[i])\n        changed = true;\n    }\n    return changed;\n  }\n\n  // Return true if we have any bits in common with RHS\n  bool intersects(const SparseBitVectorElement &RHS) const {\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i) {\n      if (RHS.Bits[i] & Bits[i])\n        return true;\n    }\n    return false;\n  }\n\n  // Intersect this Element with RHS and return true if this one changed.\n  // BecameZero is set to true if this element became all-zero bits.\n  bool intersectWith(const SparseBitVectorElement &RHS,\n                     bool &BecameZero) {\n    bool changed = false;\n    bool allzero = true;\n\n    BecameZero = false;\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i) {\n      BitWord old = changed ? 0 : Bits[i];\n\n      Bits[i] &= RHS.Bits[i];\n      if (Bits[i] != 0)\n        allzero = false;\n\n      if (!changed && old != Bits[i])\n        changed = true;\n    }\n    BecameZero = allzero;\n    return changed;\n  }\n\n  // Intersect this Element with the complement of RHS and return true if this\n  // one changed.  BecameZero is set to true if this element became all-zero\n  // bits.\n  bool intersectWithComplement(const SparseBitVectorElement &RHS,\n                               bool &BecameZero) {\n    bool changed = false;\n    bool allzero = true;\n\n    BecameZero = false;\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i) {\n      BitWord old = changed ? 0 : Bits[i];\n\n      Bits[i] &= ~RHS.Bits[i];\n      if (Bits[i] != 0)\n        allzero = false;\n\n      if (!changed && old != Bits[i])\n        changed = true;\n    }\n    BecameZero = allzero;\n    return changed;\n  }\n\n  // Three argument version of intersectWithComplement that intersects\n  // RHS1 & ~RHS2 into this element\n  void intersectWithComplement(const SparseBitVectorElement &RHS1,\n                               const SparseBitVectorElement &RHS2,\n                               bool &BecameZero) {\n    bool allzero = true;\n\n    BecameZero = false;\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i) {\n      Bits[i] = RHS1.Bits[i] & ~RHS2.Bits[i];\n      if (Bits[i] != 0)\n        allzero = false;\n    }\n    BecameZero = allzero;\n  }\n};\n\ntemplate <unsigned ElementSize = 128>\nclass SparseBitVector {\n  using ElementList = std::list<SparseBitVectorElement<ElementSize>>;\n  using ElementListIter = typename ElementList::iterator;\n  using ElementListConstIter = typename ElementList::const_iterator;\n  enum {\n    BITWORD_SIZE = SparseBitVectorElement<ElementSize>::BITWORD_SIZE\n  };\n\n  ElementList Elements;\n  // Pointer to our current Element. This has no visible effect on the external\n  // state of a SparseBitVector, it's just used to improve performance in the\n  // common case of testing/modifying bits with similar indices.\n  mutable ElementListIter CurrElementIter;\n\n  // This is like std::lower_bound, except we do linear searching from the\n  // current position.\n  ElementListIter FindLowerBoundImpl(unsigned ElementIndex) const {\n\n    // We cache a non-const iterator so we're forced to resort to const_cast to\n    // get the begin/end in the case where 'this' is const. To avoid duplication\n    // of code with the only difference being whether the const cast is present\n    // 'this' is always const in this particular function and we sort out the\n    // difference in FindLowerBound and FindLowerBoundConst.\n    ElementListIter Begin =\n        const_cast<SparseBitVector<ElementSize> *>(this)->Elements.begin();\n    ElementListIter End =\n        const_cast<SparseBitVector<ElementSize> *>(this)->Elements.end();\n\n    if (Elements.empty()) {\n      CurrElementIter = Begin;\n      return CurrElementIter;\n    }\n\n    // Make sure our current iterator is valid.\n    if (CurrElementIter == End)\n      --CurrElementIter;\n\n    // Search from our current iterator, either backwards or forwards,\n    // depending on what element we are looking for.\n    ElementListIter ElementIter = CurrElementIter;\n    if (CurrElementIter->index() == ElementIndex) {\n      return ElementIter;\n    } else if (CurrElementIter->index() > ElementIndex) {\n      while (ElementIter != Begin\n             && ElementIter->index() > ElementIndex)\n        --ElementIter;\n    } else {\n      while (ElementIter != End &&\n             ElementIter->index() < ElementIndex)\n        ++ElementIter;\n    }\n    CurrElementIter = ElementIter;\n    return ElementIter;\n  }\n  ElementListConstIter FindLowerBoundConst(unsigned ElementIndex) const {\n    return FindLowerBoundImpl(ElementIndex);\n  }\n  ElementListIter FindLowerBound(unsigned ElementIndex) {\n    return FindLowerBoundImpl(ElementIndex);\n  }\n\n  // Iterator to walk set bits in the bitmap.  This iterator is a lot uglier\n  // than it would be, in order to be efficient.\n  class SparseBitVectorIterator {\n  private:\n    bool AtEnd;\n\n    const SparseBitVector<ElementSize> *BitVector = nullptr;\n\n    // Current element inside of bitmap.\n    ElementListConstIter Iter;\n\n    // Current bit number inside of our bitmap.\n    unsigned BitNumber;\n\n    // Current word number inside of our element.\n    unsigned WordNumber;\n\n    // Current bits from the element.\n    typename SparseBitVectorElement<ElementSize>::BitWord Bits;\n\n    // Move our iterator to the first non-zero bit in the bitmap.\n    void AdvanceToFirstNonZero() {\n      if (AtEnd)\n        return;\n      if (BitVector->Elements.empty()) {\n        AtEnd = true;\n        return;\n      }\n      Iter = BitVector->Elements.begin();\n      BitNumber = Iter->index() * ElementSize;\n      unsigned BitPos = Iter->find_first();\n      BitNumber += BitPos;\n      WordNumber = (BitNumber % ElementSize) / BITWORD_SIZE;\n      Bits = Iter->word(WordNumber);\n      Bits >>= BitPos % BITWORD_SIZE;\n    }\n\n    // Move our iterator to the next non-zero bit.\n    void AdvanceToNextNonZero() {\n      if (AtEnd)\n        return;\n\n      while (Bits && !(Bits & 1)) {\n        Bits >>= 1;\n        BitNumber += 1;\n      }\n\n      // See if we ran out of Bits in this word.\n      if (!Bits) {\n        int NextSetBitNumber = Iter->find_next(BitNumber % ElementSize) ;\n        // If we ran out of set bits in this element, move to next element.\n        if (NextSetBitNumber == -1 || (BitNumber % ElementSize == 0)) {\n          ++Iter;\n          WordNumber = 0;\n\n          // We may run out of elements in the bitmap.\n          if (Iter == BitVector->Elements.end()) {\n            AtEnd = true;\n            return;\n          }\n          // Set up for next non-zero word in bitmap.\n          BitNumber = Iter->index() * ElementSize;\n          NextSetBitNumber = Iter->find_first();\n          BitNumber += NextSetBitNumber;\n          WordNumber = (BitNumber % ElementSize) / BITWORD_SIZE;\n          Bits = Iter->word(WordNumber);\n          Bits >>= NextSetBitNumber % BITWORD_SIZE;\n        } else {\n          WordNumber = (NextSetBitNumber % ElementSize) / BITWORD_SIZE;\n          Bits = Iter->word(WordNumber);\n          Bits >>= NextSetBitNumber % BITWORD_SIZE;\n          BitNumber = Iter->index() * ElementSize;\n          BitNumber += NextSetBitNumber;\n        }\n      }\n    }\n\n  public:\n    SparseBitVectorIterator() = default;\n\n    SparseBitVectorIterator(const SparseBitVector<ElementSize> *RHS,\n                            bool end = false):BitVector(RHS) {\n      Iter = BitVector->Elements.begin();\n      BitNumber = 0;\n      Bits = 0;\n      WordNumber = ~0;\n      AtEnd = end;\n      AdvanceToFirstNonZero();\n    }\n\n    // Preincrement.\n    inline SparseBitVectorIterator& operator++() {\n      ++BitNumber;\n      Bits >>= 1;\n      AdvanceToNextNonZero();\n      return *this;\n    }\n\n    // Postincrement.\n    inline SparseBitVectorIterator operator++(int) {\n      SparseBitVectorIterator tmp = *this;\n      ++*this;\n      return tmp;\n    }\n\n    // Return the current set bit number.\n    unsigned operator*() const {\n      return BitNumber;\n    }\n\n    bool operator==(const SparseBitVectorIterator &RHS) const {\n      // If they are both at the end, ignore the rest of the fields.\n      if (AtEnd && RHS.AtEnd)\n        return true;\n      // Otherwise they are the same if they have the same bit number and\n      // bitmap.\n      return AtEnd == RHS.AtEnd && RHS.BitNumber == BitNumber;\n    }\n\n    bool operator!=(const SparseBitVectorIterator &RHS) const {\n      return !(*this == RHS);\n    }\n  };\n\npublic:\n  using iterator = SparseBitVectorIterator;\n\n  SparseBitVector() : Elements(), CurrElementIter(Elements.begin()) {}\n\n  SparseBitVector(const SparseBitVector &RHS)\n      : Elements(RHS.Elements), CurrElementIter(Elements.begin()) {}\n  SparseBitVector(SparseBitVector &&RHS)\n      : Elements(std::move(RHS.Elements)), CurrElementIter(Elements.begin()) {}\n\n  // Clear.\n  void clear() {\n    Elements.clear();\n  }\n\n  // Assignment\n  SparseBitVector& operator=(const SparseBitVector& RHS) {\n    if (this == &RHS)\n      return *this;\n\n    Elements = RHS.Elements;\n    CurrElementIter = Elements.begin();\n    return *this;\n  }\n  SparseBitVector &operator=(SparseBitVector &&RHS) {\n    Elements = std::move(RHS.Elements);\n    CurrElementIter = Elements.begin();\n    return *this;\n  }\n\n  // Test, Reset, and Set a bit in the bitmap.\n  bool test(unsigned Idx) const {\n    if (Elements.empty())\n      return false;\n\n    unsigned ElementIndex = Idx / ElementSize;\n    ElementListConstIter ElementIter = FindLowerBoundConst(ElementIndex);\n\n    // If we can't find an element that is supposed to contain this bit, there\n    // is nothing more to do.\n    if (ElementIter == Elements.end() ||\n        ElementIter->index() != ElementIndex)\n      return false;\n    return ElementIter->test(Idx % ElementSize);\n  }\n\n  void reset(unsigned Idx) {\n    if (Elements.empty())\n      return;\n\n    unsigned ElementIndex = Idx / ElementSize;\n    ElementListIter ElementIter = FindLowerBound(ElementIndex);\n\n    // If we can't find an element that is supposed to contain this bit, there\n    // is nothing more to do.\n    if (ElementIter == Elements.end() ||\n        ElementIter->index() != ElementIndex)\n      return;\n    ElementIter->reset(Idx % ElementSize);\n\n    // When the element is zeroed out, delete it.\n    if (ElementIter->empty()) {\n      ++CurrElementIter;\n      Elements.erase(ElementIter);\n    }\n  }\n\n  void set(unsigned Idx) {\n    unsigned ElementIndex = Idx / ElementSize;\n    ElementListIter ElementIter;\n    if (Elements.empty()) {\n      ElementIter = Elements.emplace(Elements.end(), ElementIndex);\n    } else {\n      ElementIter = FindLowerBound(ElementIndex);\n\n      if (ElementIter == Elements.end() ||\n          ElementIter->index() != ElementIndex) {\n        // We may have hit the beginning of our SparseBitVector, in which case,\n        // we may need to insert right after this element, which requires moving\n        // the current iterator forward one, because insert does insert before.\n        if (ElementIter != Elements.end() &&\n            ElementIter->index() < ElementIndex)\n          ++ElementIter;\n        ElementIter = Elements.emplace(ElementIter, ElementIndex);\n      }\n    }\n    CurrElementIter = ElementIter;\n\n    ElementIter->set(Idx % ElementSize);\n  }\n\n  bool test_and_set(unsigned Idx) {\n    bool old = test(Idx);\n    if (!old) {\n      set(Idx);\n      return true;\n    }\n    return false;\n  }\n\n  bool operator!=(const SparseBitVector &RHS) const {\n    return !(*this == RHS);\n  }\n\n  bool operator==(const SparseBitVector &RHS) const {\n    ElementListConstIter Iter1 = Elements.begin();\n    ElementListConstIter Iter2 = RHS.Elements.begin();\n\n    for (; Iter1 != Elements.end() && Iter2 != RHS.Elements.end();\n         ++Iter1, ++Iter2) {\n      if (*Iter1 != *Iter2)\n        return false;\n    }\n    return Iter1 == Elements.end() && Iter2 == RHS.Elements.end();\n  }\n\n  // Union our bitmap with the RHS and return true if we changed.\n  bool operator|=(const SparseBitVector &RHS) {\n    if (this == &RHS)\n      return false;\n\n    bool changed = false;\n    ElementListIter Iter1 = Elements.begin();\n    ElementListConstIter Iter2 = RHS.Elements.begin();\n\n    // If RHS is empty, we are done\n    if (RHS.Elements.empty())\n      return false;\n\n    while (Iter2 != RHS.Elements.end()) {\n      if (Iter1 == Elements.end() || Iter1->index() > Iter2->index()) {\n        Elements.insert(Iter1, *Iter2);\n        ++Iter2;\n        changed = true;\n      } else if (Iter1->index() == Iter2->index()) {\n        changed |= Iter1->unionWith(*Iter2);\n        ++Iter1;\n        ++Iter2;\n      } else {\n        ++Iter1;\n      }\n    }\n    CurrElementIter = Elements.begin();\n    return changed;\n  }\n\n  // Intersect our bitmap with the RHS and return true if ours changed.\n  bool operator&=(const SparseBitVector &RHS) {\n    if (this == &RHS)\n      return false;\n\n    bool changed = false;\n    ElementListIter Iter1 = Elements.begin();\n    ElementListConstIter Iter2 = RHS.Elements.begin();\n\n    // Check if both bitmaps are empty.\n    if (Elements.empty() && RHS.Elements.empty())\n      return false;\n\n    // Loop through, intersecting as we go, erasing elements when necessary.\n    while (Iter2 != RHS.Elements.end()) {\n      if (Iter1 == Elements.end()) {\n        CurrElementIter = Elements.begin();\n        return changed;\n      }\n\n      if (Iter1->index() > Iter2->index()) {\n        ++Iter2;\n      } else if (Iter1->index() == Iter2->index()) {\n        bool BecameZero;\n        changed |= Iter1->intersectWith(*Iter2, BecameZero);\n        if (BecameZero) {\n          ElementListIter IterTmp = Iter1;\n          ++Iter1;\n          Elements.erase(IterTmp);\n        } else {\n          ++Iter1;\n        }\n        ++Iter2;\n      } else {\n        ElementListIter IterTmp = Iter1;\n        ++Iter1;\n        Elements.erase(IterTmp);\n        changed = true;\n      }\n    }\n    if (Iter1 != Elements.end()) {\n      Elements.erase(Iter1, Elements.end());\n      changed = true;\n    }\n    CurrElementIter = Elements.begin();\n    return changed;\n  }\n\n  // Intersect our bitmap with the complement of the RHS and return true\n  // if ours changed.\n  bool intersectWithComplement(const SparseBitVector &RHS) {\n    if (this == &RHS) {\n      if (!empty()) {\n        clear();\n        return true;\n      }\n      return false;\n    }\n\n    bool changed = false;\n    ElementListIter Iter1 = Elements.begin();\n    ElementListConstIter Iter2 = RHS.Elements.begin();\n\n    // If either our bitmap or RHS is empty, we are done\n    if (Elements.empty() || RHS.Elements.empty())\n      return false;\n\n    // Loop through, intersecting as we go, erasing elements when necessary.\n    while (Iter2 != RHS.Elements.end()) {\n      if (Iter1 == Elements.end()) {\n        CurrElementIter = Elements.begin();\n        return changed;\n      }\n\n      if (Iter1->index() > Iter2->index()) {\n        ++Iter2;\n      } else if (Iter1->index() == Iter2->index()) {\n        bool BecameZero;\n        changed |= Iter1->intersectWithComplement(*Iter2, BecameZero);\n        if (BecameZero) {\n          ElementListIter IterTmp = Iter1;\n          ++Iter1;\n          Elements.erase(IterTmp);\n        } else {\n          ++Iter1;\n        }\n        ++Iter2;\n      } else {\n        ++Iter1;\n      }\n    }\n    CurrElementIter = Elements.begin();\n    return changed;\n  }\n\n  bool intersectWithComplement(const SparseBitVector<ElementSize> *RHS) const {\n    return intersectWithComplement(*RHS);\n  }\n\n  //  Three argument version of intersectWithComplement.\n  //  Result of RHS1 & ~RHS2 is stored into this bitmap.\n  void intersectWithComplement(const SparseBitVector<ElementSize> &RHS1,\n                               const SparseBitVector<ElementSize> &RHS2)\n  {\n    if (this == &RHS1) {\n      intersectWithComplement(RHS2);\n      return;\n    } else if (this == &RHS2) {\n      SparseBitVector RHS2Copy(RHS2);\n      intersectWithComplement(RHS1, RHS2Copy);\n      return;\n    }\n\n    Elements.clear();\n    CurrElementIter = Elements.begin();\n    ElementListConstIter Iter1 = RHS1.Elements.begin();\n    ElementListConstIter Iter2 = RHS2.Elements.begin();\n\n    // If RHS1 is empty, we are done\n    // If RHS2 is empty, we still have to copy RHS1\n    if (RHS1.Elements.empty())\n      return;\n\n    // Loop through, intersecting as we go, erasing elements when necessary.\n    while (Iter2 != RHS2.Elements.end()) {\n      if (Iter1 == RHS1.Elements.end())\n        return;\n\n      if (Iter1->index() > Iter2->index()) {\n        ++Iter2;\n      } else if (Iter1->index() == Iter2->index()) {\n        bool BecameZero = false;\n        Elements.emplace_back(Iter1->index());\n        Elements.back().intersectWithComplement(*Iter1, *Iter2, BecameZero);\n        if (BecameZero)\n          Elements.pop_back();\n        ++Iter1;\n        ++Iter2;\n      } else {\n        Elements.push_back(*Iter1++);\n      }\n    }\n\n    // copy the remaining elements\n    std::copy(Iter1, RHS1.Elements.end(), std::back_inserter(Elements));\n  }\n\n  void intersectWithComplement(const SparseBitVector<ElementSize> *RHS1,\n                               const SparseBitVector<ElementSize> *RHS2) {\n    intersectWithComplement(*RHS1, *RHS2);\n  }\n\n  bool intersects(const SparseBitVector<ElementSize> *RHS) const {\n    return intersects(*RHS);\n  }\n\n  // Return true if we share any bits in common with RHS\n  bool intersects(const SparseBitVector<ElementSize> &RHS) const {\n    ElementListConstIter Iter1 = Elements.begin();\n    ElementListConstIter Iter2 = RHS.Elements.begin();\n\n    // Check if both bitmaps are empty.\n    if (Elements.empty() && RHS.Elements.empty())\n      return false;\n\n    // Loop through, intersecting stopping when we hit bits in common.\n    while (Iter2 != RHS.Elements.end()) {\n      if (Iter1 == Elements.end())\n        return false;\n\n      if (Iter1->index() > Iter2->index()) {\n        ++Iter2;\n      } else if (Iter1->index() == Iter2->index()) {\n        if (Iter1->intersects(*Iter2))\n          return true;\n        ++Iter1;\n        ++Iter2;\n      } else {\n        ++Iter1;\n      }\n    }\n    return false;\n  }\n\n  // Return true iff all bits set in this SparseBitVector are\n  // also set in RHS.\n  bool contains(const SparseBitVector<ElementSize> &RHS) const {\n    SparseBitVector<ElementSize> Result(*this);\n    Result &= RHS;\n    return (Result == RHS);\n  }\n\n  // Return the first set bit in the bitmap.  Return -1 if no bits are set.\n  int find_first() const {\n    if (Elements.empty())\n      return -1;\n    const SparseBitVectorElement<ElementSize> &First = *(Elements.begin());\n    return (First.index() * ElementSize) + First.find_first();\n  }\n\n  // Return the last set bit in the bitmap.  Return -1 if no bits are set.\n  int find_last() const {\n    if (Elements.empty())\n      return -1;\n    const SparseBitVectorElement<ElementSize> &Last = *(Elements.rbegin());\n    return (Last.index() * ElementSize) + Last.find_last();\n  }\n\n  // Return true if the SparseBitVector is empty\n  bool empty() const {\n    return Elements.empty();\n  }\n\n  unsigned count() const {\n    unsigned BitCount = 0;\n    for (ElementListConstIter Iter = Elements.begin();\n         Iter != Elements.end();\n         ++Iter)\n      BitCount += Iter->count();\n\n    return BitCount;\n  }\n\n  iterator begin() const {\n    return iterator(this);\n  }\n\n  iterator end() const {\n    return iterator(this, true);\n  }\n};\n\n// Convenience functions to allow Or and And without dereferencing in the user\n// code.\n\ntemplate <unsigned ElementSize>\ninline bool operator |=(SparseBitVector<ElementSize> &LHS,\n                        const SparseBitVector<ElementSize> *RHS) {\n  return LHS |= *RHS;\n}\n\ntemplate <unsigned ElementSize>\ninline bool operator |=(SparseBitVector<ElementSize> *LHS,\n                        const SparseBitVector<ElementSize> &RHS) {\n  return LHS->operator|=(RHS);\n}\n\ntemplate <unsigned ElementSize>\ninline bool operator &=(SparseBitVector<ElementSize> *LHS,\n                        const SparseBitVector<ElementSize> &RHS) {\n  return LHS->operator&=(RHS);\n}\n\ntemplate <unsigned ElementSize>\ninline bool operator &=(SparseBitVector<ElementSize> &LHS,\n                        const SparseBitVector<ElementSize> *RHS) {\n  return LHS &= *RHS;\n}\n\n// Convenience functions for infix union, intersection, difference operators.\n\ntemplate <unsigned ElementSize>\ninline SparseBitVector<ElementSize>\noperator|(const SparseBitVector<ElementSize> &LHS,\n          const SparseBitVector<ElementSize> &RHS) {\n  SparseBitVector<ElementSize> Result(LHS);\n  Result |= RHS;\n  return Result;\n}\n\ntemplate <unsigned ElementSize>\ninline SparseBitVector<ElementSize>\noperator&(const SparseBitVector<ElementSize> &LHS,\n          const SparseBitVector<ElementSize> &RHS) {\n  SparseBitVector<ElementSize> Result(LHS);\n  Result &= RHS;\n  return Result;\n}\n\ntemplate <unsigned ElementSize>\ninline SparseBitVector<ElementSize>\noperator-(const SparseBitVector<ElementSize> &LHS,\n          const SparseBitVector<ElementSize> &RHS) {\n  SparseBitVector<ElementSize> Result;\n  Result.intersectWithComplement(LHS, RHS);\n  return Result;\n}\n\n// Dump a SparseBitVector to a stream\ntemplate <unsigned ElementSize>\nvoid dump(const SparseBitVector<ElementSize> &LHS, raw_ostream &out) {\n  out << \"[\";\n\n  typename SparseBitVector<ElementSize>::iterator bi = LHS.begin(),\n    be = LHS.end();\n  if (bi != be) {\n    out << *bi;\n    for (++bi; bi != be; ++bi) {\n      out << \" \" << *bi;\n    }\n  }\n  out << \"]\\n\";\n}\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_SPARSEBITVECTOR_H\n"}, "24": {"id": 24, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist_iterator.h", "content": "//===- llvm/ADT/ilist_iterator.h - Intrusive List Iterator ------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_ILIST_ITERATOR_H\n#define LLVM_ADT_ILIST_ITERATOR_H\n\n#include \"llvm/ADT/ilist_node.h\"\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <type_traits>\n\nnamespace llvm {\n\nnamespace ilist_detail {\n\n/// Find const-correct node types.\ntemplate <class OptionsT, bool IsConst> struct IteratorTraits;\ntemplate <class OptionsT> struct IteratorTraits<OptionsT, false> {\n  using value_type = typename OptionsT::value_type;\n  using pointer = typename OptionsT::pointer;\n  using reference = typename OptionsT::reference;\n  using node_pointer = ilist_node_impl<OptionsT> *;\n  using node_reference = ilist_node_impl<OptionsT> &;\n};\ntemplate <class OptionsT> struct IteratorTraits<OptionsT, true> {\n  using value_type = const typename OptionsT::value_type;\n  using pointer = typename OptionsT::const_pointer;\n  using reference = typename OptionsT::const_reference;\n  using node_pointer = const ilist_node_impl<OptionsT> *;\n  using node_reference = const ilist_node_impl<OptionsT> &;\n};\n\ntemplate <bool IsReverse> struct IteratorHelper;\ntemplate <> struct IteratorHelper<false> : ilist_detail::NodeAccess {\n  using Access = ilist_detail::NodeAccess;\n\n  template <class T> static void increment(T *&I) { I = Access::getNext(*I); }\n  template <class T> static void decrement(T *&I) { I = Access::getPrev(*I); }\n};\ntemplate <> struct IteratorHelper<true> : ilist_detail::NodeAccess {\n  using Access = ilist_detail::NodeAccess;\n\n  template <class T> static void increment(T *&I) { I = Access::getPrev(*I); }\n  template <class T> static void decrement(T *&I) { I = Access::getNext(*I); }\n};\n\n} // end namespace ilist_detail\n\n/// Iterator for intrusive lists  based on ilist_node.\ntemplate <class OptionsT, bool IsReverse, bool IsConst>\nclass ilist_iterator : ilist_detail::SpecificNodeAccess<OptionsT> {\n  friend ilist_iterator<OptionsT, IsReverse, !IsConst>;\n  friend ilist_iterator<OptionsT, !IsReverse, IsConst>;\n  friend ilist_iterator<OptionsT, !IsReverse, !IsConst>;\n\n  using Traits = ilist_detail::IteratorTraits<OptionsT, IsConst>;\n  using Access = ilist_detail::SpecificNodeAccess<OptionsT>;\n\npublic:\n  using value_type = typename Traits::value_type;\n  using pointer = typename Traits::pointer;\n  using reference = typename Traits::reference;\n  using difference_type = ptrdiff_t;\n  using iterator_category = std::bidirectional_iterator_tag;\n  using const_pointer = typename OptionsT::const_pointer;\n  using const_reference = typename OptionsT::const_reference;\n\nprivate:\n  using node_pointer = typename Traits::node_pointer;\n  using node_reference = typename Traits::node_reference;\n\n  node_pointer NodePtr = nullptr;\n\npublic:\n  /// Create from an ilist_node.\n  explicit ilist_iterator(node_reference N) : NodePtr(&N) {}\n\n  explicit ilist_iterator(pointer NP) : NodePtr(Access::getNodePtr(NP)) {}\n  explicit ilist_iterator(reference NR) : NodePtr(Access::getNodePtr(&NR)) {}\n  ilist_iterator() = default;\n\n  // This is templated so that we can allow constructing a const iterator from\n  // a nonconst iterator...\n  template <bool RHSIsConst>\n  ilist_iterator(const ilist_iterator<OptionsT, IsReverse, RHSIsConst> &RHS,\n                 std::enable_if_t<IsConst || !RHSIsConst, void *> = nullptr)\n      : NodePtr(RHS.NodePtr) {}\n\n  // This is templated so that we can allow assigning to a const iterator from\n  // a nonconst iterator...\n  template <bool RHSIsConst>\n  std::enable_if_t<IsConst || !RHSIsConst, ilist_iterator &>\n  operator=(const ilist_iterator<OptionsT, IsReverse, RHSIsConst> &RHS) {\n    NodePtr = RHS.NodePtr;\n    return *this;\n  }\n\n  /// Explicit conversion between forward/reverse iterators.\n  ///\n  /// Translate between forward and reverse iterators without changing range\n  /// boundaries.  The resulting iterator will dereference (and have a handle)\n  /// to the previous node, which is somewhat unexpected; but converting the\n  /// two endpoints in a range will give the same range in reverse.\n  ///\n  /// This matches std::reverse_iterator conversions.\n  explicit ilist_iterator(\n      const ilist_iterator<OptionsT, !IsReverse, IsConst> &RHS)\n      : ilist_iterator(++RHS.getReverse()) {}\n\n  /// Get a reverse iterator to the same node.\n  ///\n  /// Gives a reverse iterator that will dereference (and have a handle) to the\n  /// same node.  Converting the endpoint iterators in a range will give a\n  /// different range; for range operations, use the explicit conversions.\n  ilist_iterator<OptionsT, !IsReverse, IsConst> getReverse() const {\n    if (NodePtr)\n      return ilist_iterator<OptionsT, !IsReverse, IsConst>(*NodePtr);\n    return ilist_iterator<OptionsT, !IsReverse, IsConst>();\n  }\n\n  /// Const-cast.\n  ilist_iterator<OptionsT, IsReverse, false> getNonConst() const {\n    if (NodePtr)\n      return ilist_iterator<OptionsT, IsReverse, false>(\n          const_cast<typename ilist_iterator<OptionsT, IsReverse,\n                                             false>::node_reference>(*NodePtr));\n    return ilist_iterator<OptionsT, IsReverse, false>();\n  }\n\n  // Accessors...\n  reference operator*() const {\n    assert(!NodePtr->isKnownSentinel());\n    return *Access::getValuePtr(NodePtr);\n  }\n  pointer operator->() const { return &operator*(); }\n\n  // Comparison operators\n  friend bool operator==(const ilist_iterator &LHS, const ilist_iterator &RHS) {\n    return LHS.NodePtr == RHS.NodePtr;\n  }\n  friend bool operator!=(const ilist_iterator &LHS, const ilist_iterator &RHS) {\n    return LHS.NodePtr != RHS.NodePtr;\n  }\n\n  // Increment and decrement operators...\n  ilist_iterator &operator--() {\n    NodePtr = IsReverse ? NodePtr->getNext() : NodePtr->getPrev();\n    return *this;\n  }\n  ilist_iterator &operator++() {\n    NodePtr = IsReverse ? NodePtr->getPrev() : NodePtr->getNext();\n    return *this;\n  }\n  ilist_iterator operator--(int) {\n    ilist_iterator tmp = *this;\n    --*this;\n    return tmp;\n  }\n  ilist_iterator operator++(int) {\n    ilist_iterator tmp = *this;\n    ++*this;\n    return tmp;\n  }\n\n  /// Get the underlying ilist_node.\n  node_pointer getNodePtr() const { return static_cast<node_pointer>(NodePtr); }\n\n  /// Check for end.  Only valid if ilist_sentinel_tracking<true>.\n  bool isEnd() const { return NodePtr ? NodePtr->isSentinel() : false; }\n};\n\ntemplate <typename From> struct simplify_type;\n\n/// Allow ilist_iterators to convert into pointers to a node automatically when\n/// used by the dyn_cast, cast, isa mechanisms...\n///\n/// FIXME: remove this, since there is no implicit conversion to NodeTy.\ntemplate <class OptionsT, bool IsConst>\nstruct simplify_type<ilist_iterator<OptionsT, false, IsConst>> {\n  using iterator = ilist_iterator<OptionsT, false, IsConst>;\n  using SimpleType = typename iterator::pointer;\n\n  static SimpleType getSimplifiedValue(const iterator &Node) { return &*Node; }\n};\ntemplate <class OptionsT, bool IsConst>\nstruct simplify_type<const ilist_iterator<OptionsT, false, IsConst>>\n    : simplify_type<ilist_iterator<OptionsT, false, IsConst>> {};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_ILIST_ITERATOR_H\n"}, "25": {"id": 25, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "content": "//===- iterator.h - Utilities for using and defining iterators --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_ITERATOR_H\n#define LLVM_ADT_ITERATOR_H\n\n#include \"llvm/ADT/iterator_range.h\"\n#include <algorithm>\n#include <cstddef>\n#include <iterator>\n#include <type_traits>\n#include <utility>\n\nnamespace llvm {\n\n/// CRTP base class which implements the entire standard iterator facade\n/// in terms of a minimal subset of the interface.\n///\n/// Use this when it is reasonable to implement most of the iterator\n/// functionality in terms of a core subset. If you need special behavior or\n/// there are performance implications for this, you may want to override the\n/// relevant members instead.\n///\n/// Note, one abstraction that this does *not* provide is implementing\n/// subtraction in terms of addition by negating the difference. Negation isn't\n/// always information preserving, and I can see very reasonable iterator\n/// designs where this doesn't work well. It doesn't really force much added\n/// boilerplate anyways.\n///\n/// Another abstraction that this doesn't provide is implementing increment in\n/// terms of addition of one. These aren't equivalent for all iterator\n/// categories, and respecting that adds a lot of complexity for little gain.\n///\n/// Classes wishing to use `iterator_facade_base` should implement the following\n/// methods:\n///\n/// Forward Iterators:\n///   (All of the following methods)\n///   - DerivedT &operator=(const DerivedT &R);\n///   - bool operator==(const DerivedT &R) const;\n///   - const T &operator*() const;\n///   - T &operator*();\n///   - DerivedT &operator++();\n///\n/// Bidirectional Iterators:\n///   (All methods of forward iterators, plus the following)\n///   - DerivedT &operator--();\n///\n/// Random-access Iterators:\n///   (All methods of bidirectional iterators excluding the following)\n///   - DerivedT &operator++();\n///   - DerivedT &operator--();\n///   (and plus the following)\n///   - bool operator<(const DerivedT &RHS) const;\n///   - DifferenceTypeT operator-(const DerivedT &R) const;\n///   - DerivedT &operator+=(DifferenceTypeT N);\n///   - DerivedT &operator-=(DifferenceTypeT N);\n///\ntemplate <typename DerivedT, typename IteratorCategoryT, typename T,\n          typename DifferenceTypeT = std::ptrdiff_t, typename PointerT = T *,\n          typename ReferenceT = T &>\nclass iterator_facade_base\n    : public std::iterator<IteratorCategoryT, T, DifferenceTypeT, PointerT,\n                           ReferenceT> {\nprotected:\n  enum {\n    IsRandomAccess = std::is_base_of<std::random_access_iterator_tag,\n                                     IteratorCategoryT>::value,\n    IsBidirectional = std::is_base_of<std::bidirectional_iterator_tag,\n                                      IteratorCategoryT>::value,\n  };\n\n  /// A proxy object for computing a reference via indirecting a copy of an\n  /// iterator. This is used in APIs which need to produce a reference via\n  /// indirection but for which the iterator object might be a temporary. The\n  /// proxy preserves the iterator internally and exposes the indirected\n  /// reference via a conversion operator.\n  class ReferenceProxy {\n    friend iterator_facade_base;\n\n    DerivedT I;\n\n    ReferenceProxy(DerivedT I) : I(std::move(I)) {}\n\n  public:\n    operator ReferenceT() const { return *I; }\n  };\n\npublic:\n  DerivedT operator+(DifferenceTypeT n) const {\n    static_assert(std::is_base_of<iterator_facade_base, DerivedT>::value,\n                  \"Must pass the derived type to this template!\");\n    static_assert(\n        IsRandomAccess,\n        \"The '+' operator is only defined for random access iterators.\");\n    DerivedT tmp = *static_cast<const DerivedT *>(this);\n    tmp += n;\n    return tmp;\n  }\n  friend DerivedT operator+(DifferenceTypeT n, const DerivedT &i) {\n    static_assert(\n        IsRandomAccess,\n        \"The '+' operator is only defined for random access iterators.\");\n    return i + n;\n  }\n  DerivedT operator-(DifferenceTypeT n) const {\n    static_assert(\n        IsRandomAccess,\n        \"The '-' operator is only defined for random access iterators.\");\n    DerivedT tmp = *static_cast<const DerivedT *>(this);\n    tmp -= n;\n    return tmp;\n  }\n\n  DerivedT &operator++() {\n    static_assert(std::is_base_of<iterator_facade_base, DerivedT>::value,\n                  \"Must pass the derived type to this template!\");\n    return static_cast<DerivedT *>(this)->operator+=(1);\n  }\n  DerivedT operator++(int) {\n    DerivedT tmp = *static_cast<DerivedT *>(this);\n    ++*static_cast<DerivedT *>(this);\n    return tmp;\n  }\n  DerivedT &operator--() {\n    static_assert(\n        IsBidirectional,\n        \"The decrement operator is only defined for bidirectional iterators.\");\n    return static_cast<DerivedT *>(this)->operator-=(1);\n  }\n  DerivedT operator--(int) {\n    static_assert(\n        IsBidirectional,\n        \"The decrement operator is only defined for bidirectional iterators.\");\n    DerivedT tmp = *static_cast<DerivedT *>(this);\n    --*static_cast<DerivedT *>(this);\n    return tmp;\n  }\n\n#ifndef __cpp_impl_three_way_comparison\n  bool operator!=(const DerivedT &RHS) const {\n    return !(static_cast<const DerivedT &>(*this) == RHS);\n  }\n#endif\n\n  bool operator>(const DerivedT &RHS) const {\n    static_assert(\n        IsRandomAccess,\n        \"Relational operators are only defined for random access iterators.\");\n    return !(static_cast<const DerivedT &>(*this) < RHS) &&\n           !(static_cast<const DerivedT &>(*this) == RHS);\n  }\n  bool operator<=(const DerivedT &RHS) const {\n    static_assert(\n        IsRandomAccess,\n        \"Relational operators are only defined for random access iterators.\");\n    return !(static_cast<const DerivedT &>(*this) > RHS);\n  }\n  bool operator>=(const DerivedT &RHS) const {\n    static_assert(\n        IsRandomAccess,\n        \"Relational operators are only defined for random access iterators.\");\n    return !(static_cast<const DerivedT &>(*this) < RHS);\n  }\n\n  PointerT operator->() { return &static_cast<DerivedT *>(this)->operator*(); }\n  PointerT operator->() const {\n    return &static_cast<const DerivedT *>(this)->operator*();\n  }\n  ReferenceProxy operator[](DifferenceTypeT n) {\n    static_assert(IsRandomAccess,\n                  \"Subscripting is only defined for random access iterators.\");\n    return ReferenceProxy(static_cast<DerivedT *>(this)->operator+(n));\n  }\n  ReferenceProxy operator[](DifferenceTypeT n) const {\n    static_assert(IsRandomAccess,\n                  \"Subscripting is only defined for random access iterators.\");\n    return ReferenceProxy(static_cast<const DerivedT *>(this)->operator+(n));\n  }\n};\n\n/// CRTP base class for adapting an iterator to a different type.\n///\n/// This class can be used through CRTP to adapt one iterator into another.\n/// Typically this is done through providing in the derived class a custom \\c\n/// operator* implementation. Other methods can be overridden as well.\ntemplate <\n    typename DerivedT, typename WrappedIteratorT,\n    typename IteratorCategoryT =\n        typename std::iterator_traits<WrappedIteratorT>::iterator_category,\n    typename T = typename std::iterator_traits<WrappedIteratorT>::value_type,\n    typename DifferenceTypeT =\n        typename std::iterator_traits<WrappedIteratorT>::difference_type,\n    typename PointerT = std::conditional_t<\n        std::is_same<T, typename std::iterator_traits<\n                            WrappedIteratorT>::value_type>::value,\n        typename std::iterator_traits<WrappedIteratorT>::pointer, T *>,\n    typename ReferenceT = std::conditional_t<\n        std::is_same<T, typename std::iterator_traits<\n                            WrappedIteratorT>::value_type>::value,\n        typename std::iterator_traits<WrappedIteratorT>::reference, T &>>\nclass iterator_adaptor_base\n    : public iterator_facade_base<DerivedT, IteratorCategoryT, T,\n                                  DifferenceTypeT, PointerT, ReferenceT> {\n  using BaseT = typename iterator_adaptor_base::iterator_facade_base;\n\nprotected:\n  WrappedIteratorT I;\n\n  iterator_adaptor_base() = default;\n\n  explicit iterator_adaptor_base(WrappedIteratorT u) : I(std::move(u)) {\n    static_assert(std::is_base_of<iterator_adaptor_base, DerivedT>::value,\n                  \"Must pass the derived type to this template!\");\n  }\n\n  const WrappedIteratorT &wrapped() const { return I; }\n\npublic:\n  using difference_type = DifferenceTypeT;\n\n  DerivedT &operator+=(difference_type n) {\n    static_assert(\n        BaseT::IsRandomAccess,\n        \"The '+=' operator is only defined for random access iterators.\");\n    I += n;\n    return *static_cast<DerivedT *>(this);\n  }\n  DerivedT &operator-=(difference_type n) {\n    static_assert(\n        BaseT::IsRandomAccess,\n        \"The '-=' operator is only defined for random access iterators.\");\n    I -= n;\n    return *static_cast<DerivedT *>(this);\n  }\n  using BaseT::operator-;\n  difference_type operator-(const DerivedT &RHS) const {\n    static_assert(\n        BaseT::IsRandomAccess,\n        \"The '-' operator is only defined for random access iterators.\");\n    return I - RHS.I;\n  }\n\n  // We have to explicitly provide ++ and -- rather than letting the facade\n  // forward to += because WrappedIteratorT might not support +=.\n  using BaseT::operator++;\n  DerivedT &operator++() {\n    ++I;\n    return *static_cast<DerivedT *>(this);\n  }\n  using BaseT::operator--;\n  DerivedT &operator--() {\n    static_assert(\n        BaseT::IsBidirectional,\n        \"The decrement operator is only defined for bidirectional iterators.\");\n    --I;\n    return *static_cast<DerivedT *>(this);\n  }\n\n  friend bool operator==(const iterator_adaptor_base &LHS,\n                         const iterator_adaptor_base &RHS) {\n    return LHS.I == RHS.I;\n  }\n  friend bool operator<(const iterator_adaptor_base &LHS,\n                        const iterator_adaptor_base &RHS) {\n    static_assert(\n        BaseT::IsRandomAccess,\n        \"Relational operators are only defined for random access iterators.\");\n    return LHS.I < RHS.I;\n  }\n\n  ReferenceT operator*() const { return *I; }\n};\n\n/// An iterator type that allows iterating over the pointees via some\n/// other iterator.\n///\n/// The typical usage of this is to expose a type that iterates over Ts, but\n/// which is implemented with some iterator over T*s:\n///\n/// \\code\n///   using iterator = pointee_iterator<SmallVectorImpl<T *>::iterator>;\n/// \\endcode\ntemplate <typename WrappedIteratorT,\n          typename T = std::remove_reference_t<decltype(\n              **std::declval<WrappedIteratorT>())>>\nstruct pointee_iterator\n    : iterator_adaptor_base<\n          pointee_iterator<WrappedIteratorT, T>, WrappedIteratorT,\n          typename std::iterator_traits<WrappedIteratorT>::iterator_category,\n          T> {\n  pointee_iterator() = default;\n  template <typename U>\n  pointee_iterator(U &&u)\n      : pointee_iterator::iterator_adaptor_base(std::forward<U &&>(u)) {}\n\n  T &operator*() const { return **this->I; }\n};\n\ntemplate <typename RangeT, typename WrappedIteratorT =\n                               decltype(std::begin(std::declval<RangeT>()))>\niterator_range<pointee_iterator<WrappedIteratorT>>\nmake_pointee_range(RangeT &&Range) {\n  using PointeeIteratorT = pointee_iterator<WrappedIteratorT>;\n  return make_range(PointeeIteratorT(std::begin(std::forward<RangeT>(Range))),\n                    PointeeIteratorT(std::end(std::forward<RangeT>(Range))));\n}\n\ntemplate <typename WrappedIteratorT,\n          typename T = decltype(&*std::declval<WrappedIteratorT>())>\nclass pointer_iterator\n    : public iterator_adaptor_base<\n          pointer_iterator<WrappedIteratorT, T>, WrappedIteratorT,\n          typename std::iterator_traits<WrappedIteratorT>::iterator_category,\n          T> {\n  mutable T Ptr;\n\npublic:\n  pointer_iterator() = default;\n\n  explicit pointer_iterator(WrappedIteratorT u)\n      : pointer_iterator::iterator_adaptor_base(std::move(u)) {}\n\n  T &operator*() { return Ptr = &*this->I; }\n  const T &operator*() const { return Ptr = &*this->I; }\n};\n\ntemplate <typename RangeT, typename WrappedIteratorT =\n                               decltype(std::begin(std::declval<RangeT>()))>\niterator_range<pointer_iterator<WrappedIteratorT>>\nmake_pointer_range(RangeT &&Range) {\n  using PointerIteratorT = pointer_iterator<WrappedIteratorT>;\n  return make_range(PointerIteratorT(std::begin(std::forward<RangeT>(Range))),\n                    PointerIteratorT(std::end(std::forward<RangeT>(Range))));\n}\n\ntemplate <typename WrappedIteratorT,\n          typename T1 = std::remove_reference_t<decltype(\n              **std::declval<WrappedIteratorT>())>,\n          typename T2 = std::add_pointer_t<T1>>\nusing raw_pointer_iterator =\n    pointer_iterator<pointee_iterator<WrappedIteratorT, T1>, T2>;\n\n// Wrapper iterator over iterator ItType, adding DataRef to the type of ItType,\n// to create NodeRef = std::pair<InnerTypeOfItType, DataRef>.\ntemplate <typename ItType, typename NodeRef, typename DataRef>\nclass WrappedPairNodeDataIterator\n    : public iterator_adaptor_base<\n          WrappedPairNodeDataIterator<ItType, NodeRef, DataRef>, ItType,\n          typename std::iterator_traits<ItType>::iterator_category, NodeRef,\n          std::ptrdiff_t, NodeRef *, NodeRef &> {\n  using BaseT = iterator_adaptor_base<\n      WrappedPairNodeDataIterator, ItType,\n      typename std::iterator_traits<ItType>::iterator_category, NodeRef,\n      std::ptrdiff_t, NodeRef *, NodeRef &>;\n\n  const DataRef DR;\n  mutable NodeRef NR;\n\npublic:\n  WrappedPairNodeDataIterator(ItType Begin, const DataRef DR)\n      : BaseT(Begin), DR(DR) {\n    NR.first = DR;\n  }\n\n  NodeRef &operator*() const {\n    NR.second = *this->I;\n    return NR;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_ITERATOR_H\n"}, "26": {"id": 26, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h", "content": "//===- Wasm.h - Wasm object file format -------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines manifest constants for the wasm object file format.\n// See: https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_BINARYFORMAT_WASM_H\n#define LLVM_BINARYFORMAT_WASM_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n\nnamespace llvm {\nnamespace wasm {\n\n// Object file magic string.\nconst char WasmMagic[] = {'\\0', 'a', 's', 'm'};\n// Wasm binary format version\nconst uint32_t WasmVersion = 0x1;\n// Wasm linking metadata version\nconst uint32_t WasmMetadataVersion = 0x2;\n// Wasm uses a 64k page size\nconst uint32_t WasmPageSize = 65536;\n\nstruct WasmObjectHeader {\n  StringRef Magic;\n  uint32_t Version;\n};\n\nstruct WasmDylinkInfo {\n  uint32_t MemorySize; // Memory size in bytes\n  uint32_t MemoryAlignment;  // P2 alignment of memory\n  uint32_t TableSize;  // Table size in elements\n  uint32_t TableAlignment;  // P2 alignment of table\n  std::vector<StringRef> Needed; // Shared library dependencies\n};\n\nstruct WasmProducerInfo {\n  std::vector<std::pair<std::string, std::string>> Languages;\n  std::vector<std::pair<std::string, std::string>> Tools;\n  std::vector<std::pair<std::string, std::string>> SDKs;\n};\n\nstruct WasmFeatureEntry {\n  uint8_t Prefix;\n  std::string Name;\n};\n\nstruct WasmExport {\n  StringRef Name;\n  uint8_t Kind;\n  uint32_t Index;\n};\n\nstruct WasmLimits {\n  uint8_t Flags;\n  uint64_t Initial;\n  uint64_t Maximum;\n};\n\nstruct WasmTableType {\n  uint8_t ElemType;\n  WasmLimits Limits;\n};\n\nstruct WasmTable {\n  uint32_t Index;\n  WasmTableType Type;\n  StringRef SymbolName; // from the \"linking\" section\n};\n\nstruct WasmInitExpr {\n  uint8_t Opcode;\n  union {\n    int32_t Int32;\n    int64_t Int64;\n    uint32_t Float32;\n    uint64_t Float64;\n    uint32_t Global;\n  } Value;\n};\n\nstruct WasmGlobalType {\n  uint8_t Type;\n  bool Mutable;\n};\n\nstruct WasmGlobal {\n  uint32_t Index;\n  WasmGlobalType Type;\n  WasmInitExpr InitExpr;\n  StringRef SymbolName; // from the \"linking\" section\n};\n\nstruct WasmEventType {\n  // Kind of event. Currently only WASM_EVENT_ATTRIBUTE_EXCEPTION is possible.\n  uint32_t Attribute;\n  uint32_t SigIndex;\n};\n\nstruct WasmEvent {\n  uint32_t Index;\n  WasmEventType Type;\n  StringRef SymbolName; // from the \"linking\" section\n};\n\nstruct WasmImport {\n  StringRef Module;\n  StringRef Field;\n  uint8_t Kind;\n  union {\n    uint32_t SigIndex;\n    WasmGlobalType Global;\n    WasmTableType Table;\n    WasmLimits Memory;\n    WasmEventType Event;\n  };\n};\n\nstruct WasmLocalDecl {\n  uint8_t Type;\n  uint32_t Count;\n};\n\nstruct WasmFunction {\n  uint32_t Index;\n  std::vector<WasmLocalDecl> Locals;\n  ArrayRef<uint8_t> Body;\n  uint32_t CodeSectionOffset;\n  uint32_t Size;\n  uint32_t CodeOffset;  // start of Locals and Body\n  Optional<StringRef> ExportName; // from the \"export\" section\n  StringRef SymbolName; // from the \"linking\" section\n  StringRef DebugName;  // from the \"name\" section\n  uint32_t Comdat;      // from the \"comdat info\" section\n};\n\nstruct WasmDataSegment {\n  uint32_t InitFlags;\n  // Present if InitFlags & WASM_DATA_SEGMENT_HAS_MEMINDEX.\n  uint32_t MemoryIndex;\n  // Present if InitFlags & WASM_DATA_SEGMENT_IS_PASSIVE == 0.\n  WasmInitExpr Offset;\n\n  ArrayRef<uint8_t> Content;\n  StringRef Name; // from the \"segment info\" section\n  uint32_t Alignment;\n  uint32_t LinkerFlags;\n  uint32_t Comdat; // from the \"comdat info\" section\n};\n\nstruct WasmElemSegment {\n  uint32_t Flags;\n  uint32_t TableNumber;\n  uint8_t ElemKind;\n  WasmInitExpr Offset;\n  std::vector<uint32_t> Functions;\n};\n\n// Represents the location of a Wasm data symbol within a WasmDataSegment, as\n// the index of the segment, and the offset and size within the segment.\nstruct WasmDataReference {\n  uint32_t Segment;\n  uint64_t Offset;\n  uint64_t Size;\n};\n\nstruct WasmRelocation {\n  uint8_t Type;    // The type of the relocation.\n  uint32_t Index;  // Index into either symbol or type index space.\n  uint64_t Offset; // Offset from the start of the section.\n  int64_t Addend;  // A value to add to the symbol.\n};\n\nstruct WasmInitFunc {\n  uint32_t Priority;\n  uint32_t Symbol;\n};\n\nstruct WasmSymbolInfo {\n  StringRef Name;\n  uint8_t Kind;\n  uint32_t Flags;\n  // For undefined symbols the module of the import\n  Optional<StringRef> ImportModule;\n  // For undefined symbols the name of the import\n  Optional<StringRef> ImportName;\n  // For symbols to be exported from the final module\n  Optional<StringRef> ExportName;\n  union {\n    // For function, table, or global symbols, the index in function, table, or\n    // global index space.\n    uint32_t ElementIndex;\n    // For a data symbols, the address of the data relative to segment.\n    WasmDataReference DataRef;\n  };\n};\n\nenum class NameType {\n  FUNCTION,\n  GLOBAL,\n  DATA_SEGMENT,\n};\n\nstruct WasmDebugName {\n  NameType Type;\n  uint32_t Index;\n  StringRef Name;\n};\n\nstruct WasmLinkingData {\n  uint32_t Version;\n  std::vector<WasmInitFunc> InitFunctions;\n  std::vector<StringRef> Comdats;\n  std::vector<WasmSymbolInfo> SymbolTable;\n};\n\nenum : unsigned {\n  WASM_SEC_CUSTOM = 0,     // Custom / User-defined section\n  WASM_SEC_TYPE = 1,       // Function signature declarations\n  WASM_SEC_IMPORT = 2,     // Import declarations\n  WASM_SEC_FUNCTION = 3,   // Function declarations\n  WASM_SEC_TABLE = 4,      // Indirect function table and other tables\n  WASM_SEC_MEMORY = 5,     // Memory attributes\n  WASM_SEC_GLOBAL = 6,     // Global declarations\n  WASM_SEC_EXPORT = 7,     // Exports\n  WASM_SEC_START = 8,      // Start function declaration\n  WASM_SEC_ELEM = 9,       // Elements section\n  WASM_SEC_CODE = 10,      // Function bodies (code)\n  WASM_SEC_DATA = 11,      // Data segments\n  WASM_SEC_DATACOUNT = 12, // Data segment count\n  WASM_SEC_EVENT = 13      // Event declarations\n};\n\n// Type immediate encodings used in various contexts.\nenum : unsigned {\n  WASM_TYPE_I32 = 0x7F,\n  WASM_TYPE_I64 = 0x7E,\n  WASM_TYPE_F32 = 0x7D,\n  WASM_TYPE_F64 = 0x7C,\n  WASM_TYPE_V128 = 0x7B,\n  WASM_TYPE_FUNCREF = 0x70,\n  WASM_TYPE_EXTERNREF = 0x6F,\n  WASM_TYPE_FUNC = 0x60,\n  WASM_TYPE_NORESULT = 0x40, // for blocks with no result values\n};\n\n// Kinds of externals (for imports and exports).\nenum : unsigned {\n  WASM_EXTERNAL_FUNCTION = 0x0,\n  WASM_EXTERNAL_TABLE = 0x1,\n  WASM_EXTERNAL_MEMORY = 0x2,\n  WASM_EXTERNAL_GLOBAL = 0x3,\n  WASM_EXTERNAL_EVENT = 0x4,\n};\n\n// Opcodes used in initializer expressions.\nenum : unsigned {\n  WASM_OPCODE_END = 0x0b,\n  WASM_OPCODE_CALL = 0x10,\n  WASM_OPCODE_LOCAL_GET = 0x20,\n  WASM_OPCODE_LOCAL_SET = 0x21,\n  WASM_OPCODE_GLOBAL_GET = 0x23,\n  WASM_OPCODE_GLOBAL_SET = 0x24,\n  WASM_OPCODE_I32_STORE = 0x36,\n  WASM_OPCODE_I64_STORE = 0x37,\n  WASM_OPCODE_I32_CONST = 0x41,\n  WASM_OPCODE_I64_CONST = 0x42,\n  WASM_OPCODE_F32_CONST = 0x43,\n  WASM_OPCODE_F64_CONST = 0x44,\n  WASM_OPCODE_I32_ADD = 0x6a,\n  WASM_OPCODE_I64_ADD = 0x7c,\n  WASM_OPCODE_REF_NULL = 0xd0,\n};\n\n// Opcodes used in synthetic functions.\nenum : unsigned {\n  WASM_OPCODE_IF = 0x04,\n  WASM_OPCODE_ELSE = 0x05,\n  WASM_OPCODE_DROP = 0x1a,\n  WASM_OPCODE_MISC_PREFIX = 0xfc,\n  WASM_OPCODE_MEMORY_INIT = 0x08,\n  WASM_OPCODE_DATA_DROP = 0x09,\n  WASM_OPCODE_ATOMICS_PREFIX = 0xfe,\n  WASM_OPCODE_ATOMIC_NOTIFY = 0x00,\n  WASM_OPCODE_I32_ATOMIC_WAIT = 0x01,\n  WASM_OPCODE_I32_ATOMIC_STORE = 0x17,\n  WASM_OPCODE_I32_RMW_CMPXCHG = 0x48,\n};\n\nenum : unsigned {\n  WASM_LIMITS_FLAG_NONE = 0x0,\n  WASM_LIMITS_FLAG_HAS_MAX = 0x1,\n  WASM_LIMITS_FLAG_IS_SHARED = 0x2,\n  WASM_LIMITS_FLAG_IS_64 = 0x4,\n};\n\nenum : unsigned {\n  WASM_DATA_SEGMENT_IS_PASSIVE = 0x01,\n  WASM_DATA_SEGMENT_HAS_MEMINDEX = 0x02,\n};\n\nenum : unsigned {\n  WASM_ELEM_SEGMENT_IS_PASSIVE = 0x01,\n  WASM_ELEM_SEGMENT_HAS_TABLE_NUMBER = 0x02,\n  WASM_ELEM_SEGMENT_HAS_INIT_EXPRS = 0x04,\n};\nconst unsigned WASM_ELEM_SEGMENT_MASK_HAS_ELEM_KIND = 0x3;\n\n// Feature policy prefixes used in the custom \"target_features\" section\nenum : uint8_t {\n  WASM_FEATURE_PREFIX_USED = '+',\n  WASM_FEATURE_PREFIX_REQUIRED = '=',\n  WASM_FEATURE_PREFIX_DISALLOWED = '-',\n};\n\n// Kind codes used in the custom \"name\" section\nenum : unsigned {\n  WASM_NAMES_FUNCTION = 1,\n  WASM_NAMES_LOCAL = 2,\n  WASM_NAMES_GLOBAL = 7,\n  WASM_NAMES_DATA_SEGMENT = 9,\n};\n\n// Kind codes used in the custom \"linking\" section\nenum : unsigned {\n  WASM_SEGMENT_INFO = 0x5,\n  WASM_INIT_FUNCS = 0x6,\n  WASM_COMDAT_INFO = 0x7,\n  WASM_SYMBOL_TABLE = 0x8,\n};\n\n// Kind codes used in the custom \"linking\" section in the WASM_COMDAT_INFO\nenum : unsigned {\n  WASM_COMDAT_DATA = 0x0,\n  WASM_COMDAT_FUNCTION = 0x1,\n  // GLOBAL, EVENT, and TABLE are in here but LLVM doesn't use them yet.\n  WASM_COMDAT_SECTION = 0x5,\n};\n\n// Kind codes used in the custom \"linking\" section in the WASM_SYMBOL_TABLE\nenum WasmSymbolType : unsigned {\n  WASM_SYMBOL_TYPE_FUNCTION = 0x0,\n  WASM_SYMBOL_TYPE_DATA = 0x1,\n  WASM_SYMBOL_TYPE_GLOBAL = 0x2,\n  WASM_SYMBOL_TYPE_SECTION = 0x3,\n  WASM_SYMBOL_TYPE_EVENT = 0x4,\n  WASM_SYMBOL_TYPE_TABLE = 0x5,\n};\n\n// Kinds of event attributes.\nenum WasmEventAttribute : unsigned {\n  WASM_EVENT_ATTRIBUTE_EXCEPTION = 0x0,\n};\n\nconst unsigned WASM_SYMBOL_BINDING_MASK = 0x3;\nconst unsigned WASM_SYMBOL_VISIBILITY_MASK = 0xc;\n\nconst unsigned WASM_SYMBOL_BINDING_GLOBAL = 0x0;\nconst unsigned WASM_SYMBOL_BINDING_WEAK = 0x1;\nconst unsigned WASM_SYMBOL_BINDING_LOCAL = 0x2;\nconst unsigned WASM_SYMBOL_VISIBILITY_DEFAULT = 0x0;\nconst unsigned WASM_SYMBOL_VISIBILITY_HIDDEN = 0x4;\nconst unsigned WASM_SYMBOL_UNDEFINED = 0x10;\nconst unsigned WASM_SYMBOL_EXPORTED = 0x20;\nconst unsigned WASM_SYMBOL_EXPLICIT_NAME = 0x40;\nconst unsigned WASM_SYMBOL_NO_STRIP = 0x80;\n\n#define WASM_RELOC(name, value) name = value,\n\nenum : unsigned {\n#include \"WasmRelocs.def\"\n};\n\n#undef WASM_RELOC\n\n// Subset of types that a value can have\nenum class ValType {\n  I32 = WASM_TYPE_I32,\n  I64 = WASM_TYPE_I64,\n  F32 = WASM_TYPE_F32,\n  F64 = WASM_TYPE_F64,\n  V128 = WASM_TYPE_V128,\n  FUNCREF = WASM_TYPE_FUNCREF,\n  EXTERNREF = WASM_TYPE_EXTERNREF,\n};\n\nstruct WasmSignature {\n  SmallVector<ValType, 1> Returns;\n  SmallVector<ValType, 4> Params;\n  // Support empty and tombstone instances, needed by DenseMap.\n  enum { Plain, Empty, Tombstone } State = Plain;\n\n  WasmSignature(SmallVector<ValType, 1> &&InReturns,\n                SmallVector<ValType, 4> &&InParams)\n      : Returns(InReturns), Params(InParams) {}\n  WasmSignature() = default;\n};\n\n// Useful comparison operators\ninline bool operator==(const WasmSignature &LHS, const WasmSignature &RHS) {\n  return LHS.State == RHS.State && LHS.Returns == RHS.Returns &&\n         LHS.Params == RHS.Params;\n}\n\ninline bool operator!=(const WasmSignature &LHS, const WasmSignature &RHS) {\n  return !(LHS == RHS);\n}\n\ninline bool operator==(const WasmGlobalType &LHS, const WasmGlobalType &RHS) {\n  return LHS.Type == RHS.Type && LHS.Mutable == RHS.Mutable;\n}\n\ninline bool operator!=(const WasmGlobalType &LHS, const WasmGlobalType &RHS) {\n  return !(LHS == RHS);\n}\n\nstd::string toString(WasmSymbolType type);\nstd::string relocTypetoString(uint32_t type);\nbool relocTypeHasAddend(uint32_t type);\n\n} // end namespace wasm\n} // end namespace llvm\n\n#endif\n"}, "27": {"id": 27, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h", "content": "//==- include/llvm/CodeGen/AccelTable.h - Accelerator Tables -----*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains support for writing accelerator tables.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_ACCELTABLE_H\n#define LLVM_CODEGEN_ACCELTABLE_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/CodeGen/DIE.h\"\n#include \"llvm/CodeGen/DwarfStringPoolEntry.h\"\n#include \"llvm/MC/MCSymbol.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/DJB.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/Format.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cstddef>\n#include <cstdint>\n#include <vector>\n\n/// The DWARF and Apple accelerator tables are an indirect hash table optimized\n/// for null lookup rather than access to known data. The Apple accelerator\n/// tables are a precursor of the newer DWARF v5 accelerator tables. Both\n/// formats share common design ideas.\n///\n/// The Apple accelerator table are output into an on-disk format that looks\n/// like this:\n///\n/// .------------------.\n/// |  HEADER          |\n/// |------------------|\n/// |  BUCKETS         |\n/// |------------------|\n/// |  HASHES          |\n/// |------------------|\n/// |  OFFSETS         |\n/// |------------------|\n/// |  DATA            |\n/// `------------------'\n///\n/// The header contains a magic number, version, type of hash function,\n/// the number of buckets, total number of hashes, and room for a special struct\n/// of data and the length of that struct.\n///\n/// The buckets contain an index (e.g. 6) into the hashes array. The hashes\n/// section contains all of the 32-bit hash values in contiguous memory, and the\n/// offsets contain the offset into the data area for the particular hash.\n///\n/// For a lookup example, we could hash a function name and take it modulo the\n/// number of buckets giving us our bucket. From there we take the bucket value\n/// as an index into the hashes table and look at each successive hash as long\n/// as the hash value is still the same modulo result (bucket value) as earlier.\n/// If we have a match we look at that same entry in the offsets table and grab\n/// the offset in the data for our final match.\n///\n/// The DWARF v5 accelerator table consists of zero or more name indices that\n/// are output into an on-disk format that looks like this:\n///\n/// .------------------.\n/// |  HEADER          |\n/// |------------------|\n/// |  CU LIST         |\n/// |------------------|\n/// |  LOCAL TU LIST   |\n/// |------------------|\n/// |  FOREIGN TU LIST |\n/// |------------------|\n/// |  HASH TABLE      |\n/// |------------------|\n/// |  NAME TABLE      |\n/// |------------------|\n/// |  ABBREV TABLE    |\n/// |------------------|\n/// |  ENTRY POOL      |\n/// `------------------'\n///\n/// For the full documentation please refer to the DWARF 5 standard.\n///\n///\n/// This file defines the class template AccelTable, which is represents an\n/// abstract view of an Accelerator table, without any notion of an on-disk\n/// layout. This class is parameterized by an entry type, which should derive\n/// from AccelTableData. This is the type of individual entries in the table,\n/// and it should store the data necessary to emit them. AppleAccelTableData is\n/// the base class for Apple Accelerator Table entries, which have a uniform\n/// structure based on a sequence of Atoms. There are different sub-classes\n/// derived from AppleAccelTable, which differ in the set of Atoms and how they\n/// obtain their values.\n///\n/// An Apple Accelerator Table can be serialized by calling emitAppleAccelTable\n/// function.\n\nnamespace llvm {\n\nclass AsmPrinter;\nclass DwarfCompileUnit;\nclass DwarfDebug;\n\n/// Interface which the different types of accelerator table data have to\n/// conform. It serves as a base class for different values of the template\n/// argument of the AccelTable class template.\nclass AccelTableData {\npublic:\n  virtual ~AccelTableData() = default;\n\n  bool operator<(const AccelTableData &Other) const {\n    return order() < Other.order();\n  }\n\n    // Subclasses should implement:\n    // static uint32_t hash(StringRef Name);\n\n#ifndef NDEBUG\n  virtual void print(raw_ostream &OS) const = 0;\n#endif\nprotected:\n  virtual uint64_t order() const = 0;\n};\n\n/// A base class holding non-template-dependant functionality of the AccelTable\n/// class. Clients should not use this class directly but rather instantiate\n/// AccelTable with a type derived from AccelTableData.\nclass AccelTableBase {\npublic:\n  using HashFn = uint32_t(StringRef);\n\n  /// Represents a group of entries with identical name (and hence, hash value).\n  struct HashData {\n    DwarfStringPoolEntryRef Name;\n    uint32_t HashValue;\n    std::vector<AccelTableData *> Values;\n    MCSymbol *Sym;\n\n    HashData(DwarfStringPoolEntryRef Name, HashFn *Hash)\n        : Name(Name), HashValue(Hash(Name.getString())) {}\n\n#ifndef NDEBUG\n    void print(raw_ostream &OS) const;\n    void dump() const { print(dbgs()); }\n#endif\n  };\n  using HashList = std::vector<HashData *>;\n  using BucketList = std::vector<HashList>;\n\nprotected:\n  /// Allocator for HashData and Values.\n  BumpPtrAllocator Allocator;\n\n  using StringEntries = StringMap<HashData, BumpPtrAllocator &>;\n  StringEntries Entries;\n\n  HashFn *Hash;\n  uint32_t BucketCount;\n  uint32_t UniqueHashCount;\n\n  HashList Hashes;\n  BucketList Buckets;\n\n  void computeBucketCount();\n\n  AccelTableBase(HashFn *Hash) : Entries(Allocator), Hash(Hash) {}\n\npublic:\n  void finalize(AsmPrinter *Asm, StringRef Prefix);\n  ArrayRef<HashList> getBuckets() const { return Buckets; }\n  uint32_t getBucketCount() const { return BucketCount; }\n  uint32_t getUniqueHashCount() const { return UniqueHashCount; }\n  uint32_t getUniqueNameCount() const { return Entries.size(); }\n\n#ifndef NDEBUG\n  void print(raw_ostream &OS) const;\n  void dump() const { print(dbgs()); }\n#endif\n\n  AccelTableBase(const AccelTableBase &) = delete;\n  void operator=(const AccelTableBase &) = delete;\n};\n\n/// This class holds an abstract representation of an Accelerator Table,\n/// consisting of a sequence of buckets, each bucket containint a sequence of\n/// HashData entries. The class is parameterized by the type of entries it\n/// holds. The type template parameter also defines the hash function to use for\n/// hashing names.\ntemplate <typename DataT> class AccelTable : public AccelTableBase {\npublic:\n  AccelTable() : AccelTableBase(DataT::hash) {}\n\n  template <typename... Types>\n  void addName(DwarfStringPoolEntryRef Name, Types &&... Args);\n};\n\ntemplate <typename AccelTableDataT>\ntemplate <typename... Types>\nvoid AccelTable<AccelTableDataT>::addName(DwarfStringPoolEntryRef Name,\n                                          Types &&... Args) {\n  assert(Buckets.empty() && \"Already finalized!\");\n  // If the string is in the list already then add this die to the list\n  // otherwise add a new one.\n  auto Iter = Entries.try_emplace(Name.getString(), Name, Hash).first;\n  assert(Iter->second.Name == Name);\n  Iter->second.Values.push_back(\n      new (Allocator) AccelTableDataT(std::forward<Types>(Args)...));\n}\n\n/// A base class for different implementations of Data classes for Apple\n/// Accelerator Tables. The columns in the table are defined by the static Atoms\n/// variable defined on the subclasses.\nclass AppleAccelTableData : public AccelTableData {\npublic:\n  /// An Atom defines the form of the data in an Apple accelerator table.\n  /// Conceptually it is a column in the accelerator consisting of a type and a\n  /// specification of the form of its data.\n  struct Atom {\n    /// Atom Type.\n    const uint16_t Type;\n    /// DWARF Form.\n    const uint16_t Form;\n\n    constexpr Atom(uint16_t Type, uint16_t Form) : Type(Type), Form(Form) {}\n\n#ifndef NDEBUG\n    void print(raw_ostream &OS) const;\n    void dump() const { print(dbgs()); }\n#endif\n  };\n  // Subclasses should define:\n  // static constexpr Atom Atoms[];\n\n  virtual void emit(AsmPrinter *Asm) const = 0;\n\n  static uint32_t hash(StringRef Buffer) { return djbHash(Buffer); }\n};\n\n/// The Data class implementation for DWARF v5 accelerator table. Unlike the\n/// Apple Data classes, this class is just a DIE wrapper, and does not know to\n/// serialize itself. The complete serialization logic is in the\n/// emitDWARF5AccelTable function.\nclass DWARF5AccelTableData : public AccelTableData {\npublic:\n  static uint32_t hash(StringRef Name) { return caseFoldingDjbHash(Name); }\n\n  DWARF5AccelTableData(const DIE &Die) : Die(Die) {}\n\n#ifndef NDEBUG\n  void print(raw_ostream &OS) const override;\n#endif\n\n  const DIE &getDie() const { return Die; }\n  uint64_t getDieOffset() const { return Die.getOffset(); }\n  unsigned getDieTag() const { return Die.getTag(); }\n\nprotected:\n  const DIE &Die;\n\n  uint64_t order() const override { return Die.getOffset(); }\n};\n\nclass DWARF5AccelTableStaticData : public AccelTableData {\npublic:\n  static uint32_t hash(StringRef Name) { return caseFoldingDjbHash(Name); }\n\n  DWARF5AccelTableStaticData(uint64_t DieOffset, unsigned DieTag,\n                             unsigned CUIndex)\n      : DieOffset(DieOffset), DieTag(DieTag), CUIndex(CUIndex) {}\n\n#ifndef NDEBUG\n  void print(raw_ostream &OS) const override;\n#endif\n\n  uint64_t getDieOffset() const { return DieOffset; }\n  unsigned getDieTag() const { return DieTag; }\n  unsigned getCUIndex() const { return CUIndex; }\n\nprotected:\n  uint64_t DieOffset;\n  unsigned DieTag;\n  unsigned CUIndex;\n\n  uint64_t order() const override { return DieOffset; }\n};\n\nvoid emitAppleAccelTableImpl(AsmPrinter *Asm, AccelTableBase &Contents,\n                             StringRef Prefix, const MCSymbol *SecBegin,\n                             ArrayRef<AppleAccelTableData::Atom> Atoms);\n\n/// Emit an Apple Accelerator Table consisting of entries in the specified\n/// AccelTable. The DataT template parameter should be derived from\n/// AppleAccelTableData.\ntemplate <typename DataT>\nvoid emitAppleAccelTable(AsmPrinter *Asm, AccelTable<DataT> &Contents,\n                         StringRef Prefix, const MCSymbol *SecBegin) {\n  static_assert(std::is_convertible<DataT *, AppleAccelTableData *>::value, \"\");\n  emitAppleAccelTableImpl(Asm, Contents, Prefix, SecBegin, DataT::Atoms);\n}\n\nvoid emitDWARF5AccelTable(AsmPrinter *Asm,\n                          AccelTable<DWARF5AccelTableData> &Contents,\n                          const DwarfDebug &DD,\n                          ArrayRef<std::unique_ptr<DwarfCompileUnit>> CUs);\n\nvoid emitDWARF5AccelTable(\n    AsmPrinter *Asm, AccelTable<DWARF5AccelTableStaticData> &Contents,\n    ArrayRef<MCSymbol *> CUs,\n    llvm::function_ref<unsigned(const DWARF5AccelTableStaticData &)>\n        getCUIndexForEntry);\n\n/// Accelerator table data implementation for simple Apple accelerator tables\n/// with just a DIE reference.\nclass AppleAccelTableOffsetData : public AppleAccelTableData {\npublic:\n  AppleAccelTableOffsetData(const DIE &D) : Die(D) {}\n\n  void emit(AsmPrinter *Asm) const override;\n\n  static constexpr Atom Atoms[] = {\n      Atom(dwarf::DW_ATOM_die_offset, dwarf::DW_FORM_data4)};\n\n#ifndef NDEBUG\n  void print(raw_ostream &OS) const override;\n#endif\nprotected:\n  uint64_t order() const override { return Die.getOffset(); }\n\n  const DIE &Die;\n};\n\n/// Accelerator table data implementation for Apple type accelerator tables.\nclass AppleAccelTableTypeData : public AppleAccelTableOffsetData {\npublic:\n  AppleAccelTableTypeData(const DIE &D) : AppleAccelTableOffsetData(D) {}\n\n  void emit(AsmPrinter *Asm) const override;\n\n  static constexpr Atom Atoms[] = {\n      Atom(dwarf::DW_ATOM_die_offset, dwarf::DW_FORM_data4),\n      Atom(dwarf::DW_ATOM_die_tag, dwarf::DW_FORM_data2),\n      Atom(dwarf::DW_ATOM_type_flags, dwarf::DW_FORM_data1)};\n\n#ifndef NDEBUG\n  void print(raw_ostream &OS) const override;\n#endif\n};\n\n/// Accelerator table data implementation for simple Apple accelerator tables\n/// with a DIE offset but no actual DIE pointer.\nclass AppleAccelTableStaticOffsetData : public AppleAccelTableData {\npublic:\n  AppleAccelTableStaticOffsetData(uint32_t Offset) : Offset(Offset) {}\n\n  void emit(AsmPrinter *Asm) const override;\n\n  static constexpr Atom Atoms[] = {\n      Atom(dwarf::DW_ATOM_die_offset, dwarf::DW_FORM_data4)};\n\n#ifndef NDEBUG\n  void print(raw_ostream &OS) const override;\n#endif\nprotected:\n  uint64_t order() const override { return Offset; }\n\n  uint32_t Offset;\n};\n\n/// Accelerator table data implementation for type accelerator tables with\n/// a DIE offset but no actual DIE pointer.\nclass AppleAccelTableStaticTypeData : public AppleAccelTableStaticOffsetData {\npublic:\n  AppleAccelTableStaticTypeData(uint32_t Offset, uint16_t Tag,\n                                bool ObjCClassIsImplementation,\n                                uint32_t QualifiedNameHash)\n      : AppleAccelTableStaticOffsetData(Offset),\n        QualifiedNameHash(QualifiedNameHash), Tag(Tag),\n        ObjCClassIsImplementation(ObjCClassIsImplementation) {}\n\n  void emit(AsmPrinter *Asm) const override;\n\n  static constexpr Atom Atoms[] = {\n      Atom(dwarf::DW_ATOM_die_offset, dwarf::DW_FORM_data4),\n      Atom(dwarf::DW_ATOM_die_tag, dwarf::DW_FORM_data2),\n      Atom(5, dwarf::DW_FORM_data1), Atom(6, dwarf::DW_FORM_data4)};\n\n#ifndef NDEBUG\n  void print(raw_ostream &OS) const override;\n#endif\nprotected:\n  uint64_t order() const override { return Offset; }\n\n  uint32_t QualifiedNameHash;\n  uint16_t Tag;\n  bool ObjCClassIsImplementation;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_ACCELTABLE_H\n"}, "28": {"id": 28, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "content": "//===- lib/CodeGen/DIE.h - DWARF Info Entries -------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Data structures for DWARF info entries.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_DIE_H\n#define LLVM_CODEGEN_DIE_H\n\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/CodeGen/DwarfStringPoolEntry.h\"\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <new>\n#include <type_traits>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass AsmPrinter;\nclass DIE;\nclass DIEUnit;\nclass DwarfCompileUnit;\nclass MCExpr;\nclass MCSection;\nclass MCSymbol;\nclass raw_ostream;\n\n//===--------------------------------------------------------------------===//\n/// Dwarf abbreviation data, describes one attribute of a Dwarf abbreviation.\nclass DIEAbbrevData {\n  /// Dwarf attribute code.\n  dwarf::Attribute Attribute;\n\n  /// Dwarf form code.\n  dwarf::Form Form;\n\n  /// Dwarf attribute value for DW_FORM_implicit_const\n  int64_t Value = 0;\n\npublic:\n  DIEAbbrevData(dwarf::Attribute A, dwarf::Form F)\n      : Attribute(A), Form(F) {}\n  DIEAbbrevData(dwarf::Attribute A, int64_t V)\n      : Attribute(A), Form(dwarf::DW_FORM_implicit_const), Value(V) {}\n\n  /// Accessors.\n  /// @{\n  dwarf::Attribute getAttribute() const { return Attribute; }\n  dwarf::Form getForm() const { return Form; }\n  int64_t getValue() const { return Value; }\n  /// @}\n\n  /// Used to gather unique data for the abbreviation folding set.\n  void Profile(FoldingSetNodeID &ID) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// Dwarf abbreviation, describes the organization of a debug information\n/// object.\nclass DIEAbbrev : public FoldingSetNode {\n  /// Unique number for node.\n  unsigned Number = 0;\n\n  /// Dwarf tag code.\n  dwarf::Tag Tag;\n\n  /// Whether or not this node has children.\n  ///\n  /// This cheats a bit in all of the uses since the values in the standard\n  /// are 0 and 1 for no children and children respectively.\n  bool Children;\n\n  /// Raw data bytes for abbreviation.\n  SmallVector<DIEAbbrevData, 12> Data;\n\npublic:\n  DIEAbbrev(dwarf::Tag T, bool C) : Tag(T), Children(C) {}\n\n  /// Accessors.\n  /// @{\n  dwarf::Tag getTag() const { return Tag; }\n  unsigned getNumber() const { return Number; }\n  bool hasChildren() const { return Children; }\n  const SmallVectorImpl<DIEAbbrevData> &getData() const { return Data; }\n  void setChildrenFlag(bool hasChild) { Children = hasChild; }\n  void setNumber(unsigned N) { Number = N; }\n  /// @}\n\n  /// Adds another set of attribute information to the abbreviation.\n  void AddAttribute(dwarf::Attribute Attribute, dwarf::Form Form) {\n    Data.push_back(DIEAbbrevData(Attribute, Form));\n  }\n\n  /// Adds attribute with DW_FORM_implicit_const value\n  void AddImplicitConstAttribute(dwarf::Attribute Attribute, int64_t Value) {\n    Data.push_back(DIEAbbrevData(Attribute, Value));\n  }\n\n  /// Used to gather unique data for the abbreviation folding set.\n  void Profile(FoldingSetNodeID &ID) const;\n\n  /// Print the abbreviation using the specified asm printer.\n  void Emit(const AsmPrinter *AP) const;\n\n  void print(raw_ostream &O) const;\n  void dump() const;\n};\n\n//===--------------------------------------------------------------------===//\n/// Helps unique DIEAbbrev objects and assigns abbreviation numbers.\n///\n/// This class will unique the DIE abbreviations for a llvm::DIE object and\n/// assign a unique abbreviation number to each unique DIEAbbrev object it\n/// finds. The resulting collection of DIEAbbrev objects can then be emitted\n/// into the .debug_abbrev section.\nclass DIEAbbrevSet {\n  /// The bump allocator to use when creating DIEAbbrev objects in the uniqued\n  /// storage container.\n  BumpPtrAllocator &Alloc;\n  /// FoldingSet that uniques the abbreviations.\n  FoldingSet<DIEAbbrev> AbbreviationsSet;\n  /// A list of all the unique abbreviations in use.\n  std::vector<DIEAbbrev *> Abbreviations;\n\npublic:\n  DIEAbbrevSet(BumpPtrAllocator &A) : Alloc(A) {}\n  ~DIEAbbrevSet();\n\n  /// Generate the abbreviation declaration for a DIE and return a pointer to\n  /// the generated abbreviation.\n  ///\n  /// \\param Die the debug info entry to generate the abbreviation for.\n  /// \\returns A reference to the uniqued abbreviation declaration that is\n  /// owned by this class.\n  DIEAbbrev &uniqueAbbreviation(DIE &Die);\n\n  /// Print all abbreviations using the specified asm printer.\n  void Emit(const AsmPrinter *AP, MCSection *Section) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// An integer value DIE.\n///\nclass DIEInteger {\n  uint64_t Integer;\n\npublic:\n  explicit DIEInteger(uint64_t I) : Integer(I) {}\n\n  /// Choose the best form for integer.\n  static dwarf::Form BestForm(bool IsSigned, uint64_t Int) {\n    if (IsSigned) {\n      const int64_t SignedInt = Int;\n      if ((char)Int == SignedInt)\n        return dwarf::DW_FORM_data1;\n      if ((short)Int == SignedInt)\n        return dwarf::DW_FORM_data2;\n      if ((int)Int == SignedInt)\n        return dwarf::DW_FORM_data4;\n    } else {\n      if ((unsigned char)Int == Int)\n        return dwarf::DW_FORM_data1;\n      if ((unsigned short)Int == Int)\n        return dwarf::DW_FORM_data2;\n      if ((unsigned int)Int == Int)\n        return dwarf::DW_FORM_data4;\n    }\n    return dwarf::DW_FORM_data8;\n  }\n\n  uint64_t getValue() const { return Integer; }\n  void setValue(uint64_t Val) { Integer = Val; }\n\n  void emitValue(const AsmPrinter *Asm, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// An expression DIE.\nclass DIEExpr {\n  const MCExpr *Expr;\n\npublic:\n  explicit DIEExpr(const MCExpr *E) : Expr(E) {}\n\n  /// Get MCExpr.\n  const MCExpr *getValue() const { return Expr; }\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// A label DIE.\nclass DIELabel {\n  const MCSymbol *Label;\n\npublic:\n  explicit DIELabel(const MCSymbol *L) : Label(L) {}\n\n  /// Get MCSymbol.\n  const MCSymbol *getValue() const { return Label; }\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// A BaseTypeRef DIE.\nclass DIEBaseTypeRef {\n  const DwarfCompileUnit *CU;\n  const uint64_t Index;\n  static constexpr unsigned ULEB128PadSize = 4;\n\npublic:\n  explicit DIEBaseTypeRef(const DwarfCompileUnit *TheCU, uint64_t Idx)\n    : CU(TheCU), Index(Idx) {}\n\n  /// EmitValue - Emit base type reference.\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  /// SizeOf - Determine size of the base type reference in bytes.\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n  uint64_t getIndex() const { return Index; }\n};\n\n//===--------------------------------------------------------------------===//\n/// A simple label difference DIE.\n///\nclass DIEDelta {\n  const MCSymbol *LabelHi;\n  const MCSymbol *LabelLo;\n\npublic:\n  DIEDelta(const MCSymbol *Hi, const MCSymbol *Lo) : LabelHi(Hi), LabelLo(Lo) {}\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// A container for string pool string values.\n///\n/// This class is used with the DW_FORM_strp and DW_FORM_GNU_str_index forms.\nclass DIEString {\n  DwarfStringPoolEntryRef S;\n\npublic:\n  DIEString(DwarfStringPoolEntryRef S) : S(S) {}\n\n  /// Grab the string out of the object.\n  StringRef getString() const { return S.getString(); }\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// A container for inline string values.\n///\n/// This class is used with the DW_FORM_string form.\nclass DIEInlineString {\n  StringRef S;\n\npublic:\n  template <typename Allocator>\n  explicit DIEInlineString(StringRef Str, Allocator &A) : S(Str.copy(A)) {}\n\n  ~DIEInlineString() = default;\n\n  /// Grab the string out of the object.\n  StringRef getString() const { return S; }\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// A pointer to another debug information entry.  An instance of this class can\n/// also be used as a proxy for a debug information entry not yet defined\n/// (ie. types.)\nclass DIEEntry {\n  DIE *Entry;\n\npublic:\n  DIEEntry() = delete;\n  explicit DIEEntry(DIE &E) : Entry(&E) {}\n\n  DIE &getEntry() const { return *Entry; }\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// Represents a pointer to a location list in the debug_loc\n/// section.\nclass DIELocList {\n  /// Index into the .debug_loc vector.\n  size_t Index;\n\npublic:\n  DIELocList(size_t I) : Index(I) {}\n\n  /// Grab the current index out.\n  size_t getValue() const { return Index; }\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// A BaseTypeRef DIE.\nclass DIEAddrOffset {\n  DIEInteger Addr;\n  DIEDelta Offset;\n\npublic:\n  explicit DIEAddrOffset(uint64_t Idx, const MCSymbol *Hi, const MCSymbol *Lo)\n      : Addr(Idx), Offset(Hi, Lo) {}\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// A debug information entry value. Some of these roughly correlate\n/// to DWARF attribute classes.\nclass DIEBlock;\nclass DIELoc;\nclass DIEValue {\npublic:\n  enum Type {\n    isNone,\n#define HANDLE_DIEVALUE(T) is##T,\n#include \"llvm/CodeGen/DIEValue.def\"\n  };\n\nprivate:\n  /// Type of data stored in the value.\n  Type Ty = isNone;\n  dwarf::Attribute Attribute = (dwarf::Attribute)0;\n  dwarf::Form Form = (dwarf::Form)0;\n\n  /// Storage for the value.\n  ///\n  /// All values that aren't standard layout (or are larger than 8 bytes)\n  /// should be stored by reference instead of by value.\n  using ValTy =\n      AlignedCharArrayUnion<DIEInteger, DIEString, DIEExpr, DIELabel,\n                            DIEDelta *, DIEEntry, DIEBlock *, DIELoc *,\n                            DIELocList, DIEBaseTypeRef *, DIEAddrOffset *>;\n\n  static_assert(sizeof(ValTy) <= sizeof(uint64_t) ||\n                    sizeof(ValTy) <= sizeof(void *),\n                \"Expected all large types to be stored via pointer\");\n\n  /// Underlying stored value.\n  ValTy Val;\n\n  template <class T> void construct(T V) {\n    static_assert(std::is_standard_layout<T>::value ||\n                      std::is_pointer<T>::value,\n                  \"Expected standard layout or pointer\");\n    new (reinterpret_cast<void *>(&Val)) T(V);\n  }\n\n  template <class T> T *get() { return reinterpret_cast<T *>(&Val); }\n  template <class T> const T *get() const {\n    return reinterpret_cast<const T *>(&Val);\n  }\n  template <class T> void destruct() { get<T>()->~T(); }\n\n  /// Destroy the underlying value.\n  ///\n  /// This should get optimized down to a no-op.  We could skip it if we could\n  /// add a static assert on \\a std::is_trivially_copyable(), but we currently\n  /// support versions of GCC that don't understand that.\n  void destroyVal() {\n    switch (Ty) {\n    case isNone:\n      return;\n#define HANDLE_DIEVALUE_SMALL(T)                                               \\\n  case is##T:                                                                  \\\n    destruct<DIE##T>();                                                        \\\n    return;\n#define HANDLE_DIEVALUE_LARGE(T)                                               \\\n  case is##T:                                                                  \\\n    destruct<const DIE##T *>();                                                \\\n    return;\n#include \"llvm/CodeGen/DIEValue.def\"\n    }\n  }\n\n  /// Copy the underlying value.\n  ///\n  /// This should get optimized down to a simple copy.  We need to actually\n  /// construct the value, rather than calling memcpy, to satisfy strict\n  /// aliasing rules.\n  void copyVal(const DIEValue &X) {\n    switch (Ty) {\n    case isNone:\n      return;\n#define HANDLE_DIEVALUE_SMALL(T)                                               \\\n  case is##T:                                                                  \\\n    construct<DIE##T>(*X.get<DIE##T>());                                       \\\n    return;\n#define HANDLE_DIEVALUE_LARGE(T)                                               \\\n  case is##T:                                                                  \\\n    construct<const DIE##T *>(*X.get<const DIE##T *>());                       \\\n    return;\n#include \"llvm/CodeGen/DIEValue.def\"\n    }\n  }\n\npublic:\n  DIEValue() = default;\n\n  DIEValue(const DIEValue &X) : Ty(X.Ty), Attribute(X.Attribute), Form(X.Form) {\n    copyVal(X);\n  }\n\n  DIEValue &operator=(const DIEValue &X) {\n    destroyVal();\n    Ty = X.Ty;\n    Attribute = X.Attribute;\n    Form = X.Form;\n    copyVal(X);\n    return *this;\n  }\n\n  ~DIEValue() { destroyVal(); }\n\n#define HANDLE_DIEVALUE_SMALL(T)                                               \\\n  DIEValue(dwarf::Attribute Attribute, dwarf::Form Form, const DIE##T &V)      \\\n      : Ty(is##T), Attribute(Attribute), Form(Form) {                          \\\n    construct<DIE##T>(V);                                                      \\\n  }\n#define HANDLE_DIEVALUE_LARGE(T)                                               \\\n  DIEValue(dwarf::Attribute Attribute, dwarf::Form Form, const DIE##T *V)      \\\n      : Ty(is##T), Attribute(Attribute), Form(Form) {                          \\\n    assert(V && \"Expected valid value\");                                       \\\n    construct<const DIE##T *>(V);                                              \\\n  }\n#include \"llvm/CodeGen/DIEValue.def\"\n\n  /// Accessors.\n  /// @{\n  Type getType() const { return Ty; }\n  dwarf::Attribute getAttribute() const { return Attribute; }\n  dwarf::Form getForm() const { return Form; }\n  explicit operator bool() const { return Ty; }\n  /// @}\n\n#define HANDLE_DIEVALUE_SMALL(T)                                               \\\n  const DIE##T &getDIE##T() const {                                            \\\n    assert(getType() == is##T && \"Expected \" #T);                              \\\n    return *get<DIE##T>();                                                     \\\n  }\n#define HANDLE_DIEVALUE_LARGE(T)                                               \\\n  const DIE##T &getDIE##T() const {                                            \\\n    assert(getType() == is##T && \"Expected \" #T);                              \\\n    return **get<const DIE##T *>();                                            \\\n  }\n#include \"llvm/CodeGen/DIEValue.def\"\n\n  /// Emit value via the Dwarf writer.\n  void emitValue(const AsmPrinter *AP) const;\n\n  /// Return the size of a value in bytes.\n  unsigned SizeOf(const AsmPrinter *AP) const;\n\n  void print(raw_ostream &O) const;\n  void dump() const;\n};\n\nstruct IntrusiveBackListNode {\n  PointerIntPair<IntrusiveBackListNode *, 1> Next;\n\n  IntrusiveBackListNode() : Next(this, true) {}\n\n  IntrusiveBackListNode *getNext() const {\n    return Next.getInt() ? nullptr : Next.getPointer();\n  }\n};\n\nstruct IntrusiveBackListBase {\n  using Node = IntrusiveBackListNode;\n\n  Node *Last = nullptr;\n\n  bool empty() const { return !Last; }\n\n  void push_back(Node &N) {\n    assert(N.Next.getPointer() == &N && \"Expected unlinked node\");\n    assert(N.Next.getInt() == true && \"Expected unlinked node\");\n\n    if (Last) {\n      N.Next = Last->Next;\n      Last->Next.setPointerAndInt(&N, false);\n    }\n    Last = &N;\n  }\n\n  void push_front(Node &N) {\n    assert(N.Next.getPointer() == &N && \"Expected unlinked node\");\n    assert(N.Next.getInt() == true && \"Expected unlinked node\");\n\n    if (Last) {\n      N.Next.setPointerAndInt(Last->Next.getPointer(), false);\n      Last->Next.setPointerAndInt(&N, true);\n    } else {\n      Last = &N;\n    }\n  }\n};\n\ntemplate <class T> class IntrusiveBackList : IntrusiveBackListBase {\npublic:\n  using IntrusiveBackListBase::empty;\n\n  void push_back(T &N) { IntrusiveBackListBase::push_back(N); }\n  void push_front(T &N) { IntrusiveBackListBase::push_front(N); }\n  T &back() { return *static_cast<T *>(Last); }\n  const T &back() const { return *static_cast<T *>(Last); }\n  T &front() {\n    return *static_cast<T *>(Last ? Last->Next.getPointer() : nullptr);\n  }\n  const T &front() const {\n    return *static_cast<T *>(Last ? Last->Next.getPointer() : nullptr);\n  }\n\n  void takeNodes(IntrusiveBackList<T> &Other) {\n    if (Other.empty())\n      return;\n\n    T *FirstNode = static_cast<T *>(Other.Last->Next.getPointer());\n    T *IterNode = FirstNode;\n    do {\n      // Keep a pointer to the node and increment the iterator.\n      T *TmpNode = IterNode;\n      IterNode = static_cast<T *>(IterNode->Next.getPointer());\n\n      // Unlink the node and push it back to this list.\n      TmpNode->Next.setPointerAndInt(TmpNode, true);\n      push_back(*TmpNode);\n    } while (IterNode != FirstNode);\n\n    Other.Last = nullptr;\n  }\n\n  class const_iterator;\n  class iterator\n      : public iterator_facade_base<iterator, std::forward_iterator_tag, T> {\n    friend class const_iterator;\n\n    Node *N = nullptr;\n\n  public:\n    iterator() = default;\n    explicit iterator(T *N) : N(N) {}\n\n    iterator &operator++() {\n      N = N->getNext();\n      return *this;\n    }\n\n    explicit operator bool() const { return N; }\n    T &operator*() const { return *static_cast<T *>(N); }\n\n    bool operator==(const iterator &X) const { return N == X.N; }\n  };\n\n  class const_iterator\n      : public iterator_facade_base<const_iterator, std::forward_iterator_tag,\n                                    const T> {\n    const Node *N = nullptr;\n\n  public:\n    const_iterator() = default;\n    // Placate MSVC by explicitly scoping 'iterator'.\n    const_iterator(typename IntrusiveBackList<T>::iterator X) : N(X.N) {}\n    explicit const_iterator(const T *N) : N(N) {}\n\n    const_iterator &operator++() {\n      N = N->getNext();\n      return *this;\n    }\n\n    explicit operator bool() const { return N; }\n    const T &operator*() const { return *static_cast<const T *>(N); }\n\n    bool operator==(const const_iterator &X) const { return N == X.N; }\n  };\n\n  iterator begin() {\n    return Last ? iterator(static_cast<T *>(Last->Next.getPointer())) : end();\n  }\n  const_iterator begin() const {\n    return const_cast<IntrusiveBackList *>(this)->begin();\n  }\n  iterator end() { return iterator(); }\n  const_iterator end() const { return const_iterator(); }\n\n  static iterator toIterator(T &N) { return iterator(&N); }\n  static const_iterator toIterator(const T &N) { return const_iterator(&N); }\n};\n\n/// A list of DIE values.\n///\n/// This is a singly-linked list, but instead of reversing the order of\n/// insertion, we keep a pointer to the back of the list so we can push in\n/// order.\n///\n/// There are two main reasons to choose a linked list over a customized\n/// vector-like data structure.\n///\n///  1. For teardown efficiency, we want DIEs to be BumpPtrAllocated.  Using a\n///     linked list here makes this way easier to accomplish.\n///  2. Carrying an extra pointer per \\a DIEValue isn't expensive.  45% of DIEs\n///     have 2 or fewer values, and 90% have 5 or fewer.  A vector would be\n///     over-allocated by 50% on average anyway, the same cost as the\n///     linked-list node.\nclass DIEValueList {\n  struct Node : IntrusiveBackListNode {\n    DIEValue V;\n\n    explicit Node(DIEValue V) : V(V) {}\n  };\n\n  using ListTy = IntrusiveBackList<Node>;\n\n  ListTy List;\n\npublic:\n  class const_value_iterator;\n  class value_iterator\n      : public iterator_adaptor_base<value_iterator, ListTy::iterator,\n                                     std::forward_iterator_tag, DIEValue> {\n    friend class const_value_iterator;\n\n    using iterator_adaptor =\n        iterator_adaptor_base<value_iterator, ListTy::iterator,\n                              std::forward_iterator_tag, DIEValue>;\n\n  public:\n    value_iterator() = default;\n    explicit value_iterator(ListTy::iterator X) : iterator_adaptor(X) {}\n\n    explicit operator bool() const { return bool(wrapped()); }\n    DIEValue &operator*() const { return wrapped()->V; }\n  };\n\n  class const_value_iterator : public iterator_adaptor_base<\n                                   const_value_iterator, ListTy::const_iterator,\n                                   std::forward_iterator_tag, const DIEValue> {\n    using iterator_adaptor =\n        iterator_adaptor_base<const_value_iterator, ListTy::const_iterator,\n                              std::forward_iterator_tag, const DIEValue>;\n\n  public:\n    const_value_iterator() = default;\n    const_value_iterator(DIEValueList::value_iterator X)\n        : iterator_adaptor(X.wrapped()) {}\n    explicit const_value_iterator(ListTy::const_iterator X)\n        : iterator_adaptor(X) {}\n\n    explicit operator bool() const { return bool(wrapped()); }\n    const DIEValue &operator*() const { return wrapped()->V; }\n  };\n\n  using value_range = iterator_range<value_iterator>;\n  using const_value_range = iterator_range<const_value_iterator>;\n\n  value_iterator addValue(BumpPtrAllocator &Alloc, const DIEValue &V) {\n    List.push_back(*new (Alloc) Node(V));\n    return value_iterator(ListTy::toIterator(List.back()));\n  }\n  template <class T>\n  value_iterator addValue(BumpPtrAllocator &Alloc, dwarf::Attribute Attribute,\n                    dwarf::Form Form, T &&Value) {\n    return addValue(Alloc, DIEValue(Attribute, Form, std::forward<T>(Value)));\n  }\n\n  /// Take ownership of the nodes in \\p Other, and append them to the back of\n  /// the list.\n  void takeValues(DIEValueList &Other) { List.takeNodes(Other.List); }\n\n  value_range values() {\n    return make_range(value_iterator(List.begin()), value_iterator(List.end()));\n  }\n  const_value_range values() const {\n    return make_range(const_value_iterator(List.begin()),\n                      const_value_iterator(List.end()));\n  }\n};\n\n//===--------------------------------------------------------------------===//\n/// A structured debug information entry.  Has an abbreviation which\n/// describes its organization.\nclass DIE : IntrusiveBackListNode, public DIEValueList {\n  friend class IntrusiveBackList<DIE>;\n  friend class DIEUnit;\n\n  /// Dwarf unit relative offset.\n  unsigned Offset = 0;\n  /// Size of instance + children.\n  unsigned Size = 0;\n  unsigned AbbrevNumber = ~0u;\n  /// Dwarf tag code.\n  dwarf::Tag Tag = (dwarf::Tag)0;\n  /// Set to true to force a DIE to emit an abbreviation that says it has\n  /// children even when it doesn't. This is used for unit testing purposes.\n  bool ForceChildren = false;\n  /// Children DIEs.\n  IntrusiveBackList<DIE> Children;\n\n  /// The owner is either the parent DIE for children of other DIEs, or a\n  /// DIEUnit which contains this DIE as its unit DIE.\n  PointerUnion<DIE *, DIEUnit *> Owner;\n\n  explicit DIE(dwarf::Tag Tag) : Tag(Tag) {}\n\npublic:\n  DIE() = delete;\n  DIE(const DIE &RHS) = delete;\n  DIE(DIE &&RHS) = delete;\n  DIE &operator=(const DIE &RHS) = delete;\n  DIE &operator=(const DIE &&RHS) = delete;\n\n  static DIE *get(BumpPtrAllocator &Alloc, dwarf::Tag Tag) {\n    return new (Alloc) DIE(Tag);\n  }\n\n  // Accessors.\n  unsigned getAbbrevNumber() const { return AbbrevNumber; }\n  dwarf::Tag getTag() const { return Tag; }\n  /// Get the compile/type unit relative offset of this DIE.\n  unsigned getOffset() const { return Offset; }\n  unsigned getSize() const { return Size; }\n  bool hasChildren() const { return ForceChildren || !Children.empty(); }\n  void setForceChildren(bool B) { ForceChildren = B; }\n\n  using child_iterator = IntrusiveBackList<DIE>::iterator;\n  using const_child_iterator = IntrusiveBackList<DIE>::const_iterator;\n  using child_range = iterator_range<child_iterator>;\n  using const_child_range = iterator_range<const_child_iterator>;\n\n  child_range children() {\n    return make_range(Children.begin(), Children.end());\n  }\n  const_child_range children() const {\n    return make_range(Children.begin(), Children.end());\n  }\n\n  DIE *getParent() const;\n\n  /// Generate the abbreviation for this DIE.\n  ///\n  /// Calculate the abbreviation for this, which should be uniqued and\n  /// eventually used to call \\a setAbbrevNumber().\n  DIEAbbrev generateAbbrev() const;\n\n  /// Set the abbreviation number for this DIE.\n  void setAbbrevNumber(unsigned I) { AbbrevNumber = I; }\n\n  /// Get the absolute offset within the .debug_info or .debug_types section\n  /// for this DIE.\n  uint64_t getDebugSectionOffset() const;\n\n  /// Compute the offset of this DIE and all its children.\n  ///\n  /// This function gets called just before we are going to generate the debug\n  /// information and gives each DIE a chance to figure out its CU relative DIE\n  /// offset, unique its abbreviation and fill in the abbreviation code, and\n  /// return the unit offset that points to where the next DIE will be emitted\n  /// within the debug unit section. After this function has been called for all\n  /// DIE objects, the DWARF can be generated since all DIEs will be able to\n  /// properly refer to other DIE objects since all DIEs have calculated their\n  /// offsets.\n  ///\n  /// \\param AP AsmPrinter to use when calculating sizes.\n  /// \\param AbbrevSet the abbreviation used to unique DIE abbreviations.\n  /// \\param CUOffset the compile/type unit relative offset in bytes.\n  /// \\returns the offset for the DIE that follows this DIE within the\n  /// current compile/type unit.\n  unsigned computeOffsetsAndAbbrevs(const AsmPrinter *AP,\n                                    DIEAbbrevSet &AbbrevSet, unsigned CUOffset);\n\n  /// Climb up the parent chain to get the compile unit or type unit DIE that\n  /// this DIE belongs to.\n  ///\n  /// \\returns the compile or type unit DIE that owns this DIE, or NULL if\n  /// this DIE hasn't been added to a unit DIE.\n  const DIE *getUnitDie() const;\n\n  /// Climb up the parent chain to get the compile unit or type unit that this\n  /// DIE belongs to.\n  ///\n  /// \\returns the DIEUnit that represents the compile or type unit that owns\n  /// this DIE, or NULL if this DIE hasn't been added to a unit DIE.\n  DIEUnit *getUnit() const;\n\n  void setOffset(unsigned O) { Offset = O; }\n  void setSize(unsigned S) { Size = S; }\n\n  /// Add a child to the DIE.\n  DIE &addChild(DIE *Child) {\n    assert(!Child->getParent() && \"Child should be orphaned\");\n    Child->Owner = this;\n    Children.push_back(*Child);\n    return Children.back();\n  }\n\n  DIE &addChildFront(DIE *Child) {\n    assert(!Child->getParent() && \"Child should be orphaned\");\n    Child->Owner = this;\n    Children.push_front(*Child);\n    return Children.front();\n  }\n\n  /// Find a value in the DIE with the attribute given.\n  ///\n  /// Returns a default-constructed DIEValue (where \\a DIEValue::getType()\n  /// gives \\a DIEValue::isNone) if no such attribute exists.\n  DIEValue findAttribute(dwarf::Attribute Attribute) const;\n\n  void print(raw_ostream &O, unsigned IndentCount = 0) const;\n  void dump() const;\n};\n\n//===--------------------------------------------------------------------===//\n/// Represents a compile or type unit.\nclass DIEUnit {\n  /// The compile unit or type unit DIE. This variable must be an instance of\n  /// DIE so that we can calculate the DIEUnit from any DIE by traversing the\n  /// parent backchain and getting the Unit DIE, and then casting itself to a\n  /// DIEUnit. This allows us to be able to find the DIEUnit for any DIE without\n  /// having to store a pointer to the DIEUnit in each DIE instance.\n  DIE Die;\n  /// The section this unit will be emitted in. This may or may not be set to\n  /// a valid section depending on the client that is emitting DWARF.\n  MCSection *Section;\n  uint64_t Offset; /// .debug_info or .debug_types absolute section offset.\nprotected:\n  virtual ~DIEUnit() = default;\n\npublic:\n  explicit DIEUnit(dwarf::Tag UnitTag);\n  DIEUnit(const DIEUnit &RHS) = delete;\n  DIEUnit(DIEUnit &&RHS) = delete;\n  void operator=(const DIEUnit &RHS) = delete;\n  void operator=(const DIEUnit &&RHS) = delete;\n  /// Set the section that this DIEUnit will be emitted into.\n  ///\n  /// This function is used by some clients to set the section. Not all clients\n  /// that emit DWARF use this section variable.\n  void setSection(MCSection *Section) {\n    assert(!this->Section);\n    this->Section = Section;\n  }\n\n  virtual const MCSymbol *getCrossSectionRelativeBaseAddress() const {\n    return nullptr;\n  }\n\n  /// Return the section that this DIEUnit will be emitted into.\n  ///\n  /// \\returns Section pointer which can be NULL.\n  MCSection *getSection() const { return Section; }\n  void setDebugSectionOffset(uint64_t O) { Offset = O; }\n  uint64_t getDebugSectionOffset() const { return Offset; }\n  DIE &getUnitDie() { return Die; }\n  const DIE &getUnitDie() const { return Die; }\n};\n\nstruct BasicDIEUnit final : DIEUnit {\n  explicit BasicDIEUnit(dwarf::Tag UnitTag) : DIEUnit(UnitTag) {}\n};\n\n//===--------------------------------------------------------------------===//\n/// DIELoc - Represents an expression location.\n//\nclass DIELoc : public DIEValueList {\n  mutable unsigned Size = 0; // Size in bytes excluding size header.\n\npublic:\n  DIELoc() = default;\n\n  /// ComputeSize - Calculate the size of the location expression.\n  ///\n  unsigned ComputeSize(const AsmPrinter *AP) const;\n\n  // TODO: move setSize() and Size to DIEValueList.\n  void setSize(unsigned size) { Size = size; }\n\n  /// BestForm - Choose the best form for data.\n  ///\n  dwarf::Form BestForm(unsigned DwarfVersion) const {\n    if (DwarfVersion > 3)\n      return dwarf::DW_FORM_exprloc;\n    // Pre-DWARF4 location expressions were blocks and not exprloc.\n    if ((unsigned char)Size == Size)\n      return dwarf::DW_FORM_block1;\n    if ((unsigned short)Size == Size)\n      return dwarf::DW_FORM_block2;\n    if ((unsigned int)Size == Size)\n      return dwarf::DW_FORM_block4;\n    return dwarf::DW_FORM_block;\n  }\n\n  void emitValue(const AsmPrinter *Asm, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// DIEBlock - Represents a block of values.\n//\nclass DIEBlock : public DIEValueList {\n  mutable unsigned Size = 0; // Size in bytes excluding size header.\n\npublic:\n  DIEBlock() = default;\n\n  /// ComputeSize - Calculate the size of the location expression.\n  ///\n  unsigned ComputeSize(const AsmPrinter *AP) const;\n\n  // TODO: move setSize() and Size to DIEValueList.\n  void setSize(unsigned size) { Size = size; }\n\n  /// BestForm - Choose the best form for data.\n  ///\n  dwarf::Form BestForm() const {\n    if ((unsigned char)Size == Size)\n      return dwarf::DW_FORM_block1;\n    if ((unsigned short)Size == Size)\n      return dwarf::DW_FORM_block2;\n    if ((unsigned int)Size == Size)\n      return dwarf::DW_FORM_block4;\n    return dwarf::DW_FORM_block;\n  }\n\n  void emitValue(const AsmPrinter *Asm, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_DIE_H\n"}, "29": {"id": 29, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DwarfStringPoolEntry.h", "content": "//===- llvm/CodeGen/DwarfStringPoolEntry.h - String pool entry --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_DWARFSTRINGPOOLENTRY_H\n#define LLVM_CODEGEN_DWARFSTRINGPOOLENTRY_H\n\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/StringMap.h\"\n\nnamespace llvm {\n\nclass MCSymbol;\n\n/// Data for a string pool entry.\nstruct DwarfStringPoolEntry {\n  static constexpr unsigned NotIndexed = -1;\n\n  MCSymbol *Symbol;\n  uint64_t Offset;\n  unsigned Index;\n\n  bool isIndexed() const { return Index != NotIndexed; }\n};\n\n/// String pool entry reference.\nclass DwarfStringPoolEntryRef {\n  PointerIntPair<const StringMapEntry<DwarfStringPoolEntry> *, 1, bool>\n      MapEntryAndIndexed;\n\n  const StringMapEntry<DwarfStringPoolEntry> *getMapEntry() const {\n    return MapEntryAndIndexed.getPointer();\n  }\n\npublic:\n  DwarfStringPoolEntryRef() = default;\n  DwarfStringPoolEntryRef(const StringMapEntry<DwarfStringPoolEntry> &Entry,\n                          bool Indexed)\n      : MapEntryAndIndexed(&Entry, Indexed) {}\n\n  explicit operator bool() const { return getMapEntry(); }\n  MCSymbol *getSymbol() const {\n    assert(getMapEntry()->second.Symbol && \"No symbol available!\");\n    return getMapEntry()->second.Symbol;\n  }\n  uint64_t getOffset() const { return getMapEntry()->second.Offset; }\n  bool isIndexed() const { return MapEntryAndIndexed.getInt(); }\n  unsigned getIndex() const {\n    assert(isIndexed());\n    assert(getMapEntry()->getValue().isIndexed());\n    return getMapEntry()->second.Index;\n  }\n  StringRef getString() const { return getMapEntry()->first(); }\n  /// Return the entire string pool entry for convenience.\n  DwarfStringPoolEntry getEntry() const { return getMapEntry()->getValue(); }\n\n  bool operator==(const DwarfStringPoolEntryRef &X) const {\n    return getMapEntry() == X.getMapEntry();\n  }\n  bool operator!=(const DwarfStringPoolEntryRef &X) const {\n    return getMapEntry() != X.getMapEntry();\n  }\n};\n\n} // end namespace llvm\n\n#endif\n"}, "30": {"id": 30, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h", "content": "//===- llvm/CodeGen/MachineBasicBlock.h -------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Collect the sequence of machine instructions for a basic block.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_MACHINEBASICBLOCK_H\n#define LLVM_CODEGEN_MACHINEBASICBLOCK_H\n\n#include \"llvm/ADT/GraphTraits.h\"\n#include \"llvm/ADT/ilist.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/ADT/SparseBitVector.h\"\n#include \"llvm/CodeGen/MachineInstr.h\"\n#include \"llvm/CodeGen/MachineInstrBundleIterator.h\"\n#include \"llvm/IR/DebugLoc.h\"\n#include \"llvm/MC/LaneBitmask.h\"\n#include \"llvm/Support/BranchProbability.h\"\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iterator>\n#include <string>\n#include <vector>\n\nnamespace llvm {\n\nclass BasicBlock;\nclass MachineFunction;\nclass MCSymbol;\nclass ModuleSlotTracker;\nclass Pass;\nclass Printable;\nclass SlotIndexes;\nclass StringRef;\nclass raw_ostream;\nclass LiveIntervals;\nclass TargetRegisterClass;\nclass TargetRegisterInfo;\n\n// This structure uniquely identifies a basic block section.\n// Possible values are\n//  {Type: Default, Number: (unsigned)} (These are regular section IDs)\n//  {Type: Exception, Number: 0}  (ExceptionSectionID)\n//  {Type: Cold, Number: 0}  (ColdSectionID)\nstruct MBBSectionID {\n  enum SectionType {\n    Default = 0, // Regular section (these sections are distinguished by the\n                 // Number field).\n    Exception,   // Special section type for exception handling blocks\n    Cold,        // Special section type for cold blocks\n  } Type;\n  unsigned Number;\n\n  MBBSectionID(unsigned N) : Type(Default), Number(N) {}\n\n  // Special unique sections for cold and exception blocks.\n  const static MBBSectionID ColdSectionID;\n  const static MBBSectionID ExceptionSectionID;\n\n  bool operator==(const MBBSectionID &Other) const {\n    return Type == Other.Type && Number == Other.Number;\n  }\n\n  bool operator!=(const MBBSectionID &Other) const { return !(*this == Other); }\n\nprivate:\n  // This is only used to construct the special cold and exception sections.\n  MBBSectionID(SectionType T) : Type(T), Number(0) {}\n};\n\ntemplate <> struct ilist_traits<MachineInstr> {\nprivate:\n  friend class MachineBasicBlock; // Set by the owning MachineBasicBlock.\n\n  MachineBasicBlock *Parent;\n\n  using instr_iterator =\n      simple_ilist<MachineInstr, ilist_sentinel_tracking<true>>::iterator;\n\npublic:\n  void addNodeToList(MachineInstr *N);\n  void removeNodeFromList(MachineInstr *N);\n  void transferNodesFromList(ilist_traits &FromList, instr_iterator First,\n                             instr_iterator Last);\n  void deleteNode(MachineInstr *MI);\n};\n\nclass MachineBasicBlock\n    : public ilist_node_with_parent<MachineBasicBlock, MachineFunction> {\npublic:\n  /// Pair of physical register and lane mask.\n  /// This is not simply a std::pair typedef because the members should be named\n  /// clearly as they both have an integer type.\n  struct RegisterMaskPair {\n  public:\n    MCPhysReg PhysReg;\n    LaneBitmask LaneMask;\n\n    RegisterMaskPair(MCPhysReg PhysReg, LaneBitmask LaneMask)\n        : PhysReg(PhysReg), LaneMask(LaneMask) {}\n  };\n\nprivate:\n  using Instructions = ilist<MachineInstr, ilist_sentinel_tracking<true>>;\n\n  Instructions Insts;\n  const BasicBlock *BB;\n  int Number;\n  MachineFunction *xParent;\n\n  /// Keep track of the predecessor / successor basic blocks.\n  std::vector<MachineBasicBlock *> Predecessors;\n  std::vector<MachineBasicBlock *> Successors;\n\n  /// Keep track of the probabilities to the successors. This vector has the\n  /// same order as Successors, or it is empty if we don't use it (disable\n  /// optimization).\n  std::vector<BranchProbability> Probs;\n  using probability_iterator = std::vector<BranchProbability>::iterator;\n  using const_probability_iterator =\n      std::vector<BranchProbability>::const_iterator;\n\n  Optional<uint64_t> IrrLoopHeaderWeight;\n\n  /// Keep track of the physical registers that are livein of the basicblock.\n  using LiveInVector = std::vector<RegisterMaskPair>;\n  LiveInVector LiveIns;\n\n  /// Alignment of the basic block. One if the basic block does not need to be\n  /// aligned.\n  Align Alignment;\n\n  /// Indicate that this basic block is entered via an exception handler.\n  bool IsEHPad = false;\n\n  /// Indicate that this basic block is potentially the target of an indirect\n  /// branch.\n  bool AddressTaken = false;\n\n  /// Indicate that this basic block needs its symbol be emitted regardless of\n  /// whether the flow just falls-through to it.\n  bool LabelMustBeEmitted = false;\n\n  /// Indicate that this basic block is the entry block of an EH scope, i.e.,\n  /// the block that used to have a catchpad or cleanuppad instruction in the\n  /// LLVM IR.\n  bool IsEHScopeEntry = false;\n\n  /// Indicates if this is a target block of a catchret.\n  bool IsEHCatchretTarget = false;\n\n  /// Indicate that this basic block is the entry block of an EH funclet.\n  bool IsEHFuncletEntry = false;\n\n  /// Indicate that this basic block is the entry block of a cleanup funclet.\n  bool IsCleanupFuncletEntry = false;\n\n  /// With basic block sections, this stores the Section ID of the basic block.\n  MBBSectionID SectionID{0};\n\n  // Indicate that this basic block begins a section.\n  bool IsBeginSection = false;\n\n  // Indicate that this basic block ends a section.\n  bool IsEndSection = false;\n\n  /// Indicate that this basic block is the indirect dest of an INLINEASM_BR.\n  bool IsInlineAsmBrIndirectTarget = false;\n\n  /// since getSymbol is a relatively heavy-weight operation, the symbol\n  /// is only computed once and is cached.\n  mutable MCSymbol *CachedMCSymbol = nullptr;\n\n  /// Cached MCSymbol for this block (used if IsEHCatchRetTarget).\n  mutable MCSymbol *CachedEHCatchretMCSymbol = nullptr;\n\n  /// Marks the end of the basic block. Used during basic block sections to\n  /// calculate the size of the basic block, or the BB section ending with it.\n  mutable MCSymbol *CachedEndMCSymbol = nullptr;\n\n  // Intrusive list support\n  MachineBasicBlock() = default;\n\n  explicit MachineBasicBlock(MachineFunction &MF, const BasicBlock *BB);\n\n  ~MachineBasicBlock();\n\n  // MachineBasicBlocks are allocated and owned by MachineFunction.\n  friend class MachineFunction;\n\npublic:\n  /// Return the LLVM basic block that this instance corresponded to originally.\n  /// Note that this may be NULL if this instance does not correspond directly\n  /// to an LLVM basic block.\n  const BasicBlock *getBasicBlock() const { return BB; }\n\n  /// Return the name of the corresponding LLVM basic block, or an empty string.\n  StringRef getName() const;\n\n  /// Return a formatted string to identify this block and its parent function.\n  std::string getFullName() const;\n\n  /// Test whether this block is potentially the target of an indirect branch.\n  bool hasAddressTaken() const { return AddressTaken; }\n\n  /// Set this block to reflect that it potentially is the target of an indirect\n  /// branch.\n  void setHasAddressTaken() { AddressTaken = true; }\n\n  /// Test whether this block must have its label emitted.\n  bool hasLabelMustBeEmitted() const { return LabelMustBeEmitted; }\n\n  /// Set this block to reflect that, regardless how we flow to it, we need\n  /// its label be emitted.\n  void setLabelMustBeEmitted() { LabelMustBeEmitted = true; }\n\n  /// Return the MachineFunction containing this basic block.\n  const MachineFunction *getParent() const { return xParent; }\n  MachineFunction *getParent() { return xParent; }\n\n  using instr_iterator = Instructions::iterator;\n  using const_instr_iterator = Instructions::const_iterator;\n  using reverse_instr_iterator = Instructions::reverse_iterator;\n  using const_reverse_instr_iterator = Instructions::const_reverse_iterator;\n\n  using iterator = MachineInstrBundleIterator<MachineInstr>;\n  using const_iterator = MachineInstrBundleIterator<const MachineInstr>;\n  using reverse_iterator = MachineInstrBundleIterator<MachineInstr, true>;\n  using const_reverse_iterator =\n      MachineInstrBundleIterator<const MachineInstr, true>;\n\n  unsigned size() const { return (unsigned)Insts.size(); }\n  bool empty() const { return Insts.empty(); }\n\n  MachineInstr       &instr_front()       { return Insts.front(); }\n  MachineInstr       &instr_back()        { return Insts.back();  }\n  const MachineInstr &instr_front() const { return Insts.front(); }\n  const MachineInstr &instr_back()  const { return Insts.back();  }\n\n  MachineInstr       &front()             { return Insts.front(); }\n  MachineInstr       &back()              { return *--end();      }\n  const MachineInstr &front()       const { return Insts.front(); }\n  const MachineInstr &back()        const { return *--end();      }\n\n  instr_iterator                instr_begin()       { return Insts.begin();  }\n  const_instr_iterator          instr_begin() const { return Insts.begin();  }\n  instr_iterator                  instr_end()       { return Insts.end();    }\n  const_instr_iterator            instr_end() const { return Insts.end();    }\n  reverse_instr_iterator       instr_rbegin()       { return Insts.rbegin(); }\n  const_reverse_instr_iterator instr_rbegin() const { return Insts.rbegin(); }\n  reverse_instr_iterator       instr_rend  ()       { return Insts.rend();   }\n  const_reverse_instr_iterator instr_rend  () const { return Insts.rend();   }\n\n  using instr_range = iterator_range<instr_iterator>;\n  using const_instr_range = iterator_range<const_instr_iterator>;\n  instr_range instrs() { return instr_range(instr_begin(), instr_end()); }\n  const_instr_range instrs() const {\n    return const_instr_range(instr_begin(), instr_end());\n  }\n\n  iterator                begin()       { return instr_begin();  }\n  const_iterator          begin() const { return instr_begin();  }\n  iterator                end  ()       { return instr_end();    }\n  const_iterator          end  () const { return instr_end();    }\n  reverse_iterator rbegin() {\n    return reverse_iterator::getAtBundleBegin(instr_rbegin());\n  }\n  const_reverse_iterator rbegin() const {\n    return const_reverse_iterator::getAtBundleBegin(instr_rbegin());\n  }\n  reverse_iterator rend() { return reverse_iterator(instr_rend()); }\n  const_reverse_iterator rend() const {\n    return const_reverse_iterator(instr_rend());\n  }\n\n  /// Support for MachineInstr::getNextNode().\n  static Instructions MachineBasicBlock::*getSublistAccess(MachineInstr *) {\n    return &MachineBasicBlock::Insts;\n  }\n\n  inline iterator_range<iterator> terminators() {\n    return make_range(getFirstTerminator(), end());\n  }\n  inline iterator_range<const_iterator> terminators() const {\n    return make_range(getFirstTerminator(), end());\n  }\n\n  /// Returns a range that iterates over the phis in the basic block.\n  inline iterator_range<iterator> phis() {\n    return make_range(begin(), getFirstNonPHI());\n  }\n  inline iterator_range<const_iterator> phis() const {\n    return const_cast<MachineBasicBlock *>(this)->phis();\n  }\n\n  // Machine-CFG iterators\n  using pred_iterator = std::vector<MachineBasicBlock *>::iterator;\n  using const_pred_iterator = std::vector<MachineBasicBlock *>::const_iterator;\n  using succ_iterator = std::vector<MachineBasicBlock *>::iterator;\n  using const_succ_iterator = std::vector<MachineBasicBlock *>::const_iterator;\n  using pred_reverse_iterator =\n      std::vector<MachineBasicBlock *>::reverse_iterator;\n  using const_pred_reverse_iterator =\n      std::vector<MachineBasicBlock *>::const_reverse_iterator;\n  using succ_reverse_iterator =\n      std::vector<MachineBasicBlock *>::reverse_iterator;\n  using const_succ_reverse_iterator =\n      std::vector<MachineBasicBlock *>::const_reverse_iterator;\n  pred_iterator        pred_begin()       { return Predecessors.begin(); }\n  const_pred_iterator  pred_begin() const { return Predecessors.begin(); }\n  pred_iterator        pred_end()         { return Predecessors.end();   }\n  const_pred_iterator  pred_end()   const { return Predecessors.end();   }\n  pred_reverse_iterator        pred_rbegin()\n                                          { return Predecessors.rbegin();}\n  const_pred_reverse_iterator  pred_rbegin() const\n                                          { return Predecessors.rbegin();}\n  pred_reverse_iterator        pred_rend()\n                                          { return Predecessors.rend();  }\n  const_pred_reverse_iterator  pred_rend()   const\n                                          { return Predecessors.rend();  }\n  unsigned             pred_size()  const {\n    return (unsigned)Predecessors.size();\n  }\n  bool                 pred_empty() const { return Predecessors.empty(); }\n  succ_iterator        succ_begin()       { return Successors.begin();   }\n  const_succ_iterator  succ_begin() const { return Successors.begin();   }\n  succ_iterator        succ_end()         { return Successors.end();     }\n  const_succ_iterator  succ_end()   const { return Successors.end();     }\n  succ_reverse_iterator        succ_rbegin()\n                                          { return Successors.rbegin();  }\n  const_succ_reverse_iterator  succ_rbegin() const\n                                          { return Successors.rbegin();  }\n  succ_reverse_iterator        succ_rend()\n                                          { return Successors.rend();    }\n  const_succ_reverse_iterator  succ_rend()   const\n                                          { return Successors.rend();    }\n  unsigned             succ_size()  const {\n    return (unsigned)Successors.size();\n  }\n  bool                 succ_empty() const { return Successors.empty();   }\n\n  inline iterator_range<pred_iterator> predecessors() {\n    return make_range(pred_begin(), pred_end());\n  }\n  inline iterator_range<const_pred_iterator> predecessors() const {\n    return make_range(pred_begin(), pred_end());\n  }\n  inline iterator_range<succ_iterator> successors() {\n    return make_range(succ_begin(), succ_end());\n  }\n  inline iterator_range<const_succ_iterator> successors() const {\n    return make_range(succ_begin(), succ_end());\n  }\n\n  // LiveIn management methods.\n\n  /// Adds the specified register as a live in. Note that it is an error to add\n  /// the same register to the same set more than once unless the intention is\n  /// to call sortUniqueLiveIns after all registers are added.\n  void addLiveIn(MCRegister PhysReg,\n                 LaneBitmask LaneMask = LaneBitmask::getAll()) {\n    LiveIns.push_back(RegisterMaskPair(PhysReg, LaneMask));\n  }\n  void addLiveIn(const RegisterMaskPair &RegMaskPair) {\n    LiveIns.push_back(RegMaskPair);\n  }\n\n  /// Sorts and uniques the LiveIns vector. It can be significantly faster to do\n  /// this than repeatedly calling isLiveIn before calling addLiveIn for every\n  /// LiveIn insertion.\n  void sortUniqueLiveIns();\n\n  /// Clear live in list.\n  void clearLiveIns();\n\n  /// Add PhysReg as live in to this block, and ensure that there is a copy of\n  /// PhysReg to a virtual register of class RC. Return the virtual register\n  /// that is a copy of the live in PhysReg.\n  Register addLiveIn(MCRegister PhysReg, const TargetRegisterClass *RC);\n\n  /// Remove the specified register from the live in set.\n  void removeLiveIn(MCPhysReg Reg,\n                    LaneBitmask LaneMask = LaneBitmask::getAll());\n\n  /// Return true if the specified register is in the live in set.\n  bool isLiveIn(MCPhysReg Reg,\n                LaneBitmask LaneMask = LaneBitmask::getAll()) const;\n\n  // Iteration support for live in sets.  These sets are kept in sorted\n  // order by their register number.\n  using livein_iterator = LiveInVector::const_iterator;\n#ifndef NDEBUG\n  /// Unlike livein_begin, this method does not check that the liveness\n  /// information is accurate. Still for debug purposes it may be useful\n  /// to have iterators that won't assert if the liveness information\n  /// is not current.\n  livein_iterator livein_begin_dbg() const { return LiveIns.begin(); }\n  iterator_range<livein_iterator> liveins_dbg() const {\n    return make_range(livein_begin_dbg(), livein_end());\n  }\n#endif\n  livein_iterator livein_begin() const;\n  livein_iterator livein_end()   const { return LiveIns.end(); }\n  bool            livein_empty() const { return LiveIns.empty(); }\n  iterator_range<livein_iterator> liveins() const {\n    return make_range(livein_begin(), livein_end());\n  }\n\n  /// Remove entry from the livein set and return iterator to the next.\n  livein_iterator removeLiveIn(livein_iterator I);\n\n  /// Get the clobber mask for the start of this basic block. Funclets use this\n  /// to prevent register allocation across funclet transitions.\n  const uint32_t *getBeginClobberMask(const TargetRegisterInfo *TRI) const;\n\n  /// Get the clobber mask for the end of the basic block.\n  /// \\see getBeginClobberMask()\n  const uint32_t *getEndClobberMask(const TargetRegisterInfo *TRI) const;\n\n  /// Return alignment of the basic block.\n  Align getAlignment() const { return Alignment; }\n\n  /// Set alignment of the basic block.\n  void setAlignment(Align A) { Alignment = A; }\n\n  /// Returns true if the block is a landing pad. That is this basic block is\n  /// entered via an exception handler.\n  bool isEHPad() const { return IsEHPad; }\n\n  /// Indicates the block is a landing pad.  That is this basic block is entered\n  /// via an exception handler.\n  void setIsEHPad(bool V = true) { IsEHPad = V; }\n\n  bool hasEHPadSuccessor() const;\n\n  /// Returns true if this is the entry block of the function.\n  bool isEntryBlock() const;\n\n  /// Returns true if this is the entry block of an EH scope, i.e., the block\n  /// that used to have a catchpad or cleanuppad instruction in the LLVM IR.\n  bool isEHScopeEntry() const { return IsEHScopeEntry; }\n\n  /// Indicates if this is the entry block of an EH scope, i.e., the block that\n  /// that used to have a catchpad or cleanuppad instruction in the LLVM IR.\n  void setIsEHScopeEntry(bool V = true) { IsEHScopeEntry = V; }\n\n  /// Returns true if this is a target block of a catchret.\n  bool isEHCatchretTarget() const { return IsEHCatchretTarget; }\n\n  /// Indicates if this is a target block of a catchret.\n  void setIsEHCatchretTarget(bool V = true) { IsEHCatchretTarget = V; }\n\n  /// Returns true if this is the entry block of an EH funclet.\n  bool isEHFuncletEntry() const { return IsEHFuncletEntry; }\n\n  /// Indicates if this is the entry block of an EH funclet.\n  void setIsEHFuncletEntry(bool V = true) { IsEHFuncletEntry = V; }\n\n  /// Returns true if this is the entry block of a cleanup funclet.\n  bool isCleanupFuncletEntry() const { return IsCleanupFuncletEntry; }\n\n  /// Indicates if this is the entry block of a cleanup funclet.\n  void setIsCleanupFuncletEntry(bool V = true) { IsCleanupFuncletEntry = V; }\n\n  /// Returns true if this block begins any section.\n  bool isBeginSection() const { return IsBeginSection; }\n\n  /// Returns true if this block ends any section.\n  bool isEndSection() const { return IsEndSection; }\n\n  void setIsBeginSection(bool V = true) { IsBeginSection = V; }\n\n  void setIsEndSection(bool V = true) { IsEndSection = V; }\n\n  /// Returns the section ID of this basic block.\n  MBBSectionID getSectionID() const { return SectionID; }\n\n  /// Returns the unique section ID number of this basic block.\n  unsigned getSectionIDNum() const {\n    return ((unsigned)MBBSectionID::SectionType::Cold) -\n           ((unsigned)SectionID.Type) + SectionID.Number;\n  }\n\n  /// Sets the section ID for this basic block.\n  void setSectionID(MBBSectionID V) { SectionID = V; }\n\n  /// Returns the MCSymbol marking the end of this basic block.\n  MCSymbol *getEndSymbol() const;\n\n  /// Returns true if this block may have an INLINEASM_BR (overestimate, by\n  /// checking if any of the successors are indirect targets of any inlineasm_br\n  /// in the function).\n  bool mayHaveInlineAsmBr() const;\n\n  /// Returns true if this is the indirect dest of an INLINEASM_BR.\n  bool isInlineAsmBrIndirectTarget() const {\n    return IsInlineAsmBrIndirectTarget;\n  }\n\n  /// Indicates if this is the indirect dest of an INLINEASM_BR.\n  void setIsInlineAsmBrIndirectTarget(bool V = true) {\n    IsInlineAsmBrIndirectTarget = V;\n  }\n\n  /// Returns true if it is legal to hoist instructions into this block.\n  bool isLegalToHoistInto() const;\n\n  // Code Layout methods.\n\n  /// Move 'this' block before or after the specified block.  This only moves\n  /// the block, it does not modify the CFG or adjust potential fall-throughs at\n  /// the end of the block.\n  void moveBefore(MachineBasicBlock *NewAfter);\n  void moveAfter(MachineBasicBlock *NewBefore);\n\n  /// Returns true if this and MBB belong to the same section.\n  bool sameSection(const MachineBasicBlock *MBB) const {\n    return getSectionID() == MBB->getSectionID();\n  }\n\n  /// Update the terminator instructions in block to account for changes to\n  /// block layout which may have been made. PreviousLayoutSuccessor should be\n  /// set to the block which may have been used as fallthrough before the block\n  /// layout was modified.  If the block previously fell through to that block,\n  /// it may now need a branch. If it previously branched to another block, it\n  /// may now be able to fallthrough to the current layout successor.\n  void updateTerminator(MachineBasicBlock *PreviousLayoutSuccessor);\n\n  // Machine-CFG mutators\n\n  /// Add Succ as a successor of this MachineBasicBlock.  The Predecessors list\n  /// of Succ is automatically updated. PROB parameter is stored in\n  /// Probabilities list. The default probability is set as unknown. Mixing\n  /// known and unknown probabilities in successor list is not allowed. When all\n  /// successors have unknown probabilities, 1 / N is returned as the\n  /// probability for each successor, where N is the number of successors.\n  ///\n  /// Note that duplicate Machine CFG edges are not allowed.\n  void addSuccessor(MachineBasicBlock *Succ,\n                    BranchProbability Prob = BranchProbability::getUnknown());\n\n  /// Add Succ as a successor of this MachineBasicBlock.  The Predecessors list\n  /// of Succ is automatically updated. The probability is not provided because\n  /// BPI is not available (e.g. -O0 is used), in which case edge probabilities\n  /// won't be used. Using this interface can save some space.\n  void addSuccessorWithoutProb(MachineBasicBlock *Succ);\n\n  /// Set successor probability of a given iterator.\n  void setSuccProbability(succ_iterator I, BranchProbability Prob);\n\n  /// Normalize probabilities of all successors so that the sum of them becomes\n  /// one. This is usually done when the current update on this MBB is done, and\n  /// the sum of its successors' probabilities is not guaranteed to be one. The\n  /// user is responsible for the correct use of this function.\n  /// MBB::removeSuccessor() has an option to do this automatically.\n  void normalizeSuccProbs() {\n    BranchProbability::normalizeProbabilities(Probs.begin(), Probs.end());\n  }\n\n  /// Validate successors' probabilities and check if the sum of them is\n  /// approximate one. This only works in DEBUG mode.\n  void validateSuccProbs() const;\n\n  /// Remove successor from the successors list of this MachineBasicBlock. The\n  /// Predecessors list of Succ is automatically updated.\n  /// If NormalizeSuccProbs is true, then normalize successors' probabilities\n  /// after the successor is removed.\n  void removeSuccessor(MachineBasicBlock *Succ,\n                       bool NormalizeSuccProbs = false);\n\n  /// Remove specified successor from the successors list of this\n  /// MachineBasicBlock. The Predecessors list of Succ is automatically updated.\n  /// If NormalizeSuccProbs is true, then normalize successors' probabilities\n  /// after the successor is removed.\n  /// Return the iterator to the element after the one removed.\n  succ_iterator removeSuccessor(succ_iterator I,\n                                bool NormalizeSuccProbs = false);\n\n  /// Replace successor OLD with NEW and update probability info.\n  void replaceSuccessor(MachineBasicBlock *Old, MachineBasicBlock *New);\n\n  /// Copy a successor (and any probability info) from original block to this\n  /// block's. Uses an iterator into the original blocks successors.\n  ///\n  /// This is useful when doing a partial clone of successors. Afterward, the\n  /// probabilities may need to be normalized.\n  void copySuccessor(MachineBasicBlock *Orig, succ_iterator I);\n\n  /// Split the old successor into old plus new and updates the probability\n  /// info.\n  void splitSuccessor(MachineBasicBlock *Old, MachineBasicBlock *New,\n                      bool NormalizeSuccProbs = false);\n\n  /// Transfers all the successors from MBB to this machine basic block (i.e.,\n  /// copies all the successors FromMBB and remove all the successors from\n  /// FromMBB).\n  void transferSuccessors(MachineBasicBlock *FromMBB);\n\n  /// Transfers all the successors, as in transferSuccessors, and update PHI\n  /// operands in the successor blocks which refer to FromMBB to refer to this.\n  void transferSuccessorsAndUpdatePHIs(MachineBasicBlock *FromMBB);\n\n  /// move all pseudo probes in this block to the end of /c ToMBB To and tag\n  /// them dangling.\n  void moveAndDanglePseudoProbes(MachineBasicBlock *ToMBB);\n\n  /// Return true if any of the successors have probabilities attached to them.\n  bool hasSuccessorProbabilities() const { return !Probs.empty(); }\n\n  /// Return true if the specified MBB is a predecessor of this block.\n  bool isPredecessor(const MachineBasicBlock *MBB) const;\n\n  /// Return true if the specified MBB is a successor of this block.\n  bool isSuccessor(const MachineBasicBlock *MBB) const;\n\n  /// Return true if the specified MBB will be emitted immediately after this\n  /// block, such that if this block exits by falling through, control will\n  /// transfer to the specified MBB. Note that MBB need not be a successor at\n  /// all, for example if this block ends with an unconditional branch to some\n  /// other block.\n  bool isLayoutSuccessor(const MachineBasicBlock *MBB) const;\n\n  /// Return the fallthrough block if the block can implicitly\n  /// transfer control to the block after it by falling off the end of\n  /// it.  This should return null if it can reach the block after\n  /// it, but it uses an explicit branch to do so (e.g., a table\n  /// jump).  Non-null return  is a conservative answer.\n  MachineBasicBlock *getFallThrough();\n\n  /// Return true if the block can implicitly transfer control to the\n  /// block after it by falling off the end of it.  This should return\n  /// false if it can reach the block after it, but it uses an\n  /// explicit branch to do so (e.g., a table jump).  True is a\n  /// conservative answer.\n  bool canFallThrough();\n\n  /// Returns a pointer to the first instruction in this block that is not a\n  /// PHINode instruction. When adding instructions to the beginning of the\n  /// basic block, they should be added before the returned value, not before\n  /// the first instruction, which might be PHI.\n  /// Returns end() is there's no non-PHI instruction.\n  iterator getFirstNonPHI();\n\n  /// Return the first instruction in MBB after I that is not a PHI or a label.\n  /// This is the correct point to insert lowered copies at the beginning of a\n  /// basic block that must be before any debugging information.\n  iterator SkipPHIsAndLabels(iterator I);\n\n  /// Return the first instruction in MBB after I that is not a PHI, label or\n  /// debug.  This is the correct point to insert copies at the beginning of a\n  /// basic block.\n  iterator SkipPHIsLabelsAndDebug(iterator I);\n\n  /// Returns an iterator to the first terminator instruction of this basic\n  /// block. If a terminator does not exist, it returns end().\n  iterator getFirstTerminator();\n  const_iterator getFirstTerminator() const {\n    return const_cast<MachineBasicBlock *>(this)->getFirstTerminator();\n  }\n\n  /// Same getFirstTerminator but it ignores bundles and return an\n  /// instr_iterator instead.\n  instr_iterator getFirstInstrTerminator();\n\n  /// Returns an iterator to the first non-debug instruction in the basic block,\n  /// or end(). Skip any pseudo probe operation if \\c SkipPseudoOp is true.\n  /// Pseudo probes are like debug instructions which do not turn into real\n  /// machine code. We try to use the function to skip both debug instructions\n  /// and pseudo probe operations to avoid API proliferation. This should work\n  /// most of the time when considering optimizing the rest of code in the\n  /// block, except for certain cases where pseudo probes are designed to block\n  /// the optimizations. For example, code merge like optimizations are supposed\n  /// to be blocked by pseudo probes for better AutoFDO profile quality.\n  /// Therefore, they should be considered as a valid instruction when this\n  /// function is called in a context of such optimizations. On the other hand,\n  /// \\c SkipPseudoOp should be true when it's used in optimizations that\n  /// unlikely hurt profile quality, e.g., without block merging.\n  /// TODO: flip the default value of \\c SkipPseudoOp to maximize code quality\n  /// with pseudo probes.\n  iterator getFirstNonDebugInstr(bool SkipPseudoOp = false);\n  const_iterator getFirstNonDebugInstr(bool SkipPseudoOp = false) const {\n    return const_cast<MachineBasicBlock *>(this)->getFirstNonDebugInstr(\n        SkipPseudoOp);\n  }\n\n  /// Returns an iterator to the last non-debug instruction in the basic block,\n  /// or end(). Skip any pseudo operation if \\c SkipPseudoOp is true.\n  /// Pseudo probes are like debug instructions which do not turn into real\n  /// machine code. We try to use the function to skip both debug instructions\n  /// and pseudo probe operations to avoid API proliferation. This should work\n  /// most of the time when considering optimizing the rest of code in the\n  /// block, except for certain cases where pseudo probes are designed to block\n  /// the optimizations. For example, code merge like optimizations are supposed\n  /// to be blocked by pseudo probes for better AutoFDO profile quality.\n  /// Therefore, they should be considered as a valid instruction when this\n  /// function is called in a context of such optimizations. On the other hand,\n  /// \\c SkipPseudoOp should be true when it's used in optimizations that\n  /// unlikely hurt profile quality, e.g., without block merging.\n  iterator getLastNonDebugInstr(bool SkipPseudoOp = false);\n  const_iterator getLastNonDebugInstr(bool SkipPseudoOp = false) const {\n    return const_cast<MachineBasicBlock *>(this)->getLastNonDebugInstr(\n        SkipPseudoOp);\n  }\n\n  /// Convenience function that returns true if the block ends in a return\n  /// instruction.\n  bool isReturnBlock() const {\n    return !empty() && back().isReturn();\n  }\n\n  /// Convenience function that returns true if the bock ends in a EH scope\n  /// return instruction.\n  bool isEHScopeReturnBlock() const {\n    return !empty() && back().isEHScopeReturn();\n  }\n\n  /// Split a basic block into 2 pieces at \\p SplitPoint. A new block will be\n  /// inserted after this block, and all instructions after \\p SplitInst moved\n  /// to it (\\p SplitInst will be in the original block). If \\p LIS is provided,\n  /// LiveIntervals will be appropriately updated. \\return the newly inserted\n  /// block.\n  ///\n  /// If \\p UpdateLiveIns is true, this will ensure the live ins list is\n  /// accurate, including for physreg uses/defs in the original block.\n  MachineBasicBlock *splitAt(MachineInstr &SplitInst, bool UpdateLiveIns = true,\n                             LiveIntervals *LIS = nullptr);\n\n  /// Split the critical edge from this block to the given successor block, and\n  /// return the newly created block, or null if splitting is not possible.\n  ///\n  /// This function updates LiveVariables, MachineDominatorTree, and\n  /// MachineLoopInfo, as applicable.\n  MachineBasicBlock *\n  SplitCriticalEdge(MachineBasicBlock *Succ, Pass &P,\n                    std::vector<SparseBitVector<>> *LiveInSets = nullptr);\n\n  /// Check if the edge between this block and the given successor \\p\n  /// Succ, can be split. If this returns true a subsequent call to\n  /// SplitCriticalEdge is guaranteed to return a valid basic block if\n  /// no changes occurred in the meantime.\n  bool canSplitCriticalEdge(const MachineBasicBlock *Succ) const;\n\n  void pop_front() { Insts.pop_front(); }\n  void pop_back() { Insts.pop_back(); }\n  void push_back(MachineInstr *MI) { Insts.push_back(MI); }\n\n  /// Insert MI into the instruction list before I, possibly inside a bundle.\n  ///\n  /// If the insertion point is inside a bundle, MI will be added to the bundle,\n  /// otherwise MI will not be added to any bundle. That means this function\n  /// alone can't be used to prepend or append instructions to bundles. See\n  /// MIBundleBuilder::insert() for a more reliable way of doing that.\n  instr_iterator insert(instr_iterator I, MachineInstr *M);\n\n  /// Insert a range of instructions into the instruction list before I.\n  template<typename IT>\n  void insert(iterator I, IT S, IT E) {\n    assert((I == end() || I->getParent() == this) &&\n           \"iterator points outside of basic block\");\n    Insts.insert(I.getInstrIterator(), S, E);\n  }\n\n  /// Insert MI into the instruction list before I.\n  iterator insert(iterator I, MachineInstr *MI) {\n    assert((I == end() || I->getParent() == this) &&\n           \"iterator points outside of basic block\");\n    assert(!MI->isBundledWithPred() && !MI->isBundledWithSucc() &&\n           \"Cannot insert instruction with bundle flags\");\n    return Insts.insert(I.getInstrIterator(), MI);\n  }\n\n  /// Insert MI into the instruction list after I.\n  iterator insertAfter(iterator I, MachineInstr *MI) {\n    assert((I == end() || I->getParent() == this) &&\n           \"iterator points outside of basic block\");\n    assert(!MI->isBundledWithPred() && !MI->isBundledWithSucc() &&\n           \"Cannot insert instruction with bundle flags\");\n    return Insts.insertAfter(I.getInstrIterator(), MI);\n  }\n\n  /// If I is bundled then insert MI into the instruction list after the end of\n  /// the bundle, otherwise insert MI immediately after I.\n  instr_iterator insertAfterBundle(instr_iterator I, MachineInstr *MI) {\n    assert((I == instr_end() || I->getParent() == this) &&\n           \"iterator points outside of basic block\");\n    assert(!MI->isBundledWithPred() && !MI->isBundledWithSucc() &&\n           \"Cannot insert instruction with bundle flags\");\n    while (I->isBundledWithSucc())\n      ++I;\n    return Insts.insertAfter(I, MI);\n  }\n\n  /// Remove an instruction from the instruction list and delete it.\n  ///\n  /// If the instruction is part of a bundle, the other instructions in the\n  /// bundle will still be bundled after removing the single instruction.\n  instr_iterator erase(instr_iterator I);\n\n  /// Remove an instruction from the instruction list and delete it.\n  ///\n  /// If the instruction is part of a bundle, the other instructions in the\n  /// bundle will still be bundled after removing the single instruction.\n  instr_iterator erase_instr(MachineInstr *I) {\n    return erase(instr_iterator(I));\n  }\n\n  /// Remove a range of instructions from the instruction list and delete them.\n  iterator erase(iterator I, iterator E) {\n    return Insts.erase(I.getInstrIterator(), E.getInstrIterator());\n  }\n\n  /// Remove an instruction or bundle from the instruction list and delete it.\n  ///\n  /// If I points to a bundle of instructions, they are all erased.\n  iterator erase(iterator I) {\n    return erase(I, std::next(I));\n  }\n\n  /// Remove an instruction from the instruction list and delete it.\n  ///\n  /// If I is the head of a bundle of instructions, the whole bundle will be\n  /// erased.\n  iterator erase(MachineInstr *I) {\n    return erase(iterator(I));\n  }\n\n  /// Remove the unbundled instruction from the instruction list without\n  /// deleting it.\n  ///\n  /// This function can not be used to remove bundled instructions, use\n  /// remove_instr to remove individual instructions from a bundle.\n  MachineInstr *remove(MachineInstr *I) {\n    assert(!I->isBundled() && \"Cannot remove bundled instructions\");\n    return Insts.remove(instr_iterator(I));\n  }\n\n  /// Remove the possibly bundled instruction from the instruction list\n  /// without deleting it.\n  ///\n  /// If the instruction is part of a bundle, the other instructions in the\n  /// bundle will still be bundled after removing the single instruction.\n  MachineInstr *remove_instr(MachineInstr *I);\n\n  void clear() {\n    Insts.clear();\n  }\n\n  /// Take an instruction from MBB 'Other' at the position From, and insert it\n  /// into this MBB right before 'Where'.\n  ///\n  /// If From points to a bundle of instructions, the whole bundle is moved.\n  void splice(iterator Where, MachineBasicBlock *Other, iterator From) {\n    // The range splice() doesn't allow noop moves, but this one does.\n    if (Where != From)\n      splice(Where, Other, From, std::next(From));\n  }\n\n  /// Take a block of instructions from MBB 'Other' in the range [From, To),\n  /// and insert them into this MBB right before 'Where'.\n  ///\n  /// The instruction at 'Where' must not be included in the range of\n  /// instructions to move.\n  void splice(iterator Where, MachineBasicBlock *Other,\n              iterator From, iterator To) {\n    Insts.splice(Where.getInstrIterator(), Other->Insts,\n                 From.getInstrIterator(), To.getInstrIterator());\n  }\n\n  /// This method unlinks 'this' from the containing function, and returns it,\n  /// but does not delete it.\n  MachineBasicBlock *removeFromParent();\n\n  /// This method unlinks 'this' from the containing function and deletes it.\n  void eraseFromParent();\n\n  /// Given a machine basic block that branched to 'Old', change the code and\n  /// CFG so that it branches to 'New' instead.\n  void ReplaceUsesOfBlockWith(MachineBasicBlock *Old, MachineBasicBlock *New);\n\n  /// Update all phi nodes in this basic block to refer to basic block \\p New\n  /// instead of basic block \\p Old.\n  void replacePhiUsesWith(MachineBasicBlock *Old, MachineBasicBlock *New);\n\n  /// Find the next valid DebugLoc starting at MBBI, skipping any DBG_VALUE\n  /// and DBG_LABEL instructions.  Return UnknownLoc if there is none.\n  DebugLoc findDebugLoc(instr_iterator MBBI);\n  DebugLoc findDebugLoc(iterator MBBI) {\n    return findDebugLoc(MBBI.getInstrIterator());\n  }\n\n  /// Has exact same behavior as @ref findDebugLoc (it also\n  /// searches from the first to the last MI of this MBB) except\n  /// that this takes reverse iterator.\n  DebugLoc rfindDebugLoc(reverse_instr_iterator MBBI);\n  DebugLoc rfindDebugLoc(reverse_iterator MBBI) {\n    return rfindDebugLoc(MBBI.getInstrIterator());\n  }\n\n  /// Find the previous valid DebugLoc preceding MBBI, skipping and DBG_VALUE\n  /// instructions.  Return UnknownLoc if there is none.\n  DebugLoc findPrevDebugLoc(instr_iterator MBBI);\n  DebugLoc findPrevDebugLoc(iterator MBBI) {\n    return findPrevDebugLoc(MBBI.getInstrIterator());\n  }\n\n  /// Has exact same behavior as @ref findPrevDebugLoc (it also\n  /// searches from the last to the first MI of this MBB) except\n  /// that this takes reverse iterator.\n  DebugLoc rfindPrevDebugLoc(reverse_instr_iterator MBBI);\n  DebugLoc rfindPrevDebugLoc(reverse_iterator MBBI) {\n    return rfindPrevDebugLoc(MBBI.getInstrIterator());\n  }\n\n  /// Find and return the merged DebugLoc of the branch instructions of the\n  /// block. Return UnknownLoc if there is none.\n  DebugLoc findBranchDebugLoc();\n\n  /// Possible outcome of a register liveness query to computeRegisterLiveness()\n  enum LivenessQueryResult {\n    LQR_Live,   ///< Register is known to be (at least partially) live.\n    LQR_Dead,   ///< Register is known to be fully dead.\n    LQR_Unknown ///< Register liveness not decidable from local neighborhood.\n  };\n\n  /// Return whether (physical) register \\p Reg has been defined and not\n  /// killed as of just before \\p Before.\n  ///\n  /// Search is localised to a neighborhood of \\p Neighborhood instructions\n  /// before (searching for defs or kills) and \\p Neighborhood instructions\n  /// after (searching just for defs) \\p Before.\n  ///\n  /// \\p Reg must be a physical register.\n  LivenessQueryResult computeRegisterLiveness(const TargetRegisterInfo *TRI,\n                                              MCRegister Reg,\n                                              const_iterator Before,\n                                              unsigned Neighborhood = 10) const;\n\n  // Debugging methods.\n  void dump() const;\n  void print(raw_ostream &OS, const SlotIndexes * = nullptr,\n             bool IsStandalone = true) const;\n  void print(raw_ostream &OS, ModuleSlotTracker &MST,\n             const SlotIndexes * = nullptr, bool IsStandalone = true) const;\n\n  enum PrintNameFlag {\n    PrintNameIr = (1 << 0), ///< Add IR name where available\n    PrintNameAttributes = (1 << 1), ///< Print attributes\n  };\n\n  void printName(raw_ostream &os, unsigned printNameFlags = PrintNameIr,\n                 ModuleSlotTracker *moduleSlotTracker = nullptr) const;\n\n  // Printing method used by LoopInfo.\n  void printAsOperand(raw_ostream &OS, bool PrintType = true) const;\n\n  /// MachineBasicBlocks are uniquely numbered at the function level, unless\n  /// they're not in a MachineFunction yet, in which case this will return -1.\n  int getNumber() const { return Number; }\n  void setNumber(int N) { Number = N; }\n\n  /// Return the MCSymbol for this basic block.\n  MCSymbol *getSymbol() const;\n\n  /// Return the EHCatchret Symbol for this basic block.\n  MCSymbol *getEHCatchretSymbol() const;\n\n  Optional<uint64_t> getIrrLoopHeaderWeight() const {\n    return IrrLoopHeaderWeight;\n  }\n\n  void setIrrLoopHeaderWeight(uint64_t Weight) {\n    IrrLoopHeaderWeight = Weight;\n  }\n\nprivate:\n  /// Return probability iterator corresponding to the I successor iterator.\n  probability_iterator getProbabilityIterator(succ_iterator I);\n  const_probability_iterator\n  getProbabilityIterator(const_succ_iterator I) const;\n\n  friend class MachineBranchProbabilityInfo;\n  friend class MIPrinter;\n\n  /// Return probability of the edge from this block to MBB. This method should\n  /// NOT be called directly, but by using getEdgeProbability method from\n  /// MachineBranchProbabilityInfo class.\n  BranchProbability getSuccProbability(const_succ_iterator Succ) const;\n\n  // Methods used to maintain doubly linked list of blocks...\n  friend struct ilist_callback_traits<MachineBasicBlock>;\n\n  // Machine-CFG mutators\n\n  /// Add Pred as a predecessor of this MachineBasicBlock. Don't do this\n  /// unless you know what you're doing, because it doesn't update Pred's\n  /// successors list. Use Pred->addSuccessor instead.\n  void addPredecessor(MachineBasicBlock *Pred);\n\n  /// Remove Pred as a predecessor of this MachineBasicBlock. Don't do this\n  /// unless you know what you're doing, because it doesn't update Pred's\n  /// successors list. Use Pred->removeSuccessor instead.\n  void removePredecessor(MachineBasicBlock *Pred);\n};\n\nraw_ostream& operator<<(raw_ostream &OS, const MachineBasicBlock &MBB);\n\n/// Prints a machine basic block reference.\n///\n/// The format is:\n///   %bb.5           - a machine basic block with MBB.getNumber() == 5.\n///\n/// Usage: OS << printMBBReference(MBB) << '\\n';\nPrintable printMBBReference(const MachineBasicBlock &MBB);\n\n// This is useful when building IndexedMaps keyed on basic block pointers.\nstruct MBB2NumberFunctor {\n  using argument_type = const MachineBasicBlock *;\n  unsigned operator()(const MachineBasicBlock *MBB) const {\n    return MBB->getNumber();\n  }\n};\n\n//===--------------------------------------------------------------------===//\n// GraphTraits specializations for machine basic block graphs (machine-CFGs)\n//===--------------------------------------------------------------------===//\n\n// Provide specializations of GraphTraits to be able to treat a\n// MachineFunction as a graph of MachineBasicBlocks.\n//\n\ntemplate <> struct GraphTraits<MachineBasicBlock *> {\n  using NodeRef = MachineBasicBlock *;\n  using ChildIteratorType = MachineBasicBlock::succ_iterator;\n\n  static NodeRef getEntryNode(MachineBasicBlock *BB) { return BB; }\n  static ChildIteratorType child_begin(NodeRef N) { return N->succ_begin(); }\n  static ChildIteratorType child_end(NodeRef N) { return N->succ_end(); }\n};\n\ntemplate <> struct GraphTraits<const MachineBasicBlock *> {\n  using NodeRef = const MachineBasicBlock *;\n  using ChildIteratorType = MachineBasicBlock::const_succ_iterator;\n\n  static NodeRef getEntryNode(const MachineBasicBlock *BB) { return BB; }\n  static ChildIteratorType child_begin(NodeRef N) { return N->succ_begin(); }\n  static ChildIteratorType child_end(NodeRef N) { return N->succ_end(); }\n};\n\n// Provide specializations of GraphTraits to be able to treat a\n// MachineFunction as a graph of MachineBasicBlocks and to walk it\n// in inverse order.  Inverse order for a function is considered\n// to be when traversing the predecessor edges of a MBB\n// instead of the successor edges.\n//\ntemplate <> struct GraphTraits<Inverse<MachineBasicBlock*>> {\n  using NodeRef = MachineBasicBlock *;\n  using ChildIteratorType = MachineBasicBlock::pred_iterator;\n\n  static NodeRef getEntryNode(Inverse<MachineBasicBlock *> G) {\n    return G.Graph;\n  }\n\n  static ChildIteratorType child_begin(NodeRef N) { return N->pred_begin(); }\n  static ChildIteratorType child_end(NodeRef N) { return N->pred_end(); }\n};\n\ntemplate <> struct GraphTraits<Inverse<const MachineBasicBlock*>> {\n  using NodeRef = const MachineBasicBlock *;\n  using ChildIteratorType = MachineBasicBlock::const_pred_iterator;\n\n  static NodeRef getEntryNode(Inverse<const MachineBasicBlock *> G) {\n    return G.Graph;\n  }\n\n  static ChildIteratorType child_begin(NodeRef N) { return N->pred_begin(); }\n  static ChildIteratorType child_end(NodeRef N) { return N->pred_end(); }\n};\n\n/// MachineInstrSpan provides an interface to get an iteration range\n/// containing the instruction it was initialized with, along with all\n/// those instructions inserted prior to or following that instruction\n/// at some point after the MachineInstrSpan is constructed.\nclass MachineInstrSpan {\n  MachineBasicBlock &MBB;\n  MachineBasicBlock::iterator I, B, E;\n\npublic:\n  MachineInstrSpan(MachineBasicBlock::iterator I, MachineBasicBlock *BB)\n      : MBB(*BB), I(I), B(I == MBB.begin() ? MBB.end() : std::prev(I)),\n        E(std::next(I)) {\n    assert(I == BB->end() || I->getParent() == BB);\n  }\n\n  MachineBasicBlock::iterator begin() {\n    return B == MBB.end() ? MBB.begin() : std::next(B);\n  }\n  MachineBasicBlock::iterator end() { return E; }\n  bool empty() { return begin() == end(); }\n\n  MachineBasicBlock::iterator getInitial() { return I; }\n};\n\n/// Increment \\p It until it points to a non-debug instruction or to \\p End\n/// and return the resulting iterator. This function should only be used\n/// MachineBasicBlock::{iterator, const_iterator, instr_iterator,\n/// const_instr_iterator} and the respective reverse iterators.\ntemplate <typename IterT>\ninline IterT skipDebugInstructionsForward(IterT It, IterT End,\n                                          bool SkipPseudoOp = false) {\n  while (It != End &&\n         (It->isDebugInstr() || (SkipPseudoOp && It->isPseudoProbe())))\n    ++It;\n  return It;\n}\n\n/// Decrement \\p It until it points to a non-debug instruction or to \\p Begin\n/// and return the resulting iterator. This function should only be used\n/// MachineBasicBlock::{iterator, const_iterator, instr_iterator,\n/// const_instr_iterator} and the respective reverse iterators.\ntemplate <class IterT>\ninline IterT skipDebugInstructionsBackward(IterT It, IterT Begin,\n                                           bool SkipPseudoOp = false) {\n  while (It != Begin &&\n         (It->isDebugInstr() || (SkipPseudoOp && It->isPseudoProbe())))\n    --It;\n  return It;\n}\n\n/// Increment \\p It, then continue incrementing it while it points to a debug\n/// instruction. A replacement for std::next.\ntemplate <typename IterT>\ninline IterT next_nodbg(IterT It, IterT End, bool SkipPseudoOp = false) {\n  return skipDebugInstructionsForward(std::next(It), End, SkipPseudoOp);\n}\n\n/// Decrement \\p It, then continue decrementing it while it points to a debug\n/// instruction. A replacement for std::prev.\ntemplate <typename IterT>\ninline IterT prev_nodbg(IterT It, IterT Begin, bool SkipPseudoOp = false) {\n  return skipDebugInstructionsBackward(std::prev(It), Begin, SkipPseudoOp);\n}\n\n/// Construct a range iterator which begins at \\p It and moves forwards until\n/// \\p End is reached, skipping any debug instructions.\ntemplate <typename IterT>\ninline auto instructionsWithoutDebug(IterT It, IterT End,\n                                     bool SkipPseudoOp = false) {\n  return make_filter_range(make_range(It, End), [=](const MachineInstr &MI) {\n    return !MI.isDebugInstr() && !(SkipPseudoOp && MI.isPseudoProbe());\n  });\n}\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_MACHINEBASICBLOCK_H\n"}, "31": {"id": 31, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "content": "//===- llvm/CodeGen/MachineInstrBundleIterator.h ----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Defines an iterator class that bundles MachineInstr.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_MACHINEINSTRBUNDLEITERATOR_H\n#define LLVM_CODEGEN_MACHINEINSTRBUNDLEITERATOR_H\n\n#include \"llvm/ADT/ilist.h\"\n#include \"llvm/ADT/simple_ilist.h\"\n#include <cassert>\n#include <iterator>\n#include <type_traits>\n\nnamespace llvm {\n\ntemplate <class T, bool IsReverse> struct MachineInstrBundleIteratorTraits;\ntemplate <class T> struct MachineInstrBundleIteratorTraits<T, false> {\n  using list_type = simple_ilist<T, ilist_sentinel_tracking<true>>;\n  using instr_iterator = typename list_type::iterator;\n  using nonconst_instr_iterator = typename list_type::iterator;\n  using const_instr_iterator = typename list_type::const_iterator;\n};\ntemplate <class T> struct MachineInstrBundleIteratorTraits<T, true> {\n  using list_type = simple_ilist<T, ilist_sentinel_tracking<true>>;\n  using instr_iterator = typename list_type::reverse_iterator;\n  using nonconst_instr_iterator = typename list_type::reverse_iterator;\n  using const_instr_iterator = typename list_type::const_reverse_iterator;\n};\ntemplate <class T> struct MachineInstrBundleIteratorTraits<const T, false> {\n  using list_type = simple_ilist<T, ilist_sentinel_tracking<true>>;\n  using instr_iterator = typename list_type::const_iterator;\n  using nonconst_instr_iterator = typename list_type::iterator;\n  using const_instr_iterator = typename list_type::const_iterator;\n};\ntemplate <class T> struct MachineInstrBundleIteratorTraits<const T, true> {\n  using list_type = simple_ilist<T, ilist_sentinel_tracking<true>>;\n  using instr_iterator = typename list_type::const_reverse_iterator;\n  using nonconst_instr_iterator = typename list_type::reverse_iterator;\n  using const_instr_iterator = typename list_type::const_reverse_iterator;\n};\n\ntemplate <bool IsReverse> struct MachineInstrBundleIteratorHelper;\ntemplate <> struct MachineInstrBundleIteratorHelper<false> {\n  /// Get the beginning of the current bundle.\n  template <class Iterator> static Iterator getBundleBegin(Iterator I) {\n    if (!I.isEnd())\n      while (I->isBundledWithPred())\n        --I;\n    return I;\n  }\n\n  /// Get the final node of the current bundle.\n  template <class Iterator> static Iterator getBundleFinal(Iterator I) {\n    if (!I.isEnd())\n      while (I->isBundledWithSucc())\n        ++I;\n    return I;\n  }\n\n  /// Increment forward ilist iterator.\n  template <class Iterator> static void increment(Iterator &I) {\n    I = std::next(getBundleFinal(I));\n  }\n\n  /// Decrement forward ilist iterator.\n  template <class Iterator> static void decrement(Iterator &I) {\n    I = getBundleBegin(std::prev(I));\n  }\n};\n\ntemplate <> struct MachineInstrBundleIteratorHelper<true> {\n  /// Get the beginning of the current bundle.\n  template <class Iterator> static Iterator getBundleBegin(Iterator I) {\n    return MachineInstrBundleIteratorHelper<false>::getBundleBegin(\n               I.getReverse())\n        .getReverse();\n  }\n\n  /// Get the final node of the current bundle.\n  template <class Iterator> static Iterator getBundleFinal(Iterator I) {\n    return MachineInstrBundleIteratorHelper<false>::getBundleFinal(\n               I.getReverse())\n        .getReverse();\n  }\n\n  /// Increment reverse ilist iterator.\n  template <class Iterator> static void increment(Iterator &I) {\n    I = getBundleBegin(std::next(I));\n  }\n\n  /// Decrement reverse ilist iterator.\n  template <class Iterator> static void decrement(Iterator &I) {\n    I = std::prev(getBundleFinal(I));\n  }\n};\n\n/// MachineBasicBlock iterator that automatically skips over MIs that are\n/// inside bundles (i.e. walk top level MIs only).\ntemplate <typename Ty, bool IsReverse = false>\nclass MachineInstrBundleIterator : MachineInstrBundleIteratorHelper<IsReverse> {\n  using Traits = MachineInstrBundleIteratorTraits<Ty, IsReverse>;\n  using instr_iterator = typename Traits::instr_iterator;\n\n  instr_iterator MII;\n\npublic:\n  using value_type = typename instr_iterator::value_type;\n  using difference_type = typename instr_iterator::difference_type;\n  using pointer = typename instr_iterator::pointer;\n  using reference = typename instr_iterator::reference;\n  using const_pointer = typename instr_iterator::const_pointer;\n  using const_reference = typename instr_iterator::const_reference;\n  using iterator_category = std::bidirectional_iterator_tag;\n\nprivate:\n  using nonconst_instr_iterator = typename Traits::nonconst_instr_iterator;\n  using const_instr_iterator = typename Traits::const_instr_iterator;\n  using nonconst_iterator =\n      MachineInstrBundleIterator<typename nonconst_instr_iterator::value_type,\n                                 IsReverse>;\n  using reverse_iterator = MachineInstrBundleIterator<Ty, !IsReverse>;\n\npublic:\n  MachineInstrBundleIterator(instr_iterator MI) : MII(MI) {\n    assert((!MI.getNodePtr() || MI.isEnd() || !MI->isBundledWithPred()) &&\n           \"It's not legal to initialize MachineInstrBundleIterator with a \"\n           \"bundled MI\");\n  }\n\n  MachineInstrBundleIterator(reference MI) : MII(MI) {\n    assert(!MI.isBundledWithPred() && \"It's not legal to initialize \"\n                                      \"MachineInstrBundleIterator with a \"\n                                      \"bundled MI\");\n  }\n\n  MachineInstrBundleIterator(pointer MI) : MII(MI) {\n    // FIXME: This conversion should be explicit.\n    assert((!MI || !MI->isBundledWithPred()) && \"It's not legal to initialize \"\n                                                \"MachineInstrBundleIterator \"\n                                                \"with a bundled MI\");\n  }\n\n  // Template allows conversion from const to nonconst.\n  template <class OtherTy>\n  MachineInstrBundleIterator(\n      const MachineInstrBundleIterator<OtherTy, IsReverse> &I,\n      std::enable_if_t<std::is_convertible<OtherTy *, Ty *>::value, void *> =\n          nullptr)\n      : MII(I.getInstrIterator()) {}\n\n  MachineInstrBundleIterator() : MII(nullptr) {}\n\n  /// Explicit conversion between forward/reverse iterators.\n  ///\n  /// Translate between forward and reverse iterators without changing range\n  /// boundaries.  The resulting iterator will dereference (and have a handle)\n  /// to the previous node, which is somewhat unexpected; but converting the\n  /// two endpoints in a range will give the same range in reverse.\n  ///\n  /// This matches std::reverse_iterator conversions.\n  explicit MachineInstrBundleIterator(\n      const MachineInstrBundleIterator<Ty, !IsReverse> &I)\n      : MachineInstrBundleIterator(++I.getReverse()) {}\n\n  /// Get the bundle iterator for the given instruction's bundle.\n  static MachineInstrBundleIterator getAtBundleBegin(instr_iterator MI) {\n    return MachineInstrBundleIteratorHelper<IsReverse>::getBundleBegin(MI);\n  }\n\n  reference operator*() const { return *MII; }\n  pointer operator->() const { return &operator*(); }\n\n  /// Check for null.\n  bool isValid() const { return MII.getNodePtr(); }\n\n  friend bool operator==(const MachineInstrBundleIterator &L,\n                         const MachineInstrBundleIterator &R) {\n    return L.MII == R.MII;\n  }\n  friend bool operator==(const MachineInstrBundleIterator &L,\n                         const const_instr_iterator &R) {\n    return L.MII == R; // Avoid assertion about validity of R.\n  }\n  friend bool operator==(const const_instr_iterator &L,\n                         const MachineInstrBundleIterator &R) {\n    return L == R.MII; // Avoid assertion about validity of L.\n  }\n  friend bool operator==(const MachineInstrBundleIterator &L,\n                         const nonconst_instr_iterator &R) {\n    return L.MII == R; // Avoid assertion about validity of R.\n  }\n  friend bool operator==(const nonconst_instr_iterator &L,\n                         const MachineInstrBundleIterator &R) {\n    return L == R.MII; // Avoid assertion about validity of L.\n  }\n  friend bool operator==(const MachineInstrBundleIterator &L, const_pointer R) {\n    return L == const_instr_iterator(R); // Avoid assertion about validity of R.\n  }\n  friend bool operator==(const_pointer L, const MachineInstrBundleIterator &R) {\n    return const_instr_iterator(L) == R; // Avoid assertion about validity of L.\n  }\n  friend bool operator==(const MachineInstrBundleIterator &L,\n                         const_reference R) {\n    return L == &R; // Avoid assertion about validity of R.\n  }\n  friend bool operator==(const_reference L,\n                         const MachineInstrBundleIterator &R) {\n    return &L == R; // Avoid assertion about validity of L.\n  }\n\n  friend bool operator!=(const MachineInstrBundleIterator &L,\n                         const MachineInstrBundleIterator &R) {\n    return !(L == R);\n  }\n  friend bool operator!=(const MachineInstrBundleIterator &L,\n                         const const_instr_iterator &R) {\n    return !(L == R);\n  }\n  friend bool operator!=(const const_instr_iterator &L,\n                         const MachineInstrBundleIterator &R) {\n    return !(L == R);\n  }\n  friend bool operator!=(const MachineInstrBundleIterator &L,\n                         const nonconst_instr_iterator &R) {\n    return !(L == R);\n  }\n  friend bool operator!=(const nonconst_instr_iterator &L,\n                         const MachineInstrBundleIterator &R) {\n    return !(L == R);\n  }\n  friend bool operator!=(const MachineInstrBundleIterator &L, const_pointer R) {\n    return !(L == R);\n  }\n  friend bool operator!=(const_pointer L, const MachineInstrBundleIterator &R) {\n    return !(L == R);\n  }\n  friend bool operator!=(const MachineInstrBundleIterator &L,\n                         const_reference R) {\n    return !(L == R);\n  }\n  friend bool operator!=(const_reference L,\n                         const MachineInstrBundleIterator &R) {\n    return !(L == R);\n  }\n\n  // Increment and decrement operators...\n  MachineInstrBundleIterator &operator--() {\n    this->decrement(MII);\n    return *this;\n  }\n  MachineInstrBundleIterator &operator++() {\n    this->increment(MII);\n    return *this;\n  }\n  MachineInstrBundleIterator operator--(int) {\n    MachineInstrBundleIterator Temp = *this;\n    --*this;\n    return Temp;\n  }\n  MachineInstrBundleIterator operator++(int) {\n    MachineInstrBundleIterator Temp = *this;\n    ++*this;\n    return Temp;\n  }\n\n  instr_iterator getInstrIterator() const { return MII; }\n\n  nonconst_iterator getNonConstIterator() const { return MII.getNonConst(); }\n\n  /// Get a reverse iterator to the same node.\n  ///\n  /// Gives a reverse iterator that will dereference (and have a handle) to the\n  /// same node.  Converting the endpoint iterators in a range will give a\n  /// different range; for range operations, use the explicit conversions.\n  reverse_iterator getReverse() const { return MII.getReverse(); }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_MACHINEINSTRBUNDLEITERATOR_H\n"}, "32": {"id": 32, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h", "content": "//==- llvm/CodeGen/MachineMemOperand.h - MachineMemOperand class -*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains the declaration of the MachineMemOperand class, which is a\n// description of a memory reference. It is used to help track dependencies\n// in the backend.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_MACHINEMEMOPERAND_H\n#define LLVM_CODEGEN_MACHINEMEMOPERAND_H\n\n#include \"llvm/ADT/BitmaskEnum.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/CodeGen/PseudoSourceValue.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/Value.h\" // PointerLikeTypeTraits<Value*>\n#include \"llvm/Support/AtomicOrdering.h\"\n#include \"llvm/Support/DataTypes.h\"\n\nnamespace llvm {\n\nclass FoldingSetNodeID;\nclass MDNode;\nclass raw_ostream;\nclass MachineFunction;\nclass ModuleSlotTracker;\n\n/// This class contains a discriminated union of information about pointers in\n/// memory operands, relating them back to LLVM IR or to virtual locations (such\n/// as frame indices) that are exposed during codegen.\nstruct MachinePointerInfo {\n  /// This is the IR pointer value for the access, or it is null if unknown.\n  /// If this is null, then the access is to a pointer in the default address\n  /// space.\n  PointerUnion<const Value *, const PseudoSourceValue *> V;\n\n  /// Offset - This is an offset from the base Value*.\n  int64_t Offset;\n\n  unsigned AddrSpace = 0;\n\n  uint8_t StackID;\n\n  explicit MachinePointerInfo(const Value *v, int64_t offset = 0,\n                              uint8_t ID = 0)\n      : V(v), Offset(offset), StackID(ID) {\n    AddrSpace = v ? v->getType()->getPointerAddressSpace() : 0;\n  }\n\n  explicit MachinePointerInfo(const PseudoSourceValue *v, int64_t offset = 0,\n                              uint8_t ID = 0)\n      : V(v), Offset(offset), StackID(ID) {\n    AddrSpace = v ? v->getAddressSpace() : 0;\n  }\n\n  explicit MachinePointerInfo(unsigned AddressSpace = 0, int64_t offset = 0)\n      : V((const Value *)nullptr), Offset(offset), AddrSpace(AddressSpace),\n        StackID(0) {}\n\n  explicit MachinePointerInfo(\n    PointerUnion<const Value *, const PseudoSourceValue *> v,\n    int64_t offset = 0,\n    uint8_t ID = 0)\n    : V(v), Offset(offset), StackID(ID) {\n    if (V) {\n      if (const auto *ValPtr = V.dyn_cast<const Value*>())\n        AddrSpace = ValPtr->getType()->getPointerAddressSpace();\n      else\n        AddrSpace = V.get<const PseudoSourceValue*>()->getAddressSpace();\n    }\n  }\n\n  MachinePointerInfo getWithOffset(int64_t O) const {\n    if (V.isNull())\n      return MachinePointerInfo(AddrSpace, Offset + O);\n    if (V.is<const Value*>())\n      return MachinePointerInfo(V.get<const Value*>(), Offset + O, StackID);\n    return MachinePointerInfo(V.get<const PseudoSourceValue*>(), Offset + O,\n                              StackID);\n  }\n\n  /// Return true if memory region [V, V+Offset+Size) is known to be\n  /// dereferenceable.\n  bool isDereferenceable(unsigned Size, LLVMContext &C,\n                         const DataLayout &DL) const;\n\n  /// Return the LLVM IR address space number that this pointer points into.\n  unsigned getAddrSpace() const;\n\n  /// Return a MachinePointerInfo record that refers to the constant pool.\n  static MachinePointerInfo getConstantPool(MachineFunction &MF);\n\n  /// Return a MachinePointerInfo record that refers to the specified\n  /// FrameIndex.\n  static MachinePointerInfo getFixedStack(MachineFunction &MF, int FI,\n                                          int64_t Offset = 0);\n\n  /// Return a MachinePointerInfo record that refers to a jump table entry.\n  static MachinePointerInfo getJumpTable(MachineFunction &MF);\n\n  /// Return a MachinePointerInfo record that refers to a GOT entry.\n  static MachinePointerInfo getGOT(MachineFunction &MF);\n\n  /// Stack pointer relative access.\n  static MachinePointerInfo getStack(MachineFunction &MF, int64_t Offset,\n                                     uint8_t ID = 0);\n\n  /// Stack memory without other information.\n  static MachinePointerInfo getUnknownStack(MachineFunction &MF);\n};\n\n\n//===----------------------------------------------------------------------===//\n/// A description of a memory reference used in the backend.\n/// Instead of holding a StoreInst or LoadInst, this class holds the address\n/// Value of the reference along with a byte size and offset. This allows it\n/// to describe lowered loads and stores. Also, the special PseudoSourceValue\n/// objects can be used to represent loads and stores to memory locations\n/// that aren't explicit in the regular LLVM IR.\n///\nclass MachineMemOperand {\npublic:\n  /// Flags values. These may be or'd together.\n  enum Flags : uint16_t {\n    // No flags set.\n    MONone = 0,\n    /// The memory access reads data.\n    MOLoad = 1u << 0,\n    /// The memory access writes data.\n    MOStore = 1u << 1,\n    /// The memory access is volatile.\n    MOVolatile = 1u << 2,\n    /// The memory access is non-temporal.\n    MONonTemporal = 1u << 3,\n    /// The memory access is dereferenceable (i.e., doesn't trap).\n    MODereferenceable = 1u << 4,\n    /// The memory access always returns the same value (or traps).\n    MOInvariant = 1u << 5,\n\n    // Reserved for use by target-specific passes.\n    // Targets may override getSerializableMachineMemOperandTargetFlags() to\n    // enable MIR serialization/parsing of these flags.  If more of these flags\n    // are added, the MIR printing/parsing code will need to be updated as well.\n    MOTargetFlag1 = 1u << 6,\n    MOTargetFlag2 = 1u << 7,\n    MOTargetFlag3 = 1u << 8,\n\n    LLVM_MARK_AS_BITMASK_ENUM(/* LargestFlag = */ MOTargetFlag3)\n  };\n\nprivate:\n  /// Atomic information for this memory operation.\n  struct MachineAtomicInfo {\n    /// Synchronization scope ID for this memory operation.\n    unsigned SSID : 8;            // SyncScope::ID\n    /// Atomic ordering requirements for this memory operation. For cmpxchg\n    /// atomic operations, atomic ordering requirements when store occurs.\n    unsigned Ordering : 4;        // enum AtomicOrdering\n    /// For cmpxchg atomic operations, atomic ordering requirements when store\n    /// does not occur.\n    unsigned FailureOrdering : 4; // enum AtomicOrdering\n  };\n\n  MachinePointerInfo PtrInfo;\n  uint64_t Size;\n  Flags FlagVals;\n  Align BaseAlign;\n  MachineAtomicInfo AtomicInfo;\n  AAMDNodes AAInfo;\n  const MDNode *Ranges;\n\npublic:\n  /// Construct a MachineMemOperand object with the specified PtrInfo, flags,\n  /// size, and base alignment. For atomic operations the synchronization scope\n  /// and atomic ordering requirements must also be specified. For cmpxchg\n  /// atomic operations the atomic ordering requirements when store does not\n  /// occur must also be specified.\n  MachineMemOperand(MachinePointerInfo PtrInfo, Flags flags, uint64_t s,\n                    Align a, const AAMDNodes &AAInfo = AAMDNodes(),\n                    const MDNode *Ranges = nullptr,\n                    SyncScope::ID SSID = SyncScope::System,\n                    AtomicOrdering Ordering = AtomicOrdering::NotAtomic,\n                    AtomicOrdering FailureOrdering = AtomicOrdering::NotAtomic);\n\n  const MachinePointerInfo &getPointerInfo() const { return PtrInfo; }\n\n  /// Return the base address of the memory access. This may either be a normal\n  /// LLVM IR Value, or one of the special values used in CodeGen.\n  /// Special values are those obtained via\n  /// PseudoSourceValue::getFixedStack(int), PseudoSourceValue::getStack, and\n  /// other PseudoSourceValue member functions which return objects which stand\n  /// for frame/stack pointer relative references and other special references\n  /// which are not representable in the high-level IR.\n  const Value *getValue() const { return PtrInfo.V.dyn_cast<const Value*>(); }\n\n  const PseudoSourceValue *getPseudoValue() const {\n    return PtrInfo.V.dyn_cast<const PseudoSourceValue*>();\n  }\n\n  const void *getOpaqueValue() const { return PtrInfo.V.getOpaqueValue(); }\n\n  /// Return the raw flags of the source value, \\see Flags.\n  Flags getFlags() const { return FlagVals; }\n\n  /// Bitwise OR the current flags with the given flags.\n  void setFlags(Flags f) { FlagVals |= f; }\n\n  /// For normal values, this is a byte offset added to the base address.\n  /// For PseudoSourceValue::FPRel values, this is the FrameIndex number.\n  int64_t getOffset() const { return PtrInfo.Offset; }\n\n  unsigned getAddrSpace() const { return PtrInfo.getAddrSpace(); }\n\n  /// Return the size in bytes of the memory reference.\n  uint64_t getSize() const { return Size; }\n\n  /// Return the size in bits of the memory reference.\n  uint64_t getSizeInBits() const { return Size * 8; }\n\n  LLVM_ATTRIBUTE_DEPRECATED(uint64_t getAlignment() const,\n                            \"Use getAlign instead\");\n\n  /// Return the minimum known alignment in bytes of the actual memory\n  /// reference.\n  Align getAlign() const;\n\n  LLVM_ATTRIBUTE_DEPRECATED(uint64_t getBaseAlignment() const,\n                            \"Use getBaseAlign instead\") {\n    return BaseAlign.value();\n  }\n\n  /// Return the minimum known alignment in bytes of the base address, without\n  /// the offset.\n  Align getBaseAlign() const { return BaseAlign; }\n\n  /// Return the AA tags for the memory reference.\n  AAMDNodes getAAInfo() const { return AAInfo; }\n\n  /// Return the range tag for the memory reference.\n  const MDNode *getRanges() const { return Ranges; }\n\n  /// Returns the synchronization scope ID for this memory operation.\n  SyncScope::ID getSyncScopeID() const {\n    return static_cast<SyncScope::ID>(AtomicInfo.SSID);\n  }\n\n  /// Return the atomic ordering requirements for this memory operation. For\n  /// cmpxchg atomic operations, return the atomic ordering requirements when\n  /// store occurs.\n  AtomicOrdering getOrdering() const {\n    return static_cast<AtomicOrdering>(AtomicInfo.Ordering);\n  }\n\n  /// For cmpxchg atomic operations, return the atomic ordering requirements\n  /// when store does not occur.\n  AtomicOrdering getFailureOrdering() const {\n    return static_cast<AtomicOrdering>(AtomicInfo.FailureOrdering);\n  }\n\n  bool isLoad() const { return FlagVals & MOLoad; }\n  bool isStore() const { return FlagVals & MOStore; }\n  bool isVolatile() const { return FlagVals & MOVolatile; }\n  bool isNonTemporal() const { return FlagVals & MONonTemporal; }\n  bool isDereferenceable() const { return FlagVals & MODereferenceable; }\n  bool isInvariant() const { return FlagVals & MOInvariant; }\n\n  /// Returns true if this operation has an atomic ordering requirement of\n  /// unordered or higher, false otherwise.\n  bool isAtomic() const { return getOrdering() != AtomicOrdering::NotAtomic; }\n\n  /// Returns true if this memory operation doesn't have any ordering\n  /// constraints other than normal aliasing. Volatile and (ordered) atomic\n  /// memory operations can't be reordered. \n  bool isUnordered() const {\n    return (getOrdering() == AtomicOrdering::NotAtomic ||\n            getOrdering() == AtomicOrdering::Unordered) &&\n           !isVolatile();\n  }\n\n  /// Update this MachineMemOperand to reflect the alignment of MMO, if it has a\n  /// greater alignment. This must only be used when the new alignment applies\n  /// to all users of this MachineMemOperand.\n  void refineAlignment(const MachineMemOperand *MMO);\n\n  /// Change the SourceValue for this MachineMemOperand. This should only be\n  /// used when an object is being relocated and all references to it are being\n  /// updated.\n  void setValue(const Value *NewSV) { PtrInfo.V = NewSV; }\n  void setValue(const PseudoSourceValue *NewSV) { PtrInfo.V = NewSV; }\n  void setOffset(int64_t NewOffset) { PtrInfo.Offset = NewOffset; }\n\n  /// Profile - Gather unique data for the object.\n  ///\n  void Profile(FoldingSetNodeID &ID) const;\n\n  /// Support for operator<<.\n  /// @{\n  void print(raw_ostream &OS, ModuleSlotTracker &MST,\n             SmallVectorImpl<StringRef> &SSNs, const LLVMContext &Context,\n             const MachineFrameInfo *MFI, const TargetInstrInfo *TII) const;\n  /// @}\n\n  friend bool operator==(const MachineMemOperand &LHS,\n                         const MachineMemOperand &RHS) {\n    return LHS.getValue() == RHS.getValue() &&\n           LHS.getPseudoValue() == RHS.getPseudoValue() &&\n           LHS.getSize() == RHS.getSize() &&\n           LHS.getOffset() == RHS.getOffset() &&\n           LHS.getFlags() == RHS.getFlags() &&\n           LHS.getAAInfo() == RHS.getAAInfo() &&\n           LHS.getRanges() == RHS.getRanges() &&\n           LHS.getAlign() == RHS.getAlign() &&\n           LHS.getAddrSpace() == RHS.getAddrSpace();\n  }\n\n  friend bool operator!=(const MachineMemOperand &LHS,\n                         const MachineMemOperand &RHS) {\n    return !(LHS == RHS);\n  }\n};\n\n} // End llvm namespace\n\n#endif\n"}, "33": {"id": 33, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/Register.h", "content": "//===-- llvm/CodeGen/Register.h ---------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_REGISTER_H\n#define LLVM_CODEGEN_REGISTER_H\n\n#include \"llvm/MC/MCRegister.h\"\n#include <cassert>\n\nnamespace llvm {\n\n/// Wrapper class representing virtual and physical registers. Should be passed\n/// by value.\nclass Register {\n  unsigned Reg;\n\npublic:\n  constexpr Register(unsigned Val = 0): Reg(Val) {}\n  constexpr Register(MCRegister Val): Reg(Val) {}\n\n  // Register numbers can represent physical registers, virtual registers, and\n  // sometimes stack slots. The unsigned values are divided into these ranges:\n  //\n  //   0           Not a register, can be used as a sentinel.\n  //   [1;2^30)    Physical registers assigned by TableGen.\n  //   [2^30;2^31) Stack slots. (Rarely used.)\n  //   [2^31;2^32) Virtual registers assigned by MachineRegisterInfo.\n  //\n  // Further sentinels can be allocated from the small negative integers.\n  // DenseMapInfo<unsigned> uses -1u and -2u.\n  static_assert(std::numeric_limits<decltype(Reg)>::max() >= 0xFFFFFFFF,\n                \"Reg isn't large enough to hold full range.\");\n\n  /// isStackSlot - Sometimes it is useful the be able to store a non-negative\n  /// frame index in a variable that normally holds a register. isStackSlot()\n  /// returns true if Reg is in the range used for stack slots.\n  ///\n  /// FIXME: remove in favor of member.\n  static bool isStackSlot(unsigned Reg) {\n    return MCRegister::isStackSlot(Reg);\n  }\n\n  /// Return true if this is a stack slot.\n  bool isStack() const { return MCRegister::isStackSlot(Reg); }\n\n  /// Compute the frame index from a register value representing a stack slot.\n  static int stackSlot2Index(Register Reg) {\n    assert(Reg.isStack() && \"Not a stack slot\");\n    return int(Reg - MCRegister::FirstStackSlot);\n  }\n\n  /// Convert a non-negative frame index to a stack slot register value.\n  static Register index2StackSlot(int FI) {\n    assert(FI >= 0 && \"Cannot hold a negative frame index.\");\n    return Register(FI + MCRegister::FirstStackSlot);\n  }\n\n  /// Return true if the specified register number is in\n  /// the physical register namespace.\n  static bool isPhysicalRegister(unsigned Reg) {\n    return MCRegister::isPhysicalRegister(Reg);\n  }\n\n  /// Return true if the specified register number is in\n  /// the virtual register namespace.\n  static bool isVirtualRegister(unsigned Reg) {\n    return Reg & MCRegister::VirtualRegFlag && !isStackSlot(Reg);\n  }\n\n  /// Convert a virtual register number to a 0-based index.\n  /// The first virtual register in a function will get the index 0.\n  static unsigned virtReg2Index(Register Reg) {\n    assert(isVirtualRegister(Reg) && \"Not a virtual register\");\n    return Reg & ~MCRegister::VirtualRegFlag;\n  }\n\n  /// Convert a 0-based index to a virtual register number.\n  /// This is the inverse operation of VirtReg2IndexFunctor below.\n  static Register index2VirtReg(unsigned Index) {\n    assert(Index < (1u << 31) && \"Index too large for virtual register range.\");\n    return Index | MCRegister::VirtualRegFlag;\n  }\n\n  /// Return true if the specified register number is in the virtual register\n  /// namespace.\n  bool isVirtual() const {\n    return isVirtualRegister(Reg);\n  }\n\n  /// Return true if the specified register number is in the physical register\n  /// namespace.\n  bool isPhysical() const {\n    return isPhysicalRegister(Reg);\n  }\n\n  /// Convert a virtual register number to a 0-based index. The first virtual\n  /// register in a function will get the index 0.\n  unsigned virtRegIndex() const {\n    return virtReg2Index(Reg);\n  }\n\n  constexpr operator unsigned() const {\n    return Reg;\n  }\n\n  unsigned id() const { return Reg; }\n\n  operator MCRegister() const {\n    return MCRegister(Reg);\n  }\n\n  /// Utility to check-convert this value to a MCRegister. The caller is\n  /// expected to have already validated that this Register is, indeed,\n  /// physical.\n  MCRegister asMCReg() const {\n    assert(Reg == MCRegister::NoRegister ||\n           MCRegister::isPhysicalRegister(Reg));\n    return MCRegister(Reg);\n  }\n\n  bool isValid() const { return Reg != MCRegister::NoRegister; }\n\n  /// Comparisons between register objects\n  bool operator==(const Register &Other) const { return Reg == Other.Reg; }\n  bool operator!=(const Register &Other) const { return Reg != Other.Reg; }\n  bool operator==(const MCRegister &Other) const { return Reg == Other.id(); }\n  bool operator!=(const MCRegister &Other) const { return Reg != Other.id(); }\n\n  /// Comparisons against register constants. E.g.\n  /// * R == AArch64::WZR\n  /// * R == 0\n  /// * R == VirtRegMap::NO_PHYS_REG\n  bool operator==(unsigned Other) const { return Reg == Other; }\n  bool operator!=(unsigned Other) const { return Reg != Other; }\n  bool operator==(int Other) const { return Reg == unsigned(Other); }\n  bool operator!=(int Other) const { return Reg != unsigned(Other); }\n  // MSVC requires that we explicitly declare these two as well.\n  bool operator==(MCPhysReg Other) const { return Reg == unsigned(Other); }\n  bool operator!=(MCPhysReg Other) const { return Reg != unsigned(Other); }\n};\n\n// Provide DenseMapInfo for Register\ntemplate<> struct DenseMapInfo<Register> {\n  static inline unsigned getEmptyKey() {\n    return DenseMapInfo<unsigned>::getEmptyKey();\n  }\n  static inline unsigned getTombstoneKey() {\n    return DenseMapInfo<unsigned>::getTombstoneKey();\n  }\n  static unsigned getHashValue(const Register &Val) {\n    return DenseMapInfo<unsigned>::getHashValue(Val.id());\n  }\n  static bool isEqual(const Register &LHS, const Register &RHS) {\n    return DenseMapInfo<unsigned>::isEqual(LHS.id(), RHS.id());\n  }\n};\n\n}\n\n#endif // LLVM_CODEGEN_REGISTER_H\n"}, "34": {"id": 34, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Attributes.h", "content": "//===- llvm/Attributes.h - Container for Attributes -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// This file contains the simple types necessary to represent the\n/// attributes associated with functions and their calls.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_ATTRIBUTES_H\n#define LLVM_IR_ATTRIBUTES_H\n\n#include \"llvm-c/Types.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Config/llvm-config.h\"\n#include \"llvm/Support/Alignment.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include <bitset>\n#include <cassert>\n#include <cstdint>\n#include <map>\n#include <string>\n#include <utility>\n\nnamespace llvm {\n\nclass AttrBuilder;\nclass AttributeImpl;\nclass AttributeListImpl;\nclass AttributeSetNode;\ntemplate<typename T> struct DenseMapInfo;\nclass FoldingSetNodeID;\nclass Function;\nclass LLVMContext;\nclass Type;\n\n//===----------------------------------------------------------------------===//\n/// \\class\n/// Functions, function parameters, and return types can have attributes\n/// to indicate how they should be treated by optimizations and code\n/// generation. This class represents one of those attributes. It's light-weight\n/// and should be passed around by-value.\nclass Attribute {\npublic:\n  /// This enumeration lists the attributes that can be associated with\n  /// parameters, function results, or the function itself.\n  ///\n  /// Note: The `uwtable' attribute is about the ABI or the user mandating an\n  /// entry in the unwind table. The `nounwind' attribute is about an exception\n  /// passing by the function.\n  ///\n  /// In a theoretical system that uses tables for profiling and SjLj for\n  /// exceptions, they would be fully independent. In a normal system that uses\n  /// tables for both, the semantics are:\n  ///\n  /// nil                = Needs an entry because an exception might pass by.\n  /// nounwind           = No need for an entry\n  /// uwtable            = Needs an entry because the ABI says so and because\n  ///                      an exception might pass by.\n  /// uwtable + nounwind = Needs an entry because the ABI says so.\n\n  enum AttrKind {\n    // IR-Level Attributes\n    None,                  ///< No attributes have been set\n    #define GET_ATTR_NAMES\n    #define ATTRIBUTE_ENUM(ENUM_NAME, OTHER) ENUM_NAME,\n    #include \"llvm/IR/Attributes.inc\"\n    EndAttrKinds,          ///< Sentinal value useful for loops\n    EmptyKey,              ///< Use as Empty key for DenseMap of AttrKind\n    TombstoneKey,          ///< Use as Tombstone key for DenseMap of AttrKind\n  };\n\nprivate:\n  AttributeImpl *pImpl = nullptr;\n\n  Attribute(AttributeImpl *A) : pImpl(A) {}\n\npublic:\n  Attribute() = default;\n\n  //===--------------------------------------------------------------------===//\n  // Attribute Construction\n  //===--------------------------------------------------------------------===//\n\n  /// Return a uniquified Attribute object.\n  static Attribute get(LLVMContext &Context, AttrKind Kind, uint64_t Val = 0);\n  static Attribute get(LLVMContext &Context, StringRef Kind,\n                       StringRef Val = StringRef());\n  static Attribute get(LLVMContext &Context, AttrKind Kind, Type *Ty);\n\n  /// Return a uniquified Attribute object that has the specific\n  /// alignment set.\n  static Attribute getWithAlignment(LLVMContext &Context, Align Alignment);\n  static Attribute getWithStackAlignment(LLVMContext &Context, Align Alignment);\n  static Attribute getWithDereferenceableBytes(LLVMContext &Context,\n                                              uint64_t Bytes);\n  static Attribute getWithDereferenceableOrNullBytes(LLVMContext &Context,\n                                                     uint64_t Bytes);\n  static Attribute getWithAllocSizeArgs(LLVMContext &Context,\n                                        unsigned ElemSizeArg,\n                                        const Optional<unsigned> &NumElemsArg);\n  static Attribute getWithByValType(LLVMContext &Context, Type *Ty);\n  static Attribute getWithStructRetType(LLVMContext &Context, Type *Ty);\n  static Attribute getWithByRefType(LLVMContext &Context, Type *Ty);\n  static Attribute getWithPreallocatedType(LLVMContext &Context, Type *Ty);\n\n  /// For a typed attribute, return the equivalent attribute with the type\n  /// changed to \\p ReplacementTy.\n  Attribute getWithNewType(LLVMContext &Context, Type *ReplacementTy) {\n    assert(isTypeAttribute() && \"this requires a typed attribute\");\n    return get(Context, getKindAsEnum(), ReplacementTy);\n  }\n\n  static Attribute::AttrKind getAttrKindFromName(StringRef AttrName);\n\n  static StringRef getNameFromAttrKind(Attribute::AttrKind AttrKind);\n\n  /// Return true if and only if the attribute has an Argument.\n  static bool doesAttrKindHaveArgument(Attribute::AttrKind AttrKind);\n\n  /// Return true if the provided string matches the IR name of an attribute.\n  /// example: \"noalias\" return true but not \"NoAlias\"\n  static bool isExistingAttribute(StringRef Name);\n\n  //===--------------------------------------------------------------------===//\n  // Attribute Accessors\n  //===--------------------------------------------------------------------===//\n\n  /// Return true if the attribute is an Attribute::AttrKind type.\n  bool isEnumAttribute() const;\n\n  /// Return true if the attribute is an integer attribute.\n  bool isIntAttribute() const;\n\n  /// Return true if the attribute is a string (target-dependent)\n  /// attribute.\n  bool isStringAttribute() const;\n\n  /// Return true if the attribute is a type attribute.\n  bool isTypeAttribute() const;\n\n  /// Return true if the attribute is any kind of attribute.\n  bool isValid() const { return pImpl; }\n\n  /// Return true if the attribute is present.\n  bool hasAttribute(AttrKind Val) const;\n\n  /// Return true if the target-dependent attribute is present.\n  bool hasAttribute(StringRef Val) const;\n\n  /// Return the attribute's kind as an enum (Attribute::AttrKind). This\n  /// requires the attribute to be an enum or integer attribute.\n  Attribute::AttrKind getKindAsEnum() const;\n\n  /// Return the attribute's value as an integer. This requires that the\n  /// attribute be an integer attribute.\n  uint64_t getValueAsInt() const;\n\n  /// Return the attribute's kind as a string. This requires the\n  /// attribute to be a string attribute.\n  StringRef getKindAsString() const;\n\n  /// Return the attribute's value as a string. This requires the\n  /// attribute to be a string attribute.\n  StringRef getValueAsString() const;\n\n  /// Return the attribute's value as a Type. This requires the attribute to be\n  /// a type attribute.\n  Type *getValueAsType() const;\n\n  /// Returns the alignment field of an attribute as a byte alignment\n  /// value.\n  MaybeAlign getAlignment() const;\n\n  /// Returns the stack alignment field of an attribute as a byte\n  /// alignment value.\n  MaybeAlign getStackAlignment() const;\n\n  /// Returns the number of dereferenceable bytes from the\n  /// dereferenceable attribute.\n  uint64_t getDereferenceableBytes() const;\n\n  /// Returns the number of dereferenceable_or_null bytes from the\n  /// dereferenceable_or_null attribute.\n  uint64_t getDereferenceableOrNullBytes() const;\n\n  /// Returns the argument numbers for the allocsize attribute (or pair(0, 0)\n  /// if not known).\n  std::pair<unsigned, Optional<unsigned>> getAllocSizeArgs() const;\n\n  /// The Attribute is converted to a string of equivalent mnemonic. This\n  /// is, presumably, for writing out the mnemonics for the assembly writer.\n  std::string getAsString(bool InAttrGrp = false) const;\n\n  /// Equality and non-equality operators.\n  bool operator==(Attribute A) const { return pImpl == A.pImpl; }\n  bool operator!=(Attribute A) const { return pImpl != A.pImpl; }\n\n  /// Less-than operator. Useful for sorting the attributes list.\n  bool operator<(Attribute A) const;\n\n  void Profile(FoldingSetNodeID &ID) const;\n\n  /// Return a raw pointer that uniquely identifies this attribute.\n  void *getRawPointer() const {\n    return pImpl;\n  }\n\n  /// Get an attribute from a raw pointer created by getRawPointer.\n  static Attribute fromRawPointer(void *RawPtr) {\n    return Attribute(reinterpret_cast<AttributeImpl*>(RawPtr));\n  }\n};\n\n// Specialized opaque value conversions.\ninline LLVMAttributeRef wrap(Attribute Attr) {\n  return reinterpret_cast<LLVMAttributeRef>(Attr.getRawPointer());\n}\n\n// Specialized opaque value conversions.\ninline Attribute unwrap(LLVMAttributeRef Attr) {\n  return Attribute::fromRawPointer(Attr);\n}\n\n//===----------------------------------------------------------------------===//\n/// \\class\n/// This class holds the attributes for a particular argument, parameter,\n/// function, or return value. It is an immutable value type that is cheap to\n/// copy. Adding and removing enum attributes is intended to be fast, but adding\n/// and removing string or integer attributes involves a FoldingSet lookup.\nclass AttributeSet {\n  friend AttributeListImpl;\n  template <typename Ty> friend struct DenseMapInfo;\n\n  // TODO: Extract AvailableAttrs from AttributeSetNode and store them here.\n  // This will allow an efficient implementation of addAttribute and\n  // removeAttribute for enum attrs.\n\n  /// Private implementation pointer.\n  AttributeSetNode *SetNode = nullptr;\n\nprivate:\n  explicit AttributeSet(AttributeSetNode *ASN) : SetNode(ASN) {}\n\npublic:\n  /// AttributeSet is a trivially copyable value type.\n  AttributeSet() = default;\n  AttributeSet(const AttributeSet &) = default;\n  ~AttributeSet() = default;\n\n  static AttributeSet get(LLVMContext &C, const AttrBuilder &B);\n  static AttributeSet get(LLVMContext &C, ArrayRef<Attribute> Attrs);\n\n  bool operator==(const AttributeSet &O) const { return SetNode == O.SetNode; }\n  bool operator!=(const AttributeSet &O) const { return !(*this == O); }\n\n  /// Add an argument attribute. Returns a new set because attribute sets are\n  /// immutable.\n  LLVM_NODISCARD AttributeSet addAttribute(LLVMContext &C,\n                                           Attribute::AttrKind Kind) const;\n\n  /// Add a target-dependent attribute. Returns a new set because attribute sets\n  /// are immutable.\n  LLVM_NODISCARD AttributeSet addAttribute(LLVMContext &C, StringRef Kind,\n                                           StringRef Value = StringRef()) const;\n\n  /// Add attributes to the attribute set. Returns a new set because attribute\n  /// sets are immutable.\n  LLVM_NODISCARD AttributeSet addAttributes(LLVMContext &C,\n                                            AttributeSet AS) const;\n\n  /// Remove the specified attribute from this set. Returns a new set because\n  /// attribute sets are immutable.\n  LLVM_NODISCARD AttributeSet removeAttribute(LLVMContext &C,\n                                              Attribute::AttrKind Kind) const;\n\n  /// Remove the specified attribute from this set. Returns a new set because\n  /// attribute sets are immutable.\n  LLVM_NODISCARD AttributeSet removeAttribute(LLVMContext &C,\n                                              StringRef Kind) const;\n\n  /// Remove the specified attributes from this set. Returns a new set because\n  /// attribute sets are immutable.\n  LLVM_NODISCARD AttributeSet\n  removeAttributes(LLVMContext &C, const AttrBuilder &AttrsToRemove) const;\n\n  /// Return the number of attributes in this set.\n  unsigned getNumAttributes() const;\n\n  /// Return true if attributes exists in this set.\n  bool hasAttributes() const { return SetNode != nullptr; }\n\n  /// Return true if the attribute exists in this set.\n  bool hasAttribute(Attribute::AttrKind Kind) const;\n\n  /// Return true if the attribute exists in this set.\n  bool hasAttribute(StringRef Kind) const;\n\n  /// Return the attribute object.\n  Attribute getAttribute(Attribute::AttrKind Kind) const;\n\n  /// Return the target-dependent attribute object.\n  Attribute getAttribute(StringRef Kind) const;\n\n  MaybeAlign getAlignment() const;\n  MaybeAlign getStackAlignment() const;\n  uint64_t getDereferenceableBytes() const;\n  uint64_t getDereferenceableOrNullBytes() const;\n  Type *getByValType() const;\n  Type *getStructRetType() const;\n  Type *getByRefType() const;\n  Type *getPreallocatedType() const;\n  std::pair<unsigned, Optional<unsigned>> getAllocSizeArgs() const;\n  std::string getAsString(bool InAttrGrp = false) const;\n\n  using iterator = const Attribute *;\n\n  iterator begin() const;\n  iterator end() const;\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n  void dump() const;\n#endif\n};\n\n//===----------------------------------------------------------------------===//\n/// \\class\n/// Provide DenseMapInfo for AttributeSet.\ntemplate <> struct DenseMapInfo<AttributeSet> {\n  static AttributeSet getEmptyKey() {\n    auto Val = static_cast<uintptr_t>(-1);\n    Val <<= PointerLikeTypeTraits<void *>::NumLowBitsAvailable;\n    return AttributeSet(reinterpret_cast<AttributeSetNode *>(Val));\n  }\n\n  static AttributeSet getTombstoneKey() {\n    auto Val = static_cast<uintptr_t>(-2);\n    Val <<= PointerLikeTypeTraits<void *>::NumLowBitsAvailable;\n    return AttributeSet(reinterpret_cast<AttributeSetNode *>(Val));\n  }\n\n  static unsigned getHashValue(AttributeSet AS) {\n    return (unsigned((uintptr_t)AS.SetNode) >> 4) ^\n           (unsigned((uintptr_t)AS.SetNode) >> 9);\n  }\n\n  static bool isEqual(AttributeSet LHS, AttributeSet RHS) { return LHS == RHS; }\n};\n\n//===----------------------------------------------------------------------===//\n/// \\class\n/// This class holds the attributes for a function, its return value, and\n/// its parameters. You access the attributes for each of them via an index into\n/// the AttributeList object. The function attributes are at index\n/// `AttributeList::FunctionIndex', the return value is at index\n/// `AttributeList::ReturnIndex', and the attributes for the parameters start at\n/// index `AttributeList::FirstArgIndex'.\nclass AttributeList {\npublic:\n  enum AttrIndex : unsigned {\n    ReturnIndex = 0U,\n    FunctionIndex = ~0U,\n    FirstArgIndex = 1,\n  };\n\nprivate:\n  friend class AttrBuilder;\n  friend class AttributeListImpl;\n  friend class AttributeSet;\n  friend class AttributeSetNode;\n  template <typename Ty> friend struct DenseMapInfo;\n\n  /// The attributes that we are managing. This can be null to represent\n  /// the empty attributes list.\n  AttributeListImpl *pImpl = nullptr;\n\npublic:\n  /// Create an AttributeList with the specified parameters in it.\n  static AttributeList get(LLVMContext &C,\n                           ArrayRef<std::pair<unsigned, Attribute>> Attrs);\n  static AttributeList get(LLVMContext &C,\n                           ArrayRef<std::pair<unsigned, AttributeSet>> Attrs);\n\n  /// Create an AttributeList from attribute sets for a function, its\n  /// return value, and all of its arguments.\n  static AttributeList get(LLVMContext &C, AttributeSet FnAttrs,\n                           AttributeSet RetAttrs,\n                           ArrayRef<AttributeSet> ArgAttrs);\n\nprivate:\n  explicit AttributeList(AttributeListImpl *LI) : pImpl(LI) {}\n\n  static AttributeList getImpl(LLVMContext &C, ArrayRef<AttributeSet> AttrSets);\n\n  AttributeList setAttributes(LLVMContext &C, unsigned Index,\n                              AttributeSet Attrs) const;\n\npublic:\n  AttributeList() = default;\n\n  //===--------------------------------------------------------------------===//\n  // AttributeList Construction and Mutation\n  //===--------------------------------------------------------------------===//\n\n  /// Return an AttributeList with the specified parameters in it.\n  static AttributeList get(LLVMContext &C, ArrayRef<AttributeList> Attrs);\n  static AttributeList get(LLVMContext &C, unsigned Index,\n                           ArrayRef<Attribute::AttrKind> Kinds);\n  static AttributeList get(LLVMContext &C, unsigned Index,\n                           ArrayRef<Attribute::AttrKind> Kinds,\n                           ArrayRef<uint64_t> Values);\n  static AttributeList get(LLVMContext &C, unsigned Index,\n                           ArrayRef<StringRef> Kind);\n  static AttributeList get(LLVMContext &C, unsigned Index,\n                           const AttrBuilder &B);\n\n  /// Add an attribute to the attribute set at the given index.\n  /// Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addAttribute(LLVMContext &C, unsigned Index,\n                                            Attribute::AttrKind Kind) const;\n\n  /// Add an attribute to the attribute set at the given index.\n  /// Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList\n  addAttribute(LLVMContext &C, unsigned Index, StringRef Kind,\n               StringRef Value = StringRef()) const;\n\n  /// Add an attribute to the attribute set at the given index.\n  /// Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addAttribute(LLVMContext &C, unsigned Index,\n                                            Attribute A) const;\n\n  /// Add attributes to the attribute set at the given index.\n  /// Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addAttributes(LLVMContext &C, unsigned Index,\n                                             const AttrBuilder &B) const;\n\n  /// Add an argument attribute to the list. Returns a new list because\n  /// attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addParamAttribute(\n      LLVMContext &C, unsigned ArgNo, Attribute::AttrKind Kind) const {\n    return addAttribute(C, ArgNo + FirstArgIndex, Kind);\n  }\n\n  /// Add an argument attribute to the list. Returns a new list because\n  /// attribute lists are immutable.\n  LLVM_NODISCARD AttributeList\n  addParamAttribute(LLVMContext &C, unsigned ArgNo, StringRef Kind,\n                    StringRef Value = StringRef()) const {\n    return addAttribute(C, ArgNo + FirstArgIndex, Kind, Value);\n  }\n\n  /// Add an attribute to the attribute list at the given arg indices. Returns a\n  /// new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addParamAttribute(LLVMContext &C,\n                                                 ArrayRef<unsigned> ArgNos,\n                                                 Attribute A) const;\n\n  /// Add an argument attribute to the list. Returns a new list because\n  /// attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addParamAttributes(LLVMContext &C,\n                                                  unsigned ArgNo,\n                                                  const AttrBuilder &B) const {\n    return addAttributes(C, ArgNo + FirstArgIndex, B);\n  }\n\n  /// Remove the specified attribute at the specified index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeAttribute(LLVMContext &C, unsigned Index,\n                                               Attribute::AttrKind Kind) const;\n\n  /// Remove the specified attribute at the specified index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeAttribute(LLVMContext &C, unsigned Index,\n                                               StringRef Kind) const;\n\n  /// Remove the specified attributes at the specified index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeAttributes(\n      LLVMContext &C, unsigned Index, const AttrBuilder &AttrsToRemove) const;\n\n  /// Remove all attributes at the specified index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeAttributes(LLVMContext &C,\n                                                unsigned Index) const;\n\n  /// Remove the specified attribute at the specified arg index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeParamAttribute(\n      LLVMContext &C, unsigned ArgNo, Attribute::AttrKind Kind) const {\n    return removeAttribute(C, ArgNo + FirstArgIndex, Kind);\n  }\n\n  /// Remove the specified attribute at the specified arg index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeParamAttribute(LLVMContext &C,\n                                                    unsigned ArgNo,\n                                                    StringRef Kind) const {\n    return removeAttribute(C, ArgNo + FirstArgIndex, Kind);\n  }\n\n  /// Remove the specified attribute at the specified arg index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeParamAttributes(\n      LLVMContext &C, unsigned ArgNo, const AttrBuilder &AttrsToRemove) const {\n    return removeAttributes(C, ArgNo + FirstArgIndex, AttrsToRemove);\n  }\n\n  /// Remove all attributes at the specified arg index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeParamAttributes(LLVMContext &C,\n                                                     unsigned ArgNo) const {\n    return removeAttributes(C, ArgNo + FirstArgIndex);\n  }\n\n  /// Replace the type contained by attribute \\p AttrKind at index \\p ArgNo wih\n  /// \\p ReplacementTy, preserving all other attributes.\n  LLVM_NODISCARD AttributeList replaceAttributeType(LLVMContext &C,\n                                                    unsigned ArgNo,\n                                                    Attribute::AttrKind Kind,\n                                                    Type *ReplacementTy) const {\n    Attribute Attr = getAttribute(ArgNo, Kind);\n    auto Attrs = removeAttribute(C, ArgNo, Kind);\n    return Attrs.addAttribute(C, ArgNo, Attr.getWithNewType(C, ReplacementTy));\n  }\n\n  /// \\brief Add the dereferenceable attribute to the attribute set at the given\n  /// index. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addDereferenceableAttr(LLVMContext &C,\n                                                      unsigned Index,\n                                                      uint64_t Bytes) const;\n\n  /// \\brief Add the dereferenceable attribute to the attribute set at the given\n  /// arg index. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addDereferenceableParamAttr(\n      LLVMContext &C, unsigned ArgNo, uint64_t Bytes) const {\n    return addDereferenceableAttr(C, ArgNo + FirstArgIndex, Bytes);\n  }\n\n  /// Add the dereferenceable_or_null attribute to the attribute set at\n  /// the given index. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addDereferenceableOrNullAttr(\n      LLVMContext &C, unsigned Index, uint64_t Bytes) const;\n\n  /// Add the dereferenceable_or_null attribute to the attribute set at\n  /// the given arg index. Returns a new list because attribute lists are\n  /// immutable.\n  LLVM_NODISCARD AttributeList addDereferenceableOrNullParamAttr(\n      LLVMContext &C, unsigned ArgNo, uint64_t Bytes) const {\n    return addDereferenceableOrNullAttr(C, ArgNo + FirstArgIndex, Bytes);\n  }\n\n  /// Add the allocsize attribute to the attribute set at the given index.\n  /// Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList\n  addAllocSizeAttr(LLVMContext &C, unsigned Index, unsigned ElemSizeArg,\n                   const Optional<unsigned> &NumElemsArg);\n\n  /// Add the allocsize attribute to the attribute set at the given arg index.\n  /// Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList\n  addAllocSizeParamAttr(LLVMContext &C, unsigned ArgNo, unsigned ElemSizeArg,\n                        const Optional<unsigned> &NumElemsArg) {\n    return addAllocSizeAttr(C, ArgNo + FirstArgIndex, ElemSizeArg, NumElemsArg);\n  }\n\n  //===--------------------------------------------------------------------===//\n  // AttributeList Accessors\n  //===--------------------------------------------------------------------===//\n\n  /// The attributes for the specified index are returned.\n  AttributeSet getAttributes(unsigned Index) const;\n\n  /// The attributes for the argument or parameter at the given index are\n  /// returned.\n  AttributeSet getParamAttributes(unsigned ArgNo) const;\n\n  /// The attributes for the ret value are returned.\n  AttributeSet getRetAttributes() const;\n\n  /// The function attributes are returned.\n  AttributeSet getFnAttributes() const;\n\n  /// Return true if the attribute exists at the given index.\n  bool hasAttribute(unsigned Index, Attribute::AttrKind Kind) const;\n\n  /// Return true if the attribute exists at the given index.\n  bool hasAttribute(unsigned Index, StringRef Kind) const;\n\n  /// Return true if attribute exists at the given index.\n  bool hasAttributes(unsigned Index) const;\n\n  /// Return true if the attribute exists for the given argument\n  bool hasParamAttr(unsigned ArgNo, Attribute::AttrKind Kind) const {\n    return hasAttribute(ArgNo + FirstArgIndex, Kind);\n  }\n\n  /// Return true if the attribute exists for the given argument\n  bool hasParamAttr(unsigned ArgNo, StringRef Kind) const {\n    return hasAttribute(ArgNo + FirstArgIndex, Kind);\n  }\n\n  /// Return true if attributes exists for the given argument\n  bool hasParamAttrs(unsigned ArgNo) const {\n    return hasAttributes(ArgNo + FirstArgIndex);\n  }\n\n  /// Equivalent to hasAttribute(AttributeList::FunctionIndex, Kind) but\n  /// may be faster.\n  bool hasFnAttribute(Attribute::AttrKind Kind) const;\n\n  /// Equivalent to hasAttribute(AttributeList::FunctionIndex, Kind) but\n  /// may be faster.\n  bool hasFnAttribute(StringRef Kind) const;\n\n  /// Equivalent to hasAttribute(ArgNo + FirstArgIndex, Kind).\n  bool hasParamAttribute(unsigned ArgNo, Attribute::AttrKind Kind) const;\n\n  /// Return true if the specified attribute is set for at least one\n  /// parameter or for the return value. If Index is not nullptr, the index\n  /// of a parameter with the specified attribute is provided.\n  bool hasAttrSomewhere(Attribute::AttrKind Kind,\n                        unsigned *Index = nullptr) const;\n\n  /// Return the attribute object that exists at the given index.\n  Attribute getAttribute(unsigned Index, Attribute::AttrKind Kind) const;\n\n  /// Return the attribute object that exists at the given index.\n  Attribute getAttribute(unsigned Index, StringRef Kind) const;\n\n  /// Return the attribute object that exists at the arg index.\n  Attribute getParamAttr(unsigned ArgNo, Attribute::AttrKind Kind) const {\n    return getAttribute(ArgNo + FirstArgIndex, Kind);\n  }\n\n  /// Return the attribute object that exists at the given index.\n  Attribute getParamAttr(unsigned ArgNo, StringRef Kind) const {\n    return getAttribute(ArgNo + FirstArgIndex, Kind);\n  }\n\n  /// Return the alignment of the return value.\n  MaybeAlign getRetAlignment() const;\n\n  /// Return the alignment for the specified function parameter.\n  MaybeAlign getParamAlignment(unsigned ArgNo) const;\n\n  /// Return the byval type for the specified function parameter.\n  Type *getParamByValType(unsigned ArgNo) const;\n\n  /// Return the sret type for the specified function parameter.\n  Type *getParamStructRetType(unsigned ArgNo) const;\n\n  /// Return the byref type for the specified function parameter.\n  Type *getParamByRefType(unsigned ArgNo) const;\n\n  /// Return the preallocated type for the specified function parameter.\n  Type *getParamPreallocatedType(unsigned ArgNo) const;\n\n  /// Get the stack alignment.\n  MaybeAlign getStackAlignment(unsigned Index) const;\n\n  /// Get the number of dereferenceable bytes (or zero if unknown).\n  uint64_t getDereferenceableBytes(unsigned Index) const;\n\n  /// Get the number of dereferenceable bytes (or zero if unknown) of an\n  /// arg.\n  uint64_t getParamDereferenceableBytes(unsigned ArgNo) const {\n    return getDereferenceableBytes(ArgNo + FirstArgIndex);\n  }\n\n  /// Get the number of dereferenceable_or_null bytes (or zero if\n  /// unknown).\n  uint64_t getDereferenceableOrNullBytes(unsigned Index) const;\n\n  /// Get the number of dereferenceable_or_null bytes (or zero if\n  /// unknown) of an arg.\n  uint64_t getParamDereferenceableOrNullBytes(unsigned ArgNo) const {\n    return getDereferenceableOrNullBytes(ArgNo + FirstArgIndex);\n  }\n\n  /// Get the allocsize argument numbers (or pair(0, 0) if unknown).\n  std::pair<unsigned, Optional<unsigned>>\n  getAllocSizeArgs(unsigned Index) const;\n\n  /// Return the attributes at the index as a string.\n  std::string getAsString(unsigned Index, bool InAttrGrp = false) const;\n\n  //===--------------------------------------------------------------------===//\n  // AttributeList Introspection\n  //===--------------------------------------------------------------------===//\n\n  using iterator = const AttributeSet *;\n\n  iterator begin() const;\n  iterator end() const;\n\n  unsigned getNumAttrSets() const;\n\n  /// Use these to iterate over the valid attribute indices.\n  unsigned index_begin() const { return AttributeList::FunctionIndex; }\n  unsigned index_end() const { return getNumAttrSets() - 1; }\n\n  /// operator==/!= - Provide equality predicates.\n  bool operator==(const AttributeList &RHS) const { return pImpl == RHS.pImpl; }\n  bool operator!=(const AttributeList &RHS) const { return pImpl != RHS.pImpl; }\n\n  /// Return a raw pointer that uniquely identifies this attribute list.\n  void *getRawPointer() const {\n    return pImpl;\n  }\n\n  /// Return true if there are no attributes.\n  bool isEmpty() const { return pImpl == nullptr; }\n\n  void dump() const;\n};\n\n//===----------------------------------------------------------------------===//\n/// \\class\n/// Provide DenseMapInfo for AttributeList.\ntemplate <> struct DenseMapInfo<AttributeList> {\n  static AttributeList getEmptyKey() {\n    auto Val = static_cast<uintptr_t>(-1);\n    Val <<= PointerLikeTypeTraits<void*>::NumLowBitsAvailable;\n    return AttributeList(reinterpret_cast<AttributeListImpl *>(Val));\n  }\n\n  static AttributeList getTombstoneKey() {\n    auto Val = static_cast<uintptr_t>(-2);\n    Val <<= PointerLikeTypeTraits<void*>::NumLowBitsAvailable;\n    return AttributeList(reinterpret_cast<AttributeListImpl *>(Val));\n  }\n\n  static unsigned getHashValue(AttributeList AS) {\n    return (unsigned((uintptr_t)AS.pImpl) >> 4) ^\n           (unsigned((uintptr_t)AS.pImpl) >> 9);\n  }\n\n  static bool isEqual(AttributeList LHS, AttributeList RHS) {\n    return LHS == RHS;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// \\class\n/// This class is used in conjunction with the Attribute::get method to\n/// create an Attribute object. The object itself is uniquified. The Builder's\n/// value, however, is not. So this can be used as a quick way to test for\n/// equality, presence of attributes, etc.\nclass AttrBuilder {\n  std::bitset<Attribute::EndAttrKinds> Attrs;\n  std::map<SmallString<32>, SmallString<32>, std::less<>> TargetDepAttrs;\n  MaybeAlign Alignment;\n  MaybeAlign StackAlignment;\n  uint64_t DerefBytes = 0;\n  uint64_t DerefOrNullBytes = 0;\n  uint64_t AllocSizeArgs = 0;\n  Type *ByValType = nullptr;\n  Type *StructRetType = nullptr;\n  Type *ByRefType = nullptr;\n  Type *PreallocatedType = nullptr;\n\npublic:\n  AttrBuilder() = default;\n\n  AttrBuilder(const Attribute &A) {\n    addAttribute(A);\n  }\n\n  AttrBuilder(AttributeList AS, unsigned Idx);\n  AttrBuilder(AttributeSet AS);\n\n  void clear();\n\n  /// Add an attribute to the builder.\n  AttrBuilder &addAttribute(Attribute::AttrKind Val) {\n    assert((unsigned)Val < Attribute::EndAttrKinds &&\n           \"Attribute out of range!\");\n    assert(!Attribute::doesAttrKindHaveArgument(Val) &&\n           \"Adding integer attribute without adding a value!\");\n    Attrs[Val] = true;\n    return *this;\n  }\n\n  /// Add the Attribute object to the builder.\n  AttrBuilder &addAttribute(Attribute A);\n\n  /// Add the target-dependent attribute to the builder.\n  AttrBuilder &addAttribute(StringRef A, StringRef V = StringRef());\n\n  /// Remove an attribute from the builder.\n  AttrBuilder &removeAttribute(Attribute::AttrKind Val);\n\n  /// Remove the attributes from the builder.\n  AttrBuilder &removeAttributes(AttributeList A, uint64_t WithoutIndex);\n\n  /// Remove the target-dependent attribute to the builder.\n  AttrBuilder &removeAttribute(StringRef A);\n\n  /// Add the attributes from the builder.\n  AttrBuilder &merge(const AttrBuilder &B);\n\n  /// Remove the attributes from the builder.\n  AttrBuilder &remove(const AttrBuilder &B);\n\n  /// Return true if the builder has any attribute that's in the\n  /// specified builder.\n  bool overlaps(const AttrBuilder &B) const;\n\n  /// Return true if the builder has the specified attribute.\n  bool contains(Attribute::AttrKind A) const {\n    assert((unsigned)A < Attribute::EndAttrKinds && \"Attribute out of range!\");\n    return Attrs[A];\n  }\n\n  /// Return true if the builder has the specified target-dependent\n  /// attribute.\n  bool contains(StringRef A) const;\n\n  /// Return true if the builder has IR-level attributes.\n  bool hasAttributes() const;\n\n  /// Return true if the builder has any attribute that's in the\n  /// specified attribute.\n  bool hasAttributes(AttributeList A, uint64_t Index) const;\n\n  /// Return true if the builder has an alignment attribute.\n  bool hasAlignmentAttr() const;\n\n  /// Retrieve the alignment attribute, if it exists.\n  MaybeAlign getAlignment() const { return Alignment; }\n\n  /// Retrieve the stack alignment attribute, if it exists.\n  MaybeAlign getStackAlignment() const { return StackAlignment; }\n\n  /// Retrieve the number of dereferenceable bytes, if the\n  /// dereferenceable attribute exists (zero is returned otherwise).\n  uint64_t getDereferenceableBytes() const { return DerefBytes; }\n\n  /// Retrieve the number of dereferenceable_or_null bytes, if the\n  /// dereferenceable_or_null attribute exists (zero is returned otherwise).\n  uint64_t getDereferenceableOrNullBytes() const { return DerefOrNullBytes; }\n\n  /// Retrieve the byval type.\n  Type *getByValType() const { return ByValType; }\n\n  /// Retrieve the sret type.\n  Type *getStructRetType() const { return StructRetType; }\n\n  /// Retrieve the byref type.\n  Type *getByRefType() const { return ByRefType; }\n\n  /// Retrieve the preallocated type.\n  Type *getPreallocatedType() const { return PreallocatedType; }\n\n  /// Retrieve the allocsize args, if the allocsize attribute exists.  If it\n  /// doesn't exist, pair(0, 0) is returned.\n  std::pair<unsigned, Optional<unsigned>> getAllocSizeArgs() const;\n\n  /// This turns an alignment into the form used internally in Attribute.\n  /// This call has no effect if Align is not set.\n  AttrBuilder &addAlignmentAttr(MaybeAlign Align);\n\n  /// This turns an int alignment (which must be a power of 2) into the\n  /// form used internally in Attribute.\n  /// This call has no effect if Align is 0.\n  /// Deprecated, use the version using a MaybeAlign.\n  inline AttrBuilder &addAlignmentAttr(unsigned Align) {\n    return addAlignmentAttr(MaybeAlign(Align));\n  }\n\n  /// This turns a stack alignment into the form used internally in Attribute.\n  /// This call has no effect if Align is not set.\n  AttrBuilder &addStackAlignmentAttr(MaybeAlign Align);\n\n  /// This turns an int stack alignment (which must be a power of 2) into\n  /// the form used internally in Attribute.\n  /// This call has no effect if Align is 0.\n  /// Deprecated, use the version using a MaybeAlign.\n  inline AttrBuilder &addStackAlignmentAttr(unsigned Align) {\n    return addStackAlignmentAttr(MaybeAlign(Align));\n  }\n\n  /// This turns the number of dereferenceable bytes into the form used\n  /// internally in Attribute.\n  AttrBuilder &addDereferenceableAttr(uint64_t Bytes);\n\n  /// This turns the number of dereferenceable_or_null bytes into the\n  /// form used internally in Attribute.\n  AttrBuilder &addDereferenceableOrNullAttr(uint64_t Bytes);\n\n  /// This turns one (or two) ints into the form used internally in Attribute.\n  AttrBuilder &addAllocSizeAttr(unsigned ElemSizeArg,\n                                const Optional<unsigned> &NumElemsArg);\n\n  /// This turns a byval type into the form used internally in Attribute.\n  AttrBuilder &addByValAttr(Type *Ty);\n\n  /// This turns a sret type into the form used internally in Attribute.\n  AttrBuilder &addStructRetAttr(Type *Ty);\n\n  /// This turns a byref type into the form used internally in Attribute.\n  AttrBuilder &addByRefAttr(Type *Ty);\n\n  /// This turns a preallocated type into the form used internally in Attribute.\n  AttrBuilder &addPreallocatedAttr(Type *Ty);\n\n  /// Add an allocsize attribute, using the representation returned by\n  /// Attribute.getIntValue().\n  AttrBuilder &addAllocSizeAttrFromRawRepr(uint64_t RawAllocSizeRepr);\n\n  /// Return true if the builder contains no target-independent\n  /// attributes.\n  bool empty() const { return Attrs.none(); }\n\n  // Iterators for target-dependent attributes.\n  using td_type = decltype(TargetDepAttrs)::value_type;\n  using td_iterator = decltype(TargetDepAttrs)::iterator;\n  using td_const_iterator = decltype(TargetDepAttrs)::const_iterator;\n  using td_range = iterator_range<td_iterator>;\n  using td_const_range = iterator_range<td_const_iterator>;\n\n  td_iterator td_begin() { return TargetDepAttrs.begin(); }\n  td_iterator td_end() { return TargetDepAttrs.end(); }\n\n  td_const_iterator td_begin() const { return TargetDepAttrs.begin(); }\n  td_const_iterator td_end() const { return TargetDepAttrs.end(); }\n\n  td_range td_attrs() { return td_range(td_begin(), td_end()); }\n\n  td_const_range td_attrs() const {\n    return td_const_range(td_begin(), td_end());\n  }\n\n  bool td_empty() const { return TargetDepAttrs.empty(); }\n\n  bool operator==(const AttrBuilder &B) const;\n  bool operator!=(const AttrBuilder &B) const { return !(*this == B); }\n};\n\nnamespace AttributeFuncs {\n\n/// Which attributes cannot be applied to a type.\nAttrBuilder typeIncompatible(Type *Ty);\n\n/// \\returns Return true if the two functions have compatible target-independent\n/// attributes for inlining purposes.\nbool areInlineCompatible(const Function &Caller, const Function &Callee);\n\n\n/// Checks  if there are any incompatible function attributes between\n/// \\p A and \\p B.\n///\n/// \\param [in] A - The first function to be compared with.\n/// \\param [in] B - The second function to be compared with.\n/// \\returns true if the functions have compatible attributes.\nbool areOutlineCompatible(const Function &A, const Function &B);\n\n/// Merge caller's and callee's attributes.\nvoid mergeAttributesForInlining(Function &Caller, const Function &Callee);\n\n/// Merges the functions attributes from \\p ToMerge into function \\p Base.\n///\n/// \\param [in,out] Base - The function being merged into.\n/// \\param [in] ToMerge - The function to merge attributes from.\nvoid mergeAttributesForOutlining(Function &Base, const Function &ToMerge);\n\n} // end namespace AttributeFuncs\n\n} // end namespace llvm\n\n#endif // LLVM_IR_ATTRIBUTES_H\n"}, "35": {"id": 35, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/BasicBlock.h", "content": "//===- llvm/BasicBlock.h - Represent a basic block in the VM ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains the declaration of the BasicBlock class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_BASICBLOCK_H\n#define LLVM_IR_BASICBLOCK_H\n\n#include \"llvm-c/Types.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/ADT/ilist.h\"\n#include \"llvm/ADT/ilist_node.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/SymbolTableListTraits.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/Support/CBindingWrapping.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n\nnamespace llvm {\n\nclass AssemblyAnnotationWriter;\nclass CallInst;\nclass Function;\nclass LandingPadInst;\nclass LLVMContext;\nclass Module;\nclass PHINode;\nclass ValueSymbolTable;\n\n/// LLVM Basic Block Representation\n///\n/// This represents a single basic block in LLVM. A basic block is simply a\n/// container of instructions that execute sequentially. Basic blocks are Values\n/// because they are referenced by instructions such as branches and switch\n/// tables. The type of a BasicBlock is \"Type::LabelTy\" because the basic block\n/// represents a label to which a branch can jump.\n///\n/// A well formed basic block is formed of a list of non-terminating\n/// instructions followed by a single terminator instruction. Terminator\n/// instructions may not occur in the middle of basic blocks, and must terminate\n/// the blocks. The BasicBlock class allows malformed basic blocks to occur\n/// because it may be useful in the intermediate stage of constructing or\n/// modifying a program. However, the verifier will ensure that basic blocks are\n/// \"well formed\".\nclass BasicBlock final : public Value, // Basic blocks are data objects also\n                         public ilist_node_with_parent<BasicBlock, Function> {\npublic:\n  using InstListType = SymbolTableList<Instruction>;\n\nprivate:\n  friend class BlockAddress;\n  friend class SymbolTableListTraits<BasicBlock>;\n\n  InstListType InstList;\n  Function *Parent;\n\n  void setParent(Function *parent);\n\n  /// Constructor.\n  ///\n  /// If the function parameter is specified, the basic block is automatically\n  /// inserted at either the end of the function (if InsertBefore is null), or\n  /// before the specified basic block.\n  explicit BasicBlock(LLVMContext &C, const Twine &Name = \"\",\n                      Function *Parent = nullptr,\n                      BasicBlock *InsertBefore = nullptr);\n\npublic:\n  BasicBlock(const BasicBlock &) = delete;\n  BasicBlock &operator=(const BasicBlock &) = delete;\n  ~BasicBlock();\n\n  /// Get the context in which this basic block lives.\n  LLVMContext &getContext() const;\n\n  /// Instruction iterators...\n  using iterator = InstListType::iterator;\n  using const_iterator = InstListType::const_iterator;\n  using reverse_iterator = InstListType::reverse_iterator;\n  using const_reverse_iterator = InstListType::const_reverse_iterator;\n\n  /// Creates a new BasicBlock.\n  ///\n  /// If the Parent parameter is specified, the basic block is automatically\n  /// inserted at either the end of the function (if InsertBefore is 0), or\n  /// before the specified basic block.\n  static BasicBlock *Create(LLVMContext &Context, const Twine &Name = \"\",\n                            Function *Parent = nullptr,\n                            BasicBlock *InsertBefore = nullptr) {\n    return new BasicBlock(Context, Name, Parent, InsertBefore);\n  }\n\n  /// Return the enclosing method, or null if none.\n  const Function *getParent() const { return Parent; }\n        Function *getParent()       { return Parent; }\n\n  /// Return the module owning the function this basic block belongs to, or\n  /// nullptr if the function does not have a module.\n  ///\n  /// Note: this is undefined behavior if the block does not have a parent.\n  const Module *getModule() const;\n  Module *getModule() {\n    return const_cast<Module *>(\n                            static_cast<const BasicBlock *>(this)->getModule());\n  }\n\n  /// Returns the terminator instruction if the block is well formed or null\n  /// if the block is not well formed.\n  const Instruction *getTerminator() const LLVM_READONLY;\n  Instruction *getTerminator() {\n    return const_cast<Instruction *>(\n        static_cast<const BasicBlock *>(this)->getTerminator());\n  }\n\n  /// Returns the call instruction calling \\@llvm.experimental.deoptimize\n  /// prior to the terminating return instruction of this basic block, if such\n  /// a call is present.  Otherwise, returns null.\n  const CallInst *getTerminatingDeoptimizeCall() const;\n  CallInst *getTerminatingDeoptimizeCall() {\n    return const_cast<CallInst *>(\n         static_cast<const BasicBlock *>(this)->getTerminatingDeoptimizeCall());\n  }\n\n  /// Returns the call instruction calling \\@llvm.experimental.deoptimize\n  /// that is present either in current basic block or in block that is a unique\n  /// successor to current block, if such call is present. Otherwise, returns null.\n  const CallInst *getPostdominatingDeoptimizeCall() const;\n  CallInst *getPostdominatingDeoptimizeCall() {\n    return const_cast<CallInst *>(\n         static_cast<const BasicBlock *>(this)->getPostdominatingDeoptimizeCall());\n  }\n\n  /// Returns the call instruction marked 'musttail' prior to the terminating\n  /// return instruction of this basic block, if such a call is present.\n  /// Otherwise, returns null.\n  const CallInst *getTerminatingMustTailCall() const;\n  CallInst *getTerminatingMustTailCall() {\n    return const_cast<CallInst *>(\n           static_cast<const BasicBlock *>(this)->getTerminatingMustTailCall());\n  }\n\n  /// Returns a pointer to the first instruction in this block that is not a\n  /// PHINode instruction.\n  ///\n  /// When adding instructions to the beginning of the basic block, they should\n  /// be added before the returned value, not before the first instruction,\n  /// which might be PHI. Returns 0 is there's no non-PHI instruction.\n  const Instruction* getFirstNonPHI() const;\n  Instruction* getFirstNonPHI() {\n    return const_cast<Instruction *>(\n                       static_cast<const BasicBlock *>(this)->getFirstNonPHI());\n  }\n\n  /// Returns a pointer to the first instruction in this block that is not a\n  /// PHINode or a debug intrinsic, or any pseudo operation if \\c SkipPseudoOp\n  /// is true.\n  const Instruction *getFirstNonPHIOrDbg(bool SkipPseudoOp = false) const;\n  Instruction *getFirstNonPHIOrDbg(bool SkipPseudoOp = false) {\n    return const_cast<Instruction *>(\n        static_cast<const BasicBlock *>(this)->getFirstNonPHIOrDbg(\n            SkipPseudoOp));\n  }\n\n  /// Returns a pointer to the first instruction in this block that is not a\n  /// PHINode, a debug intrinsic, or a lifetime intrinsic, or any pseudo\n  /// operation if \\c SkipPseudoOp is true.\n  const Instruction *\n  getFirstNonPHIOrDbgOrLifetime(bool SkipPseudoOp = false) const;\n  Instruction *getFirstNonPHIOrDbgOrLifetime(bool SkipPseudoOp = false) {\n    return const_cast<Instruction *>(\n        static_cast<const BasicBlock *>(this)->getFirstNonPHIOrDbgOrLifetime(\n            SkipPseudoOp));\n  }\n\n  /// Returns an iterator to the first instruction in this block that is\n  /// suitable for inserting a non-PHI instruction.\n  ///\n  /// In particular, it skips all PHIs and LandingPad instructions.\n  const_iterator getFirstInsertionPt() const;\n  iterator getFirstInsertionPt() {\n    return static_cast<const BasicBlock *>(this)\n                                          ->getFirstInsertionPt().getNonConst();\n  }\n\n  /// Return a const iterator range over the instructions in the block, skipping\n  /// any debug instructions. Skip any pseudo operations as well if \\c\n  /// SkipPseudoOp is true.\n  iterator_range<filter_iterator<BasicBlock::const_iterator,\n                                 std::function<bool(const Instruction &)>>>\n  instructionsWithoutDebug(bool SkipPseudoOp = false) const;\n\n  /// Return an iterator range over the instructions in the block, skipping any\n  /// debug instructions. Skip and any pseudo operations as well if \\c\n  /// SkipPseudoOp is true.\n  iterator_range<\n      filter_iterator<BasicBlock::iterator, std::function<bool(Instruction &)>>>\n  instructionsWithoutDebug(bool SkipPseudoOp = false);\n\n  /// Return the size of the basic block ignoring debug instructions\n  filter_iterator<BasicBlock::const_iterator,\n                  std::function<bool(const Instruction &)>>::difference_type\n  sizeWithoutDebug() const;\n\n  /// Unlink 'this' from the containing function, but do not delete it.\n  void removeFromParent();\n\n  /// Unlink 'this' from the containing function and delete it.\n  ///\n  // \\returns an iterator pointing to the element after the erased one.\n  SymbolTableList<BasicBlock>::iterator eraseFromParent();\n\n  /// Unlink this basic block from its current function and insert it into\n  /// the function that \\p MovePos lives in, right before \\p MovePos.\n  void moveBefore(BasicBlock *MovePos);\n\n  /// Unlink this basic block from its current function and insert it\n  /// right after \\p MovePos in the function \\p MovePos lives in.\n  void moveAfter(BasicBlock *MovePos);\n\n  /// Insert unlinked basic block into a function.\n  ///\n  /// Inserts an unlinked basic block into \\c Parent.  If \\c InsertBefore is\n  /// provided, inserts before that basic block, otherwise inserts at the end.\n  ///\n  /// \\pre \\a getParent() is \\c nullptr.\n  void insertInto(Function *Parent, BasicBlock *InsertBefore = nullptr);\n\n  /// Return the predecessor of this block if it has a single predecessor\n  /// block. Otherwise return a null pointer.\n  const BasicBlock *getSinglePredecessor() const;\n  BasicBlock *getSinglePredecessor() {\n    return const_cast<BasicBlock *>(\n                 static_cast<const BasicBlock *>(this)->getSinglePredecessor());\n  }\n\n  /// Return the predecessor of this block if it has a unique predecessor\n  /// block. Otherwise return a null pointer.\n  ///\n  /// Note that unique predecessor doesn't mean single edge, there can be\n  /// multiple edges from the unique predecessor to this block (for example a\n  /// switch statement with multiple cases having the same destination).\n  const BasicBlock *getUniquePredecessor() const;\n  BasicBlock *getUniquePredecessor() {\n    return const_cast<BasicBlock *>(\n                 static_cast<const BasicBlock *>(this)->getUniquePredecessor());\n  }\n\n  /// Return true if this block has exactly N predecessors.\n  bool hasNPredecessors(unsigned N) const;\n\n  /// Return true if this block has N predecessors or more.\n  bool hasNPredecessorsOrMore(unsigned N) const;\n\n  /// Return the successor of this block if it has a single successor.\n  /// Otherwise return a null pointer.\n  ///\n  /// This method is analogous to getSinglePredecessor above.\n  const BasicBlock *getSingleSuccessor() const;\n  BasicBlock *getSingleSuccessor() {\n    return const_cast<BasicBlock *>(\n                   static_cast<const BasicBlock *>(this)->getSingleSuccessor());\n  }\n\n  /// Return the successor of this block if it has a unique successor.\n  /// Otherwise return a null pointer.\n  ///\n  /// This method is analogous to getUniquePredecessor above.\n  const BasicBlock *getUniqueSuccessor() const;\n  BasicBlock *getUniqueSuccessor() {\n    return const_cast<BasicBlock *>(\n                   static_cast<const BasicBlock *>(this)->getUniqueSuccessor());\n  }\n\n  /// Print the basic block to an output stream with an optional\n  /// AssemblyAnnotationWriter.\n  void print(raw_ostream &OS, AssemblyAnnotationWriter *AAW = nullptr,\n             bool ShouldPreserveUseListOrder = false,\n             bool IsForDebug = false) const;\n\n  //===--------------------------------------------------------------------===//\n  /// Instruction iterator methods\n  ///\n  inline iterator                begin()       { return InstList.begin(); }\n  inline const_iterator          begin() const { return InstList.begin(); }\n  inline iterator                end  ()       { return InstList.end();   }\n  inline const_iterator          end  () const { return InstList.end();   }\n\n  inline reverse_iterator        rbegin()       { return InstList.rbegin(); }\n  inline const_reverse_iterator  rbegin() const { return InstList.rbegin(); }\n  inline reverse_iterator        rend  ()       { return InstList.rend();   }\n  inline const_reverse_iterator  rend  () const { return InstList.rend();   }\n\n  inline size_t                   size() const { return InstList.size();  }\n  inline bool                    empty() const { return InstList.empty(); }\n  inline const Instruction      &front() const { return InstList.front(); }\n  inline       Instruction      &front()       { return InstList.front(); }\n  inline const Instruction       &back() const { return InstList.back();  }\n  inline       Instruction       &back()       { return InstList.back();  }\n\n  /// Iterator to walk just the phi nodes in the basic block.\n  template <typename PHINodeT = PHINode, typename BBIteratorT = iterator>\n  class phi_iterator_impl\n      : public iterator_facade_base<phi_iterator_impl<PHINodeT, BBIteratorT>,\n                                    std::forward_iterator_tag, PHINodeT> {\n    friend BasicBlock;\n\n    PHINodeT *PN;\n\n    phi_iterator_impl(PHINodeT *PN) : PN(PN) {}\n\n  public:\n    // Allow default construction to build variables, but this doesn't build\n    // a useful iterator.\n    phi_iterator_impl() = default;\n\n    // Allow conversion between instantiations where valid.\n    template <typename PHINodeU, typename BBIteratorU,\n              typename = std::enable_if_t<\n                  std::is_convertible<PHINodeU *, PHINodeT *>::value>>\n    phi_iterator_impl(const phi_iterator_impl<PHINodeU, BBIteratorU> &Arg)\n        : PN(Arg.PN) {}\n\n    bool operator==(const phi_iterator_impl &Arg) const { return PN == Arg.PN; }\n\n    PHINodeT &operator*() const { return *PN; }\n\n    using phi_iterator_impl::iterator_facade_base::operator++;\n    phi_iterator_impl &operator++() {\n      assert(PN && \"Cannot increment the end iterator!\");\n      PN = dyn_cast<PHINodeT>(std::next(BBIteratorT(PN)));\n      return *this;\n    }\n  };\n  using phi_iterator = phi_iterator_impl<>;\n  using const_phi_iterator =\n      phi_iterator_impl<const PHINode, BasicBlock::const_iterator>;\n\n  /// Returns a range that iterates over the phis in the basic block.\n  ///\n  /// Note that this cannot be used with basic blocks that have no terminator.\n  iterator_range<const_phi_iterator> phis() const {\n    return const_cast<BasicBlock *>(this)->phis();\n  }\n  iterator_range<phi_iterator> phis();\n\n  /// Return the underlying instruction list container.\n  ///\n  /// Currently you need to access the underlying instruction list container\n  /// directly if you want to modify it.\n  const InstListType &getInstList() const { return InstList; }\n        InstListType &getInstList()       { return InstList; }\n\n  /// Returns a pointer to a member of the instruction list.\n  static InstListType BasicBlock::*getSublistAccess(Instruction*) {\n    return &BasicBlock::InstList;\n  }\n\n  /// Returns a pointer to the symbol table if one exists.\n  ValueSymbolTable *getValueSymbolTable();\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast.\n  static bool classof(const Value *V) {\n    return V->getValueID() == Value::BasicBlockVal;\n  }\n\n  /// Cause all subinstructions to \"let go\" of all the references that said\n  /// subinstructions are maintaining.\n  ///\n  /// This allows one to 'delete' a whole class at a time, even though there may\n  /// be circular references... first all references are dropped, and all use\n  /// counts go to zero.  Then everything is delete'd for real.  Note that no\n  /// operations are valid on an object that has \"dropped all references\",\n  /// except operator delete.\n  void dropAllReferences();\n\n  /// Update PHI nodes in this BasicBlock before removal of predecessor \\p Pred.\n  /// Note that this function does not actually remove the predecessor.\n  ///\n  /// If \\p KeepOneInputPHIs is true then don't remove PHIs that are left with\n  /// zero or one incoming values, and don't simplify PHIs with all incoming\n  /// values the same.\n  void removePredecessor(BasicBlock *Pred, bool KeepOneInputPHIs = false);\n\n  bool canSplitPredecessors() const;\n\n  /// Split the basic block into two basic blocks at the specified instruction.\n  ///\n  /// If \\p Before is true, splitBasicBlockBefore handles the\n  /// block splitting. Otherwise, execution proceeds as described below.\n  ///\n  /// Note that all instructions BEFORE the specified iterator\n  /// stay as part of the original basic block, an unconditional branch is added\n  /// to the original BB, and the rest of the instructions in the BB are moved\n  /// to the new BB, including the old terminator.  The newly formed basic block\n  /// is returned. This function invalidates the specified iterator.\n  ///\n  /// Note that this only works on well formed basic blocks (must have a\n  /// terminator), and \\p 'I' must not be the end of instruction list (which\n  /// would cause a degenerate basic block to be formed, having a terminator\n  /// inside of the basic block).\n  ///\n  /// Also note that this doesn't preserve any passes. To split blocks while\n  /// keeping loop information consistent, use the SplitBlock utility function.\n  BasicBlock *splitBasicBlock(iterator I, const Twine &BBName = \"\",\n                              bool Before = false);\n  BasicBlock *splitBasicBlock(Instruction *I, const Twine &BBName = \"\",\n                              bool Before = false) {\n    return splitBasicBlock(I->getIterator(), BBName, Before);\n  }\n\n  /// Split the basic block into two basic blocks at the specified instruction\n  /// and insert the new basic blocks as the predecessor of the current block.\n  ///\n  /// This function ensures all instructions AFTER and including the specified\n  /// iterator \\p I are part of the original basic block. All Instructions\n  /// BEFORE the iterator \\p I are moved to the new BB and an unconditional\n  /// branch is added to the new BB. The new basic block is returned.\n  ///\n  /// Note that this only works on well formed basic blocks (must have a\n  /// terminator), and \\p 'I' must not be the end of instruction list (which\n  /// would cause a degenerate basic block to be formed, having a terminator\n  /// inside of the basic block).  \\p 'I' cannot be a iterator for a PHINode\n  /// with multiple incoming blocks.\n  ///\n  /// Also note that this doesn't preserve any passes. To split blocks while\n  /// keeping loop information consistent, use the SplitBlockBefore utility\n  /// function.\n  BasicBlock *splitBasicBlockBefore(iterator I, const Twine &BBName = \"\");\n  BasicBlock *splitBasicBlockBefore(Instruction *I, const Twine &BBName = \"\") {\n    return splitBasicBlockBefore(I->getIterator(), BBName);\n  }\n\n  /// Returns true if there are any uses of this basic block other than\n  /// direct branches, switches, etc. to it.\n  bool hasAddressTaken() const {\n    return getBasicBlockBits().BlockAddressRefCount != 0;\n  }\n\n  /// Update all phi nodes in this basic block to refer to basic block \\p New\n  /// instead of basic block \\p Old.\n  void replacePhiUsesWith(BasicBlock *Old, BasicBlock *New);\n\n  /// Update all phi nodes in this basic block's successors to refer to basic\n  /// block \\p New instead of basic block \\p Old.\n  void replaceSuccessorsPhiUsesWith(BasicBlock *Old, BasicBlock *New);\n\n  /// Update all phi nodes in this basic block's successors to refer to basic\n  /// block \\p New instead of to it.\n  void replaceSuccessorsPhiUsesWith(BasicBlock *New);\n\n  /// Return true if this basic block is an exception handling block.\n  bool isEHPad() const { return getFirstNonPHI()->isEHPad(); }\n\n  /// Return true if this basic block is a landing pad.\n  ///\n  /// Being a ``landing pad'' means that the basic block is the destination of\n  /// the 'unwind' edge of an invoke instruction.\n  bool isLandingPad() const;\n\n  /// Return the landingpad instruction associated with the landing pad.\n  const LandingPadInst *getLandingPadInst() const;\n  LandingPadInst *getLandingPadInst() {\n    return const_cast<LandingPadInst *>(\n                    static_cast<const BasicBlock *>(this)->getLandingPadInst());\n  }\n\n  /// Return true if it is legal to hoist instructions into this block.\n  bool isLegalToHoistInto() const;\n\n  Optional<uint64_t> getIrrLoopHeaderWeight() const;\n\n  /// Returns true if the Order field of child Instructions is valid.\n  bool isInstrOrderValid() const {\n    return getBasicBlockBits().InstrOrderValid;\n  }\n\n  /// Mark instruction ordering invalid. Done on every instruction insert.\n  void invalidateOrders() {\n    validateInstrOrdering();\n    BasicBlockBits Bits = getBasicBlockBits();\n    Bits.InstrOrderValid = false;\n    setBasicBlockBits(Bits);\n  }\n\n  /// Renumber instructions and mark the ordering as valid.\n  void renumberInstructions();\n\n  /// Asserts that instruction order numbers are marked invalid, or that they\n  /// are in ascending order. This is constant time if the ordering is invalid,\n  /// and linear in the number of instructions if the ordering is valid. Callers\n  /// should be careful not to call this in ways that make common operations\n  /// O(n^2). For example, it takes O(n) time to assign order numbers to\n  /// instructions, so the order should be validated no more than once after\n  /// each ordering to ensure that transforms have the same algorithmic\n  /// complexity when asserts are enabled as when they are disabled.\n  void validateInstrOrdering() const;\n\nprivate:\n#if defined(_AIX) && (!defined(__GNUC__) || defined(__ibmxl__))\n// Except for GCC; by default, AIX compilers store bit-fields in 4-byte words\n// and give the `pack` pragma push semantics.\n#define BEGIN_TWO_BYTE_PACK() _Pragma(\"pack(2)\")\n#define END_TWO_BYTE_PACK() _Pragma(\"pack(pop)\")\n#else\n#define BEGIN_TWO_BYTE_PACK()\n#define END_TWO_BYTE_PACK()\n#endif\n\n  BEGIN_TWO_BYTE_PACK()\n  /// Bitfield to help interpret the bits in Value::SubclassData.\n  struct BasicBlockBits {\n    unsigned short BlockAddressRefCount : 15;\n    unsigned short InstrOrderValid : 1;\n  };\n  END_TWO_BYTE_PACK()\n\n#undef BEGIN_TWO_BYTE_PACK\n#undef END_TWO_BYTE_PACK\n\n  /// Safely reinterpret the subclass data bits to a more useful form.\n  BasicBlockBits getBasicBlockBits() const {\n    static_assert(sizeof(BasicBlockBits) == sizeof(unsigned short),\n                  \"too many bits for Value::SubclassData\");\n    unsigned short ValueData = getSubclassDataFromValue();\n    BasicBlockBits AsBits;\n    memcpy(&AsBits, &ValueData, sizeof(AsBits));\n    return AsBits;\n  }\n\n  /// Reinterpret our subclass bits and store them back into Value.\n  void setBasicBlockBits(BasicBlockBits AsBits) {\n    unsigned short D;\n    memcpy(&D, &AsBits, sizeof(D));\n    Value::setValueSubclassData(D);\n  }\n\n  /// Increment the internal refcount of the number of BlockAddresses\n  /// referencing this BasicBlock by \\p Amt.\n  ///\n  /// This is almost always 0, sometimes one possibly, but almost never 2, and\n  /// inconceivably 3 or more.\n  void AdjustBlockAddressRefCount(int Amt) {\n    BasicBlockBits Bits = getBasicBlockBits();\n    Bits.BlockAddressRefCount += Amt;\n    setBasicBlockBits(Bits);\n    assert(Bits.BlockAddressRefCount < 255 && \"Refcount wrap-around\");\n  }\n\n  /// Shadow Value::setValueSubclassData with a private forwarding method so\n  /// that any future subclasses cannot accidentally use it.\n  void setValueSubclassData(unsigned short D) {\n    Value::setValueSubclassData(D);\n  }\n};\n\n// Create wrappers for C Binding types (see CBindingWrapping.h).\nDEFINE_SIMPLE_CONVERSION_FUNCTIONS(BasicBlock, LLVMBasicBlockRef)\n\n/// Advance \\p It while it points to a debug instruction and return the result.\n/// This assumes that \\p It is not at the end of a block.\nBasicBlock::iterator skipDebugIntrinsics(BasicBlock::iterator It);\n\n#ifdef NDEBUG\n/// In release builds, this is a no-op. For !NDEBUG builds, the checks are\n/// implemented in the .cpp file to avoid circular header deps.\ninline void BasicBlock::validateInstrOrdering() const {}\n#endif\n\n} // end namespace llvm\n\n#endif // LLVM_IR_BASICBLOCK_H\n"}, "36": {"id": 36, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DataLayout.h", "content": "//===- llvm/DataLayout.h - Data size & alignment info -----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines layout properties related to datatype size/offset/alignment\n// information.  It uses lazy annotations to cache information about how\n// structure types are laid out and used.\n//\n// This structure should be created once, filled in if the defaults are not\n// correct and then passed around by const&.  None of the members functions\n// require modification to the object.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_DATALAYOUT_H\n#define LLVM_IR_DATALAYOUT_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/Type.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/Alignment.h\"\n#include \"llvm/Support/TypeSize.h\"\n#include <cassert>\n#include <cstdint>\n#include <string>\n\n// This needs to be outside of the namespace, to avoid conflict with llvm-c\n// decl.\nusing LLVMTargetDataRef = struct LLVMOpaqueTargetData *;\n\nnamespace llvm {\n\nclass GlobalVariable;\nclass LLVMContext;\nclass Module;\nclass StructLayout;\nclass Triple;\nclass Value;\n\n/// Enum used to categorize the alignment types stored by LayoutAlignElem\nenum AlignTypeEnum {\n  INVALID_ALIGN = 0,\n  INTEGER_ALIGN = 'i',\n  VECTOR_ALIGN = 'v',\n  FLOAT_ALIGN = 'f',\n  AGGREGATE_ALIGN = 'a'\n};\n\n// FIXME: Currently the DataLayout string carries a \"preferred alignment\"\n// for types. As the DataLayout is module/global, this should likely be\n// sunk down to an FTTI element that is queried rather than a global\n// preference.\n\n/// Layout alignment element.\n///\n/// Stores the alignment data associated with a given alignment type (integer,\n/// vector, float) and type bit width.\n///\n/// \\note The unusual order of elements in the structure attempts to reduce\n/// padding and make the structure slightly more cache friendly.\nstruct LayoutAlignElem {\n  /// Alignment type from \\c AlignTypeEnum\n  unsigned AlignType : 8;\n  unsigned TypeBitWidth : 24;\n  Align ABIAlign;\n  Align PrefAlign;\n\n  static LayoutAlignElem get(AlignTypeEnum align_type, Align abi_align,\n                             Align pref_align, uint32_t bit_width);\n\n  bool operator==(const LayoutAlignElem &rhs) const;\n};\n\n/// Layout pointer alignment element.\n///\n/// Stores the alignment data associated with a given pointer and address space.\n///\n/// \\note The unusual order of elements in the structure attempts to reduce\n/// padding and make the structure slightly more cache friendly.\nstruct PointerAlignElem {\n  Align ABIAlign;\n  Align PrefAlign;\n  uint32_t TypeByteWidth;\n  uint32_t AddressSpace;\n  uint32_t IndexWidth;\n\n  /// Initializer\n  static PointerAlignElem get(uint32_t AddressSpace, Align ABIAlign,\n                              Align PrefAlign, uint32_t TypeByteWidth,\n                              uint32_t IndexWidth);\n\n  bool operator==(const PointerAlignElem &rhs) const;\n};\n\n/// A parsed version of the target data layout string in and methods for\n/// querying it.\n///\n/// The target data layout string is specified *by the target* - a frontend\n/// generating LLVM IR is required to generate the right target data for the\n/// target being codegen'd to.\nclass DataLayout {\npublic:\n  enum class FunctionPtrAlignType {\n    /// The function pointer alignment is independent of the function alignment.\n    Independent,\n    /// The function pointer alignment is a multiple of the function alignment.\n    MultipleOfFunctionAlign,\n  };\nprivate:\n  /// Defaults to false.\n  bool BigEndian;\n\n  unsigned AllocaAddrSpace;\n  MaybeAlign StackNaturalAlign;\n  unsigned ProgramAddrSpace;\n  unsigned DefaultGlobalsAddrSpace;\n\n  MaybeAlign FunctionPtrAlign;\n  FunctionPtrAlignType TheFunctionPtrAlignType;\n\n  enum ManglingModeT {\n    MM_None,\n    MM_ELF,\n    MM_MachO,\n    MM_WinCOFF,\n    MM_WinCOFFX86,\n    MM_Mips,\n    MM_XCOFF\n  };\n  ManglingModeT ManglingMode;\n\n  SmallVector<unsigned char, 8> LegalIntWidths;\n\n  /// Primitive type alignment data. This is sorted by type and bit\n  /// width during construction.\n  using AlignmentsTy = SmallVector<LayoutAlignElem, 16>;\n  AlignmentsTy Alignments;\n\n  AlignmentsTy::const_iterator\n  findAlignmentLowerBound(AlignTypeEnum AlignType, uint32_t BitWidth) const {\n    return const_cast<DataLayout *>(this)->findAlignmentLowerBound(AlignType,\n                                                                   BitWidth);\n  }\n\n  AlignmentsTy::iterator\n  findAlignmentLowerBound(AlignTypeEnum AlignType, uint32_t BitWidth);\n\n  /// The string representation used to create this DataLayout\n  std::string StringRepresentation;\n\n  using PointersTy = SmallVector<PointerAlignElem, 8>;\n  PointersTy Pointers;\n\n  const PointerAlignElem &getPointerAlignElem(uint32_t AddressSpace) const;\n\n  // The StructType -> StructLayout map.\n  mutable void *LayoutMap = nullptr;\n\n  /// Pointers in these address spaces are non-integral, and don't have a\n  /// well-defined bitwise representation.\n  SmallVector<unsigned, 8> NonIntegralAddressSpaces;\n\n  /// Attempts to set the alignment of the given type. Returns an error\n  /// description on failure.\n  Error setAlignment(AlignTypeEnum align_type, Align abi_align,\n                     Align pref_align, uint32_t bit_width);\n\n  /// Attempts to set the alignment of a pointer in the given address space.\n  /// Returns an error description on failure.\n  Error setPointerAlignment(uint32_t AddrSpace, Align ABIAlign, Align PrefAlign,\n                            uint32_t TypeByteWidth, uint32_t IndexWidth);\n\n  /// Internal helper to get alignment for integer of given bitwidth.\n  Align getIntegerAlignment(uint32_t BitWidth, bool abi_or_pref) const;\n\n  /// Internal helper method that returns requested alignment for type.\n  Align getAlignment(Type *Ty, bool abi_or_pref) const;\n\n  /// Attempts to parse a target data specification string and reports an error\n  /// if the string is malformed.\n  Error parseSpecifier(StringRef Desc);\n\n  // Free all internal data structures.\n  void clear();\n\npublic:\n  /// Constructs a DataLayout from a specification string. See reset().\n  explicit DataLayout(StringRef LayoutDescription) {\n    reset(LayoutDescription);\n  }\n\n  /// Initialize target data from properties stored in the module.\n  explicit DataLayout(const Module *M);\n\n  DataLayout(const DataLayout &DL) { *this = DL; }\n\n  ~DataLayout(); // Not virtual, do not subclass this class\n\n  DataLayout &operator=(const DataLayout &DL) {\n    clear();\n    StringRepresentation = DL.StringRepresentation;\n    BigEndian = DL.isBigEndian();\n    AllocaAddrSpace = DL.AllocaAddrSpace;\n    StackNaturalAlign = DL.StackNaturalAlign;\n    FunctionPtrAlign = DL.FunctionPtrAlign;\n    TheFunctionPtrAlignType = DL.TheFunctionPtrAlignType;\n    ProgramAddrSpace = DL.ProgramAddrSpace;\n    DefaultGlobalsAddrSpace = DL.DefaultGlobalsAddrSpace;\n    ManglingMode = DL.ManglingMode;\n    LegalIntWidths = DL.LegalIntWidths;\n    Alignments = DL.Alignments;\n    Pointers = DL.Pointers;\n    NonIntegralAddressSpaces = DL.NonIntegralAddressSpaces;\n    return *this;\n  }\n\n  bool operator==(const DataLayout &Other) const;\n  bool operator!=(const DataLayout &Other) const { return !(*this == Other); }\n\n  void init(const Module *M);\n\n  /// Parse a data layout string (with fallback to default values).\n  void reset(StringRef LayoutDescription);\n\n  /// Parse a data layout string and return the layout. Return an error\n  /// description on failure.\n  static Expected<DataLayout> parse(StringRef LayoutDescription);\n\n  /// Layout endianness...\n  bool isLittleEndian() const { return !BigEndian; }\n  bool isBigEndian() const { return BigEndian; }\n\n  /// Returns the string representation of the DataLayout.\n  ///\n  /// This representation is in the same format accepted by the string\n  /// constructor above. This should not be used to compare two DataLayout as\n  /// different string can represent the same layout.\n  const std::string &getStringRepresentation() const {\n    return StringRepresentation;\n  }\n\n  /// Test if the DataLayout was constructed from an empty string.\n  bool isDefault() const { return StringRepresentation.empty(); }\n\n  /// Returns true if the specified type is known to be a native integer\n  /// type supported by the CPU.\n  ///\n  /// For example, i64 is not native on most 32-bit CPUs and i37 is not native\n  /// on any known one. This returns false if the integer width is not legal.\n  ///\n  /// The width is specified in bits.\n  bool isLegalInteger(uint64_t Width) const {\n    return llvm::is_contained(LegalIntWidths, Width);\n  }\n\n  bool isIllegalInteger(uint64_t Width) const { return !isLegalInteger(Width); }\n\n  /// Returns true if the given alignment exceeds the natural stack alignment.\n  bool exceedsNaturalStackAlignment(Align Alignment) const {\n    return StackNaturalAlign && (Alignment > *StackNaturalAlign);\n  }\n\n  Align getStackAlignment() const {\n    assert(StackNaturalAlign && \"StackNaturalAlign must be defined\");\n    return *StackNaturalAlign;\n  }\n\n  unsigned getAllocaAddrSpace() const { return AllocaAddrSpace; }\n\n  /// Returns the alignment of function pointers, which may or may not be\n  /// related to the alignment of functions.\n  /// \\see getFunctionPtrAlignType\n  MaybeAlign getFunctionPtrAlign() const { return FunctionPtrAlign; }\n\n  /// Return the type of function pointer alignment.\n  /// \\see getFunctionPtrAlign\n  FunctionPtrAlignType getFunctionPtrAlignType() const {\n    return TheFunctionPtrAlignType;\n  }\n\n  unsigned getProgramAddressSpace() const { return ProgramAddrSpace; }\n  unsigned getDefaultGlobalsAddressSpace() const {\n    return DefaultGlobalsAddrSpace;\n  }\n\n  bool hasMicrosoftFastStdCallMangling() const {\n    return ManglingMode == MM_WinCOFFX86;\n  }\n\n  /// Returns true if symbols with leading question marks should not receive IR\n  /// mangling. True for Windows mangling modes.\n  bool doNotMangleLeadingQuestionMark() const {\n    return ManglingMode == MM_WinCOFF || ManglingMode == MM_WinCOFFX86;\n  }\n\n  bool hasLinkerPrivateGlobalPrefix() const { return ManglingMode == MM_MachO; }\n\n  StringRef getLinkerPrivateGlobalPrefix() const {\n    if (ManglingMode == MM_MachO)\n      return \"l\";\n    return \"\";\n  }\n\n  char getGlobalPrefix() const {\n    switch (ManglingMode) {\n    case MM_None:\n    case MM_ELF:\n    case MM_Mips:\n    case MM_WinCOFF:\n    case MM_XCOFF:\n      return '\\0';\n    case MM_MachO:\n    case MM_WinCOFFX86:\n      return '_';\n    }\n    llvm_unreachable(\"invalid mangling mode\");\n  }\n\n  StringRef getPrivateGlobalPrefix() const {\n    switch (ManglingMode) {\n    case MM_None:\n      return \"\";\n    case MM_ELF:\n    case MM_WinCOFF:\n      return \".L\";\n    case MM_Mips:\n      return \"$\";\n    case MM_MachO:\n    case MM_WinCOFFX86:\n      return \"L\";\n    case MM_XCOFF:\n      return \"L..\";\n    }\n    llvm_unreachable(\"invalid mangling mode\");\n  }\n\n  static const char *getManglingComponent(const Triple &T);\n\n  /// Returns true if the specified type fits in a native integer type\n  /// supported by the CPU.\n  ///\n  /// For example, if the CPU only supports i32 as a native integer type, then\n  /// i27 fits in a legal integer type but i45 does not.\n  bool fitsInLegalInteger(unsigned Width) const {\n    for (unsigned LegalIntWidth : LegalIntWidths)\n      if (Width <= LegalIntWidth)\n        return true;\n    return false;\n  }\n\n  /// Layout pointer alignment\n  Align getPointerABIAlignment(unsigned AS) const;\n\n  /// Return target's alignment for stack-based pointers\n  /// FIXME: The defaults need to be removed once all of\n  /// the backends/clients are updated.\n  Align getPointerPrefAlignment(unsigned AS = 0) const;\n\n  /// Layout pointer size\n  /// FIXME: The defaults need to be removed once all of\n  /// the backends/clients are updated.\n  unsigned getPointerSize(unsigned AS = 0) const;\n\n  /// Returns the maximum pointer size over all address spaces.\n  unsigned getMaxPointerSize() const;\n\n  // Index size used for address calculation.\n  unsigned getIndexSize(unsigned AS) const;\n\n  /// Return the address spaces containing non-integral pointers.  Pointers in\n  /// this address space don't have a well-defined bitwise representation.\n  ArrayRef<unsigned> getNonIntegralAddressSpaces() const {\n    return NonIntegralAddressSpaces;\n  }\n\n  bool isNonIntegralAddressSpace(unsigned AddrSpace) const {\n    ArrayRef<unsigned> NonIntegralSpaces = getNonIntegralAddressSpaces();\n    return is_contained(NonIntegralSpaces, AddrSpace);\n  }\n\n  bool isNonIntegralPointerType(PointerType *PT) const {\n    return isNonIntegralAddressSpace(PT->getAddressSpace());\n  }\n\n  bool isNonIntegralPointerType(Type *Ty) const {\n    auto *PTy = dyn_cast<PointerType>(Ty);\n    return PTy && isNonIntegralPointerType(PTy);\n  }\n\n  /// Layout pointer size, in bits\n  /// FIXME: The defaults need to be removed once all of\n  /// the backends/clients are updated.\n  unsigned getPointerSizeInBits(unsigned AS = 0) const {\n    return getPointerSize(AS) * 8;\n  }\n\n  /// Returns the maximum pointer size over all address spaces.\n  unsigned getMaxPointerSizeInBits() const {\n    return getMaxPointerSize() * 8;\n  }\n\n  /// Size in bits of index used for address calculation in getelementptr.\n  unsigned getIndexSizeInBits(unsigned AS) const {\n    return getIndexSize(AS) * 8;\n  }\n\n  /// Layout pointer size, in bits, based on the type.  If this function is\n  /// called with a pointer type, then the type size of the pointer is returned.\n  /// If this function is called with a vector of pointers, then the type size\n  /// of the pointer is returned.  This should only be called with a pointer or\n  /// vector of pointers.\n  unsigned getPointerTypeSizeInBits(Type *) const;\n\n  /// Layout size of the index used in GEP calculation.\n  /// The function should be called with pointer or vector of pointers type.\n  unsigned getIndexTypeSizeInBits(Type *Ty) const;\n\n  unsigned getPointerTypeSize(Type *Ty) const {\n    return getPointerTypeSizeInBits(Ty) / 8;\n  }\n\n  /// Size examples:\n  ///\n  /// Type        SizeInBits  StoreSizeInBits  AllocSizeInBits[*]\n  /// ----        ----------  ---------------  ---------------\n  ///  i1            1           8                8\n  ///  i8            8           8                8\n  ///  i19          19          24               32\n  ///  i32          32          32               32\n  ///  i100        100         104              128\n  ///  i128        128         128              128\n  ///  Float        32          32               32\n  ///  Double       64          64               64\n  ///  X86_FP80     80          80               96\n  ///\n  /// [*] The alloc size depends on the alignment, and thus on the target.\n  ///     These values are for x86-32 linux.\n\n  /// Returns the number of bits necessary to hold the specified type.\n  ///\n  /// If Ty is a scalable vector type, the scalable property will be set and\n  /// the runtime size will be a positive integer multiple of the base size.\n  ///\n  /// For example, returns 36 for i36 and 80 for x86_fp80. The type passed must\n  /// have a size (Type::isSized() must return true).\n  TypeSize getTypeSizeInBits(Type *Ty) const;\n\n  /// Returns the maximum number of bytes that may be overwritten by\n  /// storing the specified type.\n  ///\n  /// If Ty is a scalable vector type, the scalable property will be set and\n  /// the runtime size will be a positive integer multiple of the base size.\n  ///\n  /// For example, returns 5 for i36 and 10 for x86_fp80.\n  TypeSize getTypeStoreSize(Type *Ty) const {\n    TypeSize BaseSize = getTypeSizeInBits(Ty);\n    return { (BaseSize.getKnownMinSize() + 7) / 8, BaseSize.isScalable() };\n  }\n\n  /// Returns the maximum number of bits that may be overwritten by\n  /// storing the specified type; always a multiple of 8.\n  ///\n  /// If Ty is a scalable vector type, the scalable property will be set and\n  /// the runtime size will be a positive integer multiple of the base size.\n  ///\n  /// For example, returns 40 for i36 and 80 for x86_fp80.\n  TypeSize getTypeStoreSizeInBits(Type *Ty) const {\n    return 8 * getTypeStoreSize(Ty);\n  }\n\n  /// Returns true if no extra padding bits are needed when storing the\n  /// specified type.\n  ///\n  /// For example, returns false for i19 that has a 24-bit store size.\n  bool typeSizeEqualsStoreSize(Type *Ty) const {\n    return getTypeSizeInBits(Ty) == getTypeStoreSizeInBits(Ty);\n  }\n\n  /// Returns the offset in bytes between successive objects of the\n  /// specified type, including alignment padding.\n  ///\n  /// If Ty is a scalable vector type, the scalable property will be set and\n  /// the runtime size will be a positive integer multiple of the base size.\n  ///\n  /// This is the amount that alloca reserves for this type. For example,\n  /// returns 12 or 16 for x86_fp80, depending on alignment.\n  TypeSize getTypeAllocSize(Type *Ty) const {\n    // Round up to the next alignment boundary.\n    return alignTo(getTypeStoreSize(Ty), getABITypeAlignment(Ty));\n  }\n\n  /// Returns the offset in bits between successive objects of the\n  /// specified type, including alignment padding; always a multiple of 8.\n  ///\n  /// If Ty is a scalable vector type, the scalable property will be set and\n  /// the runtime size will be a positive integer multiple of the base size.\n  ///\n  /// This is the amount that alloca reserves for this type. For example,\n  /// returns 96 or 128 for x86_fp80, depending on alignment.\n  TypeSize getTypeAllocSizeInBits(Type *Ty) const {\n    return 8 * getTypeAllocSize(Ty);\n  }\n\n  /// Returns the minimum ABI-required alignment for the specified type.\n  /// FIXME: Deprecate this function once migration to Align is over.\n  unsigned getABITypeAlignment(Type *Ty) const;\n\n  /// Returns the minimum ABI-required alignment for the specified type.\n  Align getABITypeAlign(Type *Ty) const;\n\n  /// Helper function to return `Alignment` if it's set or the result of\n  /// `getABITypeAlignment(Ty)`, in any case the result is a valid alignment.\n  inline Align getValueOrABITypeAlignment(MaybeAlign Alignment,\n                                          Type *Ty) const {\n    return Alignment ? *Alignment : getABITypeAlign(Ty);\n  }\n\n  /// Returns the minimum ABI-required alignment for an integer type of\n  /// the specified bitwidth.\n  Align getABIIntegerTypeAlignment(unsigned BitWidth) const {\n    return getIntegerAlignment(BitWidth, /* abi_or_pref */ true);\n  }\n\n  /// Returns the preferred stack/global alignment for the specified\n  /// type.\n  ///\n  /// This is always at least as good as the ABI alignment.\n  /// FIXME: Deprecate this function once migration to Align is over.\n  unsigned getPrefTypeAlignment(Type *Ty) const;\n\n  /// Returns the preferred stack/global alignment for the specified\n  /// type.\n  ///\n  /// This is always at least as good as the ABI alignment.\n  Align getPrefTypeAlign(Type *Ty) const;\n\n  /// Returns an integer type with size at least as big as that of a\n  /// pointer in the given address space.\n  IntegerType *getIntPtrType(LLVMContext &C, unsigned AddressSpace = 0) const;\n\n  /// Returns an integer (vector of integer) type with size at least as\n  /// big as that of a pointer of the given pointer (vector of pointer) type.\n  Type *getIntPtrType(Type *) const;\n\n  /// Returns the smallest integer type with size at least as big as\n  /// Width bits.\n  Type *getSmallestLegalIntType(LLVMContext &C, unsigned Width = 0) const;\n\n  /// Returns the largest legal integer type, or null if none are set.\n  Type *getLargestLegalIntType(LLVMContext &C) const {\n    unsigned LargestSize = getLargestLegalIntTypeSizeInBits();\n    return (LargestSize == 0) ? nullptr : Type::getIntNTy(C, LargestSize);\n  }\n\n  /// Returns the size of largest legal integer type size, or 0 if none\n  /// are set.\n  unsigned getLargestLegalIntTypeSizeInBits() const;\n\n  /// Returns the type of a GEP index.\n  /// If it was not specified explicitly, it will be the integer type of the\n  /// pointer width - IntPtrType.\n  Type *getIndexType(Type *PtrTy) const;\n\n  /// Returns the offset from the beginning of the type for the specified\n  /// indices.\n  ///\n  /// Note that this takes the element type, not the pointer type.\n  /// This is used to implement getelementptr.\n  int64_t getIndexedOffsetInType(Type *ElemTy, ArrayRef<Value *> Indices) const;\n\n  /// Returns a StructLayout object, indicating the alignment of the\n  /// struct, its size, and the offsets of its fields.\n  ///\n  /// Note that this information is lazily cached.\n  const StructLayout *getStructLayout(StructType *Ty) const;\n\n  /// Returns the preferred alignment of the specified global.\n  ///\n  /// This includes an explicitly requested alignment (if the global has one).\n  Align getPreferredAlign(const GlobalVariable *GV) const;\n\n  /// Returns the preferred alignment of the specified global.\n  ///\n  /// This includes an explicitly requested alignment (if the global has one).\n  LLVM_ATTRIBUTE_DEPRECATED(\n      inline unsigned getPreferredAlignment(const GlobalVariable *GV) const,\n      \"Use getPreferredAlign instead\") {\n    return getPreferredAlign(GV).value();\n  }\n\n  /// Returns the preferred alignment of the specified global, returned\n  /// in log form.\n  ///\n  /// This includes an explicitly requested alignment (if the global has one).\n  LLVM_ATTRIBUTE_DEPRECATED(\n      inline unsigned getPreferredAlignmentLog(const GlobalVariable *GV) const,\n      \"Inline where needed\") {\n    return Log2(getPreferredAlign(GV));\n  }\n};\n\ninline DataLayout *unwrap(LLVMTargetDataRef P) {\n  return reinterpret_cast<DataLayout *>(P);\n}\n\ninline LLVMTargetDataRef wrap(const DataLayout *P) {\n  return reinterpret_cast<LLVMTargetDataRef>(const_cast<DataLayout *>(P));\n}\n\n/// Used to lazily calculate structure layout information for a target machine,\n/// based on the DataLayout structure.\nclass StructLayout {\n  uint64_t StructSize;\n  Align StructAlignment;\n  unsigned IsPadded : 1;\n  unsigned NumElements : 31;\n  uint64_t MemberOffsets[1]; // variable sized array!\n\npublic:\n  uint64_t getSizeInBytes() const { return StructSize; }\n\n  uint64_t getSizeInBits() const { return 8 * StructSize; }\n\n  Align getAlignment() const { return StructAlignment; }\n\n  /// Returns whether the struct has padding or not between its fields.\n  /// NB: Padding in nested element is not taken into account.\n  bool hasPadding() const { return IsPadded; }\n\n  /// Given a valid byte offset into the structure, returns the structure\n  /// index that contains it.\n  unsigned getElementContainingOffset(uint64_t Offset) const;\n\n  uint64_t getElementOffset(unsigned Idx) const {\n    assert(Idx < NumElements && \"Invalid element idx!\");\n    return MemberOffsets[Idx];\n  }\n\n  uint64_t getElementOffsetInBits(unsigned Idx) const {\n    return getElementOffset(Idx) * 8;\n  }\n\nprivate:\n  friend class DataLayout; // Only DataLayout can create this class\n\n  StructLayout(StructType *ST, const DataLayout &DL);\n};\n\n// The implementation of this method is provided inline as it is particularly\n// well suited to constant folding when called on a specific Type subclass.\ninline TypeSize DataLayout::getTypeSizeInBits(Type *Ty) const {\n  assert(Ty->isSized() && \"Cannot getTypeInfo() on a type that is unsized!\");\n  switch (Ty->getTypeID()) {\n  case Type::LabelTyID:\n    return TypeSize::Fixed(getPointerSizeInBits(0));\n  case Type::PointerTyID:\n    return TypeSize::Fixed(getPointerSizeInBits(Ty->getPointerAddressSpace()));\n  case Type::ArrayTyID: {\n    ArrayType *ATy = cast<ArrayType>(Ty);\n    return ATy->getNumElements() *\n           getTypeAllocSizeInBits(ATy->getElementType());\n  }\n  case Type::StructTyID:\n    // Get the layout annotation... which is lazily created on demand.\n    return TypeSize::Fixed(\n                        getStructLayout(cast<StructType>(Ty))->getSizeInBits());\n  case Type::IntegerTyID:\n    return TypeSize::Fixed(Ty->getIntegerBitWidth());\n  case Type::HalfTyID:\n  case Type::BFloatTyID:\n    return TypeSize::Fixed(16);\n  case Type::FloatTyID:\n    return TypeSize::Fixed(32);\n  case Type::DoubleTyID:\n  case Type::X86_MMXTyID:\n    return TypeSize::Fixed(64);\n  case Type::PPC_FP128TyID:\n  case Type::FP128TyID:\n    return TypeSize::Fixed(128);\n  case Type::X86_AMXTyID:\n    return TypeSize::Fixed(8192);\n  // In memory objects this is always aligned to a higher boundary, but\n  // only 80 bits contain information.\n  case Type::X86_FP80TyID:\n    return TypeSize::Fixed(80);\n  case Type::FixedVectorTyID:\n  case Type::ScalableVectorTyID: {\n    VectorType *VTy = cast<VectorType>(Ty);\n    auto EltCnt = VTy->getElementCount();\n    uint64_t MinBits = EltCnt.getKnownMinValue() *\n                       getTypeSizeInBits(VTy->getElementType()).getFixedSize();\n    return TypeSize(MinBits, EltCnt.isScalable());\n  }\n  default:\n    llvm_unreachable(\"DataLayout::getTypeSizeInBits(): Unsupported type\");\n  }\n}\n\n} // end namespace llvm\n\n#endif // LLVM_IR_DATALAYOUT_H\n"}, "37": {"id": 37, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h", "content": "//===- llvm/IR/DebugInfoMetadata.h - Debug info metadata --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Declarations for metadata specific to debug info.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_DEBUGINFOMETADATA_H\n#define LLVM_IR_DEBUGINFOMETADATA_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/BitmaskEnum.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/Metadata.h\"\n#include \"llvm/Support/Casting.h\"\n#include <cassert>\n#include <climits>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <type_traits>\n#include <vector>\n\n// Helper macros for defining get() overrides.\n#define DEFINE_MDNODE_GET_UNPACK_IMPL(...) __VA_ARGS__\n#define DEFINE_MDNODE_GET_UNPACK(ARGS) DEFINE_MDNODE_GET_UNPACK_IMPL ARGS\n#define DEFINE_MDNODE_GET_DISTINCT_TEMPORARY(CLASS, FORMAL, ARGS)              \\\n  static CLASS *getDistinct(LLVMContext &Context,                              \\\n                            DEFINE_MDNODE_GET_UNPACK(FORMAL)) {                \\\n    return getImpl(Context, DEFINE_MDNODE_GET_UNPACK(ARGS), Distinct);         \\\n  }                                                                            \\\n  static Temp##CLASS getTemporary(LLVMContext &Context,                        \\\n                                  DEFINE_MDNODE_GET_UNPACK(FORMAL)) {          \\\n    return Temp##CLASS(                                                        \\\n        getImpl(Context, DEFINE_MDNODE_GET_UNPACK(ARGS), Temporary));          \\\n  }\n#define DEFINE_MDNODE_GET(CLASS, FORMAL, ARGS)                                 \\\n  static CLASS *get(LLVMContext &Context, DEFINE_MDNODE_GET_UNPACK(FORMAL)) {  \\\n    return getImpl(Context, DEFINE_MDNODE_GET_UNPACK(ARGS), Uniqued);          \\\n  }                                                                            \\\n  static CLASS *getIfExists(LLVMContext &Context,                              \\\n                            DEFINE_MDNODE_GET_UNPACK(FORMAL)) {                \\\n    return getImpl(Context, DEFINE_MDNODE_GET_UNPACK(ARGS), Uniqued,           \\\n                   /* ShouldCreate */ false);                                  \\\n  }                                                                            \\\n  DEFINE_MDNODE_GET_DISTINCT_TEMPORARY(CLASS, FORMAL, ARGS)\n\nnamespace llvm {\n\nclass DITypeRefArray {\n  const MDTuple *N = nullptr;\n\npublic:\n  DITypeRefArray() = default;\n  DITypeRefArray(const MDTuple *N) : N(N) {}\n\n  explicit operator bool() const { return get(); }\n  explicit operator MDTuple *() const { return get(); }\n\n  MDTuple *get() const { return const_cast<MDTuple *>(N); }\n  MDTuple *operator->() const { return get(); }\n  MDTuple &operator*() const { return *get(); }\n\n  // FIXME: Fix callers and remove condition on N.\n  unsigned size() const { return N ? N->getNumOperands() : 0u; }\n  DIType *operator[](unsigned I) const {\n    return cast_or_null<DIType>(N->getOperand(I));\n  }\n\n  class iterator : std::iterator<std::input_iterator_tag, DIType *,\n                                 std::ptrdiff_t, void, DIType *> {\n    MDNode::op_iterator I = nullptr;\n\n  public:\n    iterator() = default;\n    explicit iterator(MDNode::op_iterator I) : I(I) {}\n\n    DIType *operator*() const { return cast_or_null<DIType>(*I); }\n\n    iterator &operator++() {\n      ++I;\n      return *this;\n    }\n\n    iterator operator++(int) {\n      iterator Temp(*this);\n      ++I;\n      return Temp;\n    }\n\n    bool operator==(const iterator &X) const { return I == X.I; }\n    bool operator!=(const iterator &X) const { return I != X.I; }\n  };\n\n  // FIXME: Fix callers and remove condition on N.\n  iterator begin() const { return N ? iterator(N->op_begin()) : iterator(); }\n  iterator end() const { return N ? iterator(N->op_end()) : iterator(); }\n};\n\n/// Tagged DWARF-like metadata node.\n///\n/// A metadata node with a DWARF tag (i.e., a constant named \\c DW_TAG_*,\n/// defined in llvm/BinaryFormat/Dwarf.h).  Called \\a DINode because it's\n/// potentially used for non-DWARF output.\nclass DINode : public MDNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\nprotected:\n  DINode(LLVMContext &C, unsigned ID, StorageType Storage, unsigned Tag,\n         ArrayRef<Metadata *> Ops1, ArrayRef<Metadata *> Ops2 = None)\n      : MDNode(C, ID, Storage, Ops1, Ops2) {\n    assert(Tag < 1u << 16);\n    SubclassData16 = Tag;\n  }\n  ~DINode() = default;\n\n  template <class Ty> Ty *getOperandAs(unsigned I) const {\n    return cast_or_null<Ty>(getOperand(I));\n  }\n\n  StringRef getStringOperand(unsigned I) const {\n    if (auto *S = getOperandAs<MDString>(I))\n      return S->getString();\n    return StringRef();\n  }\n\n  static MDString *getCanonicalMDString(LLVMContext &Context, StringRef S) {\n    if (S.empty())\n      return nullptr;\n    return MDString::get(Context, S);\n  }\n\n  /// Allow subclasses to mutate the tag.\n  void setTag(unsigned Tag) { SubclassData16 = Tag; }\n\npublic:\n  unsigned getTag() const { return SubclassData16; }\n\n  /// Debug info flags.\n  ///\n  /// The three accessibility flags are mutually exclusive and rolled together\n  /// in the first two bits.\n  enum DIFlags : uint32_t {\n#define HANDLE_DI_FLAG(ID, NAME) Flag##NAME = ID,\n#define DI_FLAG_LARGEST_NEEDED\n#include \"llvm/IR/DebugInfoFlags.def\"\n    FlagAccessibility = FlagPrivate | FlagProtected | FlagPublic,\n    FlagPtrToMemberRep = FlagSingleInheritance | FlagMultipleInheritance |\n                         FlagVirtualInheritance,\n    LLVM_MARK_AS_BITMASK_ENUM(FlagLargest)\n  };\n\n  static DIFlags getFlag(StringRef Flag);\n  static StringRef getFlagString(DIFlags Flag);\n\n  /// Split up a flags bitfield.\n  ///\n  /// Split \\c Flags into \\c SplitFlags, a vector of its components.  Returns\n  /// any remaining (unrecognized) bits.\n  static DIFlags splitFlags(DIFlags Flags,\n                            SmallVectorImpl<DIFlags> &SplitFlags);\n\n  static bool classof(const Metadata *MD) {\n    switch (MD->getMetadataID()) {\n    default:\n      return false;\n    case GenericDINodeKind:\n    case DISubrangeKind:\n    case DIEnumeratorKind:\n    case DIBasicTypeKind:\n    case DIStringTypeKind:\n    case DIDerivedTypeKind:\n    case DICompositeTypeKind:\n    case DISubroutineTypeKind:\n    case DIFileKind:\n    case DICompileUnitKind:\n    case DISubprogramKind:\n    case DILexicalBlockKind:\n    case DILexicalBlockFileKind:\n    case DINamespaceKind:\n    case DICommonBlockKind:\n    case DITemplateTypeParameterKind:\n    case DITemplateValueParameterKind:\n    case DIGlobalVariableKind:\n    case DILocalVariableKind:\n    case DILabelKind:\n    case DIObjCPropertyKind:\n    case DIImportedEntityKind:\n    case DIModuleKind:\n    case DIGenericSubrangeKind:\n      return true;\n    }\n  }\n};\n\n/// Generic tagged DWARF-like metadata node.\n///\n/// An un-specialized DWARF-like metadata node.  The first operand is a\n/// (possibly empty) null-separated \\a MDString header that contains arbitrary\n/// fields.  The remaining operands are \\a dwarf_operands(), and are pointers\n/// to other metadata.\nclass GenericDINode : public DINode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  GenericDINode(LLVMContext &C, StorageType Storage, unsigned Hash,\n                unsigned Tag, ArrayRef<Metadata *> Ops1,\n                ArrayRef<Metadata *> Ops2)\n      : DINode(C, GenericDINodeKind, Storage, Tag, Ops1, Ops2) {\n    setHash(Hash);\n  }\n  ~GenericDINode() { dropAllReferences(); }\n\n  void setHash(unsigned Hash) { SubclassData32 = Hash; }\n  void recalculateHash();\n\n  static GenericDINode *getImpl(LLVMContext &Context, unsigned Tag,\n                                StringRef Header, ArrayRef<Metadata *> DwarfOps,\n                                StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, Tag, getCanonicalMDString(Context, Header),\n                   DwarfOps, Storage, ShouldCreate);\n  }\n\n  static GenericDINode *getImpl(LLVMContext &Context, unsigned Tag,\n                                MDString *Header, ArrayRef<Metadata *> DwarfOps,\n                                StorageType Storage, bool ShouldCreate = true);\n\n  TempGenericDINode cloneImpl() const {\n    return getTemporary(getContext(), getTag(), getHeader(),\n                        SmallVector<Metadata *, 4>(dwarf_operands()));\n  }\n\npublic:\n  unsigned getHash() const { return SubclassData32; }\n\n  DEFINE_MDNODE_GET(GenericDINode, (unsigned Tag, StringRef Header,\n                                    ArrayRef<Metadata *> DwarfOps),\n                    (Tag, Header, DwarfOps))\n  DEFINE_MDNODE_GET(GenericDINode, (unsigned Tag, MDString *Header,\n                                    ArrayRef<Metadata *> DwarfOps),\n                    (Tag, Header, DwarfOps))\n\n  /// Return a (temporary) clone of this.\n  TempGenericDINode clone() const { return cloneImpl(); }\n\n  unsigned getTag() const { return SubclassData16; }\n  StringRef getHeader() const { return getStringOperand(0); }\n  MDString *getRawHeader() const { return getOperandAs<MDString>(0); }\n\n  op_iterator dwarf_op_begin() const { return op_begin() + 1; }\n  op_iterator dwarf_op_end() const { return op_end(); }\n  op_range dwarf_operands() const {\n    return op_range(dwarf_op_begin(), dwarf_op_end());\n  }\n\n  unsigned getNumDwarfOperands() const { return getNumOperands() - 1; }\n  const MDOperand &getDwarfOperand(unsigned I) const {\n    return getOperand(I + 1);\n  }\n  void replaceDwarfOperandWith(unsigned I, Metadata *New) {\n    replaceOperandWith(I + 1, New);\n  }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == GenericDINodeKind;\n  }\n};\n\n/// Array subrange.\n///\n/// TODO: Merge into node for DW_TAG_array_type, which should have a custom\n/// type.\nclass DISubrange : public DINode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  DISubrange(LLVMContext &C, StorageType Storage, ArrayRef<Metadata *> Ops)\n      : DINode(C, DISubrangeKind, Storage, dwarf::DW_TAG_subrange_type, Ops) {}\n\n  ~DISubrange() = default;\n\n  static DISubrange *getImpl(LLVMContext &Context, int64_t Count,\n                             int64_t LowerBound, StorageType Storage,\n                             bool ShouldCreate = true);\n\n  static DISubrange *getImpl(LLVMContext &Context, Metadata *CountNode,\n                             int64_t LowerBound, StorageType Storage,\n                             bool ShouldCreate = true);\n\n  static DISubrange *getImpl(LLVMContext &Context, Metadata *CountNode,\n                             Metadata *LowerBound, Metadata *UpperBound,\n                             Metadata *Stride, StorageType Storage,\n                             bool ShouldCreate = true);\n\n  TempDISubrange cloneImpl() const {\n    return getTemporary(getContext(), getRawCountNode(), getRawLowerBound(),\n                        getRawUpperBound(), getRawStride());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DISubrange, (int64_t Count, int64_t LowerBound = 0),\n                    (Count, LowerBound))\n\n  DEFINE_MDNODE_GET(DISubrange, (Metadata *CountNode, int64_t LowerBound = 0),\n                    (CountNode, LowerBound))\n\n  DEFINE_MDNODE_GET(DISubrange,\n                    (Metadata * CountNode, Metadata *LowerBound,\n                     Metadata *UpperBound, Metadata *Stride),\n                    (CountNode, LowerBound, UpperBound, Stride))\n\n  TempDISubrange clone() const { return cloneImpl(); }\n\n  Metadata *getRawCountNode() const {\n    return getOperand(0).get();\n  }\n\n  Metadata *getRawLowerBound() const { return getOperand(1).get(); }\n\n  Metadata *getRawUpperBound() const { return getOperand(2).get(); }\n\n  Metadata *getRawStride() const { return getOperand(3).get(); }\n\n  typedef PointerUnion<ConstantInt*, DIVariable*> CountType;\n  typedef PointerUnion<ConstantInt *, DIVariable *, DIExpression *> BoundType;\n\n  CountType getCount() const;\n\n  BoundType getLowerBound() const;\n\n  BoundType getUpperBound() const;\n\n  BoundType getStride() const;\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DISubrangeKind;\n  }\n};\n\nclass DIGenericSubrange : public DINode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  DIGenericSubrange(LLVMContext &C, StorageType Storage,\n                    ArrayRef<Metadata *> Ops)\n      : DINode(C, DIGenericSubrangeKind, Storage,\n               dwarf::DW_TAG_generic_subrange, Ops) {}\n\n  ~DIGenericSubrange() = default;\n\n  static DIGenericSubrange *getImpl(LLVMContext &Context, Metadata *CountNode,\n                                    Metadata *LowerBound, Metadata *UpperBound,\n                                    Metadata *Stride, StorageType Storage,\n                                    bool ShouldCreate = true);\n\n  TempDIGenericSubrange cloneImpl() const {\n    return getTemporary(getContext(), getRawCountNode(), getRawLowerBound(),\n                        getRawUpperBound(), getRawStride());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIGenericSubrange,\n                    (Metadata * CountNode, Metadata *LowerBound,\n                     Metadata *UpperBound, Metadata *Stride),\n                    (CountNode, LowerBound, UpperBound, Stride))\n\n  TempDIGenericSubrange clone() const { return cloneImpl(); }\n\n  Metadata *getRawCountNode() const { return getOperand(0).get(); }\n  Metadata *getRawLowerBound() const { return getOperand(1).get(); }\n  Metadata *getRawUpperBound() const { return getOperand(2).get(); }\n  Metadata *getRawStride() const { return getOperand(3).get(); }\n\n  using BoundType = PointerUnion<DIVariable *, DIExpression *>;\n\n  BoundType getCount() const;\n  BoundType getLowerBound() const;\n  BoundType getUpperBound() const;\n  BoundType getStride() const;\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIGenericSubrangeKind;\n  }\n};\n\n/// Enumeration value.\n///\n/// TODO: Add a pointer to the context (DW_TAG_enumeration_type) once that no\n/// longer creates a type cycle.\nclass DIEnumerator : public DINode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  APInt Value;\n  DIEnumerator(LLVMContext &C, StorageType Storage, const APInt &Value,\n               bool IsUnsigned, ArrayRef<Metadata *> Ops)\n      : DINode(C, DIEnumeratorKind, Storage, dwarf::DW_TAG_enumerator, Ops),\n        Value(Value) {\n    SubclassData32 = IsUnsigned;\n  }\n  DIEnumerator(LLVMContext &C, StorageType Storage, int64_t Value,\n               bool IsUnsigned, ArrayRef<Metadata *> Ops)\n      : DIEnumerator(C, Storage, APInt(64, Value, !IsUnsigned), IsUnsigned,\n                     Ops) {}\n  ~DIEnumerator() = default;\n\n  static DIEnumerator *getImpl(LLVMContext &Context, const APInt &Value,\n                               bool IsUnsigned, StringRef Name,\n                               StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, Value, IsUnsigned,\n                   getCanonicalMDString(Context, Name), Storage, ShouldCreate);\n  }\n  static DIEnumerator *getImpl(LLVMContext &Context, const APInt &Value,\n                               bool IsUnsigned, MDString *Name,\n                               StorageType Storage, bool ShouldCreate = true);\n\n  TempDIEnumerator cloneImpl() const {\n    return getTemporary(getContext(), getValue(), isUnsigned(), getName());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIEnumerator,\n                    (int64_t Value, bool IsUnsigned, StringRef Name),\n                    (APInt(64, Value, !IsUnsigned), IsUnsigned, Name))\n  DEFINE_MDNODE_GET(DIEnumerator,\n                    (int64_t Value, bool IsUnsigned, MDString *Name),\n                    (APInt(64, Value, !IsUnsigned), IsUnsigned, Name))\n  DEFINE_MDNODE_GET(DIEnumerator,\n                    (APInt Value, bool IsUnsigned, StringRef Name),\n                    (Value, IsUnsigned, Name))\n  DEFINE_MDNODE_GET(DIEnumerator,\n                    (APInt Value, bool IsUnsigned, MDString *Name),\n                    (Value, IsUnsigned, Name))\n\n  TempDIEnumerator clone() const { return cloneImpl(); }\n\n  const APInt &getValue() const { return Value; }\n  bool isUnsigned() const { return SubclassData32; }\n  StringRef getName() const { return getStringOperand(0); }\n\n  MDString *getRawName() const { return getOperandAs<MDString>(0); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIEnumeratorKind;\n  }\n};\n\n/// Base class for scope-like contexts.\n///\n/// Base class for lexical scopes and types (which are also declaration\n/// contexts).\n///\n/// TODO: Separate the concepts of declaration contexts and lexical scopes.\nclass DIScope : public DINode {\nprotected:\n  DIScope(LLVMContext &C, unsigned ID, StorageType Storage, unsigned Tag,\n          ArrayRef<Metadata *> Ops)\n      : DINode(C, ID, Storage, Tag, Ops) {}\n  ~DIScope() = default;\n\npublic:\n  DIFile *getFile() const { return cast_or_null<DIFile>(getRawFile()); }\n\n  inline StringRef getFilename() const;\n  inline StringRef getDirectory() const;\n  inline Optional<StringRef> getSource() const;\n\n  StringRef getName() const;\n  DIScope *getScope() const;\n\n  /// Return the raw underlying file.\n  ///\n  /// A \\a DIFile is a \\a DIScope, but it doesn't point at a separate file (it\n  /// \\em is the file).  If \\c this is an \\a DIFile, we need to return \\c this.\n  /// Otherwise, return the first operand, which is where all other subclasses\n  /// store their file pointer.\n  Metadata *getRawFile() const {\n    return isa<DIFile>(this) ? const_cast<DIScope *>(this)\n                             : static_cast<Metadata *>(getOperand(0));\n  }\n\n  static bool classof(const Metadata *MD) {\n    switch (MD->getMetadataID()) {\n    default:\n      return false;\n    case DIBasicTypeKind:\n    case DIStringTypeKind:\n    case DIDerivedTypeKind:\n    case DICompositeTypeKind:\n    case DISubroutineTypeKind:\n    case DIFileKind:\n    case DICompileUnitKind:\n    case DISubprogramKind:\n    case DILexicalBlockKind:\n    case DILexicalBlockFileKind:\n    case DINamespaceKind:\n    case DICommonBlockKind:\n    case DIModuleKind:\n      return true;\n    }\n  }\n};\n\n/// File.\n///\n/// TODO: Merge with directory/file node (including users).\n/// TODO: Canonicalize paths on creation.\nclass DIFile : public DIScope {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\npublic:\n  /// Which algorithm (e.g. MD5) a checksum was generated with.\n  ///\n  /// The encoding is explicit because it is used directly in Bitcode. The\n  /// value 0 is reserved to indicate the absence of a checksum in Bitcode.\n  enum ChecksumKind {\n    // The first variant was originally CSK_None, encoded as 0. The new\n    // internal representation removes the need for this by wrapping the\n    // ChecksumInfo in an Optional, but to preserve Bitcode compatibility the 0\n    // encoding is reserved.\n    CSK_MD5 = 1,\n    CSK_SHA1 = 2,\n    CSK_SHA256 = 3,\n    CSK_Last = CSK_SHA256 // Should be last enumeration.\n  };\n\n  /// A single checksum, represented by a \\a Kind and a \\a Value (a string).\n  template <typename T>\n  struct ChecksumInfo {\n    /// The kind of checksum which \\a Value encodes.\n    ChecksumKind Kind;\n    /// The string value of the checksum.\n    T Value;\n\n    ChecksumInfo(ChecksumKind Kind, T Value) : Kind(Kind), Value(Value) { }\n    ~ChecksumInfo() = default;\n    bool operator==(const ChecksumInfo<T> &X) const {\n      return Kind == X.Kind && Value == X.Value;\n    }\n    bool operator!=(const ChecksumInfo<T> &X) const { return !(*this == X); }\n    StringRef getKindAsString() const { return getChecksumKindAsString(Kind); }\n  };\n\nprivate:\n  Optional<ChecksumInfo<MDString *>> Checksum;\n  Optional<MDString *> Source;\n\n  DIFile(LLVMContext &C, StorageType Storage,\n         Optional<ChecksumInfo<MDString *>> CS, Optional<MDString *> Src,\n         ArrayRef<Metadata *> Ops)\n      : DIScope(C, DIFileKind, Storage, dwarf::DW_TAG_file_type, Ops),\n        Checksum(CS), Source(Src) {}\n  ~DIFile() = default;\n\n  static DIFile *getImpl(LLVMContext &Context, StringRef Filename,\n                         StringRef Directory,\n                         Optional<ChecksumInfo<StringRef>> CS,\n                         Optional<StringRef> Source,\n                         StorageType Storage, bool ShouldCreate = true) {\n    Optional<ChecksumInfo<MDString *>> MDChecksum;\n    if (CS)\n      MDChecksum.emplace(CS->Kind, getCanonicalMDString(Context, CS->Value));\n    return getImpl(Context, getCanonicalMDString(Context, Filename),\n                   getCanonicalMDString(Context, Directory), MDChecksum,\n                   Source ? Optional<MDString *>(getCanonicalMDString(Context, *Source)) : None,\n                   Storage, ShouldCreate);\n  }\n  static DIFile *getImpl(LLVMContext &Context, MDString *Filename,\n                         MDString *Directory,\n                         Optional<ChecksumInfo<MDString *>> CS,\n                         Optional<MDString *> Source, StorageType Storage,\n                         bool ShouldCreate = true);\n\n  TempDIFile cloneImpl() const {\n    return getTemporary(getContext(), getFilename(), getDirectory(),\n                        getChecksum(), getSource());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIFile, (StringRef Filename, StringRef Directory,\n                             Optional<ChecksumInfo<StringRef>> CS = None,\n                             Optional<StringRef> Source = None),\n                    (Filename, Directory, CS, Source))\n  DEFINE_MDNODE_GET(DIFile, (MDString * Filename, MDString *Directory,\n                             Optional<ChecksumInfo<MDString *>> CS = None,\n                             Optional<MDString *> Source = None),\n                    (Filename, Directory, CS, Source))\n\n  TempDIFile clone() const { return cloneImpl(); }\n\n  StringRef getFilename() const { return getStringOperand(0); }\n  StringRef getDirectory() const { return getStringOperand(1); }\n  Optional<ChecksumInfo<StringRef>> getChecksum() const {\n    Optional<ChecksumInfo<StringRef>> StringRefChecksum;\n    if (Checksum)\n      StringRefChecksum.emplace(Checksum->Kind, Checksum->Value->getString());\n    return StringRefChecksum;\n  }\n  Optional<StringRef> getSource() const {\n    return Source ? Optional<StringRef>((*Source)->getString()) : None;\n  }\n\n  MDString *getRawFilename() const { return getOperandAs<MDString>(0); }\n  MDString *getRawDirectory() const { return getOperandAs<MDString>(1); }\n  Optional<ChecksumInfo<MDString *>> getRawChecksum() const { return Checksum; }\n  Optional<MDString *> getRawSource() const { return Source; }\n\n  static StringRef getChecksumKindAsString(ChecksumKind CSKind);\n  static Optional<ChecksumKind> getChecksumKind(StringRef CSKindStr);\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIFileKind;\n  }\n};\n\nStringRef DIScope::getFilename() const {\n  if (auto *F = getFile())\n    return F->getFilename();\n  return \"\";\n}\n\nStringRef DIScope::getDirectory() const {\n  if (auto *F = getFile())\n    return F->getDirectory();\n  return \"\";\n}\n\nOptional<StringRef> DIScope::getSource() const {\n  if (auto *F = getFile())\n    return F->getSource();\n  return None;\n}\n\n/// Base class for types.\n///\n/// TODO: Remove the hardcoded name and context, since many types don't use\n/// them.\n/// TODO: Split up flags.\nclass DIType : public DIScope {\n  unsigned Line;\n  DIFlags Flags;\n  uint64_t SizeInBits;\n  uint64_t OffsetInBits;\n  uint32_t AlignInBits;\n\nprotected:\n  DIType(LLVMContext &C, unsigned ID, StorageType Storage, unsigned Tag,\n         unsigned Line, uint64_t SizeInBits, uint32_t AlignInBits,\n         uint64_t OffsetInBits, DIFlags Flags, ArrayRef<Metadata *> Ops)\n      : DIScope(C, ID, Storage, Tag, Ops) {\n    init(Line, SizeInBits, AlignInBits, OffsetInBits, Flags);\n  }\n  ~DIType() = default;\n\n  void init(unsigned Line, uint64_t SizeInBits, uint32_t AlignInBits,\n            uint64_t OffsetInBits, DIFlags Flags) {\n    this->Line = Line;\n    this->Flags = Flags;\n    this->SizeInBits = SizeInBits;\n    this->AlignInBits = AlignInBits;\n    this->OffsetInBits = OffsetInBits;\n  }\n\n  /// Change fields in place.\n  void mutate(unsigned Tag, unsigned Line, uint64_t SizeInBits,\n              uint32_t AlignInBits, uint64_t OffsetInBits, DIFlags Flags) {\n    assert(isDistinct() && \"Only distinct nodes can mutate\");\n    setTag(Tag);\n    init(Line, SizeInBits, AlignInBits, OffsetInBits, Flags);\n  }\n\npublic:\n  TempDIType clone() const {\n    return TempDIType(cast<DIType>(MDNode::clone().release()));\n  }\n\n  unsigned getLine() const { return Line; }\n  uint64_t getSizeInBits() const { return SizeInBits; }\n  uint32_t getAlignInBits() const { return AlignInBits; }\n  uint32_t getAlignInBytes() const { return getAlignInBits() / CHAR_BIT; }\n  uint64_t getOffsetInBits() const { return OffsetInBits; }\n  DIFlags getFlags() const { return Flags; }\n\n  DIScope *getScope() const { return cast_or_null<DIScope>(getRawScope()); }\n  StringRef getName() const { return getStringOperand(2); }\n\n\n  Metadata *getRawScope() const { return getOperand(1); }\n  MDString *getRawName() const { return getOperandAs<MDString>(2); }\n\n  /// Returns a new temporary DIType with updated Flags\n  TempDIType cloneWithFlags(DIFlags NewFlags) const {\n    auto NewTy = clone();\n    NewTy->Flags = NewFlags;\n    return NewTy;\n  }\n\n  bool isPrivate() const {\n    return (getFlags() & FlagAccessibility) == FlagPrivate;\n  }\n  bool isProtected() const {\n    return (getFlags() & FlagAccessibility) == FlagProtected;\n  }\n  bool isPublic() const {\n    return (getFlags() & FlagAccessibility) == FlagPublic;\n  }\n  bool isForwardDecl() const { return getFlags() & FlagFwdDecl; }\n  bool isAppleBlockExtension() const { return getFlags() & FlagAppleBlock; }\n  bool isVirtual() const { return getFlags() & FlagVirtual; }\n  bool isArtificial() const { return getFlags() & FlagArtificial; }\n  bool isObjectPointer() const { return getFlags() & FlagObjectPointer; }\n  bool isObjcClassComplete() const {\n    return getFlags() & FlagObjcClassComplete;\n  }\n  bool isVector() const { return getFlags() & FlagVector; }\n  bool isBitField() const { return getFlags() & FlagBitField; }\n  bool isStaticMember() const { return getFlags() & FlagStaticMember; }\n  bool isLValueReference() const { return getFlags() & FlagLValueReference; }\n  bool isRValueReference() const { return getFlags() & FlagRValueReference; }\n  bool isTypePassByValue() const { return getFlags() & FlagTypePassByValue; }\n  bool isTypePassByReference() const {\n    return getFlags() & FlagTypePassByReference;\n  }\n  bool isBigEndian() const { return getFlags() & FlagBigEndian; }\n  bool isLittleEndian() const { return getFlags() & FlagLittleEndian; }\n  bool getExportSymbols() const { return getFlags() & FlagExportSymbols; }\n\n  static bool classof(const Metadata *MD) {\n    switch (MD->getMetadataID()) {\n    default:\n      return false;\n    case DIBasicTypeKind:\n    case DIStringTypeKind:\n    case DIDerivedTypeKind:\n    case DICompositeTypeKind:\n    case DISubroutineTypeKind:\n      return true;\n    }\n  }\n};\n\n/// Basic type, like 'int' or 'float'.\n///\n/// TODO: Split out DW_TAG_unspecified_type.\n/// TODO: Drop unused accessors.\nclass DIBasicType : public DIType {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Encoding;\n\n  DIBasicType(LLVMContext &C, StorageType Storage, unsigned Tag,\n              uint64_t SizeInBits, uint32_t AlignInBits, unsigned Encoding,\n              DIFlags Flags, ArrayRef<Metadata *> Ops)\n      : DIType(C, DIBasicTypeKind, Storage, Tag, 0, SizeInBits, AlignInBits, 0,\n               Flags, Ops),\n        Encoding(Encoding) {}\n  ~DIBasicType() = default;\n\n  static DIBasicType *getImpl(LLVMContext &Context, unsigned Tag,\n                              StringRef Name, uint64_t SizeInBits,\n                              uint32_t AlignInBits, unsigned Encoding,\n                              DIFlags Flags, StorageType Storage,\n                              bool ShouldCreate = true) {\n    return getImpl(Context, Tag, getCanonicalMDString(Context, Name),\n                   SizeInBits, AlignInBits, Encoding, Flags, Storage,\n                   ShouldCreate);\n  }\n  static DIBasicType *getImpl(LLVMContext &Context, unsigned Tag,\n                              MDString *Name, uint64_t SizeInBits,\n                              uint32_t AlignInBits, unsigned Encoding,\n                              DIFlags Flags, StorageType Storage,\n                              bool ShouldCreate = true);\n\n  TempDIBasicType cloneImpl() const {\n    return getTemporary(getContext(), getTag(), getName(), getSizeInBits(),\n                        getAlignInBits(), getEncoding(), getFlags());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIBasicType, (unsigned Tag, StringRef Name),\n                    (Tag, Name, 0, 0, 0, FlagZero))\n  DEFINE_MDNODE_GET(DIBasicType,\n                    (unsigned Tag, StringRef Name, uint64_t SizeInBits),\n                    (Tag, Name, SizeInBits, 0, 0, FlagZero))\n  DEFINE_MDNODE_GET(DIBasicType,\n                    (unsigned Tag, MDString *Name, uint64_t SizeInBits),\n                    (Tag, Name, SizeInBits, 0, 0, FlagZero))\n  DEFINE_MDNODE_GET(DIBasicType,\n                    (unsigned Tag, StringRef Name, uint64_t SizeInBits,\n                     uint32_t AlignInBits, unsigned Encoding, DIFlags Flags),\n                    (Tag, Name, SizeInBits, AlignInBits, Encoding, Flags))\n  DEFINE_MDNODE_GET(DIBasicType,\n                    (unsigned Tag, MDString *Name, uint64_t SizeInBits,\n                     uint32_t AlignInBits, unsigned Encoding, DIFlags Flags),\n                    (Tag, Name, SizeInBits, AlignInBits, Encoding, Flags))\n\n  TempDIBasicType clone() const { return cloneImpl(); }\n\n  unsigned getEncoding() const { return Encoding; }\n\n  enum class Signedness { Signed, Unsigned };\n\n  /// Return the signedness of this type, or None if this type is neither\n  /// signed nor unsigned.\n  Optional<Signedness> getSignedness() const;\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIBasicTypeKind;\n  }\n};\n\n/// String type, Fortran CHARACTER(n)\nclass DIStringType : public DIType {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Encoding;\n\n  DIStringType(LLVMContext &C, StorageType Storage, unsigned Tag,\n               uint64_t SizeInBits, uint32_t AlignInBits, unsigned Encoding,\n               ArrayRef<Metadata *> Ops)\n      : DIType(C, DIStringTypeKind, Storage, Tag, 0, SizeInBits, AlignInBits, 0,\n               FlagZero, Ops),\n        Encoding(Encoding) {}\n  ~DIStringType() = default;\n\n  static DIStringType *getImpl(LLVMContext &Context, unsigned Tag,\n                               StringRef Name, Metadata *StringLength,\n                               Metadata *StrLenExp, uint64_t SizeInBits,\n                               uint32_t AlignInBits, unsigned Encoding,\n                               StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, Tag, getCanonicalMDString(Context, Name),\n                   StringLength, StrLenExp, SizeInBits, AlignInBits, Encoding,\n                   Storage, ShouldCreate);\n  }\n  static DIStringType *getImpl(LLVMContext &Context, unsigned Tag,\n                               MDString *Name, Metadata *StringLength,\n                               Metadata *StrLenExp, uint64_t SizeInBits,\n                               uint32_t AlignInBits, unsigned Encoding,\n                               StorageType Storage, bool ShouldCreate = true);\n\n  TempDIStringType cloneImpl() const {\n    return getTemporary(getContext(), getTag(), getRawName(),\n                        getRawStringLength(), getRawStringLengthExp(),\n                        getSizeInBits(), getAlignInBits(), getEncoding());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIStringType,\n                    (unsigned Tag, StringRef Name, uint64_t SizeInBits,\n                     uint32_t AlignInBits),\n                    (Tag, Name, nullptr, nullptr, SizeInBits, AlignInBits, 0))\n  DEFINE_MDNODE_GET(DIStringType,\n                    (unsigned Tag, MDString *Name, Metadata *StringLength,\n                     Metadata *StringLengthExp, uint64_t SizeInBits,\n                     uint32_t AlignInBits, unsigned Encoding),\n                    (Tag, Name, StringLength, StringLengthExp, SizeInBits,\n                     AlignInBits, Encoding))\n  DEFINE_MDNODE_GET(DIStringType,\n                    (unsigned Tag, StringRef Name, Metadata *StringLength,\n                     Metadata *StringLengthExp, uint64_t SizeInBits,\n                     uint32_t AlignInBits, unsigned Encoding),\n                    (Tag, Name, StringLength, StringLengthExp, SizeInBits,\n                     AlignInBits, Encoding))\n\n  TempDIStringType clone() const { return cloneImpl(); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIStringTypeKind;\n  }\n\n  DIVariable *getStringLength() const {\n    return cast_or_null<DIVariable>(getRawStringLength());\n  }\n\n  DIExpression *getStringLengthExp() const {\n    return cast_or_null<DIExpression>(getRawStringLengthExp());\n  }\n\n  unsigned getEncoding() const { return Encoding; }\n\n  Metadata *getRawStringLength() const { return getOperand(3); }\n\n  Metadata *getRawStringLengthExp() const { return getOperand(4); }\n};\n\n/// Derived types.\n///\n/// This includes qualified types, pointers, references, friends, typedefs, and\n/// class members.\n///\n/// TODO: Split out members (inheritance, fields, methods, etc.).\nclass DIDerivedType : public DIType {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  /// The DWARF address space of the memory pointed to or referenced by a\n  /// pointer or reference type respectively.\n  Optional<unsigned> DWARFAddressSpace;\n\n  DIDerivedType(LLVMContext &C, StorageType Storage, unsigned Tag,\n                unsigned Line, uint64_t SizeInBits, uint32_t AlignInBits,\n                uint64_t OffsetInBits, Optional<unsigned> DWARFAddressSpace,\n                DIFlags Flags, ArrayRef<Metadata *> Ops)\n      : DIType(C, DIDerivedTypeKind, Storage, Tag, Line, SizeInBits,\n               AlignInBits, OffsetInBits, Flags, Ops),\n        DWARFAddressSpace(DWARFAddressSpace) {}\n  ~DIDerivedType() = default;\n\n  static DIDerivedType *\n  getImpl(LLVMContext &Context, unsigned Tag, StringRef Name, DIFile *File,\n          unsigned Line, DIScope *Scope, DIType *BaseType, uint64_t SizeInBits,\n          uint32_t AlignInBits, uint64_t OffsetInBits,\n          Optional<unsigned> DWARFAddressSpace, DIFlags Flags,\n          Metadata *ExtraData, StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, Tag, getCanonicalMDString(Context, Name), File,\n                   Line, Scope, BaseType, SizeInBits, AlignInBits, OffsetInBits,\n                   DWARFAddressSpace, Flags, ExtraData, Storage, ShouldCreate);\n  }\n  static DIDerivedType *getImpl(LLVMContext &Context, unsigned Tag,\n                                MDString *Name, Metadata *File, unsigned Line,\n                                Metadata *Scope, Metadata *BaseType,\n                                uint64_t SizeInBits, uint32_t AlignInBits,\n                                uint64_t OffsetInBits,\n                                Optional<unsigned> DWARFAddressSpace,\n                                DIFlags Flags, Metadata *ExtraData,\n                                StorageType Storage, bool ShouldCreate = true);\n\n  TempDIDerivedType cloneImpl() const {\n    return getTemporary(getContext(), getTag(), getName(), getFile(), getLine(),\n                        getScope(), getBaseType(), getSizeInBits(),\n                        getAlignInBits(), getOffsetInBits(),\n                        getDWARFAddressSpace(), getFlags(), getExtraData());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIDerivedType,\n                    (unsigned Tag, MDString *Name, Metadata *File,\n                     unsigned Line, Metadata *Scope, Metadata *BaseType,\n                     uint64_t SizeInBits, uint32_t AlignInBits,\n                     uint64_t OffsetInBits,\n                     Optional<unsigned> DWARFAddressSpace, DIFlags Flags,\n                     Metadata *ExtraData = nullptr),\n                    (Tag, Name, File, Line, Scope, BaseType, SizeInBits,\n                     AlignInBits, OffsetInBits, DWARFAddressSpace, Flags,\n                     ExtraData))\n  DEFINE_MDNODE_GET(DIDerivedType,\n                    (unsigned Tag, StringRef Name, DIFile *File, unsigned Line,\n                     DIScope *Scope, DIType *BaseType, uint64_t SizeInBits,\n                     uint32_t AlignInBits, uint64_t OffsetInBits,\n                     Optional<unsigned> DWARFAddressSpace, DIFlags Flags,\n                     Metadata *ExtraData = nullptr),\n                    (Tag, Name, File, Line, Scope, BaseType, SizeInBits,\n                     AlignInBits, OffsetInBits, DWARFAddressSpace, Flags,\n                     ExtraData))\n\n  TempDIDerivedType clone() const { return cloneImpl(); }\n\n  /// Get the base type this is derived from.\n  DIType *getBaseType() const { return cast_or_null<DIType>(getRawBaseType()); }\n  Metadata *getRawBaseType() const { return getOperand(3); }\n\n  /// \\returns The DWARF address space of the memory pointed to or referenced by\n  /// a pointer or reference type respectively.\n  Optional<unsigned> getDWARFAddressSpace() const { return DWARFAddressSpace; }\n\n  /// Get extra data associated with this derived type.\n  ///\n  /// Class type for pointer-to-members, objective-c property node for ivars,\n  /// global constant wrapper for static members, or virtual base pointer offset\n  /// for inheritance.\n  ///\n  /// TODO: Separate out types that need this extra operand: pointer-to-member\n  /// types and member fields (static members and ivars).\n  Metadata *getExtraData() const { return getRawExtraData(); }\n  Metadata *getRawExtraData() const { return getOperand(4); }\n\n  /// Get casted version of extra data.\n  /// @{\n  DIType *getClassType() const {\n    assert(getTag() == dwarf::DW_TAG_ptr_to_member_type);\n    return cast_or_null<DIType>(getExtraData());\n  }\n\n  DIObjCProperty *getObjCProperty() const {\n    return dyn_cast_or_null<DIObjCProperty>(getExtraData());\n  }\n\n  uint32_t getVBPtrOffset() const {\n    assert(getTag() == dwarf::DW_TAG_inheritance);\n    if (auto *CM = cast_or_null<ConstantAsMetadata>(getExtraData()))\n      if (auto *CI = dyn_cast_or_null<ConstantInt>(CM->getValue()))\n        return static_cast<uint32_t>(CI->getZExtValue());\n    return 0;\n  }\n\n  Constant *getStorageOffsetInBits() const {\n    assert(getTag() == dwarf::DW_TAG_member && isBitField());\n    if (auto *C = cast_or_null<ConstantAsMetadata>(getExtraData()))\n      return C->getValue();\n    return nullptr;\n  }\n\n  Constant *getConstant() const {\n    assert(getTag() == dwarf::DW_TAG_member && isStaticMember());\n    if (auto *C = cast_or_null<ConstantAsMetadata>(getExtraData()))\n      return C->getValue();\n    return nullptr;\n  }\n  Constant *getDiscriminantValue() const {\n    assert(getTag() == dwarf::DW_TAG_member && !isStaticMember());\n    if (auto *C = cast_or_null<ConstantAsMetadata>(getExtraData()))\n      return C->getValue();\n    return nullptr;\n  }\n  /// @}\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIDerivedTypeKind;\n  }\n};\n\n/// Composite types.\n///\n/// TODO: Detach from DerivedTypeBase (split out MDEnumType?).\n/// TODO: Create a custom, unrelated node for DW_TAG_array_type.\nclass DICompositeType : public DIType {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned RuntimeLang;\n\n  DICompositeType(LLVMContext &C, StorageType Storage, unsigned Tag,\n                  unsigned Line, unsigned RuntimeLang, uint64_t SizeInBits,\n                  uint32_t AlignInBits, uint64_t OffsetInBits, DIFlags Flags,\n                  ArrayRef<Metadata *> Ops)\n      : DIType(C, DICompositeTypeKind, Storage, Tag, Line, SizeInBits,\n               AlignInBits, OffsetInBits, Flags, Ops),\n        RuntimeLang(RuntimeLang) {}\n  ~DICompositeType() = default;\n\n  /// Change fields in place.\n  void mutate(unsigned Tag, unsigned Line, unsigned RuntimeLang,\n              uint64_t SizeInBits, uint32_t AlignInBits,\n              uint64_t OffsetInBits, DIFlags Flags) {\n    assert(isDistinct() && \"Only distinct nodes can mutate\");\n    assert(getRawIdentifier() && \"Only ODR-uniqued nodes should mutate\");\n    this->RuntimeLang = RuntimeLang;\n    DIType::mutate(Tag, Line, SizeInBits, AlignInBits, OffsetInBits, Flags);\n  }\n\n  static DICompositeType *\n  getImpl(LLVMContext &Context, unsigned Tag, StringRef Name, Metadata *File,\n          unsigned Line, DIScope *Scope, DIType *BaseType, uint64_t SizeInBits,\n          uint32_t AlignInBits, uint64_t OffsetInBits, DIFlags Flags,\n          DINodeArray Elements, unsigned RuntimeLang, DIType *VTableHolder,\n          DITemplateParameterArray TemplateParams, StringRef Identifier,\n          DIDerivedType *Discriminator, Metadata *DataLocation,\n          Metadata *Associated, Metadata *Allocated, Metadata *Rank,\n          StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(\n        Context, Tag, getCanonicalMDString(Context, Name), File, Line, Scope,\n        BaseType, SizeInBits, AlignInBits, OffsetInBits, Flags, Elements.get(),\n        RuntimeLang, VTableHolder, TemplateParams.get(),\n        getCanonicalMDString(Context, Identifier), Discriminator, DataLocation,\n        Associated, Allocated, Rank, Storage, ShouldCreate);\n  }\n  static DICompositeType *\n  getImpl(LLVMContext &Context, unsigned Tag, MDString *Name, Metadata *File,\n          unsigned Line, Metadata *Scope, Metadata *BaseType,\n          uint64_t SizeInBits, uint32_t AlignInBits, uint64_t OffsetInBits,\n          DIFlags Flags, Metadata *Elements, unsigned RuntimeLang,\n          Metadata *VTableHolder, Metadata *TemplateParams,\n          MDString *Identifier, Metadata *Discriminator, Metadata *DataLocation,\n          Metadata *Associated, Metadata *Allocated, Metadata *Rank,\n          StorageType Storage, bool ShouldCreate = true);\n\n  TempDICompositeType cloneImpl() const {\n    return getTemporary(getContext(), getTag(), getName(), getFile(), getLine(),\n                        getScope(), getBaseType(), getSizeInBits(),\n                        getAlignInBits(), getOffsetInBits(), getFlags(),\n                        getElements(), getRuntimeLang(), getVTableHolder(),\n                        getTemplateParams(), getIdentifier(),\n                        getDiscriminator(), getRawDataLocation(),\n                        getRawAssociated(), getRawAllocated(), getRawRank());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(\n      DICompositeType,\n      (unsigned Tag, StringRef Name, DIFile *File, unsigned Line,\n       DIScope *Scope, DIType *BaseType, uint64_t SizeInBits,\n       uint32_t AlignInBits, uint64_t OffsetInBits, DIFlags Flags,\n       DINodeArray Elements, unsigned RuntimeLang, DIType *VTableHolder,\n       DITemplateParameterArray TemplateParams = nullptr,\n       StringRef Identifier = \"\", DIDerivedType *Discriminator = nullptr,\n       Metadata *DataLocation = nullptr, Metadata *Associated = nullptr,\n       Metadata *Allocated = nullptr, Metadata *Rank = nullptr),\n      (Tag, Name, File, Line, Scope, BaseType, SizeInBits, AlignInBits,\n       OffsetInBits, Flags, Elements, RuntimeLang, VTableHolder, TemplateParams,\n       Identifier, Discriminator, DataLocation, Associated, Allocated, Rank))\n  DEFINE_MDNODE_GET(\n      DICompositeType,\n      (unsigned Tag, MDString *Name, Metadata *File, unsigned Line,\n       Metadata *Scope, Metadata *BaseType, uint64_t SizeInBits,\n       uint32_t AlignInBits, uint64_t OffsetInBits, DIFlags Flags,\n       Metadata *Elements, unsigned RuntimeLang, Metadata *VTableHolder,\n       Metadata *TemplateParams = nullptr, MDString *Identifier = nullptr,\n       Metadata *Discriminator = nullptr, Metadata *DataLocation = nullptr,\n       Metadata *Associated = nullptr, Metadata *Allocated = nullptr,\n       Metadata *Rank = nullptr),\n      (Tag, Name, File, Line, Scope, BaseType, SizeInBits, AlignInBits,\n       OffsetInBits, Flags, Elements, RuntimeLang, VTableHolder, TemplateParams,\n       Identifier, Discriminator, DataLocation, Associated, Allocated, Rank))\n\n  TempDICompositeType clone() const { return cloneImpl(); }\n\n  /// Get a DICompositeType with the given ODR identifier.\n  ///\n  /// If \\a LLVMContext::isODRUniquingDebugTypes(), gets the mapped\n  /// DICompositeType for the given ODR \\c Identifier.  If none exists, creates\n  /// a new node.\n  ///\n  /// Else, returns \\c nullptr.\n  static DICompositeType *\n  getODRType(LLVMContext &Context, MDString &Identifier, unsigned Tag,\n             MDString *Name, Metadata *File, unsigned Line, Metadata *Scope,\n             Metadata *BaseType, uint64_t SizeInBits, uint32_t AlignInBits,\n             uint64_t OffsetInBits, DIFlags Flags, Metadata *Elements,\n             unsigned RuntimeLang, Metadata *VTableHolder,\n             Metadata *TemplateParams, Metadata *Discriminator,\n             Metadata *DataLocation, Metadata *Associated, Metadata *Allocated,\n             Metadata *Rank);\n  static DICompositeType *getODRTypeIfExists(LLVMContext &Context,\n                                             MDString &Identifier);\n\n  /// Build a DICompositeType with the given ODR identifier.\n  ///\n  /// Looks up the mapped DICompositeType for the given ODR \\c Identifier.  If\n  /// it doesn't exist, creates a new one.  If it does exist and \\a\n  /// isForwardDecl(), and the new arguments would be a definition, mutates the\n  /// the type in place.  In either case, returns the type.\n  ///\n  /// If not \\a LLVMContext::isODRUniquingDebugTypes(), this function returns\n  /// nullptr.\n  static DICompositeType *\n  buildODRType(LLVMContext &Context, MDString &Identifier, unsigned Tag,\n               MDString *Name, Metadata *File, unsigned Line, Metadata *Scope,\n               Metadata *BaseType, uint64_t SizeInBits, uint32_t AlignInBits,\n               uint64_t OffsetInBits, DIFlags Flags, Metadata *Elements,\n               unsigned RuntimeLang, Metadata *VTableHolder,\n               Metadata *TemplateParams, Metadata *Discriminator,\n               Metadata *DataLocation, Metadata *Associated,\n               Metadata *Allocated, Metadata *Rank);\n\n  DIType *getBaseType() const { return cast_or_null<DIType>(getRawBaseType()); }\n  DINodeArray getElements() const {\n    return cast_or_null<MDTuple>(getRawElements());\n  }\n  DIType *getVTableHolder() const {\n    return cast_or_null<DIType>(getRawVTableHolder());\n  }\n  DITemplateParameterArray getTemplateParams() const {\n    return cast_or_null<MDTuple>(getRawTemplateParams());\n  }\n  StringRef getIdentifier() const { return getStringOperand(7); }\n  unsigned getRuntimeLang() const { return RuntimeLang; }\n\n  Metadata *getRawBaseType() const { return getOperand(3); }\n  Metadata *getRawElements() const { return getOperand(4); }\n  Metadata *getRawVTableHolder() const { return getOperand(5); }\n  Metadata *getRawTemplateParams() const { return getOperand(6); }\n  MDString *getRawIdentifier() const { return getOperandAs<MDString>(7); }\n  Metadata *getRawDiscriminator() const { return getOperand(8); }\n  DIDerivedType *getDiscriminator() const { return getOperandAs<DIDerivedType>(8); }\n  Metadata *getRawDataLocation() const { return getOperand(9); }\n  DIVariable *getDataLocation() const {\n    return dyn_cast_or_null<DIVariable>(getRawDataLocation());\n  }\n  DIExpression *getDataLocationExp() const {\n    return dyn_cast_or_null<DIExpression>(getRawDataLocation());\n  }\n  Metadata *getRawAssociated() const { return getOperand(10); }\n  DIVariable *getAssociated() const {\n    return dyn_cast_or_null<DIVariable>(getRawAssociated());\n  }\n  DIExpression *getAssociatedExp() const {\n    return dyn_cast_or_null<DIExpression>(getRawAssociated());\n  }\n  Metadata *getRawAllocated() const { return getOperand(11); }\n  DIVariable *getAllocated() const {\n    return dyn_cast_or_null<DIVariable>(getRawAllocated());\n  }\n  DIExpression *getAllocatedExp() const {\n    return dyn_cast_or_null<DIExpression>(getRawAllocated());\n  }\n  Metadata *getRawRank() const { return getOperand(12); }\n  ConstantInt *getRankConst() const {\n    if (auto *MD = dyn_cast_or_null<ConstantAsMetadata>(getRawRank()))\n      return dyn_cast_or_null<ConstantInt>(MD->getValue());\n    return nullptr;\n  }\n  DIExpression *getRankExp() const {\n    return dyn_cast_or_null<DIExpression>(getRawRank());\n  }\n\n  /// Replace operands.\n  ///\n  /// If this \\a isUniqued() and not \\a isResolved(), on a uniquing collision\n  /// this will be RAUW'ed and deleted.  Use a \\a TrackingMDRef to keep track\n  /// of its movement if necessary.\n  /// @{\n  void replaceElements(DINodeArray Elements) {\n#ifndef NDEBUG\n    for (DINode *Op : getElements())\n      assert(is_contained(Elements->operands(), Op) &&\n             \"Lost a member during member list replacement\");\n#endif\n    replaceOperandWith(4, Elements.get());\n  }\n\n  void replaceVTableHolder(DIType *VTableHolder) {\n    replaceOperandWith(5, VTableHolder);\n  }\n\n  void replaceTemplateParams(DITemplateParameterArray TemplateParams) {\n    replaceOperandWith(6, TemplateParams.get());\n  }\n  /// @}\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DICompositeTypeKind;\n  }\n};\n\n/// Type array for a subprogram.\n///\n/// TODO: Fold the array of types in directly as operands.\nclass DISubroutineType : public DIType {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  /// The calling convention used with DW_AT_calling_convention. Actually of\n  /// type dwarf::CallingConvention.\n  uint8_t CC;\n\n  DISubroutineType(LLVMContext &C, StorageType Storage, DIFlags Flags,\n                   uint8_t CC, ArrayRef<Metadata *> Ops)\n      : DIType(C, DISubroutineTypeKind, Storage, dwarf::DW_TAG_subroutine_type,\n               0, 0, 0, 0, Flags, Ops),\n        CC(CC) {}\n  ~DISubroutineType() = default;\n\n  static DISubroutineType *getImpl(LLVMContext &Context, DIFlags Flags,\n                                   uint8_t CC, DITypeRefArray TypeArray,\n                                   StorageType Storage,\n                                   bool ShouldCreate = true) {\n    return getImpl(Context, Flags, CC, TypeArray.get(), Storage, ShouldCreate);\n  }\n  static DISubroutineType *getImpl(LLVMContext &Context, DIFlags Flags,\n                                   uint8_t CC, Metadata *TypeArray,\n                                   StorageType Storage,\n                                   bool ShouldCreate = true);\n\n  TempDISubroutineType cloneImpl() const {\n    return getTemporary(getContext(), getFlags(), getCC(), getTypeArray());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DISubroutineType,\n                    (DIFlags Flags, uint8_t CC, DITypeRefArray TypeArray),\n                    (Flags, CC, TypeArray))\n  DEFINE_MDNODE_GET(DISubroutineType,\n                    (DIFlags Flags, uint8_t CC, Metadata *TypeArray),\n                    (Flags, CC, TypeArray))\n\n  TempDISubroutineType clone() const { return cloneImpl(); }\n\n  uint8_t getCC() const { return CC; }\n\n  DITypeRefArray getTypeArray() const {\n    return cast_or_null<MDTuple>(getRawTypeArray());\n  }\n\n  Metadata *getRawTypeArray() const { return getOperand(3); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DISubroutineTypeKind;\n  }\n};\n\n/// Compile unit.\nclass DICompileUnit : public DIScope {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\npublic:\n  enum DebugEmissionKind : unsigned {\n    NoDebug = 0,\n    FullDebug,\n    LineTablesOnly,\n    DebugDirectivesOnly,\n    LastEmissionKind = DebugDirectivesOnly\n  };\n\n  enum class DebugNameTableKind : unsigned {\n    Default = 0,\n    GNU = 1,\n    None = 2,\n    LastDebugNameTableKind = None\n  };\n\n  static Optional<DebugEmissionKind> getEmissionKind(StringRef Str);\n  static const char *emissionKindString(DebugEmissionKind EK);\n  static Optional<DebugNameTableKind> getNameTableKind(StringRef Str);\n  static const char *nameTableKindString(DebugNameTableKind PK);\n\nprivate:\n  unsigned SourceLanguage;\n  bool IsOptimized;\n  unsigned RuntimeVersion;\n  unsigned EmissionKind;\n  uint64_t DWOId;\n  bool SplitDebugInlining;\n  bool DebugInfoForProfiling;\n  unsigned NameTableKind;\n  bool RangesBaseAddress;\n\n  DICompileUnit(LLVMContext &C, StorageType Storage, unsigned SourceLanguage,\n                bool IsOptimized, unsigned RuntimeVersion,\n                unsigned EmissionKind, uint64_t DWOId, bool SplitDebugInlining,\n                bool DebugInfoForProfiling, unsigned NameTableKind,\n                bool RangesBaseAddress, ArrayRef<Metadata *> Ops)\n      : DIScope(C, DICompileUnitKind, Storage, dwarf::DW_TAG_compile_unit, Ops),\n        SourceLanguage(SourceLanguage), IsOptimized(IsOptimized),\n        RuntimeVersion(RuntimeVersion), EmissionKind(EmissionKind),\n        DWOId(DWOId), SplitDebugInlining(SplitDebugInlining),\n        DebugInfoForProfiling(DebugInfoForProfiling),\n        NameTableKind(NameTableKind), RangesBaseAddress(RangesBaseAddress) {\n    assert(Storage != Uniqued);\n  }\n  ~DICompileUnit() = default;\n\n  static DICompileUnit *\n  getImpl(LLVMContext &Context, unsigned SourceLanguage, DIFile *File,\n          StringRef Producer, bool IsOptimized, StringRef Flags,\n          unsigned RuntimeVersion, StringRef SplitDebugFilename,\n          unsigned EmissionKind, DICompositeTypeArray EnumTypes,\n          DIScopeArray RetainedTypes,\n          DIGlobalVariableExpressionArray GlobalVariables,\n          DIImportedEntityArray ImportedEntities, DIMacroNodeArray Macros,\n          uint64_t DWOId, bool SplitDebugInlining, bool DebugInfoForProfiling,\n          unsigned NameTableKind, bool RangesBaseAddress, StringRef SysRoot,\n          StringRef SDK, StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(\n        Context, SourceLanguage, File, getCanonicalMDString(Context, Producer),\n        IsOptimized, getCanonicalMDString(Context, Flags), RuntimeVersion,\n        getCanonicalMDString(Context, SplitDebugFilename), EmissionKind,\n        EnumTypes.get(), RetainedTypes.get(), GlobalVariables.get(),\n        ImportedEntities.get(), Macros.get(), DWOId, SplitDebugInlining,\n        DebugInfoForProfiling, NameTableKind, RangesBaseAddress,\n        getCanonicalMDString(Context, SysRoot),\n        getCanonicalMDString(Context, SDK), Storage, ShouldCreate);\n  }\n  static DICompileUnit *\n  getImpl(LLVMContext &Context, unsigned SourceLanguage, Metadata *File,\n          MDString *Producer, bool IsOptimized, MDString *Flags,\n          unsigned RuntimeVersion, MDString *SplitDebugFilename,\n          unsigned EmissionKind, Metadata *EnumTypes, Metadata *RetainedTypes,\n          Metadata *GlobalVariables, Metadata *ImportedEntities,\n          Metadata *Macros, uint64_t DWOId, bool SplitDebugInlining,\n          bool DebugInfoForProfiling, unsigned NameTableKind,\n          bool RangesBaseAddress, MDString *SysRoot, MDString *SDK,\n          StorageType Storage, bool ShouldCreate = true);\n\n  TempDICompileUnit cloneImpl() const {\n    return getTemporary(\n        getContext(), getSourceLanguage(), getFile(), getProducer(),\n        isOptimized(), getFlags(), getRuntimeVersion(), getSplitDebugFilename(),\n        getEmissionKind(), getEnumTypes(), getRetainedTypes(),\n        getGlobalVariables(), getImportedEntities(), getMacros(), DWOId,\n        getSplitDebugInlining(), getDebugInfoForProfiling(), getNameTableKind(),\n        getRangesBaseAddress(), getSysRoot(), getSDK());\n  }\n\npublic:\n  static void get() = delete;\n  static void getIfExists() = delete;\n\n  DEFINE_MDNODE_GET_DISTINCT_TEMPORARY(\n      DICompileUnit,\n      (unsigned SourceLanguage, DIFile *File, StringRef Producer,\n       bool IsOptimized, StringRef Flags, unsigned RuntimeVersion,\n       StringRef SplitDebugFilename, DebugEmissionKind EmissionKind,\n       DICompositeTypeArray EnumTypes, DIScopeArray RetainedTypes,\n       DIGlobalVariableExpressionArray GlobalVariables,\n       DIImportedEntityArray ImportedEntities, DIMacroNodeArray Macros,\n       uint64_t DWOId, bool SplitDebugInlining, bool DebugInfoForProfiling,\n       DebugNameTableKind NameTableKind, bool RangesBaseAddress,\n       StringRef SysRoot, StringRef SDK),\n      (SourceLanguage, File, Producer, IsOptimized, Flags, RuntimeVersion,\n       SplitDebugFilename, EmissionKind, EnumTypes, RetainedTypes,\n       GlobalVariables, ImportedEntities, Macros, DWOId, SplitDebugInlining,\n       DebugInfoForProfiling, (unsigned)NameTableKind, RangesBaseAddress,\n       SysRoot, SDK))\n  DEFINE_MDNODE_GET_DISTINCT_TEMPORARY(\n      DICompileUnit,\n      (unsigned SourceLanguage, Metadata *File, MDString *Producer,\n       bool IsOptimized, MDString *Flags, unsigned RuntimeVersion,\n       MDString *SplitDebugFilename, unsigned EmissionKind, Metadata *EnumTypes,\n       Metadata *RetainedTypes, Metadata *GlobalVariables,\n       Metadata *ImportedEntities, Metadata *Macros, uint64_t DWOId,\n       bool SplitDebugInlining, bool DebugInfoForProfiling,\n       unsigned NameTableKind, bool RangesBaseAddress, MDString *SysRoot,\n       MDString *SDK),\n      (SourceLanguage, File, Producer, IsOptimized, Flags, RuntimeVersion,\n       SplitDebugFilename, EmissionKind, EnumTypes, RetainedTypes,\n       GlobalVariables, ImportedEntities, Macros, DWOId, SplitDebugInlining,\n       DebugInfoForProfiling, NameTableKind, RangesBaseAddress, SysRoot, SDK))\n\n  TempDICompileUnit clone() const { return cloneImpl(); }\n\n  unsigned getSourceLanguage() const { return SourceLanguage; }\n  bool isOptimized() const { return IsOptimized; }\n  unsigned getRuntimeVersion() const { return RuntimeVersion; }\n  DebugEmissionKind getEmissionKind() const {\n    return (DebugEmissionKind)EmissionKind;\n  }\n  bool isDebugDirectivesOnly() const {\n    return EmissionKind == DebugDirectivesOnly;\n  }\n  bool getDebugInfoForProfiling() const { return DebugInfoForProfiling; }\n  DebugNameTableKind getNameTableKind() const {\n    return (DebugNameTableKind)NameTableKind;\n  }\n  bool getRangesBaseAddress() const { return RangesBaseAddress; }\n  StringRef getProducer() const { return getStringOperand(1); }\n  StringRef getFlags() const { return getStringOperand(2); }\n  StringRef getSplitDebugFilename() const { return getStringOperand(3); }\n  DICompositeTypeArray getEnumTypes() const {\n    return cast_or_null<MDTuple>(getRawEnumTypes());\n  }\n  DIScopeArray getRetainedTypes() const {\n    return cast_or_null<MDTuple>(getRawRetainedTypes());\n  }\n  DIGlobalVariableExpressionArray getGlobalVariables() const {\n    return cast_or_null<MDTuple>(getRawGlobalVariables());\n  }\n  DIImportedEntityArray getImportedEntities() const {\n    return cast_or_null<MDTuple>(getRawImportedEntities());\n  }\n  DIMacroNodeArray getMacros() const {\n    return cast_or_null<MDTuple>(getRawMacros());\n  }\n  uint64_t getDWOId() const { return DWOId; }\n  void setDWOId(uint64_t DwoId) { DWOId = DwoId; }\n  bool getSplitDebugInlining() const { return SplitDebugInlining; }\n  void setSplitDebugInlining(bool SplitDebugInlining) {\n    this->SplitDebugInlining = SplitDebugInlining;\n  }\n  StringRef getSysRoot() const { return getStringOperand(9); }\n  StringRef getSDK() const { return getStringOperand(10); }\n\n  MDString *getRawProducer() const { return getOperandAs<MDString>(1); }\n  MDString *getRawFlags() const { return getOperandAs<MDString>(2); }\n  MDString *getRawSplitDebugFilename() const {\n    return getOperandAs<MDString>(3);\n  }\n  Metadata *getRawEnumTypes() const { return getOperand(4); }\n  Metadata *getRawRetainedTypes() const { return getOperand(5); }\n  Metadata *getRawGlobalVariables() const { return getOperand(6); }\n  Metadata *getRawImportedEntities() const { return getOperand(7); }\n  Metadata *getRawMacros() const { return getOperand(8); }\n  MDString *getRawSysRoot() const { return getOperandAs<MDString>(9); }\n  MDString *getRawSDK() const { return getOperandAs<MDString>(10); }\n\n  /// Replace arrays.\n  ///\n  /// If this \\a isUniqued() and not \\a isResolved(), it will be RAUW'ed and\n  /// deleted on a uniquing collision.  In practice, uniquing collisions on \\a\n  /// DICompileUnit should be fairly rare.\n  /// @{\n  void replaceEnumTypes(DICompositeTypeArray N) {\n    replaceOperandWith(4, N.get());\n  }\n  void replaceRetainedTypes(DITypeArray N) {\n    replaceOperandWith(5, N.get());\n  }\n  void replaceGlobalVariables(DIGlobalVariableExpressionArray N) {\n    replaceOperandWith(6, N.get());\n  }\n  void replaceImportedEntities(DIImportedEntityArray N) {\n    replaceOperandWith(7, N.get());\n  }\n  void replaceMacros(DIMacroNodeArray N) { replaceOperandWith(8, N.get()); }\n  /// @}\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DICompileUnitKind;\n  }\n};\n\n/// A scope for locals.\n///\n/// A legal scope for lexical blocks, local variables, and debug info\n/// locations.  Subclasses are \\a DISubprogram, \\a DILexicalBlock, and \\a\n/// DILexicalBlockFile.\nclass DILocalScope : public DIScope {\nprotected:\n  DILocalScope(LLVMContext &C, unsigned ID, StorageType Storage, unsigned Tag,\n               ArrayRef<Metadata *> Ops)\n      : DIScope(C, ID, Storage, Tag, Ops) {}\n  ~DILocalScope() = default;\n\npublic:\n  /// Get the subprogram for this scope.\n  ///\n  /// Return this if it's an \\a DISubprogram; otherwise, look up the scope\n  /// chain.\n  DISubprogram *getSubprogram() const;\n\n  /// Get the first non DILexicalBlockFile scope of this scope.\n  ///\n  /// Return this if it's not a \\a DILexicalBlockFIle; otherwise, look up the\n  /// scope chain.\n  DILocalScope *getNonLexicalBlockFileScope() const;\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DISubprogramKind ||\n           MD->getMetadataID() == DILexicalBlockKind ||\n           MD->getMetadataID() == DILexicalBlockFileKind;\n  }\n};\n\n/// Debug location.\n///\n/// A debug location in source code, used for debug info and otherwise.\nclass DILocation : public MDNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  DILocation(LLVMContext &C, StorageType Storage, unsigned Line,\n             unsigned Column, ArrayRef<Metadata *> MDs, bool ImplicitCode);\n  ~DILocation() { dropAllReferences(); }\n\n  static DILocation *getImpl(LLVMContext &Context, unsigned Line,\n                             unsigned Column, Metadata *Scope,\n                             Metadata *InlinedAt, bool ImplicitCode,\n                             StorageType Storage, bool ShouldCreate = true);\n  static DILocation *getImpl(LLVMContext &Context, unsigned Line,\n                             unsigned Column, DILocalScope *Scope,\n                             DILocation *InlinedAt, bool ImplicitCode,\n                             StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, Line, Column, static_cast<Metadata *>(Scope),\n                   static_cast<Metadata *>(InlinedAt), ImplicitCode, Storage,\n                   ShouldCreate);\n  }\n\n  /// With a given unsigned int \\p U, use up to 13 bits to represent it.\n  /// old_bit 1~5  --> new_bit 1~5\n  /// old_bit 6~12 --> new_bit 7~13\n  /// new_bit_6 is 0 if higher bits (7~13) are all 0\n  static unsigned getPrefixEncodingFromUnsigned(unsigned U) {\n    U &= 0xfff;\n    return U > 0x1f ? (((U & 0xfe0) << 1) | (U & 0x1f) | 0x20) : U;\n  }\n\n  /// Reverse transformation as getPrefixEncodingFromUnsigned.\n  static unsigned getUnsignedFromPrefixEncoding(unsigned U) {\n    if (U & 1)\n      return 0;\n    U >>= 1;\n    return (U & 0x20) ? (((U >> 1) & 0xfe0) | (U & 0x1f)) : (U & 0x1f);\n  }\n\n  /// Returns the next component stored in discriminator.\n  static unsigned getNextComponentInDiscriminator(unsigned D) {\n    if ((D & 1) == 0)\n      return D >> ((D & 0x40) ? 14 : 7);\n    else\n      return D >> 1;\n  }\n\n  TempDILocation cloneImpl() const {\n    // Get the raw scope/inlinedAt since it is possible to invoke this on\n    // a DILocation containing temporary metadata.\n    return getTemporary(getContext(), getLine(), getColumn(), getRawScope(),\n                        getRawInlinedAt(), isImplicitCode());\n  }\n\n  static unsigned encodeComponent(unsigned C) {\n    return (C == 0) ? 1U : (getPrefixEncodingFromUnsigned(C) << 1);\n  }\n\n  static unsigned encodingBits(unsigned C) {\n    return (C == 0) ? 1 : (C > 0x1f ? 14 : 7);\n  }\n\npublic:\n  // Disallow replacing operands.\n  void replaceOperandWith(unsigned I, Metadata *New) = delete;\n\n  DEFINE_MDNODE_GET(DILocation,\n                    (unsigned Line, unsigned Column, Metadata *Scope,\n                     Metadata *InlinedAt = nullptr, bool ImplicitCode = false),\n                    (Line, Column, Scope, InlinedAt, ImplicitCode))\n  DEFINE_MDNODE_GET(DILocation,\n                    (unsigned Line, unsigned Column, DILocalScope *Scope,\n                     DILocation *InlinedAt = nullptr,\n                     bool ImplicitCode = false),\n                    (Line, Column, Scope, InlinedAt, ImplicitCode))\n\n  /// Return a (temporary) clone of this.\n  TempDILocation clone() const { return cloneImpl(); }\n\n  unsigned getLine() const { return SubclassData32; }\n  unsigned getColumn() const { return SubclassData16; }\n  DILocalScope *getScope() const { return cast<DILocalScope>(getRawScope()); }\n\n  DILocation *getInlinedAt() const {\n    return cast_or_null<DILocation>(getRawInlinedAt());\n  }\n\n  /// Check if the location corresponds to an implicit code.\n  /// When the ImplicitCode flag is true, it means that the Instruction\n  /// with this DILocation has been added by the front-end but it hasn't been\n  /// written explicitly by the user (e.g. cleanup stuff in C++ put on a closing\n  /// bracket). It's useful for code coverage to not show a counter on \"empty\"\n  /// lines.\n  bool isImplicitCode() const { return SubclassData1; }\n  void setImplicitCode(bool ImplicitCode) { SubclassData1 = ImplicitCode; }\n\n  DIFile *getFile() const { return getScope()->getFile(); }\n  StringRef getFilename() const { return getScope()->getFilename(); }\n  StringRef getDirectory() const { return getScope()->getDirectory(); }\n  Optional<StringRef> getSource() const { return getScope()->getSource(); }\n\n  /// Get the scope where this is inlined.\n  ///\n  /// Walk through \\a getInlinedAt() and return \\a getScope() from the deepest\n  /// location.\n  DILocalScope *getInlinedAtScope() const {\n    if (auto *IA = getInlinedAt())\n      return IA->getInlinedAtScope();\n    return getScope();\n  }\n\n  /// Get the DWARF discriminator.\n  ///\n  /// DWARF discriminators distinguish identical file locations between\n  /// instructions that are on different basic blocks.\n  ///\n  /// There are 3 components stored in discriminator, from lower bits:\n  ///\n  /// Base discriminator: assigned by AddDiscriminators pass to identify IRs\n  ///                     that are defined by the same source line, but\n  ///                     different basic blocks.\n  /// Duplication factor: assigned by optimizations that will scale down\n  ///                     the execution frequency of the original IR.\n  /// Copy Identifier: assigned by optimizations that clones the IR.\n  ///                  Each copy of the IR will be assigned an identifier.\n  ///\n  /// Encoding:\n  ///\n  /// The above 3 components are encoded into a 32bit unsigned integer in\n  /// order. If the lowest bit is 1, the current component is empty, and the\n  /// next component will start in the next bit. Otherwise, the current\n  /// component is non-empty, and its content starts in the next bit. The\n  /// value of each components is either 5 bit or 12 bit: if the 7th bit\n  /// is 0, the bit 2~6 (5 bits) are used to represent the component; if the\n  /// 7th bit is 1, the bit 2~6 (5 bits) and 8~14 (7 bits) are combined to\n  /// represent the component. Thus, the number of bits used for a component\n  /// is either 0 (if it and all the next components are empty); 1 - if it is\n  /// empty; 7 - if its value is up to and including 0x1f (lsb and msb are both\n  /// 0); or 14, if its value is up to and including 0x1ff. Note that the last\n  /// component is also capped at 0x1ff, even in the case when both first\n  /// components are 0, and we'd technically have 29 bits available.\n  ///\n  /// For precise control over the data being encoded in the discriminator,\n  /// use encodeDiscriminator/decodeDiscriminator.\n\n  inline unsigned getDiscriminator() const;\n\n  // For the regular discriminator, it stands for all empty components if all\n  // the lowest 3 bits are non-zero and all higher 29 bits are unused(zero by\n  // default). Here we fully leverage the higher 29 bits for pseudo probe use.\n  // This is the format:\n  // [2:0] - 0x7\n  // [31:3] - pseudo probe fields guaranteed to be non-zero as a whole\n  // So if the lower 3 bits is non-zero and the others has at least one\n  // non-zero bit, it guarantees to be a pseudo probe discriminator\n  inline static bool isPseudoProbeDiscriminator(unsigned Discriminator) {\n    return ((Discriminator & 0x7) == 0x7) && (Discriminator & 0xFFFFFFF8);\n  }\n\n  /// Returns a new DILocation with updated \\p Discriminator.\n  inline const DILocation *cloneWithDiscriminator(unsigned Discriminator) const;\n\n  /// Returns a new DILocation with updated base discriminator \\p BD. Only the\n  /// base discriminator is set in the new DILocation, the other encoded values\n  /// are elided.\n  /// If the discriminator cannot be encoded, the function returns None.\n  inline Optional<const DILocation *> cloneWithBaseDiscriminator(unsigned BD) const;\n\n  /// Returns the duplication factor stored in the discriminator, or 1 if no\n  /// duplication factor (or 0) is encoded.\n  inline unsigned getDuplicationFactor() const;\n\n  /// Returns the copy identifier stored in the discriminator.\n  inline unsigned getCopyIdentifier() const;\n\n  /// Returns the base discriminator stored in the discriminator.\n  inline unsigned getBaseDiscriminator() const;\n\n  /// Returns a new DILocation with duplication factor \\p DF * current\n  /// duplication factor encoded in the discriminator. The current duplication\n  /// factor is as defined by getDuplicationFactor().\n  /// Returns None if encoding failed.\n  inline Optional<const DILocation *> cloneByMultiplyingDuplicationFactor(unsigned DF) const;\n\n  /// When two instructions are combined into a single instruction we also\n  /// need to combine the original locations into a single location.\n  ///\n  /// When the locations are the same we can use either location. When they\n  /// differ, we need a third location which is distinct from either. If they\n  /// have the same file/line but have a different discriminator we could\n  /// create a location with a new discriminator. If they are from different\n  /// files/lines the location is ambiguous and can't be represented in a line\n  /// entry. In this case, if \\p GenerateLocation is true, we will set the\n  /// merged debug location as line 0 of the nearest common scope where the two\n  /// locations are inlined from.\n  ///\n  /// \\p GenerateLocation: Whether the merged location can be generated when\n  /// \\p LocA and \\p LocB differ.\n  static const DILocation *getMergedLocation(const DILocation *LocA,\n                                             const DILocation *LocB);\n\n  /// Try to combine the vector of locations passed as input in a single one.\n  /// This function applies getMergedLocation() repeatedly left-to-right.\n  ///\n  /// \\p Locs: The locations to be merged.\n  static\n  const DILocation *getMergedLocations(ArrayRef<const DILocation *> Locs);\n\n  /// Returns the base discriminator for a given encoded discriminator \\p D.\n  static unsigned getBaseDiscriminatorFromDiscriminator(unsigned D) {\n    return getUnsignedFromPrefixEncoding(D);\n  }\n\n  /// Raw encoding of the discriminator. APIs such as cloneWithDuplicationFactor\n  /// have certain special case behavior (e.g. treating empty duplication factor\n  /// as the value '1').\n  /// This API, in conjunction with cloneWithDiscriminator, may be used to encode\n  /// the raw values provided. \\p BD: base discriminator \\p DF: duplication factor\n  /// \\p CI: copy index\n  /// The return is None if the values cannot be encoded in 32 bits - for\n  /// example, values for BD or DF larger than 12 bits. Otherwise, the return\n  /// is the encoded value.\n  static Optional<unsigned> encodeDiscriminator(unsigned BD, unsigned DF, unsigned CI);\n\n  /// Raw decoder for values in an encoded discriminator D.\n  static void decodeDiscriminator(unsigned D, unsigned &BD, unsigned &DF,\n                                  unsigned &CI);\n\n  /// Returns the duplication factor for a given encoded discriminator \\p D, or\n  /// 1 if no value or 0 is encoded.\n  static unsigned getDuplicationFactorFromDiscriminator(unsigned D) {\n    D = getNextComponentInDiscriminator(D);\n    unsigned Ret = getUnsignedFromPrefixEncoding(D);\n    if (Ret == 0)\n      return 1;\n    return Ret;\n  }\n\n  /// Returns the copy identifier for a given encoded discriminator \\p D.\n  static unsigned getCopyIdentifierFromDiscriminator(unsigned D) {\n    return getUnsignedFromPrefixEncoding(getNextComponentInDiscriminator(\n        getNextComponentInDiscriminator(D)));\n  }\n\n\n  Metadata *getRawScope() const { return getOperand(0); }\n  Metadata *getRawInlinedAt() const {\n    if (getNumOperands() == 2)\n      return getOperand(1);\n    return nullptr;\n  }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DILocationKind;\n  }\n};\n\n/// Subprogram description.\nclass DISubprogram : public DILocalScope {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Line;\n  unsigned ScopeLine;\n  unsigned VirtualIndex;\n\n  /// In the MS ABI, the implicit 'this' parameter is adjusted in the prologue\n  /// of method overrides from secondary bases by this amount. It may be\n  /// negative.\n  int ThisAdjustment;\n\npublic:\n  /// Debug info subprogram flags.\n  enum DISPFlags : uint32_t {\n#define HANDLE_DISP_FLAG(ID, NAME) SPFlag##NAME = ID,\n#define DISP_FLAG_LARGEST_NEEDED\n#include \"llvm/IR/DebugInfoFlags.def\"\n    SPFlagNonvirtual = SPFlagZero,\n    SPFlagVirtuality = SPFlagVirtual | SPFlagPureVirtual,\n    LLVM_MARK_AS_BITMASK_ENUM(SPFlagLargest)\n  };\n\n  static DISPFlags getFlag(StringRef Flag);\n  static StringRef getFlagString(DISPFlags Flag);\n\n  /// Split up a flags bitfield for easier printing.\n  ///\n  /// Split \\c Flags into \\c SplitFlags, a vector of its components.  Returns\n  /// any remaining (unrecognized) bits.\n  static DISPFlags splitFlags(DISPFlags Flags,\n                              SmallVectorImpl<DISPFlags> &SplitFlags);\n\n  // Helper for converting old bitfields to new flags word.\n  static DISPFlags toSPFlags(bool IsLocalToUnit, bool IsDefinition,\n                             bool IsOptimized,\n                             unsigned Virtuality = SPFlagNonvirtual,\n                             bool IsMainSubprogram = false) {\n    // We're assuming virtuality is the low-order field.\n    static_assert(\n        int(SPFlagVirtual) == int(dwarf::DW_VIRTUALITY_virtual) &&\n            int(SPFlagPureVirtual) == int(dwarf::DW_VIRTUALITY_pure_virtual),\n        \"Virtuality constant mismatch\");\n    return static_cast<DISPFlags>(\n        (Virtuality & SPFlagVirtuality) |\n        (IsLocalToUnit ? SPFlagLocalToUnit : SPFlagZero) |\n        (IsDefinition ? SPFlagDefinition : SPFlagZero) |\n        (IsOptimized ? SPFlagOptimized : SPFlagZero) |\n        (IsMainSubprogram ? SPFlagMainSubprogram : SPFlagZero));\n  }\n\nprivate:\n  DIFlags Flags;\n  DISPFlags SPFlags;\n\n  DISubprogram(LLVMContext &C, StorageType Storage, unsigned Line,\n               unsigned ScopeLine, unsigned VirtualIndex, int ThisAdjustment,\n               DIFlags Flags, DISPFlags SPFlags, ArrayRef<Metadata *> Ops)\n      : DILocalScope(C, DISubprogramKind, Storage, dwarf::DW_TAG_subprogram,\n                     Ops),\n        Line(Line), ScopeLine(ScopeLine), VirtualIndex(VirtualIndex),\n        ThisAdjustment(ThisAdjustment), Flags(Flags), SPFlags(SPFlags) {\n    static_assert(dwarf::DW_VIRTUALITY_max < 4, \"Virtuality out of range\");\n  }\n  ~DISubprogram() = default;\n\n  static DISubprogram *\n  getImpl(LLVMContext &Context, DIScope *Scope, StringRef Name,\n          StringRef LinkageName, DIFile *File, unsigned Line,\n          DISubroutineType *Type, unsigned ScopeLine, DIType *ContainingType,\n          unsigned VirtualIndex, int ThisAdjustment, DIFlags Flags,\n          DISPFlags SPFlags, DICompileUnit *Unit,\n          DITemplateParameterArray TemplateParams, DISubprogram *Declaration,\n          DINodeArray RetainedNodes, DITypeArray ThrownTypes,\n          StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, Scope, getCanonicalMDString(Context, Name),\n                   getCanonicalMDString(Context, LinkageName), File, Line, Type,\n                   ScopeLine, ContainingType, VirtualIndex, ThisAdjustment,\n                   Flags, SPFlags, Unit, TemplateParams.get(), Declaration,\n                   RetainedNodes.get(), ThrownTypes.get(), Storage,\n                   ShouldCreate);\n  }\n  static DISubprogram *getImpl(LLVMContext &Context, Metadata *Scope,\n                               MDString *Name, MDString *LinkageName,\n                               Metadata *File, unsigned Line, Metadata *Type,\n                               unsigned ScopeLine, Metadata *ContainingType,\n                               unsigned VirtualIndex, int ThisAdjustment,\n                               DIFlags Flags, DISPFlags SPFlags, Metadata *Unit,\n                               Metadata *TemplateParams, Metadata *Declaration,\n                               Metadata *RetainedNodes, Metadata *ThrownTypes,\n                               StorageType Storage, bool ShouldCreate = true);\n\n  TempDISubprogram cloneImpl() const {\n    return getTemporary(getContext(), getScope(), getName(), getLinkageName(),\n                        getFile(), getLine(), getType(), getScopeLine(),\n                        getContainingType(), getVirtualIndex(),\n                        getThisAdjustment(), getFlags(), getSPFlags(),\n                        getUnit(), getTemplateParams(), getDeclaration(),\n                        getRetainedNodes(), getThrownTypes());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(\n      DISubprogram,\n      (DIScope * Scope, StringRef Name, StringRef LinkageName, DIFile *File,\n       unsigned Line, DISubroutineType *Type, unsigned ScopeLine,\n       DIType *ContainingType, unsigned VirtualIndex, int ThisAdjustment,\n       DIFlags Flags, DISPFlags SPFlags, DICompileUnit *Unit,\n       DITemplateParameterArray TemplateParams = nullptr,\n       DISubprogram *Declaration = nullptr, DINodeArray RetainedNodes = nullptr,\n       DITypeArray ThrownTypes = nullptr),\n      (Scope, Name, LinkageName, File, Line, Type, ScopeLine, ContainingType,\n       VirtualIndex, ThisAdjustment, Flags, SPFlags, Unit, TemplateParams,\n       Declaration, RetainedNodes, ThrownTypes))\n\n  DEFINE_MDNODE_GET(\n      DISubprogram,\n      (Metadata * Scope, MDString *Name, MDString *LinkageName, Metadata *File,\n       unsigned Line, Metadata *Type, unsigned ScopeLine,\n       Metadata *ContainingType, unsigned VirtualIndex, int ThisAdjustment,\n       DIFlags Flags, DISPFlags SPFlags, Metadata *Unit,\n       Metadata *TemplateParams = nullptr, Metadata *Declaration = nullptr,\n       Metadata *RetainedNodes = nullptr, Metadata *ThrownTypes = nullptr),\n      (Scope, Name, LinkageName, File, Line, Type, ScopeLine, ContainingType,\n       VirtualIndex, ThisAdjustment, Flags, SPFlags, Unit, TemplateParams,\n       Declaration, RetainedNodes, ThrownTypes))\n\n  TempDISubprogram clone() const { return cloneImpl(); }\n\n  /// Returns a new temporary DISubprogram with updated Flags\n  TempDISubprogram cloneWithFlags(DIFlags NewFlags) const {\n    auto NewSP = clone();\n    NewSP->Flags = NewFlags;\n    return NewSP;\n  }\n\npublic:\n  unsigned getLine() const { return Line; }\n  unsigned getVirtuality() const { return getSPFlags() & SPFlagVirtuality; }\n  unsigned getVirtualIndex() const { return VirtualIndex; }\n  int getThisAdjustment() const { return ThisAdjustment; }\n  unsigned getScopeLine() const { return ScopeLine; }\n  void setScopeLine(unsigned L) { assert(isDistinct()); ScopeLine = L; }\n  DIFlags getFlags() const { return Flags; }\n  DISPFlags getSPFlags() const { return SPFlags; }\n  bool isLocalToUnit() const { return getSPFlags() & SPFlagLocalToUnit; }\n  bool isDefinition() const { return getSPFlags() & SPFlagDefinition; }\n  bool isOptimized() const { return getSPFlags() & SPFlagOptimized; }\n  bool isMainSubprogram() const { return getSPFlags() & SPFlagMainSubprogram; }\n\n  bool isArtificial() const { return getFlags() & FlagArtificial; }\n  bool isPrivate() const {\n    return (getFlags() & FlagAccessibility) == FlagPrivate;\n  }\n  bool isProtected() const {\n    return (getFlags() & FlagAccessibility) == FlagProtected;\n  }\n  bool isPublic() const {\n    return (getFlags() & FlagAccessibility) == FlagPublic;\n  }\n  bool isExplicit() const { return getFlags() & FlagExplicit; }\n  bool isPrototyped() const { return getFlags() & FlagPrototyped; }\n  bool areAllCallsDescribed() const {\n    return getFlags() & FlagAllCallsDescribed;\n  }\n  bool isPure() const { return getSPFlags() & SPFlagPure; }\n  bool isElemental() const { return getSPFlags() & SPFlagElemental; }\n  bool isRecursive() const { return getSPFlags() & SPFlagRecursive; }\n  bool isObjCDirect() const { return getSPFlags() & SPFlagObjCDirect; }\n\n  /// Check if this is deleted member function.\n  ///\n  /// Return true if this subprogram is a C++11 special\n  /// member function declared deleted.\n  bool isDeleted() const { return getSPFlags() & SPFlagDeleted; }\n\n  /// Check if this is reference-qualified.\n  ///\n  /// Return true if this subprogram is a C++11 reference-qualified non-static\n  /// member function (void foo() &).\n  bool isLValueReference() const { return getFlags() & FlagLValueReference; }\n\n  /// Check if this is rvalue-reference-qualified.\n  ///\n  /// Return true if this subprogram is a C++11 rvalue-reference-qualified\n  /// non-static member function (void foo() &&).\n  bool isRValueReference() const { return getFlags() & FlagRValueReference; }\n\n  /// Check if this is marked as noreturn.\n  ///\n  /// Return true if this subprogram is C++11 noreturn or C11 _Noreturn\n  bool isNoReturn() const { return getFlags() & FlagNoReturn; }\n\n  // Check if this routine is a compiler-generated thunk.\n  //\n  // Returns true if this subprogram is a thunk generated by the compiler.\n  bool isThunk() const { return getFlags() & FlagThunk; }\n\n  DIScope *getScope() const { return cast_or_null<DIScope>(getRawScope()); }\n\n  StringRef getName() const { return getStringOperand(2); }\n  StringRef getLinkageName() const { return getStringOperand(3); }\n\n  DISubroutineType *getType() const {\n    return cast_or_null<DISubroutineType>(getRawType());\n  }\n  DIType *getContainingType() const {\n    return cast_or_null<DIType>(getRawContainingType());\n  }\n\n  DICompileUnit *getUnit() const {\n    return cast_or_null<DICompileUnit>(getRawUnit());\n  }\n  void replaceUnit(DICompileUnit *CU) { replaceOperandWith(5, CU); }\n  DITemplateParameterArray getTemplateParams() const {\n    return cast_or_null<MDTuple>(getRawTemplateParams());\n  }\n  DISubprogram *getDeclaration() const {\n    return cast_or_null<DISubprogram>(getRawDeclaration());\n  }\n  DINodeArray getRetainedNodes() const {\n    return cast_or_null<MDTuple>(getRawRetainedNodes());\n  }\n  DITypeArray getThrownTypes() const {\n    return cast_or_null<MDTuple>(getRawThrownTypes());\n  }\n\n  Metadata *getRawScope() const { return getOperand(1); }\n  MDString *getRawName() const { return getOperandAs<MDString>(2); }\n  MDString *getRawLinkageName() const { return getOperandAs<MDString>(3); }\n  Metadata *getRawType() const { return getOperand(4); }\n  Metadata *getRawUnit() const { return getOperand(5); }\n  Metadata *getRawDeclaration() const { return getOperand(6); }\n  Metadata *getRawRetainedNodes() const { return getOperand(7); }\n  Metadata *getRawContainingType() const {\n    return getNumOperands() > 8 ? getOperandAs<Metadata>(8) : nullptr;\n  }\n  Metadata *getRawTemplateParams() const {\n    return getNumOperands() > 9 ? getOperandAs<Metadata>(9) : nullptr;\n  }\n  Metadata *getRawThrownTypes() const {\n    return getNumOperands() > 10 ? getOperandAs<Metadata>(10) : nullptr;\n  }\n\n  void replaceRawLinkageName(MDString *LinkageName) {\n    replaceOperandWith(3, LinkageName);\n  }\n\n  /// Check if this subprogram describes the given function.\n  ///\n  /// FIXME: Should this be looking through bitcasts?\n  bool describes(const Function *F) const;\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DISubprogramKind;\n  }\n};\n\nclass DILexicalBlockBase : public DILocalScope {\nprotected:\n  DILexicalBlockBase(LLVMContext &C, unsigned ID, StorageType Storage,\n                     ArrayRef<Metadata *> Ops)\n      : DILocalScope(C, ID, Storage, dwarf::DW_TAG_lexical_block, Ops) {}\n  ~DILexicalBlockBase() = default;\n\npublic:\n  DILocalScope *getScope() const { return cast<DILocalScope>(getRawScope()); }\n\n  Metadata *getRawScope() const { return getOperand(1); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DILexicalBlockKind ||\n           MD->getMetadataID() == DILexicalBlockFileKind;\n  }\n};\n\nclass DILexicalBlock : public DILexicalBlockBase {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Line;\n  uint16_t Column;\n\n  DILexicalBlock(LLVMContext &C, StorageType Storage, unsigned Line,\n                 unsigned Column, ArrayRef<Metadata *> Ops)\n      : DILexicalBlockBase(C, DILexicalBlockKind, Storage, Ops), Line(Line),\n        Column(Column) {\n    assert(Column < (1u << 16) && \"Expected 16-bit column\");\n  }\n  ~DILexicalBlock() = default;\n\n  static DILexicalBlock *getImpl(LLVMContext &Context, DILocalScope *Scope,\n                                 DIFile *File, unsigned Line, unsigned Column,\n                                 StorageType Storage,\n                                 bool ShouldCreate = true) {\n    return getImpl(Context, static_cast<Metadata *>(Scope),\n                   static_cast<Metadata *>(File), Line, Column, Storage,\n                   ShouldCreate);\n  }\n\n  static DILexicalBlock *getImpl(LLVMContext &Context, Metadata *Scope,\n                                 Metadata *File, unsigned Line, unsigned Column,\n                                 StorageType Storage, bool ShouldCreate = true);\n\n  TempDILexicalBlock cloneImpl() const {\n    return getTemporary(getContext(), getScope(), getFile(), getLine(),\n                        getColumn());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DILexicalBlock, (DILocalScope * Scope, DIFile *File,\n                                     unsigned Line, unsigned Column),\n                    (Scope, File, Line, Column))\n  DEFINE_MDNODE_GET(DILexicalBlock, (Metadata * Scope, Metadata *File,\n                                     unsigned Line, unsigned Column),\n                    (Scope, File, Line, Column))\n\n  TempDILexicalBlock clone() const { return cloneImpl(); }\n\n  unsigned getLine() const { return Line; }\n  unsigned getColumn() const { return Column; }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DILexicalBlockKind;\n  }\n};\n\nclass DILexicalBlockFile : public DILexicalBlockBase {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Discriminator;\n\n  DILexicalBlockFile(LLVMContext &C, StorageType Storage,\n                     unsigned Discriminator, ArrayRef<Metadata *> Ops)\n      : DILexicalBlockBase(C, DILexicalBlockFileKind, Storage, Ops),\n        Discriminator(Discriminator) {}\n  ~DILexicalBlockFile() = default;\n\n  static DILexicalBlockFile *getImpl(LLVMContext &Context, DILocalScope *Scope,\n                                     DIFile *File, unsigned Discriminator,\n                                     StorageType Storage,\n                                     bool ShouldCreate = true) {\n    return getImpl(Context, static_cast<Metadata *>(Scope),\n                   static_cast<Metadata *>(File), Discriminator, Storage,\n                   ShouldCreate);\n  }\n\n  static DILexicalBlockFile *getImpl(LLVMContext &Context, Metadata *Scope,\n                                     Metadata *File, unsigned Discriminator,\n                                     StorageType Storage,\n                                     bool ShouldCreate = true);\n\n  TempDILexicalBlockFile cloneImpl() const {\n    return getTemporary(getContext(), getScope(), getFile(),\n                        getDiscriminator());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DILexicalBlockFile, (DILocalScope * Scope, DIFile *File,\n                                         unsigned Discriminator),\n                    (Scope, File, Discriminator))\n  DEFINE_MDNODE_GET(DILexicalBlockFile,\n                    (Metadata * Scope, Metadata *File, unsigned Discriminator),\n                    (Scope, File, Discriminator))\n\n  TempDILexicalBlockFile clone() const { return cloneImpl(); }\n  unsigned getDiscriminator() const { return Discriminator; }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DILexicalBlockFileKind;\n  }\n};\n\nunsigned DILocation::getDiscriminator() const {\n  if (auto *F = dyn_cast<DILexicalBlockFile>(getScope()))\n    return F->getDiscriminator();\n  return 0;\n}\n\nconst DILocation *\nDILocation::cloneWithDiscriminator(unsigned Discriminator) const {\n  DIScope *Scope = getScope();\n  // Skip all parent DILexicalBlockFile that already have a discriminator\n  // assigned. We do not want to have nested DILexicalBlockFiles that have\n  // mutliple discriminators because only the leaf DILexicalBlockFile's\n  // dominator will be used.\n  for (auto *LBF = dyn_cast<DILexicalBlockFile>(Scope);\n       LBF && LBF->getDiscriminator() != 0;\n       LBF = dyn_cast<DILexicalBlockFile>(Scope))\n    Scope = LBF->getScope();\n  DILexicalBlockFile *NewScope =\n      DILexicalBlockFile::get(getContext(), Scope, getFile(), Discriminator);\n  return DILocation::get(getContext(), getLine(), getColumn(), NewScope,\n                         getInlinedAt());\n}\n\nunsigned DILocation::getBaseDiscriminator() const {\n  return getBaseDiscriminatorFromDiscriminator(getDiscriminator());\n}\n\nunsigned DILocation::getDuplicationFactor() const {\n  return getDuplicationFactorFromDiscriminator(getDiscriminator());\n}\n\nunsigned DILocation::getCopyIdentifier() const {\n  return getCopyIdentifierFromDiscriminator(getDiscriminator());\n}\n\nOptional<const DILocation *> DILocation::cloneWithBaseDiscriminator(unsigned D) const {\n  unsigned BD, DF, CI;\n  decodeDiscriminator(getDiscriminator(), BD, DF, CI);\n  if (D == BD)\n    return this;\n  if (Optional<unsigned> Encoded = encodeDiscriminator(D, DF, CI))\n    return cloneWithDiscriminator(*Encoded);\n  return None;\n}\n\nOptional<const DILocation *> DILocation::cloneByMultiplyingDuplicationFactor(unsigned DF) const {\n  DF *= getDuplicationFactor();\n  if (DF <= 1)\n    return this;\n\n  unsigned BD = getBaseDiscriminator();\n  unsigned CI = getCopyIdentifier();\n  if (Optional<unsigned> D = encodeDiscriminator(BD, DF, CI))\n    return cloneWithDiscriminator(*D);\n  return None;\n}\n\nclass DINamespace : public DIScope {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned ExportSymbols : 1;\n\n  DINamespace(LLVMContext &Context, StorageType Storage, bool ExportSymbols,\n              ArrayRef<Metadata *> Ops)\n      : DIScope(Context, DINamespaceKind, Storage, dwarf::DW_TAG_namespace,\n                Ops),\n        ExportSymbols(ExportSymbols) {}\n  ~DINamespace() = default;\n\n  static DINamespace *getImpl(LLVMContext &Context, DIScope *Scope,\n                              StringRef Name, bool ExportSymbols,\n                              StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, Scope, getCanonicalMDString(Context, Name),\n                   ExportSymbols, Storage, ShouldCreate);\n  }\n  static DINamespace *getImpl(LLVMContext &Context, Metadata *Scope,\n                              MDString *Name, bool ExportSymbols,\n                              StorageType Storage, bool ShouldCreate = true);\n\n  TempDINamespace cloneImpl() const {\n    return getTemporary(getContext(), getScope(), getName(),\n                        getExportSymbols());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DINamespace,\n                    (DIScope *Scope, StringRef Name, bool ExportSymbols),\n                    (Scope, Name, ExportSymbols))\n  DEFINE_MDNODE_GET(DINamespace,\n                    (Metadata *Scope, MDString *Name, bool ExportSymbols),\n                    (Scope, Name, ExportSymbols))\n\n  TempDINamespace clone() const { return cloneImpl(); }\n\n  bool getExportSymbols() const { return ExportSymbols; }\n  DIScope *getScope() const { return cast_or_null<DIScope>(getRawScope()); }\n  StringRef getName() const { return getStringOperand(2); }\n\n  Metadata *getRawScope() const { return getOperand(1); }\n  MDString *getRawName() const { return getOperandAs<MDString>(2); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DINamespaceKind;\n  }\n};\n\n/// Represents a module in the programming language, for example, a Clang\n/// module, or a Fortran module.\nclass DIModule : public DIScope {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n  unsigned LineNo;\n  bool IsDecl;\n\n  DIModule(LLVMContext &Context, StorageType Storage, unsigned LineNo,\n           bool IsDecl, ArrayRef<Metadata *> Ops)\n      : DIScope(Context, DIModuleKind, Storage, dwarf::DW_TAG_module, Ops),\n        LineNo(LineNo), IsDecl(IsDecl) {}\n  ~DIModule() = default;\n\n  static DIModule *getImpl(LLVMContext &Context, DIFile *File, DIScope *Scope,\n                           StringRef Name, StringRef ConfigurationMacros,\n                           StringRef IncludePath, StringRef APINotesFile,\n                           unsigned LineNo, bool IsDecl, StorageType Storage,\n                           bool ShouldCreate = true) {\n    return getImpl(Context, File, Scope, getCanonicalMDString(Context, Name),\n                   getCanonicalMDString(Context, ConfigurationMacros),\n                   getCanonicalMDString(Context, IncludePath),\n                   getCanonicalMDString(Context, APINotesFile), LineNo, IsDecl,\n                   Storage, ShouldCreate);\n  }\n  static DIModule *getImpl(LLVMContext &Context, Metadata *File,\n                           Metadata *Scope, MDString *Name,\n                           MDString *ConfigurationMacros, MDString *IncludePath,\n                           MDString *APINotesFile, unsigned LineNo, bool IsDecl,\n                           StorageType Storage, bool ShouldCreate = true);\n\n  TempDIModule cloneImpl() const {\n    return getTemporary(getContext(), getFile(), getScope(), getName(),\n                        getConfigurationMacros(), getIncludePath(),\n                        getAPINotesFile(), getLineNo(), getIsDecl());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIModule,\n                    (DIFile * File, DIScope *Scope, StringRef Name,\n                     StringRef ConfigurationMacros, StringRef IncludePath,\n                     StringRef APINotesFile, unsigned LineNo,\n                     bool IsDecl = false),\n                    (File, Scope, Name, ConfigurationMacros, IncludePath,\n                     APINotesFile, LineNo, IsDecl))\n  DEFINE_MDNODE_GET(DIModule,\n                    (Metadata * File, Metadata *Scope, MDString *Name,\n                     MDString *ConfigurationMacros, MDString *IncludePath,\n                     MDString *APINotesFile, unsigned LineNo,\n                     bool IsDecl = false),\n                    (File, Scope, Name, ConfigurationMacros, IncludePath,\n                     APINotesFile, LineNo, IsDecl))\n\n  TempDIModule clone() const { return cloneImpl(); }\n\n  DIScope *getScope() const { return cast_or_null<DIScope>(getRawScope()); }\n  StringRef getName() const { return getStringOperand(2); }\n  StringRef getConfigurationMacros() const { return getStringOperand(3); }\n  StringRef getIncludePath() const { return getStringOperand(4); }\n  StringRef getAPINotesFile() const { return getStringOperand(5); }\n  unsigned getLineNo() const { return LineNo; }\n  bool getIsDecl() const { return IsDecl; }\n\n  Metadata *getRawScope() const { return getOperand(1); }\n  MDString *getRawName() const { return getOperandAs<MDString>(2); }\n  MDString *getRawConfigurationMacros() const {\n    return getOperandAs<MDString>(3);\n  }\n  MDString *getRawIncludePath() const { return getOperandAs<MDString>(4); }\n  MDString *getRawAPINotesFile() const { return getOperandAs<MDString>(5); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIModuleKind;\n  }\n};\n\n/// Base class for template parameters.\nclass DITemplateParameter : public DINode {\nprotected:\n  bool IsDefault;\n\n  DITemplateParameter(LLVMContext &Context, unsigned ID, StorageType Storage,\n                      unsigned Tag, bool IsDefault, ArrayRef<Metadata *> Ops)\n      : DINode(Context, ID, Storage, Tag, Ops), IsDefault(IsDefault) {}\n  ~DITemplateParameter() = default;\n\npublic:\n  StringRef getName() const { return getStringOperand(0); }\n  DIType *getType() const { return cast_or_null<DIType>(getRawType()); }\n\n  MDString *getRawName() const { return getOperandAs<MDString>(0); }\n  Metadata *getRawType() const { return getOperand(1); }\n  bool isDefault() const { return IsDefault; }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DITemplateTypeParameterKind ||\n           MD->getMetadataID() == DITemplateValueParameterKind;\n  }\n};\n\nclass DITemplateTypeParameter : public DITemplateParameter {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  DITemplateTypeParameter(LLVMContext &Context, StorageType Storage,\n                          bool IsDefault, ArrayRef<Metadata *> Ops)\n      : DITemplateParameter(Context, DITemplateTypeParameterKind, Storage,\n                            dwarf::DW_TAG_template_type_parameter, IsDefault,\n                            Ops) {}\n  ~DITemplateTypeParameter() = default;\n\n  static DITemplateTypeParameter *getImpl(LLVMContext &Context, StringRef Name,\n                                          DIType *Type, bool IsDefault,\n                                          StorageType Storage,\n                                          bool ShouldCreate = true) {\n    return getImpl(Context, getCanonicalMDString(Context, Name), Type,\n                   IsDefault, Storage, ShouldCreate);\n  }\n  static DITemplateTypeParameter *getImpl(LLVMContext &Context, MDString *Name,\n                                          Metadata *Type, bool IsDefault,\n                                          StorageType Storage,\n                                          bool ShouldCreate = true);\n\n  TempDITemplateTypeParameter cloneImpl() const {\n    return getTemporary(getContext(), getName(), getType(), isDefault());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DITemplateTypeParameter,\n                    (StringRef Name, DIType *Type, bool IsDefault),\n                    (Name, Type, IsDefault))\n  DEFINE_MDNODE_GET(DITemplateTypeParameter,\n                    (MDString *Name, Metadata *Type, bool IsDefault),\n                    (Name, Type, IsDefault))\n\n  TempDITemplateTypeParameter clone() const { return cloneImpl(); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DITemplateTypeParameterKind;\n  }\n};\n\nclass DITemplateValueParameter : public DITemplateParameter {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  DITemplateValueParameter(LLVMContext &Context, StorageType Storage,\n                           unsigned Tag, bool IsDefault,\n                           ArrayRef<Metadata *> Ops)\n      : DITemplateParameter(Context, DITemplateValueParameterKind, Storage, Tag,\n                            IsDefault, Ops) {}\n  ~DITemplateValueParameter() = default;\n\n  static DITemplateValueParameter *getImpl(LLVMContext &Context, unsigned Tag,\n                                           StringRef Name, DIType *Type,\n                                           bool IsDefault, Metadata *Value,\n                                           StorageType Storage,\n                                           bool ShouldCreate = true) {\n    return getImpl(Context, Tag, getCanonicalMDString(Context, Name), Type,\n                   IsDefault, Value, Storage, ShouldCreate);\n  }\n  static DITemplateValueParameter *getImpl(LLVMContext &Context, unsigned Tag,\n                                           MDString *Name, Metadata *Type,\n                                           bool IsDefault, Metadata *Value,\n                                           StorageType Storage,\n                                           bool ShouldCreate = true);\n\n  TempDITemplateValueParameter cloneImpl() const {\n    return getTemporary(getContext(), getTag(), getName(), getType(),\n                        isDefault(), getValue());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DITemplateValueParameter,\n                    (unsigned Tag, StringRef Name, DIType *Type, bool IsDefault,\n                     Metadata *Value),\n                    (Tag, Name, Type, IsDefault, Value))\n  DEFINE_MDNODE_GET(DITemplateValueParameter,\n                    (unsigned Tag, MDString *Name, Metadata *Type,\n                     bool IsDefault, Metadata *Value),\n                    (Tag, Name, Type, IsDefault, Value))\n\n  TempDITemplateValueParameter clone() const { return cloneImpl(); }\n\n  Metadata *getValue() const { return getOperand(2); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DITemplateValueParameterKind;\n  }\n};\n\n/// Base class for variables.\nclass DIVariable : public DINode {\n  unsigned Line;\n  uint32_t AlignInBits;\n\nprotected:\n  DIVariable(LLVMContext &C, unsigned ID, StorageType Storage, unsigned Line,\n             ArrayRef<Metadata *> Ops, uint32_t AlignInBits = 0)\n      : DINode(C, ID, Storage, dwarf::DW_TAG_variable, Ops), Line(Line),\n        AlignInBits(AlignInBits) {}\n  ~DIVariable() = default;\n\npublic:\n  unsigned getLine() const { return Line; }\n  DIScope *getScope() const { return cast_or_null<DIScope>(getRawScope()); }\n  StringRef getName() const { return getStringOperand(1); }\n  DIFile *getFile() const { return cast_or_null<DIFile>(getRawFile()); }\n  DIType *getType() const { return cast_or_null<DIType>(getRawType()); }\n  uint32_t getAlignInBits() const { return AlignInBits; }\n  uint32_t getAlignInBytes() const { return getAlignInBits() / CHAR_BIT; }\n  /// Determines the size of the variable's type.\n  Optional<uint64_t> getSizeInBits() const;\n\n  /// Return the signedness of this variable's type, or None if this type is\n  /// neither signed nor unsigned.\n  Optional<DIBasicType::Signedness> getSignedness() const {\n    if (auto *BT = dyn_cast<DIBasicType>(getType()))\n      return BT->getSignedness();\n    return None;\n  }\n\n  StringRef getFilename() const {\n    if (auto *F = getFile())\n      return F->getFilename();\n    return \"\";\n  }\n\n  StringRef getDirectory() const {\n    if (auto *F = getFile())\n      return F->getDirectory();\n    return \"\";\n  }\n\n  Optional<StringRef> getSource() const {\n    if (auto *F = getFile())\n      return F->getSource();\n    return None;\n  }\n\n  Metadata *getRawScope() const { return getOperand(0); }\n  MDString *getRawName() const { return getOperandAs<MDString>(1); }\n  Metadata *getRawFile() const { return getOperand(2); }\n  Metadata *getRawType() const { return getOperand(3); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DILocalVariableKind ||\n           MD->getMetadataID() == DIGlobalVariableKind;\n  }\n};\n\n/// DWARF expression.\n///\n/// This is (almost) a DWARF expression that modifies the location of a\n/// variable, or the location of a single piece of a variable, or (when using\n/// DW_OP_stack_value) is the constant variable value.\n///\n/// TODO: Co-allocate the expression elements.\n/// TODO: Separate from MDNode, or otherwise drop Distinct and Temporary\n/// storage types.\nclass DIExpression : public MDNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  std::vector<uint64_t> Elements;\n\n  DIExpression(LLVMContext &C, StorageType Storage, ArrayRef<uint64_t> Elements)\n      : MDNode(C, DIExpressionKind, Storage, None),\n        Elements(Elements.begin(), Elements.end()) {}\n  ~DIExpression() = default;\n\n  static DIExpression *getImpl(LLVMContext &Context,\n                               ArrayRef<uint64_t> Elements, StorageType Storage,\n                               bool ShouldCreate = true);\n\n  TempDIExpression cloneImpl() const {\n    return getTemporary(getContext(), getElements());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIExpression, (ArrayRef<uint64_t> Elements), (Elements))\n\n  TempDIExpression clone() const { return cloneImpl(); }\n\n  ArrayRef<uint64_t> getElements() const { return Elements; }\n\n  unsigned getNumElements() const { return Elements.size(); }\n\n  uint64_t getElement(unsigned I) const {\n    assert(I < Elements.size() && \"Index out of range\");\n    return Elements[I];\n  }\n\n  /// Determine whether this represents a standalone constant value.\n  bool isConstant() const;\n\n  /// Determine whether this represents a standalone signed constant value.\n  bool isSignedConstant() const;\n\n  using element_iterator = ArrayRef<uint64_t>::iterator;\n\n  element_iterator elements_begin() const { return getElements().begin(); }\n  element_iterator elements_end() const { return getElements().end(); }\n\n  /// A lightweight wrapper around an expression operand.\n  ///\n  /// TODO: Store arguments directly and change \\a DIExpression to store a\n  /// range of these.\n  class ExprOperand {\n    const uint64_t *Op = nullptr;\n\n  public:\n    ExprOperand() = default;\n    explicit ExprOperand(const uint64_t *Op) : Op(Op) {}\n\n    const uint64_t *get() const { return Op; }\n\n    /// Get the operand code.\n    uint64_t getOp() const { return *Op; }\n\n    /// Get an argument to the operand.\n    ///\n    /// Never returns the operand itself.\n    uint64_t getArg(unsigned I) const { return Op[I + 1]; }\n\n    unsigned getNumArgs() const { return getSize() - 1; }\n\n    /// Return the size of the operand.\n    ///\n    /// Return the number of elements in the operand (1 + args).\n    unsigned getSize() const;\n\n    /// Append the elements of this operand to \\p V.\n    void appendToVector(SmallVectorImpl<uint64_t> &V) const {\n      V.append(get(), get() + getSize());\n    }\n  };\n\n  /// An iterator for expression operands.\n  class expr_op_iterator\n      : public std::iterator<std::input_iterator_tag, ExprOperand> {\n    ExprOperand Op;\n\n  public:\n    expr_op_iterator() = default;\n    explicit expr_op_iterator(element_iterator I) : Op(I) {}\n\n    element_iterator getBase() const { return Op.get(); }\n    const ExprOperand &operator*() const { return Op; }\n    const ExprOperand *operator->() const { return &Op; }\n\n    expr_op_iterator &operator++() {\n      increment();\n      return *this;\n    }\n    expr_op_iterator operator++(int) {\n      expr_op_iterator T(*this);\n      increment();\n      return T;\n    }\n\n    /// Get the next iterator.\n    ///\n    /// \\a std::next() doesn't work because this is technically an\n    /// input_iterator, but it's a perfectly valid operation.  This is an\n    /// accessor to provide the same functionality.\n    expr_op_iterator getNext() const { return ++expr_op_iterator(*this); }\n\n    bool operator==(const expr_op_iterator &X) const {\n      return getBase() == X.getBase();\n    }\n    bool operator!=(const expr_op_iterator &X) const {\n      return getBase() != X.getBase();\n    }\n\n  private:\n    void increment() { Op = ExprOperand(getBase() + Op.getSize()); }\n  };\n\n  /// Visit the elements via ExprOperand wrappers.\n  ///\n  /// These range iterators visit elements through \\a ExprOperand wrappers.\n  /// This is not guaranteed to be a valid range unless \\a isValid() gives \\c\n  /// true.\n  ///\n  /// \\pre \\a isValid() gives \\c true.\n  /// @{\n  expr_op_iterator expr_op_begin() const {\n    return expr_op_iterator(elements_begin());\n  }\n  expr_op_iterator expr_op_end() const {\n    return expr_op_iterator(elements_end());\n  }\n  iterator_range<expr_op_iterator> expr_ops() const {\n    return {expr_op_begin(), expr_op_end()};\n  }\n  /// @}\n\n  bool isValid() const;\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIExpressionKind;\n  }\n\n  /// Return whether the first element a DW_OP_deref.\n  bool startsWithDeref() const {\n    return getNumElements() > 0 && getElement(0) == dwarf::DW_OP_deref;\n  }\n\n  /// Holds the characteristics of one fragment of a larger variable.\n  struct FragmentInfo {\n    uint64_t SizeInBits;\n    uint64_t OffsetInBits;\n  };\n\n  /// Retrieve the details of this fragment expression.\n  static Optional<FragmentInfo> getFragmentInfo(expr_op_iterator Start,\n                                                expr_op_iterator End);\n\n  /// Retrieve the details of this fragment expression.\n  Optional<FragmentInfo> getFragmentInfo() const {\n    return getFragmentInfo(expr_op_begin(), expr_op_end());\n  }\n\n  /// Return whether this is a piece of an aggregate variable.\n  bool isFragment() const { return getFragmentInfo().hasValue(); }\n\n  /// Return whether this is an implicit location description.\n  bool isImplicit() const;\n\n  /// Return whether the location is computed on the expression stack, meaning\n  /// it cannot be a simple register location.\n  bool isComplex() const;\n\n  /// Append \\p Ops with operations to apply the \\p Offset.\n  static void appendOffset(SmallVectorImpl<uint64_t> &Ops, int64_t Offset);\n\n  /// If this is a constant offset, extract it. If there is no expression,\n  /// return true with an offset of zero.\n  bool extractIfOffset(int64_t &Offset) const;\n\n  /// Checks if the last 4 elements of the expression are DW_OP_constu <DWARF\n  /// Address Space> DW_OP_swap DW_OP_xderef and extracts the <DWARF Address\n  /// Space>.\n  static const DIExpression *extractAddressClass(const DIExpression *Expr,\n                                                 unsigned &AddrClass);\n\n  /// Used for DIExpression::prepend.\n  enum PrependOps : uint8_t {\n    ApplyOffset = 0,\n    DerefBefore = 1 << 0,\n    DerefAfter = 1 << 1,\n    StackValue = 1 << 2,\n    EntryValue = 1 << 3\n  };\n\n  /// Prepend \\p DIExpr with a deref and offset operation and optionally turn it\n  /// into a stack value or/and an entry value.\n  static DIExpression *prepend(const DIExpression *Expr, uint8_t Flags,\n                               int64_t Offset = 0);\n\n  /// Prepend \\p DIExpr with the given opcodes and optionally turn it into a\n  /// stack value.\n  static DIExpression *prependOpcodes(const DIExpression *Expr,\n                                      SmallVectorImpl<uint64_t> &Ops,\n                                      bool StackValue = false,\n                                      bool EntryValue = false);\n\n  /// Append the opcodes \\p Ops to \\p DIExpr. Unlike \\ref appendToStack, the\n  /// returned expression is a stack value only if \\p DIExpr is a stack value.\n  /// If \\p DIExpr describes a fragment, the returned expression will describe\n  /// the same fragment.\n  static DIExpression *append(const DIExpression *Expr, ArrayRef<uint64_t> Ops);\n\n  /// Convert \\p DIExpr into a stack value if it isn't one already by appending\n  /// DW_OP_deref if needed, and appending \\p Ops to the resulting expression.\n  /// If \\p DIExpr describes a fragment, the returned expression will describe\n  /// the same fragment.\n  static DIExpression *appendToStack(const DIExpression *Expr,\n                                     ArrayRef<uint64_t> Ops);\n\n  /// Create a copy of \\p Expr by appending the given list of \\p Ops to each\n  /// instance of the operand `DW_OP_LLVM_arg, \\p ArgNo`. This is used to\n  /// modify a specific location used by \\p Expr, such as when salvaging that\n  /// location.\n  static DIExpression *appendOpsToArg(const DIExpression *Expr,\n                                      ArrayRef<uint64_t> Ops, unsigned ArgNo,\n                                      bool StackValue = false);\n\n  /// Create a copy of \\p Expr with each instance of\n  /// `DW_OP_LLVM_arg, \\p OldArg` replaced with `DW_OP_LLVM_arg, \\p NewArg`,\n  /// and each instance of `DW_OP_LLVM_arg, Arg` with `DW_OP_LLVM_arg, Arg - 1`\n  /// for all Arg > \\p OldArg.\n  /// This is used when replacing one of the operands of a debug value list\n  /// with another operand in the same list and deleting the old operand.\n  static DIExpression *replaceArg(const DIExpression *Expr, uint64_t OldArg,\n                                  uint64_t NewArg);\n\n  /// Create a DIExpression to describe one part of an aggregate variable that\n  /// is fragmented across multiple Values. The DW_OP_LLVM_fragment operation\n  /// will be appended to the elements of \\c Expr. If \\c Expr already contains\n  /// a \\c DW_OP_LLVM_fragment \\c OffsetInBits is interpreted as an offset\n  /// into the existing fragment.\n  ///\n  /// \\param OffsetInBits Offset of the piece in bits.\n  /// \\param SizeInBits   Size of the piece in bits.\n  /// \\return             Creating a fragment expression may fail if \\c Expr\n  ///                     contains arithmetic operations that would be truncated.\n  static Optional<DIExpression *>\n  createFragmentExpression(const DIExpression *Expr, unsigned OffsetInBits,\n                           unsigned SizeInBits);\n\n  /// Determine the relative position of the fragments passed in.\n  /// Returns -1 if this is entirely before Other, 0 if this and Other overlap,\n  /// 1 if this is entirely after Other.\n  static int fragmentCmp(const FragmentInfo &A, const FragmentInfo &B) {\n    uint64_t l1 = A.OffsetInBits;\n    uint64_t l2 = B.OffsetInBits;\n    uint64_t r1 = l1 + A.SizeInBits;\n    uint64_t r2 = l2 + B.SizeInBits;\n    if (r1 <= l2)\n      return -1;\n    else if (r2 <= l1)\n      return 1;\n    else\n      return 0;\n  }\n\n  using ExtOps = std::array<uint64_t, 6>;\n\n  /// Returns the ops for a zero- or sign-extension in a DIExpression.\n  static ExtOps getExtOps(unsigned FromSize, unsigned ToSize, bool Signed);\n\n  /// Append a zero- or sign-extension to \\p Expr. Converts the expression to a\n  /// stack value if it isn't one already.\n  static DIExpression *appendExt(const DIExpression *Expr, unsigned FromSize,\n                                 unsigned ToSize, bool Signed);\n\n  /// Check if fragments overlap between a pair of FragmentInfos.\n  static bool fragmentsOverlap(const FragmentInfo &A, const FragmentInfo &B) {\n    return fragmentCmp(A, B) == 0;\n  }\n\n  /// Determine the relative position of the fragments described by this\n  /// DIExpression and \\p Other. Calls static fragmentCmp implementation.\n  int fragmentCmp(const DIExpression *Other) const {\n    auto Fragment1 = *getFragmentInfo();\n    auto Fragment2 = *Other->getFragmentInfo();\n    return fragmentCmp(Fragment1, Fragment2);\n  }\n\n  /// Check if fragments overlap between this DIExpression and \\p Other.\n  bool fragmentsOverlap(const DIExpression *Other) const {\n    if (!isFragment() || !Other->isFragment())\n      return true;\n    return fragmentCmp(Other) == 0;\n  }\n\n  /// Check if the expression consists of exactly one entry value operand.\n  /// (This is the only configuration of entry values that is supported.)\n  bool isEntryValue() const {\n    return getNumElements() > 0 &&\n           getElement(0) == dwarf::DW_OP_LLVM_entry_value;\n  }\n};\n\ninline bool operator==(const DIExpression::FragmentInfo &A,\n                       const DIExpression::FragmentInfo &B) {\n  return std::tie(A.SizeInBits, A.OffsetInBits) ==\n         std::tie(B.SizeInBits, B.OffsetInBits);\n}\n\ninline bool operator<(const DIExpression::FragmentInfo &A,\n                      const DIExpression::FragmentInfo &B) {\n  return std::tie(A.SizeInBits, A.OffsetInBits) <\n         std::tie(B.SizeInBits, B.OffsetInBits);\n}\n\ntemplate <> struct DenseMapInfo<DIExpression::FragmentInfo> {\n  using FragInfo = DIExpression::FragmentInfo;\n  static const uint64_t MaxVal = std::numeric_limits<uint64_t>::max();\n\n  static inline FragInfo getEmptyKey() { return {MaxVal, MaxVal}; }\n\n  static inline FragInfo getTombstoneKey() { return {MaxVal - 1, MaxVal - 1}; }\n\n  static unsigned getHashValue(const FragInfo &Frag) {\n    return (Frag.SizeInBits & 0xffff) << 16 | (Frag.OffsetInBits & 0xffff);\n  }\n\n  static bool isEqual(const FragInfo &A, const FragInfo &B) { return A == B; }\n};\n\n/// Global variables.\n///\n/// TODO: Remove DisplayName.  It's always equal to Name.\nclass DIGlobalVariable : public DIVariable {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  bool IsLocalToUnit;\n  bool IsDefinition;\n\n  DIGlobalVariable(LLVMContext &C, StorageType Storage, unsigned Line,\n                   bool IsLocalToUnit, bool IsDefinition, uint32_t AlignInBits,\n                   ArrayRef<Metadata *> Ops)\n      : DIVariable(C, DIGlobalVariableKind, Storage, Line, Ops, AlignInBits),\n        IsLocalToUnit(IsLocalToUnit), IsDefinition(IsDefinition) {}\n  ~DIGlobalVariable() = default;\n\n  static DIGlobalVariable *\n  getImpl(LLVMContext &Context, DIScope *Scope, StringRef Name,\n          StringRef LinkageName, DIFile *File, unsigned Line, DIType *Type,\n          bool IsLocalToUnit, bool IsDefinition,\n          DIDerivedType *StaticDataMemberDeclaration, MDTuple *TemplateParams,\n          uint32_t AlignInBits, StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, Scope, getCanonicalMDString(Context, Name),\n                   getCanonicalMDString(Context, LinkageName), File, Line, Type,\n                   IsLocalToUnit, IsDefinition, StaticDataMemberDeclaration,\n                   cast_or_null<Metadata>(TemplateParams), AlignInBits, Storage,\n                   ShouldCreate);\n  }\n  static DIGlobalVariable *\n  getImpl(LLVMContext &Context, Metadata *Scope, MDString *Name,\n          MDString *LinkageName, Metadata *File, unsigned Line, Metadata *Type,\n          bool IsLocalToUnit, bool IsDefinition,\n          Metadata *StaticDataMemberDeclaration, Metadata *TemplateParams,\n          uint32_t AlignInBits, StorageType Storage, bool ShouldCreate = true);\n\n  TempDIGlobalVariable cloneImpl() const {\n    return getTemporary(getContext(), getScope(), getName(), getLinkageName(),\n                        getFile(), getLine(), getType(), isLocalToUnit(),\n                        isDefinition(), getStaticDataMemberDeclaration(),\n                        getTemplateParams(), getAlignInBits());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIGlobalVariable,\n                    (DIScope * Scope, StringRef Name, StringRef LinkageName,\n                     DIFile *File, unsigned Line, DIType *Type,\n                     bool IsLocalToUnit, bool IsDefinition,\n                     DIDerivedType *StaticDataMemberDeclaration,\n                     MDTuple *TemplateParams, uint32_t AlignInBits),\n                    (Scope, Name, LinkageName, File, Line, Type, IsLocalToUnit,\n                     IsDefinition, StaticDataMemberDeclaration, TemplateParams,\n                     AlignInBits))\n  DEFINE_MDNODE_GET(DIGlobalVariable,\n                    (Metadata * Scope, MDString *Name, MDString *LinkageName,\n                     Metadata *File, unsigned Line, Metadata *Type,\n                     bool IsLocalToUnit, bool IsDefinition,\n                     Metadata *StaticDataMemberDeclaration,\n                     Metadata *TemplateParams, uint32_t AlignInBits),\n                    (Scope, Name, LinkageName, File, Line, Type, IsLocalToUnit,\n                     IsDefinition, StaticDataMemberDeclaration, TemplateParams,\n                     AlignInBits))\n\n  TempDIGlobalVariable clone() const { return cloneImpl(); }\n\n  bool isLocalToUnit() const { return IsLocalToUnit; }\n  bool isDefinition() const { return IsDefinition; }\n  StringRef getDisplayName() const { return getStringOperand(4); }\n  StringRef getLinkageName() const { return getStringOperand(5); }\n  DIDerivedType *getStaticDataMemberDeclaration() const {\n    return cast_or_null<DIDerivedType>(getRawStaticDataMemberDeclaration());\n  }\n\n  MDString *getRawLinkageName() const { return getOperandAs<MDString>(5); }\n  Metadata *getRawStaticDataMemberDeclaration() const { return getOperand(6); }\n  Metadata *getRawTemplateParams() const { return getOperand(7); }\n  MDTuple *getTemplateParams() const { return getOperandAs<MDTuple>(7); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIGlobalVariableKind;\n  }\n};\n\nclass DICommonBlock : public DIScope {\n  unsigned LineNo;\n\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  DICommonBlock(LLVMContext &Context, StorageType Storage, unsigned LineNo,\n                ArrayRef<Metadata *> Ops)\n      : DIScope(Context, DICommonBlockKind, Storage, dwarf::DW_TAG_common_block,\n                Ops), LineNo(LineNo) {}\n\n  static DICommonBlock *getImpl(LLVMContext &Context, DIScope *Scope,\n                                DIGlobalVariable *Decl, StringRef Name,\n                                DIFile *File, unsigned LineNo,\n                                StorageType Storage,\n                                bool ShouldCreate = true) {\n    return getImpl(Context, Scope, Decl, getCanonicalMDString(Context, Name),\n                   File, LineNo, Storage, ShouldCreate);\n  }\n  static DICommonBlock *getImpl(LLVMContext &Context, Metadata *Scope,\n                                Metadata *Decl, MDString *Name, Metadata *File,\n                                unsigned LineNo, \n                                StorageType Storage, bool ShouldCreate = true);\n\n  TempDICommonBlock cloneImpl() const {\n    return getTemporary(getContext(), getScope(), getDecl(), getName(),\n                        getFile(), getLineNo());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DICommonBlock,\n                    (DIScope *Scope, DIGlobalVariable *Decl, StringRef Name,\n                     DIFile *File, unsigned LineNo),\n                    (Scope, Decl, Name, File, LineNo))\n  DEFINE_MDNODE_GET(DICommonBlock,\n                    (Metadata *Scope, Metadata *Decl, MDString *Name,\n                     Metadata *File, unsigned LineNo),\n                    (Scope, Decl, Name, File, LineNo))\n\n  TempDICommonBlock clone() const { return cloneImpl(); }\n\n  DIScope *getScope() const { return cast_or_null<DIScope>(getRawScope()); }\n  DIGlobalVariable *getDecl() const {\n    return cast_or_null<DIGlobalVariable>(getRawDecl());\n  }\n  StringRef getName() const { return getStringOperand(2); }\n  DIFile *getFile() const { return cast_or_null<DIFile>(getRawFile()); }\n  unsigned getLineNo() const { return LineNo; }\n\n  Metadata *getRawScope() const { return getOperand(0); }\n  Metadata *getRawDecl() const { return getOperand(1); }\n  MDString *getRawName() const { return getOperandAs<MDString>(2); }\n  Metadata *getRawFile() const { return getOperand(3); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DICommonBlockKind;\n  }\n};\n\n/// Local variable.\n///\n/// TODO: Split up flags.\nclass DILocalVariable : public DIVariable {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Arg : 16;\n  DIFlags Flags;\n\n  DILocalVariable(LLVMContext &C, StorageType Storage, unsigned Line,\n                  unsigned Arg, DIFlags Flags, uint32_t AlignInBits,\n                  ArrayRef<Metadata *> Ops)\n      : DIVariable(C, DILocalVariableKind, Storage, Line, Ops, AlignInBits),\n        Arg(Arg), Flags(Flags) {\n    assert(Arg < (1 << 16) && \"DILocalVariable: Arg out of range\");\n  }\n  ~DILocalVariable() = default;\n\n  static DILocalVariable *getImpl(LLVMContext &Context, DIScope *Scope,\n                                  StringRef Name, DIFile *File, unsigned Line,\n                                  DIType *Type, unsigned Arg, DIFlags Flags,\n                                  uint32_t AlignInBits, StorageType Storage,\n                                  bool ShouldCreate = true) {\n    return getImpl(Context, Scope, getCanonicalMDString(Context, Name), File,\n                   Line, Type, Arg, Flags, AlignInBits, Storage, ShouldCreate);\n  }\n  static DILocalVariable *getImpl(LLVMContext &Context, Metadata *Scope,\n                                  MDString *Name, Metadata *File, unsigned Line,\n                                  Metadata *Type, unsigned Arg, DIFlags Flags,\n                                  uint32_t AlignInBits, StorageType Storage,\n                                  bool ShouldCreate = true);\n\n  TempDILocalVariable cloneImpl() const {\n    return getTemporary(getContext(), getScope(), getName(), getFile(),\n                        getLine(), getType(), getArg(), getFlags(),\n                        getAlignInBits());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DILocalVariable,\n                    (DILocalScope * Scope, StringRef Name, DIFile *File,\n                     unsigned Line, DIType *Type, unsigned Arg, DIFlags Flags,\n                     uint32_t AlignInBits),\n                    (Scope, Name, File, Line, Type, Arg, Flags, AlignInBits))\n  DEFINE_MDNODE_GET(DILocalVariable,\n                    (Metadata * Scope, MDString *Name, Metadata *File,\n                     unsigned Line, Metadata *Type, unsigned Arg,\n                     DIFlags Flags, uint32_t AlignInBits),\n                    (Scope, Name, File, Line, Type, Arg, Flags, AlignInBits))\n\n  TempDILocalVariable clone() const { return cloneImpl(); }\n\n  /// Get the local scope for this variable.\n  ///\n  /// Variables must be defined in a local scope.\n  DILocalScope *getScope() const {\n    return cast<DILocalScope>(DIVariable::getScope());\n  }\n\n  bool isParameter() const { return Arg; }\n  unsigned getArg() const { return Arg; }\n  DIFlags getFlags() const { return Flags; }\n\n  bool isArtificial() const { return getFlags() & FlagArtificial; }\n  bool isObjectPointer() const { return getFlags() & FlagObjectPointer; }\n\n  /// Check that a location is valid for this variable.\n  ///\n  /// Check that \\c DL exists, is in the same subprogram, and has the same\n  /// inlined-at location as \\c this.  (Otherwise, it's not a valid attachment\n  /// to a \\a DbgInfoIntrinsic.)\n  bool isValidLocationForIntrinsic(const DILocation *DL) const {\n    return DL && getScope()->getSubprogram() == DL->getScope()->getSubprogram();\n  }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DILocalVariableKind;\n  }\n};\n\n/// Label.\n///\nclass DILabel : public DINode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Line;\n\n  DILabel(LLVMContext &C, StorageType Storage, unsigned Line,\n          ArrayRef<Metadata *> Ops)\n      : DINode(C, DILabelKind, Storage, dwarf::DW_TAG_label, Ops), Line(Line) {}\n  ~DILabel() = default;\n\n  static DILabel *getImpl(LLVMContext &Context, DIScope *Scope,\n                          StringRef Name, DIFile *File, unsigned Line,\n                          StorageType Storage,\n                          bool ShouldCreate = true) {\n    return getImpl(Context, Scope, getCanonicalMDString(Context, Name), File,\n                   Line, Storage, ShouldCreate);\n  }\n  static DILabel *getImpl(LLVMContext &Context, Metadata *Scope,\n                          MDString *Name, Metadata *File, unsigned Line,\n                          StorageType Storage,\n                          bool ShouldCreate = true);\n\n  TempDILabel cloneImpl() const {\n    return getTemporary(getContext(), getScope(), getName(), getFile(),\n                        getLine());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DILabel,\n                    (DILocalScope * Scope, StringRef Name, DIFile *File,\n                     unsigned Line),\n                    (Scope, Name, File, Line))\n  DEFINE_MDNODE_GET(DILabel,\n                    (Metadata * Scope, MDString *Name, Metadata *File,\n                     unsigned Line),\n                    (Scope, Name, File, Line))\n\n  TempDILabel clone() const { return cloneImpl(); }\n\n  /// Get the local scope for this label.\n  ///\n  /// Labels must be defined in a local scope.\n  DILocalScope *getScope() const {\n    return cast_or_null<DILocalScope>(getRawScope());\n  }\n  unsigned getLine() const { return Line; }\n  StringRef getName() const { return getStringOperand(1); }\n  DIFile *getFile() const { return cast_or_null<DIFile>(getRawFile()); }\n\n  Metadata *getRawScope() const { return getOperand(0); }\n  MDString *getRawName() const { return getOperandAs<MDString>(1); }\n  Metadata *getRawFile() const { return getOperand(2); }\n\n  /// Check that a location is valid for this label.\n  ///\n  /// Check that \\c DL exists, is in the same subprogram, and has the same\n  /// inlined-at location as \\c this.  (Otherwise, it's not a valid attachment\n  /// to a \\a DbgInfoIntrinsic.)\n  bool isValidLocationForIntrinsic(const DILocation *DL) const {\n    return DL && getScope()->getSubprogram() == DL->getScope()->getSubprogram();\n  }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DILabelKind;\n  }\n};\n\nclass DIObjCProperty : public DINode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Line;\n  unsigned Attributes;\n\n  DIObjCProperty(LLVMContext &C, StorageType Storage, unsigned Line,\n                 unsigned Attributes, ArrayRef<Metadata *> Ops)\n      : DINode(C, DIObjCPropertyKind, Storage, dwarf::DW_TAG_APPLE_property,\n               Ops),\n        Line(Line), Attributes(Attributes) {}\n  ~DIObjCProperty() = default;\n\n  static DIObjCProperty *\n  getImpl(LLVMContext &Context, StringRef Name, DIFile *File, unsigned Line,\n          StringRef GetterName, StringRef SetterName, unsigned Attributes,\n          DIType *Type, StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, getCanonicalMDString(Context, Name), File, Line,\n                   getCanonicalMDString(Context, GetterName),\n                   getCanonicalMDString(Context, SetterName), Attributes, Type,\n                   Storage, ShouldCreate);\n  }\n  static DIObjCProperty *getImpl(LLVMContext &Context, MDString *Name,\n                                 Metadata *File, unsigned Line,\n                                 MDString *GetterName, MDString *SetterName,\n                                 unsigned Attributes, Metadata *Type,\n                                 StorageType Storage, bool ShouldCreate = true);\n\n  TempDIObjCProperty cloneImpl() const {\n    return getTemporary(getContext(), getName(), getFile(), getLine(),\n                        getGetterName(), getSetterName(), getAttributes(),\n                        getType());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIObjCProperty,\n                    (StringRef Name, DIFile *File, unsigned Line,\n                     StringRef GetterName, StringRef SetterName,\n                     unsigned Attributes, DIType *Type),\n                    (Name, File, Line, GetterName, SetterName, Attributes,\n                     Type))\n  DEFINE_MDNODE_GET(DIObjCProperty,\n                    (MDString * Name, Metadata *File, unsigned Line,\n                     MDString *GetterName, MDString *SetterName,\n                     unsigned Attributes, Metadata *Type),\n                    (Name, File, Line, GetterName, SetterName, Attributes,\n                     Type))\n\n  TempDIObjCProperty clone() const { return cloneImpl(); }\n\n  unsigned getLine() const { return Line; }\n  unsigned getAttributes() const { return Attributes; }\n  StringRef getName() const { return getStringOperand(0); }\n  DIFile *getFile() const { return cast_or_null<DIFile>(getRawFile()); }\n  StringRef getGetterName() const { return getStringOperand(2); }\n  StringRef getSetterName() const { return getStringOperand(3); }\n  DIType *getType() const { return cast_or_null<DIType>(getRawType()); }\n\n  StringRef getFilename() const {\n    if (auto *F = getFile())\n      return F->getFilename();\n    return \"\";\n  }\n\n  StringRef getDirectory() const {\n    if (auto *F = getFile())\n      return F->getDirectory();\n    return \"\";\n  }\n\n  MDString *getRawName() const { return getOperandAs<MDString>(0); }\n  Metadata *getRawFile() const { return getOperand(1); }\n  MDString *getRawGetterName() const { return getOperandAs<MDString>(2); }\n  MDString *getRawSetterName() const { return getOperandAs<MDString>(3); }\n  Metadata *getRawType() const { return getOperand(4); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIObjCPropertyKind;\n  }\n};\n\n/// An imported module (C++ using directive or similar).\nclass DIImportedEntity : public DINode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Line;\n\n  DIImportedEntity(LLVMContext &C, StorageType Storage, unsigned Tag,\n                   unsigned Line, ArrayRef<Metadata *> Ops)\n      : DINode(C, DIImportedEntityKind, Storage, Tag, Ops), Line(Line) {}\n  ~DIImportedEntity() = default;\n\n  static DIImportedEntity *getImpl(LLVMContext &Context, unsigned Tag,\n                                   DIScope *Scope, DINode *Entity, DIFile *File,\n                                   unsigned Line, StringRef Name,\n                                   StorageType Storage,\n                                   bool ShouldCreate = true) {\n    return getImpl(Context, Tag, Scope, Entity, File, Line,\n                   getCanonicalMDString(Context, Name), Storage, ShouldCreate);\n  }\n  static DIImportedEntity *getImpl(LLVMContext &Context, unsigned Tag,\n                                   Metadata *Scope, Metadata *Entity,\n                                   Metadata *File, unsigned Line,\n                                   MDString *Name, StorageType Storage,\n                                   bool ShouldCreate = true);\n\n  TempDIImportedEntity cloneImpl() const {\n    return getTemporary(getContext(), getTag(), getScope(), getEntity(),\n                        getFile(), getLine(), getName());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIImportedEntity,\n                    (unsigned Tag, DIScope *Scope, DINode *Entity, DIFile *File,\n                     unsigned Line, StringRef Name = \"\"),\n                    (Tag, Scope, Entity, File, Line, Name))\n  DEFINE_MDNODE_GET(DIImportedEntity,\n                    (unsigned Tag, Metadata *Scope, Metadata *Entity,\n                     Metadata *File, unsigned Line, MDString *Name),\n                    (Tag, Scope, Entity, File, Line, Name))\n\n  TempDIImportedEntity clone() const { return cloneImpl(); }\n\n  unsigned getLine() const { return Line; }\n  DIScope *getScope() const { return cast_or_null<DIScope>(getRawScope()); }\n  DINode *getEntity() const { return cast_or_null<DINode>(getRawEntity()); }\n  StringRef getName() const { return getStringOperand(2); }\n  DIFile *getFile() const { return cast_or_null<DIFile>(getRawFile()); }\n\n  Metadata *getRawScope() const { return getOperand(0); }\n  Metadata *getRawEntity() const { return getOperand(1); }\n  MDString *getRawName() const { return getOperandAs<MDString>(2); }\n  Metadata *getRawFile() const { return getOperand(3); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIImportedEntityKind;\n  }\n};\n\n/// A pair of DIGlobalVariable and DIExpression.\nclass DIGlobalVariableExpression : public MDNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  DIGlobalVariableExpression(LLVMContext &C, StorageType Storage,\n                             ArrayRef<Metadata *> Ops)\n      : MDNode(C, DIGlobalVariableExpressionKind, Storage, Ops) {}\n  ~DIGlobalVariableExpression() = default;\n\n  static DIGlobalVariableExpression *\n  getImpl(LLVMContext &Context, Metadata *Variable, Metadata *Expression,\n          StorageType Storage, bool ShouldCreate = true);\n\n  TempDIGlobalVariableExpression cloneImpl() const {\n    return getTemporary(getContext(), getVariable(), getExpression());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIGlobalVariableExpression,\n                    (Metadata * Variable, Metadata *Expression),\n                    (Variable, Expression))\n\n  TempDIGlobalVariableExpression clone() const { return cloneImpl(); }\n\n  Metadata *getRawVariable() const { return getOperand(0); }\n\n  DIGlobalVariable *getVariable() const {\n    return cast_or_null<DIGlobalVariable>(getRawVariable());\n  }\n\n  Metadata *getRawExpression() const { return getOperand(1); }\n\n  DIExpression *getExpression() const {\n    return cast<DIExpression>(getRawExpression());\n  }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIGlobalVariableExpressionKind;\n  }\n};\n\n/// Macro Info DWARF-like metadata node.\n///\n/// A metadata node with a DWARF macro info (i.e., a constant named\n/// \\c DW_MACINFO_*, defined in llvm/BinaryFormat/Dwarf.h).  Called \\a\n/// DIMacroNode\n/// because it's potentially used for non-DWARF output.\nclass DIMacroNode : public MDNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\nprotected:\n  DIMacroNode(LLVMContext &C, unsigned ID, StorageType Storage, unsigned MIType,\n              ArrayRef<Metadata *> Ops1, ArrayRef<Metadata *> Ops2 = None)\n      : MDNode(C, ID, Storage, Ops1, Ops2) {\n    assert(MIType < 1u << 16);\n    SubclassData16 = MIType;\n  }\n  ~DIMacroNode() = default;\n\n  template <class Ty> Ty *getOperandAs(unsigned I) const {\n    return cast_or_null<Ty>(getOperand(I));\n  }\n\n  StringRef getStringOperand(unsigned I) const {\n    if (auto *S = getOperandAs<MDString>(I))\n      return S->getString();\n    return StringRef();\n  }\n\n  static MDString *getCanonicalMDString(LLVMContext &Context, StringRef S) {\n    if (S.empty())\n      return nullptr;\n    return MDString::get(Context, S);\n  }\n\npublic:\n  unsigned getMacinfoType() const { return SubclassData16; }\n\n  static bool classof(const Metadata *MD) {\n    switch (MD->getMetadataID()) {\n    default:\n      return false;\n    case DIMacroKind:\n    case DIMacroFileKind:\n      return true;\n    }\n  }\n};\n\nclass DIMacro : public DIMacroNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Line;\n\n  DIMacro(LLVMContext &C, StorageType Storage, unsigned MIType, unsigned Line,\n          ArrayRef<Metadata *> Ops)\n      : DIMacroNode(C, DIMacroKind, Storage, MIType, Ops), Line(Line) {}\n  ~DIMacro() = default;\n\n  static DIMacro *getImpl(LLVMContext &Context, unsigned MIType, unsigned Line,\n                          StringRef Name, StringRef Value, StorageType Storage,\n                          bool ShouldCreate = true) {\n    return getImpl(Context, MIType, Line, getCanonicalMDString(Context, Name),\n                   getCanonicalMDString(Context, Value), Storage, ShouldCreate);\n  }\n  static DIMacro *getImpl(LLVMContext &Context, unsigned MIType, unsigned Line,\n                          MDString *Name, MDString *Value, StorageType Storage,\n                          bool ShouldCreate = true);\n\n  TempDIMacro cloneImpl() const {\n    return getTemporary(getContext(), getMacinfoType(), getLine(), getName(),\n                        getValue());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIMacro, (unsigned MIType, unsigned Line, StringRef Name,\n                              StringRef Value = \"\"),\n                    (MIType, Line, Name, Value))\n  DEFINE_MDNODE_GET(DIMacro, (unsigned MIType, unsigned Line, MDString *Name,\n                              MDString *Value),\n                    (MIType, Line, Name, Value))\n\n  TempDIMacro clone() const { return cloneImpl(); }\n\n  unsigned getLine() const { return Line; }\n\n  StringRef getName() const { return getStringOperand(0); }\n  StringRef getValue() const { return getStringOperand(1); }\n\n  MDString *getRawName() const { return getOperandAs<MDString>(0); }\n  MDString *getRawValue() const { return getOperandAs<MDString>(1); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIMacroKind;\n  }\n};\n\nclass DIMacroFile : public DIMacroNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Line;\n\n  DIMacroFile(LLVMContext &C, StorageType Storage, unsigned MIType,\n              unsigned Line, ArrayRef<Metadata *> Ops)\n      : DIMacroNode(C, DIMacroFileKind, Storage, MIType, Ops), Line(Line) {}\n  ~DIMacroFile() = default;\n\n  static DIMacroFile *getImpl(LLVMContext &Context, unsigned MIType,\n                              unsigned Line, DIFile *File,\n                              DIMacroNodeArray Elements, StorageType Storage,\n                              bool ShouldCreate = true) {\n    return getImpl(Context, MIType, Line, static_cast<Metadata *>(File),\n                   Elements.get(), Storage, ShouldCreate);\n  }\n\n  static DIMacroFile *getImpl(LLVMContext &Context, unsigned MIType,\n                              unsigned Line, Metadata *File, Metadata *Elements,\n                              StorageType Storage, bool ShouldCreate = true);\n\n  TempDIMacroFile cloneImpl() const {\n    return getTemporary(getContext(), getMacinfoType(), getLine(), getFile(),\n                        getElements());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIMacroFile, (unsigned MIType, unsigned Line, DIFile *File,\n                                  DIMacroNodeArray Elements),\n                    (MIType, Line, File, Elements))\n  DEFINE_MDNODE_GET(DIMacroFile, (unsigned MIType, unsigned Line,\n                                  Metadata *File, Metadata *Elements),\n                    (MIType, Line, File, Elements))\n\n  TempDIMacroFile clone() const { return cloneImpl(); }\n\n  void replaceElements(DIMacroNodeArray Elements) {\n#ifndef NDEBUG\n    for (DIMacroNode *Op : getElements())\n      assert(is_contained(Elements->operands(), Op) &&\n             \"Lost a macro node during macro node list replacement\");\n#endif\n    replaceOperandWith(1, Elements.get());\n  }\n\n  unsigned getLine() const { return Line; }\n  DIFile *getFile() const { return cast_or_null<DIFile>(getRawFile()); }\n\n  DIMacroNodeArray getElements() const {\n    return cast_or_null<MDTuple>(getRawElements());\n  }\n\n  Metadata *getRawFile() const { return getOperand(0); }\n  Metadata *getRawElements() const { return getOperand(1); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIMacroFileKind;\n  }\n};\n\n/// List of ValueAsMetadata, to be used as an argument to a dbg.value\n/// intrinsic.\nclass DIArgList : public MDNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n  using iterator = SmallVectorImpl<ValueAsMetadata *>::iterator;\n\n  SmallVector<ValueAsMetadata *, 4> Args;\n\n  DIArgList(LLVMContext &C, StorageType Storage,\n            ArrayRef<ValueAsMetadata *> Args)\n      : MDNode(C, DIArgListKind, Storage, None),\n        Args(Args.begin(), Args.end()) {\n    track();\n  }\n  ~DIArgList() { untrack(); }\n\n  static DIArgList *getImpl(LLVMContext &Context,\n                            ArrayRef<ValueAsMetadata *> Args,\n                            StorageType Storage, bool ShouldCreate = true);\n\n  TempDIArgList cloneImpl() const {\n    return getTemporary(getContext(), getArgs());\n  }\n\n  void track();\n  void untrack();\n  void dropAllReferences();\n\npublic:\n  DEFINE_MDNODE_GET(DIArgList, (ArrayRef<ValueAsMetadata *> Args), (Args))\n\n  TempDIArgList clone() const { return cloneImpl(); }\n\n  ArrayRef<ValueAsMetadata *> getArgs() const { return Args; }\n\n  iterator args_begin() { return Args.begin(); }\n  iterator args_end() { return Args.end(); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIArgListKind;\n  }\n\n  void handleChangedOperand(void *Ref, Metadata *New);\n};\n\n/// Identifies a unique instance of a variable.\n///\n/// Storage for identifying a potentially inlined instance of a variable,\n/// or a fragment thereof. This guarantees that exactly one variable instance\n/// may be identified by this class, even when that variable is a fragment of\n/// an aggregate variable and/or there is another inlined instance of the same\n/// source code variable nearby.\n/// This class does not necessarily uniquely identify that variable: it is\n/// possible that a DebugVariable with different parameters may point to the\n/// same variable instance, but not that one DebugVariable points to multiple\n/// variable instances.\nclass DebugVariable {\n  using FragmentInfo = DIExpression::FragmentInfo;\n\n  const DILocalVariable *Variable;\n  Optional<FragmentInfo> Fragment;\n  const DILocation *InlinedAt;\n\n  /// Fragment that will overlap all other fragments. Used as default when\n  /// caller demands a fragment.\n  static const FragmentInfo DefaultFragment;\n\npublic:\n  DebugVariable(const DILocalVariable *Var, Optional<FragmentInfo> FragmentInfo,\n                const DILocation *InlinedAt)\n      : Variable(Var), Fragment(FragmentInfo), InlinedAt(InlinedAt) {}\n\n  DebugVariable(const DILocalVariable *Var, const DIExpression *DIExpr,\n                const DILocation *InlinedAt)\n      : Variable(Var),\n        Fragment(DIExpr ? DIExpr->getFragmentInfo() : NoneType()),\n        InlinedAt(InlinedAt) {}\n\n  const DILocalVariable *getVariable() const { return Variable; }\n  Optional<FragmentInfo> getFragment() const { return Fragment; }\n  const DILocation *getInlinedAt() const { return InlinedAt; }\n\n  FragmentInfo getFragmentOrDefault() const {\n    return Fragment.getValueOr(DefaultFragment);\n  }\n\n  static bool isDefaultFragment(const FragmentInfo F) {\n    return F == DefaultFragment;\n  }\n\n  bool operator==(const DebugVariable &Other) const {\n    return std::tie(Variable, Fragment, InlinedAt) ==\n           std::tie(Other.Variable, Other.Fragment, Other.InlinedAt);\n  }\n\n  bool operator<(const DebugVariable &Other) const {\n    return std::tie(Variable, Fragment, InlinedAt) <\n           std::tie(Other.Variable, Other.Fragment, Other.InlinedAt);\n  }\n};\n\ntemplate <> struct DenseMapInfo<DebugVariable> {\n  using FragmentInfo = DIExpression::FragmentInfo;\n\n  /// Empty key: no key should be generated that has no DILocalVariable.\n  static inline DebugVariable getEmptyKey() {\n    return DebugVariable(nullptr, NoneType(), nullptr);\n  }\n\n  /// Difference in tombstone is that the Optional is meaningful.\n  static inline DebugVariable getTombstoneKey() {\n    return DebugVariable(nullptr, {{0, 0}}, nullptr);\n  }\n\n  static unsigned getHashValue(const DebugVariable &D) {\n    unsigned HV = 0;\n    const Optional<FragmentInfo> Fragment = D.getFragment();\n    if (Fragment)\n      HV = DenseMapInfo<FragmentInfo>::getHashValue(*Fragment);\n\n    return hash_combine(D.getVariable(), HV, D.getInlinedAt());\n  }\n\n  static bool isEqual(const DebugVariable &A, const DebugVariable &B) {\n    return A == B;\n  }\n};\n\n} // end namespace llvm\n\n#undef DEFINE_MDNODE_GET_UNPACK_IMPL\n#undef DEFINE_MDNODE_GET_UNPACK\n#undef DEFINE_MDNODE_GET\n\n#endif // LLVM_IR_DEBUGINFOMETADATA_H\n"}, "38": {"id": 38, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DebugLoc.h", "content": "//===- DebugLoc.h - Debug Location Information ------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines a number of light weight data structures used\n// to describe and track debug location information.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_DEBUGLOC_H\n#define LLVM_IR_DEBUGLOC_H\n\n#include \"llvm/IR/TrackingMDRef.h\"\n#include \"llvm/Support/DataTypes.h\"\n\nnamespace llvm {\n\n  class LLVMContext;\n  class raw_ostream;\n  class DILocation;\n\n  /// A debug info location.\n  ///\n  /// This class is a wrapper around a tracking reference to an \\a DILocation\n  /// pointer.\n  ///\n  /// To avoid extra includes, \\a DebugLoc doubles the \\a DILocation API with a\n  /// one based on relatively opaque \\a MDNode pointers.\n  class DebugLoc {\n    TrackingMDNodeRef Loc;\n\n  public:\n    DebugLoc() = default;\n\n    /// Construct from an \\a DILocation.\n    DebugLoc(const DILocation *L);\n\n    /// Construct from an \\a MDNode.\n    ///\n    /// Note: if \\c N is not an \\a DILocation, a verifier check will fail, and\n    /// accessors will crash.  However, construction from other nodes is\n    /// supported in order to handle forward references when reading textual\n    /// IR.\n    explicit DebugLoc(const MDNode *N);\n\n    /// Get the underlying \\a DILocation.\n    ///\n    /// \\pre !*this or \\c isa<DILocation>(getAsMDNode()).\n    /// @{\n    DILocation *get() const;\n    operator DILocation *() const { return get(); }\n    DILocation *operator->() const { return get(); }\n    DILocation &operator*() const { return *get(); }\n    /// @}\n\n    /// Check for null.\n    ///\n    /// Check for null in a way that is safe with broken debug info.  Unlike\n    /// the conversion to \\c DILocation, this doesn't require that \\c Loc is of\n    /// the right type.  Important for cases like \\a llvm::StripDebugInfo() and\n    /// \\a Instruction::hasMetadata().\n    explicit operator bool() const { return Loc; }\n\n    /// Check whether this has a trivial destructor.\n    bool hasTrivialDestructor() const { return Loc.hasTrivialDestructor(); }\n\n    enum { ReplaceLastInlinedAt = true };\n    /// Rebuild the entire inlined-at chain for this instruction so that the top of\n    /// the chain now is inlined-at the new call site.\n    /// \\param   InlinedAt    The new outermost inlined-at in the chain.\n    static DebugLoc appendInlinedAt(const DebugLoc &DL, DILocation *InlinedAt,\n                                    LLVMContext &Ctx,\n                                    DenseMap<const MDNode *, MDNode *> &Cache);\n\n    unsigned getLine() const;\n    unsigned getCol() const;\n    MDNode *getScope() const;\n    DILocation *getInlinedAt() const;\n\n    /// Get the fully inlined-at scope for a DebugLoc.\n    ///\n    /// Gets the inlined-at scope for a DebugLoc.\n    MDNode *getInlinedAtScope() const;\n\n    /// Find the debug info location for the start of the function.\n    ///\n    /// Walk up the scope chain of given debug loc and find line number info\n    /// for the function.\n    ///\n    /// FIXME: Remove this.  Users should use DILocation/DILocalScope API to\n    /// find the subprogram, and then DILocation::get().\n    DebugLoc getFnDebugLoc() const;\n\n    /// Return \\c this as a bar \\a MDNode.\n    MDNode *getAsMDNode() const { return Loc; }\n\n    /// Check if the DebugLoc corresponds to an implicit code.\n    bool isImplicitCode() const;\n    void setImplicitCode(bool ImplicitCode);\n\n    bool operator==(const DebugLoc &DL) const { return Loc == DL.Loc; }\n    bool operator!=(const DebugLoc &DL) const { return Loc != DL.Loc; }\n\n    void dump() const;\n\n    /// prints source location /path/to/file.exe:line:col @[inlined at]\n    void print(raw_ostream &OS) const;\n  };\n\n} // end namespace llvm\n\n#endif // LLVM_IR_DEBUGLOC_H\n"}, "39": {"id": 39, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Intrinsics.h", "content": "//===- Intrinsics.h - LLVM Intrinsic Function Handling ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines a set of enums which allow processing of intrinsic\n// functions.  Values of these enum types are returned by\n// Function::getIntrinsicID.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_INTRINSICS_H\n#define LLVM_IR_INTRINSICS_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/Support/TypeSize.h\"\n#include <string>\n\nnamespace llvm {\n\nclass Type;\nclass FunctionType;\nclass Function;\nclass LLVMContext;\nclass Module;\nclass AttributeList;\n\n/// This namespace contains an enum with a value for every intrinsic/builtin\n/// function known by LLVM. The enum values are returned by\n/// Function::getIntrinsicID().\nnamespace Intrinsic {\n  // Abstraction for the arguments of the noalias intrinsics\n  static const int NoAliasScopeDeclScopeArg = 0;\n\n  // Intrinsic ID type. This is an opaque typedef to facilitate splitting up\n  // the enum into target-specific enums.\n  typedef unsigned ID;\n\n  enum IndependentIntrinsics : unsigned {\n    not_intrinsic = 0, // Must be zero\n\n  // Get the intrinsic enums generated from Intrinsics.td\n#define GET_INTRINSIC_ENUM_VALUES\n#include \"llvm/IR/IntrinsicEnums.inc\"\n#undef GET_INTRINSIC_ENUM_VALUES\n  };\n\n  /// Return the LLVM name for an intrinsic, such as \"llvm.ppc.altivec.lvx\".\n  /// Note, this version is for intrinsics with no overloads.  Use the other\n  /// version of getName if overloads are required.\n  StringRef getName(ID id);\n\n  /// Return the LLVM name for an intrinsic, such as \"llvm.ppc.altivec.lvx\".\n  /// Note, this version of getName supports overloads, but not unnamed types.\n  /// It is less efficient than the StringRef version of this function. If no\n  /// overloads are required, it is safe to use this version, but better to use\n  /// the StringRef version.\n  std::string getName(ID Id, ArrayRef<Type *> Tys);\n\n  /// Return the LLVM name for an intrinsic, such as \"llvm.ssa.copy.p0s_s.1\".\n  /// Note, this version of getName supports overloads and unnamed types, but is\n  /// less efficient than the StringRef version of this function.  If no\n  /// overloads are required, it is safe to use this version, but better to use\n  /// the StringRef version. A function type FT can be provided to avoid\n  /// computing it. It is used (or computed) if one of the types is based on an\n  /// unnamed type.\n  std::string getName(ID Id, ArrayRef<Type *> Tys, Module *M, FunctionType *FT);\n\n  /// Return the function type for an intrinsic.\n  FunctionType *getType(LLVMContext &Context, ID id,\n                        ArrayRef<Type*> Tys = None);\n\n  /// Returns true if the intrinsic can be overloaded.\n  bool isOverloaded(ID id);\n\n  /// Returns true if the intrinsic is a leaf, i.e. it does not make any calls\n  /// itself.  Most intrinsics are leafs, the exceptions being the patchpoint\n  /// and statepoint intrinsics. These call (or invoke) their \"target\" argument.\n  bool isLeaf(ID id);\n\n  /// Return the attributes for an intrinsic.\n  AttributeList getAttributes(LLVMContext &C, ID id);\n\n  /// Create or insert an LLVM Function declaration for an intrinsic, and return\n  /// it.\n  ///\n  /// The Tys parameter is for intrinsics with overloaded types (e.g., those\n  /// using iAny, fAny, vAny, or iPTRAny).  For a declaration of an overloaded\n  /// intrinsic, Tys must provide exactly one type for each overloaded type in\n  /// the intrinsic.\n  Function *getDeclaration(Module *M, ID id, ArrayRef<Type*> Tys = None);\n\n  /// Looks up Name in NameTable via binary search. NameTable must be sorted\n  /// and all entries must start with \"llvm.\".  If NameTable contains an exact\n  /// match for Name or a prefix of Name followed by a dot, its index in\n  /// NameTable is returned. Otherwise, -1 is returned.\n  int lookupLLVMIntrinsicByName(ArrayRef<const char *> NameTable,\n                                StringRef Name);\n\n  /// Map a GCC builtin name to an intrinsic ID.\n  ID getIntrinsicForGCCBuiltin(const char *Prefix, StringRef BuiltinName);\n\n  /// Map a MS builtin name to an intrinsic ID.\n  ID getIntrinsicForMSBuiltin(const char *Prefix, StringRef BuiltinName);\n\n  /// This is a type descriptor which explains the type requirements of an\n  /// intrinsic. This is returned by getIntrinsicInfoTableEntries.\n  struct IITDescriptor {\n    enum IITDescriptorKind {\n      Void,\n      VarArg,\n      MMX,\n      Token,\n      Metadata,\n      Half,\n      BFloat,\n      Float,\n      Double,\n      Quad,\n      Integer,\n      Vector,\n      Pointer,\n      Struct,\n      Argument,\n      ExtendArgument,\n      TruncArgument,\n      HalfVecArgument,\n      SameVecWidthArgument,\n      PtrToArgument,\n      PtrToElt,\n      VecOfAnyPtrsToElt,\n      VecElementArgument,\n      Subdivide2Argument,\n      Subdivide4Argument,\n      VecOfBitcastsToInt,\n      AMX\n    } Kind;\n\n    union {\n      unsigned Integer_Width;\n      unsigned Float_Width;\n      unsigned Pointer_AddressSpace;\n      unsigned Struct_NumElements;\n      unsigned Argument_Info;\n      ElementCount Vector_Width;\n    };\n\n    enum ArgKind {\n      AK_Any,\n      AK_AnyInteger,\n      AK_AnyFloat,\n      AK_AnyVector,\n      AK_AnyPointer,\n      AK_MatchType = 7\n    };\n\n    unsigned getArgumentNumber() const {\n      assert(Kind == Argument || Kind == ExtendArgument ||\n             Kind == TruncArgument || Kind == HalfVecArgument ||\n             Kind == SameVecWidthArgument || Kind == PtrToArgument ||\n             Kind == PtrToElt || Kind == VecElementArgument ||\n             Kind == Subdivide2Argument || Kind == Subdivide4Argument ||\n             Kind == VecOfBitcastsToInt);\n      return Argument_Info >> 3;\n    }\n    ArgKind getArgumentKind() const {\n      assert(Kind == Argument || Kind == ExtendArgument ||\n             Kind == TruncArgument || Kind == HalfVecArgument ||\n             Kind == SameVecWidthArgument || Kind == PtrToArgument ||\n             Kind == VecElementArgument || Kind == Subdivide2Argument ||\n             Kind == Subdivide4Argument || Kind == VecOfBitcastsToInt);\n      return (ArgKind)(Argument_Info & 7);\n    }\n\n    // VecOfAnyPtrsToElt uses both an overloaded argument (for address space)\n    // and a reference argument (for matching vector width and element types)\n    unsigned getOverloadArgNumber() const {\n      assert(Kind == VecOfAnyPtrsToElt);\n      return Argument_Info >> 16;\n    }\n    unsigned getRefArgNumber() const {\n      assert(Kind == VecOfAnyPtrsToElt);\n      return Argument_Info & 0xFFFF;\n    }\n\n    static IITDescriptor get(IITDescriptorKind K, unsigned Field) {\n      IITDescriptor Result = { K, { Field } };\n      return Result;\n    }\n\n    static IITDescriptor get(IITDescriptorKind K, unsigned short Hi,\n                             unsigned short Lo) {\n      unsigned Field = Hi << 16 | Lo;\n      IITDescriptor Result = {K, {Field}};\n      return Result;\n    }\n\n    static IITDescriptor getVector(unsigned Width, bool IsScalable) {\n      IITDescriptor Result = {Vector, {0}};\n      Result.Vector_Width = ElementCount::get(Width, IsScalable);\n      return Result;\n    }\n  };\n\n  /// Return the IIT table descriptor for the specified intrinsic into an array\n  /// of IITDescriptors.\n  void getIntrinsicInfoTableEntries(ID id, SmallVectorImpl<IITDescriptor> &T);\n\n  enum MatchIntrinsicTypesResult {\n    MatchIntrinsicTypes_Match = 0,\n    MatchIntrinsicTypes_NoMatchRet = 1,\n    MatchIntrinsicTypes_NoMatchArg = 2,\n  };\n\n  /// Match the specified function type with the type constraints specified by\n  /// the .td file. If the given type is an overloaded type it is pushed to the\n  /// ArgTys vector.\n  ///\n  /// Returns false if the given type matches with the constraints, true\n  /// otherwise.\n  MatchIntrinsicTypesResult\n  matchIntrinsicSignature(FunctionType *FTy, ArrayRef<IITDescriptor> &Infos,\n                          SmallVectorImpl<Type *> &ArgTys);\n\n  /// Verify if the intrinsic has variable arguments. This method is intended to\n  /// be called after all the fixed arguments have been matched first.\n  ///\n  /// This method returns true on error.\n  bool matchIntrinsicVarArg(bool isVarArg, ArrayRef<IITDescriptor> &Infos);\n\n  /// Gets the type arguments of an intrinsic call by matching type contraints\n  /// specified by the .td file. The overloaded types are pushed into the\n  /// AgTys vector.\n  ///\n  /// Returns false if the given function is not a valid intrinsic call.\n  bool getIntrinsicSignature(Function *F, SmallVectorImpl<Type *> &ArgTys);\n\n  // Checks if the intrinsic name matches with its signature and if not\n  // returns the declaration with the same signature and remangled name.\n  llvm::Optional<Function*> remangleIntrinsicFunction(Function *F);\n\n} // End Intrinsic namespace\n\n} // End llvm namespace\n\n#endif\n"}, "40": {"id": 40, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "content": "//===- llvm/IR/Metadata.h - Metadata definitions ----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// @file\n/// This file contains the declarations for metadata subclasses.\n/// They represent the different flavors of metadata that live in LLVM.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_METADATA_H\n#define LLVM_IR_METADATA_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/ilist_node.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/IR/Constant.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/Support/CBindingWrapping.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <memory>\n#include <string>\n#include <type_traits>\n#include <utility>\n\nnamespace llvm {\n\nclass Module;\nclass ModuleSlotTracker;\nclass raw_ostream;\nclass Type;\n\nenum LLVMConstants : uint32_t {\n  DEBUG_METADATA_VERSION = 3 // Current debug info version number.\n};\n\n/// Root of the metadata hierarchy.\n///\n/// This is a root class for typeless data in the IR.\nclass Metadata {\n  friend class ReplaceableMetadataImpl;\n\n  /// RTTI.\n  const unsigned char SubclassID;\n\nprotected:\n  /// Active type of storage.\n  enum StorageType { Uniqued, Distinct, Temporary };\n\n  /// Storage flag for non-uniqued, otherwise unowned, metadata.\n  unsigned char Storage : 7;\n\n  unsigned char SubclassData1 : 1;\n  unsigned short SubclassData16 = 0;\n  unsigned SubclassData32 = 0;\n\npublic:\n  enum MetadataKind {\n#define HANDLE_METADATA_LEAF(CLASS) CLASS##Kind,\n#include \"llvm/IR/Metadata.def\"\n  };\n\nprotected:\n  Metadata(unsigned ID, StorageType Storage)\n      : SubclassID(ID), Storage(Storage), SubclassData1(false) {\n    static_assert(sizeof(*this) == 8, \"Metadata fields poorly packed\");\n  }\n\n  ~Metadata() = default;\n\n  /// Default handling of a changed operand, which asserts.\n  ///\n  /// If subclasses pass themselves in as owners to a tracking node reference,\n  /// they must provide an implementation of this method.\n  void handleChangedOperand(void *, Metadata *) {\n    llvm_unreachable(\"Unimplemented in Metadata subclass\");\n  }\n\npublic:\n  unsigned getMetadataID() const { return SubclassID; }\n\n  /// User-friendly dump.\n  ///\n  /// If \\c M is provided, metadata nodes will be numbered canonically;\n  /// otherwise, pointer addresses are substituted.\n  ///\n  /// Note: this uses an explicit overload instead of default arguments so that\n  /// the nullptr version is easy to call from a debugger.\n  ///\n  /// @{\n  void dump() const;\n  void dump(const Module *M) const;\n  /// @}\n\n  /// Print.\n  ///\n  /// Prints definition of \\c this.\n  ///\n  /// If \\c M is provided, metadata nodes will be numbered canonically;\n  /// otherwise, pointer addresses are substituted.\n  /// @{\n  void print(raw_ostream &OS, const Module *M = nullptr,\n             bool IsForDebug = false) const;\n  void print(raw_ostream &OS, ModuleSlotTracker &MST, const Module *M = nullptr,\n             bool IsForDebug = false) const;\n  /// @}\n\n  /// Print as operand.\n  ///\n  /// Prints reference of \\c this.\n  ///\n  /// If \\c M is provided, metadata nodes will be numbered canonically;\n  /// otherwise, pointer addresses are substituted.\n  /// @{\n  void printAsOperand(raw_ostream &OS, const Module *M = nullptr) const;\n  void printAsOperand(raw_ostream &OS, ModuleSlotTracker &MST,\n                      const Module *M = nullptr) const;\n  /// @}\n};\n\n// Create wrappers for C Binding types (see CBindingWrapping.h).\nDEFINE_ISA_CONVERSION_FUNCTIONS(Metadata, LLVMMetadataRef)\n\n// Specialized opaque metadata conversions.\ninline Metadata **unwrap(LLVMMetadataRef *MDs) {\n  return reinterpret_cast<Metadata**>(MDs);\n}\n\n#define HANDLE_METADATA(CLASS) class CLASS;\n#include \"llvm/IR/Metadata.def\"\n\n// Provide specializations of isa so that we don't need definitions of\n// subclasses to see if the metadata is a subclass.\n#define HANDLE_METADATA_LEAF(CLASS)                                            \\\n  template <> struct isa_impl<CLASS, Metadata> {                               \\\n    static inline bool doit(const Metadata &MD) {                              \\\n      return MD.getMetadataID() == Metadata::CLASS##Kind;                      \\\n    }                                                                          \\\n  };\n#include \"llvm/IR/Metadata.def\"\n\ninline raw_ostream &operator<<(raw_ostream &OS, const Metadata &MD) {\n  MD.print(OS);\n  return OS;\n}\n\n/// Metadata wrapper in the Value hierarchy.\n///\n/// A member of the \\a Value hierarchy to represent a reference to metadata.\n/// This allows, e.g., instrinsics to have metadata as operands.\n///\n/// Notably, this is the only thing in either hierarchy that is allowed to\n/// reference \\a LocalAsMetadata.\nclass MetadataAsValue : public Value {\n  friend class ReplaceableMetadataImpl;\n  friend class LLVMContextImpl;\n\n  Metadata *MD;\n\n  MetadataAsValue(Type *Ty, Metadata *MD);\n\n  /// Drop use of metadata (during teardown).\n  void dropUse() { MD = nullptr; }\n\npublic:\n  ~MetadataAsValue();\n\n  static MetadataAsValue *get(LLVMContext &Context, Metadata *MD);\n  static MetadataAsValue *getIfExists(LLVMContext &Context, Metadata *MD);\n\n  Metadata *getMetadata() const { return MD; }\n\n  static bool classof(const Value *V) {\n    return V->getValueID() == MetadataAsValueVal;\n  }\n\nprivate:\n  void handleChangedMetadata(Metadata *MD);\n  void track();\n  void untrack();\n};\n\n/// API for tracking metadata references through RAUW and deletion.\n///\n/// Shared API for updating \\a Metadata pointers in subclasses that support\n/// RAUW.\n///\n/// This API is not meant to be used directly.  See \\a TrackingMDRef for a\n/// user-friendly tracking reference.\nclass MetadataTracking {\npublic:\n  /// Track the reference to metadata.\n  ///\n  /// Register \\c MD with \\c *MD, if the subclass supports tracking.  If \\c *MD\n  /// gets RAUW'ed, \\c MD will be updated to the new address.  If \\c *MD gets\n  /// deleted, \\c MD will be set to \\c nullptr.\n  ///\n  /// If tracking isn't supported, \\c *MD will not change.\n  ///\n  /// \\return true iff tracking is supported by \\c MD.\n  static bool track(Metadata *&MD) {\n    return track(&MD, *MD, static_cast<Metadata *>(nullptr));\n  }\n\n  /// Track the reference to metadata for \\a Metadata.\n  ///\n  /// As \\a track(Metadata*&), but with support for calling back to \\c Owner to\n  /// tell it that its operand changed.  This could trigger \\c Owner being\n  /// re-uniqued.\n  static bool track(void *Ref, Metadata &MD, Metadata &Owner) {\n    return track(Ref, MD, &Owner);\n  }\n\n  /// Track the reference to metadata for \\a MetadataAsValue.\n  ///\n  /// As \\a track(Metadata*&), but with support for calling back to \\c Owner to\n  /// tell it that its operand changed.  This could trigger \\c Owner being\n  /// re-uniqued.\n  static bool track(void *Ref, Metadata &MD, MetadataAsValue &Owner) {\n    return track(Ref, MD, &Owner);\n  }\n\n  /// Stop tracking a reference to metadata.\n  ///\n  /// Stops \\c *MD from tracking \\c MD.\n  static void untrack(Metadata *&MD) { untrack(&MD, *MD); }\n  static void untrack(void *Ref, Metadata &MD);\n\n  /// Move tracking from one reference to another.\n  ///\n  /// Semantically equivalent to \\c untrack(MD) followed by \\c track(New),\n  /// except that ownership callbacks are maintained.\n  ///\n  /// Note: it is an error if \\c *MD does not equal \\c New.\n  ///\n  /// \\return true iff tracking is supported by \\c MD.\n  static bool retrack(Metadata *&MD, Metadata *&New) {\n    return retrack(&MD, *MD, &New);\n  }\n  static bool retrack(void *Ref, Metadata &MD, void *New);\n\n  /// Check whether metadata is replaceable.\n  static bool isReplaceable(const Metadata &MD);\n\n  using OwnerTy = PointerUnion<MetadataAsValue *, Metadata *>;\n\nprivate:\n  /// Track a reference to metadata for an owner.\n  ///\n  /// Generalized version of tracking.\n  static bool track(void *Ref, Metadata &MD, OwnerTy Owner);\n};\n\n/// Shared implementation of use-lists for replaceable metadata.\n///\n/// Most metadata cannot be RAUW'ed.  This is a shared implementation of\n/// use-lists and associated API for the two that support it (\\a ValueAsMetadata\n/// and \\a TempMDNode).\nclass ReplaceableMetadataImpl {\n  friend class MetadataTracking;\n\npublic:\n  using OwnerTy = MetadataTracking::OwnerTy;\n\nprivate:\n  LLVMContext &Context;\n  uint64_t NextIndex = 0;\n  SmallDenseMap<void *, std::pair<OwnerTy, uint64_t>, 4> UseMap;\n\npublic:\n  ReplaceableMetadataImpl(LLVMContext &Context) : Context(Context) {}\n\n  ~ReplaceableMetadataImpl() {\n    assert(UseMap.empty() && \"Cannot destroy in-use replaceable metadata\");\n  }\n\n  LLVMContext &getContext() const { return Context; }\n\n  /// Replace all uses of this with MD.\n  ///\n  /// Replace all uses of this with \\c MD, which is allowed to be null.\n  void replaceAllUsesWith(Metadata *MD);\n\n  /// Returns the list of all DIArgList users of this.\n  SmallVector<Metadata *, 4> getAllArgListUsers();\n\n  /// Resolve all uses of this.\n  ///\n  /// Resolve all uses of this, turning off RAUW permanently.  If \\c\n  /// ResolveUsers, call \\a MDNode::resolve() on any users whose last operand\n  /// is resolved.\n  void resolveAllUses(bool ResolveUsers = true);\n\nprivate:\n  void addRef(void *Ref, OwnerTy Owner);\n  void dropRef(void *Ref);\n  void moveRef(void *Ref, void *New, const Metadata &MD);\n\n  /// Lazily construct RAUW support on MD.\n  ///\n  /// If this is an unresolved MDNode, RAUW support will be created on-demand.\n  /// ValueAsMetadata always has RAUW support.\n  static ReplaceableMetadataImpl *getOrCreate(Metadata &MD);\n\n  /// Get RAUW support on MD, if it exists.\n  static ReplaceableMetadataImpl *getIfExists(Metadata &MD);\n\n  /// Check whether this node will support RAUW.\n  ///\n  /// Returns \\c true unless getOrCreate() would return null.\n  static bool isReplaceable(const Metadata &MD);\n};\n\n/// Value wrapper in the Metadata hierarchy.\n///\n/// This is a custom value handle that allows other metadata to refer to\n/// classes in the Value hierarchy.\n///\n/// Because of full uniquing support, each value is only wrapped by a single \\a\n/// ValueAsMetadata object, so the lookup maps are far more efficient than\n/// those using ValueHandleBase.\nclass ValueAsMetadata : public Metadata, ReplaceableMetadataImpl {\n  friend class ReplaceableMetadataImpl;\n  friend class LLVMContextImpl;\n\n  Value *V;\n\n  /// Drop users without RAUW (during teardown).\n  void dropUsers() {\n    ReplaceableMetadataImpl::resolveAllUses(/* ResolveUsers */ false);\n  }\n\nprotected:\n  ValueAsMetadata(unsigned ID, Value *V)\n      : Metadata(ID, Uniqued), ReplaceableMetadataImpl(V->getContext()), V(V) {\n    assert(V && \"Expected valid value\");\n  }\n\n  ~ValueAsMetadata() = default;\n\npublic:\n  static ValueAsMetadata *get(Value *V);\n\n  static ConstantAsMetadata *getConstant(Value *C) {\n    return cast<ConstantAsMetadata>(get(C));\n  }\n\n  static LocalAsMetadata *getLocal(Value *Local) {\n    return cast<LocalAsMetadata>(get(Local));\n  }\n\n  static ValueAsMetadata *getIfExists(Value *V);\n\n  static ConstantAsMetadata *getConstantIfExists(Value *C) {\n    return cast_or_null<ConstantAsMetadata>(getIfExists(C));\n  }\n\n  static LocalAsMetadata *getLocalIfExists(Value *Local) {\n    return cast_or_null<LocalAsMetadata>(getIfExists(Local));\n  }\n\n  Value *getValue() const { return V; }\n  Type *getType() const { return V->getType(); }\n  LLVMContext &getContext() const { return V->getContext(); }\n\n  SmallVector<Metadata *, 4> getAllArgListUsers() {\n    return ReplaceableMetadataImpl::getAllArgListUsers();\n  }\n\n  static void handleDeletion(Value *V);\n  static void handleRAUW(Value *From, Value *To);\n\nprotected:\n  /// Handle collisions after \\a Value::replaceAllUsesWith().\n  ///\n  /// RAUW isn't supported directly for \\a ValueAsMetadata, but if the wrapped\n  /// \\a Value gets RAUW'ed and the target already exists, this is used to\n  /// merge the two metadata nodes.\n  void replaceAllUsesWith(Metadata *MD) {\n    ReplaceableMetadataImpl::replaceAllUsesWith(MD);\n  }\n\npublic:\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == LocalAsMetadataKind ||\n           MD->getMetadataID() == ConstantAsMetadataKind;\n  }\n};\n\nclass ConstantAsMetadata : public ValueAsMetadata {\n  friend class ValueAsMetadata;\n\n  ConstantAsMetadata(Constant *C)\n      : ValueAsMetadata(ConstantAsMetadataKind, C) {}\n\npublic:\n  static ConstantAsMetadata *get(Constant *C) {\n    return ValueAsMetadata::getConstant(C);\n  }\n\n  static ConstantAsMetadata *getIfExists(Constant *C) {\n    return ValueAsMetadata::getConstantIfExists(C);\n  }\n\n  Constant *getValue() const {\n    return cast<Constant>(ValueAsMetadata::getValue());\n  }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == ConstantAsMetadataKind;\n  }\n};\n\nclass LocalAsMetadata : public ValueAsMetadata {\n  friend class ValueAsMetadata;\n\n  LocalAsMetadata(Value *Local)\n      : ValueAsMetadata(LocalAsMetadataKind, Local) {\n    assert(!isa<Constant>(Local) && \"Expected local value\");\n  }\n\npublic:\n  static LocalAsMetadata *get(Value *Local) {\n    return ValueAsMetadata::getLocal(Local);\n  }\n\n  static LocalAsMetadata *getIfExists(Value *Local) {\n    return ValueAsMetadata::getLocalIfExists(Local);\n  }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == LocalAsMetadataKind;\n  }\n};\n\n/// Transitional API for extracting constants from Metadata.\n///\n/// This namespace contains transitional functions for metadata that points to\n/// \\a Constants.\n///\n/// In prehistory -- when metadata was a subclass of \\a Value -- \\a MDNode\n/// operands could refer to any \\a Value.  There's was a lot of code like this:\n///\n/// \\code\n///     MDNode *N = ...;\n///     auto *CI = dyn_cast<ConstantInt>(N->getOperand(2));\n/// \\endcode\n///\n/// Now that \\a Value and \\a Metadata are in separate hierarchies, maintaining\n/// the semantics for \\a isa(), \\a cast(), \\a dyn_cast() (etc.) requires three\n/// steps: cast in the \\a Metadata hierarchy, extraction of the \\a Value, and\n/// cast in the \\a Value hierarchy.  Besides creating boiler-plate, this\n/// requires subtle control flow changes.\n///\n/// The end-goal is to create a new type of metadata, called (e.g.) \\a MDInt,\n/// so that metadata can refer to numbers without traversing a bridge to the \\a\n/// Value hierarchy.  In this final state, the code above would look like this:\n///\n/// \\code\n///     MDNode *N = ...;\n///     auto *MI = dyn_cast<MDInt>(N->getOperand(2));\n/// \\endcode\n///\n/// The API in this namespace supports the transition.  \\a MDInt doesn't exist\n/// yet, and even once it does, changing each metadata schema to use it is its\n/// own mini-project.  In the meantime this API prevents us from introducing\n/// complex and bug-prone control flow that will disappear in the end.  In\n/// particular, the above code looks like this:\n///\n/// \\code\n///     MDNode *N = ...;\n///     auto *CI = mdconst::dyn_extract<ConstantInt>(N->getOperand(2));\n/// \\endcode\n///\n/// The full set of provided functions includes:\n///\n///   mdconst::hasa                <=> isa\n///   mdconst::extract             <=> cast\n///   mdconst::extract_or_null     <=> cast_or_null\n///   mdconst::dyn_extract         <=> dyn_cast\n///   mdconst::dyn_extract_or_null <=> dyn_cast_or_null\n///\n/// The target of the cast must be a subclass of \\a Constant.\nnamespace mdconst {\n\nnamespace detail {\n\ntemplate <class T> T &make();\ntemplate <class T, class Result> struct HasDereference {\n  using Yes = char[1];\n  using No = char[2];\n  template <size_t N> struct SFINAE {};\n\n  template <class U, class V>\n  static Yes &hasDereference(SFINAE<sizeof(static_cast<V>(*make<U>()))> * = 0);\n  template <class U, class V> static No &hasDereference(...);\n\n  static const bool value =\n      sizeof(hasDereference<T, Result>(nullptr)) == sizeof(Yes);\n};\ntemplate <class V, class M> struct IsValidPointer {\n  static const bool value = std::is_base_of<Constant, V>::value &&\n                            HasDereference<M, const Metadata &>::value;\n};\ntemplate <class V, class M> struct IsValidReference {\n  static const bool value = std::is_base_of<Constant, V>::value &&\n                            std::is_convertible<M, const Metadata &>::value;\n};\n\n} // end namespace detail\n\n/// Check whether Metadata has a Value.\n///\n/// As an analogue to \\a isa(), check whether \\c MD has an \\a Value inside of\n/// type \\c X.\ntemplate <class X, class Y>\ninline std::enable_if_t<detail::IsValidPointer<X, Y>::value, bool>\nhasa(Y &&MD) {\n  assert(MD && \"Null pointer sent into hasa\");\n  if (auto *V = dyn_cast<ConstantAsMetadata>(MD))\n    return isa<X>(V->getValue());\n  return false;\n}\ntemplate <class X, class Y>\ninline std::enable_if_t<detail::IsValidReference<X, Y &>::value, bool>\nhasa(Y &MD) {\n  return hasa(&MD);\n}\n\n/// Extract a Value from Metadata.\n///\n/// As an analogue to \\a cast(), extract the \\a Value subclass \\c X from \\c MD.\ntemplate <class X, class Y>\ninline std::enable_if_t<detail::IsValidPointer<X, Y>::value, X *>\nextract(Y &&MD) {\n  return cast<X>(cast<ConstantAsMetadata>(MD)->getValue());\n}\ntemplate <class X, class Y>\ninline std::enable_if_t<detail::IsValidReference<X, Y &>::value, X *>\nextract(Y &MD) {\n  return extract(&MD);\n}\n\n/// Extract a Value from Metadata, allowing null.\n///\n/// As an analogue to \\a cast_or_null(), extract the \\a Value subclass \\c X\n/// from \\c MD, allowing \\c MD to be null.\ntemplate <class X, class Y>\ninline std::enable_if_t<detail::IsValidPointer<X, Y>::value, X *>\nextract_or_null(Y &&MD) {\n  if (auto *V = cast_or_null<ConstantAsMetadata>(MD))\n    return cast<X>(V->getValue());\n  return nullptr;\n}\n\n/// Extract a Value from Metadata, if any.\n///\n/// As an analogue to \\a dyn_cast_or_null(), extract the \\a Value subclass \\c X\n/// from \\c MD, return null if \\c MD doesn't contain a \\a Value or if the \\a\n/// Value it does contain is of the wrong subclass.\ntemplate <class X, class Y>\ninline std::enable_if_t<detail::IsValidPointer<X, Y>::value, X *>\ndyn_extract(Y &&MD) {\n  if (auto *V = dyn_cast<ConstantAsMetadata>(MD))\n    return dyn_cast<X>(V->getValue());\n  return nullptr;\n}\n\n/// Extract a Value from Metadata, if any, allowing null.\n///\n/// As an analogue to \\a dyn_cast_or_null(), extract the \\a Value subclass \\c X\n/// from \\c MD, return null if \\c MD doesn't contain a \\a Value or if the \\a\n/// Value it does contain is of the wrong subclass, allowing \\c MD to be null.\ntemplate <class X, class Y>\ninline std::enable_if_t<detail::IsValidPointer<X, Y>::value, X *>\ndyn_extract_or_null(Y &&MD) {\n  if (auto *V = dyn_cast_or_null<ConstantAsMetadata>(MD))\n    return dyn_cast<X>(V->getValue());\n  return nullptr;\n}\n\n} // end namespace mdconst\n\n//===----------------------------------------------------------------------===//\n/// A single uniqued string.\n///\n/// These are used to efficiently contain a byte sequence for metadata.\n/// MDString is always unnamed.\nclass MDString : public Metadata {\n  friend class StringMapEntryStorage<MDString>;\n\n  StringMapEntry<MDString> *Entry = nullptr;\n\n  MDString() : Metadata(MDStringKind, Uniqued) {}\n\npublic:\n  MDString(const MDString &) = delete;\n  MDString &operator=(MDString &&) = delete;\n  MDString &operator=(const MDString &) = delete;\n\n  static MDString *get(LLVMContext &Context, StringRef Str);\n  static MDString *get(LLVMContext &Context, const char *Str) {\n    return get(Context, Str ? StringRef(Str) : StringRef());\n  }\n\n  StringRef getString() const;\n\n  unsigned getLength() const { return (unsigned)getString().size(); }\n\n  using iterator = StringRef::iterator;\n\n  /// Pointer to the first byte of the string.\n  iterator begin() const { return getString().begin(); }\n\n  /// Pointer to one byte past the end of the string.\n  iterator end() const { return getString().end(); }\n\n  const unsigned char *bytes_begin() const { return getString().bytes_begin(); }\n  const unsigned char *bytes_end() const { return getString().bytes_end(); }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast.\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == MDStringKind;\n  }\n};\n\n/// A collection of metadata nodes that might be associated with a\n/// memory access used by the alias-analysis infrastructure.\nstruct AAMDNodes {\n  explicit AAMDNodes() = default;\n  explicit AAMDNodes(MDNode *T, MDNode *TS, MDNode *S, MDNode *N)\n      : TBAA(T), TBAAStruct(TS), Scope(S), NoAlias(N) {}\n\n  bool operator==(const AAMDNodes &A) const {\n    return TBAA == A.TBAA && TBAAStruct == A.TBAAStruct && Scope == A.Scope &&\n           NoAlias == A.NoAlias;\n  }\n\n  bool operator!=(const AAMDNodes &A) const { return !(*this == A); }\n\n  explicit operator bool() const {\n    return TBAA || TBAAStruct || Scope || NoAlias;\n  }\n\n  /// The tag for type-based alias analysis.\n  MDNode *TBAA = nullptr;\n\n  /// The tag for type-based alias analysis (tbaa struct).\n  MDNode *TBAAStruct = nullptr;\n\n  /// The tag for alias scope specification (used with noalias).\n  MDNode *Scope = nullptr;\n\n  /// The tag specifying the noalias scope.\n  MDNode *NoAlias = nullptr;\n\n  // Shift tbaa Metadata node to start off bytes later\n  static MDNode *ShiftTBAA(MDNode *M, size_t off);\n\n  // Shift tbaa.struct Metadata node to start off bytes later\n  static MDNode *ShiftTBAAStruct(MDNode *M, size_t off);\n\n  /// Given two sets of AAMDNodes that apply to the same pointer,\n  /// give the best AAMDNodes that are compatible with both (i.e. a set of\n  /// nodes whose allowable aliasing conclusions are a subset of those\n  /// allowable by both of the inputs). However, for efficiency\n  /// reasons, do not create any new MDNodes.\n  AAMDNodes intersect(const AAMDNodes &Other) {\n    AAMDNodes Result;\n    Result.TBAA = Other.TBAA == TBAA ? TBAA : nullptr;\n    Result.TBAAStruct = Other.TBAAStruct == TBAAStruct ? TBAAStruct : nullptr;\n    Result.Scope = Other.Scope == Scope ? Scope : nullptr;\n    Result.NoAlias = Other.NoAlias == NoAlias ? NoAlias : nullptr;\n    return Result;\n  }\n\n  /// Create a new AAMDNode that describes this AAMDNode after applying a\n  /// constant offset to the start of the pointer\n  AAMDNodes shift(size_t Offset) {\n    AAMDNodes Result;\n    Result.TBAA = TBAA ? ShiftTBAA(TBAA, Offset) : nullptr;\n    Result.TBAAStruct =\n        TBAAStruct ? ShiftTBAAStruct(TBAAStruct, Offset) : nullptr;\n    Result.Scope = Scope;\n    Result.NoAlias = NoAlias;\n    return Result;\n  }\n};\n\n// Specialize DenseMapInfo for AAMDNodes.\ntemplate<>\nstruct DenseMapInfo<AAMDNodes> {\n  static inline AAMDNodes getEmptyKey() {\n    return AAMDNodes(DenseMapInfo<MDNode *>::getEmptyKey(),\n                     nullptr, nullptr, nullptr);\n  }\n\n  static inline AAMDNodes getTombstoneKey() {\n    return AAMDNodes(DenseMapInfo<MDNode *>::getTombstoneKey(),\n                     nullptr, nullptr, nullptr);\n  }\n\n  static unsigned getHashValue(const AAMDNodes &Val) {\n    return DenseMapInfo<MDNode *>::getHashValue(Val.TBAA) ^\n           DenseMapInfo<MDNode *>::getHashValue(Val.TBAAStruct) ^\n           DenseMapInfo<MDNode *>::getHashValue(Val.Scope) ^\n           DenseMapInfo<MDNode *>::getHashValue(Val.NoAlias);\n  }\n\n  static bool isEqual(const AAMDNodes &LHS, const AAMDNodes &RHS) {\n    return LHS == RHS;\n  }\n};\n\n/// Tracking metadata reference owned by Metadata.\n///\n/// Similar to \\a TrackingMDRef, but it's expected to be owned by an instance\n/// of \\a Metadata, which has the option of registering itself for callbacks to\n/// re-unique itself.\n///\n/// In particular, this is used by \\a MDNode.\nclass MDOperand {\n  Metadata *MD = nullptr;\n\npublic:\n  MDOperand() = default;\n  MDOperand(MDOperand &&) = delete;\n  MDOperand(const MDOperand &) = delete;\n  MDOperand &operator=(MDOperand &&) = delete;\n  MDOperand &operator=(const MDOperand &) = delete;\n  ~MDOperand() { untrack(); }\n\n  Metadata *get() const { return MD; }\n  operator Metadata *() const { return get(); }\n  Metadata *operator->() const { return get(); }\n  Metadata &operator*() const { return *get(); }\n\n  void reset() {\n    untrack();\n    MD = nullptr;\n  }\n  void reset(Metadata *MD, Metadata *Owner) {\n    untrack();\n    this->MD = MD;\n    track(Owner);\n  }\n\nprivate:\n  void track(Metadata *Owner) {\n    if (MD) {\n      if (Owner)\n        MetadataTracking::track(this, *MD, *Owner);\n      else\n        MetadataTracking::track(MD);\n    }\n  }\n\n  void untrack() {\n    assert(static_cast<void *>(this) == &MD && \"Expected same address\");\n    if (MD)\n      MetadataTracking::untrack(MD);\n  }\n};\n\ntemplate <> struct simplify_type<MDOperand> {\n  using SimpleType = Metadata *;\n\n  static SimpleType getSimplifiedValue(MDOperand &MD) { return MD.get(); }\n};\n\ntemplate <> struct simplify_type<const MDOperand> {\n  using SimpleType = Metadata *;\n\n  static SimpleType getSimplifiedValue(const MDOperand &MD) { return MD.get(); }\n};\n\n/// Pointer to the context, with optional RAUW support.\n///\n/// Either a raw (non-null) pointer to the \\a LLVMContext, or an owned pointer\n/// to \\a ReplaceableMetadataImpl (which has a reference to \\a LLVMContext).\nclass ContextAndReplaceableUses {\n  PointerUnion<LLVMContext *, ReplaceableMetadataImpl *> Ptr;\n\npublic:\n  ContextAndReplaceableUses(LLVMContext &Context) : Ptr(&Context) {}\n  ContextAndReplaceableUses(\n      std::unique_ptr<ReplaceableMetadataImpl> ReplaceableUses)\n      : Ptr(ReplaceableUses.release()) {\n    assert(getReplaceableUses() && \"Expected non-null replaceable uses\");\n  }\n  ContextAndReplaceableUses() = delete;\n  ContextAndReplaceableUses(ContextAndReplaceableUses &&) = delete;\n  ContextAndReplaceableUses(const ContextAndReplaceableUses &) = delete;\n  ContextAndReplaceableUses &operator=(ContextAndReplaceableUses &&) = delete;\n  ContextAndReplaceableUses &\n  operator=(const ContextAndReplaceableUses &) = delete;\n  ~ContextAndReplaceableUses() { delete getReplaceableUses(); }\n\n  operator LLVMContext &() { return getContext(); }\n\n  /// Whether this contains RAUW support.\n  bool hasReplaceableUses() const {\n    return Ptr.is<ReplaceableMetadataImpl *>();\n  }\n\n  LLVMContext &getContext() const {\n    if (hasReplaceableUses())\n      return getReplaceableUses()->getContext();\n    return *Ptr.get<LLVMContext *>();\n  }\n\n  ReplaceableMetadataImpl *getReplaceableUses() const {\n    if (hasReplaceableUses())\n      return Ptr.get<ReplaceableMetadataImpl *>();\n    return nullptr;\n  }\n\n  /// Ensure that this has RAUW support, and then return it.\n  ReplaceableMetadataImpl *getOrCreateReplaceableUses() {\n    if (!hasReplaceableUses())\n      makeReplaceable(std::make_unique<ReplaceableMetadataImpl>(getContext()));\n    return getReplaceableUses();\n  }\n\n  /// Assign RAUW support to this.\n  ///\n  /// Make this replaceable, taking ownership of \\c ReplaceableUses (which must\n  /// not be null).\n  void\n  makeReplaceable(std::unique_ptr<ReplaceableMetadataImpl> ReplaceableUses) {\n    assert(ReplaceableUses && \"Expected non-null replaceable uses\");\n    assert(&ReplaceableUses->getContext() == &getContext() &&\n           \"Expected same context\");\n    delete getReplaceableUses();\n    Ptr = ReplaceableUses.release();\n  }\n\n  /// Drop RAUW support.\n  ///\n  /// Cede ownership of RAUW support, returning it.\n  std::unique_ptr<ReplaceableMetadataImpl> takeReplaceableUses() {\n    assert(hasReplaceableUses() && \"Expected to own replaceable uses\");\n    std::unique_ptr<ReplaceableMetadataImpl> ReplaceableUses(\n        getReplaceableUses());\n    Ptr = &ReplaceableUses->getContext();\n    return ReplaceableUses;\n  }\n};\n\nstruct TempMDNodeDeleter {\n  inline void operator()(MDNode *Node) const;\n};\n\n#define HANDLE_MDNODE_LEAF(CLASS)                                              \\\n  using Temp##CLASS = std::unique_ptr<CLASS, TempMDNodeDeleter>;\n#define HANDLE_MDNODE_BRANCH(CLASS) HANDLE_MDNODE_LEAF(CLASS)\n#include \"llvm/IR/Metadata.def\"\n\n/// Metadata node.\n///\n/// Metadata nodes can be uniqued, like constants, or distinct.  Temporary\n/// metadata nodes (with full support for RAUW) can be used to delay uniquing\n/// until forward references are known.  The basic metadata node is an \\a\n/// MDTuple.\n///\n/// There is limited support for RAUW at construction time.  At construction\n/// time, if any operand is a temporary node (or an unresolved uniqued node,\n/// which indicates a transitive temporary operand), the node itself will be\n/// unresolved.  As soon as all operands become resolved, it will drop RAUW\n/// support permanently.\n///\n/// If an unresolved node is part of a cycle, \\a resolveCycles() needs\n/// to be called on some member of the cycle once all temporary nodes have been\n/// replaced.\nclass MDNode : public Metadata {\n  friend class ReplaceableMetadataImpl;\n  friend class LLVMContextImpl;\n\n  unsigned NumOperands;\n  unsigned NumUnresolved;\n\n  ContextAndReplaceableUses Context;\n\nprotected:\n  MDNode(LLVMContext &Context, unsigned ID, StorageType Storage,\n         ArrayRef<Metadata *> Ops1, ArrayRef<Metadata *> Ops2 = None);\n  ~MDNode() = default;\n\n  void *operator new(size_t Size, unsigned NumOps);\n  void operator delete(void *Mem);\n\n  /// Required by std, but never called.\n  void operator delete(void *, unsigned) {\n    llvm_unreachable(\"Constructor throws?\");\n  }\n\n  /// Required by std, but never called.\n  void operator delete(void *, unsigned, bool) {\n    llvm_unreachable(\"Constructor throws?\");\n  }\n\n  void dropAllReferences();\n\n  MDOperand *mutable_begin() { return mutable_end() - NumOperands; }\n  MDOperand *mutable_end() { return reinterpret_cast<MDOperand *>(this); }\n\n  using mutable_op_range = iterator_range<MDOperand *>;\n\n  mutable_op_range mutable_operands() {\n    return mutable_op_range(mutable_begin(), mutable_end());\n  }\n\npublic:\n  MDNode(const MDNode &) = delete;\n  void operator=(const MDNode &) = delete;\n  void *operator new(size_t) = delete;\n\n  static inline MDTuple *get(LLVMContext &Context, ArrayRef<Metadata *> MDs);\n  static inline MDTuple *getIfExists(LLVMContext &Context,\n                                     ArrayRef<Metadata *> MDs);\n  static inline MDTuple *getDistinct(LLVMContext &Context,\n                                     ArrayRef<Metadata *> MDs);\n  static inline TempMDTuple getTemporary(LLVMContext &Context,\n                                         ArrayRef<Metadata *> MDs);\n\n  /// Create a (temporary) clone of this.\n  TempMDNode clone() const;\n\n  /// Deallocate a node created by getTemporary.\n  ///\n  /// Calls \\c replaceAllUsesWith(nullptr) before deleting, so any remaining\n  /// references will be reset.\n  static void deleteTemporary(MDNode *N);\n\n  LLVMContext &getContext() const { return Context.getContext(); }\n\n  /// Replace a specific operand.\n  void replaceOperandWith(unsigned I, Metadata *New);\n\n  /// Check if node is fully resolved.\n  ///\n  /// If \\a isTemporary(), this always returns \\c false; if \\a isDistinct(),\n  /// this always returns \\c true.\n  ///\n  /// If \\a isUniqued(), returns \\c true if this has already dropped RAUW\n  /// support (because all operands are resolved).\n  ///\n  /// As forward declarations are resolved, their containers should get\n  /// resolved automatically.  However, if this (or one of its operands) is\n  /// involved in a cycle, \\a resolveCycles() needs to be called explicitly.\n  bool isResolved() const { return !isTemporary() && !NumUnresolved; }\n\n  bool isUniqued() const { return Storage == Uniqued; }\n  bool isDistinct() const { return Storage == Distinct; }\n  bool isTemporary() const { return Storage == Temporary; }\n\n  /// RAUW a temporary.\n  ///\n  /// \\pre \\a isTemporary() must be \\c true.\n  void replaceAllUsesWith(Metadata *MD) {\n    assert(isTemporary() && \"Expected temporary node\");\n    if (Context.hasReplaceableUses())\n      Context.getReplaceableUses()->replaceAllUsesWith(MD);\n  }\n\n  /// Resolve cycles.\n  ///\n  /// Once all forward declarations have been resolved, force cycles to be\n  /// resolved.\n  ///\n  /// \\pre No operands (or operands' operands, etc.) have \\a isTemporary().\n  void resolveCycles();\n\n  /// Resolve a unique, unresolved node.\n  void resolve();\n\n  /// Replace a temporary node with a permanent one.\n  ///\n  /// Try to create a uniqued version of \\c N -- in place, if possible -- and\n  /// return it.  If \\c N cannot be uniqued, return a distinct node instead.\n  template <class T>\n  static std::enable_if_t<std::is_base_of<MDNode, T>::value, T *>\n  replaceWithPermanent(std::unique_ptr<T, TempMDNodeDeleter> N) {\n    return cast<T>(N.release()->replaceWithPermanentImpl());\n  }\n\n  /// Replace a temporary node with a uniqued one.\n  ///\n  /// Create a uniqued version of \\c N -- in place, if possible -- and return\n  /// it.  Takes ownership of the temporary node.\n  ///\n  /// \\pre N does not self-reference.\n  template <class T>\n  static std::enable_if_t<std::is_base_of<MDNode, T>::value, T *>\n  replaceWithUniqued(std::unique_ptr<T, TempMDNodeDeleter> N) {\n    return cast<T>(N.release()->replaceWithUniquedImpl());\n  }\n\n  /// Replace a temporary node with a distinct one.\n  ///\n  /// Create a distinct version of \\c N -- in place, if possible -- and return\n  /// it.  Takes ownership of the temporary node.\n  template <class T>\n  static std::enable_if_t<std::is_base_of<MDNode, T>::value, T *>\n  replaceWithDistinct(std::unique_ptr<T, TempMDNodeDeleter> N) {\n    return cast<T>(N.release()->replaceWithDistinctImpl());\n  }\n\nprivate:\n  MDNode *replaceWithPermanentImpl();\n  MDNode *replaceWithUniquedImpl();\n  MDNode *replaceWithDistinctImpl();\n\nprotected:\n  /// Set an operand.\n  ///\n  /// Sets the operand directly, without worrying about uniquing.\n  void setOperand(unsigned I, Metadata *New);\n\n  void storeDistinctInContext();\n  template <class T, class StoreT>\n  static T *storeImpl(T *N, StorageType Storage, StoreT &Store);\n  template <class T> static T *storeImpl(T *N, StorageType Storage);\n\nprivate:\n  void handleChangedOperand(void *Ref, Metadata *New);\n\n  /// Drop RAUW support, if any.\n  void dropReplaceableUses();\n\n  void resolveAfterOperandChange(Metadata *Old, Metadata *New);\n  void decrementUnresolvedOperandCount();\n  void countUnresolvedOperands();\n\n  /// Mutate this to be \"uniqued\".\n  ///\n  /// Mutate this so that \\a isUniqued().\n  /// \\pre \\a isTemporary().\n  /// \\pre already added to uniquing set.\n  void makeUniqued();\n\n  /// Mutate this to be \"distinct\".\n  ///\n  /// Mutate this so that \\a isDistinct().\n  /// \\pre \\a isTemporary().\n  void makeDistinct();\n\n  void deleteAsSubclass();\n  MDNode *uniquify();\n  void eraseFromStore();\n\n  template <class NodeTy> struct HasCachedHash;\n  template <class NodeTy>\n  static void dispatchRecalculateHash(NodeTy *N, std::true_type) {\n    N->recalculateHash();\n  }\n  template <class NodeTy>\n  static void dispatchRecalculateHash(NodeTy *, std::false_type) {}\n  template <class NodeTy>\n  static void dispatchResetHash(NodeTy *N, std::true_type) {\n    N->setHash(0);\n  }\n  template <class NodeTy>\n  static void dispatchResetHash(NodeTy *, std::false_type) {}\n\npublic:\n  using op_iterator = const MDOperand *;\n  using op_range = iterator_range<op_iterator>;\n\n  op_iterator op_begin() const {\n    return const_cast<MDNode *>(this)->mutable_begin();\n  }\n\n  op_iterator op_end() const {\n    return const_cast<MDNode *>(this)->mutable_end();\n  }\n\n  op_range operands() const { return op_range(op_begin(), op_end()); }\n\n  const MDOperand &getOperand(unsigned I) const {\n    assert(I < NumOperands && \"Out of range\");\n    return op_begin()[I];\n  }\n\n  /// Return number of MDNode operands.\n  unsigned getNumOperands() const { return NumOperands; }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Metadata *MD) {\n    switch (MD->getMetadataID()) {\n    default:\n      return false;\n#define HANDLE_MDNODE_LEAF(CLASS)                                              \\\n  case CLASS##Kind:                                                            \\\n    return true;\n#include \"llvm/IR/Metadata.def\"\n    }\n  }\n\n  /// Check whether MDNode is a vtable access.\n  bool isTBAAVtableAccess() const;\n\n  /// Methods for metadata merging.\n  static MDNode *concatenate(MDNode *A, MDNode *B);\n  static MDNode *intersect(MDNode *A, MDNode *B);\n  static MDNode *getMostGenericTBAA(MDNode *A, MDNode *B);\n  static MDNode *getMostGenericFPMath(MDNode *A, MDNode *B);\n  static MDNode *getMostGenericRange(MDNode *A, MDNode *B);\n  static MDNode *getMostGenericAliasScope(MDNode *A, MDNode *B);\n  static MDNode *getMostGenericAlignmentOrDereferenceable(MDNode *A, MDNode *B);\n};\n\n/// Tuple of metadata.\n///\n/// This is the simple \\a MDNode arbitrary tuple.  Nodes are uniqued by\n/// default based on their operands.\nclass MDTuple : public MDNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  MDTuple(LLVMContext &C, StorageType Storage, unsigned Hash,\n          ArrayRef<Metadata *> Vals)\n      : MDNode(C, MDTupleKind, Storage, Vals) {\n    setHash(Hash);\n  }\n\n  ~MDTuple() { dropAllReferences(); }\n\n  void setHash(unsigned Hash) { SubclassData32 = Hash; }\n  void recalculateHash();\n\n  static MDTuple *getImpl(LLVMContext &Context, ArrayRef<Metadata *> MDs,\n                          StorageType Storage, bool ShouldCreate = true);\n\n  TempMDTuple cloneImpl() const {\n    return getTemporary(getContext(), SmallVector<Metadata *, 4>(operands()));\n  }\n\npublic:\n  /// Get the hash, if any.\n  unsigned getHash() const { return SubclassData32; }\n\n  static MDTuple *get(LLVMContext &Context, ArrayRef<Metadata *> MDs) {\n    return getImpl(Context, MDs, Uniqued);\n  }\n\n  static MDTuple *getIfExists(LLVMContext &Context, ArrayRef<Metadata *> MDs) {\n    return getImpl(Context, MDs, Uniqued, /* ShouldCreate */ false);\n  }\n\n  /// Return a distinct node.\n  ///\n  /// Return a distinct node -- i.e., a node that is not uniqued.\n  static MDTuple *getDistinct(LLVMContext &Context, ArrayRef<Metadata *> MDs) {\n    return getImpl(Context, MDs, Distinct);\n  }\n\n  /// Return a temporary node.\n  ///\n  /// For use in constructing cyclic MDNode structures. A temporary MDNode is\n  /// not uniqued, may be RAUW'd, and must be manually deleted with\n  /// deleteTemporary.\n  static TempMDTuple getTemporary(LLVMContext &Context,\n                                  ArrayRef<Metadata *> MDs) {\n    return TempMDTuple(getImpl(Context, MDs, Temporary));\n  }\n\n  /// Return a (temporary) clone of this.\n  TempMDTuple clone() const { return cloneImpl(); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == MDTupleKind;\n  }\n};\n\nMDTuple *MDNode::get(LLVMContext &Context, ArrayRef<Metadata *> MDs) {\n  return MDTuple::get(Context, MDs);\n}\n\nMDTuple *MDNode::getIfExists(LLVMContext &Context, ArrayRef<Metadata *> MDs) {\n  return MDTuple::getIfExists(Context, MDs);\n}\n\nMDTuple *MDNode::getDistinct(LLVMContext &Context, ArrayRef<Metadata *> MDs) {\n  return MDTuple::getDistinct(Context, MDs);\n}\n\nTempMDTuple MDNode::getTemporary(LLVMContext &Context,\n                                 ArrayRef<Metadata *> MDs) {\n  return MDTuple::getTemporary(Context, MDs);\n}\n\nvoid TempMDNodeDeleter::operator()(MDNode *Node) const {\n  MDNode::deleteTemporary(Node);\n}\n\n/// This is a simple wrapper around an MDNode which provides a higher-level\n/// interface by hiding the details of how alias analysis information is encoded\n/// in its operands.\nclass AliasScopeNode {\n  const MDNode *Node = nullptr;\n\npublic:\n  AliasScopeNode() = default;\n  explicit AliasScopeNode(const MDNode *N) : Node(N) {}\n\n  /// Get the MDNode for this AliasScopeNode.\n  const MDNode *getNode() const { return Node; }\n\n  /// Get the MDNode for this AliasScopeNode's domain.\n  const MDNode *getDomain() const {\n    if (Node->getNumOperands() < 2)\n      return nullptr;\n    return dyn_cast_or_null<MDNode>(Node->getOperand(1));\n  }\n  StringRef getName() const {\n    if (Node->getNumOperands() > 2)\n      if (MDString *N = dyn_cast_or_null<MDString>(Node->getOperand(2)))\n        return N->getString();\n    return StringRef();\n  }\n};\n\n/// Typed iterator through MDNode operands.\n///\n/// An iterator that transforms an \\a MDNode::iterator into an iterator over a\n/// particular Metadata subclass.\ntemplate <class T>\nclass TypedMDOperandIterator\n    : public std::iterator<std::input_iterator_tag, T *, std::ptrdiff_t, void,\n                           T *> {\n  MDNode::op_iterator I = nullptr;\n\npublic:\n  TypedMDOperandIterator() = default;\n  explicit TypedMDOperandIterator(MDNode::op_iterator I) : I(I) {}\n\n  T *operator*() const { return cast_or_null<T>(*I); }\n\n  TypedMDOperandIterator &operator++() {\n    ++I;\n    return *this;\n  }\n\n  TypedMDOperandIterator operator++(int) {\n    TypedMDOperandIterator Temp(*this);\n    ++I;\n    return Temp;\n  }\n\n  bool operator==(const TypedMDOperandIterator &X) const { return I == X.I; }\n  bool operator!=(const TypedMDOperandIterator &X) const { return I != X.I; }\n};\n\n/// Typed, array-like tuple of metadata.\n///\n/// This is a wrapper for \\a MDTuple that makes it act like an array holding a\n/// particular type of metadata.\ntemplate <class T> class MDTupleTypedArrayWrapper {\n  const MDTuple *N = nullptr;\n\npublic:\n  MDTupleTypedArrayWrapper() = default;\n  MDTupleTypedArrayWrapper(const MDTuple *N) : N(N) {}\n\n  template <class U>\n  MDTupleTypedArrayWrapper(\n      const MDTupleTypedArrayWrapper<U> &Other,\n      std::enable_if_t<std::is_convertible<U *, T *>::value> * = nullptr)\n      : N(Other.get()) {}\n\n  template <class U>\n  explicit MDTupleTypedArrayWrapper(\n      const MDTupleTypedArrayWrapper<U> &Other,\n      std::enable_if_t<!std::is_convertible<U *, T *>::value> * = nullptr)\n      : N(Other.get()) {}\n\n  explicit operator bool() const { return get(); }\n  explicit operator MDTuple *() const { return get(); }\n\n  MDTuple *get() const { return const_cast<MDTuple *>(N); }\n  MDTuple *operator->() const { return get(); }\n  MDTuple &operator*() const { return *get(); }\n\n  // FIXME: Fix callers and remove condition on N.\n  unsigned size() const { return N ? N->getNumOperands() : 0u; }\n  bool empty() const { return N ? N->getNumOperands() == 0 : true; }\n  T *operator[](unsigned I) const { return cast_or_null<T>(N->getOperand(I)); }\n\n  // FIXME: Fix callers and remove condition on N.\n  using iterator = TypedMDOperandIterator<T>;\n\n  iterator begin() const { return N ? iterator(N->op_begin()) : iterator(); }\n  iterator end() const { return N ? iterator(N->op_end()) : iterator(); }\n};\n\n#define HANDLE_METADATA(CLASS)                                                 \\\n  using CLASS##Array = MDTupleTypedArrayWrapper<CLASS>;\n#include \"llvm/IR/Metadata.def\"\n\n/// Placeholder metadata for operands of distinct MDNodes.\n///\n/// This is a lightweight placeholder for an operand of a distinct node.  It's\n/// purpose is to help track forward references when creating a distinct node.\n/// This allows distinct nodes involved in a cycle to be constructed before\n/// their operands without requiring a heavyweight temporary node with\n/// full-blown RAUW support.\n///\n/// Each placeholder supports only a single MDNode user.  Clients should pass\n/// an ID, retrieved via \\a getID(), to indicate the \"real\" operand that this\n/// should be replaced with.\n///\n/// While it would be possible to implement move operators, they would be\n/// fairly expensive.  Leave them unimplemented to discourage their use\n/// (clients can use std::deque, std::list, BumpPtrAllocator, etc.).\nclass DistinctMDOperandPlaceholder : public Metadata {\n  friend class MetadataTracking;\n\n  Metadata **Use = nullptr;\n\npublic:\n  explicit DistinctMDOperandPlaceholder(unsigned ID)\n      : Metadata(DistinctMDOperandPlaceholderKind, Distinct) {\n    SubclassData32 = ID;\n  }\n\n  DistinctMDOperandPlaceholder() = delete;\n  DistinctMDOperandPlaceholder(DistinctMDOperandPlaceholder &&) = delete;\n  DistinctMDOperandPlaceholder(const DistinctMDOperandPlaceholder &) = delete;\n\n  ~DistinctMDOperandPlaceholder() {\n    if (Use)\n      *Use = nullptr;\n  }\n\n  unsigned getID() const { return SubclassData32; }\n\n  /// Replace the use of this with MD.\n  void replaceUseWith(Metadata *MD) {\n    if (!Use)\n      return;\n    *Use = MD;\n\n    if (*Use)\n      MetadataTracking::track(*Use);\n\n    Metadata *T = cast<Metadata>(this);\n    MetadataTracking::untrack(T);\n    assert(!Use && \"Use is still being tracked despite being untracked!\");\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// A tuple of MDNodes.\n///\n/// Despite its name, a NamedMDNode isn't itself an MDNode.\n///\n/// NamedMDNodes are named module-level entities that contain lists of MDNodes.\n///\n/// It is illegal for a NamedMDNode to appear as an operand of an MDNode.\nclass NamedMDNode : public ilist_node<NamedMDNode> {\n  friend class LLVMContextImpl;\n  friend class Module;\n\n  std::string Name;\n  Module *Parent = nullptr;\n  void *Operands; // SmallVector<TrackingMDRef, 4>\n\n  void setParent(Module *M) { Parent = M; }\n\n  explicit NamedMDNode(const Twine &N);\n\n  template<class T1, class T2>\n  class op_iterator_impl :\n      public std::iterator<std::bidirectional_iterator_tag, T2> {\n    friend class NamedMDNode;\n\n    const NamedMDNode *Node = nullptr;\n    unsigned Idx = 0;\n\n    op_iterator_impl(const NamedMDNode *N, unsigned i) : Node(N), Idx(i) {}\n\n  public:\n    op_iterator_impl() = default;\n\n    bool operator==(const op_iterator_impl &o) const { return Idx == o.Idx; }\n    bool operator!=(const op_iterator_impl &o) const { return Idx != o.Idx; }\n\n    op_iterator_impl &operator++() {\n      ++Idx;\n      return *this;\n    }\n\n    op_iterator_impl operator++(int) {\n      op_iterator_impl tmp(*this);\n      operator++();\n      return tmp;\n    }\n\n    op_iterator_impl &operator--() {\n      --Idx;\n      return *this;\n    }\n\n    op_iterator_impl operator--(int) {\n      op_iterator_impl tmp(*this);\n      operator--();\n      return tmp;\n    }\n\n    T1 operator*() const { return Node->getOperand(Idx); }\n  };\n\npublic:\n  NamedMDNode(const NamedMDNode &) = delete;\n  ~NamedMDNode();\n\n  /// Drop all references and remove the node from parent module.\n  void eraseFromParent();\n\n  /// Remove all uses and clear node vector.\n  void dropAllReferences() { clearOperands(); }\n  /// Drop all references to this node's operands.\n  void clearOperands();\n\n  /// Get the module that holds this named metadata collection.\n  inline Module *getParent() { return Parent; }\n  inline const Module *getParent() const { return Parent; }\n\n  MDNode *getOperand(unsigned i) const;\n  unsigned getNumOperands() const;\n  void addOperand(MDNode *M);\n  void setOperand(unsigned I, MDNode *New);\n  StringRef getName() const;\n  void print(raw_ostream &ROS, bool IsForDebug = false) const;\n  void print(raw_ostream &ROS, ModuleSlotTracker &MST,\n             bool IsForDebug = false) const;\n  void dump() const;\n\n  // ---------------------------------------------------------------------------\n  // Operand Iterator interface...\n  //\n  using op_iterator = op_iterator_impl<MDNode *, MDNode>;\n\n  op_iterator op_begin() { return op_iterator(this, 0); }\n  op_iterator op_end()   { return op_iterator(this, getNumOperands()); }\n\n  using const_op_iterator = op_iterator_impl<const MDNode *, MDNode>;\n\n  const_op_iterator op_begin() const { return const_op_iterator(this, 0); }\n  const_op_iterator op_end()   const { return const_op_iterator(this, getNumOperands()); }\n\n  inline iterator_range<op_iterator>  operands() {\n    return make_range(op_begin(), op_end());\n  }\n  inline iterator_range<const_op_iterator> operands() const {\n    return make_range(op_begin(), op_end());\n  }\n};\n\n// Create wrappers for C Binding types (see CBindingWrapping.h).\nDEFINE_ISA_CONVERSION_FUNCTIONS(NamedMDNode, LLVMNamedMDNodeRef)\n\n} // end namespace llvm\n\n#endif // LLVM_IR_METADATA_H\n"}, "41": {"id": 41, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Module.h", "content": "//===- llvm/Module.h - C++ class to represent a VM module -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// @file\n/// Module.h This file contains the declarations for the Module class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_MODULE_H\n#define LLVM_IR_MODULE_H\n\n#include \"llvm-c/Types.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/IR/Attributes.h\"\n#include \"llvm/IR/Comdat.h\"\n#include \"llvm/IR/DataLayout.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/GlobalAlias.h\"\n#include \"llvm/IR/GlobalIFunc.h\"\n#include \"llvm/IR/GlobalVariable.h\"\n#include \"llvm/IR/Metadata.h\"\n#include \"llvm/IR/ProfileSummary.h\"\n#include \"llvm/IR/SymbolTableListTraits.h\"\n#include \"llvm/Support/CBindingWrapping.h\"\n#include \"llvm/Support/CodeGen.h\"\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <memory>\n#include <string>\n#include <vector>\n\nnamespace llvm {\n\nclass Error;\nclass FunctionType;\nclass GVMaterializer;\nclass LLVMContext;\nclass MemoryBuffer;\nclass ModuleSummaryIndex;\nclass Pass;\nclass RandomNumberGenerator;\ntemplate <class PtrType> class SmallPtrSetImpl;\nclass StructType;\nclass VersionTuple;\n\n/// A Module instance is used to store all the information related to an\n/// LLVM module. Modules are the top level container of all other LLVM\n/// Intermediate Representation (IR) objects. Each module directly contains a\n/// list of globals variables, a list of functions, a list of libraries (or\n/// other modules) this module depends on, a symbol table, and various data\n/// about the target's characteristics.\n///\n/// A module maintains a GlobalValRefMap object that is used to hold all\n/// constant references to global variables in the module.  When a global\n/// variable is destroyed, it should have no entries in the GlobalValueRefMap.\n/// The main container class for the LLVM Intermediate Representation.\nclass Module {\n/// @name Types And Enumerations\n/// @{\npublic:\n  /// The type for the list of global variables.\n  using GlobalListType = SymbolTableList<GlobalVariable>;\n  /// The type for the list of functions.\n  using FunctionListType = SymbolTableList<Function>;\n  /// The type for the list of aliases.\n  using AliasListType = SymbolTableList<GlobalAlias>;\n  /// The type for the list of ifuncs.\n  using IFuncListType = SymbolTableList<GlobalIFunc>;\n  /// The type for the list of named metadata.\n  using NamedMDListType = ilist<NamedMDNode>;\n  /// The type of the comdat \"symbol\" table.\n  using ComdatSymTabType = StringMap<Comdat>;\n  /// The type for mapping names to named metadata.\n  using NamedMDSymTabType = StringMap<NamedMDNode *>;\n\n  /// The Global Variable iterator.\n  using global_iterator = GlobalListType::iterator;\n  /// The Global Variable constant iterator.\n  using const_global_iterator = GlobalListType::const_iterator;\n\n  /// The Function iterators.\n  using iterator = FunctionListType::iterator;\n  /// The Function constant iterator\n  using const_iterator = FunctionListType::const_iterator;\n\n  /// The Function reverse iterator.\n  using reverse_iterator = FunctionListType::reverse_iterator;\n  /// The Function constant reverse iterator.\n  using const_reverse_iterator = FunctionListType::const_reverse_iterator;\n\n  /// The Global Alias iterators.\n  using alias_iterator = AliasListType::iterator;\n  /// The Global Alias constant iterator\n  using const_alias_iterator = AliasListType::const_iterator;\n\n  /// The Global IFunc iterators.\n  using ifunc_iterator = IFuncListType::iterator;\n  /// The Global IFunc constant iterator\n  using const_ifunc_iterator = IFuncListType::const_iterator;\n\n  /// The named metadata iterators.\n  using named_metadata_iterator = NamedMDListType::iterator;\n  /// The named metadata constant iterators.\n  using const_named_metadata_iterator = NamedMDListType::const_iterator;\n\n  /// This enumeration defines the supported behaviors of module flags.\n  enum ModFlagBehavior {\n    /// Emits an error if two values disagree, otherwise the resulting value is\n    /// that of the operands.\n    Error = 1,\n\n    /// Emits a warning if two values disagree. The result value will be the\n    /// operand for the flag from the first module being linked.\n    Warning = 2,\n\n    /// Adds a requirement that another module flag be present and have a\n    /// specified value after linking is performed. The value must be a metadata\n    /// pair, where the first element of the pair is the ID of the module flag\n    /// to be restricted, and the second element of the pair is the value the\n    /// module flag should be restricted to. This behavior can be used to\n    /// restrict the allowable results (via triggering of an error) of linking\n    /// IDs with the **Override** behavior.\n    Require = 3,\n\n    /// Uses the specified value, regardless of the behavior or value of the\n    /// other module. If both modules specify **Override**, but the values\n    /// differ, an error will be emitted.\n    Override = 4,\n\n    /// Appends the two values, which are required to be metadata nodes.\n    Append = 5,\n\n    /// Appends the two values, which are required to be metadata\n    /// nodes. However, duplicate entries in the second list are dropped\n    /// during the append operation.\n    AppendUnique = 6,\n\n    /// Takes the max of the two values, which are required to be integers.\n    Max = 7,\n\n    // Markers:\n    ModFlagBehaviorFirstVal = Error,\n    ModFlagBehaviorLastVal = Max\n  };\n\n  /// Checks if Metadata represents a valid ModFlagBehavior, and stores the\n  /// converted result in MFB.\n  static bool isValidModFlagBehavior(Metadata *MD, ModFlagBehavior &MFB);\n\n  /// Check if the given module flag metadata represents a valid module flag,\n  /// and store the flag behavior, the key string and the value metadata.\n  static bool isValidModuleFlag(const MDNode &ModFlag, ModFlagBehavior &MFB,\n                                MDString *&Key, Metadata *&Val);\n\n  struct ModuleFlagEntry {\n    ModFlagBehavior Behavior;\n    MDString *Key;\n    Metadata *Val;\n\n    ModuleFlagEntry(ModFlagBehavior B, MDString *K, Metadata *V)\n        : Behavior(B), Key(K), Val(V) {}\n  };\n\n/// @}\n/// @name Member Variables\n/// @{\nprivate:\n  LLVMContext &Context;           ///< The LLVMContext from which types and\n                                  ///< constants are allocated.\n  GlobalListType GlobalList;      ///< The Global Variables in the module\n  FunctionListType FunctionList;  ///< The Functions in the module\n  AliasListType AliasList;        ///< The Aliases in the module\n  IFuncListType IFuncList;        ///< The IFuncs in the module\n  NamedMDListType NamedMDList;    ///< The named metadata in the module\n  std::string GlobalScopeAsm;     ///< Inline Asm at global scope.\n  std::unique_ptr<ValueSymbolTable> ValSymTab; ///< Symbol table for values\n  ComdatSymTabType ComdatSymTab;  ///< Symbol table for COMDATs\n  std::unique_ptr<MemoryBuffer>\n  OwnedMemoryBuffer;              ///< Memory buffer directly owned by this\n                                  ///< module, for legacy clients only.\n  std::unique_ptr<GVMaterializer>\n  Materializer;                   ///< Used to materialize GlobalValues\n  std::string ModuleID;           ///< Human readable identifier for the module\n  std::string SourceFileName;     ///< Original source file name for module,\n                                  ///< recorded in bitcode.\n  std::string TargetTriple;       ///< Platform target triple Module compiled on\n                                  ///< Format: (arch)(sub)-(vendor)-(sys0-(abi)\n  NamedMDSymTabType NamedMDSymTab;  ///< NamedMDNode names.\n  DataLayout DL;                  ///< DataLayout associated with the module\n  StringMap<unsigned>\n      CurrentIntrinsicIds; ///< Keep track of the current unique id count for\n                           ///< the specified intrinsic basename.\n  DenseMap<std::pair<Intrinsic::ID, const FunctionType *>, unsigned>\n      UniquedIntrinsicNames; ///< Keep track of uniqued names of intrinsics\n                             ///< based on unnamed types. The combination of\n                             ///< ID and FunctionType maps to the extension that\n                             ///< is used to make the intrinsic name unique.\n\n  friend class Constant;\n\n/// @}\n/// @name Constructors\n/// @{\npublic:\n  /// The Module constructor. Note that there is no default constructor. You\n  /// must provide a name for the module upon construction.\n  explicit Module(StringRef ModuleID, LLVMContext& C);\n  /// The module destructor. This will dropAllReferences.\n  ~Module();\n\n/// @}\n/// @name Module Level Accessors\n/// @{\n\n  /// Get the module identifier which is, essentially, the name of the module.\n  /// @returns the module identifier as a string\n  const std::string &getModuleIdentifier() const { return ModuleID; }\n\n  /// Returns the number of non-debug IR instructions in the module.\n  /// This is equivalent to the sum of the IR instruction counts of each\n  /// function contained in the module.\n  unsigned getInstructionCount();\n\n  /// Get the module's original source file name. When compiling from\n  /// bitcode, this is taken from a bitcode record where it was recorded.\n  /// For other compiles it is the same as the ModuleID, which would\n  /// contain the source file name.\n  const std::string &getSourceFileName() const { return SourceFileName; }\n\n  /// Get a short \"name\" for the module.\n  ///\n  /// This is useful for debugging or logging. It is essentially a convenience\n  /// wrapper around getModuleIdentifier().\n  StringRef getName() const { return ModuleID; }\n\n  /// Get the data layout string for the module's target platform. This is\n  /// equivalent to getDataLayout()->getStringRepresentation().\n  const std::string &getDataLayoutStr() const {\n    return DL.getStringRepresentation();\n  }\n\n  /// Get the data layout for the module's target platform.\n  const DataLayout &getDataLayout() const;\n\n  /// Get the target triple which is a string describing the target host.\n  /// @returns a string containing the target triple.\n  const std::string &getTargetTriple() const { return TargetTriple; }\n\n  /// Get the global data context.\n  /// @returns LLVMContext - a container for LLVM's global information\n  LLVMContext &getContext() const { return Context; }\n\n  /// Get any module-scope inline assembly blocks.\n  /// @returns a string containing the module-scope inline assembly blocks.\n  const std::string &getModuleInlineAsm() const { return GlobalScopeAsm; }\n\n  /// Get a RandomNumberGenerator salted for use with this module. The\n  /// RNG can be seeded via -rng-seed=<uint64> and is salted with the\n  /// ModuleID and the provided pass salt. The returned RNG should not\n  /// be shared across threads or passes.\n  ///\n  /// A unique RNG per pass ensures a reproducible random stream even\n  /// when other randomness consuming passes are added or removed. In\n  /// addition, the random stream will be reproducible across LLVM\n  /// versions when the pass does not change.\n  std::unique_ptr<RandomNumberGenerator> createRNG(const StringRef Name) const;\n\n  /// Return true if size-info optimization remark is enabled, false\n  /// otherwise.\n  bool shouldEmitInstrCountChangedRemark() {\n    return getContext().getDiagHandlerPtr()->isAnalysisRemarkEnabled(\n        \"size-info\");\n  }\n\n  /// @}\n  /// @name Module Level Mutators\n  /// @{\n\n  /// Set the module identifier.\n  void setModuleIdentifier(StringRef ID) { ModuleID = std::string(ID); }\n\n  /// Set the module's original source file name.\n  void setSourceFileName(StringRef Name) { SourceFileName = std::string(Name); }\n\n  /// Set the data layout\n  void setDataLayout(StringRef Desc);\n  void setDataLayout(const DataLayout &Other);\n\n  /// Set the target triple.\n  void setTargetTriple(StringRef T) { TargetTriple = std::string(T); }\n\n  /// Set the module-scope inline assembly blocks.\n  /// A trailing newline is added if the input doesn't have one.\n  void setModuleInlineAsm(StringRef Asm) {\n    GlobalScopeAsm = std::string(Asm);\n    if (!GlobalScopeAsm.empty() && GlobalScopeAsm.back() != '\\n')\n      GlobalScopeAsm += '\\n';\n  }\n\n  /// Append to the module-scope inline assembly blocks.\n  /// A trailing newline is added if the input doesn't have one.\n  void appendModuleInlineAsm(StringRef Asm) {\n    GlobalScopeAsm += Asm;\n    if (!GlobalScopeAsm.empty() && GlobalScopeAsm.back() != '\\n')\n      GlobalScopeAsm += '\\n';\n  }\n\n/// @}\n/// @name Generic Value Accessors\n/// @{\n\n  /// Return the global value in the module with the specified name, of\n  /// arbitrary type. This method returns null if a global with the specified\n  /// name is not found.\n  GlobalValue *getNamedValue(StringRef Name) const;\n\n  /// Return a unique non-zero ID for the specified metadata kind. This ID is\n  /// uniqued across modules in the current LLVMContext.\n  unsigned getMDKindID(StringRef Name) const;\n\n  /// Populate client supplied SmallVector with the name for custom metadata IDs\n  /// registered in this LLVMContext.\n  void getMDKindNames(SmallVectorImpl<StringRef> &Result) const;\n\n  /// Populate client supplied SmallVector with the bundle tags registered in\n  /// this LLVMContext.  The bundle tags are ordered by increasing bundle IDs.\n  /// \\see LLVMContext::getOperandBundleTagID\n  void getOperandBundleTags(SmallVectorImpl<StringRef> &Result) const;\n\n  std::vector<StructType *> getIdentifiedStructTypes() const;\n\n  /// Return a unique name for an intrinsic whose mangling is based on an\n  /// unnamed type. The Proto represents the function prototype.\n  std::string getUniqueIntrinsicName(StringRef BaseName, Intrinsic::ID Id,\n                                     const FunctionType *Proto);\n\n/// @}\n/// @name Function Accessors\n/// @{\n\n  /// Look up the specified function in the module symbol table. Four\n  /// possibilities:\n  ///   1. If it does not exist, add a prototype for the function and return it.\n  ///   2. Otherwise, if the existing function has the correct prototype, return\n  ///      the existing function.\n  ///   3. Finally, the function exists but has the wrong prototype: return the\n  ///      function with a constantexpr cast to the right prototype.\n  ///\n  /// In all cases, the returned value is a FunctionCallee wrapper around the\n  /// 'FunctionType *T' passed in, as well as a 'Value*' either of the Function or\n  /// the bitcast to the function.\n  FunctionCallee getOrInsertFunction(StringRef Name, FunctionType *T,\n                                     AttributeList AttributeList);\n\n  FunctionCallee getOrInsertFunction(StringRef Name, FunctionType *T);\n\n  /// Look up the specified function in the module symbol table. If it does not\n  /// exist, add a prototype for the function and return it. This function\n  /// guarantees to return a constant of pointer to the specified function type\n  /// or a ConstantExpr BitCast of that type if the named function has a\n  /// different type. This version of the method takes a list of\n  /// function arguments, which makes it easier for clients to use.\n  template <typename... ArgsTy>\n  FunctionCallee getOrInsertFunction(StringRef Name,\n                                     AttributeList AttributeList, Type *RetTy,\n                                     ArgsTy... Args) {\n    SmallVector<Type*, sizeof...(ArgsTy)> ArgTys{Args...};\n    return getOrInsertFunction(Name,\n                               FunctionType::get(RetTy, ArgTys, false),\n                               AttributeList);\n  }\n\n  /// Same as above, but without the attributes.\n  template <typename... ArgsTy>\n  FunctionCallee getOrInsertFunction(StringRef Name, Type *RetTy,\n                                     ArgsTy... Args) {\n    return getOrInsertFunction(Name, AttributeList{}, RetTy, Args...);\n  }\n\n  // Avoid an incorrect ordering that'd otherwise compile incorrectly.\n  template <typename... ArgsTy>\n  FunctionCallee\n  getOrInsertFunction(StringRef Name, AttributeList AttributeList,\n                      FunctionType *Invalid, ArgsTy... Args) = delete;\n\n  /// Look up the specified function in the module symbol table. If it does not\n  /// exist, return null.\n  Function *getFunction(StringRef Name) const;\n\n/// @}\n/// @name Global Variable Accessors\n/// @{\n\n  /// Look up the specified global variable in the module symbol table. If it\n  /// does not exist, return null. If AllowInternal is set to true, this\n  /// function will return types that have InternalLinkage. By default, these\n  /// types are not returned.\n  GlobalVariable *getGlobalVariable(StringRef Name) const {\n    return getGlobalVariable(Name, false);\n  }\n\n  GlobalVariable *getGlobalVariable(StringRef Name, bool AllowInternal) const;\n\n  GlobalVariable *getGlobalVariable(StringRef Name,\n                                    bool AllowInternal = false) {\n    return static_cast<const Module *>(this)->getGlobalVariable(Name,\n                                                                AllowInternal);\n  }\n\n  /// Return the global variable in the module with the specified name, of\n  /// arbitrary type. This method returns null if a global with the specified\n  /// name is not found.\n  const GlobalVariable *getNamedGlobal(StringRef Name) const {\n    return getGlobalVariable(Name, true);\n  }\n  GlobalVariable *getNamedGlobal(StringRef Name) {\n    return const_cast<GlobalVariable *>(\n                       static_cast<const Module *>(this)->getNamedGlobal(Name));\n  }\n\n  /// Look up the specified global in the module symbol table.\n  /// If it does not exist, invoke a callback to create a declaration of the\n  /// global and return it. The global is constantexpr casted to the expected\n  /// type if necessary.\n  Constant *\n  getOrInsertGlobal(StringRef Name, Type *Ty,\n                    function_ref<GlobalVariable *()> CreateGlobalCallback);\n\n  /// Look up the specified global in the module symbol table. If required, this\n  /// overload constructs the global variable using its constructor's defaults.\n  Constant *getOrInsertGlobal(StringRef Name, Type *Ty);\n\n/// @}\n/// @name Global Alias Accessors\n/// @{\n\n  /// Return the global alias in the module with the specified name, of\n  /// arbitrary type. This method returns null if a global with the specified\n  /// name is not found.\n  GlobalAlias *getNamedAlias(StringRef Name) const;\n\n/// @}\n/// @name Global IFunc Accessors\n/// @{\n\n  /// Return the global ifunc in the module with the specified name, of\n  /// arbitrary type. This method returns null if a global with the specified\n  /// name is not found.\n  GlobalIFunc *getNamedIFunc(StringRef Name) const;\n\n/// @}\n/// @name Named Metadata Accessors\n/// @{\n\n  /// Return the first NamedMDNode in the module with the specified name. This\n  /// method returns null if a NamedMDNode with the specified name is not found.\n  NamedMDNode *getNamedMetadata(const Twine &Name) const;\n\n  /// Return the named MDNode in the module with the specified name. This method\n  /// returns a new NamedMDNode if a NamedMDNode with the specified name is not\n  /// found.\n  NamedMDNode *getOrInsertNamedMetadata(StringRef Name);\n\n  /// Remove the given NamedMDNode from this module and delete it.\n  void eraseNamedMetadata(NamedMDNode *NMD);\n\n/// @}\n/// @name Comdat Accessors\n/// @{\n\n  /// Return the Comdat in the module with the specified name. It is created\n  /// if it didn't already exist.\n  Comdat *getOrInsertComdat(StringRef Name);\n\n/// @}\n/// @name Module Flags Accessors\n/// @{\n\n  /// Returns the module flags in the provided vector.\n  void getModuleFlagsMetadata(SmallVectorImpl<ModuleFlagEntry> &Flags) const;\n\n  /// Return the corresponding value if Key appears in module flags, otherwise\n  /// return null.\n  Metadata *getModuleFlag(StringRef Key) const;\n\n  /// Returns the NamedMDNode in the module that represents module-level flags.\n  /// This method returns null if there are no module-level flags.\n  NamedMDNode *getModuleFlagsMetadata() const;\n\n  /// Returns the NamedMDNode in the module that represents module-level flags.\n  /// If module-level flags aren't found, it creates the named metadata that\n  /// contains them.\n  NamedMDNode *getOrInsertModuleFlagsMetadata();\n\n  /// Add a module-level flag to the module-level flags metadata. It will create\n  /// the module-level flags named metadata if it doesn't already exist.\n  void addModuleFlag(ModFlagBehavior Behavior, StringRef Key, Metadata *Val);\n  void addModuleFlag(ModFlagBehavior Behavior, StringRef Key, Constant *Val);\n  void addModuleFlag(ModFlagBehavior Behavior, StringRef Key, uint32_t Val);\n  void addModuleFlag(MDNode *Node);\n  /// Like addModuleFlag but replaces the old module flag if it already exists.\n  void setModuleFlag(ModFlagBehavior Behavior, StringRef Key, Metadata *Val);\n\n  /// @}\n  /// @name Materialization\n  /// @{\n\n  /// Sets the GVMaterializer to GVM. This module must not yet have a\n  /// Materializer. To reset the materializer for a module that already has one,\n  /// call materializeAll first. Destroying this module will destroy\n  /// its materializer without materializing any more GlobalValues. Without\n  /// destroying the Module, there is no way to detach or destroy a materializer\n  /// without materializing all the GVs it controls, to avoid leaving orphan\n  /// unmaterialized GVs.\n  void setMaterializer(GVMaterializer *GVM);\n  /// Retrieves the GVMaterializer, if any, for this Module.\n  GVMaterializer *getMaterializer() const { return Materializer.get(); }\n  bool isMaterialized() const { return !getMaterializer(); }\n\n  /// Make sure the GlobalValue is fully read.\n  llvm::Error materialize(GlobalValue *GV);\n\n  /// Make sure all GlobalValues in this Module are fully read and clear the\n  /// Materializer.\n  llvm::Error materializeAll();\n\n  llvm::Error materializeMetadata();\n\n/// @}\n/// @name Direct access to the globals list, functions list, and symbol table\n/// @{\n\n  /// Get the Module's list of global variables (constant).\n  const GlobalListType   &getGlobalList() const       { return GlobalList; }\n  /// Get the Module's list of global variables.\n  GlobalListType         &getGlobalList()             { return GlobalList; }\n\n  static GlobalListType Module::*getSublistAccess(GlobalVariable*) {\n    return &Module::GlobalList;\n  }\n\n  /// Get the Module's list of functions (constant).\n  const FunctionListType &getFunctionList() const     { return FunctionList; }\n  /// Get the Module's list of functions.\n  FunctionListType       &getFunctionList()           { return FunctionList; }\n  static FunctionListType Module::*getSublistAccess(Function*) {\n    return &Module::FunctionList;\n  }\n\n  /// Get the Module's list of aliases (constant).\n  const AliasListType    &getAliasList() const        { return AliasList; }\n  /// Get the Module's list of aliases.\n  AliasListType          &getAliasList()              { return AliasList; }\n\n  static AliasListType Module::*getSublistAccess(GlobalAlias*) {\n    return &Module::AliasList;\n  }\n\n  /// Get the Module's list of ifuncs (constant).\n  const IFuncListType    &getIFuncList() const        { return IFuncList; }\n  /// Get the Module's list of ifuncs.\n  IFuncListType          &getIFuncList()              { return IFuncList; }\n\n  static IFuncListType Module::*getSublistAccess(GlobalIFunc*) {\n    return &Module::IFuncList;\n  }\n\n  /// Get the Module's list of named metadata (constant).\n  const NamedMDListType  &getNamedMDList() const      { return NamedMDList; }\n  /// Get the Module's list of named metadata.\n  NamedMDListType        &getNamedMDList()            { return NamedMDList; }\n\n  static NamedMDListType Module::*getSublistAccess(NamedMDNode*) {\n    return &Module::NamedMDList;\n  }\n\n  /// Get the symbol table of global variable and function identifiers\n  const ValueSymbolTable &getValueSymbolTable() const { return *ValSymTab; }\n  /// Get the Module's symbol table of global variable and function identifiers.\n  ValueSymbolTable       &getValueSymbolTable()       { return *ValSymTab; }\n\n  /// Get the Module's symbol table for COMDATs (constant).\n  const ComdatSymTabType &getComdatSymbolTable() const { return ComdatSymTab; }\n  /// Get the Module's symbol table for COMDATs.\n  ComdatSymTabType &getComdatSymbolTable() { return ComdatSymTab; }\n\n/// @}\n/// @name Global Variable Iteration\n/// @{\n\n  global_iterator       global_begin()       { return GlobalList.begin(); }\n  const_global_iterator global_begin() const { return GlobalList.begin(); }\n  global_iterator       global_end  ()       { return GlobalList.end(); }\n  const_global_iterator global_end  () const { return GlobalList.end(); }\n  size_t                global_size () const { return GlobalList.size(); }\n  bool                  global_empty() const { return GlobalList.empty(); }\n\n  iterator_range<global_iterator> globals() {\n    return make_range(global_begin(), global_end());\n  }\n  iterator_range<const_global_iterator> globals() const {\n    return make_range(global_begin(), global_end());\n  }\n\n/// @}\n/// @name Function Iteration\n/// @{\n\n  iterator                begin()       { return FunctionList.begin(); }\n  const_iterator          begin() const { return FunctionList.begin(); }\n  iterator                end  ()       { return FunctionList.end();   }\n  const_iterator          end  () const { return FunctionList.end();   }\n  reverse_iterator        rbegin()      { return FunctionList.rbegin(); }\n  const_reverse_iterator  rbegin() const{ return FunctionList.rbegin(); }\n  reverse_iterator        rend()        { return FunctionList.rend(); }\n  const_reverse_iterator  rend() const  { return FunctionList.rend(); }\n  size_t                  size() const  { return FunctionList.size(); }\n  bool                    empty() const { return FunctionList.empty(); }\n\n  iterator_range<iterator> functions() {\n    return make_range(begin(), end());\n  }\n  iterator_range<const_iterator> functions() const {\n    return make_range(begin(), end());\n  }\n\n/// @}\n/// @name Alias Iteration\n/// @{\n\n  alias_iterator       alias_begin()            { return AliasList.begin(); }\n  const_alias_iterator alias_begin() const      { return AliasList.begin(); }\n  alias_iterator       alias_end  ()            { return AliasList.end();   }\n  const_alias_iterator alias_end  () const      { return AliasList.end();   }\n  size_t               alias_size () const      { return AliasList.size();  }\n  bool                 alias_empty() const      { return AliasList.empty(); }\n\n  iterator_range<alias_iterator> aliases() {\n    return make_range(alias_begin(), alias_end());\n  }\n  iterator_range<const_alias_iterator> aliases() const {\n    return make_range(alias_begin(), alias_end());\n  }\n\n/// @}\n/// @name IFunc Iteration\n/// @{\n\n  ifunc_iterator       ifunc_begin()            { return IFuncList.begin(); }\n  const_ifunc_iterator ifunc_begin() const      { return IFuncList.begin(); }\n  ifunc_iterator       ifunc_end  ()            { return IFuncList.end();   }\n  const_ifunc_iterator ifunc_end  () const      { return IFuncList.end();   }\n  size_t               ifunc_size () const      { return IFuncList.size();  }\n  bool                 ifunc_empty() const      { return IFuncList.empty(); }\n\n  iterator_range<ifunc_iterator> ifuncs() {\n    return make_range(ifunc_begin(), ifunc_end());\n  }\n  iterator_range<const_ifunc_iterator> ifuncs() const {\n    return make_range(ifunc_begin(), ifunc_end());\n  }\n\n  /// @}\n  /// @name Convenience iterators\n  /// @{\n\n  using global_object_iterator =\n      concat_iterator<GlobalObject, iterator, global_iterator>;\n  using const_global_object_iterator =\n      concat_iterator<const GlobalObject, const_iterator,\n                      const_global_iterator>;\n\n  iterator_range<global_object_iterator> global_objects();\n  iterator_range<const_global_object_iterator> global_objects() const;\n\n  using global_value_iterator =\n      concat_iterator<GlobalValue, iterator, global_iterator, alias_iterator,\n                      ifunc_iterator>;\n  using const_global_value_iterator =\n      concat_iterator<const GlobalValue, const_iterator, const_global_iterator,\n                      const_alias_iterator, const_ifunc_iterator>;\n\n  iterator_range<global_value_iterator> global_values();\n  iterator_range<const_global_value_iterator> global_values() const;\n\n  /// @}\n  /// @name Named Metadata Iteration\n  /// @{\n\n  named_metadata_iterator named_metadata_begin() { return NamedMDList.begin(); }\n  const_named_metadata_iterator named_metadata_begin() const {\n    return NamedMDList.begin();\n  }\n\n  named_metadata_iterator named_metadata_end() { return NamedMDList.end(); }\n  const_named_metadata_iterator named_metadata_end() const {\n    return NamedMDList.end();\n  }\n\n  size_t named_metadata_size() const { return NamedMDList.size();  }\n  bool named_metadata_empty() const { return NamedMDList.empty(); }\n\n  iterator_range<named_metadata_iterator> named_metadata() {\n    return make_range(named_metadata_begin(), named_metadata_end());\n  }\n  iterator_range<const_named_metadata_iterator> named_metadata() const {\n    return make_range(named_metadata_begin(), named_metadata_end());\n  }\n\n  /// An iterator for DICompileUnits that skips those marked NoDebug.\n  class debug_compile_units_iterator\n      : public std::iterator<std::input_iterator_tag, DICompileUnit *> {\n    NamedMDNode *CUs;\n    unsigned Idx;\n\n    void SkipNoDebugCUs();\n\n  public:\n    explicit debug_compile_units_iterator(NamedMDNode *CUs, unsigned Idx)\n        : CUs(CUs), Idx(Idx) {\n      SkipNoDebugCUs();\n    }\n\n    debug_compile_units_iterator &operator++() {\n      ++Idx;\n      SkipNoDebugCUs();\n      return *this;\n    }\n\n    debug_compile_units_iterator operator++(int) {\n      debug_compile_units_iterator T(*this);\n      ++Idx;\n      return T;\n    }\n\n    bool operator==(const debug_compile_units_iterator &I) const {\n      return Idx == I.Idx;\n    }\n\n    bool operator!=(const debug_compile_units_iterator &I) const {\n      return Idx != I.Idx;\n    }\n\n    DICompileUnit *operator*() const;\n    DICompileUnit *operator->() const;\n  };\n\n  debug_compile_units_iterator debug_compile_units_begin() const {\n    auto *CUs = getNamedMetadata(\"llvm.dbg.cu\");\n    return debug_compile_units_iterator(CUs, 0);\n  }\n\n  debug_compile_units_iterator debug_compile_units_end() const {\n    auto *CUs = getNamedMetadata(\"llvm.dbg.cu\");\n    return debug_compile_units_iterator(CUs, CUs ? CUs->getNumOperands() : 0);\n  }\n\n  /// Return an iterator for all DICompileUnits listed in this Module's\n  /// llvm.dbg.cu named metadata node and aren't explicitly marked as\n  /// NoDebug.\n  iterator_range<debug_compile_units_iterator> debug_compile_units() const {\n    auto *CUs = getNamedMetadata(\"llvm.dbg.cu\");\n    return make_range(\n        debug_compile_units_iterator(CUs, 0),\n        debug_compile_units_iterator(CUs, CUs ? CUs->getNumOperands() : 0));\n  }\n/// @}\n\n  /// Destroy ConstantArrays in LLVMContext if they are not used.\n  /// ConstantArrays constructed during linking can cause quadratic memory\n  /// explosion. Releasing all unused constants can cause a 20% LTO compile-time\n  /// slowdown for a large application.\n  ///\n  /// NOTE: Constants are currently owned by LLVMContext. This can then only\n  /// be called where all uses of the LLVMContext are understood.\n  void dropTriviallyDeadConstantArrays();\n\n/// @name Utility functions for printing and dumping Module objects\n/// @{\n\n  /// Print the module to an output stream with an optional\n  /// AssemblyAnnotationWriter.  If \\c ShouldPreserveUseListOrder, then include\n  /// uselistorder directives so that use-lists can be recreated when reading\n  /// the assembly.\n  void print(raw_ostream &OS, AssemblyAnnotationWriter *AAW,\n             bool ShouldPreserveUseListOrder = false,\n             bool IsForDebug = false) const;\n\n  /// Dump the module to stderr (for debugging).\n  void dump() const;\n\n  /// This function causes all the subinstructions to \"let go\" of all references\n  /// that they are maintaining.  This allows one to 'delete' a whole class at\n  /// a time, even though there may be circular references... first all\n  /// references are dropped, and all use counts go to zero.  Then everything\n  /// is delete'd for real.  Note that no operations are valid on an object\n  /// that has \"dropped all references\", except operator delete.\n  void dropAllReferences();\n\n/// @}\n/// @name Utility functions for querying Debug information.\n/// @{\n\n  /// Returns the Number of Register ParametersDwarf Version by checking\n  /// module flags.\n  unsigned getNumberRegisterParameters() const;\n\n  /// Returns the Dwarf Version by checking module flags.\n  unsigned getDwarfVersion() const;\n\n  /// Returns the DWARF format by checking module flags.\n  bool isDwarf64() const;\n\n  /// Returns the CodeView Version by checking module flags.\n  /// Returns zero if not present in module.\n  unsigned getCodeViewFlag() const;\n\n/// @}\n/// @name Utility functions for querying and setting PIC level\n/// @{\n\n  /// Returns the PIC level (small or large model)\n  PICLevel::Level getPICLevel() const;\n\n  /// Set the PIC level (small or large model)\n  void setPICLevel(PICLevel::Level PL);\n/// @}\n\n/// @}\n/// @name Utility functions for querying and setting PIE level\n/// @{\n\n  /// Returns the PIE level (small or large model)\n  PIELevel::Level getPIELevel() const;\n\n  /// Set the PIE level (small or large model)\n  void setPIELevel(PIELevel::Level PL);\n/// @}\n\n  /// @}\n  /// @name Utility function for querying and setting code model\n  /// @{\n\n  /// Returns the code model (tiny, small, kernel, medium or large model)\n  Optional<CodeModel::Model> getCodeModel() const;\n\n  /// Set the code model (tiny, small, kernel, medium or large)\n  void setCodeModel(CodeModel::Model CL);\n  /// @}\n\n  /// @name Utility functions for querying and setting PGO summary\n  /// @{\n\n  /// Attach profile summary metadata to this module.\n  void setProfileSummary(Metadata *M, ProfileSummary::Kind Kind);\n\n  /// Returns profile summary metadata. When IsCS is true, use the context\n  /// sensitive profile summary.\n  Metadata *getProfileSummary(bool IsCS) const;\n  /// @}\n\n  /// Returns whether semantic interposition is to be respected.\n  bool getSemanticInterposition() const;\n\n  /// Set whether semantic interposition is to be respected.\n  void setSemanticInterposition(bool);\n\n  /// Returns true if PLT should be avoided for RTLib calls.\n  bool getRtLibUseGOT() const;\n\n  /// Set that PLT should be avoid for RTLib calls.\n  void setRtLibUseGOT();\n\n  /// @name Utility functions for querying and setting the build SDK version\n  /// @{\n\n  /// Attach a build SDK version metadata to this module.\n  void setSDKVersion(const VersionTuple &V);\n\n  /// Get the build SDK version metadata.\n  ///\n  /// An empty version is returned if no such metadata is attached.\n  VersionTuple getSDKVersion() const;\n  /// @}\n\n  /// Take ownership of the given memory buffer.\n  void setOwnedMemoryBuffer(std::unique_ptr<MemoryBuffer> MB);\n\n  /// Set the partial sample profile ratio in the profile summary module flag,\n  /// if applicable.\n  void setPartialSampleProfileRatio(const ModuleSummaryIndex &Index);\n};\n\n/// Given \"llvm.used\" or \"llvm.compiler.used\" as a global name, collect the\n/// initializer elements of that global in a SmallVector and return the global\n/// itself.\nGlobalVariable *collectUsedGlobalVariables(const Module &M,\n                                           SmallVectorImpl<GlobalValue *> &Vec,\n                                           bool CompilerUsed);\n\n/// An raw_ostream inserter for modules.\ninline raw_ostream &operator<<(raw_ostream &O, const Module &M) {\n  M.print(O, nullptr);\n  return O;\n}\n\n// Create wrappers for C Binding types (see CBindingWrapping.h).\nDEFINE_SIMPLE_CONVERSION_FUNCTIONS(Module, LLVMModuleRef)\n\n/* LLVMModuleProviderRef exists for historical reasons, but now just holds a\n * Module.\n */\ninline Module *unwrap(LLVMModuleProviderRef MP) {\n  return reinterpret_cast<Module*>(MP);\n}\n\n} // end namespace llvm\n\n#endif // LLVM_IR_MODULE_H\n"}, "42": {"id": 42, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/TrackingMDRef.h", "content": "//===- llvm/IR/TrackingMDRef.h - Tracking Metadata references ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// References to metadata that track RAUW.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_TRACKINGMDREF_H\n#define LLVM_IR_TRACKINGMDREF_H\n\n#include \"llvm/IR/Metadata.h\"\n#include <algorithm>\n#include <cassert>\n\nnamespace llvm {\n\n/// Tracking metadata reference.\n///\n/// This class behaves like \\a TrackingVH, but for metadata.\nclass TrackingMDRef {\n  Metadata *MD = nullptr;\n\npublic:\n  TrackingMDRef() = default;\n  explicit TrackingMDRef(Metadata *MD) : MD(MD) { track(); }\n\n  TrackingMDRef(TrackingMDRef &&X) : MD(X.MD) { retrack(X); }\n  TrackingMDRef(const TrackingMDRef &X) : MD(X.MD) { track(); }\n\n  TrackingMDRef &operator=(TrackingMDRef &&X) {\n    if (&X == this)\n      return *this;\n\n    untrack();\n    MD = X.MD;\n    retrack(X);\n    return *this;\n  }\n\n  TrackingMDRef &operator=(const TrackingMDRef &X) {\n    if (&X == this)\n      return *this;\n\n    untrack();\n    MD = X.MD;\n    track();\n    return *this;\n  }\n\n  ~TrackingMDRef() { untrack(); }\n\n  Metadata *get() const { return MD; }\n  operator Metadata *() const { return get(); }\n  Metadata *operator->() const { return get(); }\n  Metadata &operator*() const { return *get(); }\n\n  void reset() {\n    untrack();\n    MD = nullptr;\n  }\n  void reset(Metadata *MD) {\n    untrack();\n    this->MD = MD;\n    track();\n  }\n\n  /// Check whether this has a trivial destructor.\n  ///\n  /// If \\c MD isn't replaceable, the destructor will be a no-op.\n  bool hasTrivialDestructor() const {\n    return !MD || !MetadataTracking::isReplaceable(*MD);\n  }\n\n  bool operator==(const TrackingMDRef &X) const { return MD == X.MD; }\n  bool operator!=(const TrackingMDRef &X) const { return MD != X.MD; }\n\nprivate:\n  void track() {\n    if (MD)\n      MetadataTracking::track(MD);\n  }\n\n  void untrack() {\n    if (MD)\n      MetadataTracking::untrack(MD);\n  }\n\n  void retrack(TrackingMDRef &X) {\n    assert(MD == X.MD && \"Expected values to match\");\n    if (X.MD) {\n      MetadataTracking::retrack(X.MD, MD);\n      X.MD = nullptr;\n    }\n  }\n};\n\n/// Typed tracking ref.\n///\n/// Track refererences of a particular type.  It's useful to use this for \\a\n/// MDNode and \\a ValueAsMetadata.\ntemplate <class T> class TypedTrackingMDRef {\n  TrackingMDRef Ref;\n\npublic:\n  TypedTrackingMDRef() = default;\n  explicit TypedTrackingMDRef(T *MD) : Ref(static_cast<Metadata *>(MD)) {}\n\n  TypedTrackingMDRef(TypedTrackingMDRef &&X) : Ref(std::move(X.Ref)) {}\n  TypedTrackingMDRef(const TypedTrackingMDRef &X) : Ref(X.Ref) {}\n\n  TypedTrackingMDRef &operator=(TypedTrackingMDRef &&X) {\n    Ref = std::move(X.Ref);\n    return *this;\n  }\n\n  TypedTrackingMDRef &operator=(const TypedTrackingMDRef &X) {\n    Ref = X.Ref;\n    return *this;\n  }\n\n  T *get() const { return (T *)Ref.get(); }\n  operator T *() const { return get(); }\n  T *operator->() const { return get(); }\n  T &operator*() const { return *get(); }\n\n  bool operator==(const TypedTrackingMDRef &X) const { return Ref == X.Ref; }\n  bool operator!=(const TypedTrackingMDRef &X) const { return Ref != X.Ref; }\n\n  void reset() { Ref.reset(); }\n  void reset(T *MD) { Ref.reset(static_cast<Metadata *>(MD)); }\n\n  /// Check whether this has a trivial destructor.\n  bool hasTrivialDestructor() const { return Ref.hasTrivialDestructor(); }\n};\n\nusing TrackingMDNodeRef = TypedTrackingMDRef<MDNode>;\nusing TrackingValueAsMetadataRef = TypedTrackingMDRef<ValueAsMetadata>;\n\n// Expose the underlying metadata to casting.\ntemplate <> struct simplify_type<TrackingMDRef> {\n  using SimpleType = Metadata *;\n\n  static SimpleType getSimplifiedValue(TrackingMDRef &MD) { return MD.get(); }\n};\n\ntemplate <> struct simplify_type<const TrackingMDRef> {\n  using SimpleType = Metadata *;\n\n  static SimpleType getSimplifiedValue(const TrackingMDRef &MD) {\n    return MD.get();\n  }\n};\n\ntemplate <class T> struct simplify_type<TypedTrackingMDRef<T>> {\n  using SimpleType = T *;\n\n  static SimpleType getSimplifiedValue(TypedTrackingMDRef<T> &MD) {\n    return MD.get();\n  }\n};\n\ntemplate <class T> struct simplify_type<const TypedTrackingMDRef<T>> {\n  using SimpleType = T *;\n\n  static SimpleType getSimplifiedValue(const TypedTrackingMDRef<T> &MD) {\n    return MD.get();\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_IR_TRACKINGMDREF_H\n"}, "43": {"id": 43, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Value.h", "content": "//===- llvm/Value.h - Definition of the Value class -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the Value class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_VALUE_H\n#define LLVM_IR_VALUE_H\n\n#include \"llvm-c/Types.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/IR/Use.h\"\n#include \"llvm/Support/Alignment.h\"\n#include \"llvm/Support/CBindingWrapping.h\"\n#include \"llvm/Support/Casting.h\"\n#include <cassert>\n#include <iterator>\n#include <memory>\n\nnamespace llvm {\n\nclass APInt;\nclass Argument;\nclass BasicBlock;\nclass Constant;\nclass ConstantData;\nclass ConstantAggregate;\nclass DataLayout;\nclass Function;\nclass GlobalAlias;\nclass GlobalIFunc;\nclass GlobalIndirectSymbol;\nclass GlobalObject;\nclass GlobalValue;\nclass GlobalVariable;\nclass InlineAsm;\nclass Instruction;\nclass LLVMContext;\nclass MDNode;\nclass Module;\nclass ModuleSlotTracker;\nclass raw_ostream;\ntemplate<typename ValueTy> class StringMapEntry;\nclass Twine;\nclass Type;\nclass User;\n\nusing ValueName = StringMapEntry<Value *>;\n\n//===----------------------------------------------------------------------===//\n//                                 Value Class\n//===----------------------------------------------------------------------===//\n\n/// LLVM Value Representation\n///\n/// This is a very important LLVM class. It is the base class of all values\n/// computed by a program that may be used as operands to other values. Value is\n/// the super class of other important classes such as Instruction and Function.\n/// All Values have a Type. Type is not a subclass of Value. Some values can\n/// have a name and they belong to some Module.  Setting the name on the Value\n/// automatically updates the module's symbol table.\n///\n/// Every value has a \"use list\" that keeps track of which other Values are\n/// using this Value.  A Value can also have an arbitrary number of ValueHandle\n/// objects that watch it and listen to RAUW and Destroy events.  See\n/// llvm/IR/ValueHandle.h for details.\nclass Value {\n  Type *VTy;\n  Use *UseList;\n\n  friend class ValueAsMetadata; // Allow access to IsUsedByMD.\n  friend class ValueHandleBase;\n\n  const unsigned char SubclassID;   // Subclass identifier (for isa/dyn_cast)\n  unsigned char HasValueHandle : 1; // Has a ValueHandle pointing to this?\n\nprotected:\n  /// Hold subclass data that can be dropped.\n  ///\n  /// This member is similar to SubclassData, however it is for holding\n  /// information which may be used to aid optimization, but which may be\n  /// cleared to zero without affecting conservative interpretation.\n  unsigned char SubclassOptionalData : 7;\n\nprivate:\n  /// Hold arbitrary subclass data.\n  ///\n  /// This member is defined by this class, but is not used for anything.\n  /// Subclasses can use it to hold whatever state they find useful.  This\n  /// field is initialized to zero by the ctor.\n  unsigned short SubclassData;\n\nprotected:\n  /// The number of operands in the subclass.\n  ///\n  /// This member is defined by this class, but not used for anything.\n  /// Subclasses can use it to store their number of operands, if they have\n  /// any.\n  ///\n  /// This is stored here to save space in User on 64-bit hosts.  Since most\n  /// instances of Value have operands, 32-bit hosts aren't significantly\n  /// affected.\n  ///\n  /// Note, this should *NOT* be used directly by any class other than User.\n  /// User uses this value to find the Use list.\n  enum : unsigned { NumUserOperandsBits = 27 };\n  unsigned NumUserOperands : NumUserOperandsBits;\n\n  // Use the same type as the bitfield above so that MSVC will pack them.\n  unsigned IsUsedByMD : 1;\n  unsigned HasName : 1;\n  unsigned HasMetadata : 1; // Has metadata attached to this?\n  unsigned HasHungOffUses : 1;\n  unsigned HasDescriptor : 1;\n\nprivate:\n  template <typename UseT> // UseT == 'Use' or 'const Use'\n  class use_iterator_impl\n      : public std::iterator<std::forward_iterator_tag, UseT *> {\n    friend class Value;\n\n    UseT *U;\n\n    explicit use_iterator_impl(UseT *u) : U(u) {}\n\n  public:\n    use_iterator_impl() : U() {}\n\n    bool operator==(const use_iterator_impl &x) const { return U == x.U; }\n    bool operator!=(const use_iterator_impl &x) const { return !operator==(x); }\n\n    use_iterator_impl &operator++() { // Preincrement\n      assert(U && \"Cannot increment end iterator!\");\n      U = U->getNext();\n      return *this;\n    }\n\n    use_iterator_impl operator++(int) { // Postincrement\n      auto tmp = *this;\n      ++*this;\n      return tmp;\n    }\n\n    UseT &operator*() const {\n      assert(U && \"Cannot dereference end iterator!\");\n      return *U;\n    }\n\n    UseT *operator->() const { return &operator*(); }\n\n    operator use_iterator_impl<const UseT>() const {\n      return use_iterator_impl<const UseT>(U);\n    }\n  };\n\n  template <typename UserTy> // UserTy == 'User' or 'const User'\n  class user_iterator_impl\n      : public std::iterator<std::forward_iterator_tag, UserTy *> {\n    use_iterator_impl<Use> UI;\n    explicit user_iterator_impl(Use *U) : UI(U) {}\n    friend class Value;\n\n  public:\n    user_iterator_impl() = default;\n\n    bool operator==(const user_iterator_impl &x) const { return UI == x.UI; }\n    bool operator!=(const user_iterator_impl &x) const { return !operator==(x); }\n\n    /// Returns true if this iterator is equal to user_end() on the value.\n    bool atEnd() const { return *this == user_iterator_impl(); }\n\n    user_iterator_impl &operator++() { // Preincrement\n      ++UI;\n      return *this;\n    }\n\n    user_iterator_impl operator++(int) { // Postincrement\n      auto tmp = *this;\n      ++*this;\n      return tmp;\n    }\n\n    // Retrieve a pointer to the current User.\n    UserTy *operator*() const {\n      return UI->getUser();\n    }\n\n    UserTy *operator->() const { return operator*(); }\n\n    operator user_iterator_impl<const UserTy>() const {\n      return user_iterator_impl<const UserTy>(*UI);\n    }\n\n    Use &getUse() const { return *UI; }\n  };\n\nprotected:\n  Value(Type *Ty, unsigned scid);\n\n  /// Value's destructor should be virtual by design, but that would require\n  /// that Value and all of its subclasses have a vtable that effectively\n  /// duplicates the information in the value ID. As a size optimization, the\n  /// destructor has been protected, and the caller should manually call\n  /// deleteValue.\n  ~Value(); // Use deleteValue() to delete a generic Value.\n\npublic:\n  Value(const Value &) = delete;\n  Value &operator=(const Value &) = delete;\n\n  /// Delete a pointer to a generic Value.\n  void deleteValue();\n\n  /// Support for debugging, callable in GDB: V->dump()\n  void dump() const;\n\n  /// Implement operator<< on Value.\n  /// @{\n  void print(raw_ostream &O, bool IsForDebug = false) const;\n  void print(raw_ostream &O, ModuleSlotTracker &MST,\n             bool IsForDebug = false) const;\n  /// @}\n\n  /// Print the name of this Value out to the specified raw_ostream.\n  ///\n  /// This is useful when you just want to print 'int %reg126', not the\n  /// instruction that generated it. If you specify a Module for context, then\n  /// even constanst get pretty-printed; for example, the type of a null\n  /// pointer is printed symbolically.\n  /// @{\n  void printAsOperand(raw_ostream &O, bool PrintType = true,\n                      const Module *M = nullptr) const;\n  void printAsOperand(raw_ostream &O, bool PrintType,\n                      ModuleSlotTracker &MST) const;\n  /// @}\n\n  /// All values are typed, get the type of this value.\n  Type *getType() const { return VTy; }\n\n  /// All values hold a context through their type.\n  LLVMContext &getContext() const;\n\n  // All values can potentially be named.\n  bool hasName() const { return HasName; }\n  ValueName *getValueName() const;\n  void setValueName(ValueName *VN);\n\nprivate:\n  void destroyValueName();\n  enum class ReplaceMetadataUses { No, Yes };\n  void doRAUW(Value *New, ReplaceMetadataUses);\n  void setNameImpl(const Twine &Name);\n\npublic:\n  /// Return a constant reference to the value's name.\n  ///\n  /// This guaranteed to return the same reference as long as the value is not\n  /// modified.  If the value has a name, this does a hashtable lookup, so it's\n  /// not free.\n  StringRef getName() const;\n\n  /// Change the name of the value.\n  ///\n  /// Choose a new unique name if the provided name is taken.\n  ///\n  /// \\param Name The new name; or \"\" if the value's name should be removed.\n  void setName(const Twine &Name);\n\n  /// Transfer the name from V to this value.\n  ///\n  /// After taking V's name, sets V's name to empty.\n  ///\n  /// \\note It is an error to call V->takeName(V).\n  void takeName(Value *V);\n\n#ifndef NDEBUG\n  std::string getNameOrAsOperand() const;\n#endif\n\n  /// Change all uses of this to point to a new Value.\n  ///\n  /// Go through the uses list for this definition and make each use point to\n  /// \"V\" instead of \"this\".  After this completes, 'this's use list is\n  /// guaranteed to be empty.\n  void replaceAllUsesWith(Value *V);\n\n  /// Change non-metadata uses of this to point to a new Value.\n  ///\n  /// Go through the uses list for this definition and make each use point to\n  /// \"V\" instead of \"this\". This function skips metadata entries in the list.\n  void replaceNonMetadataUsesWith(Value *V);\n\n  /// Go through the uses list for this definition and make each use point\n  /// to \"V\" if the callback ShouldReplace returns true for the given Use.\n  /// Unlike replaceAllUsesWith() this function does not support basic block\n  /// values or constant users.\n  void replaceUsesWithIf(Value *New,\n                         llvm::function_ref<bool(Use &U)> ShouldReplace) {\n    assert(New && \"Value::replaceUsesWithIf(<null>) is invalid!\");\n    assert(New->getType() == getType() &&\n           \"replaceUses of value with new value of different type!\");\n\n    for (use_iterator UI = use_begin(), E = use_end(); UI != E;) {\n      Use &U = *UI;\n      ++UI;\n      if (!ShouldReplace(U))\n        continue;\n      U.set(New);\n    }\n  }\n\n  /// replaceUsesOutsideBlock - Go through the uses list for this definition and\n  /// make each use point to \"V\" instead of \"this\" when the use is outside the\n  /// block. 'This's use list is expected to have at least one element.\n  /// Unlike replaceAllUsesWith() this function does not support basic block\n  /// values or constant users.\n  void replaceUsesOutsideBlock(Value *V, BasicBlock *BB);\n\n  //----------------------------------------------------------------------\n  // Methods for handling the chain of uses of this Value.\n  //\n  // Materializing a function can introduce new uses, so these methods come in\n  // two variants:\n  // The methods that start with materialized_ check the uses that are\n  // currently known given which functions are materialized. Be very careful\n  // when using them since you might not get all uses.\n  // The methods that don't start with materialized_ assert that modules is\n  // fully materialized.\n  void assertModuleIsMaterializedImpl() const;\n  // This indirection exists so we can keep assertModuleIsMaterializedImpl()\n  // around in release builds of Value.cpp to be linked with other code built\n  // in debug mode. But this avoids calling it in any of the release built code.\n  void assertModuleIsMaterialized() const {\n#ifndef NDEBUG\n    assertModuleIsMaterializedImpl();\n#endif\n  }\n\n  bool use_empty() const {\n    assertModuleIsMaterialized();\n    return UseList == nullptr;\n  }\n\n  bool materialized_use_empty() const {\n    return UseList == nullptr;\n  }\n\n  using use_iterator = use_iterator_impl<Use>;\n  using const_use_iterator = use_iterator_impl<const Use>;\n\n  use_iterator materialized_use_begin() { return use_iterator(UseList); }\n  const_use_iterator materialized_use_begin() const {\n    return const_use_iterator(UseList);\n  }\n  use_iterator use_begin() {\n    assertModuleIsMaterialized();\n    return materialized_use_begin();\n  }\n  const_use_iterator use_begin() const {\n    assertModuleIsMaterialized();\n    return materialized_use_begin();\n  }\n  use_iterator use_end() { return use_iterator(); }\n  const_use_iterator use_end() const { return const_use_iterator(); }\n  iterator_range<use_iterator> materialized_uses() {\n    return make_range(materialized_use_begin(), use_end());\n  }\n  iterator_range<const_use_iterator> materialized_uses() const {\n    return make_range(materialized_use_begin(), use_end());\n  }\n  iterator_range<use_iterator> uses() {\n    assertModuleIsMaterialized();\n    return materialized_uses();\n  }\n  iterator_range<const_use_iterator> uses() const {\n    assertModuleIsMaterialized();\n    return materialized_uses();\n  }\n\n  bool user_empty() const {\n    assertModuleIsMaterialized();\n    return UseList == nullptr;\n  }\n\n  using user_iterator = user_iterator_impl<User>;\n  using const_user_iterator = user_iterator_impl<const User>;\n\n  user_iterator materialized_user_begin() { return user_iterator(UseList); }\n  const_user_iterator materialized_user_begin() const {\n    return const_user_iterator(UseList);\n  }\n  user_iterator user_begin() {\n    assertModuleIsMaterialized();\n    return materialized_user_begin();\n  }\n  const_user_iterator user_begin() const {\n    assertModuleIsMaterialized();\n    return materialized_user_begin();\n  }\n  user_iterator user_end() { return user_iterator(); }\n  const_user_iterator user_end() const { return const_user_iterator(); }\n  User *user_back() {\n    assertModuleIsMaterialized();\n    return *materialized_user_begin();\n  }\n  const User *user_back() const {\n    assertModuleIsMaterialized();\n    return *materialized_user_begin();\n  }\n  iterator_range<user_iterator> materialized_users() {\n    return make_range(materialized_user_begin(), user_end());\n  }\n  iterator_range<const_user_iterator> materialized_users() const {\n    return make_range(materialized_user_begin(), user_end());\n  }\n  iterator_range<user_iterator> users() {\n    assertModuleIsMaterialized();\n    return materialized_users();\n  }\n  iterator_range<const_user_iterator> users() const {\n    assertModuleIsMaterialized();\n    return materialized_users();\n  }\n\n  /// Return true if there is exactly one use of this value.\n  ///\n  /// This is specialized because it is a common request and does not require\n  /// traversing the whole use list.\n  bool hasOneUse() const { return hasSingleElement(uses()); }\n\n  /// Return true if this Value has exactly N uses.\n  bool hasNUses(unsigned N) const;\n\n  /// Return true if this value has N uses or more.\n  ///\n  /// This is logically equivalent to getNumUses() >= N.\n  bool hasNUsesOrMore(unsigned N) const;\n\n  /// Return true if there is exactly one user of this value.\n  ///\n  /// Note that this is not the same as \"has one use\". If a value has one use,\n  /// then there certainly is a single user. But if value has several uses,\n  /// it is possible that all uses are in a single user, or not.\n  ///\n  /// This check is potentially costly, since it requires traversing,\n  /// in the worst case, the whole use list of a value.\n  bool hasOneUser() const;\n\n  /// Return true if there is exactly one use of this value that cannot be\n  /// dropped.\n  ///\n  /// This is specialized because it is a common request and does not require\n  /// traversing the whole use list.\n  Use *getSingleUndroppableUse();\n  const Use *getSingleUndroppableUse() const {\n    return const_cast<Value *>(this)->getSingleUndroppableUse();\n  }\n\n  /// Return true if there this value.\n  ///\n  /// This is specialized because it is a common request and does not require\n  /// traversing the whole use list.\n  bool hasNUndroppableUses(unsigned N) const;\n\n  /// Return true if this value has N uses or more.\n  ///\n  /// This is logically equivalent to getNumUses() >= N.\n  bool hasNUndroppableUsesOrMore(unsigned N) const;\n\n  /// Remove every uses that can safely be removed.\n  ///\n  /// This will remove for example uses in llvm.assume.\n  /// This should be used when performing want to perform a tranformation but\n  /// some Droppable uses pervent it.\n  /// This function optionally takes a filter to only remove some droppable\n  /// uses.\n  void dropDroppableUses(llvm::function_ref<bool(const Use *)> ShouldDrop =\n                             [](const Use *) { return true; });\n\n  /// Remove every use of this value in \\p User that can safely be removed.\n  void dropDroppableUsesIn(User &Usr);\n\n  /// Remove the droppable use \\p U.\n  static void dropDroppableUse(Use &U);\n\n  /// Check if this value is used in the specified basic block.\n  bool isUsedInBasicBlock(const BasicBlock *BB) const;\n\n  /// This method computes the number of uses of this Value.\n  ///\n  /// This is a linear time operation.  Use hasOneUse, hasNUses, or\n  /// hasNUsesOrMore to check for specific values.\n  unsigned getNumUses() const;\n\n  /// This method should only be used by the Use class.\n  void addUse(Use &U) { U.addToList(&UseList); }\n\n  /// Concrete subclass of this.\n  ///\n  /// An enumeration for keeping track of the concrete subclass of Value that\n  /// is actually instantiated. Values of this enumeration are kept in the\n  /// Value classes SubclassID field. They are used for concrete type\n  /// identification.\n  enum ValueTy {\n#define HANDLE_VALUE(Name) Name##Val,\n#include \"llvm/IR/Value.def\"\n\n    // Markers:\n#define HANDLE_CONSTANT_MARKER(Marker, Constant) Marker = Constant##Val,\n#include \"llvm/IR/Value.def\"\n  };\n\n  /// Return an ID for the concrete type of this object.\n  ///\n  /// This is used to implement the classof checks.  This should not be used\n  /// for any other purpose, as the values may change as LLVM evolves.  Also,\n  /// note that for instructions, the Instruction's opcode is added to\n  /// InstructionVal. So this means three things:\n  /// # there is no value with code InstructionVal (no opcode==0).\n  /// # there are more possible values for the value type than in ValueTy enum.\n  /// # the InstructionVal enumerator must be the highest valued enumerator in\n  ///   the ValueTy enum.\n  unsigned getValueID() const {\n    return SubclassID;\n  }\n\n  /// Return the raw optional flags value contained in this value.\n  ///\n  /// This should only be used when testing two Values for equivalence.\n  unsigned getRawSubclassOptionalData() const {\n    return SubclassOptionalData;\n  }\n\n  /// Clear the optional flags contained in this value.\n  void clearSubclassOptionalData() {\n    SubclassOptionalData = 0;\n  }\n\n  /// Check the optional flags for equality.\n  bool hasSameSubclassOptionalData(const Value *V) const {\n    return SubclassOptionalData == V->SubclassOptionalData;\n  }\n\n  /// Return true if there is a value handle associated with this value.\n  bool hasValueHandle() const { return HasValueHandle; }\n\n  /// Return true if there is metadata referencing this value.\n  bool isUsedByMetadata() const { return IsUsedByMD; }\n\nprotected:\n  /// Get the current metadata attachments for the given kind, if any.\n  ///\n  /// These functions require that the value have at most a single attachment\n  /// of the given kind, and return \\c nullptr if such an attachment is missing.\n  /// @{\n  MDNode *getMetadata(unsigned KindID) const;\n  MDNode *getMetadata(StringRef Kind) const;\n  /// @}\n\n  /// Appends all attachments with the given ID to \\c MDs in insertion order.\n  /// If the Value has no attachments with the given ID, or if ID is invalid,\n  /// leaves MDs unchanged.\n  /// @{\n  void getMetadata(unsigned KindID, SmallVectorImpl<MDNode *> &MDs) const;\n  void getMetadata(StringRef Kind, SmallVectorImpl<MDNode *> &MDs) const;\n  /// @}\n\n  /// Appends all metadata attached to this value to \\c MDs, sorting by\n  /// KindID. The first element of each pair returned is the KindID, the second\n  /// element is the metadata value. Attachments with the same ID appear in\n  /// insertion order.\n  void\n  getAllMetadata(SmallVectorImpl<std::pair<unsigned, MDNode *>> &MDs) const;\n\n  /// Return true if this value has any metadata attached to it.\n  bool hasMetadata() const { return (bool)HasMetadata; }\n\n  /// Return true if this value has the given type of metadata attached.\n  /// @{\n  bool hasMetadata(unsigned KindID) const {\n    return getMetadata(KindID) != nullptr;\n  }\n  bool hasMetadata(StringRef Kind) const {\n    return getMetadata(Kind) != nullptr;\n  }\n  /// @}\n\n  /// Set a particular kind of metadata attachment.\n  ///\n  /// Sets the given attachment to \\c MD, erasing it if \\c MD is \\c nullptr or\n  /// replacing it if it already exists.\n  /// @{\n  void setMetadata(unsigned KindID, MDNode *Node);\n  void setMetadata(StringRef Kind, MDNode *Node);\n  /// @}\n\n  /// Add a metadata attachment.\n  /// @{\n  void addMetadata(unsigned KindID, MDNode &MD);\n  void addMetadata(StringRef Kind, MDNode &MD);\n  /// @}\n\n  /// Erase all metadata attachments with the given kind.\n  ///\n  /// \\returns true if any metadata was removed.\n  bool eraseMetadata(unsigned KindID);\n\n  /// Erase all metadata attached to this Value.\n  void clearMetadata();\n\npublic:\n  /// Return true if this value is a swifterror value.\n  ///\n  /// swifterror values can be either a function argument or an alloca with a\n  /// swifterror attribute.\n  bool isSwiftError() const;\n\n  /// Strip off pointer casts, all-zero GEPs and address space casts.\n  ///\n  /// Returns the original uncasted value.  If this is called on a non-pointer\n  /// value, it returns 'this'.\n  const Value *stripPointerCasts() const;\n  Value *stripPointerCasts() {\n    return const_cast<Value *>(\n        static_cast<const Value *>(this)->stripPointerCasts());\n  }\n\n  /// Strip off pointer casts, all-zero GEPs, address space casts, and aliases.\n  ///\n  /// Returns the original uncasted value.  If this is called on a non-pointer\n  /// value, it returns 'this'.\n  const Value *stripPointerCastsAndAliases() const;\n  Value *stripPointerCastsAndAliases() {\n    return const_cast<Value *>(\n        static_cast<const Value *>(this)->stripPointerCastsAndAliases());\n  }\n\n  /// Strip off pointer casts, all-zero GEPs and address space casts\n  /// but ensures the representation of the result stays the same.\n  ///\n  /// Returns the original uncasted value with the same representation. If this\n  /// is called on a non-pointer value, it returns 'this'.\n  const Value *stripPointerCastsSameRepresentation() const;\n  Value *stripPointerCastsSameRepresentation() {\n    return const_cast<Value *>(static_cast<const Value *>(this)\n                                   ->stripPointerCastsSameRepresentation());\n  }\n\n  /// Strip off pointer casts, all-zero GEPs, single-argument phi nodes and\n  /// invariant group info.\n  ///\n  /// Returns the original uncasted value.  If this is called on a non-pointer\n  /// value, it returns 'this'. This function should be used only in\n  /// Alias analysis.\n  const Value *stripPointerCastsForAliasAnalysis() const;\n  Value *stripPointerCastsForAliasAnalysis() {\n    return const_cast<Value *>(static_cast<const Value *>(this)\n                                   ->stripPointerCastsForAliasAnalysis());\n  }\n\n  /// Strip off pointer casts and all-constant inbounds GEPs.\n  ///\n  /// Returns the original pointer value.  If this is called on a non-pointer\n  /// value, it returns 'this'.\n  const Value *stripInBoundsConstantOffsets() const;\n  Value *stripInBoundsConstantOffsets() {\n    return const_cast<Value *>(\n              static_cast<const Value *>(this)->stripInBoundsConstantOffsets());\n  }\n\n  /// Accumulate the constant offset this value has compared to a base pointer.\n  /// Only 'getelementptr' instructions (GEPs) are accumulated but other\n  /// instructions, e.g., casts, are stripped away as well.\n  /// The accumulated constant offset is added to \\p Offset and the base\n  /// pointer is returned.\n  ///\n  /// The APInt \\p Offset has to have a bit-width equal to the IntPtr type for\n  /// the address space of 'this' pointer value, e.g., use\n  /// DataLayout::getIndexTypeSizeInBits(Ty).\n  ///\n  /// If \\p AllowNonInbounds is true, offsets in GEPs are stripped and\n  /// accumulated even if the GEP is not \"inbounds\".\n  ///\n  /// If \\p ExternalAnalysis is provided it will be used to calculate a offset\n  /// when a operand of GEP is not constant.\n  /// For example, for a value \\p ExternalAnalysis might try to calculate a\n  /// lower bound. If \\p ExternalAnalysis is successful, it should return true.\n  ///\n  /// If this is called on a non-pointer value, it returns 'this' and the\n  /// \\p Offset is not modified.\n  ///\n  /// Note that this function will never return a nullptr. It will also never\n  /// manipulate the \\p Offset in a way that would not match the difference\n  /// between the underlying value and the returned one. Thus, if no constant\n  /// offset was found, the returned value is the underlying one and \\p Offset\n  /// is unchanged.\n  const Value *stripAndAccumulateConstantOffsets(\n      const DataLayout &DL, APInt &Offset, bool AllowNonInbounds,\n      function_ref<bool(Value &Value, APInt &Offset)> ExternalAnalysis =\n          nullptr) const;\n  Value *stripAndAccumulateConstantOffsets(const DataLayout &DL, APInt &Offset,\n                                           bool AllowNonInbounds) {\n    return const_cast<Value *>(\n        static_cast<const Value *>(this)->stripAndAccumulateConstantOffsets(\n            DL, Offset, AllowNonInbounds));\n  }\n\n  /// This is a wrapper around stripAndAccumulateConstantOffsets with the\n  /// in-bounds requirement set to false.\n  const Value *stripAndAccumulateInBoundsConstantOffsets(const DataLayout &DL,\n                                                         APInt &Offset) const {\n    return stripAndAccumulateConstantOffsets(DL, Offset,\n                                             /* AllowNonInbounds */ false);\n  }\n  Value *stripAndAccumulateInBoundsConstantOffsets(const DataLayout &DL,\n                                                   APInt &Offset) {\n    return stripAndAccumulateConstantOffsets(DL, Offset,\n                                             /* AllowNonInbounds */ false);\n  }\n\n  /// Strip off pointer casts and inbounds GEPs.\n  ///\n  /// Returns the original pointer value.  If this is called on a non-pointer\n  /// value, it returns 'this'.\n  const Value *stripInBoundsOffsets(function_ref<void(const Value *)> Func =\n                                        [](const Value *) {}) const;\n  inline Value *stripInBoundsOffsets(function_ref<void(const Value *)> Func =\n                                  [](const Value *) {}) {\n    return const_cast<Value *>(\n        static_cast<const Value *>(this)->stripInBoundsOffsets(Func));\n  }\n\n  /// Returns the number of bytes known to be dereferenceable for the\n  /// pointer value.\n  ///\n  /// If CanBeNull is set by this function the pointer can either be null or be\n  /// dereferenceable up to the returned number of bytes.\n  ///\n  /// IF CanBeFreed is true, the pointer is known to be dereferenceable at\n  /// point of definition only.  Caller must prove that allocation is not\n  /// deallocated between point of definition and use.\n  uint64_t getPointerDereferenceableBytes(const DataLayout &DL,\n                                          bool &CanBeNull,\n                                          bool &CanBeFreed) const;\n\n  /// Returns an alignment of the pointer value.\n  ///\n  /// Returns an alignment which is either specified explicitly, e.g. via\n  /// align attribute of a function argument, or guaranteed by DataLayout.\n  Align getPointerAlignment(const DataLayout &DL) const;\n\n  /// Translate PHI node to its predecessor from the given basic block.\n  ///\n  /// If this value is a PHI node with CurBB as its parent, return the value in\n  /// the PHI node corresponding to PredBB.  If not, return ourself.  This is\n  /// useful if you want to know the value something has in a predecessor\n  /// block.\n  const Value *DoPHITranslation(const BasicBlock *CurBB,\n                                const BasicBlock *PredBB) const;\n  Value *DoPHITranslation(const BasicBlock *CurBB, const BasicBlock *PredBB) {\n    return const_cast<Value *>(\n             static_cast<const Value *>(this)->DoPHITranslation(CurBB, PredBB));\n  }\n\n  /// The maximum alignment for instructions.\n  ///\n  /// This is the greatest alignment value supported by load, store, and alloca\n  /// instructions, and global values.\n  static const unsigned MaxAlignmentExponent = 29;\n  static const unsigned MaximumAlignment = 1u << MaxAlignmentExponent;\n\n  /// Mutate the type of this Value to be of the specified type.\n  ///\n  /// Note that this is an extremely dangerous operation which can create\n  /// completely invalid IR very easily.  It is strongly recommended that you\n  /// recreate IR objects with the right types instead of mutating them in\n  /// place.\n  void mutateType(Type *Ty) {\n    VTy = Ty;\n  }\n\n  /// Sort the use-list.\n  ///\n  /// Sorts the Value's use-list by Cmp using a stable mergesort.  Cmp is\n  /// expected to compare two \\a Use references.\n  template <class Compare> void sortUseList(Compare Cmp);\n\n  /// Reverse the use-list.\n  void reverseUseList();\n\nprivate:\n  /// Merge two lists together.\n  ///\n  /// Merges \\c L and \\c R using \\c Cmp.  To enable stable sorts, always pushes\n  /// \"equal\" items from L before items from R.\n  ///\n  /// \\return the first element in the list.\n  ///\n  /// \\note Completely ignores \\a Use::Prev (doesn't read, doesn't update).\n  template <class Compare>\n  static Use *mergeUseLists(Use *L, Use *R, Compare Cmp) {\n    Use *Merged;\n    Use **Next = &Merged;\n\n    while (true) {\n      if (!L) {\n        *Next = R;\n        break;\n      }\n      if (!R) {\n        *Next = L;\n        break;\n      }\n      if (Cmp(*R, *L)) {\n        *Next = R;\n        Next = &R->Next;\n        R = R->Next;\n      } else {\n        *Next = L;\n        Next = &L->Next;\n        L = L->Next;\n      }\n    }\n\n    return Merged;\n  }\n\nprotected:\n  unsigned short getSubclassDataFromValue() const { return SubclassData; }\n  void setValueSubclassData(unsigned short D) { SubclassData = D; }\n};\n\nstruct ValueDeleter { void operator()(Value *V) { V->deleteValue(); } };\n\n/// Use this instead of std::unique_ptr<Value> or std::unique_ptr<Instruction>.\n/// Those don't work because Value and Instruction's destructors are protected,\n/// aren't virtual, and won't destroy the complete object.\nusing unique_value = std::unique_ptr<Value, ValueDeleter>;\n\ninline raw_ostream &operator<<(raw_ostream &OS, const Value &V) {\n  V.print(OS);\n  return OS;\n}\n\nvoid Use::set(Value *V) {\n  if (Val) removeFromList();\n  Val = V;\n  if (V) V->addUse(*this);\n}\n\nValue *Use::operator=(Value *RHS) {\n  set(RHS);\n  return RHS;\n}\n\nconst Use &Use::operator=(const Use &RHS) {\n  set(RHS.Val);\n  return *this;\n}\n\ntemplate <class Compare> void Value::sortUseList(Compare Cmp) {\n  if (!UseList || !UseList->Next)\n    // No need to sort 0 or 1 uses.\n    return;\n\n  // Note: this function completely ignores Prev pointers until the end when\n  // they're fixed en masse.\n\n  // Create a binomial vector of sorted lists, visiting uses one at a time and\n  // merging lists as necessary.\n  const unsigned MaxSlots = 32;\n  Use *Slots[MaxSlots];\n\n  // Collect the first use, turning it into a single-item list.\n  Use *Next = UseList->Next;\n  UseList->Next = nullptr;\n  unsigned NumSlots = 1;\n  Slots[0] = UseList;\n\n  // Collect all but the last use.\n  while (Next->Next) {\n    Use *Current = Next;\n    Next = Current->Next;\n\n    // Turn Current into a single-item list.\n    Current->Next = nullptr;\n\n    // Save Current in the first available slot, merging on collisions.\n    unsigned I;\n    for (I = 0; I < NumSlots; ++I) {\n      if (!Slots[I])\n        break;\n\n      // Merge two lists, doubling the size of Current and emptying slot I.\n      //\n      // Since the uses in Slots[I] originally preceded those in Current, send\n      // Slots[I] in as the left parameter to maintain a stable sort.\n      Current = mergeUseLists(Slots[I], Current, Cmp);\n      Slots[I] = nullptr;\n    }\n    // Check if this is a new slot.\n    if (I == NumSlots) {\n      ++NumSlots;\n      assert(NumSlots <= MaxSlots && \"Use list bigger than 2^32\");\n    }\n\n    // Found an open slot.\n    Slots[I] = Current;\n  }\n\n  // Merge all the lists together.\n  assert(Next && \"Expected one more Use\");\n  assert(!Next->Next && \"Expected only one Use\");\n  UseList = Next;\n  for (unsigned I = 0; I < NumSlots; ++I)\n    if (Slots[I])\n      // Since the uses in Slots[I] originally preceded those in UseList, send\n      // Slots[I] in as the left parameter to maintain a stable sort.\n      UseList = mergeUseLists(Slots[I], UseList, Cmp);\n\n  // Fix the Prev pointers.\n  for (Use *I = UseList, **Prev = &UseList; I; I = I->Next) {\n    I->Prev = Prev;\n    Prev = &I->Next;\n  }\n}\n\n// isa - Provide some specializations of isa so that we don't have to include\n// the subtype header files to test to see if the value is a subclass...\n//\ntemplate <> struct isa_impl<Constant, Value> {\n  static inline bool doit(const Value &Val) {\n    static_assert(Value::ConstantFirstVal == 0, \"Val.getValueID() >= Value::ConstantFirstVal\");\n    return Val.getValueID() <= Value::ConstantLastVal;\n  }\n};\n\ntemplate <> struct isa_impl<ConstantData, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() >= Value::ConstantDataFirstVal &&\n           Val.getValueID() <= Value::ConstantDataLastVal;\n  }\n};\n\ntemplate <> struct isa_impl<ConstantAggregate, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() >= Value::ConstantAggregateFirstVal &&\n           Val.getValueID() <= Value::ConstantAggregateLastVal;\n  }\n};\n\ntemplate <> struct isa_impl<Argument, Value> {\n  static inline bool doit (const Value &Val) {\n    return Val.getValueID() == Value::ArgumentVal;\n  }\n};\n\ntemplate <> struct isa_impl<InlineAsm, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() == Value::InlineAsmVal;\n  }\n};\n\ntemplate <> struct isa_impl<Instruction, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() >= Value::InstructionVal;\n  }\n};\n\ntemplate <> struct isa_impl<BasicBlock, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() == Value::BasicBlockVal;\n  }\n};\n\ntemplate <> struct isa_impl<Function, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() == Value::FunctionVal;\n  }\n};\n\ntemplate <> struct isa_impl<GlobalVariable, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() == Value::GlobalVariableVal;\n  }\n};\n\ntemplate <> struct isa_impl<GlobalAlias, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() == Value::GlobalAliasVal;\n  }\n};\n\ntemplate <> struct isa_impl<GlobalIFunc, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() == Value::GlobalIFuncVal;\n  }\n};\n\ntemplate <> struct isa_impl<GlobalIndirectSymbol, Value> {\n  static inline bool doit(const Value &Val) {\n    return isa<GlobalAlias>(Val) || isa<GlobalIFunc>(Val);\n  }\n};\n\ntemplate <> struct isa_impl<GlobalValue, Value> {\n  static inline bool doit(const Value &Val) {\n    return isa<GlobalObject>(Val) || isa<GlobalIndirectSymbol>(Val);\n  }\n};\n\ntemplate <> struct isa_impl<GlobalObject, Value> {\n  static inline bool doit(const Value &Val) {\n    return isa<GlobalVariable>(Val) || isa<Function>(Val);\n  }\n};\n\n// Create wrappers for C Binding types (see CBindingWrapping.h).\nDEFINE_ISA_CONVERSION_FUNCTIONS(Value, LLVMValueRef)\n\n// Specialized opaque value conversions.\ninline Value **unwrap(LLVMValueRef *Vals) {\n  return reinterpret_cast<Value**>(Vals);\n}\n\ntemplate<typename T>\ninline T **unwrap(LLVMValueRef *Vals, unsigned Length) {\n#ifndef NDEBUG\n  for (LLVMValueRef *I = Vals, *E = Vals + Length; I != E; ++I)\n    unwrap<T>(*I); // For side effect of calling assert on invalid usage.\n#endif\n  (void)Length;\n  return reinterpret_cast<T**>(Vals);\n}\n\ninline LLVMValueRef *wrap(const Value **Vals) {\n  return reinterpret_cast<LLVMValueRef*>(const_cast<Value**>(Vals));\n}\n\n} // end namespace llvm\n\n#endif // LLVM_IR_VALUE_H\n"}, "44": {"id": 44, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ValueMap.h", "content": "//===- ValueMap.h - Safe map from Values to data ----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the ValueMap class.  ValueMap maps Value* or any subclass\n// to an arbitrary other type.  It provides the DenseMap interface but updates\n// itself to remain safe when keys are RAUWed or deleted.  By default, when a\n// key is RAUWed from V1 to V2, the old mapping V1->target is removed, and a new\n// mapping V2->target is added.  If V2 already existed, its old target is\n// overwritten.  When a key is deleted, its mapping is removed.\n//\n// You can override a ValueMap's Config parameter to control exactly what\n// happens on RAUW and destruction and to get called back on each event.  It's\n// legal to call back into the ValueMap from a Config's callbacks.  Config\n// parameters should inherit from ValueMapConfig<KeyT> to get default\n// implementations of all the methods ValueMap uses.  See ValueMapConfig for\n// documentation of the functions you can override.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_VALUEMAP_H\n#define LLVM_IR_VALUEMAP_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/IR/TrackingMDRef.h\"\n#include \"llvm/IR/ValueHandle.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Mutex.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <mutex>\n#include <type_traits>\n#include <utility>\n\nnamespace llvm {\n\ntemplate<typename KeyT, typename ValueT, typename Config>\nclass ValueMapCallbackVH;\ntemplate<typename DenseMapT, typename KeyT>\nclass ValueMapIterator;\ntemplate<typename DenseMapT, typename KeyT>\nclass ValueMapConstIterator;\n\n/// This class defines the default behavior for configurable aspects of\n/// ValueMap<>.  User Configs should inherit from this class to be as compatible\n/// as possible with future versions of ValueMap.\ntemplate<typename KeyT, typename MutexT = sys::Mutex>\nstruct ValueMapConfig {\n  using mutex_type = MutexT;\n\n  /// If FollowRAUW is true, the ValueMap will update mappings on RAUW. If it's\n  /// false, the ValueMap will leave the original mapping in place.\n  enum { FollowRAUW = true };\n\n  // All methods will be called with a first argument of type ExtraData.  The\n  // default implementations in this class take a templated first argument so\n  // that users' subclasses can use any type they want without having to\n  // override all the defaults.\n  struct ExtraData {};\n\n  template<typename ExtraDataT>\n  static void onRAUW(const ExtraDataT & /*Data*/, KeyT /*Old*/, KeyT /*New*/) {}\n  template<typename ExtraDataT>\n  static void onDelete(const ExtraDataT &/*Data*/, KeyT /*Old*/) {}\n\n  /// Returns a mutex that should be acquired around any changes to the map.\n  /// This is only acquired from the CallbackVH (and held around calls to onRAUW\n  /// and onDelete) and not inside other ValueMap methods.  NULL means that no\n  /// mutex is necessary.\n  template<typename ExtraDataT>\n  static mutex_type *getMutex(const ExtraDataT &/*Data*/) { return nullptr; }\n};\n\n/// See the file comment.\ntemplate<typename KeyT, typename ValueT, typename Config =ValueMapConfig<KeyT>>\nclass ValueMap {\n  friend class ValueMapCallbackVH<KeyT, ValueT, Config>;\n\n  using ValueMapCVH = ValueMapCallbackVH<KeyT, ValueT, Config>;\n  using MapT = DenseMap<ValueMapCVH, ValueT, DenseMapInfo<ValueMapCVH>>;\n  using MDMapT = DenseMap<const Metadata *, TrackingMDRef>;\n  using ExtraData = typename Config::ExtraData;\n\n  MapT Map;\n  Optional<MDMapT> MDMap;\n  ExtraData Data;\n\npublic:\n  using key_type = KeyT;\n  using mapped_type = ValueT;\n  using value_type = std::pair<KeyT, ValueT>;\n  using size_type = unsigned;\n\n  explicit ValueMap(unsigned NumInitBuckets = 64)\n      : Map(NumInitBuckets), Data() {}\n  explicit ValueMap(const ExtraData &Data, unsigned NumInitBuckets = 64)\n      : Map(NumInitBuckets), Data(Data) {}\n  // ValueMap can't be copied nor moved, beucase the callbacks store pointer\n  // to it.\n  ValueMap(const ValueMap &) = delete;\n  ValueMap(ValueMap &&) = delete;\n  ValueMap &operator=(const ValueMap &) = delete;\n  ValueMap &operator=(ValueMap &&) = delete;\n\n  bool hasMD() const { return bool(MDMap); }\n  MDMapT &MD() {\n    if (!MDMap)\n      MDMap.emplace();\n    return *MDMap;\n  }\n  Optional<MDMapT> &getMDMap() { return MDMap; }\n\n  /// Get the mapped metadata, if it's in the map.\n  Optional<Metadata *> getMappedMD(const Metadata *MD) const {\n    if (!MDMap)\n      return None;\n    auto Where = MDMap->find(MD);\n    if (Where == MDMap->end())\n      return None;\n    return Where->second.get();\n  }\n\n  using iterator = ValueMapIterator<MapT, KeyT>;\n  using const_iterator = ValueMapConstIterator<MapT, KeyT>;\n\n  inline iterator begin() { return iterator(Map.begin()); }\n  inline iterator end() { return iterator(Map.end()); }\n  inline const_iterator begin() const { return const_iterator(Map.begin()); }\n  inline const_iterator end() const { return const_iterator(Map.end()); }\n\n  bool empty() const { return Map.empty(); }\n  size_type size() const { return Map.size(); }\n\n  /// Grow the map so that it has at least Size buckets. Does not shrink\n  void resize(size_t Size) { Map.resize(Size); }\n\n  void clear() {\n    Map.clear();\n    MDMap.reset();\n  }\n\n  /// Return 1 if the specified key is in the map, 0 otherwise.\n  size_type count(const KeyT &Val) const {\n    return Map.find_as(Val) == Map.end() ? 0 : 1;\n  }\n\n  iterator find(const KeyT &Val) {\n    return iterator(Map.find_as(Val));\n  }\n  const_iterator find(const KeyT &Val) const {\n    return const_iterator(Map.find_as(Val));\n  }\n\n  /// lookup - Return the entry for the specified key, or a default\n  /// constructed value if no such entry exists.\n  ValueT lookup(const KeyT &Val) const {\n    typename MapT::const_iterator I = Map.find_as(Val);\n    return I != Map.end() ? I->second : ValueT();\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // If the key is already in the map, it returns false and doesn't update the\n  // value.\n  std::pair<iterator, bool> insert(const std::pair<KeyT, ValueT> &KV) {\n    auto MapResult = Map.insert(std::make_pair(Wrap(KV.first), KV.second));\n    return std::make_pair(iterator(MapResult.first), MapResult.second);\n  }\n\n  std::pair<iterator, bool> insert(std::pair<KeyT, ValueT> &&KV) {\n    auto MapResult =\n        Map.insert(std::make_pair(Wrap(KV.first), std::move(KV.second)));\n    return std::make_pair(iterator(MapResult.first), MapResult.second);\n  }\n\n  /// insert - Range insertion of pairs.\n  template<typename InputIt>\n  void insert(InputIt I, InputIt E) {\n    for (; I != E; ++I)\n      insert(*I);\n  }\n\n  bool erase(const KeyT &Val) {\n    typename MapT::iterator I = Map.find_as(Val);\n    if (I == Map.end())\n      return false;\n\n    Map.erase(I);\n    return true;\n  }\n  void erase(iterator I) {\n    return Map.erase(I.base());\n  }\n\n  value_type& FindAndConstruct(const KeyT &Key) {\n    return Map.FindAndConstruct(Wrap(Key));\n  }\n\n  ValueT &operator[](const KeyT &Key) {\n    return Map[Wrap(Key)];\n  }\n\n  /// isPointerIntoBucketsArray - Return true if the specified pointer points\n  /// somewhere into the ValueMap's array of buckets (i.e. either to a key or\n  /// value in the ValueMap).\n  bool isPointerIntoBucketsArray(const void *Ptr) const {\n    return Map.isPointerIntoBucketsArray(Ptr);\n  }\n\n  /// getPointerIntoBucketsArray() - Return an opaque pointer into the buckets\n  /// array.  In conjunction with the previous method, this can be used to\n  /// determine whether an insertion caused the ValueMap to reallocate.\n  const void *getPointerIntoBucketsArray() const {\n    return Map.getPointerIntoBucketsArray();\n  }\n\nprivate:\n  // Takes a key being looked up in the map and wraps it into a\n  // ValueMapCallbackVH, the actual key type of the map.  We use a helper\n  // function because ValueMapCVH is constructed with a second parameter.\n  ValueMapCVH Wrap(KeyT key) const {\n    // The only way the resulting CallbackVH could try to modify *this (making\n    // the const_cast incorrect) is if it gets inserted into the map.  But then\n    // this function must have been called from a non-const method, making the\n    // const_cast ok.\n    return ValueMapCVH(key, const_cast<ValueMap*>(this));\n  }\n};\n\n// This CallbackVH updates its ValueMap when the contained Value changes,\n// according to the user's preferences expressed through the Config object.\ntemplate <typename KeyT, typename ValueT, typename Config>\nclass ValueMapCallbackVH final : public CallbackVH {\n  friend class ValueMap<KeyT, ValueT, Config>;\n  friend struct DenseMapInfo<ValueMapCallbackVH>;\n\n  using ValueMapT = ValueMap<KeyT, ValueT, Config>;\n  using KeySansPointerT = std::remove_pointer_t<KeyT>;\n\n  ValueMapT *Map;\n\n  ValueMapCallbackVH(KeyT Key, ValueMapT *Map)\n      : CallbackVH(const_cast<Value*>(static_cast<const Value*>(Key))),\n        Map(Map) {}\n\n  // Private constructor used to create empty/tombstone DenseMap keys.\n  ValueMapCallbackVH(Value *V) : CallbackVH(V), Map(nullptr) {}\n\npublic:\n  KeyT Unwrap() const { return cast_or_null<KeySansPointerT>(getValPtr()); }\n\n  void deleted() override {\n    // Make a copy that won't get changed even when *this is destroyed.\n    ValueMapCallbackVH Copy(*this);\n    typename Config::mutex_type *M = Config::getMutex(Copy.Map->Data);\n    std::unique_lock<typename Config::mutex_type> Guard;\n    if (M)\n      Guard = std::unique_lock<typename Config::mutex_type>(*M);\n    Config::onDelete(Copy.Map->Data, Copy.Unwrap());  // May destroy *this.\n    Copy.Map->Map.erase(Copy);  // Definitely destroys *this.\n  }\n\n  void allUsesReplacedWith(Value *new_key) override {\n    assert(isa<KeySansPointerT>(new_key) &&\n           \"Invalid RAUW on key of ValueMap<>\");\n    // Make a copy that won't get changed even when *this is destroyed.\n    ValueMapCallbackVH Copy(*this);\n    typename Config::mutex_type *M = Config::getMutex(Copy.Map->Data);\n    std::unique_lock<typename Config::mutex_type> Guard;\n    if (M)\n      Guard = std::unique_lock<typename Config::mutex_type>(*M);\n\n    KeyT typed_new_key = cast<KeySansPointerT>(new_key);\n    // Can destroy *this:\n    Config::onRAUW(Copy.Map->Data, Copy.Unwrap(), typed_new_key);\n    if (Config::FollowRAUW) {\n      typename ValueMapT::MapT::iterator I = Copy.Map->Map.find(Copy);\n      // I could == Copy.Map->Map.end() if the onRAUW callback already\n      // removed the old mapping.\n      if (I != Copy.Map->Map.end()) {\n        ValueT Target(std::move(I->second));\n        Copy.Map->Map.erase(I);  // Definitely destroys *this.\n        Copy.Map->insert(std::make_pair(typed_new_key, std::move(Target)));\n      }\n    }\n  }\n};\n\ntemplate<typename KeyT, typename ValueT, typename Config>\nstruct DenseMapInfo<ValueMapCallbackVH<KeyT, ValueT, Config>> {\n  using VH = ValueMapCallbackVH<KeyT, ValueT, Config>;\n\n  static inline VH getEmptyKey() {\n    return VH(DenseMapInfo<Value *>::getEmptyKey());\n  }\n\n  static inline VH getTombstoneKey() {\n    return VH(DenseMapInfo<Value *>::getTombstoneKey());\n  }\n\n  static unsigned getHashValue(const VH &Val) {\n    return DenseMapInfo<KeyT>::getHashValue(Val.Unwrap());\n  }\n\n  static unsigned getHashValue(const KeyT &Val) {\n    return DenseMapInfo<KeyT>::getHashValue(Val);\n  }\n\n  static bool isEqual(const VH &LHS, const VH &RHS) {\n    return LHS == RHS;\n  }\n\n  static bool isEqual(const KeyT &LHS, const VH &RHS) {\n    return LHS == RHS.getValPtr();\n  }\n};\n\ntemplate<typename DenseMapT, typename KeyT>\nclass ValueMapIterator :\n    public std::iterator<std::forward_iterator_tag,\n                         std::pair<KeyT, typename DenseMapT::mapped_type>,\n                         ptrdiff_t> {\n  using BaseT = typename DenseMapT::iterator;\n  using ValueT = typename DenseMapT::mapped_type;\n\n  BaseT I;\n\npublic:\n  ValueMapIterator() : I() {}\n  ValueMapIterator(BaseT I) : I(I) {}\n\n  BaseT base() const { return I; }\n\n  struct ValueTypeProxy {\n    const KeyT first;\n    ValueT& second;\n\n    ValueTypeProxy *operator->() { return this; }\n\n    operator std::pair<KeyT, ValueT>() const {\n      return std::make_pair(first, second);\n    }\n  };\n\n  ValueTypeProxy operator*() const {\n    ValueTypeProxy Result = {I->first.Unwrap(), I->second};\n    return Result;\n  }\n\n  ValueTypeProxy operator->() const {\n    return operator*();\n  }\n\n  bool operator==(const ValueMapIterator &RHS) const {\n    return I == RHS.I;\n  }\n  bool operator!=(const ValueMapIterator &RHS) const {\n    return I != RHS.I;\n  }\n\n  inline ValueMapIterator& operator++() {  // Preincrement\n    ++I;\n    return *this;\n  }\n  ValueMapIterator operator++(int) {  // Postincrement\n    ValueMapIterator tmp = *this; ++*this; return tmp;\n  }\n};\n\ntemplate<typename DenseMapT, typename KeyT>\nclass ValueMapConstIterator :\n    public std::iterator<std::forward_iterator_tag,\n                         std::pair<KeyT, typename DenseMapT::mapped_type>,\n                         ptrdiff_t> {\n  using BaseT = typename DenseMapT::const_iterator;\n  using ValueT = typename DenseMapT::mapped_type;\n\n  BaseT I;\n\npublic:\n  ValueMapConstIterator() : I() {}\n  ValueMapConstIterator(BaseT I) : I(I) {}\n  ValueMapConstIterator(ValueMapIterator<DenseMapT, KeyT> Other)\n    : I(Other.base()) {}\n\n  BaseT base() const { return I; }\n\n  struct ValueTypeProxy {\n    const KeyT first;\n    const ValueT& second;\n    ValueTypeProxy *operator->() { return this; }\n    operator std::pair<KeyT, ValueT>() const {\n      return std::make_pair(first, second);\n    }\n  };\n\n  ValueTypeProxy operator*() const {\n    ValueTypeProxy Result = {I->first.Unwrap(), I->second};\n    return Result;\n  }\n\n  ValueTypeProxy operator->() const {\n    return operator*();\n  }\n\n  bool operator==(const ValueMapConstIterator &RHS) const {\n    return I == RHS.I;\n  }\n  bool operator!=(const ValueMapConstIterator &RHS) const {\n    return I != RHS.I;\n  }\n\n  inline ValueMapConstIterator& operator++() {  // Preincrement\n    ++I;\n    return *this;\n  }\n  ValueMapConstIterator operator++(int) {  // Postincrement\n    ValueMapConstIterator tmp = *this; ++*this; return tmp;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_IR_VALUEMAP_H\n"}, "45": {"id": 45, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/LaneBitmask.h", "content": "//===- llvm/MC/LaneBitmask.h ------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// A common definition of LaneBitmask for use in TableGen and CodeGen.\n///\n/// A lane mask is a bitmask representing the covering of a register with\n/// sub-registers.\n///\n/// This is typically used to track liveness at sub-register granularity.\n/// Lane masks for sub-register indices are similar to register units for\n/// physical registers. The individual bits in a lane mask can't be assigned\n/// any specific meaning. They can be used to check if two sub-register\n/// indices overlap.\n///\n/// Iff the target has a register such that:\n///\n///   getSubReg(Reg, A) overlaps getSubReg(Reg, B)\n///\n/// then:\n///\n///   (getSubRegIndexLaneMask(A) & getSubRegIndexLaneMask(B)) != 0\n\n#ifndef LLVM_MC_LANEBITMASK_H\n#define LLVM_MC_LANEBITMASK_H\n\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/Format.h\"\n#include \"llvm/Support/Printable.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\nnamespace llvm {\n\n  struct LaneBitmask {\n    // When changing the underlying type, change the format string as well.\n    using Type = uint64_t;\n    enum : unsigned { BitWidth = 8*sizeof(Type) };\n    constexpr static const char *const FormatStr = \"%016llX\";\n\n    constexpr LaneBitmask() = default;\n    explicit constexpr LaneBitmask(Type V) : Mask(V) {}\n\n    constexpr bool operator== (LaneBitmask M) const { return Mask == M.Mask; }\n    constexpr bool operator!= (LaneBitmask M) const { return Mask != M.Mask; }\n    constexpr bool operator< (LaneBitmask M)  const { return Mask < M.Mask; }\n    constexpr bool none() const { return Mask == 0; }\n    constexpr bool any()  const { return Mask != 0; }\n    constexpr bool all()  const { return ~Mask == 0; }\n\n    constexpr LaneBitmask operator~() const {\n      return LaneBitmask(~Mask);\n    }\n    constexpr LaneBitmask operator|(LaneBitmask M) const {\n      return LaneBitmask(Mask | M.Mask);\n    }\n    constexpr LaneBitmask operator&(LaneBitmask M) const {\n      return LaneBitmask(Mask & M.Mask);\n    }\n    LaneBitmask &operator|=(LaneBitmask M) {\n      Mask |= M.Mask;\n      return *this;\n    }\n    LaneBitmask &operator&=(LaneBitmask M) {\n      Mask &= M.Mask;\n      return *this;\n    }\n\n    constexpr Type getAsInteger() const { return Mask; }\n\n    unsigned getNumLanes() const {\n      return countPopulation(Mask);\n    }\n    unsigned getHighestLane() const {\n      return Log2_64(Mask);\n    }\n\n    static constexpr LaneBitmask getNone() { return LaneBitmask(0); }\n    static constexpr LaneBitmask getAll() { return ~LaneBitmask(0); }\n    static constexpr LaneBitmask getLane(unsigned Lane) {\n      return LaneBitmask(Type(1) << Lane);\n    }\n\n  private:\n    Type Mask = 0;\n  };\n\n  /// Create Printable object to print LaneBitmasks on a \\ref raw_ostream.\n  inline Printable PrintLaneMask(LaneBitmask LaneMask) {\n    return Printable([LaneMask](raw_ostream &OS) {\n      OS << format(LaneBitmask::FormatStr, LaneMask.getAsInteger());\n    });\n  }\n\n} // end namespace llvm\n\n#endif // LLVM_MC_LANEBITMASK_H\n"}, "46": {"id": 46, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegister.h", "content": "//===-- llvm/MC/Register.h --------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_MCREGISTER_H\n#define LLVM_MC_MCREGISTER_H\n\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include <cassert>\n\nnamespace llvm {\n\n/// An unsigned integer type large enough to represent all physical registers,\n/// but not necessarily virtual registers.\nusing MCPhysReg = uint16_t;\n\n/// Wrapper class representing physical registers. Should be passed by value.\nclass MCRegister {\n  friend hash_code hash_value(const MCRegister &);\n  unsigned Reg;\n\npublic:\n  constexpr MCRegister(unsigned Val = 0): Reg(Val) {}\n\n  // Register numbers can represent physical registers, virtual registers, and\n  // sometimes stack slots. The unsigned values are divided into these ranges:\n  //\n  //   0           Not a register, can be used as a sentinel.\n  //   [1;2^30)    Physical registers assigned by TableGen.\n  //   [2^30;2^31) Stack slots. (Rarely used.)\n  //   [2^31;2^32) Virtual registers assigned by MachineRegisterInfo.\n  //\n  // Further sentinels can be allocated from the small negative integers.\n  // DenseMapInfo<unsigned> uses -1u and -2u.\n  static_assert(std::numeric_limits<decltype(Reg)>::max() >= 0xFFFFFFFF,\n                \"Reg isn't large enough to hold full range.\");\n  static constexpr unsigned NoRegister = 0u;\n  static constexpr unsigned FirstPhysicalReg = 1u;\n  static constexpr unsigned FirstStackSlot = 1u << 30;\n  static constexpr unsigned VirtualRegFlag = 1u << 31;\n\n  /// This is the portion of the positive number space that is not a physical\n  /// register. StackSlot values do not exist in the MC layer, see\n  /// Register::isStackSlot() for the more information on them.\n  ///\n  static bool isStackSlot(unsigned Reg) {\n    return FirstStackSlot <= Reg && Reg < VirtualRegFlag;\n  }\n\n  /// Return true if the specified register number is in\n  /// the physical register namespace.\n  static bool isPhysicalRegister(unsigned Reg) {\n    return FirstPhysicalReg <= Reg && Reg < FirstStackSlot;\n  }\n\n  constexpr operator unsigned() const {\n    return Reg;\n  }\n\n  /// Check the provided unsigned value is a valid MCRegister.\n  static MCRegister from(unsigned Val) {\n    assert(Val == NoRegister || isPhysicalRegister(Val));\n    return MCRegister(Val);\n  }\n\n  unsigned id() const {\n    return Reg;\n  }\n\n  bool isValid() const { return Reg != NoRegister; }\n\n  /// Comparisons between register objects\n  bool operator==(const MCRegister &Other) const { return Reg == Other.Reg; }\n  bool operator!=(const MCRegister &Other) const { return Reg != Other.Reg; }\n\n  /// Comparisons against register constants. E.g.\n  /// * R == AArch64::WZR\n  /// * R == 0\n  /// * R == VirtRegMap::NO_PHYS_REG\n  bool operator==(unsigned Other) const { return Reg == Other; }\n  bool operator!=(unsigned Other) const { return Reg != Other; }\n  bool operator==(int Other) const { return Reg == unsigned(Other); }\n  bool operator!=(int Other) const { return Reg != unsigned(Other); }\n  // MSVC requires that we explicitly declare these two as well.\n  bool operator==(MCPhysReg Other) const { return Reg == unsigned(Other); }\n  bool operator!=(MCPhysReg Other) const { return Reg != unsigned(Other); }\n};\n\n// Provide DenseMapInfo for MCRegister\ntemplate<> struct DenseMapInfo<MCRegister> {\n  static inline unsigned getEmptyKey() {\n    return DenseMapInfo<unsigned>::getEmptyKey();\n  }\n  static inline unsigned getTombstoneKey() {\n    return DenseMapInfo<unsigned>::getTombstoneKey();\n  }\n  static unsigned getHashValue(const MCRegister &Val) {\n    return DenseMapInfo<unsigned>::getHashValue(Val.id());\n  }\n  static bool isEqual(const MCRegister &LHS, const MCRegister &RHS) {\n    return DenseMapInfo<unsigned>::isEqual(LHS.id(), RHS.id());\n  }\n};\n\ninline hash_code hash_value(const MCRegister &Reg) {\n  return hash_value(Reg.id());\n}\n}\n\n#endif // LLVM_MC_MCREGISTER_H\n"}, "47": {"id": 47, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h", "content": "//===- MC/MCRegisterInfo.h - Target Register Description --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file describes an abstract interface used to get information about a\n// target machines register file.  This information is used for a variety of\n// purposed, especially register allocation.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_MCREGISTERINFO_H\n#define LLVM_MC_MCREGISTERINFO_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/MC/LaneBitmask.h\"\n#include \"llvm/MC/MCRegister.h\"\n#include <cassert>\n#include <cstdint>\n#include <iterator>\n#include <utility>\n\nnamespace llvm {\n\n/// MCRegisterClass - Base class of TargetRegisterClass.\nclass MCRegisterClass {\npublic:\n  using iterator = const MCPhysReg*;\n  using const_iterator = const MCPhysReg*;\n\n  const iterator RegsBegin;\n  const uint8_t *const RegSet;\n  const uint32_t NameIdx;\n  const uint16_t RegsSize;\n  const uint16_t RegSetSize;\n  const uint16_t ID;\n  const int8_t CopyCost;\n  const bool Allocatable;\n\n  /// getID() - Return the register class ID number.\n  ///\n  unsigned getID() const { return ID; }\n\n  /// begin/end - Return all of the registers in this class.\n  ///\n  iterator       begin() const { return RegsBegin; }\n  iterator         end() const { return RegsBegin + RegsSize; }\n\n  /// getNumRegs - Return the number of registers in this class.\n  ///\n  unsigned getNumRegs() const { return RegsSize; }\n\n  /// getRegister - Return the specified register in the class.\n  ///\n  unsigned getRegister(unsigned i) const {\n    assert(i < getNumRegs() && \"Register number out of range!\");\n    return RegsBegin[i];\n  }\n\n  /// contains - Return true if the specified register is included in this\n  /// register class.  This does not include virtual registers.\n  bool contains(MCRegister Reg) const {\n    unsigned RegNo = unsigned(Reg);\n    unsigned InByte = RegNo % 8;\n    unsigned Byte = RegNo / 8;\n    if (Byte >= RegSetSize)\n      return false;\n    return (RegSet[Byte] & (1 << InByte)) != 0;\n  }\n\n  /// contains - Return true if both registers are in this class.\n  bool contains(MCRegister Reg1, MCRegister Reg2) const {\n    return contains(Reg1) && contains(Reg2);\n  }\n\n  /// getCopyCost - Return the cost of copying a value between two registers in\n  /// this class. A negative number means the register class is very expensive\n  /// to copy e.g. status flag register classes.\n  int getCopyCost() const { return CopyCost; }\n\n  /// isAllocatable - Return true if this register class may be used to create\n  /// virtual registers.\n  bool isAllocatable() const { return Allocatable; }\n};\n\n/// MCRegisterDesc - This record contains information about a particular\n/// register.  The SubRegs field is a zero terminated array of registers that\n/// are sub-registers of the specific register, e.g. AL, AH are sub-registers\n/// of AX. The SuperRegs field is a zero terminated array of registers that are\n/// super-registers of the specific register, e.g. RAX, EAX, are\n/// super-registers of AX.\n///\nstruct MCRegisterDesc {\n  uint32_t Name;      // Printable name for the reg (for debugging)\n  uint32_t SubRegs;   // Sub-register set, described above\n  uint32_t SuperRegs; // Super-register set, described above\n\n  // Offset into MCRI::SubRegIndices of a list of sub-register indices for each\n  // sub-register in SubRegs.\n  uint32_t SubRegIndices;\n\n  // RegUnits - Points to the list of register units. The low 4 bits holds the\n  // Scale, the high bits hold an offset into DiffLists. See MCRegUnitIterator.\n  uint32_t RegUnits;\n\n  /// Index into list with lane mask sequences. The sequence contains a lanemask\n  /// for every register unit.\n  uint16_t RegUnitLaneMasks;\n};\n\n/// MCRegisterInfo base class - We assume that the target defines a static\n/// array of MCRegisterDesc objects that represent all of the machine\n/// registers that the target has.  As such, we simply have to track a pointer\n/// to this array so that we can turn register number into a register\n/// descriptor.\n///\n/// Note this class is designed to be a base class of TargetRegisterInfo, which\n/// is the interface used by codegen. However, specific targets *should never*\n/// specialize this class. MCRegisterInfo should only contain getters to access\n/// TableGen generated physical register data. It must not be extended with\n/// virtual methods.\n///\nclass MCRegisterInfo {\npublic:\n  using regclass_iterator = const MCRegisterClass *;\n\n  /// DwarfLLVMRegPair - Emitted by tablegen so Dwarf<->LLVM reg mappings can be\n  /// performed with a binary search.\n  struct DwarfLLVMRegPair {\n    unsigned FromReg;\n    unsigned ToReg;\n\n    bool operator<(DwarfLLVMRegPair RHS) const { return FromReg < RHS.FromReg; }\n  };\n\n  /// SubRegCoveredBits - Emitted by tablegen: bit range covered by a subreg\n  /// index, -1 in any being invalid.\n  struct SubRegCoveredBits {\n    uint16_t Offset;\n    uint16_t Size;\n  };\n\nprivate:\n  const MCRegisterDesc *Desc;                 // Pointer to the descriptor array\n  unsigned NumRegs;                           // Number of entries in the array\n  MCRegister RAReg;                           // Return address register\n  MCRegister PCReg;                           // Program counter register\n  const MCRegisterClass *Classes;             // Pointer to the regclass array\n  unsigned NumClasses;                        // Number of entries in the array\n  unsigned NumRegUnits;                       // Number of regunits.\n  const MCPhysReg (*RegUnitRoots)[2];         // Pointer to regunit root table.\n  const MCPhysReg *DiffLists;                 // Pointer to the difflists array\n  const LaneBitmask *RegUnitMaskSequences;    // Pointer to lane mask sequences\n                                              // for register units.\n  const char *RegStrings;                     // Pointer to the string table.\n  const char *RegClassStrings;                // Pointer to the class strings.\n  const uint16_t *SubRegIndices;              // Pointer to the subreg lookup\n                                              // array.\n  const SubRegCoveredBits *SubRegIdxRanges;   // Pointer to the subreg covered\n                                              // bit ranges array.\n  unsigned NumSubRegIndices;                  // Number of subreg indices.\n  const uint16_t *RegEncodingTable;           // Pointer to array of register\n                                              // encodings.\n\n  unsigned L2DwarfRegsSize;\n  unsigned EHL2DwarfRegsSize;\n  unsigned Dwarf2LRegsSize;\n  unsigned EHDwarf2LRegsSize;\n  const DwarfLLVMRegPair *L2DwarfRegs;        // LLVM to Dwarf regs mapping\n  const DwarfLLVMRegPair *EHL2DwarfRegs;      // LLVM to Dwarf regs mapping EH\n  const DwarfLLVMRegPair *Dwarf2LRegs;        // Dwarf to LLVM regs mapping\n  const DwarfLLVMRegPair *EHDwarf2LRegs;      // Dwarf to LLVM regs mapping EH\n  DenseMap<MCRegister, int> L2SEHRegs;        // LLVM to SEH regs mapping\n  DenseMap<MCRegister, int> L2CVRegs;         // LLVM to CV regs mapping\n\npublic:\n  // Forward declaration to become a friend class of DiffListIterator.\n  template <class SubT> class mc_difflist_iterator;\n\n  /// DiffListIterator - Base iterator class that can traverse the\n  /// differentially encoded register and regunit lists in DiffLists.\n  /// Don't use this class directly, use one of the specialized sub-classes\n  /// defined below.\n  class DiffListIterator {\n    uint16_t Val = 0;\n    const MCPhysReg *List = nullptr;\n\n  protected:\n    /// Create an invalid iterator. Call init() to point to something useful.\n    DiffListIterator() = default;\n\n    /// init - Point the iterator to InitVal, decoding subsequent values from\n    /// DiffList. The iterator will initially point to InitVal, sub-classes are\n    /// responsible for skipping the seed value if it is not part of the list.\n    void init(MCPhysReg InitVal, const MCPhysReg *DiffList) {\n      Val = InitVal;\n      List = DiffList;\n    }\n\n    /// advance - Move to the next list position, return the applied\n    /// differential. This function does not detect the end of the list, that\n    /// is the caller's responsibility (by checking for a 0 return value).\n    MCRegister advance() {\n      assert(isValid() && \"Cannot move off the end of the list.\");\n      MCPhysReg D = *List++;\n      Val += D;\n      return D;\n    }\n\n  public:\n    /// isValid - returns true if this iterator is not yet at the end.\n    bool isValid() const { return List; }\n\n    /// Dereference the iterator to get the value at the current position.\n    MCRegister operator*() const { return Val; }\n\n    /// Pre-increment to move to the next position.\n    void operator++() {\n      // The end of the list is encoded as a 0 differential.\n      if (!advance())\n        List = nullptr;\n    }\n\n    template <class SubT> friend class MCRegisterInfo::mc_difflist_iterator;\n  };\n\n  /// Forward iterator using DiffListIterator.\n  template <class SubT>\n  class mc_difflist_iterator\n      : public iterator_facade_base<mc_difflist_iterator<SubT>,\n                                    std::forward_iterator_tag, MCPhysReg> {\n    MCRegisterInfo::DiffListIterator Iter;\n    /// Current value as MCPhysReg, so we can return a reference to it.\n    MCPhysReg Val;\n\n  protected:\n    mc_difflist_iterator(MCRegisterInfo::DiffListIterator Iter) : Iter(Iter) {}\n\n    // Allow conversion between instantiations where valid.\n    mc_difflist_iterator(MCRegister Reg, const MCPhysReg *DiffList) {\n      Iter.init(Reg, DiffList);\n      Val = *Iter;\n    }\n\n  public:\n    // Allow default construction to build variables, but this doesn't build\n    // a useful iterator.\n    mc_difflist_iterator() = default;\n\n    /// Return an iterator past the last element.\n    static SubT end() {\n      SubT End;\n      End.Iter.List = nullptr;\n      return End;\n    }\n\n    bool operator==(const mc_difflist_iterator &Arg) const {\n      return Iter.List == Arg.Iter.List;\n    }\n\n    const MCPhysReg &operator*() const { return Val; }\n\n    using mc_difflist_iterator::iterator_facade_base::operator++;\n    void operator++() {\n      assert(Iter.List && \"Cannot increment the end iterator!\");\n      ++Iter;\n      Val = *Iter;\n    }\n  };\n\n  /// Forward iterator over all sub-registers.\n  /// TODO: Replace remaining uses of MCSubRegIterator.\n  class mc_subreg_iterator : public mc_difflist_iterator<mc_subreg_iterator> {\n  public:\n    mc_subreg_iterator(MCRegisterInfo::DiffListIterator Iter)\n        : mc_difflist_iterator(Iter) {}\n    mc_subreg_iterator() = default;\n    mc_subreg_iterator(MCRegister Reg, const MCRegisterInfo *MCRI)\n        : mc_difflist_iterator(Reg, MCRI->DiffLists + MCRI->get(Reg).SubRegs) {}\n  };\n\n  /// Forward iterator over all super-registers.\n  /// TODO: Replace remaining uses of MCSuperRegIterator.\n  class mc_superreg_iterator\n      : public mc_difflist_iterator<mc_superreg_iterator> {\n  public:\n    mc_superreg_iterator(MCRegisterInfo::DiffListIterator Iter)\n        : mc_difflist_iterator(Iter) {}\n    mc_superreg_iterator() = default;\n    mc_superreg_iterator(MCRegister Reg, const MCRegisterInfo *MCRI)\n        : mc_difflist_iterator(Reg,\n                               MCRI->DiffLists + MCRI->get(Reg).SuperRegs) {}\n  };\n\n  /// Return an iterator range over all sub-registers of \\p Reg, excluding \\p\n  /// Reg.\n  iterator_range<mc_subreg_iterator> subregs(MCRegister Reg) const {\n    return make_range(std::next(mc_subreg_iterator(Reg, this)),\n                      mc_subreg_iterator::end());\n  }\n\n  /// Return an iterator range over all sub-registers of \\p Reg, including \\p\n  /// Reg.\n  iterator_range<mc_subreg_iterator> subregs_inclusive(MCRegister Reg) const {\n    return make_range({Reg, this}, mc_subreg_iterator::end());\n  }\n\n  /// Return an iterator range over all super-registers of \\p Reg, excluding \\p\n  /// Reg.\n  iterator_range<mc_superreg_iterator> superregs(MCRegister Reg) const {\n    return make_range(std::next(mc_superreg_iterator(Reg, this)),\n                      mc_superreg_iterator::end());\n  }\n\n  /// Return an iterator range over all super-registers of \\p Reg, including \\p\n  /// Reg.\n  iterator_range<mc_superreg_iterator>\n  superregs_inclusive(MCRegister Reg) const {\n    return make_range({Reg, this}, mc_superreg_iterator::end());\n  }\n\n  /// Return an iterator range over all sub- and super-registers of \\p Reg,\n  /// including \\p Reg.\n  detail::concat_range<const MCPhysReg, iterator_range<mc_subreg_iterator>,\n                       iterator_range<mc_superreg_iterator>>\n  sub_and_superregs_inclusive(MCRegister Reg) const {\n    return concat<const MCPhysReg>(subregs_inclusive(Reg), superregs(Reg));\n  }\n\n  // These iterators are allowed to sub-class DiffListIterator and access\n  // internal list pointers.\n  friend class MCSubRegIterator;\n  friend class MCSubRegIndexIterator;\n  friend class MCSuperRegIterator;\n  friend class MCRegUnitIterator;\n  friend class MCRegUnitMaskIterator;\n  friend class MCRegUnitRootIterator;\n\n  /// Initialize MCRegisterInfo, called by TableGen\n  /// auto-generated routines. *DO NOT USE*.\n  void InitMCRegisterInfo(const MCRegisterDesc *D, unsigned NR, unsigned RA,\n                          unsigned PC,\n                          const MCRegisterClass *C, unsigned NC,\n                          const MCPhysReg (*RURoots)[2],\n                          unsigned NRU,\n                          const MCPhysReg *DL,\n                          const LaneBitmask *RUMS,\n                          const char *Strings,\n                          const char *ClassStrings,\n                          const uint16_t *SubIndices,\n                          unsigned NumIndices,\n                          const SubRegCoveredBits *SubIdxRanges,\n                          const uint16_t *RET) {\n    Desc = D;\n    NumRegs = NR;\n    RAReg = RA;\n    PCReg = PC;\n    Classes = C;\n    DiffLists = DL;\n    RegUnitMaskSequences = RUMS;\n    RegStrings = Strings;\n    RegClassStrings = ClassStrings;\n    NumClasses = NC;\n    RegUnitRoots = RURoots;\n    NumRegUnits = NRU;\n    SubRegIndices = SubIndices;\n    NumSubRegIndices = NumIndices;\n    SubRegIdxRanges = SubIdxRanges;\n    RegEncodingTable = RET;\n\n    // Initialize DWARF register mapping variables\n    EHL2DwarfRegs = nullptr;\n    EHL2DwarfRegsSize = 0;\n    L2DwarfRegs = nullptr;\n    L2DwarfRegsSize = 0;\n    EHDwarf2LRegs = nullptr;\n    EHDwarf2LRegsSize = 0;\n    Dwarf2LRegs = nullptr;\n    Dwarf2LRegsSize = 0;\n  }\n\n  /// Used to initialize LLVM register to Dwarf\n  /// register number mapping. Called by TableGen auto-generated routines.\n  /// *DO NOT USE*.\n  void mapLLVMRegsToDwarfRegs(const DwarfLLVMRegPair *Map, unsigned Size,\n                              bool isEH) {\n    if (isEH) {\n      EHL2DwarfRegs = Map;\n      EHL2DwarfRegsSize = Size;\n    } else {\n      L2DwarfRegs = Map;\n      L2DwarfRegsSize = Size;\n    }\n  }\n\n  /// Used to initialize Dwarf register to LLVM\n  /// register number mapping. Called by TableGen auto-generated routines.\n  /// *DO NOT USE*.\n  void mapDwarfRegsToLLVMRegs(const DwarfLLVMRegPair *Map, unsigned Size,\n                              bool isEH) {\n    if (isEH) {\n      EHDwarf2LRegs = Map;\n      EHDwarf2LRegsSize = Size;\n    } else {\n      Dwarf2LRegs = Map;\n      Dwarf2LRegsSize = Size;\n    }\n  }\n\n  /// mapLLVMRegToSEHReg - Used to initialize LLVM register to SEH register\n  /// number mapping. By default the SEH register number is just the same\n  /// as the LLVM register number.\n  /// FIXME: TableGen these numbers. Currently this requires target specific\n  /// initialization code.\n  void mapLLVMRegToSEHReg(MCRegister LLVMReg, int SEHReg) {\n    L2SEHRegs[LLVMReg] = SEHReg;\n  }\n\n  void mapLLVMRegToCVReg(MCRegister LLVMReg, int CVReg) {\n    L2CVRegs[LLVMReg] = CVReg;\n  }\n\n  /// This method should return the register where the return\n  /// address can be found.\n  MCRegister getRARegister() const {\n    return RAReg;\n  }\n\n  /// Return the register which is the program counter.\n  MCRegister getProgramCounter() const {\n    return PCReg;\n  }\n\n  const MCRegisterDesc &operator[](MCRegister RegNo) const {\n    assert(RegNo < NumRegs &&\n           \"Attempting to access record for invalid register number!\");\n    return Desc[RegNo];\n  }\n\n  /// Provide a get method, equivalent to [], but more useful with a\n  /// pointer to this object.\n  const MCRegisterDesc &get(MCRegister RegNo) const {\n    return operator[](RegNo);\n  }\n\n  /// Returns the physical register number of sub-register \"Index\"\n  /// for physical register RegNo. Return zero if the sub-register does not\n  /// exist.\n  MCRegister getSubReg(MCRegister Reg, unsigned Idx) const;\n\n  /// Return a super-register of the specified register\n  /// Reg so its sub-register of index SubIdx is Reg.\n  MCRegister getMatchingSuperReg(MCRegister Reg, unsigned SubIdx,\n                                 const MCRegisterClass *RC) const;\n\n  /// For a given register pair, return the sub-register index\n  /// if the second register is a sub-register of the first. Return zero\n  /// otherwise.\n  unsigned getSubRegIndex(MCRegister RegNo, MCRegister SubRegNo) const;\n\n  /// Get the size of the bit range covered by a sub-register index.\n  /// If the index isn't continuous, return the sum of the sizes of its parts.\n  /// If the index is used to access subregisters of different sizes, return -1.\n  unsigned getSubRegIdxSize(unsigned Idx) const;\n\n  /// Get the offset of the bit range covered by a sub-register index.\n  /// If an Offset doesn't make sense (the index isn't continuous, or is used to\n  /// access sub-registers at different offsets), return -1.\n  unsigned getSubRegIdxOffset(unsigned Idx) const;\n\n  /// Return the human-readable symbolic target-specific name for the\n  /// specified physical register.\n  const char *getName(MCRegister RegNo) const {\n    return RegStrings + get(RegNo).Name;\n  }\n\n  /// Return the number of registers this target has (useful for\n  /// sizing arrays holding per register information)\n  unsigned getNumRegs() const {\n    return NumRegs;\n  }\n\n  /// Return the number of sub-register indices\n  /// understood by the target. Index 0 is reserved for the no-op sub-register,\n  /// while 1 to getNumSubRegIndices() - 1 represent real sub-registers.\n  unsigned getNumSubRegIndices() const {\n    return NumSubRegIndices;\n  }\n\n  /// Return the number of (native) register units in the\n  /// target. Register units are numbered from 0 to getNumRegUnits() - 1. They\n  /// can be accessed through MCRegUnitIterator defined below.\n  unsigned getNumRegUnits() const {\n    return NumRegUnits;\n  }\n\n  /// Map a target register to an equivalent dwarf register\n  /// number.  Returns -1 if there is no equivalent value.  The second\n  /// parameter allows targets to use different numberings for EH info and\n  /// debugging info.\n  int getDwarfRegNum(MCRegister RegNum, bool isEH) const;\n\n  /// Map a dwarf register back to a target register. Returns None is there is\n  /// no mapping.\n  Optional<unsigned> getLLVMRegNum(unsigned RegNum, bool isEH) const;\n\n  /// Map a target EH register number to an equivalent DWARF register\n  /// number.\n  int getDwarfRegNumFromDwarfEHRegNum(unsigned RegNum) const;\n\n  /// Map a target register to an equivalent SEH register\n  /// number.  Returns LLVM register number if there is no equivalent value.\n  int getSEHRegNum(MCRegister RegNum) const;\n\n  /// Map a target register to an equivalent CodeView register\n  /// number.\n  int getCodeViewRegNum(MCRegister RegNum) const;\n\n  regclass_iterator regclass_begin() const { return Classes; }\n  regclass_iterator regclass_end() const { return Classes+NumClasses; }\n  iterator_range<regclass_iterator> regclasses() const {\n    return make_range(regclass_begin(), regclass_end());\n  }\n\n  unsigned getNumRegClasses() const {\n    return (unsigned)(regclass_end()-regclass_begin());\n  }\n\n  /// Returns the register class associated with the enumeration\n  /// value.  See class MCOperandInfo.\n  const MCRegisterClass& getRegClass(unsigned i) const {\n    assert(i < getNumRegClasses() && \"Register Class ID out of range\");\n    return Classes[i];\n  }\n\n  const char *getRegClassName(const MCRegisterClass *Class) const {\n    return RegClassStrings + Class->NameIdx;\n  }\n\n   /// Returns the encoding for RegNo\n  uint16_t getEncodingValue(MCRegister RegNo) const {\n    assert(RegNo < NumRegs &&\n           \"Attempting to get encoding for invalid register number!\");\n    return RegEncodingTable[RegNo];\n  }\n\n  /// Returns true if RegB is a sub-register of RegA.\n  bool isSubRegister(MCRegister RegA, MCRegister RegB) const {\n    return isSuperRegister(RegB, RegA);\n  }\n\n  /// Returns true if RegB is a super-register of RegA.\n  bool isSuperRegister(MCRegister RegA, MCRegister RegB) const;\n\n  /// Returns true if RegB is a sub-register of RegA or if RegB == RegA.\n  bool isSubRegisterEq(MCRegister RegA, MCRegister RegB) const {\n    return isSuperRegisterEq(RegB, RegA);\n  }\n\n  /// Returns true if RegB is a super-register of RegA or if\n  /// RegB == RegA.\n  bool isSuperRegisterEq(MCRegister RegA, MCRegister RegB) const {\n    return RegA == RegB || isSuperRegister(RegA, RegB);\n  }\n\n  /// Returns true if RegB is a super-register or sub-register of RegA\n  /// or if RegB == RegA.\n  bool isSuperOrSubRegisterEq(MCRegister RegA, MCRegister RegB) const {\n    return isSubRegisterEq(RegA, RegB) || isSuperRegister(RegA, RegB);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                          Register List Iterators\n//===----------------------------------------------------------------------===//\n\n// MCRegisterInfo provides lists of super-registers, sub-registers, and\n// aliasing registers. Use these iterator classes to traverse the lists.\n\n/// MCSubRegIterator enumerates all sub-registers of Reg.\n/// If IncludeSelf is set, Reg itself is included in the list.\nclass MCSubRegIterator : public MCRegisterInfo::DiffListIterator {\npublic:\n  MCSubRegIterator(MCRegister Reg, const MCRegisterInfo *MCRI,\n                   bool IncludeSelf = false) {\n    init(Reg, MCRI->DiffLists + MCRI->get(Reg).SubRegs);\n    // Initially, the iterator points to Reg itself.\n    if (!IncludeSelf)\n      ++*this;\n  }\n};\n\n/// Iterator that enumerates the sub-registers of a Reg and the associated\n/// sub-register indices.\nclass MCSubRegIndexIterator {\n  MCSubRegIterator SRIter;\n  const uint16_t *SRIndex;\n\npublic:\n  /// Constructs an iterator that traverses subregisters and their\n  /// associated subregister indices.\n  MCSubRegIndexIterator(MCRegister Reg, const MCRegisterInfo *MCRI)\n    : SRIter(Reg, MCRI) {\n    SRIndex = MCRI->SubRegIndices + MCRI->get(Reg).SubRegIndices;\n  }\n\n  /// Returns current sub-register.\n  MCRegister getSubReg() const {\n    return *SRIter;\n  }\n\n  /// Returns sub-register index of the current sub-register.\n  unsigned getSubRegIndex() const {\n    return *SRIndex;\n  }\n\n  /// Returns true if this iterator is not yet at the end.\n  bool isValid() const { return SRIter.isValid(); }\n\n  /// Moves to the next position.\n  void operator++() {\n    ++SRIter;\n    ++SRIndex;\n  }\n};\n\n/// MCSuperRegIterator enumerates all super-registers of Reg.\n/// If IncludeSelf is set, Reg itself is included in the list.\nclass MCSuperRegIterator : public MCRegisterInfo::DiffListIterator {\npublic:\n  MCSuperRegIterator() = default;\n\n  MCSuperRegIterator(MCRegister Reg, const MCRegisterInfo *MCRI,\n                     bool IncludeSelf = false) {\n    init(Reg, MCRI->DiffLists + MCRI->get(Reg).SuperRegs);\n    // Initially, the iterator points to Reg itself.\n    if (!IncludeSelf)\n      ++*this;\n  }\n};\n\n// Definition for isSuperRegister. Put it down here since it needs the\n// iterator defined above in addition to the MCRegisterInfo class itself.\ninline bool MCRegisterInfo::isSuperRegister(MCRegister RegA, MCRegister RegB) const{\n  for (MCSuperRegIterator I(RegA, this); I.isValid(); ++I)\n    if (*I == RegB)\n      return true;\n  return false;\n}\n\n//===----------------------------------------------------------------------===//\n//                               Register Units\n//===----------------------------------------------------------------------===//\n\n// Register units are used to compute register aliasing. Every register has at\n// least one register unit, but it can have more. Two registers overlap if and\n// only if they have a common register unit.\n//\n// A target with a complicated sub-register structure will typically have many\n// fewer register units than actual registers. MCRI::getNumRegUnits() returns\n// the number of register units in the target.\n\n// MCRegUnitIterator enumerates a list of register units for Reg. The list is\n// in ascending numerical order.\nclass MCRegUnitIterator : public MCRegisterInfo::DiffListIterator {\npublic:\n  /// MCRegUnitIterator - Create an iterator that traverses the register units\n  /// in Reg.\n  MCRegUnitIterator() = default;\n\n  MCRegUnitIterator(MCRegister Reg, const MCRegisterInfo *MCRI) {\n    assert(Reg && \"Null register has no regunits\");\n    assert(MCRegister::isPhysicalRegister(Reg.id()));\n    // Decode the RegUnits MCRegisterDesc field.\n    unsigned RU = MCRI->get(Reg).RegUnits;\n    unsigned Scale = RU & 15;\n    unsigned Offset = RU >> 4;\n\n    // Initialize the iterator to Reg * Scale, and the List pointer to\n    // DiffLists + Offset.\n    init(Reg * Scale, MCRI->DiffLists + Offset);\n\n    // That may not be a valid unit, we need to advance by one to get the real\n    // unit number. The first differential can be 0 which would normally\n    // terminate the list, but since we know every register has at least one\n    // unit, we can allow a 0 differential here.\n    advance();\n  }\n};\n\n/// MCRegUnitMaskIterator enumerates a list of register units and their\n/// associated lane masks for Reg. The register units are in ascending\n/// numerical order.\nclass MCRegUnitMaskIterator {\n  MCRegUnitIterator RUIter;\n  const LaneBitmask *MaskListIter;\n\npublic:\n  MCRegUnitMaskIterator() = default;\n\n  /// Constructs an iterator that traverses the register units and their\n  /// associated LaneMasks in Reg.\n  MCRegUnitMaskIterator(MCRegister Reg, const MCRegisterInfo *MCRI)\n    : RUIter(Reg, MCRI) {\n      uint16_t Idx = MCRI->get(Reg).RegUnitLaneMasks;\n      MaskListIter = &MCRI->RegUnitMaskSequences[Idx];\n  }\n\n  /// Returns a (RegUnit, LaneMask) pair.\n  std::pair<unsigned,LaneBitmask> operator*() const {\n    return std::make_pair(*RUIter, *MaskListIter);\n  }\n\n  /// Returns true if this iterator is not yet at the end.\n  bool isValid() const { return RUIter.isValid(); }\n\n  /// Moves to the next position.\n  void operator++() {\n    ++MaskListIter;\n    ++RUIter;\n  }\n};\n\n// Each register unit has one or two root registers. The complete set of\n// registers containing a register unit is the union of the roots and their\n// super-registers. All registers aliasing Unit can be visited like this:\n//\n//   for (MCRegUnitRootIterator RI(Unit, MCRI); RI.isValid(); ++RI) {\n//     for (MCSuperRegIterator SI(*RI, MCRI, true); SI.isValid(); ++SI)\n//       visit(*SI);\n//    }\n\n/// MCRegUnitRootIterator enumerates the root registers of a register unit.\nclass MCRegUnitRootIterator {\n  uint16_t Reg0 = 0;\n  uint16_t Reg1 = 0;\n\npublic:\n  MCRegUnitRootIterator() = default;\n\n  MCRegUnitRootIterator(unsigned RegUnit, const MCRegisterInfo *MCRI) {\n    assert(RegUnit < MCRI->getNumRegUnits() && \"Invalid register unit\");\n    Reg0 = MCRI->RegUnitRoots[RegUnit][0];\n    Reg1 = MCRI->RegUnitRoots[RegUnit][1];\n  }\n\n  /// Dereference to get the current root register.\n  unsigned operator*() const {\n    return Reg0;\n  }\n\n  /// Check if the iterator is at the end of the list.\n  bool isValid() const {\n    return Reg0;\n  }\n\n  /// Preincrement to move to the next root register.\n  void operator++() {\n    assert(isValid() && \"Cannot move off the end of the list.\");\n    Reg0 = Reg1;\n    Reg1 = 0;\n  }\n};\n\n/// MCRegAliasIterator enumerates all registers aliasing Reg.  If IncludeSelf is\n/// set, Reg itself is included in the list.  This iterator does not guarantee\n/// any ordering or that entries are unique.\nclass MCRegAliasIterator {\nprivate:\n  MCRegister Reg;\n  const MCRegisterInfo *MCRI;\n  bool IncludeSelf;\n\n  MCRegUnitIterator RI;\n  MCRegUnitRootIterator RRI;\n  MCSuperRegIterator SI;\n\npublic:\n  MCRegAliasIterator(MCRegister Reg, const MCRegisterInfo *MCRI,\n                     bool IncludeSelf)\n    : Reg(Reg), MCRI(MCRI), IncludeSelf(IncludeSelf) {\n    // Initialize the iterators.\n    for (RI = MCRegUnitIterator(Reg, MCRI); RI.isValid(); ++RI) {\n      for (RRI = MCRegUnitRootIterator(*RI, MCRI); RRI.isValid(); ++RRI) {\n        for (SI = MCSuperRegIterator(*RRI, MCRI, true); SI.isValid(); ++SI) {\n          if (!(!IncludeSelf && Reg == *SI))\n            return;\n        }\n      }\n    }\n  }\n\n  bool isValid() const { return RI.isValid(); }\n\n  MCRegister operator*() const {\n    assert(SI.isValid() && \"Cannot dereference an invalid iterator.\");\n    return *SI;\n  }\n\n  void advance() {\n    // Assuming SI is valid.\n    ++SI;\n    if (SI.isValid()) return;\n\n    ++RRI;\n    if (RRI.isValid()) {\n      SI = MCSuperRegIterator(*RRI, MCRI, true);\n      return;\n    }\n\n    ++RI;\n    if (RI.isValid()) {\n      RRI = MCRegUnitRootIterator(*RI, MCRI);\n      SI = MCSuperRegIterator(*RRI, MCRI, true);\n    }\n  }\n\n  void operator++() {\n    assert(isValid() && \"Cannot move off the end of the list.\");\n    do advance();\n    while (!IncludeSelf && isValid() && *SI == Reg);\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_MC_MCREGISTERINFO_H\n"}, "48": {"id": 48, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCSchedule.h", "content": "//===-- llvm/MC/MCSchedule.h - Scheduling -----------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the classes used to describe a subtarget's machine model\n// for scheduling and other instruction cost heuristics.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_MCSCHEDULE_H\n#define LLVM_MC_MCSCHEDULE_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/Config/llvm-config.h\"\n#include \"llvm/Support/DataTypes.h\"\n#include <cassert>\n\nnamespace llvm {\n\ntemplate <typename T> class ArrayRef;\nstruct InstrItinerary;\nclass MCSubtargetInfo;\nclass MCInstrInfo;\nclass MCInst;\nclass InstrItineraryData;\n\n/// Define a kind of processor resource that will be modeled by the scheduler.\nstruct MCProcResourceDesc {\n  const char *Name;\n  unsigned NumUnits; // Number of resource of this kind\n  unsigned SuperIdx; // Index of the resources kind that contains this kind.\n\n  // Number of resources that may be buffered.\n  //\n  // Buffered resources (BufferSize != 0) may be consumed at some indeterminate\n  // cycle after dispatch. This should be used for out-of-order cpus when\n  // instructions that use this resource can be buffered in a reservaton\n  // station.\n  //\n  // Unbuffered resources (BufferSize == 0) always consume their resource some\n  // fixed number of cycles after dispatch. If a resource is unbuffered, then\n  // the scheduler will avoid scheduling instructions with conflicting resources\n  // in the same cycle. This is for in-order cpus, or the in-order portion of\n  // an out-of-order cpus.\n  int BufferSize;\n\n  // If the resource has sub-units, a pointer to the first element of an array\n  // of `NumUnits` elements containing the ProcResourceIdx of the sub units.\n  // nullptr if the resource does not have sub-units.\n  const unsigned *SubUnitsIdxBegin;\n\n  bool operator==(const MCProcResourceDesc &Other) const {\n    return NumUnits == Other.NumUnits && SuperIdx == Other.SuperIdx\n      && BufferSize == Other.BufferSize;\n  }\n};\n\n/// Identify one of the processor resource kinds consumed by a particular\n/// scheduling class for the specified number of cycles.\nstruct MCWriteProcResEntry {\n  uint16_t ProcResourceIdx;\n  uint16_t Cycles;\n\n  bool operator==(const MCWriteProcResEntry &Other) const {\n    return ProcResourceIdx == Other.ProcResourceIdx && Cycles == Other.Cycles;\n  }\n};\n\n/// Specify the latency in cpu cycles for a particular scheduling class and def\n/// index. -1 indicates an invalid latency. Heuristics would typically consider\n/// an instruction with invalid latency to have infinite latency.  Also identify\n/// the WriteResources of this def. When the operand expands to a sequence of\n/// writes, this ID is the last write in the sequence.\nstruct MCWriteLatencyEntry {\n  int16_t Cycles;\n  uint16_t WriteResourceID;\n\n  bool operator==(const MCWriteLatencyEntry &Other) const {\n    return Cycles == Other.Cycles && WriteResourceID == Other.WriteResourceID;\n  }\n};\n\n/// Specify the number of cycles allowed after instruction issue before a\n/// particular use operand reads its registers. This effectively reduces the\n/// write's latency. Here we allow negative cycles for corner cases where\n/// latency increases. This rule only applies when the entry's WriteResource\n/// matches the write's WriteResource.\n///\n/// MCReadAdvanceEntries are sorted first by operand index (UseIdx), then by\n/// WriteResourceIdx.\nstruct MCReadAdvanceEntry {\n  unsigned UseIdx;\n  unsigned WriteResourceID;\n  int Cycles;\n\n  bool operator==(const MCReadAdvanceEntry &Other) const {\n    return UseIdx == Other.UseIdx && WriteResourceID == Other.WriteResourceID\n      && Cycles == Other.Cycles;\n  }\n};\n\n/// Summarize the scheduling resources required for an instruction of a\n/// particular scheduling class.\n///\n/// Defined as an aggregate struct for creating tables with initializer lists.\nstruct MCSchedClassDesc {\n  static const unsigned short InvalidNumMicroOps = (1U << 13) - 1;\n  static const unsigned short VariantNumMicroOps = InvalidNumMicroOps - 1;\n\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n  const char* Name;\n#endif\n  uint16_t NumMicroOps : 13;\n  uint16_t BeginGroup : 1;\n  uint16_t EndGroup : 1;\n  uint16_t RetireOOO : 1;\n  uint16_t WriteProcResIdx; // First index into WriteProcResTable.\n  uint16_t NumWriteProcResEntries;\n  uint16_t WriteLatencyIdx; // First index into WriteLatencyTable.\n  uint16_t NumWriteLatencyEntries;\n  uint16_t ReadAdvanceIdx; // First index into ReadAdvanceTable.\n  uint16_t NumReadAdvanceEntries;\n\n  bool isValid() const {\n    return NumMicroOps != InvalidNumMicroOps;\n  }\n  bool isVariant() const {\n    return NumMicroOps == VariantNumMicroOps;\n  }\n};\n\n/// Specify the cost of a register definition in terms of number of physical\n/// register allocated at register renaming stage. For example, AMD Jaguar.\n/// natively supports 128-bit data types, and operations on 256-bit registers\n/// (i.e. YMM registers) are internally split into two COPs (complex operations)\n/// and each COP updates a physical register. Basically, on Jaguar, a YMM\n/// register write effectively consumes two physical registers. That means,\n/// the cost of a YMM write in the BtVer2 model is 2.\nstruct MCRegisterCostEntry {\n  unsigned RegisterClassID;\n  unsigned Cost;\n  bool AllowMoveElimination;\n};\n\n/// A register file descriptor.\n///\n/// This struct allows to describe processor register files. In particular, it\n/// helps describing the size of the register file, as well as the cost of\n/// allocating a register file at register renaming stage.\n/// FIXME: this struct can be extended to provide information about the number\n/// of read/write ports to the register file.  A value of zero for field\n/// 'NumPhysRegs' means: this register file has an unbounded number of physical\n/// registers.\nstruct MCRegisterFileDesc {\n  const char *Name;\n  uint16_t NumPhysRegs;\n  uint16_t NumRegisterCostEntries;\n  // Index of the first cost entry in MCExtraProcessorInfo::RegisterCostTable.\n  uint16_t RegisterCostEntryIdx;\n  // A value of zero means: there is no limit in the number of moves that can be\n  // eliminated every cycle.\n  uint16_t MaxMovesEliminatedPerCycle;\n  // Ture if this register file only knows how to optimize register moves from\n  // known zero registers.\n  bool AllowZeroMoveEliminationOnly;\n};\n\n/// Provide extra details about the machine processor.\n///\n/// This is a collection of \"optional\" processor information that is not\n/// normally used by the LLVM machine schedulers, but that can be consumed by\n/// external tools like llvm-mca to improve the quality of the peformance\n/// analysis.\nstruct MCExtraProcessorInfo {\n  // Actual size of the reorder buffer in hardware.\n  unsigned ReorderBufferSize;\n  // Number of instructions retired per cycle.\n  unsigned MaxRetirePerCycle;\n  const MCRegisterFileDesc *RegisterFiles;\n  unsigned NumRegisterFiles;\n  const MCRegisterCostEntry *RegisterCostTable;\n  unsigned NumRegisterCostEntries;\n  unsigned LoadQueueID;\n  unsigned StoreQueueID;\n};\n\n/// Machine model for scheduling, bundling, and heuristics.\n///\n/// The machine model directly provides basic information about the\n/// microarchitecture to the scheduler in the form of properties. It also\n/// optionally refers to scheduler resource tables and itinerary\n/// tables. Scheduler resource tables model the latency and cost for each\n/// instruction type. Itinerary tables are an independent mechanism that\n/// provides a detailed reservation table describing each cycle of instruction\n/// execution. Subtargets may define any or all of the above categories of data\n/// depending on the type of CPU and selected scheduler.\n///\n/// The machine independent properties defined here are used by the scheduler as\n/// an abstract machine model. A real micro-architecture has a number of\n/// buffers, queues, and stages. Declaring that a given machine-independent\n/// abstract property corresponds to a specific physical property across all\n/// subtargets can't be done. Nonetheless, the abstract model is\n/// useful. Futhermore, subtargets typically extend this model with processor\n/// specific resources to model any hardware features that can be exploited by\n/// scheduling heuristics and aren't sufficiently represented in the abstract.\n///\n/// The abstract pipeline is built around the notion of an \"issue point\". This\n/// is merely a reference point for counting machine cycles. The physical\n/// machine will have pipeline stages that delay execution. The scheduler does\n/// not model those delays because they are irrelevant as long as they are\n/// consistent. Inaccuracies arise when instructions have different execution\n/// delays relative to each other, in addition to their intrinsic latency. Those\n/// special cases can be handled by TableGen constructs such as, ReadAdvance,\n/// which reduces latency when reading data, and ResourceCycles, which consumes\n/// a processor resource when writing data for a number of abstract\n/// cycles.\n///\n/// TODO: One tool currently missing is the ability to add a delay to\n/// ResourceCycles. That would be easy to add and would likely cover all cases\n/// currently handled by the legacy itinerary tables.\n///\n/// A note on out-of-order execution and, more generally, instruction\n/// buffers. Part of the CPU pipeline is always in-order. The issue point, which\n/// is the point of reference for counting cycles, only makes sense as an\n/// in-order part of the pipeline. Other parts of the pipeline are sometimes\n/// falling behind and sometimes catching up. It's only interesting to model\n/// those other, decoupled parts of the pipeline if they may be predictably\n/// resource constrained in a way that the scheduler can exploit.\n///\n/// The LLVM machine model distinguishes between in-order constraints and\n/// out-of-order constraints so that the target's scheduling strategy can apply\n/// appropriate heuristics. For a well-balanced CPU pipeline, out-of-order\n/// resources would not typically be treated as a hard scheduling\n/// constraint. For example, in the GenericScheduler, a delay caused by limited\n/// out-of-order resources is not directly reflected in the number of cycles\n/// that the scheduler sees between issuing an instruction and its dependent\n/// instructions. In other words, out-of-order resources don't directly increase\n/// the latency between pairs of instructions. However, they can still be used\n/// to detect potential bottlenecks across a sequence of instructions and bias\n/// the scheduling heuristics appropriately.\nstruct MCSchedModel {\n  // IssueWidth is the maximum number of instructions that may be scheduled in\n  // the same per-cycle group. This is meant to be a hard in-order constraint\n  // (a.k.a. \"hazard\"). In the GenericScheduler strategy, no more than\n  // IssueWidth micro-ops can ever be scheduled in a particular cycle.\n  //\n  // In practice, IssueWidth is useful to model any bottleneck between the\n  // decoder (after micro-op expansion) and the out-of-order reservation\n  // stations or the decoder bandwidth itself. If the total number of\n  // reservation stations is also a bottleneck, or if any other pipeline stage\n  // has a bandwidth limitation, then that can be naturally modeled by adding an\n  // out-of-order processor resource.\n  unsigned IssueWidth;\n  static const unsigned DefaultIssueWidth = 1;\n\n  // MicroOpBufferSize is the number of micro-ops that the processor may buffer\n  // for out-of-order execution.\n  //\n  // \"0\" means operations that are not ready in this cycle are not considered\n  // for scheduling (they go in the pending queue). Latency is paramount. This\n  // may be more efficient if many instructions are pending in a schedule.\n  //\n  // \"1\" means all instructions are considered for scheduling regardless of\n  // whether they are ready in this cycle. Latency still causes issue stalls,\n  // but we balance those stalls against other heuristics.\n  //\n  // \"> 1\" means the processor is out-of-order. This is a machine independent\n  // estimate of highly machine specific characteristics such as the register\n  // renaming pool and reorder buffer.\n  unsigned MicroOpBufferSize;\n  static const unsigned DefaultMicroOpBufferSize = 0;\n\n  // LoopMicroOpBufferSize is the number of micro-ops that the processor may\n  // buffer for optimized loop execution. More generally, this represents the\n  // optimal number of micro-ops in a loop body. A loop may be partially\n  // unrolled to bring the count of micro-ops in the loop body closer to this\n  // number.\n  unsigned LoopMicroOpBufferSize;\n  static const unsigned DefaultLoopMicroOpBufferSize = 0;\n\n  // LoadLatency is the expected latency of load instructions.\n  unsigned LoadLatency;\n  static const unsigned DefaultLoadLatency = 4;\n\n  // HighLatency is the expected latency of \"very high latency\" operations.\n  // See TargetInstrInfo::isHighLatencyDef().\n  // By default, this is set to an arbitrarily high number of cycles\n  // likely to have some impact on scheduling heuristics.\n  unsigned HighLatency;\n  static const unsigned DefaultHighLatency = 10;\n\n  // MispredictPenalty is the typical number of extra cycles the processor\n  // takes to recover from a branch misprediction.\n  unsigned MispredictPenalty;\n  static const unsigned DefaultMispredictPenalty = 10;\n\n  bool PostRAScheduler; // default value is false\n\n  bool CompleteModel;\n\n  unsigned ProcID;\n  const MCProcResourceDesc *ProcResourceTable;\n  const MCSchedClassDesc *SchedClassTable;\n  unsigned NumProcResourceKinds;\n  unsigned NumSchedClasses;\n  // Instruction itinerary tables used by InstrItineraryData.\n  friend class InstrItineraryData;\n  const InstrItinerary *InstrItineraries;\n\n  const MCExtraProcessorInfo *ExtraProcessorInfo;\n\n  bool hasExtraProcessorInfo() const { return ExtraProcessorInfo; }\n\n  unsigned getProcessorID() const { return ProcID; }\n\n  /// Does this machine model include instruction-level scheduling.\n  bool hasInstrSchedModel() const { return SchedClassTable; }\n\n  const MCExtraProcessorInfo &getExtraProcessorInfo() const {\n    assert(hasExtraProcessorInfo() &&\n           \"No extra information available for this model\");\n    return *ExtraProcessorInfo;\n  }\n\n  /// Return true if this machine model data for all instructions with a\n  /// scheduling class (itinerary class or SchedRW list).\n  bool isComplete() const { return CompleteModel; }\n\n  /// Return true if machine supports out of order execution.\n  bool isOutOfOrder() const { return MicroOpBufferSize > 1; }\n\n  unsigned getNumProcResourceKinds() const {\n    return NumProcResourceKinds;\n  }\n\n  const MCProcResourceDesc *getProcResource(unsigned ProcResourceIdx) const {\n    assert(hasInstrSchedModel() && \"No scheduling machine model\");\n\n    assert(ProcResourceIdx < NumProcResourceKinds && \"bad proc resource idx\");\n    return &ProcResourceTable[ProcResourceIdx];\n  }\n\n  const MCSchedClassDesc *getSchedClassDesc(unsigned SchedClassIdx) const {\n    assert(hasInstrSchedModel() && \"No scheduling machine model\");\n\n    assert(SchedClassIdx < NumSchedClasses && \"bad scheduling class idx\");\n    return &SchedClassTable[SchedClassIdx];\n  }\n\n  /// Returns the latency value for the scheduling class.\n  static int computeInstrLatency(const MCSubtargetInfo &STI,\n                                 const MCSchedClassDesc &SCDesc);\n\n  int computeInstrLatency(const MCSubtargetInfo &STI, unsigned SClass) const;\n  int computeInstrLatency(const MCSubtargetInfo &STI, const MCInstrInfo &MCII,\n                          const MCInst &Inst) const;\n\n  // Returns the reciprocal throughput information from a MCSchedClassDesc.\n  static double\n  getReciprocalThroughput(const MCSubtargetInfo &STI,\n                          const MCSchedClassDesc &SCDesc);\n\n  static double\n  getReciprocalThroughput(unsigned SchedClass, const InstrItineraryData &IID);\n\n  double\n  getReciprocalThroughput(const MCSubtargetInfo &STI, const MCInstrInfo &MCII,\n                          const MCInst &Inst) const;\n\n  /// Returns the maximum forwarding delay for register reads dependent on\n  /// writes of scheduling class WriteResourceIdx.\n  static unsigned getForwardingDelayCycles(ArrayRef<MCReadAdvanceEntry> Entries,\n                                           unsigned WriteResourceIdx = 0);\n\n  /// Returns the default initialized model.\n  static const MCSchedModel &GetDefaultSchedModel() { return Default; }\n  static const MCSchedModel Default;\n};\n\n} // namespace llvm\n\n#endif\n"}, "49": {"id": 49, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h", "content": "//===- llvm/MC/MCSubtargetInfo.h - Subtarget Information --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file describes the subtarget options of a Target machine.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_MCSUBTARGETINFO_H\n#define LLVM_MC_MCSUBTARGETINFO_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/MC/MCInstrItineraries.h\"\n#include \"llvm/MC/MCSchedule.h\"\n#include \"llvm/MC/SubtargetFeature.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <string>\n\nnamespace llvm {\n\nclass MCInst;\n\n//===----------------------------------------------------------------------===//\n\n/// Used to provide key value pairs for feature and CPU bit flags.\nstruct SubtargetFeatureKV {\n  const char *Key;                      ///< K-V key string\n  const char *Desc;                     ///< Help descriptor\n  unsigned Value;                       ///< K-V integer value\n  FeatureBitArray Implies;              ///< K-V bit mask\n\n  /// Compare routine for std::lower_bound\n  bool operator<(StringRef S) const {\n    return StringRef(Key) < S;\n  }\n\n  /// Compare routine for std::is_sorted.\n  bool operator<(const SubtargetFeatureKV &Other) const {\n    return StringRef(Key) < StringRef(Other.Key);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n\n/// Used to provide key value pairs for feature and CPU bit flags.\nstruct SubtargetSubTypeKV {\n  const char *Key;                      ///< K-V key string\n  FeatureBitArray Implies;              ///< K-V bit mask\n  FeatureBitArray TuneImplies;          ///< K-V bit mask\n  const MCSchedModel *SchedModel;\n\n  /// Compare routine for std::lower_bound\n  bool operator<(StringRef S) const {\n    return StringRef(Key) < S;\n  }\n\n  /// Compare routine for std::is_sorted.\n  bool operator<(const SubtargetSubTypeKV &Other) const {\n    return StringRef(Key) < StringRef(Other.Key);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n///\n/// Generic base class for all target subtargets.\n///\nclass MCSubtargetInfo {\n  Triple TargetTriple;\n  std::string CPU; // CPU being targeted.\n  std::string TuneCPU; // CPU being tuned for.\n  ArrayRef<SubtargetFeatureKV> ProcFeatures;  // Processor feature list\n  ArrayRef<SubtargetSubTypeKV> ProcDesc;  // Processor descriptions\n\n  // Scheduler machine model\n  const MCWriteProcResEntry *WriteProcResTable;\n  const MCWriteLatencyEntry *WriteLatencyTable;\n  const MCReadAdvanceEntry *ReadAdvanceTable;\n  const MCSchedModel *CPUSchedModel;\n\n  const InstrStage *Stages;            // Instruction itinerary stages\n  const unsigned *OperandCycles;       // Itinerary operand cycles\n  const unsigned *ForwardingPaths;\n  FeatureBitset FeatureBits;           // Feature bits for current CPU + FS\n\npublic:\n  MCSubtargetInfo(const MCSubtargetInfo &) = default;\n  MCSubtargetInfo(const Triple &TT, StringRef CPU, StringRef TuneCPU,\n                  StringRef FS, ArrayRef<SubtargetFeatureKV> PF,\n                  ArrayRef<SubtargetSubTypeKV> PD,\n                  const MCWriteProcResEntry *WPR, const MCWriteLatencyEntry *WL,\n                  const MCReadAdvanceEntry *RA, const InstrStage *IS,\n                  const unsigned *OC, const unsigned *FP);\n  MCSubtargetInfo() = delete;\n  MCSubtargetInfo &operator=(const MCSubtargetInfo &) = delete;\n  MCSubtargetInfo &operator=(MCSubtargetInfo &&) = delete;\n  virtual ~MCSubtargetInfo() = default;\n\n  const Triple &getTargetTriple() const { return TargetTriple; }\n  StringRef getCPU() const { return CPU; }\n  StringRef getTuneCPU() const { return TuneCPU; }\n\n  const FeatureBitset& getFeatureBits() const { return FeatureBits; }\n  void setFeatureBits(const FeatureBitset &FeatureBits_) {\n    FeatureBits = FeatureBits_;\n  }\n\n  bool hasFeature(unsigned Feature) const {\n    return FeatureBits[Feature];\n  }\n\nprotected:\n  /// Initialize the scheduling model and feature bits.\n  ///\n  /// FIXME: Find a way to stick this in the constructor, since it should only\n  /// be called during initialization.\n  void InitMCProcessorInfo(StringRef CPU, StringRef TuneCPU, StringRef FS);\n\npublic:\n  /// Set the features to the default for the given CPU and TuneCPU, with ano\n  /// appended feature string.\n  void setDefaultFeatures(StringRef CPU, StringRef TuneCPU, StringRef FS);\n\n  /// Toggle a feature and return the re-computed feature bits.\n  /// This version does not change the implied bits.\n  FeatureBitset ToggleFeature(uint64_t FB);\n\n  /// Toggle a feature and return the re-computed feature bits.\n  /// This version does not change the implied bits.\n  FeatureBitset ToggleFeature(const FeatureBitset& FB);\n\n  /// Toggle a set of features and return the re-computed feature bits.\n  /// This version will also change all implied bits.\n  FeatureBitset ToggleFeature(StringRef FS);\n\n  /// Apply a feature flag and return the re-computed feature bits, including\n  /// all feature bits implied by the flag.\n  FeatureBitset ApplyFeatureFlag(StringRef FS);\n\n  /// Set/clear additional feature bits, including all other bits they imply.\n  FeatureBitset SetFeatureBitsTransitively(const FeatureBitset& FB);\n  FeatureBitset ClearFeatureBitsTransitively(const FeatureBitset &FB);\n\n  /// Check whether the subtarget features are enabled/disabled as per\n  /// the provided string, ignoring all other features.\n  bool checkFeatures(StringRef FS) const;\n\n  /// Get the machine model of a CPU.\n  const MCSchedModel &getSchedModelForCPU(StringRef CPU) const;\n\n  /// Get the machine model for this subtarget's CPU.\n  const MCSchedModel &getSchedModel() const { return *CPUSchedModel; }\n\n  /// Return an iterator at the first process resource consumed by the given\n  /// scheduling class.\n  const MCWriteProcResEntry *getWriteProcResBegin(\n    const MCSchedClassDesc *SC) const {\n    return &WriteProcResTable[SC->WriteProcResIdx];\n  }\n  const MCWriteProcResEntry *getWriteProcResEnd(\n    const MCSchedClassDesc *SC) const {\n    return getWriteProcResBegin(SC) + SC->NumWriteProcResEntries;\n  }\n\n  const MCWriteLatencyEntry *getWriteLatencyEntry(const MCSchedClassDesc *SC,\n                                                  unsigned DefIdx) const {\n    assert(DefIdx < SC->NumWriteLatencyEntries &&\n           \"MachineModel does not specify a WriteResource for DefIdx\");\n\n    return &WriteLatencyTable[SC->WriteLatencyIdx + DefIdx];\n  }\n\n  int getReadAdvanceCycles(const MCSchedClassDesc *SC, unsigned UseIdx,\n                           unsigned WriteResID) const {\n    // TODO: The number of read advance entries in a class can be significant\n    // (~50). Consider compressing the WriteID into a dense ID of those that are\n    // used by ReadAdvance and representing them as a bitset.\n    for (const MCReadAdvanceEntry *I = &ReadAdvanceTable[SC->ReadAdvanceIdx],\n           *E = I + SC->NumReadAdvanceEntries; I != E; ++I) {\n      if (I->UseIdx < UseIdx)\n        continue;\n      if (I->UseIdx > UseIdx)\n        break;\n      // Find the first WriteResIdx match, which has the highest cycle count.\n      if (!I->WriteResourceID || I->WriteResourceID == WriteResID) {\n        return I->Cycles;\n      }\n    }\n    return 0;\n  }\n\n  /// Return the set of ReadAdvance entries declared by the scheduling class\n  /// descriptor in input.\n  ArrayRef<MCReadAdvanceEntry>\n  getReadAdvanceEntries(const MCSchedClassDesc &SC) const {\n    if (!SC.NumReadAdvanceEntries)\n      return ArrayRef<MCReadAdvanceEntry>();\n    return ArrayRef<MCReadAdvanceEntry>(&ReadAdvanceTable[SC.ReadAdvanceIdx],\n                                        SC.NumReadAdvanceEntries);\n  }\n\n  /// Get scheduling itinerary of a CPU.\n  InstrItineraryData getInstrItineraryForCPU(StringRef CPU) const;\n\n  /// Initialize an InstrItineraryData instance.\n  void initInstrItins(InstrItineraryData &InstrItins) const;\n\n  /// Resolve a variant scheduling class for the given MCInst and CPU.\n  virtual unsigned resolveVariantSchedClass(unsigned SchedClass,\n                                            const MCInst *MI,\n                                            const MCInstrInfo *MCII,\n                                            unsigned CPUID) const {\n    return 0;\n  }\n\n  /// Check whether the CPU string is valid.\n  bool isCPUStringValid(StringRef CPU) const {\n    auto Found = llvm::lower_bound(ProcDesc, CPU);\n    return Found != ProcDesc.end() && StringRef(Found->Key) == CPU;\n  }\n\n  virtual unsigned getHwMode() const { return 0; }\n\n  /// Return the cache size in bytes for the given level of cache.\n  /// Level is zero-based, so a value of zero means the first level of\n  /// cache.\n  ///\n  virtual Optional<unsigned> getCacheSize(unsigned Level) const;\n\n  /// Return the cache associatvity for the given level of cache.\n  /// Level is zero-based, so a value of zero means the first level of\n  /// cache.\n  ///\n  virtual Optional<unsigned> getCacheAssociativity(unsigned Level) const;\n\n  /// Return the target cache line size in bytes at a given level.\n  ///\n  virtual Optional<unsigned> getCacheLineSize(unsigned Level) const;\n\n  /// Return the target cache line size in bytes.  By default, return\n  /// the line size for the bottom-most level of cache.  This provides\n  /// a more convenient interface for the common case where all cache\n  /// levels have the same line size.  Return zero if there is no\n  /// cache model.\n  ///\n  virtual unsigned getCacheLineSize() const {\n    Optional<unsigned> Size = getCacheLineSize(0);\n    if (Size)\n      return *Size;\n\n    return 0;\n  }\n\n  /// Return the preferred prefetch distance in terms of instructions.\n  ///\n  virtual unsigned getPrefetchDistance() const;\n\n  /// Return the maximum prefetch distance in terms of loop\n  /// iterations.\n  ///\n  virtual unsigned getMaxPrefetchIterationsAhead() const;\n\n  /// \\return True if prefetching should also be done for writes.\n  ///\n  virtual bool enableWritePrefetching() const;\n\n  /// Return the minimum stride necessary to trigger software\n  /// prefetching.\n  ///\n  virtual unsigned getMinPrefetchStride(unsigned NumMemAccesses,\n                                        unsigned NumStridedMemAccesses,\n                                        unsigned NumPrefetches,\n                                        bool HasCall) const;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_MC_MCSUBTARGETINFO_H\n"}, "50": {"id": 50, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCWinEH.h", "content": "//===- MCWinEH.h - Windows Unwinding Support --------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_MCWINEH_H\n#define LLVM_MC_MCWINEH_H\n\n#include \"llvm/ADT/MapVector.h\"\n#include <vector>\n\nnamespace llvm {\nclass MCSection;\nclass MCStreamer;\nclass MCSymbol;\n\nnamespace WinEH {\nstruct Instruction {\n  const MCSymbol *Label;\n  unsigned Offset;\n  unsigned Register;\n  unsigned Operation;\n\n  Instruction(unsigned Op, MCSymbol *L, unsigned Reg, unsigned Off)\n    : Label(L), Offset(Off), Register(Reg), Operation(Op) {}\n\n  bool operator==(const Instruction &I) const {\n    // Check whether two instructions refer to the same operation\n    // applied at a different spot (i.e. pointing at a different label).\n    return Offset == I.Offset && Register == I.Register &&\n           Operation == I.Operation;\n  }\n  bool operator!=(const Instruction &I) const { return !(*this == I); }\n};\n\nstruct FrameInfo {\n  const MCSymbol *Begin = nullptr;\n  const MCSymbol *End = nullptr;\n  const MCSymbol *FuncletOrFuncEnd = nullptr;\n  const MCSymbol *ExceptionHandler = nullptr;\n  const MCSymbol *Function = nullptr;\n  const MCSymbol *PrologEnd = nullptr;\n  const MCSymbol *Symbol = nullptr;\n  MCSection *TextSection = nullptr;\n  uint32_t PackedInfo = 0;\n\n  bool HandlesUnwind = false;\n  bool HandlesExceptions = false;\n  bool EmitAttempted = false;\n\n  int LastFrameInst = -1;\n  const FrameInfo *ChainedParent = nullptr;\n  std::vector<Instruction> Instructions;\n  MapVector<MCSymbol*, std::vector<Instruction>> EpilogMap;\n\n  FrameInfo() = default;\n  FrameInfo(const MCSymbol *Function, const MCSymbol *BeginFuncEHLabel)\n      : Begin(BeginFuncEHLabel), Function(Function) {}\n  FrameInfo(const MCSymbol *Function, const MCSymbol *BeginFuncEHLabel,\n            const FrameInfo *ChainedParent)\n      : Begin(BeginFuncEHLabel), Function(Function),\n        ChainedParent(ChainedParent) {}\n\n  bool empty() const {\n    if (!Instructions.empty())\n      return false;\n    for (const auto &E : EpilogMap)\n      if (!E.second.empty())\n        return false;\n    return true;\n  }\n};\n\nclass UnwindEmitter {\npublic:\n  virtual ~UnwindEmitter();\n\n  /// This emits the unwind info sections (.pdata and .xdata in PE/COFF).\n  virtual void Emit(MCStreamer &Streamer) const = 0;\n  virtual void EmitUnwindInfo(MCStreamer &Streamer, FrameInfo *FI,\n                              bool HandlerData) const = 0;\n};\n}\n}\n\n#endif\n"}, "51": {"id": 51, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MachineLocation.h", "content": "//===- llvm/MC/MachineLocation.h --------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n// The MachineLocation class is used to represent a simple location in a machine\n// frame.  Locations will be one of two forms; a register or an address formed\n// from a base address plus an offset.  Register indirection can be specified by\n// explicitly passing an offset to the constructor.\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_MACHINELOCATION_H\n#define LLVM_MC_MACHINELOCATION_H\n\n#include <cstdint>\n#include <cassert>\n\nnamespace llvm {\n\nclass MachineLocation {\nprivate:\n  bool IsRegister = false;              ///< True if location is a register.\n  unsigned Register = 0;                ///< gcc/gdb register number.\n\npublic:\n  enum : uint32_t {\n    // The target register number for an abstract frame pointer. The value is\n    // an arbitrary value that doesn't collide with any real target register.\n    VirtualFP = ~0U\n  };\n\n  MachineLocation() = default;\n  /// Create a direct register location.\n  explicit MachineLocation(unsigned R, bool Indirect = false)\n      : IsRegister(!Indirect), Register(R) {}\n\n  bool operator==(const MachineLocation &Other) const {\n    return IsRegister == Other.IsRegister && Register == Other.Register;\n  }\n\n  // Accessors.\n  /// \\return true iff this is a register-indirect location.\n  bool isIndirect()      const { return !IsRegister; }\n  bool isReg()           const { return IsRegister; }\n  unsigned getReg()      const { return Register; }\n  void setIsRegister(bool Is)  { IsRegister = Is; }\n  void setRegister(unsigned R) { Register = R; }\n};\n\ninline bool operator!=(const MachineLocation &LHS, const MachineLocation &RHS) {\n  return !(LHS == RHS);\n}\n\n} // end namespace llvm\n\n#endif // LLVM_MC_MACHINELOCATION_H\n"}, "55": {"id": 55, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BranchProbability.h", "content": "//===- BranchProbability.h - Branch Probability Wrapper ---------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Definition of BranchProbability shared by IR and Machine Instructions.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_BRANCHPROBABILITY_H\n#define LLVM_SUPPORT_BRANCHPROBABILITY_H\n\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Support/DataTypes.h\"\n#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <numeric>\n\nnamespace llvm {\n\nextern cl::opt<uint32_t> LikelyBranchWeight;\nextern cl::opt<uint32_t> UnlikelyBranchWeight;\n\nclass raw_ostream;\n\n// This class represents Branch Probability as a non-negative fraction that is\n// no greater than 1. It uses a fixed-point-like implementation, in which the\n// denominator is always a constant value (here we use 1<<31 for maximum\n// precision).\nclass BranchProbability {\n  // Numerator\n  uint32_t N;\n\n  // Denominator, which is a constant value.\n  static constexpr uint32_t D = 1u << 31;\n  static constexpr uint32_t UnknownN = UINT32_MAX;\n\n  // Construct a BranchProbability with only numerator assuming the denominator\n  // is 1<<31. For internal use only.\n  explicit BranchProbability(uint32_t n) : N(n) {}\n\npublic:\n  BranchProbability() : N(UnknownN) {}\n  BranchProbability(uint32_t Numerator, uint32_t Denominator);\n\n  bool isZero() const { return N == 0; }\n  bool isUnknown() const { return N == UnknownN; }\n\n  static BranchProbability getZero() { return BranchProbability(0); }\n  static BranchProbability getOne() { return BranchProbability(D); }\n  static BranchProbability getUnknown() { return BranchProbability(UnknownN); }\n  // Create a BranchProbability object with the given numerator and 1<<31\n  // as denominator.\n  static BranchProbability getRaw(uint32_t N) { return BranchProbability(N); }\n  // Create a BranchProbability object from 64-bit integers.\n  static BranchProbability getBranchProbability(uint64_t Numerator,\n                                                uint64_t Denominator);\n\n  // Normalize given probabilties so that the sum of them becomes approximate\n  // one.\n  template <class ProbabilityIter>\n  static void normalizeProbabilities(ProbabilityIter Begin,\n                                     ProbabilityIter End);\n\n  uint32_t getNumerator() const { return N; }\n  static uint32_t getDenominator() { return D; }\n\n  // Return (1 - Probability).\n  BranchProbability getCompl() const { return BranchProbability(D - N); }\n\n  raw_ostream &print(raw_ostream &OS) const;\n\n  void dump() const;\n\n  /// Scale a large integer.\n  ///\n  /// Scales \\c Num.  Guarantees full precision.  Returns the floor of the\n  /// result.\n  ///\n  /// \\return \\c Num times \\c this.\n  uint64_t scale(uint64_t Num) const;\n\n  /// Scale a large integer by the inverse.\n  ///\n  /// Scales \\c Num by the inverse of \\c this.  Guarantees full precision.\n  /// Returns the floor of the result.\n  ///\n  /// \\return \\c Num divided by \\c this.\n  uint64_t scaleByInverse(uint64_t Num) const;\n\n  BranchProbability &operator+=(BranchProbability RHS) {\n    assert(N != UnknownN && RHS.N != UnknownN &&\n           \"Unknown probability cannot participate in arithmetics.\");\n    // Saturate the result in case of overflow.\n    N = (uint64_t(N) + RHS.N > D) ? D : N + RHS.N;\n    return *this;\n  }\n\n  BranchProbability &operator-=(BranchProbability RHS) {\n    assert(N != UnknownN && RHS.N != UnknownN &&\n           \"Unknown probability cannot participate in arithmetics.\");\n    // Saturate the result in case of underflow.\n    N = N < RHS.N ? 0 : N - RHS.N;\n    return *this;\n  }\n\n  BranchProbability &operator*=(BranchProbability RHS) {\n    assert(N != UnknownN && RHS.N != UnknownN &&\n           \"Unknown probability cannot participate in arithmetics.\");\n    N = (static_cast<uint64_t>(N) * RHS.N + D / 2) / D;\n    return *this;\n  }\n\n  BranchProbability &operator*=(uint32_t RHS) {\n    assert(N != UnknownN &&\n           \"Unknown probability cannot participate in arithmetics.\");\n    N = (uint64_t(N) * RHS > D) ? D : N * RHS;\n    return *this;\n  }\n\n  BranchProbability &operator/=(BranchProbability RHS) {\n    assert(N != UnknownN && RHS.N != UnknownN &&\n           \"Unknown probability cannot participate in arithmetics.\");\n    N = (static_cast<uint64_t>(N) * D + RHS.N / 2) / RHS.N;\n    return *this;\n  }\n\n  BranchProbability &operator/=(uint32_t RHS) {\n    assert(N != UnknownN &&\n           \"Unknown probability cannot participate in arithmetics.\");\n    assert(RHS > 0 && \"The divider cannot be zero.\");\n    N /= RHS;\n    return *this;\n  }\n\n  BranchProbability operator+(BranchProbability RHS) const {\n    BranchProbability Prob(*this);\n    Prob += RHS;\n    return Prob;\n  }\n\n  BranchProbability operator-(BranchProbability RHS) const {\n    BranchProbability Prob(*this);\n    Prob -= RHS;\n    return Prob;\n  }\n\n  BranchProbability operator*(BranchProbability RHS) const {\n    BranchProbability Prob(*this);\n    Prob *= RHS;\n    return Prob;\n  }\n\n  BranchProbability operator*(uint32_t RHS) const {\n    BranchProbability Prob(*this);\n    Prob *= RHS;\n    return Prob;\n  }\n\n  BranchProbability operator/(BranchProbability RHS) const {\n    BranchProbability Prob(*this);\n    Prob /= RHS;\n    return Prob;\n  }\n\n  BranchProbability operator/(uint32_t RHS) const {\n    BranchProbability Prob(*this);\n    Prob /= RHS;\n    return Prob;\n  }\n\n  bool operator==(BranchProbability RHS) const { return N == RHS.N; }\n  bool operator!=(BranchProbability RHS) const { return !(*this == RHS); }\n\n  bool operator<(BranchProbability RHS) const {\n    assert(N != UnknownN && RHS.N != UnknownN &&\n           \"Unknown probability cannot participate in comparisons.\");\n    return N < RHS.N;\n  }\n\n  bool operator>(BranchProbability RHS) const {\n    assert(N != UnknownN && RHS.N != UnknownN &&\n           \"Unknown probability cannot participate in comparisons.\");\n    return RHS < *this;\n  }\n\n  bool operator<=(BranchProbability RHS) const {\n    assert(N != UnknownN && RHS.N != UnknownN &&\n           \"Unknown probability cannot participate in comparisons.\");\n    return !(RHS < *this);\n  }\n\n  bool operator>=(BranchProbability RHS) const {\n    assert(N != UnknownN && RHS.N != UnknownN &&\n           \"Unknown probability cannot participate in comparisons.\");\n    return !(*this < RHS);\n  }\n};\n\ninline raw_ostream &operator<<(raw_ostream &OS, BranchProbability Prob) {\n  return Prob.print(OS);\n}\n\ntemplate <class ProbabilityIter>\nvoid BranchProbability::normalizeProbabilities(ProbabilityIter Begin,\n                                               ProbabilityIter End) {\n  if (Begin == End)\n    return;\n\n  unsigned UnknownProbCount = 0;\n  uint64_t Sum = std::accumulate(Begin, End, uint64_t(0),\n                                 [&](uint64_t S, const BranchProbability &BP) {\n                                   if (!BP.isUnknown())\n                                     return S + BP.N;\n                                   UnknownProbCount++;\n                                   return S;\n                                 });\n\n  if (UnknownProbCount > 0) {\n    BranchProbability ProbForUnknown = BranchProbability::getZero();\n    // If the sum of all known probabilities is less than one, evenly distribute\n    // the complement of sum to unknown probabilities. Otherwise, set unknown\n    // probabilities to zeros and continue to normalize known probabilities.\n    if (Sum < BranchProbability::getDenominator())\n      ProbForUnknown = BranchProbability::getRaw(\n          (BranchProbability::getDenominator() - Sum) / UnknownProbCount);\n\n    std::replace_if(Begin, End,\n                    [](const BranchProbability &BP) { return BP.isUnknown(); },\n                    ProbForUnknown);\n\n    if (Sum <= BranchProbability::getDenominator())\n      return;\n  }\n\n  if (Sum == 0) {\n    BranchProbability BP(1, std::distance(Begin, End));\n    std::fill(Begin, End, BP);\n    return;\n  }\n\n  for (auto I = Begin; I != End; ++I)\n    I->N = (I->N * uint64_t(D) + Sum / 2) / Sum;\n}\n\n}\n\n#endif\n"}, "59": {"id": 59, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/LowLevelTypeImpl.h", "content": "//== llvm/Support/LowLevelTypeImpl.h --------------------------- -*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// Implement a low-level type suitable for MachineInstr level instruction\n/// selection.\n///\n/// For a type attached to a MachineInstr, we only care about 2 details: total\n/// size and the number of vector lanes (if any). Accordingly, there are 4\n/// possible valid type-kinds:\n///\n///    * `sN` for scalars and aggregates\n///    * `<N x sM>` for vectors, which must have at least 2 elements.\n///    * `pN` for pointers\n///\n/// Other information required for correct selection is expected to be carried\n/// by the opcode, or non-type flags. For example the distinction between G_ADD\n/// and G_FADD for int/float or fast-math flags.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_LOWLEVELTYPEIMPL_H\n#define LLVM_SUPPORT_LOWLEVELTYPEIMPL_H\n\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/MachineValueType.h\"\n#include <cassert>\n\nnamespace llvm {\n\nclass DataLayout;\nclass Type;\nclass raw_ostream;\n\nclass LLT {\npublic:\n  /// Get a low-level scalar or aggregate \"bag of bits\".\n  static LLT scalar(unsigned SizeInBits) {\n    assert(SizeInBits > 0 && \"invalid scalar size\");\n    return LLT{/*isPointer=*/false, /*isVector=*/false, /*NumElements=*/0,\n               SizeInBits, /*AddressSpace=*/0};\n  }\n\n  /// Get a low-level pointer in the given address space.\n  static LLT pointer(unsigned AddressSpace, unsigned SizeInBits) {\n    assert(SizeInBits > 0 && \"invalid pointer size\");\n    return LLT{/*isPointer=*/true, /*isVector=*/false, /*NumElements=*/0,\n               SizeInBits, AddressSpace};\n  }\n\n  /// Get a low-level vector of some number of elements and element width.\n  /// \\p NumElements must be at least 2.\n  static LLT vector(uint16_t NumElements, unsigned ScalarSizeInBits) {\n    assert(NumElements > 1 && \"invalid number of vector elements\");\n    assert(ScalarSizeInBits > 0 && \"invalid vector element size\");\n    return LLT{/*isPointer=*/false, /*isVector=*/true, NumElements,\n               ScalarSizeInBits, /*AddressSpace=*/0};\n  }\n\n  /// Get a low-level vector of some number of elements and element type.\n  static LLT vector(uint16_t NumElements, LLT ScalarTy) {\n    assert(NumElements > 1 && \"invalid number of vector elements\");\n    assert(!ScalarTy.isVector() && \"invalid vector element type\");\n    return LLT{ScalarTy.isPointer(), /*isVector=*/true, NumElements,\n               ScalarTy.getSizeInBits(),\n               ScalarTy.isPointer() ? ScalarTy.getAddressSpace() : 0};\n  }\n\n  static LLT scalarOrVector(uint16_t NumElements, LLT ScalarTy) {\n    return NumElements == 1 ? ScalarTy : LLT::vector(NumElements, ScalarTy);\n  }\n\n  static LLT scalarOrVector(uint16_t NumElements, unsigned ScalarSize) {\n    return scalarOrVector(NumElements, LLT::scalar(ScalarSize));\n  }\n\n  explicit LLT(bool isPointer, bool isVector, uint16_t NumElements,\n               unsigned SizeInBits, unsigned AddressSpace) {\n    init(isPointer, isVector, NumElements, SizeInBits, AddressSpace);\n  }\n  explicit LLT() : IsPointer(false), IsVector(false), RawData(0) {}\n\n  explicit LLT(MVT VT);\n\n  bool isValid() const { return RawData != 0; }\n\n  bool isScalar() const { return isValid() && !IsPointer && !IsVector; }\n\n  bool isPointer() const { return isValid() && IsPointer && !IsVector; }\n\n  bool isVector() const { return isValid() && IsVector; }\n\n  /// Returns the number of elements in a vector LLT. Must only be called on\n  /// vector types.\n  uint16_t getNumElements() const {\n    assert(IsVector && \"cannot get number of elements on scalar/aggregate\");\n    if (!IsPointer)\n      return getFieldValue(VectorElementsFieldInfo);\n    else\n      return getFieldValue(PointerVectorElementsFieldInfo);\n  }\n\n  /// Returns the total size of the type. Must only be called on sized types.\n  unsigned getSizeInBits() const {\n    if (isPointer() || isScalar())\n      return getScalarSizeInBits();\n    return getScalarSizeInBits() * getNumElements();\n  }\n\n  /// Returns the total size of the type in bytes, i.e. number of whole bytes\n  /// needed to represent the size in bits. Must only be called on sized types.\n  unsigned getSizeInBytes() const {\n    return (getSizeInBits() + 7) / 8;\n  }\n\n  LLT getScalarType() const {\n    return isVector() ? getElementType() : *this;\n  }\n\n  /// If this type is a vector, return a vector with the same number of elements\n  /// but the new element type. Otherwise, return the new element type.\n  LLT changeElementType(LLT NewEltTy) const {\n    return isVector() ? LLT::vector(getNumElements(), NewEltTy) : NewEltTy;\n  }\n\n  /// If this type is a vector, return a vector with the same number of elements\n  /// but the new element size. Otherwise, return the new element type. Invalid\n  /// for pointer types. For pointer types, use changeElementType.\n  LLT changeElementSize(unsigned NewEltSize) const {\n    assert(!getScalarType().isPointer() &&\n           \"invalid to directly change element size for pointers\");\n    return isVector() ? LLT::vector(getNumElements(), NewEltSize)\n                      : LLT::scalar(NewEltSize);\n  }\n\n  /// Return a vector or scalar with the same element type and the new number of\n  /// elements.\n  LLT changeNumElements(unsigned NewNumElts) const {\n    return LLT::scalarOrVector(NewNumElts, getScalarType());\n  }\n\n  /// Return a type that is \\p Factor times smaller. Reduces the number of\n  /// elements if this is a vector, or the bitwidth for scalar/pointers. Does\n  /// not attempt to handle cases that aren't evenly divisible.\n  LLT divide(int Factor) const {\n    assert(Factor != 1);\n    if (isVector()) {\n      assert(getNumElements() % Factor == 0);\n      return scalarOrVector(getNumElements() / Factor, getElementType());\n    }\n\n    assert(getSizeInBits() % Factor == 0);\n    return scalar(getSizeInBits() / Factor);\n  }\n\n  bool isByteSized() const { return (getSizeInBits() & 7) == 0; }\n\n  unsigned getScalarSizeInBits() const {\n    assert(RawData != 0 && \"Invalid Type\");\n    if (!IsVector) {\n      if (!IsPointer)\n        return getFieldValue(ScalarSizeFieldInfo);\n      else\n        return getFieldValue(PointerSizeFieldInfo);\n    } else {\n      if (!IsPointer)\n        return getFieldValue(VectorSizeFieldInfo);\n      else\n        return getFieldValue(PointerVectorSizeFieldInfo);\n    }\n  }\n\n  unsigned getAddressSpace() const {\n    assert(RawData != 0 && \"Invalid Type\");\n    assert(IsPointer && \"cannot get address space of non-pointer type\");\n    if (!IsVector)\n      return getFieldValue(PointerAddressSpaceFieldInfo);\n    else\n      return getFieldValue(PointerVectorAddressSpaceFieldInfo);\n  }\n\n  /// Returns the vector's element type. Only valid for vector types.\n  LLT getElementType() const {\n    assert(isVector() && \"cannot get element type of scalar/aggregate\");\n    if (IsPointer)\n      return pointer(getAddressSpace(), getScalarSizeInBits());\n    else\n      return scalar(getScalarSizeInBits());\n  }\n\n  void print(raw_ostream &OS) const;\n\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n  LLVM_DUMP_METHOD void dump() const {\n    print(dbgs());\n    dbgs() << '\\n';\n  }\n#endif\n\n  bool operator==(const LLT &RHS) const {\n    return IsPointer == RHS.IsPointer && IsVector == RHS.IsVector &&\n           RHS.RawData == RawData;\n  }\n\n  bool operator!=(const LLT &RHS) const { return !(*this == RHS); }\n\n  friend struct DenseMapInfo<LLT>;\n  friend class GISelInstProfileBuilder;\n\nprivate:\n  /// LLT is packed into 64 bits as follows:\n  /// isPointer : 1\n  /// isVector  : 1\n  /// with 62 bits remaining for Kind-specific data, packed in bitfields\n  /// as described below. As there isn't a simple portable way to pack bits\n  /// into bitfields, here the different fields in the packed structure is\n  /// described in static const *Field variables. Each of these variables\n  /// is a 2-element array, with the first element describing the bitfield size\n  /// and the second element describing the bitfield offset.\n  typedef int BitFieldInfo[2];\n  ///\n  /// This is how the bitfields are packed per Kind:\n  /// * Invalid:\n  ///   gets encoded as RawData == 0, as that is an invalid encoding, since for\n  ///   valid encodings, SizeInBits/SizeOfElement must be larger than 0.\n  /// * Non-pointer scalar (isPointer == 0 && isVector == 0):\n  ///   SizeInBits: 32;\n  static const constexpr BitFieldInfo ScalarSizeFieldInfo{32, 0};\n  /// * Pointer (isPointer == 1 && isVector == 0):\n  ///   SizeInBits: 16;\n  ///   AddressSpace: 24;\n  static const constexpr BitFieldInfo PointerSizeFieldInfo{16, 0};\n  static const constexpr BitFieldInfo PointerAddressSpaceFieldInfo{\n      24, PointerSizeFieldInfo[0] + PointerSizeFieldInfo[1]};\n  /// * Vector-of-non-pointer (isPointer == 0 && isVector == 1):\n  ///   NumElements: 16;\n  ///   SizeOfElement: 32;\n  static const constexpr BitFieldInfo VectorElementsFieldInfo{16, 0};\n  static const constexpr BitFieldInfo VectorSizeFieldInfo{\n      32, VectorElementsFieldInfo[0] + VectorElementsFieldInfo[1]};\n  /// * Vector-of-pointer (isPointer == 1 && isVector == 1):\n  ///   NumElements: 16;\n  ///   SizeOfElement: 16;\n  ///   AddressSpace: 24;\n  static const constexpr BitFieldInfo PointerVectorElementsFieldInfo{16, 0};\n  static const constexpr BitFieldInfo PointerVectorSizeFieldInfo{\n      16,\n      PointerVectorElementsFieldInfo[1] + PointerVectorElementsFieldInfo[0]};\n  static const constexpr BitFieldInfo PointerVectorAddressSpaceFieldInfo{\n      24, PointerVectorSizeFieldInfo[1] + PointerVectorSizeFieldInfo[0]};\n\n  uint64_t IsPointer : 1;\n  uint64_t IsVector : 1;\n  uint64_t RawData : 62;\n\n  static uint64_t getMask(const BitFieldInfo FieldInfo) {\n    const int FieldSizeInBits = FieldInfo[0];\n    return (((uint64_t)1) << FieldSizeInBits) - 1;\n  }\n  static uint64_t maskAndShift(uint64_t Val, uint64_t Mask, uint8_t Shift) {\n    assert(Val <= Mask && \"Value too large for field\");\n    return (Val & Mask) << Shift;\n  }\n  static uint64_t maskAndShift(uint64_t Val, const BitFieldInfo FieldInfo) {\n    return maskAndShift(Val, getMask(FieldInfo), FieldInfo[1]);\n  }\n  uint64_t getFieldValue(const BitFieldInfo FieldInfo) const {\n    return getMask(FieldInfo) & (RawData >> FieldInfo[1]);\n  }\n\n  void init(bool IsPointer, bool IsVector, uint16_t NumElements,\n            unsigned SizeInBits, unsigned AddressSpace) {\n    this->IsPointer = IsPointer;\n    this->IsVector = IsVector;\n    if (!IsVector) {\n      if (!IsPointer)\n        RawData = maskAndShift(SizeInBits, ScalarSizeFieldInfo);\n      else\n        RawData = maskAndShift(SizeInBits, PointerSizeFieldInfo) |\n                  maskAndShift(AddressSpace, PointerAddressSpaceFieldInfo);\n    } else {\n      assert(NumElements > 1 && \"invalid number of vector elements\");\n      if (!IsPointer)\n        RawData = maskAndShift(NumElements, VectorElementsFieldInfo) |\n                  maskAndShift(SizeInBits, VectorSizeFieldInfo);\n      else\n        RawData =\n            maskAndShift(NumElements, PointerVectorElementsFieldInfo) |\n            maskAndShift(SizeInBits, PointerVectorSizeFieldInfo) |\n            maskAndShift(AddressSpace, PointerVectorAddressSpaceFieldInfo);\n    }\n  }\n\n  uint64_t getUniqueRAWLLTData() const {\n    return ((uint64_t)RawData) << 2 | ((uint64_t)IsPointer) << 1 |\n           ((uint64_t)IsVector);\n  }\n};\n\ninline raw_ostream& operator<<(raw_ostream &OS, const LLT &Ty) {\n  Ty.print(OS);\n  return OS;\n}\n\ntemplate<> struct DenseMapInfo<LLT> {\n  static inline LLT getEmptyKey() {\n    LLT Invalid;\n    Invalid.IsPointer = true;\n    return Invalid;\n  }\n  static inline LLT getTombstoneKey() {\n    LLT Invalid;\n    Invalid.IsVector = true;\n    return Invalid;\n  }\n  static inline unsigned getHashValue(const LLT &Ty) {\n    uint64_t Val = Ty.getUniqueRAWLLTData();\n    return DenseMapInfo<uint64_t>::getHashValue(Val);\n  }\n  static bool isEqual(const LLT &LHS, const LLT &RHS) {\n    return LHS == RHS;\n  }\n};\n\n}\n\n#endif // LLVM_SUPPORT_LOWLEVELTYPEIMPL_H\n"}, "61": {"id": 61, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/MachineValueType.h", "content": "//===- Support/MachineValueType.h - Machine-Level types ---------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the set of machine-level target independent types which\n// legal values in the code generator use.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_MACHINEVALUETYPE_H\n#define LLVM_SUPPORT_MACHINEVALUETYPE_H\n\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/TypeSize.h\"\n#include <cassert>\n\nnamespace llvm {\n\n  class Type;\n\n  /// Machine Value Type. Every type that is supported natively by some\n  /// processor targeted by LLVM occurs here. This means that any legal value\n  /// type can be represented by an MVT.\n  class MVT {\n  public:\n    enum SimpleValueType : uint8_t {\n      // Simple value types that aren't explicitly part of this enumeration\n      // are considered extended value types.\n      INVALID_SIMPLE_VALUE_TYPE = 0,\n\n      // If you change this numbering, you must change the values in\n      // ValueTypes.td as well!\n      Other          =   1,   // This is a non-standard value\n      i1             =   2,   // This is a 1 bit integer value\n      i8             =   3,   // This is an 8 bit integer value\n      i16            =   4,   // This is a 16 bit integer value\n      i32            =   5,   // This is a 32 bit integer value\n      i64            =   6,   // This is a 64 bit integer value\n      i128           =   7,   // This is a 128 bit integer value\n\n      FIRST_INTEGER_VALUETYPE = i1,\n      LAST_INTEGER_VALUETYPE  = i128,\n\n      bf16           =   8,   // This is a 16 bit brain floating point value\n      f16            =   9,   // This is a 16 bit floating point value\n      f32            =  10,   // This is a 32 bit floating point value\n      f64            =  11,   // This is a 64 bit floating point value\n      f80            =  12,   // This is a 80 bit floating point value\n      f128           =  13,   // This is a 128 bit floating point value\n      ppcf128        =  14,   // This is a PPC 128-bit floating point value\n\n      FIRST_FP_VALUETYPE = bf16,\n      LAST_FP_VALUETYPE  = ppcf128,\n\n      v1i1           =  15,   //    1 x i1\n      v2i1           =  16,   //    2 x i1\n      v4i1           =  17,   //    4 x i1\n      v8i1           =  18,   //    8 x i1\n      v16i1          =  19,   //   16 x i1\n      v32i1          =  20,   //   32 x i1\n      v64i1          =  21,   //   64 x i1\n      v128i1         =  22,   //  128 x i1\n      v256i1         =  23,   //  256 x i1\n      v512i1         =  24,   //  512 x i1\n      v1024i1        =  25,   // 1024 x i1\n\n      v1i8           =  26,   //   1 x i8\n      v2i8           =  27,   //   2 x i8\n      v4i8           =  28,   //   4 x i8\n      v8i8           =  29,   //   8 x i8\n      v16i8          =  30,   //  16 x i8\n      v32i8          =  31,   //  32 x i8\n      v64i8          =  32,   //  64 x i8\n      v128i8         =  33,   // 128 x i8\n      v256i8         =  34,   // 256 x i8\n\n      v1i16          =  35,   //   1 x i16\n      v2i16          =  36,   //   2 x i16\n      v3i16          =  37,   //   3 x i16\n      v4i16          =  38,   //   4 x i16\n      v8i16          =  39,   //   8 x i16\n      v16i16         =  40,   //  16 x i16\n      v32i16         =  41,   //  32 x i16\n      v64i16         =  42,   //  64 x i16\n      v128i16        =  43,   // 128 x i16\n\n      v1i32          =  44,   //    1 x i32\n      v2i32          =  45,   //    2 x i32\n      v3i32          =  46,   //    3 x i32\n      v4i32          =  47,   //    4 x i32\n      v5i32          =  48,   //    5 x i32\n      v8i32          =  49,   //    8 x i32\n      v16i32         =  50,   //   16 x i32\n      v32i32         =  51,   //   32 x i32\n      v64i32         =  52,   //   64 x i32\n      v128i32        =  53,   //  128 x i32\n      v256i32        =  54,   //  256 x i32\n      v512i32        =  55,   //  512 x i32\n      v1024i32       =  56,   // 1024 x i32\n      v2048i32       =  57,   // 2048 x i32\n\n      v1i64          =  58,   //   1 x i64\n      v2i64          =  59,   //   2 x i64\n      v4i64          =  60,   //   4 x i64\n      v8i64          =  61,   //   8 x i64\n      v16i64         =  62,   //  16 x i64\n      v32i64         =  63,   //  32 x i64\n      v64i64         =  64,   //  64 x i64\n      v128i64        =  65,   // 128 x i64\n      v256i64        =  66,   // 256 x i64\n\n      v1i128         =  67,   //  1 x i128\n\n      FIRST_INTEGER_FIXEDLEN_VECTOR_VALUETYPE = v1i1,\n      LAST_INTEGER_FIXEDLEN_VECTOR_VALUETYPE = v1i128,\n\n      v1f16          =  68,   //    1 x f16\n      v2f16          =  69,   //    2 x f16\n      v3f16          =  70,   //    3 x f16\n      v4f16          =  71,   //    4 x f16\n      v8f16          =  72,   //    8 x f16\n      v16f16         =  73,   //   16 x f16\n      v32f16         =  74,   //   32 x f16\n      v64f16         =  75,   //   64 x f16\n      v128f16        =  76,   //  128 x f16\n      v2bf16         =  77,   //    2 x bf16\n      v3bf16         =  78,   //    3 x bf16\n      v4bf16         =  79,   //    4 x bf16\n      v8bf16         =  80,   //    8 x bf16\n      v16bf16        =  81,   //   16 x bf16\n      v32bf16        =  82,   //   32 x bf16\n      v64bf16        =  83,   //   64 x bf16\n      v128bf16       =  84,   //  128 x bf16\n      v1f32          =  85,   //    1 x f32\n      v2f32          =  86,   //    2 x f32\n      v3f32          =  87,   //    3 x f32\n      v4f32          =  88,   //    4 x f32\n      v5f32          =  89,   //    5 x f32\n      v8f32          =  90,   //    8 x f32\n      v16f32         =  91,   //   16 x f32\n      v32f32         =  92,   //   32 x f32\n      v64f32         =  93,   //   64 x f32\n      v128f32        =  94,   //  128 x f32\n      v256f32        =  95,   //  256 x f32\n      v512f32        =  96,   //  512 x f32\n      v1024f32       =  97,   // 1024 x f32\n      v2048f32       =  98,   // 2048 x f32\n      v1f64          =  99,   //    1 x f64\n      v2f64          = 100,   //    2 x f64\n      v4f64          = 101,   //    4 x f64\n      v8f64          = 102,   //    8 x f64\n      v16f64         = 103,   //   16 x f64\n      v32f64         = 104,   //   32 x f64\n      v64f64         = 105,   //   64 x f64\n      v128f64        = 106,   //  128 x f64\n      v256f64        = 107,   //  256 x f64\n\n      FIRST_FP_FIXEDLEN_VECTOR_VALUETYPE = v1f16,\n      LAST_FP_FIXEDLEN_VECTOR_VALUETYPE = v256f64,\n\n      FIRST_FIXEDLEN_VECTOR_VALUETYPE = v1i1,\n      LAST_FIXEDLEN_VECTOR_VALUETYPE = v256f64,\n\n      nxv1i1         = 108,   // n x  1 x i1\n      nxv2i1         = 109,   // n x  2 x i1\n      nxv4i1         = 110,   // n x  4 x i1\n      nxv8i1         = 111,   // n x  8 x i1\n      nxv16i1        = 112,   // n x 16 x i1\n      nxv32i1        = 113,   // n x 32 x i1\n      nxv64i1        = 114,   // n x 64 x i1\n\n      nxv1i8         = 115,   // n x  1 x i8\n      nxv2i8         = 116,   // n x  2 x i8\n      nxv4i8         = 117,   // n x  4 x i8\n      nxv8i8         = 118,   // n x  8 x i8\n      nxv16i8        = 119,   // n x 16 x i8\n      nxv32i8        = 120,   // n x 32 x i8\n      nxv64i8        = 121,   // n x 64 x i8\n\n      nxv1i16        = 122,  // n x  1 x i16\n      nxv2i16        = 123,  // n x  2 x i16\n      nxv4i16        = 124,  // n x  4 x i16\n      nxv8i16        = 125,  // n x  8 x i16\n      nxv16i16       = 126,  // n x 16 x i16\n      nxv32i16       = 127,  // n x 32 x i16\n\n      nxv1i32        = 128,  // n x  1 x i32\n      nxv2i32        = 129,  // n x  2 x i32\n      nxv4i32        = 130,  // n x  4 x i32\n      nxv8i32        = 131,  // n x  8 x i32\n      nxv16i32       = 132,  // n x 16 x i32\n      nxv32i32       = 133,  // n x 32 x i32\n\n      nxv1i64        = 134,  // n x  1 x i64\n      nxv2i64        = 135,  // n x  2 x i64\n      nxv4i64        = 136,  // n x  4 x i64\n      nxv8i64        = 137,  // n x  8 x i64\n      nxv16i64       = 138,  // n x 16 x i64\n      nxv32i64       = 139,  // n x 32 x i64\n\n      FIRST_INTEGER_SCALABLE_VECTOR_VALUETYPE = nxv1i1,\n      LAST_INTEGER_SCALABLE_VECTOR_VALUETYPE = nxv32i64,\n\n      nxv1f16        = 140,  // n x  1 x f16\n      nxv2f16        = 141,  // n x  2 x f16\n      nxv4f16        = 142,  // n x  4 x f16\n      nxv8f16        = 143,  // n x  8 x f16\n      nxv16f16       = 144,  // n x 16 x f16\n      nxv32f16       = 145,  // n x 32 x f16\n      nxv1bf16       = 146,  // n x  1 x bf16\n      nxv2bf16       = 147,  // n x  2 x bf16\n      nxv4bf16       = 148,  // n x  4 x bf16\n      nxv8bf16       = 149,  // n x  8 x bf16\n      nxv1f32        = 150,  // n x  1 x f32\n      nxv2f32        = 151,  // n x  2 x f32\n      nxv4f32        = 152,  // n x  4 x f32\n      nxv8f32        = 153,  // n x  8 x f32\n      nxv16f32       = 154,  // n x 16 x f32\n      nxv1f64        = 155,  // n x  1 x f64\n      nxv2f64        = 156,  // n x  2 x f64\n      nxv4f64        = 157,  // n x  4 x f64\n      nxv8f64        = 158,  // n x  8 x f64\n\n      FIRST_FP_SCALABLE_VECTOR_VALUETYPE = nxv1f16,\n      LAST_FP_SCALABLE_VECTOR_VALUETYPE = nxv8f64,\n\n      FIRST_SCALABLE_VECTOR_VALUETYPE = nxv1i1,\n      LAST_SCALABLE_VECTOR_VALUETYPE = nxv8f64,\n\n      FIRST_VECTOR_VALUETYPE = v1i1,\n      LAST_VECTOR_VALUETYPE  = nxv8f64,\n\n      x86mmx         = 159,   // This is an X86 MMX value\n\n      Glue           = 160,   // This glues nodes together during pre-RA sched\n\n      isVoid         = 161,   // This has no value\n\n      Untyped        = 162,   // This value takes a register, but has\n                              // unspecified type.  The register class\n                              // will be determined by the opcode.\n\n      funcref        = 163,   // WebAssembly's funcref type\n      externref      = 164,   // WebAssembly's externref type\n      x86amx         = 165,   // This is an X86 AMX value\n\n      FIRST_VALUETYPE =  1,   // This is always the beginning of the list.\n      LAST_VALUETYPE = 166,   // This always remains at the end of the list.\n\n      // This is the current maximum for LAST_VALUETYPE.\n      // MVT::MAX_ALLOWED_VALUETYPE is used for asserts and to size bit vectors\n      // This value must be a multiple of 32.\n      MAX_ALLOWED_VALUETYPE = 192,\n\n      // A value of type llvm::TokenTy\n      token          = 248,\n\n      // This is MDNode or MDString.\n      Metadata       = 249,\n\n      // An int value the size of the pointer of the current\n      // target to any address space. This must only be used internal to\n      // tblgen. Other than for overloading, we treat iPTRAny the same as iPTR.\n      iPTRAny        = 250,\n\n      // A vector with any length and element size. This is used\n      // for intrinsics that have overloadings based on vector types.\n      // This is only for tblgen's consumption!\n      vAny           = 251,\n\n      // Any floating-point or vector floating-point value. This is used\n      // for intrinsics that have overloadings based on floating-point types.\n      // This is only for tblgen's consumption!\n      fAny           = 252,\n\n      // An integer or vector integer value of any bit width. This is\n      // used for intrinsics that have overloadings based on integer bit widths.\n      // This is only for tblgen's consumption!\n      iAny           = 253,\n\n      // An int value the size of the pointer of the current\n      // target.  This should only be used internal to tblgen!\n      iPTR           = 254,\n\n      // Any type. This is used for intrinsics that have overloadings.\n      // This is only for tblgen's consumption!\n      Any            = 255\n    };\n\n    SimpleValueType SimpleTy = INVALID_SIMPLE_VALUE_TYPE;\n\n    constexpr MVT() = default;\n    constexpr MVT(SimpleValueType SVT) : SimpleTy(SVT) {}\n\n    bool operator>(const MVT& S)  const { return SimpleTy >  S.SimpleTy; }\n    bool operator<(const MVT& S)  const { return SimpleTy <  S.SimpleTy; }\n    bool operator==(const MVT& S) const { return SimpleTy == S.SimpleTy; }\n    bool operator!=(const MVT& S) const { return SimpleTy != S.SimpleTy; }\n    bool operator>=(const MVT& S) const { return SimpleTy >= S.SimpleTy; }\n    bool operator<=(const MVT& S) const { return SimpleTy <= S.SimpleTy; }\n\n    /// Return true if this is a valid simple valuetype.\n    bool isValid() const {\n      return (SimpleTy >= MVT::FIRST_VALUETYPE &&\n              SimpleTy < MVT::LAST_VALUETYPE);\n    }\n\n    /// Return true if this is a FP or a vector FP type.\n    bool isFloatingPoint() const {\n      return ((SimpleTy >= MVT::FIRST_FP_VALUETYPE &&\n               SimpleTy <= MVT::LAST_FP_VALUETYPE) ||\n              (SimpleTy >= MVT::FIRST_FP_FIXEDLEN_VECTOR_VALUETYPE &&\n               SimpleTy <= MVT::LAST_FP_FIXEDLEN_VECTOR_VALUETYPE) ||\n              (SimpleTy >= MVT::FIRST_FP_SCALABLE_VECTOR_VALUETYPE &&\n               SimpleTy <= MVT::LAST_FP_SCALABLE_VECTOR_VALUETYPE));\n    }\n\n    /// Return true if this is an integer or a vector integer type.\n    bool isInteger() const {\n      return ((SimpleTy >= MVT::FIRST_INTEGER_VALUETYPE &&\n               SimpleTy <= MVT::LAST_INTEGER_VALUETYPE) ||\n              (SimpleTy >= MVT::FIRST_INTEGER_FIXEDLEN_VECTOR_VALUETYPE &&\n               SimpleTy <= MVT::LAST_INTEGER_FIXEDLEN_VECTOR_VALUETYPE) ||\n              (SimpleTy >= MVT::FIRST_INTEGER_SCALABLE_VECTOR_VALUETYPE &&\n               SimpleTy <= MVT::LAST_INTEGER_SCALABLE_VECTOR_VALUETYPE));\n    }\n\n    /// Return true if this is an integer, not including vectors.\n    bool isScalarInteger() const {\n      return (SimpleTy >= MVT::FIRST_INTEGER_VALUETYPE &&\n              SimpleTy <= MVT::LAST_INTEGER_VALUETYPE);\n    }\n\n    /// Return true if this is a vector value type.\n    bool isVector() const {\n      return (SimpleTy >= MVT::FIRST_VECTOR_VALUETYPE &&\n              SimpleTy <= MVT::LAST_VECTOR_VALUETYPE);\n    }\n\n    /// Return true if this is a vector value type where the\n    /// runtime length is machine dependent\n    bool isScalableVector() const {\n      return (SimpleTy >= MVT::FIRST_SCALABLE_VECTOR_VALUETYPE &&\n              SimpleTy <= MVT::LAST_SCALABLE_VECTOR_VALUETYPE);\n    }\n\n    bool isFixedLengthVector() const {\n      return (SimpleTy >= MVT::FIRST_FIXEDLEN_VECTOR_VALUETYPE &&\n              SimpleTy <= MVT::LAST_FIXEDLEN_VECTOR_VALUETYPE);\n    }\n\n    /// Return true if this is a 16-bit vector type.\n    bool is16BitVector() const {\n      return (SimpleTy == MVT::v2i8  || SimpleTy == MVT::v1i16 ||\n              SimpleTy == MVT::v16i1 || SimpleTy == MVT::v1f16);\n    }\n\n    /// Return true if this is a 32-bit vector type.\n    bool is32BitVector() const {\n      return (SimpleTy == MVT::v32i1 || SimpleTy == MVT::v4i8   ||\n              SimpleTy == MVT::v2i16 || SimpleTy == MVT::v1i32  ||\n              SimpleTy == MVT::v2f16 || SimpleTy == MVT::v2bf16 ||\n              SimpleTy == MVT::v1f32);\n    }\n\n    /// Return true if this is a 64-bit vector type.\n    bool is64BitVector() const {\n      return (SimpleTy == MVT::v64i1  || SimpleTy == MVT::v8i8  ||\n              SimpleTy == MVT::v4i16  || SimpleTy == MVT::v2i32 ||\n              SimpleTy == MVT::v1i64  || SimpleTy == MVT::v4f16 ||\n              SimpleTy == MVT::v4bf16 ||SimpleTy == MVT::v2f32  ||\n              SimpleTy == MVT::v1f64);\n    }\n\n    /// Return true if this is a 128-bit vector type.\n    bool is128BitVector() const {\n      return (SimpleTy == MVT::v128i1 || SimpleTy == MVT::v16i8  ||\n              SimpleTy == MVT::v8i16  || SimpleTy == MVT::v4i32  ||\n              SimpleTy == MVT::v2i64  || SimpleTy == MVT::v1i128 ||\n              SimpleTy == MVT::v8f16  || SimpleTy == MVT::v8bf16 ||\n              SimpleTy == MVT::v4f32  || SimpleTy == MVT::v2f64);\n    }\n\n    /// Return true if this is a 256-bit vector type.\n    bool is256BitVector() const {\n      return (SimpleTy == MVT::v16f16 || SimpleTy == MVT::v16bf16 ||\n              SimpleTy == MVT::v8f32  || SimpleTy == MVT::v4f64   ||\n              SimpleTy == MVT::v32i8  || SimpleTy == MVT::v16i16  ||\n              SimpleTy == MVT::v8i32  || SimpleTy == MVT::v4i64   ||\n              SimpleTy == MVT::v256i1);\n    }\n\n    /// Return true if this is a 512-bit vector type.\n    bool is512BitVector() const {\n      return (SimpleTy == MVT::v32f16 || SimpleTy == MVT::v32bf16 ||\n              SimpleTy == MVT::v16f32 || SimpleTy == MVT::v8f64   ||\n              SimpleTy == MVT::v512i1 || SimpleTy == MVT::v64i8   ||\n              SimpleTy == MVT::v32i16 || SimpleTy == MVT::v16i32  ||\n              SimpleTy == MVT::v8i64);\n    }\n\n    /// Return true if this is a 1024-bit vector type.\n    bool is1024BitVector() const {\n      return (SimpleTy == MVT::v1024i1 || SimpleTy == MVT::v128i8 ||\n              SimpleTy == MVT::v64i16  || SimpleTy == MVT::v32i32 ||\n              SimpleTy == MVT::v16i64  || SimpleTy == MVT::v64f16 ||\n              SimpleTy == MVT::v32f32  || SimpleTy == MVT::v16f64 ||\n              SimpleTy == MVT::v64bf16);\n    }\n\n    /// Return true if this is a 2048-bit vector type.\n    bool is2048BitVector() const {\n      return (SimpleTy == MVT::v256i8  || SimpleTy == MVT::v128i16 ||\n              SimpleTy == MVT::v64i32  || SimpleTy == MVT::v32i64  ||\n              SimpleTy == MVT::v128f16 || SimpleTy == MVT::v64f32  ||\n              SimpleTy == MVT::v32f64  || SimpleTy == MVT::v128bf16);\n    }\n\n    /// Return true if this is an overloaded type for TableGen.\n    bool isOverloaded() const {\n      return (SimpleTy == MVT::Any || SimpleTy == MVT::iAny ||\n              SimpleTy == MVT::fAny || SimpleTy == MVT::vAny ||\n              SimpleTy == MVT::iPTRAny);\n    }\n\n    /// Return a vector with the same number of elements as this vector, but\n    /// with the element type converted to an integer type with the same\n    /// bitwidth.\n    MVT changeVectorElementTypeToInteger() const {\n      MVT EltTy = getVectorElementType();\n      MVT IntTy = MVT::getIntegerVT(EltTy.getSizeInBits());\n      MVT VecTy = MVT::getVectorVT(IntTy, getVectorElementCount());\n      assert(VecTy.SimpleTy != MVT::INVALID_SIMPLE_VALUE_TYPE &&\n             \"Simple vector VT not representable by simple integer vector VT!\");\n      return VecTy;\n    }\n\n    /// Return a VT for a vector type whose attributes match ourselves\n    /// with the exception of the element type that is chosen by the caller.\n    MVT changeVectorElementType(MVT EltVT) const {\n      MVT VecTy = MVT::getVectorVT(EltVT, getVectorElementCount());\n      assert(VecTy.SimpleTy != MVT::INVALID_SIMPLE_VALUE_TYPE &&\n             \"Simple vector VT not representable by simple integer vector VT!\");\n      return VecTy;\n    }\n\n    /// Return the type converted to an equivalently sized integer or vector\n    /// with integer element type. Similar to changeVectorElementTypeToInteger,\n    /// but also handles scalars.\n    MVT changeTypeToInteger() {\n      if (isVector())\n        return changeVectorElementTypeToInteger();\n      return MVT::getIntegerVT(getSizeInBits());\n    }\n\n    /// Return a VT for a vector type with the same element type but\n    /// half the number of elements.\n    MVT getHalfNumVectorElementsVT() const {\n      MVT EltVT = getVectorElementType();\n      auto EltCnt = getVectorElementCount();\n      assert(EltCnt.isKnownEven() && \"Splitting vector, but not in half!\");\n      return getVectorVT(EltVT, EltCnt.divideCoefficientBy(2));\n    }\n\n    /// Returns true if the given vector is a power of 2.\n    bool isPow2VectorType() const {\n      unsigned NElts = getVectorNumElements();\n      return !(NElts & (NElts - 1));\n    }\n\n    /// Widens the length of the given vector MVT up to the nearest power of 2\n    /// and returns that type.\n    MVT getPow2VectorType() const {\n      if (isPow2VectorType())\n        return *this;\n\n      unsigned NElts = getVectorNumElements();\n      unsigned Pow2NElts = 1 << Log2_32_Ceil(NElts);\n      return MVT::getVectorVT(getVectorElementType(), Pow2NElts);\n    }\n\n    /// If this is a vector, return the element type, otherwise return this.\n    MVT getScalarType() const {\n      return isVector() ? getVectorElementType() : *this;\n    }\n\n    MVT getVectorElementType() const {\n      switch (SimpleTy) {\n      default:\n        llvm_unreachable(\"Not a vector MVT!\");\n      case v1i1:\n      case v2i1:\n      case v4i1:\n      case v8i1:\n      case v16i1:\n      case v32i1:\n      case v64i1:\n      case v128i1:\n      case v256i1:\n      case v512i1:\n      case v1024i1:\n      case nxv1i1:\n      case nxv2i1:\n      case nxv4i1:\n      case nxv8i1:\n      case nxv16i1:\n      case nxv32i1:\n      case nxv64i1: return i1;\n      case v1i8:\n      case v2i8:\n      case v4i8:\n      case v8i8:\n      case v16i8:\n      case v32i8:\n      case v64i8:\n      case v128i8:\n      case v256i8:\n      case nxv1i8:\n      case nxv2i8:\n      case nxv4i8:\n      case nxv8i8:\n      case nxv16i8:\n      case nxv32i8:\n      case nxv64i8: return i8;\n      case v1i16:\n      case v2i16:\n      case v3i16:\n      case v4i16:\n      case v8i16:\n      case v16i16:\n      case v32i16:\n      case v64i16:\n      case v128i16:\n      case nxv1i16:\n      case nxv2i16:\n      case nxv4i16:\n      case nxv8i16:\n      case nxv16i16:\n      case nxv32i16: return i16;\n      case v1i32:\n      case v2i32:\n      case v3i32:\n      case v4i32:\n      case v5i32:\n      case v8i32:\n      case v16i32:\n      case v32i32:\n      case v64i32:\n      case v128i32:\n      case v256i32:\n      case v512i32:\n      case v1024i32:\n      case v2048i32:\n      case nxv1i32:\n      case nxv2i32:\n      case nxv4i32:\n      case nxv8i32:\n      case nxv16i32:\n      case nxv32i32: return i32;\n      case v1i64:\n      case v2i64:\n      case v4i64:\n      case v8i64:\n      case v16i64:\n      case v32i64:\n      case v64i64:\n      case v128i64:\n      case v256i64:\n      case nxv1i64:\n      case nxv2i64:\n      case nxv4i64:\n      case nxv8i64:\n      case nxv16i64:\n      case nxv32i64: return i64;\n      case v1i128: return i128;\n      case v1f16:\n      case v2f16:\n      case v3f16:\n      case v4f16:\n      case v8f16:\n      case v16f16:\n      case v32f16:\n      case v64f16:\n      case v128f16:\n      case nxv1f16:\n      case nxv2f16:\n      case nxv4f16:\n      case nxv8f16:\n      case nxv16f16:\n      case nxv32f16: return f16;\n      case v2bf16:\n      case v3bf16:\n      case v4bf16:\n      case v8bf16:\n      case v16bf16:\n      case v32bf16:\n      case v64bf16:\n      case v128bf16:\n      case nxv1bf16:\n      case nxv2bf16:\n      case nxv4bf16:\n      case nxv8bf16: return bf16;\n      case v1f32:\n      case v2f32:\n      case v3f32:\n      case v4f32:\n      case v5f32:\n      case v8f32:\n      case v16f32:\n      case v32f32:\n      case v64f32:\n      case v128f32:\n      case v256f32:\n      case v512f32:\n      case v1024f32:\n      case v2048f32:\n      case nxv1f32:\n      case nxv2f32:\n      case nxv4f32:\n      case nxv8f32:\n      case nxv16f32: return f32;\n      case v1f64:\n      case v2f64:\n      case v4f64:\n      case v8f64:\n      case v16f64:\n      case v32f64:\n      case v64f64:\n      case v128f64:\n      case v256f64:\n      case nxv1f64:\n      case nxv2f64:\n      case nxv4f64:\n      case nxv8f64: return f64;\n      }\n    }\n\n    unsigned getVectorNumElements() const {\n      switch (SimpleTy) {\n      default:\n        llvm_unreachable(\"Not a vector MVT!\");\n      case v2048i32:\n      case v2048f32: return 2048;\n      case v1024i1:\n      case v1024i32:\n      case v1024f32: return 1024;\n      case v512i1:\n      case v512i32:\n      case v512f32: return 512;\n      case v256i1:\n      case v256i8:\n      case v256i32:\n      case v256i64:\n      case v256f32:\n      case v256f64: return 256;\n      case v128i1:\n      case v128i8:\n      case v128i16:\n      case v128i32:\n      case v128i64:\n      case v128f16:\n      case v128bf16:\n      case v128f32:\n      case v128f64: return 128;\n      case v64i1:\n      case v64i8:\n      case v64i16:\n      case v64i32:\n      case v64i64:\n      case v64f16:\n      case v64bf16:\n      case v64f32:\n      case v64f64:\n      case nxv64i1:\n      case nxv64i8: return 64;\n      case v32i1:\n      case v32i8:\n      case v32i16:\n      case v32i32:\n      case v32i64:\n      case v32f16:\n      case v32bf16:\n      case v32f32:\n      case v32f64:\n      case nxv32i1:\n      case nxv32i8:\n      case nxv32i16:\n      case nxv32i32:\n      case nxv32i64:\n      case nxv32f16: return 32;\n      case v16i1:\n      case v16i8:\n      case v16i16:\n      case v16i32:\n      case v16i64:\n      case v16f16:\n      case v16bf16:\n      case v16f32:\n      case v16f64:\n      case nxv16i1:\n      case nxv16i8:\n      case nxv16i16:\n      case nxv16i32:\n      case nxv16i64:\n      case nxv16f16:\n      case nxv16f32: return 16;\n      case v8i1:\n      case v8i8:\n      case v8i16:\n      case v8i32:\n      case v8i64:\n      case v8f16:\n      case v8bf16:\n      case v8f32:\n      case v8f64:\n      case nxv8i1:\n      case nxv8i8:\n      case nxv8i16:\n      case nxv8i32:\n      case nxv8i64:\n      case nxv8f16:\n      case nxv8bf16:\n      case nxv8f32:\n      case nxv8f64: return 8;\n      case v5i32:\n      case v5f32: return 5;\n      case v4i1:\n      case v4i8:\n      case v4i16:\n      case v4i32:\n      case v4i64:\n      case v4f16:\n      case v4bf16:\n      case v4f32:\n      case v4f64:\n      case nxv4i1:\n      case nxv4i8:\n      case nxv4i16:\n      case nxv4i32:\n      case nxv4i64:\n      case nxv4f16:\n      case nxv4bf16:\n      case nxv4f32:\n      case nxv4f64: return 4;\n      case v3i16:\n      case v3i32:\n      case v3f16:\n      case v3bf16:\n      case v3f32: return 3;\n      case v2i1:\n      case v2i8:\n      case v2i16:\n      case v2i32:\n      case v2i64:\n      case v2f16:\n      case v2bf16:\n      case v2f32:\n      case v2f64:\n      case nxv2i1:\n      case nxv2i8:\n      case nxv2i16:\n      case nxv2i32:\n      case nxv2i64:\n      case nxv2f16:\n      case nxv2bf16:\n      case nxv2f32:\n      case nxv2f64: return 2;\n      case v1i1:\n      case v1i8:\n      case v1i16:\n      case v1i32:\n      case v1i64:\n      case v1i128:\n      case v1f16:\n      case v1f32:\n      case v1f64:\n      case nxv1i1:\n      case nxv1i8:\n      case nxv1i16:\n      case nxv1i32:\n      case nxv1i64:\n      case nxv1f16:\n      case nxv1bf16:\n      case nxv1f32:\n      case nxv1f64: return 1;\n      }\n    }\n\n    ElementCount getVectorElementCount() const {\n      return ElementCount::get(getVectorNumElements(), isScalableVector());\n    }\n\n    /// Given a vector type, return the minimum number of elements it contains.\n    unsigned getVectorMinNumElements() const {\n      return getVectorElementCount().getKnownMinValue();\n    }\n\n    /// Returns the size of the specified MVT in bits.\n    ///\n    /// If the value type is a scalable vector type, the scalable property will\n    /// be set and the runtime size will be a positive integer multiple of the\n    /// base size.\n    TypeSize getSizeInBits() const {\n      switch (SimpleTy) {\n      default:\n        llvm_unreachable(\"getSizeInBits called on extended MVT.\");\n      case Other:\n        llvm_unreachable(\"Value type is non-standard value, Other.\");\n      case iPTR:\n        llvm_unreachable(\"Value type size is target-dependent. Ask TLI.\");\n      case iPTRAny:\n      case iAny:\n      case fAny:\n      case vAny:\n      case Any:\n        llvm_unreachable(\"Value type is overloaded.\");\n      case token:\n        llvm_unreachable(\"Token type is a sentinel that cannot be used \"\n                         \"in codegen and has no size\");\n      case Metadata:\n        llvm_unreachable(\"Value type is metadata.\");\n      case i1:\n      case v1i1: return TypeSize::Fixed(1);\n      case nxv1i1: return TypeSize::Scalable(1);\n      case v2i1: return TypeSize::Fixed(2);\n      case nxv2i1: return TypeSize::Scalable(2);\n      case v4i1: return TypeSize::Fixed(4);\n      case nxv4i1: return TypeSize::Scalable(4);\n      case i8  :\n      case v1i8:\n      case v8i1: return TypeSize::Fixed(8);\n      case nxv1i8:\n      case nxv8i1: return TypeSize::Scalable(8);\n      case i16 :\n      case f16:\n      case bf16:\n      case v16i1:\n      case v2i8:\n      case v1i16:\n      case v1f16: return TypeSize::Fixed(16);\n      case nxv16i1:\n      case nxv2i8:\n      case nxv1i16:\n      case nxv1bf16:\n      case nxv1f16: return TypeSize::Scalable(16);\n      case f32 :\n      case i32 :\n      case v32i1:\n      case v4i8:\n      case v2i16:\n      case v2f16:\n      case v2bf16:\n      case v1f32:\n      case v1i32: return TypeSize::Fixed(32);\n      case nxv32i1:\n      case nxv4i8:\n      case nxv2i16:\n      case nxv1i32:\n      case nxv2f16:\n      case nxv2bf16:\n      case nxv1f32: return TypeSize::Scalable(32);\n      case v3i16:\n      case v3f16:\n      case v3bf16: return TypeSize::Fixed(48);\n      case x86mmx:\n      case f64 :\n      case i64 :\n      case v64i1:\n      case v8i8:\n      case v4i16:\n      case v2i32:\n      case v1i64:\n      case v4f16:\n      case v4bf16:\n      case v2f32:\n      case v1f64: return TypeSize::Fixed(64);\n      case nxv64i1:\n      case nxv8i8:\n      case nxv4i16:\n      case nxv2i32:\n      case nxv1i64:\n      case nxv4f16:\n      case nxv4bf16:\n      case nxv2f32:\n      case nxv1f64: return TypeSize::Scalable(64);\n      case f80 :  return TypeSize::Fixed(80);\n      case v3i32:\n      case v3f32: return TypeSize::Fixed(96);\n      case f128:\n      case ppcf128:\n      case i128:\n      case v128i1:\n      case v16i8:\n      case v8i16:\n      case v4i32:\n      case v2i64:\n      case v1i128:\n      case v8f16:\n      case v8bf16:\n      case v4f32:\n      case v2f64: return TypeSize::Fixed(128);\n      case nxv16i8:\n      case nxv8i16:\n      case nxv4i32:\n      case nxv2i64:\n      case nxv8f16:\n      case nxv8bf16:\n      case nxv4f32:\n      case nxv2f64: return TypeSize::Scalable(128);\n      case v5i32:\n      case v5f32: return TypeSize::Fixed(160);\n      case v256i1:\n      case v32i8:\n      case v16i16:\n      case v8i32:\n      case v4i64:\n      case v16f16:\n      case v16bf16:\n      case v8f32:\n      case v4f64: return TypeSize::Fixed(256);\n      case nxv32i8:\n      case nxv16i16:\n      case nxv8i32:\n      case nxv4i64:\n      case nxv16f16:\n      case nxv8f32:\n      case nxv4f64: return TypeSize::Scalable(256);\n      case v512i1:\n      case v64i8:\n      case v32i16:\n      case v16i32:\n      case v8i64:\n      case v32f16:\n      case v32bf16:\n      case v16f32:\n      case v8f64: return TypeSize::Fixed(512);\n      case nxv64i8:\n      case nxv32i16:\n      case nxv16i32:\n      case nxv8i64:\n      case nxv32f16:\n      case nxv16f32:\n      case nxv8f64: return TypeSize::Scalable(512);\n      case v1024i1:\n      case v128i8:\n      case v64i16:\n      case v32i32:\n      case v16i64:\n      case v64f16:\n      case v64bf16:\n      case v32f32:\n      case v16f64: return TypeSize::Fixed(1024);\n      case nxv32i32:\n      case nxv16i64: return TypeSize::Scalable(1024);\n      case v256i8:\n      case v128i16:\n      case v64i32:\n      case v32i64:\n      case v128f16:\n      case v128bf16:\n      case v64f32:\n      case v32f64: return TypeSize::Fixed(2048);\n      case nxv32i64: return TypeSize::Scalable(2048);\n      case v128i32:\n      case v64i64:\n      case v128f32:\n      case v64f64:  return TypeSize::Fixed(4096);\n      case v256i32:\n      case v128i64:\n      case v256f32:\n      case x86amx:\n      case v128f64:  return TypeSize::Fixed(8192);\n      case v512i32:\n      case v256i64:\n      case v512f32:\n      case v256f64:  return TypeSize::Fixed(16384);\n      case v1024i32:\n      case v1024f32:  return TypeSize::Fixed(32768);\n      case v2048i32:\n      case v2048f32:  return TypeSize::Fixed(65536);\n      case funcref:\n      case externref: return TypeSize::Fixed(0); // opaque type\n      }\n    }\n\n    /// Return the size of the specified fixed width value type in bits. The\n    /// function will assert if the type is scalable.\n    uint64_t getFixedSizeInBits() const {\n      return getSizeInBits().getFixedSize();\n    }\n\n    uint64_t getScalarSizeInBits() const {\n      return getScalarType().getSizeInBits().getFixedSize();\n    }\n\n    /// Return the number of bytes overwritten by a store of the specified value\n    /// type.\n    ///\n    /// If the value type is a scalable vector type, the scalable property will\n    /// be set and the runtime size will be a positive integer multiple of the\n    /// base size.\n    TypeSize getStoreSize() const {\n      TypeSize BaseSize = getSizeInBits();\n      return {(BaseSize.getKnownMinSize() + 7) / 8, BaseSize.isScalable()};\n    }\n\n    /// Return the number of bits overwritten by a store of the specified value\n    /// type.\n    ///\n    /// If the value type is a scalable vector type, the scalable property will\n    /// be set and the runtime size will be a positive integer multiple of the\n    /// base size.\n    TypeSize getStoreSizeInBits() const {\n      return getStoreSize() * 8;\n    }\n\n    /// Returns true if the number of bits for the type is a multiple of an\n    /// 8-bit byte.\n    bool isByteSized() const { return getSizeInBits().isKnownMultipleOf(8); }\n\n    /// Return true if we know at compile time this has more bits than VT.\n    bool knownBitsGT(MVT VT) const {\n      return TypeSize::isKnownGT(getSizeInBits(), VT.getSizeInBits());\n    }\n\n    /// Return true if we know at compile time this has more than or the same\n    /// bits as VT.\n    bool knownBitsGE(MVT VT) const {\n      return TypeSize::isKnownGE(getSizeInBits(), VT.getSizeInBits());\n    }\n\n    /// Return true if we know at compile time this has fewer bits than VT.\n    bool knownBitsLT(MVT VT) const {\n      return TypeSize::isKnownLT(getSizeInBits(), VT.getSizeInBits());\n    }\n\n    /// Return true if we know at compile time this has fewer than or the same\n    /// bits as VT.\n    bool knownBitsLE(MVT VT) const {\n      return TypeSize::isKnownLE(getSizeInBits(), VT.getSizeInBits());\n    }\n\n    /// Return true if this has more bits than VT.\n    bool bitsGT(MVT VT) const {\n      assert(isScalableVector() == VT.isScalableVector() &&\n             \"Comparison between scalable and fixed types\");\n      return knownBitsGT(VT);\n    }\n\n    /// Return true if this has no less bits than VT.\n    bool bitsGE(MVT VT) const {\n      assert(isScalableVector() == VT.isScalableVector() &&\n             \"Comparison between scalable and fixed types\");\n      return knownBitsGE(VT);\n    }\n\n    /// Return true if this has less bits than VT.\n    bool bitsLT(MVT VT) const {\n      assert(isScalableVector() == VT.isScalableVector() &&\n             \"Comparison between scalable and fixed types\");\n      return knownBitsLT(VT);\n    }\n\n    /// Return true if this has no more bits than VT.\n    bool bitsLE(MVT VT) const {\n      assert(isScalableVector() == VT.isScalableVector() &&\n             \"Comparison between scalable and fixed types\");\n      return knownBitsLE(VT);\n    }\n\n    static MVT getFloatingPointVT(unsigned BitWidth) {\n      switch (BitWidth) {\n      default:\n        llvm_unreachable(\"Bad bit width!\");\n      case 16:\n        return MVT::f16;\n      case 32:\n        return MVT::f32;\n      case 64:\n        return MVT::f64;\n      case 80:\n        return MVT::f80;\n      case 128:\n        return MVT::f128;\n      }\n    }\n\n    static MVT getIntegerVT(unsigned BitWidth) {\n      switch (BitWidth) {\n      default:\n        return (MVT::SimpleValueType)(MVT::INVALID_SIMPLE_VALUE_TYPE);\n      case 1:\n        return MVT::i1;\n      case 8:\n        return MVT::i8;\n      case 16:\n        return MVT::i16;\n      case 32:\n        return MVT::i32;\n      case 64:\n        return MVT::i64;\n      case 128:\n        return MVT::i128;\n      }\n    }\n\n    static MVT getVectorVT(MVT VT, unsigned NumElements) {\n      switch (VT.SimpleTy) {\n      default:\n        break;\n      case MVT::i1:\n        if (NumElements == 1)    return MVT::v1i1;\n        if (NumElements == 2)    return MVT::v2i1;\n        if (NumElements == 4)    return MVT::v4i1;\n        if (NumElements == 8)    return MVT::v8i1;\n        if (NumElements == 16)   return MVT::v16i1;\n        if (NumElements == 32)   return MVT::v32i1;\n        if (NumElements == 64)   return MVT::v64i1;\n        if (NumElements == 128)  return MVT::v128i1;\n        if (NumElements == 256)  return MVT::v256i1;\n        if (NumElements == 512)  return MVT::v512i1;\n        if (NumElements == 1024) return MVT::v1024i1;\n        break;\n      case MVT::i8:\n        if (NumElements == 1)   return MVT::v1i8;\n        if (NumElements == 2)   return MVT::v2i8;\n        if (NumElements == 4)   return MVT::v4i8;\n        if (NumElements == 8)   return MVT::v8i8;\n        if (NumElements == 16)  return MVT::v16i8;\n        if (NumElements == 32)  return MVT::v32i8;\n        if (NumElements == 64)  return MVT::v64i8;\n        if (NumElements == 128) return MVT::v128i8;\n        if (NumElements == 256) return MVT::v256i8;\n        break;\n      case MVT::i16:\n        if (NumElements == 1)   return MVT::v1i16;\n        if (NumElements == 2)   return MVT::v2i16;\n        if (NumElements == 3)   return MVT::v3i16;\n        if (NumElements == 4)   return MVT::v4i16;\n        if (NumElements == 8)   return MVT::v8i16;\n        if (NumElements == 16)  return MVT::v16i16;\n        if (NumElements == 32)  return MVT::v32i16;\n        if (NumElements == 64)  return MVT::v64i16;\n        if (NumElements == 128) return MVT::v128i16;\n        break;\n      case MVT::i32:\n        if (NumElements == 1)    return MVT::v1i32;\n        if (NumElements == 2)    return MVT::v2i32;\n        if (NumElements == 3)    return MVT::v3i32;\n        if (NumElements == 4)    return MVT::v4i32;\n        if (NumElements == 5)    return MVT::v5i32;\n        if (NumElements == 8)    return MVT::v8i32;\n        if (NumElements == 16)   return MVT::v16i32;\n        if (NumElements == 32)   return MVT::v32i32;\n        if (NumElements == 64)   return MVT::v64i32;\n        if (NumElements == 128)  return MVT::v128i32;\n        if (NumElements == 256)  return MVT::v256i32;\n        if (NumElements == 512)  return MVT::v512i32;\n        if (NumElements == 1024) return MVT::v1024i32;\n        if (NumElements == 2048) return MVT::v2048i32;\n        break;\n      case MVT::i64:\n        if (NumElements == 1)  return MVT::v1i64;\n        if (NumElements == 2)  return MVT::v2i64;\n        if (NumElements == 4)  return MVT::v4i64;\n        if (NumElements == 8)  return MVT::v8i64;\n        if (NumElements == 16) return MVT::v16i64;\n        if (NumElements == 32) return MVT::v32i64;\n        if (NumElements == 64) return MVT::v64i64;\n        if (NumElements == 128) return MVT::v128i64;\n        if (NumElements == 256) return MVT::v256i64;\n        break;\n      case MVT::i128:\n        if (NumElements == 1)  return MVT::v1i128;\n        break;\n      case MVT::f16:\n        if (NumElements == 1)   return MVT::v1f16;\n        if (NumElements == 2)   return MVT::v2f16;\n        if (NumElements == 3)   return MVT::v3f16;\n        if (NumElements == 4)   return MVT::v4f16;\n        if (NumElements == 8)   return MVT::v8f16;\n        if (NumElements == 16)  return MVT::v16f16;\n        if (NumElements == 32)  return MVT::v32f16;\n        if (NumElements == 64)  return MVT::v64f16;\n        if (NumElements == 128) return MVT::v128f16;\n        break;\n      case MVT::bf16:\n        if (NumElements == 2)   return MVT::v2bf16;\n        if (NumElements == 3)   return MVT::v3bf16;\n        if (NumElements == 4)   return MVT::v4bf16;\n        if (NumElements == 8)   return MVT::v8bf16;\n        if (NumElements == 16)  return MVT::v16bf16;\n        if (NumElements == 32)  return MVT::v32bf16;\n        if (NumElements == 64)  return MVT::v64bf16;\n        if (NumElements == 128) return MVT::v128bf16;\n        break;\n      case MVT::f32:\n        if (NumElements == 1)    return MVT::v1f32;\n        if (NumElements == 2)    return MVT::v2f32;\n        if (NumElements == 3)    return MVT::v3f32;\n        if (NumElements == 4)    return MVT::v4f32;\n        if (NumElements == 5)    return MVT::v5f32;\n        if (NumElements == 8)    return MVT::v8f32;\n        if (NumElements == 16)   return MVT::v16f32;\n        if (NumElements == 32)   return MVT::v32f32;\n        if (NumElements == 64)   return MVT::v64f32;\n        if (NumElements == 128)  return MVT::v128f32;\n        if (NumElements == 256)  return MVT::v256f32;\n        if (NumElements == 512)  return MVT::v512f32;\n        if (NumElements == 1024) return MVT::v1024f32;\n        if (NumElements == 2048) return MVT::v2048f32;\n        break;\n      case MVT::f64:\n        if (NumElements == 1)  return MVT::v1f64;\n        if (NumElements == 2)  return MVT::v2f64;\n        if (NumElements == 4)  return MVT::v4f64;\n        if (NumElements == 8)  return MVT::v8f64;\n        if (NumElements == 16) return MVT::v16f64;\n        if (NumElements == 32) return MVT::v32f64;\n        if (NumElements == 64) return MVT::v64f64;\n        if (NumElements == 128) return MVT::v128f64;\n        if (NumElements == 256) return MVT::v256f64;\n        break;\n      }\n      return (MVT::SimpleValueType)(MVT::INVALID_SIMPLE_VALUE_TYPE);\n    }\n\n    static MVT getScalableVectorVT(MVT VT, unsigned NumElements) {\n      switch(VT.SimpleTy) {\n        default:\n          break;\n        case MVT::i1:\n          if (NumElements == 1)  return MVT::nxv1i1;\n          if (NumElements == 2)  return MVT::nxv2i1;\n          if (NumElements == 4)  return MVT::nxv4i1;\n          if (NumElements == 8)  return MVT::nxv8i1;\n          if (NumElements == 16) return MVT::nxv16i1;\n          if (NumElements == 32) return MVT::nxv32i1;\n          if (NumElements == 64) return MVT::nxv64i1;\n          break;\n        case MVT::i8:\n          if (NumElements == 1)  return MVT::nxv1i8;\n          if (NumElements == 2)  return MVT::nxv2i8;\n          if (NumElements == 4)  return MVT::nxv4i8;\n          if (NumElements == 8)  return MVT::nxv8i8;\n          if (NumElements == 16) return MVT::nxv16i8;\n          if (NumElements == 32) return MVT::nxv32i8;\n          if (NumElements == 64) return MVT::nxv64i8;\n          break;\n        case MVT::i16:\n          if (NumElements == 1)  return MVT::nxv1i16;\n          if (NumElements == 2)  return MVT::nxv2i16;\n          if (NumElements == 4)  return MVT::nxv4i16;\n          if (NumElements == 8)  return MVT::nxv8i16;\n          if (NumElements == 16) return MVT::nxv16i16;\n          if (NumElements == 32) return MVT::nxv32i16;\n          break;\n        case MVT::i32:\n          if (NumElements == 1)  return MVT::nxv1i32;\n          if (NumElements == 2)  return MVT::nxv2i32;\n          if (NumElements == 4)  return MVT::nxv4i32;\n          if (NumElements == 8)  return MVT::nxv8i32;\n          if (NumElements == 16) return MVT::nxv16i32;\n          if (NumElements == 32) return MVT::nxv32i32;\n          break;\n        case MVT::i64:\n          if (NumElements == 1)  return MVT::nxv1i64;\n          if (NumElements == 2)  return MVT::nxv2i64;\n          if (NumElements == 4)  return MVT::nxv4i64;\n          if (NumElements == 8)  return MVT::nxv8i64;\n          if (NumElements == 16) return MVT::nxv16i64;\n          if (NumElements == 32) return MVT::nxv32i64;\n          break;\n        case MVT::f16:\n          if (NumElements == 1)  return MVT::nxv1f16;\n          if (NumElements == 2)  return MVT::nxv2f16;\n          if (NumElements == 4)  return MVT::nxv4f16;\n          if (NumElements == 8)  return MVT::nxv8f16;\n          if (NumElements == 16)  return MVT::nxv16f16;\n          if (NumElements == 32)  return MVT::nxv32f16;\n          break;\n        case MVT::bf16:\n          if (NumElements == 1)  return MVT::nxv1bf16;\n          if (NumElements == 2)  return MVT::nxv2bf16;\n          if (NumElements == 4)  return MVT::nxv4bf16;\n          if (NumElements == 8)  return MVT::nxv8bf16;\n          break;\n        case MVT::f32:\n          if (NumElements == 1)  return MVT::nxv1f32;\n          if (NumElements == 2)  return MVT::nxv2f32;\n          if (NumElements == 4)  return MVT::nxv4f32;\n          if (NumElements == 8)  return MVT::nxv8f32;\n          if (NumElements == 16) return MVT::nxv16f32;\n          break;\n        case MVT::f64:\n          if (NumElements == 1)  return MVT::nxv1f64;\n          if (NumElements == 2)  return MVT::nxv2f64;\n          if (NumElements == 4)  return MVT::nxv4f64;\n          if (NumElements == 8)  return MVT::nxv8f64;\n          break;\n      }\n      return (MVT::SimpleValueType)(MVT::INVALID_SIMPLE_VALUE_TYPE);\n    }\n\n    static MVT getVectorVT(MVT VT, unsigned NumElements, bool IsScalable) {\n      if (IsScalable)\n        return getScalableVectorVT(VT, NumElements);\n      return getVectorVT(VT, NumElements);\n    }\n\n    static MVT getVectorVT(MVT VT, ElementCount EC) {\n      if (EC.isScalable())\n        return getScalableVectorVT(VT, EC.getKnownMinValue());\n      return getVectorVT(VT, EC.getKnownMinValue());\n    }\n\n    /// Return the value type corresponding to the specified type.  This returns\n    /// all pointers as iPTR.  If HandleUnknown is true, unknown types are\n    /// returned as Other, otherwise they are invalid.\n    static MVT getVT(Type *Ty, bool HandleUnknown = false);\n\n  private:\n    /// A simple iterator over the MVT::SimpleValueType enum.\n    struct mvt_iterator {\n      SimpleValueType VT;\n\n      mvt_iterator(SimpleValueType VT) : VT(VT) {}\n\n      MVT operator*() const { return VT; }\n      bool operator!=(const mvt_iterator &LHS) const { return VT != LHS.VT; }\n\n      mvt_iterator& operator++() {\n        VT = (MVT::SimpleValueType)((int)VT + 1);\n        assert((int)VT <= MVT::MAX_ALLOWED_VALUETYPE &&\n               \"MVT iterator overflowed.\");\n        return *this;\n      }\n    };\n\n    /// A range of the MVT::SimpleValueType enum.\n    using mvt_range = iterator_range<mvt_iterator>;\n\n  public:\n    /// SimpleValueType Iteration\n    /// @{\n    static mvt_range all_valuetypes() {\n      return mvt_range(MVT::FIRST_VALUETYPE, MVT::LAST_VALUETYPE);\n    }\n\n    static mvt_range integer_valuetypes() {\n      return mvt_range(MVT::FIRST_INTEGER_VALUETYPE,\n                       (MVT::SimpleValueType)(MVT::LAST_INTEGER_VALUETYPE + 1));\n    }\n\n    static mvt_range fp_valuetypes() {\n      return mvt_range(MVT::FIRST_FP_VALUETYPE,\n                       (MVT::SimpleValueType)(MVT::LAST_FP_VALUETYPE + 1));\n    }\n\n    static mvt_range vector_valuetypes() {\n      return mvt_range(MVT::FIRST_VECTOR_VALUETYPE,\n                       (MVT::SimpleValueType)(MVT::LAST_VECTOR_VALUETYPE + 1));\n    }\n\n    static mvt_range fixedlen_vector_valuetypes() {\n      return mvt_range(\n               MVT::FIRST_FIXEDLEN_VECTOR_VALUETYPE,\n               (MVT::SimpleValueType)(MVT::LAST_FIXEDLEN_VECTOR_VALUETYPE + 1));\n    }\n\n    static mvt_range scalable_vector_valuetypes() {\n      return mvt_range(\n               MVT::FIRST_SCALABLE_VECTOR_VALUETYPE,\n               (MVT::SimpleValueType)(MVT::LAST_SCALABLE_VECTOR_VALUETYPE + 1));\n    }\n\n    static mvt_range integer_fixedlen_vector_valuetypes() {\n      return mvt_range(\n       MVT::FIRST_INTEGER_FIXEDLEN_VECTOR_VALUETYPE,\n       (MVT::SimpleValueType)(MVT::LAST_INTEGER_FIXEDLEN_VECTOR_VALUETYPE + 1));\n    }\n\n    static mvt_range fp_fixedlen_vector_valuetypes() {\n      return mvt_range(\n          MVT::FIRST_FP_FIXEDLEN_VECTOR_VALUETYPE,\n          (MVT::SimpleValueType)(MVT::LAST_FP_FIXEDLEN_VECTOR_VALUETYPE + 1));\n    }\n\n    static mvt_range integer_scalable_vector_valuetypes() {\n      return mvt_range(\n       MVT::FIRST_INTEGER_SCALABLE_VECTOR_VALUETYPE,\n       (MVT::SimpleValueType)(MVT::LAST_INTEGER_SCALABLE_VECTOR_VALUETYPE + 1));\n    }\n\n    static mvt_range fp_scalable_vector_valuetypes() {\n      return mvt_range(\n            MVT::FIRST_FP_SCALABLE_VECTOR_VALUETYPE,\n            (MVT::SimpleValueType)(MVT::LAST_FP_SCALABLE_VECTOR_VALUETYPE + 1));\n    }\n    /// @}\n  };\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_MACHINEVALUETYPE_H\n"}, "69": {"id": 69, "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h", "content": "//===-- llvm/CodeGen/DebugLocEntry.h - Entry in debug_loc list -*- C++ -*--===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_LIB_CODEGEN_ASMPRINTER_DEBUGLOCENTRY_H\n#define LLVM_LIB_CODEGEN_ASMPRINTER_DEBUGLOCENTRY_H\n\n#include \"DebugLocStream.h\"\n#include \"llvm/Config/llvm-config.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/DebugInfo.h\"\n#include \"llvm/MC/MCSymbol.h\"\n#include \"llvm/MC/MachineLocation.h\"\n#include \"llvm/Support/Debug.h\"\n\nnamespace llvm {\nclass AsmPrinter;\n\n/// This struct describes target specific location.\nstruct TargetIndexLocation {\n  int Index;\n  int Offset;\n\n  TargetIndexLocation() = default;\n  TargetIndexLocation(unsigned Idx, int64_t Offset)\n      : Index(Idx), Offset(Offset) {}\n\n  bool operator==(const TargetIndexLocation &Other) const {\n    return Index == Other.Index && Offset == Other.Offset;\n  }\n};\n\n/// A single location or constant within a variable location description, with\n/// either a single entry (with an optional DIExpression) used for a DBG_VALUE,\n/// or a list of entries used for a DBG_VALUE_LIST.\nclass DbgValueLocEntry {\n\n  /// Type of entry that this represents.\n  enum EntryType {\n    E_Location,\n    E_Integer,\n    E_ConstantFP,\n    E_ConstantInt,\n    E_TargetIndexLocation\n  };\n  enum EntryType EntryKind;\n\n  /// Either a constant,\n  union {\n    int64_t Int;\n    const ConstantFP *CFP;\n    const ConstantInt *CIP;\n  } Constant;\n\n  union {\n    /// Or a location in the machine frame.\n    MachineLocation Loc;\n    /// Or a location from target specific location.\n    TargetIndexLocation TIL;\n  };\n\npublic:\n  DbgValueLocEntry(int64_t i) : EntryKind(E_Integer) { Constant.Int = i; }\n  DbgValueLocEntry(const ConstantFP *CFP) : EntryKind(E_ConstantFP) {\n    Constant.CFP = CFP;\n  }\n  DbgValueLocEntry(const ConstantInt *CIP) : EntryKind(E_ConstantInt) {\n    Constant.CIP = CIP;\n  }\n  DbgValueLocEntry(MachineLocation Loc) : EntryKind(E_Location), Loc(Loc) {}\n  DbgValueLocEntry(TargetIndexLocation Loc)\n      : EntryKind(E_TargetIndexLocation), TIL(Loc) {}\n\n  bool isLocation() const { return EntryKind == E_Location; }\n  bool isTargetIndexLocation() const {\n    return EntryKind == E_TargetIndexLocation;\n  }\n  bool isInt() const { return EntryKind == E_Integer; }\n  bool isConstantFP() const { return EntryKind == E_ConstantFP; }\n  bool isConstantInt() const { return EntryKind == E_ConstantInt; }\n  int64_t getInt() const { return Constant.Int; }\n  const ConstantFP *getConstantFP() const { return Constant.CFP; }\n  const ConstantInt *getConstantInt() const { return Constant.CIP; }\n  MachineLocation getLoc() const { return Loc; }\n  TargetIndexLocation getTargetIndexLocation() const { return TIL; }\n  friend bool operator==(const DbgValueLocEntry &, const DbgValueLocEntry &);\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n  LLVM_DUMP_METHOD void dump() const {\n    if (isLocation()) {\n      llvm::dbgs() << \"Loc = { reg=\" << Loc.getReg() << \" \";\n      if (Loc.isIndirect())\n        llvm::dbgs() << \"+0\";\n      llvm::dbgs() << \"} \";\n    } else if (isConstantInt())\n      Constant.CIP->dump();\n    else if (isConstantFP())\n      Constant.CFP->dump();\n  }\n#endif\n};\n\n/// The location of a single variable, composed of an expression and 0 or more\n/// DbgValueLocEntries.\nclass DbgValueLoc {\n  /// Any complex address location expression for this DbgValueLoc.\n  const DIExpression *Expression;\n\n  SmallVector<DbgValueLocEntry, 2> ValueLocEntries;\n\n  bool IsVariadic;\n\npublic:\n  DbgValueLoc(const DIExpression *Expr, ArrayRef<DbgValueLocEntry> Locs)\n      : Expression(Expr), ValueLocEntries(Locs.begin(), Locs.end()),\n        IsVariadic(true) {\n#ifndef NDEBUG\n    // Currently, DBG_VALUE_VAR expressions must use stack_value.\n    assert(Expr && Expr->isValid() &&\n           is_contained(Locs, dwarf::DW_OP_stack_value));\n    for (DbgValueLocEntry &Entry : ValueLocEntries) {\n      assert(!Entry.isConstantFP() && !Entry.isConstantInt() &&\n             \"Constant values should only be present in non-variadic \"\n             \"DBG_VALUEs.\");\n    }\n#endif\n  }\n\n  DbgValueLoc(const DIExpression *Expr, ArrayRef<DbgValueLocEntry> Locs,\n              bool IsVariadic)\n      : Expression(Expr), ValueLocEntries(Locs.begin(), Locs.end()),\n        IsVariadic(IsVariadic) {\n#ifndef NDEBUG\n    assert(cast<DIExpression>(Expr)->isValid() ||\n           !any_of(Locs, [](auto LE) { return LE.isLocation(); }));\n    if (!IsVariadic) {\n      assert(ValueLocEntries.size() == 1);\n    } else {\n      // Currently, DBG_VALUE_VAR expressions must use stack_value.\n      assert(Expr && Expr->isValid() &&\n             is_contained(Expr->getElements(), dwarf::DW_OP_stack_value));\n      for (DbgValueLocEntry &Entry : ValueLocEntries) {\n        assert(!Entry.isConstantFP() && !Entry.isConstantInt() &&\n               \"Constant values should only be present in non-variadic \"\n               \"DBG_VALUEs.\");\n      }\n    }\n#endif\n  }\n\n  DbgValueLoc(const DIExpression *Expr, DbgValueLocEntry Loc)\n      : Expression(Expr), ValueLocEntries(1, Loc), IsVariadic(false) {\n    assert(((Expr && Expr->isValid()) || !Loc.isLocation()) &&\n           \"DBG_VALUE with a machine location must have a valid expression.\");\n  }\n\n  bool isFragment() const { return getExpression()->isFragment(); }\n  bool isEntryVal() const { return getExpression()->isEntryValue(); }\n  bool isVariadic() const { return IsVariadic; }\n  const DIExpression *getExpression() const { return Expression; }\n  const ArrayRef<DbgValueLocEntry> getLocEntries() const {\n    return ValueLocEntries;\n  }\n  friend bool operator==(const DbgValueLoc &, const DbgValueLoc &);\n  friend bool operator<(const DbgValueLoc &, const DbgValueLoc &);\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n  LLVM_DUMP_METHOD void dump() const {\n    for (DbgValueLocEntry DV : ValueLocEntries)\n      DV.dump();\n    if (Expression)\n      Expression->dump();\n  }\n#endif\n};\n\n/// This struct describes location entries emitted in the .debug_loc\n/// section.\nclass DebugLocEntry {\n  /// Begin and end symbols for the address range that this location is valid.\n  const MCSymbol *Begin;\n  const MCSymbol *End;\n\n  /// A nonempty list of locations/constants belonging to this entry,\n  /// sorted by offset.\n  SmallVector<DbgValueLoc, 1> Values;\n\npublic:\n  /// Create a location list entry for the range [\\p Begin, \\p End).\n  ///\n  /// \\param Vals One or more values describing (parts of) the variable.\n  DebugLocEntry(const MCSymbol *Begin, const MCSymbol *End,\n                ArrayRef<DbgValueLoc> Vals)\n      : Begin(Begin), End(End) {\n    addValues(Vals);\n  }\n\n  /// Attempt to merge this DebugLocEntry with Next and return\n  /// true if the merge was successful. Entries can be merged if they\n  /// share the same Loc/Constant and if Next immediately follows this\n  /// Entry.\n  bool MergeRanges(const DebugLocEntry &Next) {\n    // If this and Next are describing the same variable, merge them.\n    if ((End == Next.Begin && Values == Next.Values)) {\n      End = Next.End;\n      return true;\n    }\n    return false;\n  }\n\n  const MCSymbol *getBeginSym() const { return Begin; }\n  const MCSymbol *getEndSym() const { return End; }\n  ArrayRef<DbgValueLoc> getValues() const { return Values; }\n  void addValues(ArrayRef<DbgValueLoc> Vals) {\n    Values.append(Vals.begin(), Vals.end());\n    sortUniqueValues();\n    assert((Values.size() == 1 || all_of(Values, [](DbgValueLoc V) {\n              return V.isFragment();\n            })) && \"must either have a single value or multiple pieces\");\n  }\n\n  // Sort the pieces by offset.\n  // Remove any duplicate entries by dropping all but the first.\n  void sortUniqueValues() {\n    llvm::sort(Values);\n    Values.erase(std::unique(Values.begin(), Values.end(),\n                             [](const DbgValueLoc &A, const DbgValueLoc &B) {\n                               return A.getExpression() == B.getExpression();\n                             }),\n                 Values.end());\n  }\n\n  /// Lower this entry into a DWARF expression.\n  void finalize(const AsmPrinter &AP,\n                DebugLocStream::ListBuilder &List,\n                const DIBasicType *BT,\n                DwarfCompileUnit &TheCU);\n};\n\n/// Compare two DbgValueLocEntries for equality.\ninline bool operator==(const DbgValueLocEntry &A, const DbgValueLocEntry &B) {\n  if (A.EntryKind != B.EntryKind)\n    return false;\n\n  switch (A.EntryKind) {\n  case DbgValueLocEntry::E_Location:\n    return A.Loc == B.Loc;\n  case DbgValueLocEntry::E_TargetIndexLocation:\n    return A.TIL == B.TIL;\n  case DbgValueLocEntry::E_Integer:\n    return A.Constant.Int == B.Constant.Int;\n  case DbgValueLocEntry::E_ConstantFP:\n    return A.Constant.CFP == B.Constant.CFP;\n  case DbgValueLocEntry::E_ConstantInt:\n    return A.Constant.CIP == B.Constant.CIP;\n  }\n  llvm_unreachable(\"unhandled EntryKind\");\n}\n\n/// Compare two DbgValueLocs for equality.\ninline bool operator==(const DbgValueLoc &A, const DbgValueLoc &B) {\n  return A.ValueLocEntries == B.ValueLocEntries &&\n         A.Expression == B.Expression && A.IsVariadic == B.IsVariadic;\n}\n\n/// Compare two fragments based on their offset.\ninline bool operator<(const DbgValueLoc &A,\n                      const DbgValueLoc &B) {\n  return A.getExpression()->getFragmentInfo()->OffsetInBits <\n         B.getExpression()->getFragmentInfo()->OffsetInBits;\n}\n\n}\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 50, "file": 5, "line": 1245}, "message": "'LHS' of type 'llvm::DenseMapIterator<const llvm::Metadata *, llvm::TrackingMDRef, llvm::DenseMapInfo<const llvm::Metadata *>, llvm::detail::DenseMapPair<const llvm::Metadata *, llvm::TrackingMDRef>, true>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "ad79e2d7d6a301f4891de9a848597885", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 50, "file": 5, "line": 1246}, "message": "'RHS' of type 'llvm::DenseMapIterator<const llvm::Metadata *, llvm::TrackingMDRef, llvm::DenseMapInfo<const llvm::Metadata *>, llvm::detail::DenseMapPair<const llvm::Metadata *, llvm::TrackingMDRef>, true>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "21996acd9127b7637fe425193c9daf97", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 50, "file": 5, "line": 1254}, "message": "'LHS' of type 'llvm::DenseMapIterator<const llvm::Metadata *, llvm::TrackingMDRef, llvm::DenseMapInfo<const llvm::Metadata *>, llvm::detail::DenseMapPair<const llvm::Metadata *, llvm::TrackingMDRef>, true>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "1c7ebf584f04c2e0b962566f23beac96", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 50, "file": 5, "line": 1255}, "message": "'RHS' of type 'llvm::DenseMapIterator<const llvm::Metadata *, llvm::TrackingMDRef, llvm::DenseMapInfo<const llvm::Metadata *>, llvm::detail::DenseMapPair<const llvm::Metadata *, llvm::TrackingMDRef>, true>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "21996acd9127b7637fe425193c9daf97", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 13, "line": 169}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerSumType.h", "reportHash": "6ad641db94c0510856b1c58c69441959", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 13, "line": 172}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerSumType.h", "reportHash": "e5ca4d8503870e75897ce8fbca5f66b5", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 13, "line": 175}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerSumType.h", "reportHash": "4b4e1b7e40595a80688ce493ca83c6cc", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 13, "line": 178}, "message": "'operator>' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerSumType.h", "reportHash": "2289fd29c37cc1fc1c0c0e8de845f96c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 13, "line": 181}, "message": "'operator<=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerSumType.h", "reportHash": "59aa2d3e3f4e6db8b8d5cd700ba3ed9e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 13, "line": 184}, "message": "'operator>=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerSumType.h", "reportHash": "a11abf99e3ef8b25702d71b8fbdf1673", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 16, "line": 238}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SetVector.h", "reportHash": "cf5f548d2868a2a2d80350b99117c98c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 16, "line": 242}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SetVector.h", "reportHash": "ff3912fa055851152d2a02f4f7b64a2d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 18, "line": 110}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallSet.h", "reportHash": "837b47cf0b4710b8dfbcd09c1f817a04", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 18, "line": 267}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 18, "line": 267}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallSet.h", "reportHash": "f72b6eaf57cf1c6d93a72222cfd28320", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 18, "line": 267}, "message": "'operator==' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallSet.h", "reportHash": "6fe2102ddacb0f07540c515568a0f48a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 18, "line": 279}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 18, "line": 279}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallSet.h", "reportHash": "c73ea865ff504400c510edb19bd4b2d2", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 18, "line": 279}, "message": "'operator!=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallSet.h", "reportHash": "6961c293e0accaf2f0ada9d79472424e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 68}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h", "reportHash": "77ad6ae0f278c2e992339bdb7d72a117", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 77}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h", "reportHash": "63d3b8a6c8af18c1e9654b904fe2c856", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 20, "line": 426}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h", "reportHash": "6f4939980d8990fbadf4213c94694038", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 20, "line": 435}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h", "reportHash": "934cbc4460e493fb69088a6180721809", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 540}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h", "reportHash": "c97fc6fb4abed51785ed554301da62be", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 544}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h", "reportHash": "46665aff944618a5e348bb7249f405cc", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 24, "line": 144}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 24, "line": 144}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist_iterator.h", "reportHash": "6caae4d8e2b71b786a657d43e44674f2", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 24, "line": 147}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 24, "line": 147}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist_iterator.h", "reportHash": "2a3043826643399afc5fab00f8249cd1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 55, "file": 25, "line": 265}, "message": "'LHS' of type 'llvm::iterator_adaptor_base<llvm::DIEValueList::const_value_iterator, llvm::IntrusiveBackList<llvm::DIEValueList::Node>::const_iterator, std::forward_iterator_tag, const llvm::DIEValue, long, const llvm::DIEValue *, const llvm::DIEValue &>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "reportHash": "f7f7f7934cc1e2ce533a9ec7d16e5ba4", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 55, "file": 25, "line": 265}, "message": "'LHS' of type 'llvm::iterator_adaptor_base<llvm::DIEValueList::value_iterator, llvm::IntrusiveBackList<llvm::DIEValueList::Node>::iterator, std::forward_iterator_tag, llvm::DIEValue, long, llvm::DIEValue *, llvm::DIEValue &>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "reportHash": "019b18fa55922712a19ea34c8cc3380e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 55, "file": 25, "line": 265}, "message": "'LHS' of type 'llvm::iterator_adaptor_base<llvm::User::const_value_op_iterator, const llvm::Use *, std::random_access_iterator_tag, const llvm::Value *, long, const llvm::Value *, const llvm::Value *>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "reportHash": "fc1a9de8cdd3985e2d5d2ddfe39cf51d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 55, "file": 25, "line": 265}, "message": "'LHS' of type 'llvm::iterator_adaptor_base<llvm::User::value_op_iterator, llvm::Use *, std::random_access_iterator_tag, llvm::Value *, long, llvm::Value *, llvm::Value *>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "reportHash": "d7bad9bfdcaa944107bf86f254bf290a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 55, "file": 25, "line": 266}, "message": "'RHS' of type 'llvm::iterator_adaptor_base<llvm::DIEValueList::const_value_iterator, llvm::IntrusiveBackList<llvm::DIEValueList::Node>::const_iterator, std::forward_iterator_tag, const llvm::DIEValue, long, const llvm::DIEValue *, const llvm::DIEValue &>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "reportHash": "b3c71acbc10dc845ac4702687e810078", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 55, "file": 25, "line": 266}, "message": "'RHS' of type 'llvm::iterator_adaptor_base<llvm::DIEValueList::value_iterator, llvm::IntrusiveBackList<llvm::DIEValueList::Node>::iterator, std::forward_iterator_tag, llvm::DIEValue, long, llvm::DIEValue *, llvm::DIEValue &>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "reportHash": "5f00b657e6686115b695c9ca07d1fda1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 55, "file": 25, "line": 266}, "message": "'RHS' of type 'llvm::iterator_adaptor_base<llvm::User::const_value_op_iterator, const llvm::Use *, std::random_access_iterator_tag, const llvm::Value *, long, const llvm::Value *, const llvm::Value *>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "reportHash": "834aadc9bf2d34e696a1024c7f2cc6bb", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 55, "file": 25, "line": 266}, "message": "'RHS' of type 'llvm::iterator_adaptor_base<llvm::User::value_op_iterator, llvm::Use *, std::random_access_iterator_tag, llvm::Value *, long, llvm::Value *, llvm::Value *>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "reportHash": "3813a8c7500b121be5f828a14543af22", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 54, "file": 25, "line": 269}, "message": "'LHS' of type 'llvm::iterator_adaptor_base<llvm::DIEValueList::const_value_iterator, llvm::IntrusiveBackList<llvm::DIEValueList::Node>::const_iterator, std::forward_iterator_tag, const llvm::DIEValue, long, const llvm::DIEValue *, const llvm::DIEValue &>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "reportHash": "a0b707c3113fd36542fe7d7b15f9299f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 54, "file": 25, "line": 269}, "message": "'LHS' of type 'llvm::iterator_adaptor_base<llvm::DIEValueList::value_iterator, llvm::IntrusiveBackList<llvm::DIEValueList::Node>::iterator, std::forward_iterator_tag, llvm::DIEValue, long, llvm::DIEValue *, llvm::DIEValue &>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "reportHash": "00be0ae04adf1cfee21277e3a5beaf88", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 54, "file": 25, "line": 269}, "message": "'LHS' of type 'llvm::iterator_adaptor_base<llvm::User::const_value_op_iterator, const llvm::Use *, std::random_access_iterator_tag, const llvm::Value *, long, const llvm::Value *, const llvm::Value *>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "reportHash": "4e12170c00142557ecf328e77b6c8dfd", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 54, "file": 25, "line": 269}, "message": "'LHS' of type 'llvm::iterator_adaptor_base<llvm::User::value_op_iterator, llvm::Use *, std::random_access_iterator_tag, llvm::Value *, long, llvm::Value *, llvm::Value *>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "reportHash": "b83ef07d8d7cf8b0a8971344810bab68", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 54, "file": 25, "line": 270}, "message": "'RHS' of type 'llvm::iterator_adaptor_base<llvm::DIEValueList::const_value_iterator, llvm::IntrusiveBackList<llvm::DIEValueList::Node>::const_iterator, std::forward_iterator_tag, const llvm::DIEValue, long, const llvm::DIEValue *, const llvm::DIEValue &>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "reportHash": "abd61bddd9be7eb0e8cc32fc2839db35", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 54, "file": 25, "line": 270}, "message": "'RHS' of type 'llvm::iterator_adaptor_base<llvm::DIEValueList::value_iterator, llvm::IntrusiveBackList<llvm::DIEValueList::Node>::iterator, std::forward_iterator_tag, llvm::DIEValue, long, llvm::DIEValue *, llvm::DIEValue &>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "reportHash": "acefd5e186b8028b5afd85654c14713d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 54, "file": 25, "line": 270}, "message": "'RHS' of type 'llvm::iterator_adaptor_base<llvm::User::const_value_op_iterator, const llvm::Use *, std::random_access_iterator_tag, const llvm::Value *, long, const llvm::Value *, const llvm::Value *>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "reportHash": "ccbdbbdec3fb6bd3fcfb1e69f26cdf9b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 54, "file": 25, "line": 270}, "message": "'RHS' of type 'llvm::iterator_adaptor_base<llvm::User::value_op_iterator, llvm::Use *, std::random_access_iterator_tag, llvm::Value *, long, llvm::Value *, llvm::Value *>' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "reportHash": "076194494aa9e158275f1ec5634464bb", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 45, "file": 26, "line": 410}, "message": "'LHS' of type 'llvm::wasm::WasmSignature' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h", "reportHash": "2d0b014856770a8ad16c5d22e301108f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 71, "file": 26, "line": 410}, "message": "'RHS' of type 'llvm::wasm::WasmSignature' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h", "reportHash": "e16cd901e3bb9d4d455b2f67c7f5de9f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 45, "file": 26, "line": 415}, "message": "'LHS' of type 'llvm::wasm::WasmSignature' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h", "reportHash": "f044a5d180acc5f86a4c423ba2db9758", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 71, "file": 26, "line": 415}, "message": "'RHS' of type 'llvm::wasm::WasmSignature' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h", "reportHash": "b98454d59b8466a2e711ac68697a1698", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 27, "line": 118}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h", "reportHash": "eae9035565f3d2b94e2f7269a60f07d9", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 28, "line": 609}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "29bf1da79142b5c01f6efaafab97aebc", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 28, "line": 631}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "d5821d981f7acd17ce1e6e4276aa49f0", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 29, "line": 61}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DwarfStringPoolEntry.h", "reportHash": "74aeb59a807a45899de2918401242715", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 29, "line": 64}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DwarfStringPoolEntry.h", "reportHash": "f3cf9b2565735906b8c7a50684912c77", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 30, "line": 67}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h", "reportHash": "b4313009211ff4bff018af04c65691a3", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 30, "line": 71}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h", "reportHash": "f2cbdf84ed03c1857bf9447c760b068b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 31, "line": 184}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 31, "line": 184}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "reportHash": "bde8f6fc5a64eee3014ae38ba5d25f29", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 31, "line": 188}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 31, "line": 188}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "reportHash": "bde8f6fc5a64eee3014ae38ba5d25f29", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 31, "line": 188}, "message": "'operator==' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "reportHash": "6b6c016b5bc75ae5afba1f0ced0db995", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 31, "line": 192}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 31, "line": 192}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "reportHash": "ad7020224518f9dc7ea2aeeeab202c01", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 31, "line": 192}, "message": "'operator==' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "reportHash": "6c1940c754d386671263cad90d551501", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 31, "line": 196}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 31, "line": 196}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "reportHash": "bde8f6fc5a64eee3014ae38ba5d25f29", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 31, "line": 196}, "message": "'operator==' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "reportHash": "6b6c016b5bc75ae5afba1f0ced0db995", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 31, "line": 200}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 31, "line": 200}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "reportHash": "9ba3f3b24a60f08117fbc3a1b760f01b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 31, "line": 200}, "message": "'operator==' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "reportHash": "fda606530979297fa765b5080cecfaef", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 31, "line": 204}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 31, "line": 204}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "reportHash": "f42b07966a3d32fd20aacef0a9ec7e56", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 31, "line": 204}, "message": "'operator==' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "reportHash": "47d79ee282137f1b0d61efb6a4e0f6ce", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 31, "line": 207}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 31, "line": 207}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "reportHash": "a799a534bbe0adb12758caf79bf9ba92", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 31, "line": 207}, "message": "'operator==' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "reportHash": "b7a833b3dc3f68d0737807a3d97546d1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 31, "line": 210}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 31, "line": 210}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "reportHash": "bde8f6fc5a64eee3014ae38ba5d25f29", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 31, "line": 210}, "message": "'operator==' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "reportHash": "6b6c016b5bc75ae5afba1f0ced0db995", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 31, "line": 214}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 31, "line": 214}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "reportHash": "8ea907500343f9255c7b283b49e6338e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 31, "line": 214}, "message": "'operator==' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "reportHash": "a324e7633253308c29f47146a532adb3", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 31, "line": 219}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 31, "line": 219}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "reportHash": "e12790d2de8fcac5d624fed98381f268", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 31, "line": 223}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 31, "line": 223}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "reportHash": "e12790d2de8fcac5d624fed98381f268", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 31, "line": 223}, "message": "'operator!=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "reportHash": "3370b8b1549015144c6cd399a934813e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 31, "line": 227}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 31, "line": 227}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "reportHash": "1ea9bd0e5112ed0fba9a43e0479a83f8", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 31, "line": 227}, "message": "'operator!=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "reportHash": "d28b21a9d8818bd5c443336721e30ccc", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 31, "line": 231}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 31, "line": 231}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "reportHash": "e12790d2de8fcac5d624fed98381f268", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 31, "line": 231}, "message": "'operator!=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "reportHash": "3370b8b1549015144c6cd399a934813e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 31, "line": 235}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 31, "line": 235}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "reportHash": "4d9a5298ce7d46ac90aab98a4ff00c79", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 31, "line": 235}, "message": "'operator!=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "reportHash": "c793c1801832af79ea48f100f17f38e3", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 31, "line": 239}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 31, "line": 239}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "reportHash": "254fad0fee3495aed33ee54cc0c4e301", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 31, "line": 239}, "message": "'operator!=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "reportHash": "b91e988b9b547cd5533665d4cf4be923", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 31, "line": 242}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 31, "line": 242}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "reportHash": "08ee9d4c1cde0e208c20c5be794b7dbf", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 31, "line": 242}, "message": "'operator!=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "reportHash": "6adccf6fbf9cd5b7847b1b6e880f93a4", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 31, "line": 245}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 31, "line": 245}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "reportHash": "e12790d2de8fcac5d624fed98381f268", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 31, "line": 245}, "message": "'operator!=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "reportHash": "3370b8b1549015144c6cd399a934813e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 31, "line": 249}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 31, "line": 249}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "reportHash": "938a81fe28648512f6d2230c7fde0a80", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 31, "line": 249}, "message": "'operator!=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h", "reportHash": "55b32af6d7bbc47384cf4a28f9df7865", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 32, "line": 309}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 32, "line": 309}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h", "reportHash": "1fbde2854b4d844a2b8f01cc3e796a78", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 32, "line": 322}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 32, "line": 322}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h", "reportHash": "d6cb17bfcc77d29596dca50e65cc28e9", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 33, "line": 129}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/Register.h", "reportHash": "0564566c506eea68f44c48ed3bcf3876", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 33, "line": 130}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/Register.h", "reportHash": "a8b625feb112f85ea8fa8cf614e0709f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 33, "line": 131}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/Register.h", "reportHash": "cfa945757840fa83a20805f3cc58d3e4", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 33, "line": 132}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/Register.h", "reportHash": "4b2fcfbe9eb30663cdb3c26f6b2f6268", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 33, "line": 138}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/Register.h", "reportHash": "c02d9aabfaf151ee00397e35cd895396", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 33, "line": 139}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/Register.h", "reportHash": "66d13b76282d72912c2d105df0e34bff", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 33, "line": 140}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/Register.h", "reportHash": "28913c838361d0432bda67208b3eac13", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 33, "line": 141}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/Register.h", "reportHash": "b1b76913c5ea905b5d94ed7d8eb410df", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 33, "line": 143}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/Register.h", "reportHash": "3b73bfa65ddd18d664ef462d724fc94e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 33, "line": 144}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/Register.h", "reportHash": "062efaacd1cadbb3e6efe9c32e81c164", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 34, "line": 205}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Attributes.h", "reportHash": "0742489267983ad61249bec3b1b1a28b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 34, "line": 206}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Attributes.h", "reportHash": "921947c7b71a264b738c770c589566bb", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 34, "line": 209}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Attributes.h", "reportHash": "3af3f2fbc4375f30808ebd2036d64b1e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 34, "line": 263}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Attributes.h", "reportHash": "7217ee0cdb67c7bfb416cf1d05411f0d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 34, "line": 264}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Attributes.h", "reportHash": "89f93eea26f13fd8b648a6c9b4ef5abe", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 34, "line": 712}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Attributes.h", "reportHash": "8b52d0a36a32c03d17399b77462c79b4", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 34, "line": 713}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Attributes.h", "reportHash": "bc1c72bb2fd20f37b94a5e5fa80a4f26", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 34, "line": 945}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Attributes.h", "reportHash": "49fda4b95b9855275bd74b8c1c9a597f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 34, "line": 946}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Attributes.h", "reportHash": "6c484f77ff37a4ea4af53077892c7b24", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 35, "line": 336}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/BasicBlock.h", "reportHash": "bc101b746314a80613825f7a359433ab", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 81}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DataLayout.h", "reportHash": "bbd0bd3911d3c95c60654b970b94306e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 102}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DataLayout.h", "reportHash": "96fe7c823d1f743c06c411ded0ec2c66", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 227}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DataLayout.h", "reportHash": "6d6d967fa34016e173c3e202cd18f2a3", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 228}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DataLayout.h", "reportHash": "f8cb39151698f145ecf3f5efb3688f1d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 37, "line": 104}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h", "reportHash": "662077aec435255efa859da5d99c5a3f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 37, "line": 105}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h", "reportHash": "d73dc2a30d50d138f04a906c78f786b5", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 37, "line": 552}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h", "reportHash": "98556aa1f80186b7fc03a334ac5debdc", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 37, "line": 555}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h", "reportHash": "848c006eceae185bdc607a6c914c0405", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 37, "line": 2661}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h", "reportHash": "eacb647dde2762df487b92a4be210def", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 37, "line": 2664}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h", "reportHash": "9bdb2a79f1bf4834e80a1005cbe960f0", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 37, "line": 2859}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 37, "line": 2859}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h", "reportHash": "8cc798bea3e3a419c68969641410c138", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 58, "file": 37, "line": 2859}, "message": "'A' of type 'DIExpression::FragmentInfo' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h", "reportHash": "64c84b90dda60a5f4d8dcbcf7f8b6722", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 58, "file": 37, "line": 2860}, "message": "'B' of type 'DIExpression::FragmentInfo' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h", "reportHash": "0d4f881e6aa5d17d08dfa9f1502d283b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 37, "line": 2865}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 37, "line": 2865}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h", "reportHash": "5320cd16c728d95a05b226f741f227ce", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 57, "file": 37, "line": 2865}, "message": "'A' of type 'DIExpression::FragmentInfo' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h", "reportHash": "aa2136ab2719c03119b9220f966cd98b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 57, "file": 37, "line": 2866}, "message": "'B' of type 'DIExpression::FragmentInfo' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h", "reportHash": "02d0007a203e77ac6026543072affd13", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 37, "line": 3613}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h", "reportHash": "362fb6eb3f3823bf331e537d6099ffc3", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 37, "line": 3618}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h", "reportHash": "0097d931cbe33c48c81b5e3fa4ee4795", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 38, "line": 105}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DebugLoc.h", "reportHash": "97a69696b3ecdd4694eb648d9e327dd8", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 38, "line": 106}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DebugLoc.h", "reportHash": "b071ccf9fd45877db269a687ec655109", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 39, "line": 49}, "message": "'llvm/IR/IntrinsicEnums.inc' file not found"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Intrinsics.h", "reportHash": "66fd43c8c64831667bf194039dfffe87", "checkerName": "clang-diagnostic-error", "reviewStatus": null, "severity": "CRITICAL"}, {"events": [{"location": {"col": 8, "file": 40, "line": 652}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "reportHash": "8d27e5fbd3db9b7e41dd9f6485cbba2e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 40, "line": 657}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "reportHash": "a8f1a104ea8d864b9af2149662be123b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 40, "line": 1269}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "reportHash": "a879cc215b7c13de76ded9471b2fcc15", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 40, "line": 1270}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "reportHash": "016c298b6a17190b1c6a9302597537ca", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 40, "line": 1404}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "reportHash": "ec7be3c5a2c43e11c150995450fd0307", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 40, "line": 1405}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "reportHash": "2f9785cc0f2b7b978cc6157f92bd84c5", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 41, "line": 746}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Module.h", "reportHash": "259783cb50b34eda3b1ee7790dd9c49e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 41, "line": 750}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Module.h", "reportHash": "b287c5ee8b9a2eb411c399479d821b41", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 42, "line": 79}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/TrackingMDRef.h", "reportHash": "1cef1c8cd6c502bd18369073d19b45ab", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 42, "line": 80}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/TrackingMDRef.h", "reportHash": "196018dd6eda0dc74d3121600142533f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 42, "line": 131}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/TrackingMDRef.h", "reportHash": "60c6288889a66db45836770c1ed81117", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 42, "line": 132}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/TrackingMDRef.h", "reportHash": "0a0bde839dc44a69fae272e0b67a965e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 43, "line": 137}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Value.h", "reportHash": "832bac67f25dbd554710975672c51269", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 43, "line": 138}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Value.h", "reportHash": "28712e74d940b76a6fc7e0af53c4d920", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 43, "line": 174}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Value.h", "reportHash": "68aa2c242881fd13cc7c36d7794da47f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 43, "line": 175}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Value.h", "reportHash": "343f8adfcd0359a61ff941c8b14fcc17", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 44, "line": 362}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ValueMap.h", "reportHash": "7b8670d82513ebf244690a7c58fa421a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 44, "line": 365}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ValueMap.h", "reportHash": "1468dc764f7adac7afe6ada7e131f0a9", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 44, "line": 414}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ValueMap.h", "reportHash": "4e9fda2ae01c4b34f15c0f43706fd300", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 44, "line": 417}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ValueMap.h", "reportHash": "7fa11cf60a491da69ebdffbf801ebefc", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 45, "line": 48}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/LaneBitmask.h", "reportHash": "a166f4976efa421ef5fd31e555101ce9", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 45, "line": 49}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/LaneBitmask.h", "reportHash": "d88382229f983a67cb1ca2fe82d6f529", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 45, "line": 50}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/LaneBitmask.h", "reportHash": "8667c1e4fa9a614239b78f1f0a394e61", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 46, "line": 77}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegister.h", "reportHash": "dfc4672049377a08c1fd4a2679359178", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 46, "line": 78}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegister.h", "reportHash": "f783acbf59e26ad1c9c2bf320aa445f0", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 46, "line": 84}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegister.h", "reportHash": "f94aa0c064d08ddd3a63a598ea5a75dc", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 46, "line": 85}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegister.h", "reportHash": "81ea00bc02939c882b68759fd57ef355", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 46, "line": 86}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegister.h", "reportHash": "fe672f965545f63b6e6a575a99eab808", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 46, "line": 87}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegister.h", "reportHash": "43194fcd083ab7fd5f50538fa09b2a9d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 46, "line": 89}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegister.h", "reportHash": "7ab9f5ac849de5a29e98c287a4e137c3", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 46, "line": 90}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegister.h", "reportHash": "f5dc033c914c34eff81fd3033faa16c5", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 47, "line": 138}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h", "reportHash": "000e90f1a292f273832d13c7a1b761f9", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 47, "line": 262}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h", "reportHash": "8f77930e41bc17b38825b21e22adb9f4", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 48, "line": 56}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCSchedule.h", "reportHash": "5990e45cfe2e64cb81b34f1ff05692ca", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 48, "line": 68}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCSchedule.h", "reportHash": "e65c2f968741977f9a2314eb47071525", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 48, "line": 82}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCSchedule.h", "reportHash": "a1bddf85379bd99877c9e23d3f480689", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 48, "line": 100}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCSchedule.h", "reportHash": "94327bd0dc39fe84f25c9901d8977b24", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 49, "line": 41}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h", "reportHash": "f1cdb7ca30b5074eda7d5688a43b5cfe", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 49, "line": 46}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h", "reportHash": "208ecd64099affa38f0a642ff0ca0e16", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 49, "line": 61}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h", "reportHash": "f1cdb7ca30b5074eda7d5688a43b5cfe", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 49, "line": 66}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h", "reportHash": "3da5d24f9ca0482da3ce4b3f026bc84e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 50, "line": 30}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCWinEH.h", "reportHash": "bedb62f7646c493f3ed592a7d1847842", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 50, "line": 36}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCWinEH.h", "reportHash": "3904501b2ff84146b94cf2199031119d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 51, "line": 39}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MachineLocation.h", "reportHash": "0ca54dc81220ad285012d6537bec1ac5", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 51, "line": 52}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 51, "line": 52}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MachineLocation.h", "reportHash": "992d1fe63a663ade771857688028fb6c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 47, "file": 51, "line": 52}, "message": "'LHS' of type 'llvm::MachineLocation' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MachineLocation.h", "reportHash": "25ef9e8c6e07347bc944342f1cd4392c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 75, "file": 51, "line": 52}, "message": "'RHS' of type 'llvm::MachineLocation' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MachineLocation.h", "reportHash": "a4590c93cbb284db236a961523434acc", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 55, "line": 176}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BranchProbability.h", "reportHash": "20583d923f09e987a2e4d270715157c6", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 55, "line": 177}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BranchProbability.h", "reportHash": "f8004c34cd3fca0a22726c1504eee0e9", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 55, "line": 179}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BranchProbability.h", "reportHash": "7a73f414b4f8c91eac6363f444887a89", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 55, "line": 185}, "message": "'operator>' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BranchProbability.h", "reportHash": "0ee154f07a8e9fd03c891625ce004c40", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 55, "line": 191}, "message": "'operator<=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BranchProbability.h", "reportHash": "d55dad81fb959e0478f2be000ace4a6a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 55, "line": 197}, "message": "'operator>=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/BranchProbability.h", "reportHash": "6258d856a75844bc37310a83fe52fc41", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 59, "line": 205}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/LowLevelTypeImpl.h", "reportHash": "02a5479e9cc2251124e0215be576cfc3", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 59, "line": 210}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/LowLevelTypeImpl.h", "reportHash": "2a88ac593a84402cb3d4886be74e8273", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 61, "line": 301}, "message": "'operator>' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/MachineValueType.h", "reportHash": "81dee51d5ac5457164e52b1d988cf404", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 61, "line": 302}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/MachineValueType.h", "reportHash": "ec315359e6d8a382d51f18a393c727eb", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 61, "line": 303}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/MachineValueType.h", "reportHash": "b75abae7ebe768c40a6bbee7bcff1a8a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 61, "line": 304}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/MachineValueType.h", "reportHash": "ba385f62270cc762137ee65c7b5e71dc", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 61, "line": 305}, "message": "'operator>=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/MachineValueType.h", "reportHash": "254ea414011f85a36fd1132e5d86c55c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 61, "line": 306}, "message": "'operator<=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/MachineValueType.h", "reportHash": "7cfc605467987aa5e1f1d7435c3c721c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 61, "line": 1336}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/MachineValueType.h", "reportHash": "418583167b1e3fdeff2713ba5c2aac0f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 69, "line": 32}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h", "reportHash": "0d1c65dc07deb869dcb8893446a1dc43", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 69, "line": 90}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 69, "line": 90}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h", "reportHash": "c8750d034bdbf2b792da92f46cdde4d2", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 69, "line": 167}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 69, "line": 167}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h", "reportHash": "c3e1a01e310425d7391ccdcdac059f7a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 45, "file": 69, "line": 167}, "message": "'' of type 'llvm::DbgValueLoc' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h", "reportHash": "f07f39083fa42fad452b61e80fc38c1f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 66, "file": 69, "line": 167}, "message": "'' of type 'llvm::DbgValueLoc' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h", "reportHash": "45efde02a1a5d7da7f7492261b1089c2", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 69, "line": 168}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 69, "line": 168}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h", "reportHash": "8771258157c2ed5024ed8316a9fb157e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 44, "file": 69, "line": 168}, "message": "'' of type 'llvm::DbgValueLoc' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h", "reportHash": "0b436694cc77b00cc7e492956e4fe347", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 65, "file": 69, "line": 168}, "message": "'' of type 'llvm::DbgValueLoc' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h", "reportHash": "0744a98890faac557ad732075c15032c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 69, "line": 243}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 69, "line": 243}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h", "reportHash": "1869a844d8594c26616db1979ac0ce19", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 69, "line": 263}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 69, "line": 263}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h", "reportHash": "a2c69fb27a9d2d6004abba2575d0b7a8", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 43, "file": 69, "line": 263}, "message": "'A' of type 'llvm::DbgValueLoc' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h", "reportHash": "052c847be7236d221d11be0928267671", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 65, "file": 69, "line": 263}, "message": "'B' of type 'llvm::DbgValueLoc' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h", "reportHash": "2c3437b867b5b1025f361a2ade98a405", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 69, "line": 269}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 69, "line": 269}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h", "reportHash": "0765fd841df8958b1f94c8547de678ee", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 69, "line": 269}, "message": "'A' of type 'llvm::DbgValueLoc' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h", "reportHash": "bb97f2e82d3dbb2d4efa3df5e673f86e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 42, "file": 69, "line": 270}, "message": "'B' of type 'llvm::DbgValueLoc' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h", "reportHash": "22c28d0c1c60a9d02fcc056899d4dac7", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
