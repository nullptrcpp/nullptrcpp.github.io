<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"18": {"id": 18, "path": "/home/vsts/work/1/llvm-project/clang/lib/AST/ExprConstant.cpp", "content": "//===--- ExprConstant.cpp - Expression Constant Evaluator -----------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements the Expr constant evaluator.\n//\n// Constant expression evaluation produces four main results:\n//\n//  * A success/failure flag indicating whether constant folding was successful.\n//    This is the 'bool' return value used by most of the code in this file. A\n//    'false' return value indicates that constant folding has failed, and any\n//    appropriate diagnostic has already been produced.\n//\n//  * An evaluated result, valid only if constant folding has not failed.\n//\n//  * A flag indicating if evaluation encountered (unevaluated) side-effects.\n//    These arise in cases such as (sideEffect(), 0) and (sideEffect() || 1),\n//    where it is possible to determine the evaluated result regardless.\n//\n//  * A set of notes indicating why the evaluation was not a constant expression\n//    (under the C++11 / C++1y rules only, at the moment), or, if folding failed\n//    too, why the expression could not be folded.\n//\n// If we are checking for a potential constant expression, failure to constant\n// fold a potential constant sub-expression will be indicated by a 'false'\n// return value (the expression could not be folded) and no diagnostic (the\n// expression is not necessarily non-constant).\n//\n//===----------------------------------------------------------------------===//\n\n#include \"Interp/Context.h\"\n#include \"Interp/Frame.h\"\n#include \"Interp/State.h\"\n#include \"clang/AST/APValue.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/ASTDiagnostic.h\"\n#include \"clang/AST/ASTLambda.h\"\n#include \"clang/AST/Attr.h\"\n#include \"clang/AST/CXXInheritance.h\"\n#include \"clang/AST/CharUnits.h\"\n#include \"clang/AST/CurrentSourceLocExprScope.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/OSLog.h\"\n#include \"clang/AST/OptionalDiagnostic.h\"\n#include \"clang/AST/RecordLayout.h\"\n#include \"clang/AST/StmtVisitor.h\"\n#include \"clang/AST/TypeLoc.h\"\n#include \"clang/Basic/Builtins.h\"\n#include \"clang/Basic/TargetInfo.h\"\n#include \"llvm/ADT/APFixedPoint.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallBitVector.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/SaveAndRestore.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cstring>\n#include <functional>\n\n#define DEBUG_TYPE \"exprconstant\"\n\nusing namespace clang;\nusing llvm::APFixedPoint;\nusing llvm::APInt;\nusing llvm::APSInt;\nusing llvm::APFloat;\nusing llvm::FixedPointSemantics;\nusing llvm::Optional;\n\nnamespace {\n  struct LValue;\n  class CallStackFrame;\n  class EvalInfo;\n\n  using SourceLocExprScopeGuard =\n      CurrentSourceLocExprScope::SourceLocExprScopeGuard;\n\n  static QualType getType(APValue::LValueBase B) {\n    return B.getType();\n  }\n\n  /// Get an LValue path entry, which is known to not be an array index, as a\n  /// field declaration.\n  static const FieldDecl *getAsField(APValue::LValuePathEntry E) {\n    return dyn_cast_or_null<FieldDecl>(E.getAsBaseOrMember().getPointer());\n  }\n  /// Get an LValue path entry, which is known to not be an array index, as a\n  /// base class declaration.\n  static const CXXRecordDecl *getAsBaseClass(APValue::LValuePathEntry E) {\n    return dyn_cast_or_null<CXXRecordDecl>(E.getAsBaseOrMember().getPointer());\n  }\n  /// Determine whether this LValue path entry for a base class names a virtual\n  /// base class.\n  static bool isVirtualBaseClass(APValue::LValuePathEntry E) {\n    return E.getAsBaseOrMember().getInt();\n  }\n\n  /// Given an expression, determine the type used to store the result of\n  /// evaluating that expression.\n  static QualType getStorageType(const ASTContext &Ctx, const Expr *E) {\n    if (E->isRValue())\n      return E->getType();\n    return Ctx.getLValueReferenceType(E->getType());\n  }\n\n  /// Given a CallExpr, try to get the alloc_size attribute. May return null.\n  static const AllocSizeAttr *getAllocSizeAttr(const CallExpr *CE) {\n    const FunctionDecl *Callee = CE->getDirectCallee();\n    return Callee ? Callee->getAttr<AllocSizeAttr>() : nullptr;\n  }\n\n  /// Attempts to unwrap a CallExpr (with an alloc_size attribute) from an Expr.\n  /// This will look through a single cast.\n  ///\n  /// Returns null if we couldn't unwrap a function with alloc_size.\n  static const CallExpr *tryUnwrapAllocSizeCall(const Expr *E) {\n    if (!E->getType()->isPointerType())\n      return nullptr;\n\n    E = E->IgnoreParens();\n    // If we're doing a variable assignment from e.g. malloc(N), there will\n    // probably be a cast of some kind. In exotic cases, we might also see a\n    // top-level ExprWithCleanups. Ignore them either way.\n    if (const auto *FE = dyn_cast<FullExpr>(E))\n      E = FE->getSubExpr()->IgnoreParens();\n\n    if (const auto *Cast = dyn_cast<CastExpr>(E))\n      E = Cast->getSubExpr()->IgnoreParens();\n\n    if (const auto *CE = dyn_cast<CallExpr>(E))\n      return getAllocSizeAttr(CE) ? CE : nullptr;\n    return nullptr;\n  }\n\n  /// Determines whether or not the given Base contains a call to a function\n  /// with the alloc_size attribute.\n  static bool isBaseAnAllocSizeCall(APValue::LValueBase Base) {\n    const auto *E = Base.dyn_cast<const Expr *>();\n    return E && E->getType()->isPointerType() && tryUnwrapAllocSizeCall(E);\n  }\n\n  /// Determines whether the given kind of constant expression is only ever\n  /// used for name mangling. If so, it's permitted to reference things that we\n  /// can't generate code for (in particular, dllimported functions).\n  static bool isForManglingOnly(ConstantExprKind Kind) {\n    switch (Kind) {\n    case ConstantExprKind::Normal:\n    case ConstantExprKind::ClassTemplateArgument:\n    case ConstantExprKind::ImmediateInvocation:\n      // Note that non-type template arguments of class type are emitted as\n      // template parameter objects.\n      return false;\n\n    case ConstantExprKind::NonClassTemplateArgument:\n      return true;\n    }\n    llvm_unreachable(\"unknown ConstantExprKind\");\n  }\n\n  static bool isTemplateArgument(ConstantExprKind Kind) {\n    switch (Kind) {\n    case ConstantExprKind::Normal:\n    case ConstantExprKind::ImmediateInvocation:\n      return false;\n\n    case ConstantExprKind::ClassTemplateArgument:\n    case ConstantExprKind::NonClassTemplateArgument:\n      return true;\n    }\n    llvm_unreachable(\"unknown ConstantExprKind\");\n  }\n\n  /// The bound to claim that an array of unknown bound has.\n  /// The value in MostDerivedArraySize is undefined in this case. So, set it\n  /// to an arbitrary value that's likely to loudly break things if it's used.\n  static const uint64_t AssumedSizeForUnsizedArray =\n      std::numeric_limits<uint64_t>::max() / 2;\n\n  /// Determines if an LValue with the given LValueBase will have an unsized\n  /// array in its designator.\n  /// Find the path length and type of the most-derived subobject in the given\n  /// path, and find the size of the containing array, if any.\n  static unsigned\n  findMostDerivedSubobject(ASTContext &Ctx, APValue::LValueBase Base,\n                           ArrayRef<APValue::LValuePathEntry> Path,\n                           uint64_t &ArraySize, QualType &Type, bool &IsArray,\n                           bool &FirstEntryIsUnsizedArray) {\n    // This only accepts LValueBases from APValues, and APValues don't support\n    // arrays that lack size info.\n    assert(!isBaseAnAllocSizeCall(Base) &&\n           \"Unsized arrays shouldn't appear here\");\n    unsigned MostDerivedLength = 0;\n    Type = getType(Base);\n\n    for (unsigned I = 0, N = Path.size(); I != N; ++I) {\n      if (Type->isArrayType()) {\n        const ArrayType *AT = Ctx.getAsArrayType(Type);\n        Type = AT->getElementType();\n        MostDerivedLength = I + 1;\n        IsArray = true;\n\n        if (auto *CAT = dyn_cast<ConstantArrayType>(AT)) {\n          ArraySize = CAT->getSize().getZExtValue();\n        } else {\n          assert(I == 0 && \"unexpected unsized array designator\");\n          FirstEntryIsUnsizedArray = true;\n          ArraySize = AssumedSizeForUnsizedArray;\n        }\n      } else if (Type->isAnyComplexType()) {\n        const ComplexType *CT = Type->castAs<ComplexType>();\n        Type = CT->getElementType();\n        ArraySize = 2;\n        MostDerivedLength = I + 1;\n        IsArray = true;\n      } else if (const FieldDecl *FD = getAsField(Path[I])) {\n        Type = FD->getType();\n        ArraySize = 0;\n        MostDerivedLength = I + 1;\n        IsArray = false;\n      } else {\n        // Path[I] describes a base class.\n        ArraySize = 0;\n        IsArray = false;\n      }\n    }\n    return MostDerivedLength;\n  }\n\n  /// A path from a glvalue to a subobject of that glvalue.\n  struct SubobjectDesignator {\n    /// True if the subobject was named in a manner not supported by C++11. Such\n    /// lvalues can still be folded, but they are not core constant expressions\n    /// and we cannot perform lvalue-to-rvalue conversions on them.\n    unsigned Invalid : 1;\n\n    /// Is this a pointer one past the end of an object?\n    unsigned IsOnePastTheEnd : 1;\n\n    /// Indicator of whether the first entry is an unsized array.\n    unsigned FirstEntryIsAnUnsizedArray : 1;\n\n    /// Indicator of whether the most-derived object is an array element.\n    unsigned MostDerivedIsArrayElement : 1;\n\n    /// The length of the path to the most-derived object of which this is a\n    /// subobject.\n    unsigned MostDerivedPathLength : 28;\n\n    /// The size of the array of which the most-derived object is an element.\n    /// This will always be 0 if the most-derived object is not an array\n    /// element. 0 is not an indicator of whether or not the most-derived object\n    /// is an array, however, because 0-length arrays are allowed.\n    ///\n    /// If the current array is an unsized array, the value of this is\n    /// undefined.\n    uint64_t MostDerivedArraySize;\n\n    /// The type of the most derived object referred to by this address.\n    QualType MostDerivedType;\n\n    typedef APValue::LValuePathEntry PathEntry;\n\n    /// The entries on the path from the glvalue to the designated subobject.\n    SmallVector<PathEntry, 8> Entries;\n\n    SubobjectDesignator() : Invalid(true) {}\n\n    explicit SubobjectDesignator(QualType T)\n        : Invalid(false), IsOnePastTheEnd(false),\n          FirstEntryIsAnUnsizedArray(false), MostDerivedIsArrayElement(false),\n          MostDerivedPathLength(0), MostDerivedArraySize(0),\n          MostDerivedType(T) {}\n\n    SubobjectDesignator(ASTContext &Ctx, const APValue &V)\n        : Invalid(!V.isLValue() || !V.hasLValuePath()), IsOnePastTheEnd(false),\n          FirstEntryIsAnUnsizedArray(false), MostDerivedIsArrayElement(false),\n          MostDerivedPathLength(0), MostDerivedArraySize(0) {\n      assert(V.isLValue() && \"Non-LValue used to make an LValue designator?\");\n      if (!Invalid) {\n        IsOnePastTheEnd = V.isLValueOnePastTheEnd();\n        ArrayRef<PathEntry> VEntries = V.getLValuePath();\n        Entries.insert(Entries.end(), VEntries.begin(), VEntries.end());\n        if (V.getLValueBase()) {\n          bool IsArray = false;\n          bool FirstIsUnsizedArray = false;\n          MostDerivedPathLength = findMostDerivedSubobject(\n              Ctx, V.getLValueBase(), V.getLValuePath(), MostDerivedArraySize,\n              MostDerivedType, IsArray, FirstIsUnsizedArray);\n          MostDerivedIsArrayElement = IsArray;\n          FirstEntryIsAnUnsizedArray = FirstIsUnsizedArray;\n        }\n      }\n    }\n\n    void truncate(ASTContext &Ctx, APValue::LValueBase Base,\n                  unsigned NewLength) {\n      if (Invalid)\n        return;\n\n      assert(Base && \"cannot truncate path for null pointer\");\n      assert(NewLength <= Entries.size() && \"not a truncation\");\n\n      if (NewLength == Entries.size())\n        return;\n      Entries.resize(NewLength);\n\n      bool IsArray = false;\n      bool FirstIsUnsizedArray = false;\n      MostDerivedPathLength = findMostDerivedSubobject(\n          Ctx, Base, Entries, MostDerivedArraySize, MostDerivedType, IsArray,\n          FirstIsUnsizedArray);\n      MostDerivedIsArrayElement = IsArray;\n      FirstEntryIsAnUnsizedArray = FirstIsUnsizedArray;\n    }\n\n    void setInvalid() {\n      Invalid = true;\n      Entries.clear();\n    }\n\n    /// Determine whether the most derived subobject is an array without a\n    /// known bound.\n    bool isMostDerivedAnUnsizedArray() const {\n      assert(!Invalid && \"Calling this makes no sense on invalid designators\");\n      return Entries.size() == 1 && FirstEntryIsAnUnsizedArray;\n    }\n\n    /// Determine what the most derived array's size is. Results in an assertion\n    /// failure if the most derived array lacks a size.\n    uint64_t getMostDerivedArraySize() const {\n      assert(!isMostDerivedAnUnsizedArray() && \"Unsized array has no size\");\n      return MostDerivedArraySize;\n    }\n\n    /// Determine whether this is a one-past-the-end pointer.\n    bool isOnePastTheEnd() const {\n      assert(!Invalid);\n      if (IsOnePastTheEnd)\n        return true;\n      if (!isMostDerivedAnUnsizedArray() && MostDerivedIsArrayElement &&\n          Entries[MostDerivedPathLength - 1].getAsArrayIndex() ==\n              MostDerivedArraySize)\n        return true;\n      return false;\n    }\n\n    /// Get the range of valid index adjustments in the form\n    ///   {maximum value that can be subtracted from this pointer,\n    ///    maximum value that can be added to this pointer}\n    std::pair<uint64_t, uint64_t> validIndexAdjustments() {\n      if (Invalid || isMostDerivedAnUnsizedArray())\n        return {0, 0};\n\n      // [expr.add]p4: For the purposes of these operators, a pointer to a\n      // nonarray object behaves the same as a pointer to the first element of\n      // an array of length one with the type of the object as its element type.\n      bool IsArray = MostDerivedPathLength == Entries.size() &&\n                     MostDerivedIsArrayElement;\n      uint64_t ArrayIndex = IsArray ? Entries.back().getAsArrayIndex()\n                                    : (uint64_t)IsOnePastTheEnd;\n      uint64_t ArraySize =\n          IsArray ? getMostDerivedArraySize() : (uint64_t)1;\n      return {ArrayIndex, ArraySize - ArrayIndex};\n    }\n\n    /// Check that this refers to a valid subobject.\n    bool isValidSubobject() const {\n      if (Invalid)\n        return false;\n      return !isOnePastTheEnd();\n    }\n    /// Check that this refers to a valid subobject, and if not, produce a\n    /// relevant diagnostic and set the designator as invalid.\n    bool checkSubobject(EvalInfo &Info, const Expr *E, CheckSubobjectKind CSK);\n\n    /// Get the type of the designated object.\n    QualType getType(ASTContext &Ctx) const {\n      assert(!Invalid && \"invalid designator has no subobject type\");\n      return MostDerivedPathLength == Entries.size()\n                 ? MostDerivedType\n                 : Ctx.getRecordType(getAsBaseClass(Entries.back()));\n    }\n\n    /// Update this designator to refer to the first element within this array.\n    void addArrayUnchecked(const ConstantArrayType *CAT) {\n      Entries.push_back(PathEntry::ArrayIndex(0));\n\n      // This is a most-derived object.\n      MostDerivedType = CAT->getElementType();\n      MostDerivedIsArrayElement = true;\n      MostDerivedArraySize = CAT->getSize().getZExtValue();\n      MostDerivedPathLength = Entries.size();\n    }\n    /// Update this designator to refer to the first element within the array of\n    /// elements of type T. This is an array of unknown size.\n    void addUnsizedArrayUnchecked(QualType ElemTy) {\n      Entries.push_back(PathEntry::ArrayIndex(0));\n\n      MostDerivedType = ElemTy;\n      MostDerivedIsArrayElement = true;\n      // The value in MostDerivedArraySize is undefined in this case. So, set it\n      // to an arbitrary value that's likely to loudly break things if it's\n      // used.\n      MostDerivedArraySize = AssumedSizeForUnsizedArray;\n      MostDerivedPathLength = Entries.size();\n    }\n    /// Update this designator to refer to the given base or member of this\n    /// object.\n    void addDeclUnchecked(const Decl *D, bool Virtual = false) {\n      Entries.push_back(APValue::BaseOrMemberType(D, Virtual));\n\n      // If this isn't a base class, it's a new most-derived object.\n      if (const FieldDecl *FD = dyn_cast<FieldDecl>(D)) {\n        MostDerivedType = FD->getType();\n        MostDerivedIsArrayElement = false;\n        MostDerivedArraySize = 0;\n        MostDerivedPathLength = Entries.size();\n      }\n    }\n    /// Update this designator to refer to the given complex component.\n    void addComplexUnchecked(QualType EltTy, bool Imag) {\n      Entries.push_back(PathEntry::ArrayIndex(Imag));\n\n      // This is technically a most-derived object, though in practice this\n      // is unlikely to matter.\n      MostDerivedType = EltTy;\n      MostDerivedIsArrayElement = true;\n      MostDerivedArraySize = 2;\n      MostDerivedPathLength = Entries.size();\n    }\n    void diagnoseUnsizedArrayPointerArithmetic(EvalInfo &Info, const Expr *E);\n    void diagnosePointerArithmetic(EvalInfo &Info, const Expr *E,\n                                   const APSInt &N);\n    /// Add N to the address of this subobject.\n    void adjustIndex(EvalInfo &Info, const Expr *E, APSInt N) {\n      if (Invalid || !N) return;\n      uint64_t TruncatedN = N.extOrTrunc(64).getZExtValue();\n      if (isMostDerivedAnUnsizedArray()) {\n        diagnoseUnsizedArrayPointerArithmetic(Info, E);\n        // Can't verify -- trust that the user is doing the right thing (or if\n        // not, trust that the caller will catch the bad behavior).\n        // FIXME: Should we reject if this overflows, at least?\n        Entries.back() = PathEntry::ArrayIndex(\n            Entries.back().getAsArrayIndex() + TruncatedN);\n        return;\n      }\n\n      // [expr.add]p4: For the purposes of these operators, a pointer to a\n      // nonarray object behaves the same as a pointer to the first element of\n      // an array of length one with the type of the object as its element type.\n      bool IsArray = MostDerivedPathLength == Entries.size() &&\n                     MostDerivedIsArrayElement;\n      uint64_t ArrayIndex = IsArray ? Entries.back().getAsArrayIndex()\n                                    : (uint64_t)IsOnePastTheEnd;\n      uint64_t ArraySize =\n          IsArray ? getMostDerivedArraySize() : (uint64_t)1;\n\n      if (N < -(int64_t)ArrayIndex || N > ArraySize - ArrayIndex) {\n        // Calculate the actual index in a wide enough type, so we can include\n        // it in the note.\n        N = N.extend(std::max<unsigned>(N.getBitWidth() + 1, 65));\n        (llvm::APInt&)N += ArrayIndex;\n        assert(N.ugt(ArraySize) && \"bounds check failed for in-bounds index\");\n        diagnosePointerArithmetic(Info, E, N);\n        setInvalid();\n        return;\n      }\n\n      ArrayIndex += TruncatedN;\n      assert(ArrayIndex <= ArraySize &&\n             \"bounds check succeeded for out-of-bounds index\");\n\n      if (IsArray)\n        Entries.back() = PathEntry::ArrayIndex(ArrayIndex);\n      else\n        IsOnePastTheEnd = (ArrayIndex != 0);\n    }\n  };\n\n  /// A scope at the end of which an object can need to be destroyed.\n  enum class ScopeKind {\n    Block,\n    FullExpression,\n    Call\n  };\n\n  /// A reference to a particular call and its arguments.\n  struct CallRef {\n    CallRef() : OrigCallee(), CallIndex(0), Version() {}\n    CallRef(const FunctionDecl *Callee, unsigned CallIndex, unsigned Version)\n        : OrigCallee(Callee), CallIndex(CallIndex), Version(Version) {}\n\n    explicit operator bool() const { return OrigCallee; }\n\n    /// Get the parameter that the caller initialized, corresponding to the\n    /// given parameter in the callee.\n    const ParmVarDecl *getOrigParam(const ParmVarDecl *PVD) const {\n      return OrigCallee ? OrigCallee->getParamDecl(PVD->getFunctionScopeIndex())\n                        : PVD;\n    }\n\n    /// The callee at the point where the arguments were evaluated. This might\n    /// be different from the actual callee (a different redeclaration, or a\n    /// virtual override), but this function's parameters are the ones that\n    /// appear in the parameter map.\n    const FunctionDecl *OrigCallee;\n    /// The call index of the frame that holds the argument values.\n    unsigned CallIndex;\n    /// The version of the parameters corresponding to this call.\n    unsigned Version;\n  };\n\n  /// A stack frame in the constexpr call stack.\n  class CallStackFrame : public interp::Frame {\n  public:\n    EvalInfo &Info;\n\n    /// Parent - The caller of this stack frame.\n    CallStackFrame *Caller;\n\n    /// Callee - The function which was called.\n    const FunctionDecl *Callee;\n\n    /// This - The binding for the this pointer in this call, if any.\n    const LValue *This;\n\n    /// Information on how to find the arguments to this call. Our arguments\n    /// are stored in our parent's CallStackFrame, using the ParmVarDecl* as a\n    /// key and this value as the version.\n    CallRef Arguments;\n\n    /// Source location information about the default argument or default\n    /// initializer expression we're evaluating, if any.\n    CurrentSourceLocExprScope CurSourceLocExprScope;\n\n    // Note that we intentionally use std::map here so that references to\n    // values are stable.\n    typedef std::pair<const void *, unsigned> MapKeyTy;\n    typedef std::map<MapKeyTy, APValue> MapTy;\n    /// Temporaries - Temporary lvalues materialized within this stack frame.\n    MapTy Temporaries;\n\n    /// CallLoc - The location of the call expression for this call.\n    SourceLocation CallLoc;\n\n    /// Index - The call index of this call.\n    unsigned Index;\n\n    /// The stack of integers for tracking version numbers for temporaries.\n    SmallVector<unsigned, 2> TempVersionStack = {1};\n    unsigned CurTempVersion = TempVersionStack.back();\n\n    unsigned getTempVersion() const { return TempVersionStack.back(); }\n\n    void pushTempVersion() {\n      TempVersionStack.push_back(++CurTempVersion);\n    }\n\n    void popTempVersion() {\n      TempVersionStack.pop_back();\n    }\n\n    CallRef createCall(const FunctionDecl *Callee) {\n      return {Callee, Index, ++CurTempVersion};\n    }\n\n    // FIXME: Adding this to every 'CallStackFrame' may have a nontrivial impact\n    // on the overall stack usage of deeply-recursing constexpr evaluations.\n    // (We should cache this map rather than recomputing it repeatedly.)\n    // But let's try this and see how it goes; we can look into caching the map\n    // as a later change.\n\n    /// LambdaCaptureFields - Mapping from captured variables/this to\n    /// corresponding data members in the closure class.\n    llvm::DenseMap<const VarDecl *, FieldDecl *> LambdaCaptureFields;\n    FieldDecl *LambdaThisCaptureField;\n\n    CallStackFrame(EvalInfo &Info, SourceLocation CallLoc,\n                   const FunctionDecl *Callee, const LValue *This,\n                   CallRef Arguments);\n    ~CallStackFrame();\n\n    // Return the temporary for Key whose version number is Version.\n    APValue *getTemporary(const void *Key, unsigned Version) {\n      MapKeyTy KV(Key, Version);\n      auto LB = Temporaries.lower_bound(KV);\n      if (LB != Temporaries.end() && LB->first == KV)\n        return &LB->second;\n      // Pair (Key,Version) wasn't found in the map. Check that no elements\n      // in the map have 'Key' as their key.\n      assert((LB == Temporaries.end() || LB->first.first != Key) &&\n             (LB == Temporaries.begin() || std::prev(LB)->first.first != Key) &&\n             \"Element with key 'Key' found in map\");\n      return nullptr;\n    }\n\n    // Return the current temporary for Key in the map.\n    APValue *getCurrentTemporary(const void *Key) {\n      auto UB = Temporaries.upper_bound(MapKeyTy(Key, UINT_MAX));\n      if (UB != Temporaries.begin() && std::prev(UB)->first.first == Key)\n        return &std::prev(UB)->second;\n      return nullptr;\n    }\n\n    // Return the version number of the current temporary for Key.\n    unsigned getCurrentTemporaryVersion(const void *Key) const {\n      auto UB = Temporaries.upper_bound(MapKeyTy(Key, UINT_MAX));\n      if (UB != Temporaries.begin() && std::prev(UB)->first.first == Key)\n        return std::prev(UB)->first.second;\n      return 0;\n    }\n\n    /// Allocate storage for an object of type T in this stack frame.\n    /// Populates LV with a handle to the created object. Key identifies\n    /// the temporary within the stack frame, and must not be reused without\n    /// bumping the temporary version number.\n    template<typename KeyT>\n    APValue &createTemporary(const KeyT *Key, QualType T,\n                             ScopeKind Scope, LValue &LV);\n\n    /// Allocate storage for a parameter of a function call made in this frame.\n    APValue &createParam(CallRef Args, const ParmVarDecl *PVD, LValue &LV);\n\n    void describe(llvm::raw_ostream &OS) override;\n\n    Frame *getCaller() const override { return Caller; }\n    SourceLocation getCallLocation() const override { return CallLoc; }\n    const FunctionDecl *getCallee() const override { return Callee; }\n\n    bool isStdFunction() const {\n      for (const DeclContext *DC = Callee; DC; DC = DC->getParent())\n        if (DC->isStdNamespace())\n          return true;\n      return false;\n    }\n\n  private:\n    APValue &createLocal(APValue::LValueBase Base, const void *Key, QualType T,\n                         ScopeKind Scope);\n  };\n\n  /// Temporarily override 'this'.\n  class ThisOverrideRAII {\n  public:\n    ThisOverrideRAII(CallStackFrame &Frame, const LValue *NewThis, bool Enable)\n        : Frame(Frame), OldThis(Frame.This) {\n      if (Enable)\n        Frame.This = NewThis;\n    }\n    ~ThisOverrideRAII() {\n      Frame.This = OldThis;\n    }\n  private:\n    CallStackFrame &Frame;\n    const LValue *OldThis;\n  };\n}\n\nstatic bool HandleDestruction(EvalInfo &Info, const Expr *E,\n                              const LValue &This, QualType ThisType);\nstatic bool HandleDestruction(EvalInfo &Info, SourceLocation Loc,\n                              APValue::LValueBase LVBase, APValue &Value,\n                              QualType T);\n\nnamespace {\n  /// A cleanup, and a flag indicating whether it is lifetime-extended.\n  class Cleanup {\n    llvm::PointerIntPair<APValue*, 2, ScopeKind> Value;\n    APValue::LValueBase Base;\n    QualType T;\n\n  public:\n    Cleanup(APValue *Val, APValue::LValueBase Base, QualType T,\n            ScopeKind Scope)\n        : Value(Val, Scope), Base(Base), T(T) {}\n\n    /// Determine whether this cleanup should be performed at the end of the\n    /// given kind of scope.\n    bool isDestroyedAtEndOf(ScopeKind K) const {\n      return (int)Value.getInt() >= (int)K;\n    }\n    bool endLifetime(EvalInfo &Info, bool RunDestructors) {\n      if (RunDestructors) {\n        SourceLocation Loc;\n        if (const ValueDecl *VD = Base.dyn_cast<const ValueDecl*>())\n          Loc = VD->getLocation();\n        else if (const Expr *E = Base.dyn_cast<const Expr*>())\n          Loc = E->getExprLoc();\n        return HandleDestruction(Info, Loc, Base, *Value.getPointer(), T);\n      }\n      *Value.getPointer() = APValue();\n      return true;\n    }\n\n    bool hasSideEffect() {\n      return T.isDestructedType();\n    }\n  };\n\n  /// A reference to an object whose construction we are currently evaluating.\n  struct ObjectUnderConstruction {\n    APValue::LValueBase Base;\n    ArrayRef<APValue::LValuePathEntry> Path;\n    friend bool operator==(const ObjectUnderConstruction &LHS,\n                           const ObjectUnderConstruction &RHS) {\n      return LHS.Base == RHS.Base && LHS.Path == RHS.Path;\n    }\n    friend llvm::hash_code hash_value(const ObjectUnderConstruction &Obj) {\n      return llvm::hash_combine(Obj.Base, Obj.Path);\n    }\n  };\n  enum class ConstructionPhase {\n    None,\n    Bases,\n    AfterBases,\n    AfterFields,\n    Destroying,\n    DestroyingBases\n  };\n}\n\nnamespace llvm {\ntemplate<> struct DenseMapInfo<ObjectUnderConstruction> {\n  using Base = DenseMapInfo<APValue::LValueBase>;\n  static ObjectUnderConstruction getEmptyKey() {\n    return {Base::getEmptyKey(), {}}; }\n  static ObjectUnderConstruction getTombstoneKey() {\n    return {Base::getTombstoneKey(), {}};\n  }\n  static unsigned getHashValue(const ObjectUnderConstruction &Object) {\n    return hash_value(Object);\n  }\n  static bool isEqual(const ObjectUnderConstruction &LHS,\n                      const ObjectUnderConstruction &RHS) {\n    return LHS == RHS;\n  }\n};\n}\n\nnamespace {\n  /// A dynamically-allocated heap object.\n  struct DynAlloc {\n    /// The value of this heap-allocated object.\n    APValue Value;\n    /// The allocating expression; used for diagnostics. Either a CXXNewExpr\n    /// or a CallExpr (the latter is for direct calls to operator new inside\n    /// std::allocator<T>::allocate).\n    const Expr *AllocExpr = nullptr;\n\n    enum Kind {\n      New,\n      ArrayNew,\n      StdAllocator\n    };\n\n    /// Get the kind of the allocation. This must match between allocation\n    /// and deallocation.\n    Kind getKind() const {\n      if (auto *NE = dyn_cast<CXXNewExpr>(AllocExpr))\n        return NE->isArray() ? ArrayNew : New;\n      assert(isa<CallExpr>(AllocExpr));\n      return StdAllocator;\n    }\n  };\n\n  struct DynAllocOrder {\n    bool operator()(DynamicAllocLValue L, DynamicAllocLValue R) const {\n      return L.getIndex() < R.getIndex();\n    }\n  };\n\n  /// EvalInfo - This is a private struct used by the evaluator to capture\n  /// information about a subexpression as it is folded.  It retains information\n  /// about the AST context, but also maintains information about the folded\n  /// expression.\n  ///\n  /// If an expression could be evaluated, it is still possible it is not a C\n  /// \"integer constant expression\" or constant expression.  If not, this struct\n  /// captures information about how and why not.\n  ///\n  /// One bit of information passed *into* the request for constant folding\n  /// indicates whether the subexpression is \"evaluated\" or not according to C\n  /// rules.  For example, the RHS of (0 && foo()) is not evaluated.  We can\n  /// evaluate the expression regardless of what the RHS is, but C only allows\n  /// certain things in certain situations.\n  class EvalInfo : public interp::State {\n  public:\n    ASTContext &Ctx;\n\n    /// EvalStatus - Contains information about the evaluation.\n    Expr::EvalStatus &EvalStatus;\n\n    /// CurrentCall - The top of the constexpr call stack.\n    CallStackFrame *CurrentCall;\n\n    /// CallStackDepth - The number of calls in the call stack right now.\n    unsigned CallStackDepth;\n\n    /// NextCallIndex - The next call index to assign.\n    unsigned NextCallIndex;\n\n    /// StepsLeft - The remaining number of evaluation steps we're permitted\n    /// to perform. This is essentially a limit for the number of statements\n    /// we will evaluate.\n    unsigned StepsLeft;\n\n    /// Enable the experimental new constant interpreter. If an expression is\n    /// not supported by the interpreter, an error is triggered.\n    bool EnableNewConstInterp;\n\n    /// BottomFrame - The frame in which evaluation started. This must be\n    /// initialized after CurrentCall and CallStackDepth.\n    CallStackFrame BottomFrame;\n\n    /// A stack of values whose lifetimes end at the end of some surrounding\n    /// evaluation frame.\n    llvm::SmallVector<Cleanup, 16> CleanupStack;\n\n    /// EvaluatingDecl - This is the declaration whose initializer is being\n    /// evaluated, if any.\n    APValue::LValueBase EvaluatingDecl;\n\n    enum class EvaluatingDeclKind {\n      None,\n      /// We're evaluating the construction of EvaluatingDecl.\n      Ctor,\n      /// We're evaluating the destruction of EvaluatingDecl.\n      Dtor,\n    };\n    EvaluatingDeclKind IsEvaluatingDecl = EvaluatingDeclKind::None;\n\n    /// EvaluatingDeclValue - This is the value being constructed for the\n    /// declaration whose initializer is being evaluated, if any.\n    APValue *EvaluatingDeclValue;\n\n    /// Set of objects that are currently being constructed.\n    llvm::DenseMap<ObjectUnderConstruction, ConstructionPhase>\n        ObjectsUnderConstruction;\n\n    /// Current heap allocations, along with the location where each was\n    /// allocated. We use std::map here because we need stable addresses\n    /// for the stored APValues.\n    std::map<DynamicAllocLValue, DynAlloc, DynAllocOrder> HeapAllocs;\n\n    /// The number of heap allocations performed so far in this evaluation.\n    unsigned NumHeapAllocs = 0;\n\n    struct EvaluatingConstructorRAII {\n      EvalInfo &EI;\n      ObjectUnderConstruction Object;\n      bool DidInsert;\n      EvaluatingConstructorRAII(EvalInfo &EI, ObjectUnderConstruction Object,\n                                bool HasBases)\n          : EI(EI), Object(Object) {\n        DidInsert =\n            EI.ObjectsUnderConstruction\n                .insert({Object, HasBases ? ConstructionPhase::Bases\n                                          : ConstructionPhase::AfterBases})\n                .second;\n      }\n      void finishedConstructingBases() {\n        EI.ObjectsUnderConstruction[Object] = ConstructionPhase::AfterBases;\n      }\n      void finishedConstructingFields() {\n        EI.ObjectsUnderConstruction[Object] = ConstructionPhase::AfterFields;\n      }\n      ~EvaluatingConstructorRAII() {\n        if (DidInsert) EI.ObjectsUnderConstruction.erase(Object);\n      }\n    };\n\n    struct EvaluatingDestructorRAII {\n      EvalInfo &EI;\n      ObjectUnderConstruction Object;\n      bool DidInsert;\n      EvaluatingDestructorRAII(EvalInfo &EI, ObjectUnderConstruction Object)\n          : EI(EI), Object(Object) {\n        DidInsert = EI.ObjectsUnderConstruction\n                        .insert({Object, ConstructionPhase::Destroying})\n                        .second;\n      }\n      void startedDestroyingBases() {\n        EI.ObjectsUnderConstruction[Object] =\n            ConstructionPhase::DestroyingBases;\n      }\n      ~EvaluatingDestructorRAII() {\n        if (DidInsert)\n          EI.ObjectsUnderConstruction.erase(Object);\n      }\n    };\n\n    ConstructionPhase\n    isEvaluatingCtorDtor(APValue::LValueBase Base,\n                         ArrayRef<APValue::LValuePathEntry> Path) {\n      return ObjectsUnderConstruction.lookup({Base, Path});\n    }\n\n    /// If we're currently speculatively evaluating, the outermost call stack\n    /// depth at which we can mutate state, otherwise 0.\n    unsigned SpeculativeEvaluationDepth = 0;\n\n    /// The current array initialization index, if we're performing array\n    /// initialization.\n    uint64_t ArrayInitIndex = -1;\n\n    /// HasActiveDiagnostic - Was the previous diagnostic stored? If so, further\n    /// notes attached to it will also be stored, otherwise they will not be.\n    bool HasActiveDiagnostic;\n\n    /// Have we emitted a diagnostic explaining why we couldn't constant\n    /// fold (not just why it's not strictly a constant expression)?\n    bool HasFoldFailureDiagnostic;\n\n    /// Whether or not we're in a context where the front end requires a\n    /// constant value.\n    bool InConstantContext;\n\n    /// Whether we're checking that an expression is a potential constant\n    /// expression. If so, do not fail on constructs that could become constant\n    /// later on (such as a use of an undefined global).\n    bool CheckingPotentialConstantExpression = false;\n\n    /// Whether we're checking for an expression that has undefined behavior.\n    /// If so, we will produce warnings if we encounter an operation that is\n    /// always undefined.\n    ///\n    /// Note that we still need to evaluate the expression normally when this\n    /// is set; this is used when evaluating ICEs in C.\n    bool CheckingForUndefinedBehavior = false;\n\n    enum EvaluationMode {\n      /// Evaluate as a constant expression. Stop if we find that the expression\n      /// is not a constant expression.\n      EM_ConstantExpression,\n\n      /// Evaluate as a constant expression. Stop if we find that the expression\n      /// is not a constant expression. Some expressions can be retried in the\n      /// optimizer if we don't constant fold them here, but in an unevaluated\n      /// context we try to fold them immediately since the optimizer never\n      /// gets a chance to look at it.\n      EM_ConstantExpressionUnevaluated,\n\n      /// Fold the expression to a constant. Stop if we hit a side-effect that\n      /// we can't model.\n      EM_ConstantFold,\n\n      /// Evaluate in any way we know how. Don't worry about side-effects that\n      /// can't be modeled.\n      EM_IgnoreSideEffects,\n    } EvalMode;\n\n    /// Are we checking whether the expression is a potential constant\n    /// expression?\n    bool checkingPotentialConstantExpression() const override  {\n      return CheckingPotentialConstantExpression;\n    }\n\n    /// Are we checking an expression for overflow?\n    // FIXME: We should check for any kind of undefined or suspicious behavior\n    // in such constructs, not just overflow.\n    bool checkingForUndefinedBehavior() const override {\n      return CheckingForUndefinedBehavior;\n    }\n\n    EvalInfo(const ASTContext &C, Expr::EvalStatus &S, EvaluationMode Mode)\n        : Ctx(const_cast<ASTContext &>(C)), EvalStatus(S), CurrentCall(nullptr),\n          CallStackDepth(0), NextCallIndex(1),\n          StepsLeft(C.getLangOpts().ConstexprStepLimit),\n          EnableNewConstInterp(C.getLangOpts().EnableNewConstInterp),\n          BottomFrame(*this, SourceLocation(), nullptr, nullptr, CallRef()),\n          EvaluatingDecl((const ValueDecl *)nullptr),\n          EvaluatingDeclValue(nullptr), HasActiveDiagnostic(false),\n          HasFoldFailureDiagnostic(false), InConstantContext(false),\n          EvalMode(Mode) {}\n\n    ~EvalInfo() {\n      discardCleanups();\n    }\n\n    void setEvaluatingDecl(APValue::LValueBase Base, APValue &Value,\n                           EvaluatingDeclKind EDK = EvaluatingDeclKind::Ctor) {\n      EvaluatingDecl = Base;\n      IsEvaluatingDecl = EDK;\n      EvaluatingDeclValue = &Value;\n    }\n\n    bool CheckCallLimit(SourceLocation Loc) {\n      // Don't perform any constexpr calls (other than the call we're checking)\n      // when checking a potential constant expression.\n      if (checkingPotentialConstantExpression() && CallStackDepth > 1)\n        return false;\n      if (NextCallIndex == 0) {\n        // NextCallIndex has wrapped around.\n        FFDiag(Loc, diag::note_constexpr_call_limit_exceeded);\n        return false;\n      }\n      if (CallStackDepth <= getLangOpts().ConstexprCallDepth)\n        return true;\n      FFDiag(Loc, diag::note_constexpr_depth_limit_exceeded)\n        << getLangOpts().ConstexprCallDepth;\n      return false;\n    }\n\n    std::pair<CallStackFrame *, unsigned>\n    getCallFrameAndDepth(unsigned CallIndex) {\n      assert(CallIndex && \"no call index in getCallFrameAndDepth\");\n      // We will eventually hit BottomFrame, which has Index 1, so Frame can't\n      // be null in this loop.\n      unsigned Depth = CallStackDepth;\n      CallStackFrame *Frame = CurrentCall;\n      while (Frame->Index > CallIndex) {\n        Frame = Frame->Caller;\n        --Depth;\n      }\n      if (Frame->Index == CallIndex)\n        return {Frame, Depth};\n      return {nullptr, 0};\n    }\n\n    bool nextStep(const Stmt *S) {\n      if (!StepsLeft) {\n        FFDiag(S->getBeginLoc(), diag::note_constexpr_step_limit_exceeded);\n        return false;\n      }\n      --StepsLeft;\n      return true;\n    }\n\n    APValue *createHeapAlloc(const Expr *E, QualType T, LValue &LV);\n\n    Optional<DynAlloc*> lookupDynamicAlloc(DynamicAllocLValue DA) {\n      Optional<DynAlloc*> Result;\n      auto It = HeapAllocs.find(DA);\n      if (It != HeapAllocs.end())\n        Result = &It->second;\n      return Result;\n    }\n\n    /// Get the allocated storage for the given parameter of the given call.\n    APValue *getParamSlot(CallRef Call, const ParmVarDecl *PVD) {\n      CallStackFrame *Frame = getCallFrameAndDepth(Call.CallIndex).first;\n      return Frame ? Frame->getTemporary(Call.getOrigParam(PVD), Call.Version)\n                   : nullptr;\n    }\n\n    /// Information about a stack frame for std::allocator<T>::[de]allocate.\n    struct StdAllocatorCaller {\n      unsigned FrameIndex;\n      QualType ElemType;\n      explicit operator bool() const { return FrameIndex != 0; };\n    };\n\n    StdAllocatorCaller getStdAllocatorCaller(StringRef FnName) const {\n      for (const CallStackFrame *Call = CurrentCall; Call != &BottomFrame;\n           Call = Call->Caller) {\n        const auto *MD = dyn_cast_or_null<CXXMethodDecl>(Call->Callee);\n        if (!MD)\n          continue;\n        const IdentifierInfo *FnII = MD->getIdentifier();\n        if (!FnII || !FnII->isStr(FnName))\n          continue;\n\n        const auto *CTSD =\n            dyn_cast<ClassTemplateSpecializationDecl>(MD->getParent());\n        if (!CTSD)\n          continue;\n\n        const IdentifierInfo *ClassII = CTSD->getIdentifier();\n        const TemplateArgumentList &TAL = CTSD->getTemplateArgs();\n        if (CTSD->isInStdNamespace() && ClassII &&\n            ClassII->isStr(\"allocator\") && TAL.size() >= 1 &&\n            TAL[0].getKind() == TemplateArgument::Type)\n          return {Call->Index, TAL[0].getAsType()};\n      }\n\n      return {};\n    }\n\n    void performLifetimeExtension() {\n      // Disable the cleanups for lifetime-extended temporaries.\n      CleanupStack.erase(std::remove_if(CleanupStack.begin(),\n                                        CleanupStack.end(),\n                                        [](Cleanup &C) {\n                                          return !C.isDestroyedAtEndOf(\n                                              ScopeKind::FullExpression);\n                                        }),\n                         CleanupStack.end());\n     }\n\n    /// Throw away any remaining cleanups at the end of evaluation. If any\n    /// cleanups would have had a side-effect, note that as an unmodeled\n    /// side-effect and return false. Otherwise, return true.\n    bool discardCleanups() {\n      for (Cleanup &C : CleanupStack) {\n        if (C.hasSideEffect() && !noteSideEffect()) {\n          CleanupStack.clear();\n          return false;\n        }\n      }\n      CleanupStack.clear();\n      return true;\n    }\n\n  private:\n    interp::Frame *getCurrentFrame() override { return CurrentCall; }\n    const interp::Frame *getBottomFrame() const override { return &BottomFrame; }\n\n    bool hasActiveDiagnostic() override { return HasActiveDiagnostic; }\n    void setActiveDiagnostic(bool Flag) override { HasActiveDiagnostic = Flag; }\n\n    void setFoldFailureDiagnostic(bool Flag) override {\n      HasFoldFailureDiagnostic = Flag;\n    }\n\n    Expr::EvalStatus &getEvalStatus() const override { return EvalStatus; }\n\n    ASTContext &getCtx() const override { return Ctx; }\n\n    // If we have a prior diagnostic, it will be noting that the expression\n    // isn't a constant expression. This diagnostic is more important,\n    // unless we require this evaluation to produce a constant expression.\n    //\n    // FIXME: We might want to show both diagnostics to the user in\n    // EM_ConstantFold mode.\n    bool hasPriorDiagnostic() override {\n      if (!EvalStatus.Diag->empty()) {\n        switch (EvalMode) {\n        case EM_ConstantFold:\n        case EM_IgnoreSideEffects:\n          if (!HasFoldFailureDiagnostic)\n            break;\n          // We've already failed to fold something. Keep that diagnostic.\n          LLVM_FALLTHROUGH;\n        case EM_ConstantExpression:\n        case EM_ConstantExpressionUnevaluated:\n          setActiveDiagnostic(false);\n          return true;\n        }\n      }\n      return false;\n    }\n\n    unsigned getCallStackDepth() override { return CallStackDepth; }\n\n  public:\n    /// Should we continue evaluation after encountering a side-effect that we\n    /// couldn't model?\n    bool keepEvaluatingAfterSideEffect() {\n      switch (EvalMode) {\n      case EM_IgnoreSideEffects:\n        return true;\n\n      case EM_ConstantExpression:\n      case EM_ConstantExpressionUnevaluated:\n      case EM_ConstantFold:\n        // By default, assume any side effect might be valid in some other\n        // evaluation of this expression from a different context.\n        return checkingPotentialConstantExpression() ||\n               checkingForUndefinedBehavior();\n      }\n      llvm_unreachable(\"Missed EvalMode case\");\n    }\n\n    /// Note that we have had a side-effect, and determine whether we should\n    /// keep evaluating.\n    bool noteSideEffect() {\n      EvalStatus.HasSideEffects = true;\n      return keepEvaluatingAfterSideEffect();\n    }\n\n    /// Should we continue evaluation after encountering undefined behavior?\n    bool keepEvaluatingAfterUndefinedBehavior() {\n      switch (EvalMode) {\n      case EM_IgnoreSideEffects:\n      case EM_ConstantFold:\n        return true;\n\n      case EM_ConstantExpression:\n      case EM_ConstantExpressionUnevaluated:\n        return checkingForUndefinedBehavior();\n      }\n      llvm_unreachable(\"Missed EvalMode case\");\n    }\n\n    /// Note that we hit something that was technically undefined behavior, but\n    /// that we can evaluate past it (such as signed overflow or floating-point\n    /// division by zero.)\n    bool noteUndefinedBehavior() override {\n      EvalStatus.HasUndefinedBehavior = true;\n      return keepEvaluatingAfterUndefinedBehavior();\n    }\n\n    /// Should we continue evaluation as much as possible after encountering a\n    /// construct which can't be reduced to a value?\n    bool keepEvaluatingAfterFailure() const override {\n      if (!StepsLeft)\n        return false;\n\n      switch (EvalMode) {\n      case EM_ConstantExpression:\n      case EM_ConstantExpressionUnevaluated:\n      case EM_ConstantFold:\n      case EM_IgnoreSideEffects:\n        return checkingPotentialConstantExpression() ||\n               checkingForUndefinedBehavior();\n      }\n      llvm_unreachable(\"Missed EvalMode case\");\n    }\n\n    /// Notes that we failed to evaluate an expression that other expressions\n    /// directly depend on, and determine if we should keep evaluating. This\n    /// should only be called if we actually intend to keep evaluating.\n    ///\n    /// Call noteSideEffect() instead if we may be able to ignore the value that\n    /// we failed to evaluate, e.g. if we failed to evaluate Foo() in:\n    ///\n    /// (Foo(), 1)      // use noteSideEffect\n    /// (Foo() || true) // use noteSideEffect\n    /// Foo() + 1       // use noteFailure\n    LLVM_NODISCARD bool noteFailure() {\n      // Failure when evaluating some expression often means there is some\n      // subexpression whose evaluation was skipped. Therefore, (because we\n      // don't track whether we skipped an expression when unwinding after an\n      // evaluation failure) every evaluation failure that bubbles up from a\n      // subexpression implies that a side-effect has potentially happened. We\n      // skip setting the HasSideEffects flag to true until we decide to\n      // continue evaluating after that point, which happens here.\n      bool KeepGoing = keepEvaluatingAfterFailure();\n      EvalStatus.HasSideEffects |= KeepGoing;\n      return KeepGoing;\n    }\n\n    class ArrayInitLoopIndex {\n      EvalInfo &Info;\n      uint64_t OuterIndex;\n\n    public:\n      ArrayInitLoopIndex(EvalInfo &Info)\n          : Info(Info), OuterIndex(Info.ArrayInitIndex) {\n        Info.ArrayInitIndex = 0;\n      }\n      ~ArrayInitLoopIndex() { Info.ArrayInitIndex = OuterIndex; }\n\n      operator uint64_t&() { return Info.ArrayInitIndex; }\n    };\n  };\n\n  /// Object used to treat all foldable expressions as constant expressions.\n  struct FoldConstant {\n    EvalInfo &Info;\n    bool Enabled;\n    bool HadNoPriorDiags;\n    EvalInfo::EvaluationMode OldMode;\n\n    explicit FoldConstant(EvalInfo &Info, bool Enabled)\n      : Info(Info),\n        Enabled(Enabled),\n        HadNoPriorDiags(Info.EvalStatus.Diag &&\n                        Info.EvalStatus.Diag->empty() &&\n                        !Info.EvalStatus.HasSideEffects),\n        OldMode(Info.EvalMode) {\n      if (Enabled)\n        Info.EvalMode = EvalInfo::EM_ConstantFold;\n    }\n    void keepDiagnostics() { Enabled = false; }\n    ~FoldConstant() {\n      if (Enabled && HadNoPriorDiags && !Info.EvalStatus.Diag->empty() &&\n          !Info.EvalStatus.HasSideEffects)\n        Info.EvalStatus.Diag->clear();\n      Info.EvalMode = OldMode;\n    }\n  };\n\n  /// RAII object used to set the current evaluation mode to ignore\n  /// side-effects.\n  struct IgnoreSideEffectsRAII {\n    EvalInfo &Info;\n    EvalInfo::EvaluationMode OldMode;\n    explicit IgnoreSideEffectsRAII(EvalInfo &Info)\n        : Info(Info), OldMode(Info.EvalMode) {\n      Info.EvalMode = EvalInfo::EM_IgnoreSideEffects;\n    }\n\n    ~IgnoreSideEffectsRAII() { Info.EvalMode = OldMode; }\n  };\n\n  /// RAII object used to optionally suppress diagnostics and side-effects from\n  /// a speculative evaluation.\n  class SpeculativeEvaluationRAII {\n    EvalInfo *Info = nullptr;\n    Expr::EvalStatus OldStatus;\n    unsigned OldSpeculativeEvaluationDepth;\n\n    void moveFromAndCancel(SpeculativeEvaluationRAII &&Other) {\n      Info = Other.Info;\n      OldStatus = Other.OldStatus;\n      OldSpeculativeEvaluationDepth = Other.OldSpeculativeEvaluationDepth;\n      Other.Info = nullptr;\n    }\n\n    void maybeRestoreState() {\n      if (!Info)\n        return;\n\n      Info->EvalStatus = OldStatus;\n      Info->SpeculativeEvaluationDepth = OldSpeculativeEvaluationDepth;\n    }\n\n  public:\n    SpeculativeEvaluationRAII() = default;\n\n    SpeculativeEvaluationRAII(\n        EvalInfo &Info, SmallVectorImpl<PartialDiagnosticAt> *NewDiag = nullptr)\n        : Info(&Info), OldStatus(Info.EvalStatus),\n          OldSpeculativeEvaluationDepth(Info.SpeculativeEvaluationDepth) {\n      Info.EvalStatus.Diag = NewDiag;\n      Info.SpeculativeEvaluationDepth = Info.CallStackDepth + 1;\n    }\n\n    SpeculativeEvaluationRAII(const SpeculativeEvaluationRAII &Other) = delete;\n    SpeculativeEvaluationRAII(SpeculativeEvaluationRAII &&Other) {\n      moveFromAndCancel(std::move(Other));\n    }\n\n    SpeculativeEvaluationRAII &operator=(SpeculativeEvaluationRAII &&Other) {\n      maybeRestoreState();\n      moveFromAndCancel(std::move(Other));\n      return *this;\n    }\n\n    ~SpeculativeEvaluationRAII() { maybeRestoreState(); }\n  };\n\n  /// RAII object wrapping a full-expression or block scope, and handling\n  /// the ending of the lifetime of temporaries created within it.\n  template<ScopeKind Kind>\n  class ScopeRAII {\n    EvalInfo &Info;\n    unsigned OldStackSize;\n  public:\n    ScopeRAII(EvalInfo &Info)\n        : Info(Info), OldStackSize(Info.CleanupStack.size()) {\n      // Push a new temporary version. This is needed to distinguish between\n      // temporaries created in different iterations of a loop.\n      Info.CurrentCall->pushTempVersion();\n    }\n    bool destroy(bool RunDestructors = true) {\n      bool OK = cleanup(Info, RunDestructors, OldStackSize);\n      OldStackSize = -1U;\n      return OK;\n    }\n    ~ScopeRAII() {\n      if (OldStackSize != -1U)\n        destroy(false);\n      // Body moved to a static method to encourage the compiler to inline away\n      // instances of this class.\n      Info.CurrentCall->popTempVersion();\n    }\n  private:\n    static bool cleanup(EvalInfo &Info, bool RunDestructors,\n                        unsigned OldStackSize) {\n      assert(OldStackSize <= Info.CleanupStack.size() &&\n             \"running cleanups out of order?\");\n\n      // Run all cleanups for a block scope, and non-lifetime-extended cleanups\n      // for a full-expression scope.\n      bool Success = true;\n      for (unsigned I = Info.CleanupStack.size(); I > OldStackSize; --I) {\n        if (Info.CleanupStack[I - 1].isDestroyedAtEndOf(Kind)) {\n          if (!Info.CleanupStack[I - 1].endLifetime(Info, RunDestructors)) {\n            Success = false;\n            break;\n          }\n        }\n      }\n\n      // Compact any retained cleanups.\n      auto NewEnd = Info.CleanupStack.begin() + OldStackSize;\n      if (Kind != ScopeKind::Block)\n        NewEnd =\n            std::remove_if(NewEnd, Info.CleanupStack.end(), [](Cleanup &C) {\n              return C.isDestroyedAtEndOf(Kind);\n            });\n      Info.CleanupStack.erase(NewEnd, Info.CleanupStack.end());\n      return Success;\n    }\n  };\n  typedef ScopeRAII<ScopeKind::Block> BlockScopeRAII;\n  typedef ScopeRAII<ScopeKind::FullExpression> FullExpressionRAII;\n  typedef ScopeRAII<ScopeKind::Call> CallScopeRAII;\n}\n\nbool SubobjectDesignator::checkSubobject(EvalInfo &Info, const Expr *E,\n                                         CheckSubobjectKind CSK) {\n  if (Invalid)\n    return false;\n  if (isOnePastTheEnd()) {\n    Info.CCEDiag(E, diag::note_constexpr_past_end_subobject)\n      << CSK;\n    setInvalid();\n    return false;\n  }\n  // Note, we do not diagnose if isMostDerivedAnUnsizedArray(), because there\n  // must actually be at least one array element; even a VLA cannot have a\n  // bound of zero. And if our index is nonzero, we already had a CCEDiag.\n  return true;\n}\n\nvoid SubobjectDesignator::diagnoseUnsizedArrayPointerArithmetic(EvalInfo &Info,\n                                                                const Expr *E) {\n  Info.CCEDiag(E, diag::note_constexpr_unsized_array_indexed);\n  // Do not set the designator as invalid: we can represent this situation,\n  // and correct handling of __builtin_object_size requires us to do so.\n}\n\nvoid SubobjectDesignator::diagnosePointerArithmetic(EvalInfo &Info,\n                                                    const Expr *E,\n                                                    const APSInt &N) {\n  // If we're complaining, we must be able to statically determine the size of\n  // the most derived array.\n  if (MostDerivedPathLength == Entries.size() && MostDerivedIsArrayElement)\n    Info.CCEDiag(E, diag::note_constexpr_array_index)\n      << N << /*array*/ 0\n      << static_cast<unsigned>(getMostDerivedArraySize());\n  else\n    Info.CCEDiag(E, diag::note_constexpr_array_index)\n      << N << /*non-array*/ 1;\n  setInvalid();\n}\n\nCallStackFrame::CallStackFrame(EvalInfo &Info, SourceLocation CallLoc,\n                               const FunctionDecl *Callee, const LValue *This,\n                               CallRef Call)\n    : Info(Info), Caller(Info.CurrentCall), Callee(Callee), This(This),\n      Arguments(Call), CallLoc(CallLoc), Index(Info.NextCallIndex++) {\n  Info.CurrentCall = this;\n  ++Info.CallStackDepth;\n}\n\nCallStackFrame::~CallStackFrame() {\n  assert(Info.CurrentCall == this && \"calls retired out of order\");\n  --Info.CallStackDepth;\n  Info.CurrentCall = Caller;\n}\n\nstatic bool isRead(AccessKinds AK) {\n  return AK == AK_Read || AK == AK_ReadObjectRepresentation;\n}\n\nstatic bool isModification(AccessKinds AK) {\n  switch (AK) {\n  case AK_Read:\n  case AK_ReadObjectRepresentation:\n  case AK_MemberCall:\n  case AK_DynamicCast:\n  case AK_TypeId:\n    return false;\n  case AK_Assign:\n  case AK_Increment:\n  case AK_Decrement:\n  case AK_Construct:\n  case AK_Destroy:\n    return true;\n  }\n  llvm_unreachable(\"unknown access kind\");\n}\n\nstatic bool isAnyAccess(AccessKinds AK) {\n  return isRead(AK) || isModification(AK);\n}\n\n/// Is this an access per the C++ definition?\nstatic bool isFormalAccess(AccessKinds AK) {\n  return isAnyAccess(AK) && AK != AK_Construct && AK != AK_Destroy;\n}\n\n/// Is this kind of axcess valid on an indeterminate object value?\nstatic bool isValidIndeterminateAccess(AccessKinds AK) {\n  switch (AK) {\n  case AK_Read:\n  case AK_Increment:\n  case AK_Decrement:\n    // These need the object's value.\n    return false;\n\n  case AK_ReadObjectRepresentation:\n  case AK_Assign:\n  case AK_Construct:\n  case AK_Destroy:\n    // Construction and destruction don't need the value.\n    return true;\n\n  case AK_MemberCall:\n  case AK_DynamicCast:\n  case AK_TypeId:\n    // These aren't really meaningful on scalars.\n    return true;\n  }\n  llvm_unreachable(\"unknown access kind\");\n}\n\nnamespace {\n  struct ComplexValue {\n  private:\n    bool IsInt;\n\n  public:\n    APSInt IntReal, IntImag;\n    APFloat FloatReal, FloatImag;\n\n    ComplexValue() : FloatReal(APFloat::Bogus()), FloatImag(APFloat::Bogus()) {}\n\n    void makeComplexFloat() { IsInt = false; }\n    bool isComplexFloat() const { return !IsInt; }\n    APFloat &getComplexFloatReal() { return FloatReal; }\n    APFloat &getComplexFloatImag() { return FloatImag; }\n\n    void makeComplexInt() { IsInt = true; }\n    bool isComplexInt() const { return IsInt; }\n    APSInt &getComplexIntReal() { return IntReal; }\n    APSInt &getComplexIntImag() { return IntImag; }\n\n    void moveInto(APValue &v) const {\n      if (isComplexFloat())\n        v = APValue(FloatReal, FloatImag);\n      else\n        v = APValue(IntReal, IntImag);\n    }\n    void setFrom(const APValue &v) {\n      assert(v.isComplexFloat() || v.isComplexInt());\n      if (v.isComplexFloat()) {\n        makeComplexFloat();\n        FloatReal = v.getComplexFloatReal();\n        FloatImag = v.getComplexFloatImag();\n      } else {\n        makeComplexInt();\n        IntReal = v.getComplexIntReal();\n        IntImag = v.getComplexIntImag();\n      }\n    }\n  };\n\n  struct LValue {\n    APValue::LValueBase Base;\n    CharUnits Offset;\n    SubobjectDesignator Designator;\n    bool IsNullPtr : 1;\n    bool InvalidBase : 1;\n\n    const APValue::LValueBase getLValueBase() const { return Base; }\n    CharUnits &getLValueOffset() { return Offset; }\n    const CharUnits &getLValueOffset() const { return Offset; }\n    SubobjectDesignator &getLValueDesignator() { return Designator; }\n    const SubobjectDesignator &getLValueDesignator() const { return Designator;}\n    bool isNullPointer() const { return IsNullPtr;}\n\n    unsigned getLValueCallIndex() const { return Base.getCallIndex(); }\n    unsigned getLValueVersion() const { return Base.getVersion(); }\n\n    void moveInto(APValue &V) const {\n      if (Designator.Invalid)\n        V = APValue(Base, Offset, APValue::NoLValuePath(), IsNullPtr);\n      else {\n        assert(!InvalidBase && \"APValues can't handle invalid LValue bases\");\n        V = APValue(Base, Offset, Designator.Entries,\n                    Designator.IsOnePastTheEnd, IsNullPtr);\n      }\n    }\n    void setFrom(ASTContext &Ctx, const APValue &V) {\n      assert(V.isLValue() && \"Setting LValue from a non-LValue?\");\n      Base = V.getLValueBase();\n      Offset = V.getLValueOffset();\n      InvalidBase = false;\n      Designator = SubobjectDesignator(Ctx, V);\n      IsNullPtr = V.isNullPointer();\n    }\n\n    void set(APValue::LValueBase B, bool BInvalid = false) {\n#ifndef NDEBUG\n      // We only allow a few types of invalid bases. Enforce that here.\n      if (BInvalid) {\n        const auto *E = B.get<const Expr *>();\n        assert((isa<MemberExpr>(E) || tryUnwrapAllocSizeCall(E)) &&\n               \"Unexpected type of invalid base\");\n      }\n#endif\n\n      Base = B;\n      Offset = CharUnits::fromQuantity(0);\n      InvalidBase = BInvalid;\n      Designator = SubobjectDesignator(getType(B));\n      IsNullPtr = false;\n    }\n\n    void setNull(ASTContext &Ctx, QualType PointerTy) {\n      Base = (const ValueDecl *)nullptr;\n      Offset =\n          CharUnits::fromQuantity(Ctx.getTargetNullPointerValue(PointerTy));\n      InvalidBase = false;\n      Designator = SubobjectDesignator(PointerTy->getPointeeType());\n      IsNullPtr = true;\n    }\n\n    void setInvalid(APValue::LValueBase B, unsigned I = 0) {\n      set(B, true);\n    }\n\n    std::string toString(ASTContext &Ctx, QualType T) const {\n      APValue Printable;\n      moveInto(Printable);\n      return Printable.getAsString(Ctx, T);\n    }\n\n  private:\n    // Check that this LValue is not based on a null pointer. If it is, produce\n    // a diagnostic and mark the designator as invalid.\n    template <typename GenDiagType>\n    bool checkNullPointerDiagnosingWith(const GenDiagType &GenDiag) {\n      if (Designator.Invalid)\n        return false;\n      if (IsNullPtr) {\n        GenDiag();\n        Designator.setInvalid();\n        return false;\n      }\n      return true;\n    }\n\n  public:\n    bool checkNullPointer(EvalInfo &Info, const Expr *E,\n                          CheckSubobjectKind CSK) {\n      return checkNullPointerDiagnosingWith([&Info, E, CSK] {\n        Info.CCEDiag(E, diag::note_constexpr_null_subobject) << CSK;\n      });\n    }\n\n    bool checkNullPointerForFoldAccess(EvalInfo &Info, const Expr *E,\n                                       AccessKinds AK) {\n      return checkNullPointerDiagnosingWith([&Info, E, AK] {\n        Info.FFDiag(E, diag::note_constexpr_access_null) << AK;\n      });\n    }\n\n    // Check this LValue refers to an object. If not, set the designator to be\n    // invalid and emit a diagnostic.\n    bool checkSubobject(EvalInfo &Info, const Expr *E, CheckSubobjectKind CSK) {\n      return (CSK == CSK_ArrayToPointer || checkNullPointer(Info, E, CSK)) &&\n             Designator.checkSubobject(Info, E, CSK);\n    }\n\n    void addDecl(EvalInfo &Info, const Expr *E,\n                 const Decl *D, bool Virtual = false) {\n      if (checkSubobject(Info, E, isa<FieldDecl>(D) ? CSK_Field : CSK_Base))\n        Designator.addDeclUnchecked(D, Virtual);\n    }\n    void addUnsizedArray(EvalInfo &Info, const Expr *E, QualType ElemTy) {\n      if (!Designator.Entries.empty()) {\n        Info.CCEDiag(E, diag::note_constexpr_unsupported_unsized_array);\n        Designator.setInvalid();\n        return;\n      }\n      if (checkSubobject(Info, E, CSK_ArrayToPointer)) {\n        assert(getType(Base)->isPointerType() || getType(Base)->isArrayType());\n        Designator.FirstEntryIsAnUnsizedArray = true;\n        Designator.addUnsizedArrayUnchecked(ElemTy);\n      }\n    }\n    void addArray(EvalInfo &Info, const Expr *E, const ConstantArrayType *CAT) {\n      if (checkSubobject(Info, E, CSK_ArrayToPointer))\n        Designator.addArrayUnchecked(CAT);\n    }\n    void addComplex(EvalInfo &Info, const Expr *E, QualType EltTy, bool Imag) {\n      if (checkSubobject(Info, E, Imag ? CSK_Imag : CSK_Real))\n        Designator.addComplexUnchecked(EltTy, Imag);\n    }\n    void clearIsNullPointer() {\n      IsNullPtr = false;\n    }\n    void adjustOffsetAndIndex(EvalInfo &Info, const Expr *E,\n                              const APSInt &Index, CharUnits ElementSize) {\n      // An index of 0 has no effect. (In C, adding 0 to a null pointer is UB,\n      // but we're not required to diagnose it and it's valid in C++.)\n      if (!Index)\n        return;\n\n      // Compute the new offset in the appropriate width, wrapping at 64 bits.\n      // FIXME: When compiling for a 32-bit target, we should use 32-bit\n      // offsets.\n      uint64_t Offset64 = Offset.getQuantity();\n      uint64_t ElemSize64 = ElementSize.getQuantity();\n      uint64_t Index64 = Index.extOrTrunc(64).getZExtValue();\n      Offset = CharUnits::fromQuantity(Offset64 + ElemSize64 * Index64);\n\n      if (checkNullPointer(Info, E, CSK_ArrayIndex))\n        Designator.adjustIndex(Info, E, Index);\n      clearIsNullPointer();\n    }\n    void adjustOffset(CharUnits N) {\n      Offset += N;\n      if (N.getQuantity())\n        clearIsNullPointer();\n    }\n  };\n\n  struct MemberPtr {\n    MemberPtr() {}\n    explicit MemberPtr(const ValueDecl *Decl) :\n      DeclAndIsDerivedMember(Decl, false), Path() {}\n\n    /// The member or (direct or indirect) field referred to by this member\n    /// pointer, or 0 if this is a null member pointer.\n    const ValueDecl *getDecl() const {\n      return DeclAndIsDerivedMember.getPointer();\n    }\n    /// Is this actually a member of some type derived from the relevant class?\n    bool isDerivedMember() const {\n      return DeclAndIsDerivedMember.getInt();\n    }\n    /// Get the class which the declaration actually lives in.\n    const CXXRecordDecl *getContainingRecord() const {\n      return cast<CXXRecordDecl>(\n          DeclAndIsDerivedMember.getPointer()->getDeclContext());\n    }\n\n    void moveInto(APValue &V) const {\n      V = APValue(getDecl(), isDerivedMember(), Path);\n    }\n    void setFrom(const APValue &V) {\n      assert(V.isMemberPointer());\n      DeclAndIsDerivedMember.setPointer(V.getMemberPointerDecl());\n      DeclAndIsDerivedMember.setInt(V.isMemberPointerToDerivedMember());\n      Path.clear();\n      ArrayRef<const CXXRecordDecl*> P = V.getMemberPointerPath();\n      Path.insert(Path.end(), P.begin(), P.end());\n    }\n\n    /// DeclAndIsDerivedMember - The member declaration, and a flag indicating\n    /// whether the member is a member of some class derived from the class type\n    /// of the member pointer.\n    llvm::PointerIntPair<const ValueDecl*, 1, bool> DeclAndIsDerivedMember;\n    /// Path - The path of base/derived classes from the member declaration's\n    /// class (exclusive) to the class type of the member pointer (inclusive).\n    SmallVector<const CXXRecordDecl*, 4> Path;\n\n    /// Perform a cast towards the class of the Decl (either up or down the\n    /// hierarchy).\n    bool castBack(const CXXRecordDecl *Class) {\n      assert(!Path.empty());\n      const CXXRecordDecl *Expected;\n      if (Path.size() >= 2)\n        Expected = Path[Path.size() - 2];\n      else\n        Expected = getContainingRecord();\n      if (Expected->getCanonicalDecl() != Class->getCanonicalDecl()) {\n        // C++11 [expr.static.cast]p12: In a conversion from (D::*) to (B::*),\n        // if B does not contain the original member and is not a base or\n        // derived class of the class containing the original member, the result\n        // of the cast is undefined.\n        // C++11 [conv.mem]p2 does not cover this case for a cast from (B::*) to\n        // (D::*). We consider that to be a language defect.\n        return false;\n      }\n      Path.pop_back();\n      return true;\n    }\n    /// Perform a base-to-derived member pointer cast.\n    bool castToDerived(const CXXRecordDecl *Derived) {\n      if (!getDecl())\n        return true;\n      if (!isDerivedMember()) {\n        Path.push_back(Derived);\n        return true;\n      }\n      if (!castBack(Derived))\n        return false;\n      if (Path.empty())\n        DeclAndIsDerivedMember.setInt(false);\n      return true;\n    }\n    /// Perform a derived-to-base member pointer cast.\n    bool castToBase(const CXXRecordDecl *Base) {\n      if (!getDecl())\n        return true;\n      if (Path.empty())\n        DeclAndIsDerivedMember.setInt(true);\n      if (isDerivedMember()) {\n        Path.push_back(Base);\n        return true;\n      }\n      return castBack(Base);\n    }\n  };\n\n  /// Compare two member pointers, which are assumed to be of the same type.\n  static bool operator==(const MemberPtr &LHS, const MemberPtr &RHS) {\n    if (!LHS.getDecl() || !RHS.getDecl())\n      return !LHS.getDecl() && !RHS.getDecl();\n    if (LHS.getDecl()->getCanonicalDecl() != RHS.getDecl()->getCanonicalDecl())\n      return false;\n    return LHS.Path == RHS.Path;\n  }\n}\n\nstatic bool Evaluate(APValue &Result, EvalInfo &Info, const Expr *E);\nstatic bool EvaluateInPlace(APValue &Result, EvalInfo &Info,\n                            const LValue &This, const Expr *E,\n                            bool AllowNonLiteralTypes = false);\nstatic bool EvaluateLValue(const Expr *E, LValue &Result, EvalInfo &Info,\n                           bool InvalidBaseOK = false);\nstatic bool EvaluatePointer(const Expr *E, LValue &Result, EvalInfo &Info,\n                            bool InvalidBaseOK = false);\nstatic bool EvaluateMemberPointer(const Expr *E, MemberPtr &Result,\n                                  EvalInfo &Info);\nstatic bool EvaluateTemporary(const Expr *E, LValue &Result, EvalInfo &Info);\nstatic bool EvaluateInteger(const Expr *E, APSInt &Result, EvalInfo &Info);\nstatic bool EvaluateIntegerOrLValue(const Expr *E, APValue &Result,\n                                    EvalInfo &Info);\nstatic bool EvaluateFloat(const Expr *E, APFloat &Result, EvalInfo &Info);\nstatic bool EvaluateComplex(const Expr *E, ComplexValue &Res, EvalInfo &Info);\nstatic bool EvaluateAtomic(const Expr *E, const LValue *This, APValue &Result,\n                           EvalInfo &Info);\nstatic bool EvaluateAsRValue(EvalInfo &Info, const Expr *E, APValue &Result);\n\n/// Evaluate an integer or fixed point expression into an APResult.\nstatic bool EvaluateFixedPointOrInteger(const Expr *E, APFixedPoint &Result,\n                                        EvalInfo &Info);\n\n/// Evaluate only a fixed point expression into an APResult.\nstatic bool EvaluateFixedPoint(const Expr *E, APFixedPoint &Result,\n                               EvalInfo &Info);\n\n//===----------------------------------------------------------------------===//\n// Misc utilities\n//===----------------------------------------------------------------------===//\n\n/// Negate an APSInt in place, converting it to a signed form if necessary, and\n/// preserving its value (by extending by up to one bit as needed).\nstatic void negateAsSigned(APSInt &Int) {\n  if (Int.isUnsigned() || Int.isMinSignedValue()) {\n    Int = Int.extend(Int.getBitWidth() + 1);\n    Int.setIsSigned(true);\n  }\n  Int = -Int;\n}\n\ntemplate<typename KeyT>\nAPValue &CallStackFrame::createTemporary(const KeyT *Key, QualType T,\n                                         ScopeKind Scope, LValue &LV) {\n  unsigned Version = getTempVersion();\n  APValue::LValueBase Base(Key, Index, Version);\n  LV.set(Base);\n  return createLocal(Base, Key, T, Scope);\n}\n\n/// Allocate storage for a parameter of a function call made in this frame.\nAPValue &CallStackFrame::createParam(CallRef Args, const ParmVarDecl *PVD,\n                                     LValue &LV) {\n  assert(Args.CallIndex == Index && \"creating parameter in wrong frame\");\n  APValue::LValueBase Base(PVD, Index, Args.Version);\n  LV.set(Base);\n  // We always destroy parameters at the end of the call, even if we'd allow\n  // them to live to the end of the full-expression at runtime, in order to\n  // give portable results and match other compilers.\n  return createLocal(Base, PVD, PVD->getType(), ScopeKind::Call);\n}\n\nAPValue &CallStackFrame::createLocal(APValue::LValueBase Base, const void *Key,\n                                     QualType T, ScopeKind Scope) {\n  assert(Base.getCallIndex() == Index && \"lvalue for wrong frame\");\n  unsigned Version = Base.getVersion();\n  APValue &Result = Temporaries[MapKeyTy(Key, Version)];\n  assert(Result.isAbsent() && \"local created multiple times\");\n\n  // If we're creating a local immediately in the operand of a speculative\n  // evaluation, don't register a cleanup to be run outside the speculative\n  // evaluation context, since we won't actually be able to initialize this\n  // object.\n  if (Index <= Info.SpeculativeEvaluationDepth) {\n    if (T.isDestructedType())\n      Info.noteSideEffect();\n  } else {\n    Info.CleanupStack.push_back(Cleanup(&Result, Base, T, Scope));\n  }\n  return Result;\n}\n\nAPValue *EvalInfo::createHeapAlloc(const Expr *E, QualType T, LValue &LV) {\n  if (NumHeapAllocs > DynamicAllocLValue::getMaxIndex()) {\n    FFDiag(E, diag::note_constexpr_heap_alloc_limit_exceeded);\n    return nullptr;\n  }\n\n  DynamicAllocLValue DA(NumHeapAllocs++);\n  LV.set(APValue::LValueBase::getDynamicAlloc(DA, T));\n  auto Result = HeapAllocs.emplace(std::piecewise_construct,\n                                   std::forward_as_tuple(DA), std::tuple<>());\n  assert(Result.second && \"reused a heap alloc index?\");\n  Result.first->second.AllocExpr = E;\n  return &Result.first->second.Value;\n}\n\n/// Produce a string describing the given constexpr call.\nvoid CallStackFrame::describe(raw_ostream &Out) {\n  unsigned ArgIndex = 0;\n  bool IsMemberCall = isa<CXXMethodDecl>(Callee) &&\n                      !isa<CXXConstructorDecl>(Callee) &&\n                      cast<CXXMethodDecl>(Callee)->isInstance();\n\n  if (!IsMemberCall)\n    Out << *Callee << '(';\n\n  if (This && IsMemberCall) {\n    APValue Val;\n    This->moveInto(Val);\n    Val.printPretty(Out, Info.Ctx,\n                    This->Designator.MostDerivedType);\n    // FIXME: Add parens around Val if needed.\n    Out << \"->\" << *Callee << '(';\n    IsMemberCall = false;\n  }\n\n  for (FunctionDecl::param_const_iterator I = Callee->param_begin(),\n       E = Callee->param_end(); I != E; ++I, ++ArgIndex) {\n    if (ArgIndex > (unsigned)IsMemberCall)\n      Out << \", \";\n\n    const ParmVarDecl *Param = *I;\n    APValue *V = Info.getParamSlot(Arguments, Param);\n    if (V)\n      V->printPretty(Out, Info.Ctx, Param->getType());\n    else\n      Out << \"<...>\";\n\n    if (ArgIndex == 0 && IsMemberCall)\n      Out << \"->\" << *Callee << '(';\n  }\n\n  Out << ')';\n}\n\n/// Evaluate an expression to see if it had side-effects, and discard its\n/// result.\n/// \\return \\c true if the caller should keep evaluating.\nstatic bool EvaluateIgnoredValue(EvalInfo &Info, const Expr *E) {\n  assert(!E->isValueDependent());\n  APValue Scratch;\n  if (!Evaluate(Scratch, Info, E))\n    // We don't need the value, but we might have skipped a side effect here.\n    return Info.noteSideEffect();\n  return true;\n}\n\n/// Should this call expression be treated as a string literal?\nstatic bool IsStringLiteralCall(const CallExpr *E) {\n  unsigned Builtin = E->getBuiltinCallee();\n  return (Builtin == Builtin::BI__builtin___CFStringMakeConstantString ||\n          Builtin == Builtin::BI__builtin___NSStringMakeConstantString);\n}\n\nstatic bool IsGlobalLValue(APValue::LValueBase B) {\n  // C++11 [expr.const]p3 An address constant expression is a prvalue core\n  // constant expression of pointer type that evaluates to...\n\n  // ... a null pointer value, or a prvalue core constant expression of type\n  // std::nullptr_t.\n  if (!B) return true;\n\n  if (const ValueDecl *D = B.dyn_cast<const ValueDecl*>()) {\n    // ... the address of an object with static storage duration,\n    if (const VarDecl *VD = dyn_cast<VarDecl>(D))\n      return VD->hasGlobalStorage();\n    if (isa<TemplateParamObjectDecl>(D))\n      return true;\n    // ... the address of a function,\n    // ... the address of a GUID [MS extension],\n    return isa<FunctionDecl>(D) || isa<MSGuidDecl>(D);\n  }\n\n  if (B.is<TypeInfoLValue>() || B.is<DynamicAllocLValue>())\n    return true;\n\n  const Expr *E = B.get<const Expr*>();\n  switch (E->getStmtClass()) {\n  default:\n    return false;\n  case Expr::CompoundLiteralExprClass: {\n    const CompoundLiteralExpr *CLE = cast<CompoundLiteralExpr>(E);\n    return CLE->isFileScope() && CLE->isLValue();\n  }\n  case Expr::MaterializeTemporaryExprClass:\n    // A materialized temporary might have been lifetime-extended to static\n    // storage duration.\n    return cast<MaterializeTemporaryExpr>(E)->getStorageDuration() == SD_Static;\n  // A string literal has static storage duration.\n  case Expr::StringLiteralClass:\n  case Expr::PredefinedExprClass:\n  case Expr::ObjCStringLiteralClass:\n  case Expr::ObjCEncodeExprClass:\n    return true;\n  case Expr::ObjCBoxedExprClass:\n    return cast<ObjCBoxedExpr>(E)->isExpressibleAsConstantInitializer();\n  case Expr::CallExprClass:\n    return IsStringLiteralCall(cast<CallExpr>(E));\n  // For GCC compatibility, &&label has static storage duration.\n  case Expr::AddrLabelExprClass:\n    return true;\n  // A Block literal expression may be used as the initialization value for\n  // Block variables at global or local static scope.\n  case Expr::BlockExprClass:\n    return !cast<BlockExpr>(E)->getBlockDecl()->hasCaptures();\n  case Expr::ImplicitValueInitExprClass:\n    // FIXME:\n    // We can never form an lvalue with an implicit value initialization as its\n    // base through expression evaluation, so these only appear in one case: the\n    // implicit variable declaration we invent when checking whether a constexpr\n    // constructor can produce a constant expression. We must assume that such\n    // an expression might be a global lvalue.\n    return true;\n  }\n}\n\nstatic const ValueDecl *GetLValueBaseDecl(const LValue &LVal) {\n  return LVal.Base.dyn_cast<const ValueDecl*>();\n}\n\nstatic bool IsLiteralLValue(const LValue &Value) {\n  if (Value.getLValueCallIndex())\n    return false;\n  const Expr *E = Value.Base.dyn_cast<const Expr*>();\n  return E && !isa<MaterializeTemporaryExpr>(E);\n}\n\nstatic bool IsWeakLValue(const LValue &Value) {\n  const ValueDecl *Decl = GetLValueBaseDecl(Value);\n  return Decl && Decl->isWeak();\n}\n\nstatic bool isZeroSized(const LValue &Value) {\n  const ValueDecl *Decl = GetLValueBaseDecl(Value);\n  if (Decl && isa<VarDecl>(Decl)) {\n    QualType Ty = Decl->getType();\n    if (Ty->isArrayType())\n      return Ty->isIncompleteType() ||\n             Decl->getASTContext().getTypeSize(Ty) == 0;\n  }\n  return false;\n}\n\nstatic bool HasSameBase(const LValue &A, const LValue &B) {\n  if (!A.getLValueBase())\n    return !B.getLValueBase();\n  if (!B.getLValueBase())\n    return false;\n\n  if (A.getLValueBase().getOpaqueValue() !=\n      B.getLValueBase().getOpaqueValue())\n    return false;\n\n  return A.getLValueCallIndex() == B.getLValueCallIndex() &&\n         A.getLValueVersion() == B.getLValueVersion();\n}\n\nstatic void NoteLValueLocation(EvalInfo &Info, APValue::LValueBase Base) {\n  assert(Base && \"no location for a null lvalue\");\n  const ValueDecl *VD = Base.dyn_cast<const ValueDecl*>();\n\n  // For a parameter, find the corresponding call stack frame (if it still\n  // exists), and point at the parameter of the function definition we actually\n  // invoked.\n  if (auto *PVD = dyn_cast_or_null<ParmVarDecl>(VD)) {\n    unsigned Idx = PVD->getFunctionScopeIndex();\n    for (CallStackFrame *F = Info.CurrentCall; F; F = F->Caller) {\n      if (F->Arguments.CallIndex == Base.getCallIndex() &&\n          F->Arguments.Version == Base.getVersion() && F->Callee &&\n          Idx < F->Callee->getNumParams()) {\n        VD = F->Callee->getParamDecl(Idx);\n        break;\n      }\n    }\n  }\n\n  if (VD)\n    Info.Note(VD->getLocation(), diag::note_declared_at);\n  else if (const Expr *E = Base.dyn_cast<const Expr*>())\n    Info.Note(E->getExprLoc(), diag::note_constexpr_temporary_here);\n  else if (DynamicAllocLValue DA = Base.dyn_cast<DynamicAllocLValue>()) {\n    // FIXME: Produce a note for dangling pointers too.\n    if (Optional<DynAlloc*> Alloc = Info.lookupDynamicAlloc(DA))\n      Info.Note((*Alloc)->AllocExpr->getExprLoc(),\n                diag::note_constexpr_dynamic_alloc_here);\n  }\n  // We have no information to show for a typeid(T) object.\n}\n\nenum class CheckEvaluationResultKind {\n  ConstantExpression,\n  FullyInitialized,\n};\n\n/// Materialized temporaries that we've already checked to determine if they're\n/// initializsed by a constant expression.\nusing CheckedTemporaries =\n    llvm::SmallPtrSet<const MaterializeTemporaryExpr *, 8>;\n\nstatic bool CheckEvaluationResult(CheckEvaluationResultKind CERK,\n                                  EvalInfo &Info, SourceLocation DiagLoc,\n                                  QualType Type, const APValue &Value,\n                                  ConstantExprKind Kind,\n                                  SourceLocation SubobjectLoc,\n                                  CheckedTemporaries &CheckedTemps);\n\n/// Check that this reference or pointer core constant expression is a valid\n/// value for an address or reference constant expression. Return true if we\n/// can fold this expression, whether or not it's a constant expression.\nstatic bool CheckLValueConstantExpression(EvalInfo &Info, SourceLocation Loc,\n                                          QualType Type, const LValue &LVal,\n                                          ConstantExprKind Kind,\n                                          CheckedTemporaries &CheckedTemps) {\n  bool IsReferenceType = Type->isReferenceType();\n\n  APValue::LValueBase Base = LVal.getLValueBase();\n  const SubobjectDesignator &Designator = LVal.getLValueDesignator();\n\n  const Expr *BaseE = Base.dyn_cast<const Expr *>();\n  const ValueDecl *BaseVD = Base.dyn_cast<const ValueDecl*>();\n\n  // Additional restrictions apply in a template argument. We only enforce the\n  // C++20 restrictions here; additional syntactic and semantic restrictions\n  // are applied elsewhere.\n  if (isTemplateArgument(Kind)) {\n    int InvalidBaseKind = -1;\n    StringRef Ident;\n    if (Base.is<TypeInfoLValue>())\n      InvalidBaseKind = 0;\n    else if (isa_and_nonnull<StringLiteral>(BaseE))\n      InvalidBaseKind = 1;\n    else if (isa_and_nonnull<MaterializeTemporaryExpr>(BaseE) ||\n             isa_and_nonnull<LifetimeExtendedTemporaryDecl>(BaseVD))\n      InvalidBaseKind = 2;\n    else if (auto *PE = dyn_cast_or_null<PredefinedExpr>(BaseE)) {\n      InvalidBaseKind = 3;\n      Ident = PE->getIdentKindName();\n    }\n\n    if (InvalidBaseKind != -1) {\n      Info.FFDiag(Loc, diag::note_constexpr_invalid_template_arg)\n          << IsReferenceType << !Designator.Entries.empty() << InvalidBaseKind\n          << Ident;\n      return false;\n    }\n  }\n\n  if (auto *FD = dyn_cast_or_null<FunctionDecl>(BaseVD)) {\n    if (FD->isConsteval()) {\n      Info.FFDiag(Loc, diag::note_consteval_address_accessible)\n          << !Type->isAnyPointerType();\n      Info.Note(FD->getLocation(), diag::note_declared_at);\n      return false;\n    }\n  }\n\n  // Check that the object is a global. Note that the fake 'this' object we\n  // manufacture when checking potential constant expressions is conservatively\n  // assumed to be global here.\n  if (!IsGlobalLValue(Base)) {\n    if (Info.getLangOpts().CPlusPlus11) {\n      const ValueDecl *VD = Base.dyn_cast<const ValueDecl*>();\n      Info.FFDiag(Loc, diag::note_constexpr_non_global, 1)\n        << IsReferenceType << !Designator.Entries.empty()\n        << !!VD << VD;\n\n      auto *VarD = dyn_cast_or_null<VarDecl>(VD);\n      if (VarD && VarD->isConstexpr()) {\n        // Non-static local constexpr variables have unintuitive semantics:\n        //   constexpr int a = 1;\n        //   constexpr const int *p = &a;\n        // ... is invalid because the address of 'a' is not constant. Suggest\n        // adding a 'static' in this case.\n        Info.Note(VarD->getLocation(), diag::note_constexpr_not_static)\n            << VarD\n            << FixItHint::CreateInsertion(VarD->getBeginLoc(), \"static \");\n      } else {\n        NoteLValueLocation(Info, Base);\n      }\n    } else {\n      Info.FFDiag(Loc);\n    }\n    // Don't allow references to temporaries to escape.\n    return false;\n  }\n  assert((Info.checkingPotentialConstantExpression() ||\n          LVal.getLValueCallIndex() == 0) &&\n         \"have call index for global lvalue\");\n\n  if (Base.is<DynamicAllocLValue>()) {\n    Info.FFDiag(Loc, diag::note_constexpr_dynamic_alloc)\n        << IsReferenceType << !Designator.Entries.empty();\n    NoteLValueLocation(Info, Base);\n    return false;\n  }\n\n  if (BaseVD) {\n    if (const VarDecl *Var = dyn_cast<const VarDecl>(BaseVD)) {\n      // Check if this is a thread-local variable.\n      if (Var->getTLSKind())\n        // FIXME: Diagnostic!\n        return false;\n\n      // A dllimport variable never acts like a constant, unless we're\n      // evaluating a value for use only in name mangling.\n      if (!isForManglingOnly(Kind) && Var->hasAttr<DLLImportAttr>())\n        // FIXME: Diagnostic!\n        return false;\n    }\n    if (const auto *FD = dyn_cast<const FunctionDecl>(BaseVD)) {\n      // __declspec(dllimport) must be handled very carefully:\n      // We must never initialize an expression with the thunk in C++.\n      // Doing otherwise would allow the same id-expression to yield\n      // different addresses for the same function in different translation\n      // units.  However, this means that we must dynamically initialize the\n      // expression with the contents of the import address table at runtime.\n      //\n      // The C language has no notion of ODR; furthermore, it has no notion of\n      // dynamic initialization.  This means that we are permitted to\n      // perform initialization with the address of the thunk.\n      if (Info.getLangOpts().CPlusPlus && !isForManglingOnly(Kind) &&\n          FD->hasAttr<DLLImportAttr>())\n        // FIXME: Diagnostic!\n        return false;\n    }\n  } else if (const auto *MTE =\n                 dyn_cast_or_null<MaterializeTemporaryExpr>(BaseE)) {\n    if (CheckedTemps.insert(MTE).second) {\n      QualType TempType = getType(Base);\n      if (TempType.isDestructedType()) {\n        Info.FFDiag(MTE->getExprLoc(),\n                    diag::note_constexpr_unsupported_temporary_nontrivial_dtor)\n            << TempType;\n        return false;\n      }\n\n      APValue *V = MTE->getOrCreateValue(false);\n      assert(V && \"evasluation result refers to uninitialised temporary\");\n      if (!CheckEvaluationResult(CheckEvaluationResultKind::ConstantExpression,\n                                 Info, MTE->getExprLoc(), TempType, *V,\n                                 Kind, SourceLocation(), CheckedTemps))\n        return false;\n    }\n  }\n\n  // Allow address constant expressions to be past-the-end pointers. This is\n  // an extension: the standard requires them to point to an object.\n  if (!IsReferenceType)\n    return true;\n\n  // A reference constant expression must refer to an object.\n  if (!Base) {\n    // FIXME: diagnostic\n    Info.CCEDiag(Loc);\n    return true;\n  }\n\n  // Does this refer one past the end of some object?\n  if (!Designator.Invalid && Designator.isOnePastTheEnd()) {\n    Info.FFDiag(Loc, diag::note_constexpr_past_end, 1)\n      << !Designator.Entries.empty() << !!BaseVD << BaseVD;\n    NoteLValueLocation(Info, Base);\n  }\n\n  return true;\n}\n\n/// Member pointers are constant expressions unless they point to a\n/// non-virtual dllimport member function.\nstatic bool CheckMemberPointerConstantExpression(EvalInfo &Info,\n                                                 SourceLocation Loc,\n                                                 QualType Type,\n                                                 const APValue &Value,\n                                                 ConstantExprKind Kind) {\n  const ValueDecl *Member = Value.getMemberPointerDecl();\n  const auto *FD = dyn_cast_or_null<CXXMethodDecl>(Member);\n  if (!FD)\n    return true;\n  if (FD->isConsteval()) {\n    Info.FFDiag(Loc, diag::note_consteval_address_accessible) << /*pointer*/ 0;\n    Info.Note(FD->getLocation(), diag::note_declared_at);\n    return false;\n  }\n  return isForManglingOnly(Kind) || FD->isVirtual() ||\n         !FD->hasAttr<DLLImportAttr>();\n}\n\n/// Check that this core constant expression is of literal type, and if not,\n/// produce an appropriate diagnostic.\nstatic bool CheckLiteralType(EvalInfo &Info, const Expr *E,\n                             const LValue *This = nullptr) {\n  if (!E->isRValue() || E->getType()->isLiteralType(Info.Ctx))\n    return true;\n\n  // C++1y: A constant initializer for an object o [...] may also invoke\n  // constexpr constructors for o and its subobjects even if those objects\n  // are of non-literal class types.\n  //\n  // C++11 missed this detail for aggregates, so classes like this:\n  //   struct foo_t { union { int i; volatile int j; } u; };\n  // are not (obviously) initializable like so:\n  //   __attribute__((__require_constant_initialization__))\n  //   static const foo_t x = {{0}};\n  // because \"i\" is a subobject with non-literal initialization (due to the\n  // volatile member of the union). See:\n  //   http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1677\n  // Therefore, we use the C++1y behavior.\n  if (This && Info.EvaluatingDecl == This->getLValueBase())\n    return true;\n\n  // Prvalue constant expressions must be of literal types.\n  if (Info.getLangOpts().CPlusPlus11)\n    Info.FFDiag(E, diag::note_constexpr_nonliteral)\n      << E->getType();\n  else\n    Info.FFDiag(E, diag::note_invalid_subexpr_in_const_expr);\n  return false;\n}\n\nstatic bool CheckEvaluationResult(CheckEvaluationResultKind CERK,\n                                  EvalInfo &Info, SourceLocation DiagLoc,\n                                  QualType Type, const APValue &Value,\n                                  ConstantExprKind Kind,\n                                  SourceLocation SubobjectLoc,\n                                  CheckedTemporaries &CheckedTemps) {\n  if (!Value.hasValue()) {\n    Info.FFDiag(DiagLoc, diag::note_constexpr_uninitialized)\n      << true << Type;\n    if (SubobjectLoc.isValid())\n      Info.Note(SubobjectLoc, diag::note_constexpr_subobject_declared_here);\n    return false;\n  }\n\n  // We allow _Atomic(T) to be initialized from anything that T can be\n  // initialized from.\n  if (const AtomicType *AT = Type->getAs<AtomicType>())\n    Type = AT->getValueType();\n\n  // Core issue 1454: For a literal constant expression of array or class type,\n  // each subobject of its value shall have been initialized by a constant\n  // expression.\n  if (Value.isArray()) {\n    QualType EltTy = Type->castAsArrayTypeUnsafe()->getElementType();\n    for (unsigned I = 0, N = Value.getArrayInitializedElts(); I != N; ++I) {\n      if (!CheckEvaluationResult(CERK, Info, DiagLoc, EltTy,\n                                 Value.getArrayInitializedElt(I), Kind,\n                                 SubobjectLoc, CheckedTemps))\n        return false;\n    }\n    if (!Value.hasArrayFiller())\n      return true;\n    return CheckEvaluationResult(CERK, Info, DiagLoc, EltTy,\n                                 Value.getArrayFiller(), Kind, SubobjectLoc,\n                                 CheckedTemps);\n  }\n  if (Value.isUnion() && Value.getUnionField()) {\n    return CheckEvaluationResult(\n        CERK, Info, DiagLoc, Value.getUnionField()->getType(),\n        Value.getUnionValue(), Kind, Value.getUnionField()->getLocation(),\n        CheckedTemps);\n  }\n  if (Value.isStruct()) {\n    RecordDecl *RD = Type->castAs<RecordType>()->getDecl();\n    if (const CXXRecordDecl *CD = dyn_cast<CXXRecordDecl>(RD)) {\n      unsigned BaseIndex = 0;\n      for (const CXXBaseSpecifier &BS : CD->bases()) {\n        if (!CheckEvaluationResult(CERK, Info, DiagLoc, BS.getType(),\n                                   Value.getStructBase(BaseIndex), Kind,\n                                   BS.getBeginLoc(), CheckedTemps))\n          return false;\n        ++BaseIndex;\n      }\n    }\n    for (const auto *I : RD->fields()) {\n      if (I->isUnnamedBitfield())\n        continue;\n\n      if (!CheckEvaluationResult(CERK, Info, DiagLoc, I->getType(),\n                                 Value.getStructField(I->getFieldIndex()),\n                                 Kind, I->getLocation(), CheckedTemps))\n        return false;\n    }\n  }\n\n  if (Value.isLValue() &&\n      CERK == CheckEvaluationResultKind::ConstantExpression) {\n    LValue LVal;\n    LVal.setFrom(Info.Ctx, Value);\n    return CheckLValueConstantExpression(Info, DiagLoc, Type, LVal, Kind,\n                                         CheckedTemps);\n  }\n\n  if (Value.isMemberPointer() &&\n      CERK == CheckEvaluationResultKind::ConstantExpression)\n    return CheckMemberPointerConstantExpression(Info, DiagLoc, Type, Value, Kind);\n\n  // Everything else is fine.\n  return true;\n}\n\n/// Check that this core constant expression value is a valid value for a\n/// constant expression. If not, report an appropriate diagnostic. Does not\n/// check that the expression is of literal type.\nstatic bool CheckConstantExpression(EvalInfo &Info, SourceLocation DiagLoc,\n                                    QualType Type, const APValue &Value,\n                                    ConstantExprKind Kind) {\n  // Nothing to check for a constant expression of type 'cv void'.\n  if (Type->isVoidType())\n    return true;\n\n  CheckedTemporaries CheckedTemps;\n  return CheckEvaluationResult(CheckEvaluationResultKind::ConstantExpression,\n                               Info, DiagLoc, Type, Value, Kind,\n                               SourceLocation(), CheckedTemps);\n}\n\n/// Check that this evaluated value is fully-initialized and can be loaded by\n/// an lvalue-to-rvalue conversion.\nstatic bool CheckFullyInitialized(EvalInfo &Info, SourceLocation DiagLoc,\n                                  QualType Type, const APValue &Value) {\n  CheckedTemporaries CheckedTemps;\n  return CheckEvaluationResult(\n      CheckEvaluationResultKind::FullyInitialized, Info, DiagLoc, Type, Value,\n      ConstantExprKind::Normal, SourceLocation(), CheckedTemps);\n}\n\n/// Enforce C++2a [expr.const]/4.17, which disallows new-expressions unless\n/// \"the allocated storage is deallocated within the evaluation\".\nstatic bool CheckMemoryLeaks(EvalInfo &Info) {\n  if (!Info.HeapAllocs.empty()) {\n    // We can still fold to a constant despite a compile-time memory leak,\n    // so long as the heap allocation isn't referenced in the result (we check\n    // that in CheckConstantExpression).\n    Info.CCEDiag(Info.HeapAllocs.begin()->second.AllocExpr,\n                 diag::note_constexpr_memory_leak)\n        << unsigned(Info.HeapAllocs.size() - 1);\n  }\n  return true;\n}\n\nstatic bool EvalPointerValueAsBool(const APValue &Value, bool &Result) {\n  // A null base expression indicates a null pointer.  These are always\n  // evaluatable, and they are false unless the offset is zero.\n  if (!Value.getLValueBase()) {\n    Result = !Value.getLValueOffset().isZero();\n    return true;\n  }\n\n  // We have a non-null base.  These are generally known to be true, but if it's\n  // a weak declaration it can be null at runtime.\n  Result = true;\n  const ValueDecl *Decl = Value.getLValueBase().dyn_cast<const ValueDecl*>();\n  return !Decl || !Decl->isWeak();\n}\n\nstatic bool HandleConversionToBool(const APValue &Val, bool &Result) {\n  switch (Val.getKind()) {\n  case APValue::None:\n  case APValue::Indeterminate:\n    return false;\n  case APValue::Int:\n    Result = Val.getInt().getBoolValue();\n    return true;\n  case APValue::FixedPoint:\n    Result = Val.getFixedPoint().getBoolValue();\n    return true;\n  case APValue::Float:\n    Result = !Val.getFloat().isZero();\n    return true;\n  case APValue::ComplexInt:\n    Result = Val.getComplexIntReal().getBoolValue() ||\n             Val.getComplexIntImag().getBoolValue();\n    return true;\n  case APValue::ComplexFloat:\n    Result = !Val.getComplexFloatReal().isZero() ||\n             !Val.getComplexFloatImag().isZero();\n    return true;\n  case APValue::LValue:\n    return EvalPointerValueAsBool(Val, Result);\n  case APValue::MemberPointer:\n    Result = Val.getMemberPointerDecl();\n    return true;\n  case APValue::Vector:\n  case APValue::Array:\n  case APValue::Struct:\n  case APValue::Union:\n  case APValue::AddrLabelDiff:\n    return false;\n  }\n\n  llvm_unreachable(\"unknown APValue kind\");\n}\n\nstatic bool EvaluateAsBooleanCondition(const Expr *E, bool &Result,\n                                       EvalInfo &Info) {\n  assert(!E->isValueDependent());\n  assert(E->isRValue() && \"missing lvalue-to-rvalue conv in bool condition\");\n  APValue Val;\n  if (!Evaluate(Val, Info, E))\n    return false;\n  return HandleConversionToBool(Val, Result);\n}\n\ntemplate<typename T>\nstatic bool HandleOverflow(EvalInfo &Info, const Expr *E,\n                           const T &SrcValue, QualType DestType) {\n  Info.CCEDiag(E, diag::note_constexpr_overflow)\n    << SrcValue << DestType;\n  return Info.noteUndefinedBehavior();\n}\n\nstatic bool HandleFloatToIntCast(EvalInfo &Info, const Expr *E,\n                                 QualType SrcType, const APFloat &Value,\n                                 QualType DestType, APSInt &Result) {\n  unsigned DestWidth = Info.Ctx.getIntWidth(DestType);\n  // Determine whether we are converting to unsigned or signed.\n  bool DestSigned = DestType->isSignedIntegerOrEnumerationType();\n\n  Result = APSInt(DestWidth, !DestSigned);\n  bool ignored;\n  if (Value.convertToInteger(Result, llvm::APFloat::rmTowardZero, &ignored)\n      & APFloat::opInvalidOp)\n    return HandleOverflow(Info, E, Value, DestType);\n  return true;\n}\n\n/// Get rounding mode used for evaluation of the specified expression.\n/// \\param[out] DynamicRM Is set to true is the requested rounding mode is\n///                       dynamic.\n/// If rounding mode is unknown at compile time, still try to evaluate the\n/// expression. If the result is exact, it does not depend on rounding mode.\n/// So return \"tonearest\" mode instead of \"dynamic\".\nstatic llvm::RoundingMode getActiveRoundingMode(EvalInfo &Info, const Expr *E,\n                                                bool &DynamicRM) {\n  llvm::RoundingMode RM =\n      E->getFPFeaturesInEffect(Info.Ctx.getLangOpts()).getRoundingMode();\n  DynamicRM = (RM == llvm::RoundingMode::Dynamic);\n  if (DynamicRM)\n    RM = llvm::RoundingMode::NearestTiesToEven;\n  return RM;\n}\n\n/// Check if the given evaluation result is allowed for constant evaluation.\nstatic bool checkFloatingPointResult(EvalInfo &Info, const Expr *E,\n                                     APFloat::opStatus St) {\n  // In a constant context, assume that any dynamic rounding mode or FP\n  // exception state matches the default floating-point environment.\n  if (Info.InConstantContext)\n    return true;\n\n  FPOptions FPO = E->getFPFeaturesInEffect(Info.Ctx.getLangOpts());\n  if ((St & APFloat::opInexact) &&\n      FPO.getRoundingMode() == llvm::RoundingMode::Dynamic) {\n    // Inexact result means that it depends on rounding mode. If the requested\n    // mode is dynamic, the evaluation cannot be made in compile time.\n    Info.FFDiag(E, diag::note_constexpr_dynamic_rounding);\n    return false;\n  }\n\n  if ((St != APFloat::opOK) &&\n      (FPO.getRoundingMode() == llvm::RoundingMode::Dynamic ||\n       FPO.getFPExceptionMode() != LangOptions::FPE_Ignore ||\n       FPO.getAllowFEnvAccess())) {\n    Info.FFDiag(E, diag::note_constexpr_float_arithmetic_strict);\n    return false;\n  }\n\n  if ((St & APFloat::opStatus::opInvalidOp) &&\n      FPO.getFPExceptionMode() != LangOptions::FPE_Ignore) {\n    // There is no usefully definable result.\n    Info.FFDiag(E);\n    return false;\n  }\n\n  // FIXME: if:\n  // - evaluation triggered other FP exception, and\n  // - exception mode is not \"ignore\", and\n  // - the expression being evaluated is not a part of global variable\n  //   initializer,\n  // the evaluation probably need to be rejected.\n  return true;\n}\n\nstatic bool HandleFloatToFloatCast(EvalInfo &Info, const Expr *E,\n                                   QualType SrcType, QualType DestType,\n                                   APFloat &Result) {\n  assert(isa<CastExpr>(E) || isa<CompoundAssignOperator>(E));\n  bool DynamicRM;\n  llvm::RoundingMode RM = getActiveRoundingMode(Info, E, DynamicRM);\n  APFloat::opStatus St;\n  APFloat Value = Result;\n  bool ignored;\n  St = Result.convert(Info.Ctx.getFloatTypeSemantics(DestType), RM, &ignored);\n  return checkFloatingPointResult(Info, E, St);\n}\n\nstatic APSInt HandleIntToIntCast(EvalInfo &Info, const Expr *E,\n                                 QualType DestType, QualType SrcType,\n                                 const APSInt &Value) {\n  unsigned DestWidth = Info.Ctx.getIntWidth(DestType);\n  // Figure out if this is a truncate, extend or noop cast.\n  // If the input is signed, do a sign extend, noop, or truncate.\n  APSInt Result = Value.extOrTrunc(DestWidth);\n  Result.setIsUnsigned(DestType->isUnsignedIntegerOrEnumerationType());\n  if (DestType->isBooleanType())\n    Result = Value.getBoolValue();\n  return Result;\n}\n\nstatic bool HandleIntToFloatCast(EvalInfo &Info, const Expr *E,\n                                 const FPOptions FPO,\n                                 QualType SrcType, const APSInt &Value,\n                                 QualType DestType, APFloat &Result) {\n  Result = APFloat(Info.Ctx.getFloatTypeSemantics(DestType), 1);\n  APFloat::opStatus St = Result.convertFromAPInt(Value, Value.isSigned(),\n       APFloat::rmNearestTiesToEven);\n  if (!Info.InConstantContext && St != llvm::APFloatBase::opOK &&\n      FPO.isFPConstrained()) {\n    Info.FFDiag(E, diag::note_constexpr_float_arithmetic_strict);\n    return false;\n  }\n  return true;\n}\n\nstatic bool truncateBitfieldValue(EvalInfo &Info, const Expr *E,\n                                  APValue &Value, const FieldDecl *FD) {\n  assert(FD->isBitField() && \"truncateBitfieldValue on non-bitfield\");\n\n  if (!Value.isInt()) {\n    // Trying to store a pointer-cast-to-integer into a bitfield.\n    // FIXME: In this case, we should provide the diagnostic for casting\n    // a pointer to an integer.\n    assert(Value.isLValue() && \"integral value neither int nor lvalue?\");\n    Info.FFDiag(E);\n    return false;\n  }\n\n  APSInt &Int = Value.getInt();\n  unsigned OldBitWidth = Int.getBitWidth();\n  unsigned NewBitWidth = FD->getBitWidthValue(Info.Ctx);\n  if (NewBitWidth < OldBitWidth)\n    Int = Int.trunc(NewBitWidth).extend(OldBitWidth);\n  return true;\n}\n\nstatic bool EvalAndBitcastToAPInt(EvalInfo &Info, const Expr *E,\n                                  llvm::APInt &Res) {\n  APValue SVal;\n  if (!Evaluate(SVal, Info, E))\n    return false;\n  if (SVal.isInt()) {\n    Res = SVal.getInt();\n    return true;\n  }\n  if (SVal.isFloat()) {\n    Res = SVal.getFloat().bitcastToAPInt();\n    return true;\n  }\n  if (SVal.isVector()) {\n    QualType VecTy = E->getType();\n    unsigned VecSize = Info.Ctx.getTypeSize(VecTy);\n    QualType EltTy = VecTy->castAs<VectorType>()->getElementType();\n    unsigned EltSize = Info.Ctx.getTypeSize(EltTy);\n    bool BigEndian = Info.Ctx.getTargetInfo().isBigEndian();\n    Res = llvm::APInt::getNullValue(VecSize);\n    for (unsigned i = 0; i < SVal.getVectorLength(); i++) {\n      APValue &Elt = SVal.getVectorElt(i);\n      llvm::APInt EltAsInt;\n      if (Elt.isInt()) {\n        EltAsInt = Elt.getInt();\n      } else if (Elt.isFloat()) {\n        EltAsInt = Elt.getFloat().bitcastToAPInt();\n      } else {\n        // Don't try to handle vectors of anything other than int or float\n        // (not sure if it's possible to hit this case).\n        Info.FFDiag(E, diag::note_invalid_subexpr_in_const_expr);\n        return false;\n      }\n      unsigned BaseEltSize = EltAsInt.getBitWidth();\n      if (BigEndian)\n        Res |= EltAsInt.zextOrTrunc(VecSize).rotr(i*EltSize+BaseEltSize);\n      else\n        Res |= EltAsInt.zextOrTrunc(VecSize).rotl(i*EltSize);\n    }\n    return true;\n  }\n  // Give up if the input isn't an int, float, or vector.  For example, we\n  // reject \"(v4i16)(intptr_t)&a\".\n  Info.FFDiag(E, diag::note_invalid_subexpr_in_const_expr);\n  return false;\n}\n\n/// Perform the given integer operation, which is known to need at most BitWidth\n/// bits, and check for overflow in the original type (if that type was not an\n/// unsigned type).\ntemplate<typename Operation>\nstatic bool CheckedIntArithmetic(EvalInfo &Info, const Expr *E,\n                                 const APSInt &LHS, const APSInt &RHS,\n                                 unsigned BitWidth, Operation Op,\n                                 APSInt &Result) {\n  if (LHS.isUnsigned()) {\n    Result = Op(LHS, RHS);\n    return true;\n  }\n\n  APSInt Value(Op(LHS.extend(BitWidth), RHS.extend(BitWidth)), false);\n  Result = Value.trunc(LHS.getBitWidth());\n  if (Result.extend(BitWidth) != Value) {\n    if (Info.checkingForUndefinedBehavior())\n      Info.Ctx.getDiagnostics().Report(E->getExprLoc(),\n                                       diag::warn_integer_constant_overflow)\n          << Result.toString(10) << E->getType();\n    return HandleOverflow(Info, E, Value, E->getType());\n  }\n  return true;\n}\n\n/// Perform the given binary integer operation.\nstatic bool handleIntIntBinOp(EvalInfo &Info, const Expr *E, const APSInt &LHS,\n                              BinaryOperatorKind Opcode, APSInt RHS,\n                              APSInt &Result) {\n  switch (Opcode) {\n  default:\n    Info.FFDiag(E);\n    return false;\n  case BO_Mul:\n    return CheckedIntArithmetic(Info, E, LHS, RHS, LHS.getBitWidth() * 2,\n                                std::multiplies<APSInt>(), Result);\n  case BO_Add:\n    return CheckedIntArithmetic(Info, E, LHS, RHS, LHS.getBitWidth() + 1,\n                                std::plus<APSInt>(), Result);\n  case BO_Sub:\n    return CheckedIntArithmetic(Info, E, LHS, RHS, LHS.getBitWidth() + 1,\n                                std::minus<APSInt>(), Result);\n  case BO_And: Result = LHS & RHS; return true;\n  case BO_Xor: Result = LHS ^ RHS; return true;\n  case BO_Or:  Result = LHS | RHS; return true;\n  case BO_Div:\n  case BO_Rem:\n    if (RHS == 0) {\n      Info.FFDiag(E, diag::note_expr_divide_by_zero);\n      return false;\n    }\n    Result = (Opcode == BO_Rem ? LHS % RHS : LHS / RHS);\n    // Check for overflow case: INT_MIN / -1 or INT_MIN % -1. APSInt supports\n    // this operation and gives the two's complement result.\n    if (RHS.isNegative() && RHS.isAllOnesValue() &&\n        LHS.isSigned() && LHS.isMinSignedValue())\n      return HandleOverflow(Info, E, -LHS.extend(LHS.getBitWidth() + 1),\n                            E->getType());\n    return true;\n  case BO_Shl: {\n    if (Info.getLangOpts().OpenCL)\n      // OpenCL 6.3j: shift values are effectively % word size of LHS.\n      RHS &= APSInt(llvm::APInt(RHS.getBitWidth(),\n                    static_cast<uint64_t>(LHS.getBitWidth() - 1)),\n                    RHS.isUnsigned());\n    else if (RHS.isSigned() && RHS.isNegative()) {\n      // During constant-folding, a negative shift is an opposite shift. Such\n      // a shift is not a constant expression.\n      Info.CCEDiag(E, diag::note_constexpr_negative_shift) << RHS;\n      RHS = -RHS;\n      goto shift_right;\n    }\n  shift_left:\n    // C++11 [expr.shift]p1: Shift width must be less than the bit width of\n    // the shifted type.\n    unsigned SA = (unsigned) RHS.getLimitedValue(LHS.getBitWidth()-1);\n    if (SA != RHS) {\n      Info.CCEDiag(E, diag::note_constexpr_large_shift)\n        << RHS << E->getType() << LHS.getBitWidth();\n    } else if (LHS.isSigned() && !Info.getLangOpts().CPlusPlus20) {\n      // C++11 [expr.shift]p2: A signed left shift must have a non-negative\n      // operand, and must not overflow the corresponding unsigned type.\n      // C++2a [expr.shift]p2: E1 << E2 is the unique value congruent to\n      // E1 x 2^E2 module 2^N.\n      if (LHS.isNegative())\n        Info.CCEDiag(E, diag::note_constexpr_lshift_of_negative) << LHS;\n      else if (LHS.countLeadingZeros() < SA)\n        Info.CCEDiag(E, diag::note_constexpr_lshift_discards);\n    }\n    Result = LHS << SA;\n    return true;\n  }\n  case BO_Shr: {\n    if (Info.getLangOpts().OpenCL)\n      // OpenCL 6.3j: shift values are effectively % word size of LHS.\n      RHS &= APSInt(llvm::APInt(RHS.getBitWidth(),\n                    static_cast<uint64_t>(LHS.getBitWidth() - 1)),\n                    RHS.isUnsigned());\n    else if (RHS.isSigned() && RHS.isNegative()) {\n      // During constant-folding, a negative shift is an opposite shift. Such a\n      // shift is not a constant expression.\n      Info.CCEDiag(E, diag::note_constexpr_negative_shift) << RHS;\n      RHS = -RHS;\n      goto shift_left;\n    }\n  shift_right:\n    // C++11 [expr.shift]p1: Shift width must be less than the bit width of the\n    // shifted type.\n    unsigned SA = (unsigned) RHS.getLimitedValue(LHS.getBitWidth()-1);\n    if (SA != RHS)\n      Info.CCEDiag(E, diag::note_constexpr_large_shift)\n        << RHS << E->getType() << LHS.getBitWidth();\n    Result = LHS >> SA;\n    return true;\n  }\n\n  case BO_LT: Result = LHS < RHS; return true;\n  case BO_GT: Result = LHS > RHS; return true;\n  case BO_LE: Result = LHS <= RHS; return true;\n  case BO_GE: Result = LHS >= RHS; return true;\n  case BO_EQ: Result = LHS == RHS; return true;\n  case BO_NE: Result = LHS != RHS; return true;\n  case BO_Cmp:\n    llvm_unreachable(\"BO_Cmp should be handled elsewhere\");\n  }\n}\n\n/// Perform the given binary floating-point operation, in-place, on LHS.\nstatic bool handleFloatFloatBinOp(EvalInfo &Info, const BinaryOperator *E,\n                                  APFloat &LHS, BinaryOperatorKind Opcode,\n                                  const APFloat &RHS) {\n  bool DynamicRM;\n  llvm::RoundingMode RM = getActiveRoundingMode(Info, E, DynamicRM);\n  APFloat::opStatus St;\n  switch (Opcode) {\n  default:\n    Info.FFDiag(E);\n    return false;\n  case BO_Mul:\n    St = LHS.multiply(RHS, RM);\n    break;\n  case BO_Add:\n    St = LHS.add(RHS, RM);\n    break;\n  case BO_Sub:\n    St = LHS.subtract(RHS, RM);\n    break;\n  case BO_Div:\n    // [expr.mul]p4:\n    //   If the second operand of / or % is zero the behavior is undefined.\n    if (RHS.isZero())\n      Info.CCEDiag(E, diag::note_expr_divide_by_zero);\n    St = LHS.divide(RHS, RM);\n    break;\n  }\n\n  // [expr.pre]p4:\n  //   If during the evaluation of an expression, the result is not\n  //   mathematically defined [...], the behavior is undefined.\n  // FIXME: C++ rules require us to not conform to IEEE 754 here.\n  if (LHS.isNaN()) {\n    Info.CCEDiag(E, diag::note_constexpr_float_arithmetic) << LHS.isNaN();\n    return Info.noteUndefinedBehavior();\n  }\n\n  return checkFloatingPointResult(Info, E, St);\n}\n\nstatic bool handleLogicalOpForVector(const APInt &LHSValue,\n                                     BinaryOperatorKind Opcode,\n                                     const APInt &RHSValue, APInt &Result) {\n  bool LHS = (LHSValue != 0);\n  bool RHS = (RHSValue != 0);\n\n  if (Opcode == BO_LAnd)\n    Result = LHS && RHS;\n  else\n    Result = LHS || RHS;\n  return true;\n}\nstatic bool handleLogicalOpForVector(const APFloat &LHSValue,\n                                     BinaryOperatorKind Opcode,\n                                     const APFloat &RHSValue, APInt &Result) {\n  bool LHS = !LHSValue.isZero();\n  bool RHS = !RHSValue.isZero();\n\n  if (Opcode == BO_LAnd)\n    Result = LHS && RHS;\n  else\n    Result = LHS || RHS;\n  return true;\n}\n\nstatic bool handleLogicalOpForVector(const APValue &LHSValue,\n                                     BinaryOperatorKind Opcode,\n                                     const APValue &RHSValue, APInt &Result) {\n  // The result is always an int type, however operands match the first.\n  if (LHSValue.getKind() == APValue::Int)\n    return handleLogicalOpForVector(LHSValue.getInt(), Opcode,\n                                    RHSValue.getInt(), Result);\n  assert(LHSValue.getKind() == APValue::Float && \"Should be no other options\");\n  return handleLogicalOpForVector(LHSValue.getFloat(), Opcode,\n                                  RHSValue.getFloat(), Result);\n}\n\ntemplate <typename APTy>\nstatic bool\nhandleCompareOpForVectorHelper(const APTy &LHSValue, BinaryOperatorKind Opcode,\n                               const APTy &RHSValue, APInt &Result) {\n  switch (Opcode) {\n  default:\n    llvm_unreachable(\"unsupported binary operator\");\n  case BO_EQ:\n    Result = (LHSValue == RHSValue);\n    break;\n  case BO_NE:\n    Result = (LHSValue != RHSValue);\n    break;\n  case BO_LT:\n    Result = (LHSValue < RHSValue);\n    break;\n  case BO_GT:\n    Result = (LHSValue > RHSValue);\n    break;\n  case BO_LE:\n    Result = (LHSValue <= RHSValue);\n    break;\n  case BO_GE:\n    Result = (LHSValue >= RHSValue);\n    break;\n  }\n\n  return true;\n}\n\nstatic bool handleCompareOpForVector(const APValue &LHSValue,\n                                     BinaryOperatorKind Opcode,\n                                     const APValue &RHSValue, APInt &Result) {\n  // The result is always an int type, however operands match the first.\n  if (LHSValue.getKind() == APValue::Int)\n    return handleCompareOpForVectorHelper(LHSValue.getInt(), Opcode,\n                                          RHSValue.getInt(), Result);\n  assert(LHSValue.getKind() == APValue::Float && \"Should be no other options\");\n  return handleCompareOpForVectorHelper(LHSValue.getFloat(), Opcode,\n                                        RHSValue.getFloat(), Result);\n}\n\n// Perform binary operations for vector types, in place on the LHS.\nstatic bool handleVectorVectorBinOp(EvalInfo &Info, const BinaryOperator *E,\n                                    BinaryOperatorKind Opcode,\n                                    APValue &LHSValue,\n                                    const APValue &RHSValue) {\n  assert(Opcode != BO_PtrMemD && Opcode != BO_PtrMemI &&\n         \"Operation not supported on vector types\");\n\n  const auto *VT = E->getType()->castAs<VectorType>();\n  unsigned NumElements = VT->getNumElements();\n  QualType EltTy = VT->getElementType();\n\n  // In the cases (typically C as I've observed) where we aren't evaluating\n  // constexpr but are checking for cases where the LHS isn't yet evaluatable,\n  // just give up.\n  if (!LHSValue.isVector()) {\n    assert(LHSValue.isLValue() &&\n           \"A vector result that isn't a vector OR uncalculated LValue\");\n    Info.FFDiag(E);\n    return false;\n  }\n\n  assert(LHSValue.getVectorLength() == NumElements &&\n         RHSValue.getVectorLength() == NumElements && \"Different vector sizes\");\n\n  SmallVector<APValue, 4> ResultElements;\n\n  for (unsigned EltNum = 0; EltNum < NumElements; ++EltNum) {\n    APValue LHSElt = LHSValue.getVectorElt(EltNum);\n    APValue RHSElt = RHSValue.getVectorElt(EltNum);\n\n    if (EltTy->isIntegerType()) {\n      APSInt EltResult{Info.Ctx.getIntWidth(EltTy),\n                       EltTy->isUnsignedIntegerType()};\n      bool Success = true;\n\n      if (BinaryOperator::isLogicalOp(Opcode))\n        Success = handleLogicalOpForVector(LHSElt, Opcode, RHSElt, EltResult);\n      else if (BinaryOperator::isComparisonOp(Opcode))\n        Success = handleCompareOpForVector(LHSElt, Opcode, RHSElt, EltResult);\n      else\n        Success = handleIntIntBinOp(Info, E, LHSElt.getInt(), Opcode,\n                                    RHSElt.getInt(), EltResult);\n\n      if (!Success) {\n        Info.FFDiag(E);\n        return false;\n      }\n      ResultElements.emplace_back(EltResult);\n\n    } else if (EltTy->isFloatingType()) {\n      assert(LHSElt.getKind() == APValue::Float &&\n             RHSElt.getKind() == APValue::Float &&\n             \"Mismatched LHS/RHS/Result Type\");\n      APFloat LHSFloat = LHSElt.getFloat();\n\n      if (!handleFloatFloatBinOp(Info, E, LHSFloat, Opcode,\n                                 RHSElt.getFloat())) {\n        Info.FFDiag(E);\n        return false;\n      }\n\n      ResultElements.emplace_back(LHSFloat);\n    }\n  }\n\n  LHSValue = APValue(ResultElements.data(), ResultElements.size());\n  return true;\n}\n\n/// Cast an lvalue referring to a base subobject to a derived class, by\n/// truncating the lvalue's path to the given length.\nstatic bool CastToDerivedClass(EvalInfo &Info, const Expr *E, LValue &Result,\n                               const RecordDecl *TruncatedType,\n                               unsigned TruncatedElements) {\n  SubobjectDesignator &D = Result.Designator;\n\n  // Check we actually point to a derived class object.\n  if (TruncatedElements == D.Entries.size())\n    return true;\n  assert(TruncatedElements >= D.MostDerivedPathLength &&\n         \"not casting to a derived class\");\n  if (!Result.checkSubobject(Info, E, CSK_Derived))\n    return false;\n\n  // Truncate the path to the subobject, and remove any derived-to-base offsets.\n  const RecordDecl *RD = TruncatedType;\n  for (unsigned I = TruncatedElements, N = D.Entries.size(); I != N; ++I) {\n    if (RD->isInvalidDecl()) return false;\n    const ASTRecordLayout &Layout = Info.Ctx.getASTRecordLayout(RD);\n    const CXXRecordDecl *Base = getAsBaseClass(D.Entries[I]);\n    if (isVirtualBaseClass(D.Entries[I]))\n      Result.Offset -= Layout.getVBaseClassOffset(Base);\n    else\n      Result.Offset -= Layout.getBaseClassOffset(Base);\n    RD = Base;\n  }\n  D.Entries.resize(TruncatedElements);\n  return true;\n}\n\nstatic bool HandleLValueDirectBase(EvalInfo &Info, const Expr *E, LValue &Obj,\n                                   const CXXRecordDecl *Derived,\n                                   const CXXRecordDecl *Base,\n                                   const ASTRecordLayout *RL = nullptr) {\n  if (!RL) {\n    if (Derived->isInvalidDecl()) return false;\n    RL = &Info.Ctx.getASTRecordLayout(Derived);\n  }\n\n  Obj.getLValueOffset() += RL->getBaseClassOffset(Base);\n  Obj.addDecl(Info, E, Base, /*Virtual*/ false);\n  return true;\n}\n\nstatic bool HandleLValueBase(EvalInfo &Info, const Expr *E, LValue &Obj,\n                             const CXXRecordDecl *DerivedDecl,\n                             const CXXBaseSpecifier *Base) {\n  const CXXRecordDecl *BaseDecl = Base->getType()->getAsCXXRecordDecl();\n\n  if (!Base->isVirtual())\n    return HandleLValueDirectBase(Info, E, Obj, DerivedDecl, BaseDecl);\n\n  SubobjectDesignator &D = Obj.Designator;\n  if (D.Invalid)\n    return false;\n\n  // Extract most-derived object and corresponding type.\n  DerivedDecl = D.MostDerivedType->getAsCXXRecordDecl();\n  if (!CastToDerivedClass(Info, E, Obj, DerivedDecl, D.MostDerivedPathLength))\n    return false;\n\n  // Find the virtual base class.\n  if (DerivedDecl->isInvalidDecl()) return false;\n  const ASTRecordLayout &Layout = Info.Ctx.getASTRecordLayout(DerivedDecl);\n  Obj.getLValueOffset() += Layout.getVBaseClassOffset(BaseDecl);\n  Obj.addDecl(Info, E, BaseDecl, /*Virtual*/ true);\n  return true;\n}\n\nstatic bool HandleLValueBasePath(EvalInfo &Info, const CastExpr *E,\n                                 QualType Type, LValue &Result) {\n  for (CastExpr::path_const_iterator PathI = E->path_begin(),\n                                     PathE = E->path_end();\n       PathI != PathE; ++PathI) {\n    if (!HandleLValueBase(Info, E, Result, Type->getAsCXXRecordDecl(),\n                          *PathI))\n      return false;\n    Type = (*PathI)->getType();\n  }\n  return true;\n}\n\n/// Cast an lvalue referring to a derived class to a known base subobject.\nstatic bool CastToBaseClass(EvalInfo &Info, const Expr *E, LValue &Result,\n                            const CXXRecordDecl *DerivedRD,\n                            const CXXRecordDecl *BaseRD) {\n  CXXBasePaths Paths(/*FindAmbiguities=*/false,\n                     /*RecordPaths=*/true, /*DetectVirtual=*/false);\n  if (!DerivedRD->isDerivedFrom(BaseRD, Paths))\n    llvm_unreachable(\"Class must be derived from the passed in base class!\");\n\n  for (CXXBasePathElement &Elem : Paths.front())\n    if (!HandleLValueBase(Info, E, Result, Elem.Class, Elem.Base))\n      return false;\n  return true;\n}\n\n/// Update LVal to refer to the given field, which must be a member of the type\n/// currently described by LVal.\nstatic bool HandleLValueMember(EvalInfo &Info, const Expr *E, LValue &LVal,\n                               const FieldDecl *FD,\n                               const ASTRecordLayout *RL = nullptr) {\n  if (!RL) {\n    if (FD->getParent()->isInvalidDecl()) return false;\n    RL = &Info.Ctx.getASTRecordLayout(FD->getParent());\n  }\n\n  unsigned I = FD->getFieldIndex();\n  LVal.adjustOffset(Info.Ctx.toCharUnitsFromBits(RL->getFieldOffset(I)));\n  LVal.addDecl(Info, E, FD);\n  return true;\n}\n\n/// Update LVal to refer to the given indirect field.\nstatic bool HandleLValueIndirectMember(EvalInfo &Info, const Expr *E,\n                                       LValue &LVal,\n                                       const IndirectFieldDecl *IFD) {\n  for (const auto *C : IFD->chain())\n    if (!HandleLValueMember(Info, E, LVal, cast<FieldDecl>(C)))\n      return false;\n  return true;\n}\n\n/// Get the size of the given type in char units.\nstatic bool HandleSizeof(EvalInfo &Info, SourceLocation Loc,\n                         QualType Type, CharUnits &Size) {\n  // sizeof(void), __alignof__(void), sizeof(function) = 1 as a gcc\n  // extension.\n  if (Type->isVoidType() || Type->isFunctionType()) {\n    Size = CharUnits::One();\n    return true;\n  }\n\n  if (Type->isDependentType()) {\n    Info.FFDiag(Loc);\n    return false;\n  }\n\n  if (!Type->isConstantSizeType()) {\n    // sizeof(vla) is not a constantexpr: C99 6.5.3.4p2.\n    // FIXME: Better diagnostic.\n    Info.FFDiag(Loc);\n    return false;\n  }\n\n  Size = Info.Ctx.getTypeSizeInChars(Type);\n  return true;\n}\n\n/// Update a pointer value to model pointer arithmetic.\n/// \\param Info - Information about the ongoing evaluation.\n/// \\param E - The expression being evaluated, for diagnostic purposes.\n/// \\param LVal - The pointer value to be updated.\n/// \\param EltTy - The pointee type represented by LVal.\n/// \\param Adjustment - The adjustment, in objects of type EltTy, to add.\nstatic bool HandleLValueArrayAdjustment(EvalInfo &Info, const Expr *E,\n                                        LValue &LVal, QualType EltTy,\n                                        APSInt Adjustment) {\n  CharUnits SizeOfPointee;\n  if (!HandleSizeof(Info, E->getExprLoc(), EltTy, SizeOfPointee))\n    return false;\n\n  LVal.adjustOffsetAndIndex(Info, E, Adjustment, SizeOfPointee);\n  return true;\n}\n\nstatic bool HandleLValueArrayAdjustment(EvalInfo &Info, const Expr *E,\n                                        LValue &LVal, QualType EltTy,\n                                        int64_t Adjustment) {\n  return HandleLValueArrayAdjustment(Info, E, LVal, EltTy,\n                                     APSInt::get(Adjustment));\n}\n\n/// Update an lvalue to refer to a component of a complex number.\n/// \\param Info - Information about the ongoing evaluation.\n/// \\param LVal - The lvalue to be updated.\n/// \\param EltTy - The complex number's component type.\n/// \\param Imag - False for the real component, true for the imaginary.\nstatic bool HandleLValueComplexElement(EvalInfo &Info, const Expr *E,\n                                       LValue &LVal, QualType EltTy,\n                                       bool Imag) {\n  if (Imag) {\n    CharUnits SizeOfComponent;\n    if (!HandleSizeof(Info, E->getExprLoc(), EltTy, SizeOfComponent))\n      return false;\n    LVal.Offset += SizeOfComponent;\n  }\n  LVal.addComplex(Info, E, EltTy, Imag);\n  return true;\n}\n\n/// Try to evaluate the initializer for a variable declaration.\n///\n/// \\param Info   Information about the ongoing evaluation.\n/// \\param E      An expression to be used when printing diagnostics.\n/// \\param VD     The variable whose initializer should be obtained.\n/// \\param Version The version of the variable within the frame.\n/// \\param Frame  The frame in which the variable was created. Must be null\n///               if this variable is not local to the evaluation.\n/// \\param Result Filled in with a pointer to the value of the variable.\nstatic bool evaluateVarDeclInit(EvalInfo &Info, const Expr *E,\n                                const VarDecl *VD, CallStackFrame *Frame,\n                                unsigned Version, APValue *&Result) {\n  APValue::LValueBase Base(VD, Frame ? Frame->Index : 0, Version);\n\n  // If this is a local variable, dig out its value.\n  if (Frame) {\n    Result = Frame->getTemporary(VD, Version);\n    if (Result)\n      return true;\n\n    if (!isa<ParmVarDecl>(VD)) {\n      // Assume variables referenced within a lambda's call operator that were\n      // not declared within the call operator are captures and during checking\n      // of a potential constant expression, assume they are unknown constant\n      // expressions.\n      assert(isLambdaCallOperator(Frame->Callee) &&\n             (VD->getDeclContext() != Frame->Callee || VD->isInitCapture()) &&\n             \"missing value for local variable\");\n      if (Info.checkingPotentialConstantExpression())\n        return false;\n      // FIXME: This diagnostic is bogus; we do support captures. Is this code\n      // still reachable at all?\n      Info.FFDiag(E->getBeginLoc(),\n                  diag::note_unimplemented_constexpr_lambda_feature_ast)\n          << \"captures not currently allowed\";\n      return false;\n    }\n  }\n\n  // If we're currently evaluating the initializer of this declaration, use that\n  // in-flight value.\n  if (Info.EvaluatingDecl == Base) {\n    Result = Info.EvaluatingDeclValue;\n    return true;\n  }\n\n  if (isa<ParmVarDecl>(VD)) {\n    // Assume parameters of a potential constant expression are usable in\n    // constant expressions.\n    if (!Info.checkingPotentialConstantExpression() ||\n        !Info.CurrentCall->Callee ||\n        !Info.CurrentCall->Callee->Equals(VD->getDeclContext())) {\n      if (Info.getLangOpts().CPlusPlus11) {\n        Info.FFDiag(E, diag::note_constexpr_function_param_value_unknown)\n            << VD;\n        NoteLValueLocation(Info, Base);\n      } else {\n        Info.FFDiag(E);\n      }\n    }\n    return false;\n  }\n\n  // Dig out the initializer, and use the declaration which it's attached to.\n  // FIXME: We should eventually check whether the variable has a reachable\n  // initializing declaration.\n  const Expr *Init = VD->getAnyInitializer(VD);\n  if (!Init) {\n    // Don't diagnose during potential constant expression checking; an\n    // initializer might be added later.\n    if (!Info.checkingPotentialConstantExpression()) {\n      Info.FFDiag(E, diag::note_constexpr_var_init_unknown, 1)\n        << VD;\n      NoteLValueLocation(Info, Base);\n    }\n    return false;\n  }\n\n  if (Init->isValueDependent()) {\n    // The DeclRefExpr is not value-dependent, but the variable it refers to\n    // has a value-dependent initializer. This should only happen in\n    // constant-folding cases, where the variable is not actually of a suitable\n    // type for use in a constant expression (otherwise the DeclRefExpr would\n    // have been value-dependent too), so diagnose that.\n    assert(!VD->mightBeUsableInConstantExpressions(Info.Ctx));\n    if (!Info.checkingPotentialConstantExpression()) {\n      Info.FFDiag(E, Info.getLangOpts().CPlusPlus11\n                         ? diag::note_constexpr_ltor_non_constexpr\n                         : diag::note_constexpr_ltor_non_integral, 1)\n          << VD << VD->getType();\n      NoteLValueLocation(Info, Base);\n    }\n    return false;\n  }\n\n  // Check that we can fold the initializer. In C++, we will have already done\n  // this in the cases where it matters for conformance.\n  if (!VD->evaluateValue()) {\n    Info.FFDiag(E, diag::note_constexpr_var_init_non_constant, 1) << VD;\n    NoteLValueLocation(Info, Base);\n    return false;\n  }\n\n  // Check that the variable is actually usable in constant expressions. For a\n  // const integral variable or a reference, we might have a non-constant\n  // initializer that we can nonetheless evaluate the initializer for. Such\n  // variables are not usable in constant expressions. In C++98, the\n  // initializer also syntactically needs to be an ICE.\n  //\n  // FIXME: We don't diagnose cases that aren't potentially usable in constant\n  // expressions here; doing so would regress diagnostics for things like\n  // reading from a volatile constexpr variable.\n  if ((Info.getLangOpts().CPlusPlus && !VD->hasConstantInitialization() &&\n       VD->mightBeUsableInConstantExpressions(Info.Ctx)) ||\n      ((Info.getLangOpts().CPlusPlus || Info.getLangOpts().OpenCL) &&\n       !Info.getLangOpts().CPlusPlus11 && !VD->hasICEInitializer(Info.Ctx))) {\n    Info.CCEDiag(E, diag::note_constexpr_var_init_non_constant, 1) << VD;\n    NoteLValueLocation(Info, Base);\n  }\n\n  // Never use the initializer of a weak variable, not even for constant\n  // folding. We can't be sure that this is the definition that will be used.\n  if (VD->isWeak()) {\n    Info.FFDiag(E, diag::note_constexpr_var_init_weak) << VD;\n    NoteLValueLocation(Info, Base);\n    return false;\n  }\n\n  Result = VD->getEvaluatedValue();\n  return true;\n}\n\n/// Get the base index of the given base class within an APValue representing\n/// the given derived class.\nstatic unsigned getBaseIndex(const CXXRecordDecl *Derived,\n                             const CXXRecordDecl *Base) {\n  Base = Base->getCanonicalDecl();\n  unsigned Index = 0;\n  for (CXXRecordDecl::base_class_const_iterator I = Derived->bases_begin(),\n         E = Derived->bases_end(); I != E; ++I, ++Index) {\n    if (I->getType()->getAsCXXRecordDecl()->getCanonicalDecl() == Base)\n      return Index;\n  }\n\n  llvm_unreachable(\"base class missing from derived class's bases list\");\n}\n\n/// Extract the value of a character from a string literal.\nstatic APSInt extractStringLiteralCharacter(EvalInfo &Info, const Expr *Lit,\n                                            uint64_t Index) {\n  assert(!isa<SourceLocExpr>(Lit) &&\n         \"SourceLocExpr should have already been converted to a StringLiteral\");\n\n  // FIXME: Support MakeStringConstant\n  if (const auto *ObjCEnc = dyn_cast<ObjCEncodeExpr>(Lit)) {\n    std::string Str;\n    Info.Ctx.getObjCEncodingForType(ObjCEnc->getEncodedType(), Str);\n    assert(Index <= Str.size() && \"Index too large\");\n    return APSInt::getUnsigned(Str.c_str()[Index]);\n  }\n\n  if (auto PE = dyn_cast<PredefinedExpr>(Lit))\n    Lit = PE->getFunctionName();\n  const StringLiteral *S = cast<StringLiteral>(Lit);\n  const ConstantArrayType *CAT =\n      Info.Ctx.getAsConstantArrayType(S->getType());\n  assert(CAT && \"string literal isn't an array\");\n  QualType CharType = CAT->getElementType();\n  assert(CharType->isIntegerType() && \"unexpected character type\");\n\n  APSInt Value(S->getCharByteWidth() * Info.Ctx.getCharWidth(),\n               CharType->isUnsignedIntegerType());\n  if (Index < S->getLength())\n    Value = S->getCodeUnit(Index);\n  return Value;\n}\n\n// Expand a string literal into an array of characters.\n//\n// FIXME: This is inefficient; we should probably introduce something similar\n// to the LLVM ConstantDataArray to make this cheaper.\nstatic void expandStringLiteral(EvalInfo &Info, const StringLiteral *S,\n                                APValue &Result,\n                                QualType AllocType = QualType()) {\n  const ConstantArrayType *CAT = Info.Ctx.getAsConstantArrayType(\n      AllocType.isNull() ? S->getType() : AllocType);\n  assert(CAT && \"string literal isn't an array\");\n  QualType CharType = CAT->getElementType();\n  assert(CharType->isIntegerType() && \"unexpected character type\");\n\n  unsigned Elts = CAT->getSize().getZExtValue();\n  Result = APValue(APValue::UninitArray(),\n                   std::min(S->getLength(), Elts), Elts);\n  APSInt Value(S->getCharByteWidth() * Info.Ctx.getCharWidth(),\n               CharType->isUnsignedIntegerType());\n  if (Result.hasArrayFiller())\n    Result.getArrayFiller() = APValue(Value);\n  for (unsigned I = 0, N = Result.getArrayInitializedElts(); I != N; ++I) {\n    Value = S->getCodeUnit(I);\n    Result.getArrayInitializedElt(I) = APValue(Value);\n  }\n}\n\n// Expand an array so that it has more than Index filled elements.\nstatic void expandArray(APValue &Array, unsigned Index) {\n  unsigned Size = Array.getArraySize();\n  assert(Index < Size);\n\n  // Always at least double the number of elements for which we store a value.\n  unsigned OldElts = Array.getArrayInitializedElts();\n  unsigned NewElts = std::max(Index+1, OldElts * 2);\n  NewElts = std::min(Size, std::max(NewElts, 8u));\n\n  // Copy the data across.\n  APValue NewValue(APValue::UninitArray(), NewElts, Size);\n  for (unsigned I = 0; I != OldElts; ++I)\n    NewValue.getArrayInitializedElt(I).swap(Array.getArrayInitializedElt(I));\n  for (unsigned I = OldElts; I != NewElts; ++I)\n    NewValue.getArrayInitializedElt(I) = Array.getArrayFiller();\n  if (NewValue.hasArrayFiller())\n    NewValue.getArrayFiller() = Array.getArrayFiller();\n  Array.swap(NewValue);\n}\n\n/// Determine whether a type would actually be read by an lvalue-to-rvalue\n/// conversion. If it's of class type, we may assume that the copy operation\n/// is trivial. Note that this is never true for a union type with fields\n/// (because the copy always \"reads\" the active member) and always true for\n/// a non-class type.\nstatic bool isReadByLvalueToRvalueConversion(const CXXRecordDecl *RD);\nstatic bool isReadByLvalueToRvalueConversion(QualType T) {\n  CXXRecordDecl *RD = T->getBaseElementTypeUnsafe()->getAsCXXRecordDecl();\n  return !RD || isReadByLvalueToRvalueConversion(RD);\n}\nstatic bool isReadByLvalueToRvalueConversion(const CXXRecordDecl *RD) {\n  // FIXME: A trivial copy of a union copies the object representation, even if\n  // the union is empty.\n  if (RD->isUnion())\n    return !RD->field_empty();\n  if (RD->isEmpty())\n    return false;\n\n  for (auto *Field : RD->fields())\n    if (!Field->isUnnamedBitfield() &&\n        isReadByLvalueToRvalueConversion(Field->getType()))\n      return true;\n\n  for (auto &BaseSpec : RD->bases())\n    if (isReadByLvalueToRvalueConversion(BaseSpec.getType()))\n      return true;\n\n  return false;\n}\n\n/// Diagnose an attempt to read from any unreadable field within the specified\n/// type, which might be a class type.\nstatic bool diagnoseMutableFields(EvalInfo &Info, const Expr *E, AccessKinds AK,\n                                  QualType T) {\n  CXXRecordDecl *RD = T->getBaseElementTypeUnsafe()->getAsCXXRecordDecl();\n  if (!RD)\n    return false;\n\n  if (!RD->hasMutableFields())\n    return false;\n\n  for (auto *Field : RD->fields()) {\n    // If we're actually going to read this field in some way, then it can't\n    // be mutable. If we're in a union, then assigning to a mutable field\n    // (even an empty one) can change the active member, so that's not OK.\n    // FIXME: Add core issue number for the union case.\n    if (Field->isMutable() &&\n        (RD->isUnion() || isReadByLvalueToRvalueConversion(Field->getType()))) {\n      Info.FFDiag(E, diag::note_constexpr_access_mutable, 1) << AK << Field;\n      Info.Note(Field->getLocation(), diag::note_declared_at);\n      return true;\n    }\n\n    if (diagnoseMutableFields(Info, E, AK, Field->getType()))\n      return true;\n  }\n\n  for (auto &BaseSpec : RD->bases())\n    if (diagnoseMutableFields(Info, E, AK, BaseSpec.getType()))\n      return true;\n\n  // All mutable fields were empty, and thus not actually read.\n  return false;\n}\n\nstatic bool lifetimeStartedInEvaluation(EvalInfo &Info,\n                                        APValue::LValueBase Base,\n                                        bool MutableSubobject = false) {\n  // A temporary or transient heap allocation we created.\n  if (Base.getCallIndex() || Base.is<DynamicAllocLValue>())\n    return true;\n\n  switch (Info.IsEvaluatingDecl) {\n  case EvalInfo::EvaluatingDeclKind::None:\n    return false;\n\n  case EvalInfo::EvaluatingDeclKind::Ctor:\n    // The variable whose initializer we're evaluating.\n    if (Info.EvaluatingDecl == Base)\n      return true;\n\n    // A temporary lifetime-extended by the variable whose initializer we're\n    // evaluating.\n    if (auto *BaseE = Base.dyn_cast<const Expr *>())\n      if (auto *BaseMTE = dyn_cast<MaterializeTemporaryExpr>(BaseE))\n        return Info.EvaluatingDecl == BaseMTE->getExtendingDecl();\n    return false;\n\n  case EvalInfo::EvaluatingDeclKind::Dtor:\n    // C++2a [expr.const]p6:\n    //   [during constant destruction] the lifetime of a and its non-mutable\n    //   subobjects (but not its mutable subobjects) [are] considered to start\n    //   within e.\n    if (MutableSubobject || Base != Info.EvaluatingDecl)\n      return false;\n    // FIXME: We can meaningfully extend this to cover non-const objects, but\n    // we will need special handling: we should be able to access only\n    // subobjects of such objects that are themselves declared const.\n    QualType T = getType(Base);\n    return T.isConstQualified() || T->isReferenceType();\n  }\n\n  llvm_unreachable(\"unknown evaluating decl kind\");\n}\n\nnamespace {\n/// A handle to a complete object (an object that is not a subobject of\n/// another object).\nstruct CompleteObject {\n  /// The identity of the object.\n  APValue::LValueBase Base;\n  /// The value of the complete object.\n  APValue *Value;\n  /// The type of the complete object.\n  QualType Type;\n\n  CompleteObject() : Value(nullptr) {}\n  CompleteObject(APValue::LValueBase Base, APValue *Value, QualType Type)\n      : Base(Base), Value(Value), Type(Type) {}\n\n  bool mayAccessMutableMembers(EvalInfo &Info, AccessKinds AK) const {\n    // If this isn't a \"real\" access (eg, if it's just accessing the type\n    // info), allow it. We assume the type doesn't change dynamically for\n    // subobjects of constexpr objects (even though we'd hit UB here if it\n    // did). FIXME: Is this right?\n    if (!isAnyAccess(AK))\n      return true;\n\n    // In C++14 onwards, it is permitted to read a mutable member whose\n    // lifetime began within the evaluation.\n    // FIXME: Should we also allow this in C++11?\n    if (!Info.getLangOpts().CPlusPlus14)\n      return false;\n    return lifetimeStartedInEvaluation(Info, Base, /*MutableSubobject*/true);\n  }\n\n  explicit operator bool() const { return !Type.isNull(); }\n};\n} // end anonymous namespace\n\nstatic QualType getSubobjectType(QualType ObjType, QualType SubobjType,\n                                 bool IsMutable = false) {\n  // C++ [basic.type.qualifier]p1:\n  // - A const object is an object of type const T or a non-mutable subobject\n  //   of a const object.\n  if (ObjType.isConstQualified() && !IsMutable)\n    SubobjType.addConst();\n  // - A volatile object is an object of type const T or a subobject of a\n  //   volatile object.\n  if (ObjType.isVolatileQualified())\n    SubobjType.addVolatile();\n  return SubobjType;\n}\n\n/// Find the designated sub-object of an rvalue.\ntemplate<typename SubobjectHandler>\ntypename SubobjectHandler::result_type\nfindSubobject(EvalInfo &Info, const Expr *E, const CompleteObject &Obj,\n              const SubobjectDesignator &Sub, SubobjectHandler &handler) {\n  if (Sub.Invalid)\n    // A diagnostic will have already been produced.\n    return handler.failed();\n  if (Sub.isOnePastTheEnd() || Sub.isMostDerivedAnUnsizedArray()) {\n    if (Info.getLangOpts().CPlusPlus11)\n      Info.FFDiag(E, Sub.isOnePastTheEnd()\n                         ? diag::note_constexpr_access_past_end\n                         : diag::note_constexpr_access_unsized_array)\n          << handler.AccessKind;\n    else\n      Info.FFDiag(E);\n    return handler.failed();\n  }\n\n  APValue *O = Obj.Value;\n  QualType ObjType = Obj.Type;\n  const FieldDecl *LastField = nullptr;\n  const FieldDecl *VolatileField = nullptr;\n\n  // Walk the designator's path to find the subobject.\n  for (unsigned I = 0, N = Sub.Entries.size(); /**/; ++I) {\n    // Reading an indeterminate value is undefined, but assigning over one is OK.\n    if ((O->isAbsent() && !(handler.AccessKind == AK_Construct && I == N)) ||\n        (O->isIndeterminate() &&\n         !isValidIndeterminateAccess(handler.AccessKind))) {\n      if (!Info.checkingPotentialConstantExpression())\n        Info.FFDiag(E, diag::note_constexpr_access_uninit)\n            << handler.AccessKind << O->isIndeterminate();\n      return handler.failed();\n    }\n\n    // C++ [class.ctor]p5, C++ [class.dtor]p5:\n    //    const and volatile semantics are not applied on an object under\n    //    {con,de}struction.\n    if ((ObjType.isConstQualified() || ObjType.isVolatileQualified()) &&\n        ObjType->isRecordType() &&\n        Info.isEvaluatingCtorDtor(\n            Obj.Base, llvm::makeArrayRef(Sub.Entries.begin(),\n                                         Sub.Entries.begin() + I)) !=\n                          ConstructionPhase::None) {\n      ObjType = Info.Ctx.getCanonicalType(ObjType);\n      ObjType.removeLocalConst();\n      ObjType.removeLocalVolatile();\n    }\n\n    // If this is our last pass, check that the final object type is OK.\n    if (I == N || (I == N - 1 && ObjType->isAnyComplexType())) {\n      // Accesses to volatile objects are prohibited.\n      if (ObjType.isVolatileQualified() && isFormalAccess(handler.AccessKind)) {\n        if (Info.getLangOpts().CPlusPlus) {\n          int DiagKind;\n          SourceLocation Loc;\n          const NamedDecl *Decl = nullptr;\n          if (VolatileField) {\n            DiagKind = 2;\n            Loc = VolatileField->getLocation();\n            Decl = VolatileField;\n          } else if (auto *VD = Obj.Base.dyn_cast<const ValueDecl*>()) {\n            DiagKind = 1;\n            Loc = VD->getLocation();\n            Decl = VD;\n          } else {\n            DiagKind = 0;\n            if (auto *E = Obj.Base.dyn_cast<const Expr *>())\n              Loc = E->getExprLoc();\n          }\n          Info.FFDiag(E, diag::note_constexpr_access_volatile_obj, 1)\n              << handler.AccessKind << DiagKind << Decl;\n          Info.Note(Loc, diag::note_constexpr_volatile_here) << DiagKind;\n        } else {\n          Info.FFDiag(E, diag::note_invalid_subexpr_in_const_expr);\n        }\n        return handler.failed();\n      }\n\n      // If we are reading an object of class type, there may still be more\n      // things we need to check: if there are any mutable subobjects, we\n      // cannot perform this read. (This only happens when performing a trivial\n      // copy or assignment.)\n      if (ObjType->isRecordType() &&\n          !Obj.mayAccessMutableMembers(Info, handler.AccessKind) &&\n          diagnoseMutableFields(Info, E, handler.AccessKind, ObjType))\n        return handler.failed();\n    }\n\n    if (I == N) {\n      if (!handler.found(*O, ObjType))\n        return false;\n\n      // If we modified a bit-field, truncate it to the right width.\n      if (isModification(handler.AccessKind) &&\n          LastField && LastField->isBitField() &&\n          !truncateBitfieldValue(Info, E, *O, LastField))\n        return false;\n\n      return true;\n    }\n\n    LastField = nullptr;\n    if (ObjType->isArrayType()) {\n      // Next subobject is an array element.\n      const ConstantArrayType *CAT = Info.Ctx.getAsConstantArrayType(ObjType);\n      assert(CAT && \"vla in literal type?\");\n      uint64_t Index = Sub.Entries[I].getAsArrayIndex();\n      if (CAT->getSize().ule(Index)) {\n        // Note, it should not be possible to form a pointer with a valid\n        // designator which points more than one past the end of the array.\n        if (Info.getLangOpts().CPlusPlus11)\n          Info.FFDiag(E, diag::note_constexpr_access_past_end)\n            << handler.AccessKind;\n        else\n          Info.FFDiag(E);\n        return handler.failed();\n      }\n\n      ObjType = CAT->getElementType();\n\n      if (O->getArrayInitializedElts() > Index)\n        O = &O->getArrayInitializedElt(Index);\n      else if (!isRead(handler.AccessKind)) {\n        expandArray(*O, Index);\n        O = &O->getArrayInitializedElt(Index);\n      } else\n        O = &O->getArrayFiller();\n    } else if (ObjType->isAnyComplexType()) {\n      // Next subobject is a complex number.\n      uint64_t Index = Sub.Entries[I].getAsArrayIndex();\n      if (Index > 1) {\n        if (Info.getLangOpts().CPlusPlus11)\n          Info.FFDiag(E, diag::note_constexpr_access_past_end)\n            << handler.AccessKind;\n        else\n          Info.FFDiag(E);\n        return handler.failed();\n      }\n\n      ObjType = getSubobjectType(\n          ObjType, ObjType->castAs<ComplexType>()->getElementType());\n\n      assert(I == N - 1 && \"extracting subobject of scalar?\");\n      if (O->isComplexInt()) {\n        return handler.found(Index ? O->getComplexIntImag()\n                                   : O->getComplexIntReal(), ObjType);\n      } else {\n        assert(O->isComplexFloat());\n        return handler.found(Index ? O->getComplexFloatImag()\n                                   : O->getComplexFloatReal(), ObjType);\n      }\n    } else if (const FieldDecl *Field = getAsField(Sub.Entries[I])) {\n      if (Field->isMutable() &&\n          !Obj.mayAccessMutableMembers(Info, handler.AccessKind)) {\n        Info.FFDiag(E, diag::note_constexpr_access_mutable, 1)\n          << handler.AccessKind << Field;\n        Info.Note(Field->getLocation(), diag::note_declared_at);\n        return handler.failed();\n      }\n\n      // Next subobject is a class, struct or union field.\n      RecordDecl *RD = ObjType->castAs<RecordType>()->getDecl();\n      if (RD->isUnion()) {\n        const FieldDecl *UnionField = O->getUnionField();\n        if (!UnionField ||\n            UnionField->getCanonicalDecl() != Field->getCanonicalDecl()) {\n          if (I == N - 1 && handler.AccessKind == AK_Construct) {\n            // Placement new onto an inactive union member makes it active.\n            O->setUnion(Field, APValue());\n          } else {\n            // FIXME: If O->getUnionValue() is absent, report that there's no\n            // active union member rather than reporting the prior active union\n            // member. We'll need to fix nullptr_t to not use APValue() as its\n            // representation first.\n            Info.FFDiag(E, diag::note_constexpr_access_inactive_union_member)\n                << handler.AccessKind << Field << !UnionField << UnionField;\n            return handler.failed();\n          }\n        }\n        O = &O->getUnionValue();\n      } else\n        O = &O->getStructField(Field->getFieldIndex());\n\n      ObjType = getSubobjectType(ObjType, Field->getType(), Field->isMutable());\n      LastField = Field;\n      if (Field->getType().isVolatileQualified())\n        VolatileField = Field;\n    } else {\n      // Next subobject is a base class.\n      const CXXRecordDecl *Derived = ObjType->getAsCXXRecordDecl();\n      const CXXRecordDecl *Base = getAsBaseClass(Sub.Entries[I]);\n      O = &O->getStructBase(getBaseIndex(Derived, Base));\n\n      ObjType = getSubobjectType(ObjType, Info.Ctx.getRecordType(Base));\n    }\n  }\n}\n\nnamespace {\nstruct ExtractSubobjectHandler {\n  EvalInfo &Info;\n  const Expr *E;\n  APValue &Result;\n  const AccessKinds AccessKind;\n\n  typedef bool result_type;\n  bool failed() { return false; }\n  bool found(APValue &Subobj, QualType SubobjType) {\n    Result = Subobj;\n    if (AccessKind == AK_ReadObjectRepresentation)\n      return true;\n    return CheckFullyInitialized(Info, E->getExprLoc(), SubobjType, Result);\n  }\n  bool found(APSInt &Value, QualType SubobjType) {\n    Result = APValue(Value);\n    return true;\n  }\n  bool found(APFloat &Value, QualType SubobjType) {\n    Result = APValue(Value);\n    return true;\n  }\n};\n} // end anonymous namespace\n\n/// Extract the designated sub-object of an rvalue.\nstatic bool extractSubobject(EvalInfo &Info, const Expr *E,\n                             const CompleteObject &Obj,\n                             const SubobjectDesignator &Sub, APValue &Result,\n                             AccessKinds AK = AK_Read) {\n  assert(AK == AK_Read || AK == AK_ReadObjectRepresentation);\n  ExtractSubobjectHandler Handler = {Info, E, Result, AK};\n  return findSubobject(Info, E, Obj, Sub, Handler);\n}\n\nnamespace {\nstruct ModifySubobjectHandler {\n  EvalInfo &Info;\n  APValue &NewVal;\n  const Expr *E;\n\n  typedef bool result_type;\n  static const AccessKinds AccessKind = AK_Assign;\n\n  bool checkConst(QualType QT) {\n    // Assigning to a const object has undefined behavior.\n    if (QT.isConstQualified()) {\n      Info.FFDiag(E, diag::note_constexpr_modify_const_type) << QT;\n      return false;\n    }\n    return true;\n  }\n\n  bool failed() { return false; }\n  bool found(APValue &Subobj, QualType SubobjType) {\n    if (!checkConst(SubobjType))\n      return false;\n    // We've been given ownership of NewVal, so just swap it in.\n    Subobj.swap(NewVal);\n    return true;\n  }\n  bool found(APSInt &Value, QualType SubobjType) {\n    if (!checkConst(SubobjType))\n      return false;\n    if (!NewVal.isInt()) {\n      // Maybe trying to write a cast pointer value into a complex?\n      Info.FFDiag(E);\n      return false;\n    }\n    Value = NewVal.getInt();\n    return true;\n  }\n  bool found(APFloat &Value, QualType SubobjType) {\n    if (!checkConst(SubobjType))\n      return false;\n    Value = NewVal.getFloat();\n    return true;\n  }\n};\n} // end anonymous namespace\n\nconst AccessKinds ModifySubobjectHandler::AccessKind;\n\n/// Update the designated sub-object of an rvalue to the given value.\nstatic bool modifySubobject(EvalInfo &Info, const Expr *E,\n                            const CompleteObject &Obj,\n                            const SubobjectDesignator &Sub,\n                            APValue &NewVal) {\n  ModifySubobjectHandler Handler = { Info, NewVal, E };\n  return findSubobject(Info, E, Obj, Sub, Handler);\n}\n\n/// Find the position where two subobject designators diverge, or equivalently\n/// the length of the common initial subsequence.\nstatic unsigned FindDesignatorMismatch(QualType ObjType,\n                                       const SubobjectDesignator &A,\n                                       const SubobjectDesignator &B,\n                                       bool &WasArrayIndex) {\n  unsigned I = 0, N = std::min(A.Entries.size(), B.Entries.size());\n  for (/**/; I != N; ++I) {\n    if (!ObjType.isNull() &&\n        (ObjType->isArrayType() || ObjType->isAnyComplexType())) {\n      // Next subobject is an array element.\n      if (A.Entries[I].getAsArrayIndex() != B.Entries[I].getAsArrayIndex()) {\n        WasArrayIndex = true;\n        return I;\n      }\n      if (ObjType->isAnyComplexType())\n        ObjType = ObjType->castAs<ComplexType>()->getElementType();\n      else\n        ObjType = ObjType->castAsArrayTypeUnsafe()->getElementType();\n    } else {\n      if (A.Entries[I].getAsBaseOrMember() !=\n          B.Entries[I].getAsBaseOrMember()) {\n        WasArrayIndex = false;\n        return I;\n      }\n      if (const FieldDecl *FD = getAsField(A.Entries[I]))\n        // Next subobject is a field.\n        ObjType = FD->getType();\n      else\n        // Next subobject is a base class.\n        ObjType = QualType();\n    }\n  }\n  WasArrayIndex = false;\n  return I;\n}\n\n/// Determine whether the given subobject designators refer to elements of the\n/// same array object.\nstatic bool AreElementsOfSameArray(QualType ObjType,\n                                   const SubobjectDesignator &A,\n                                   const SubobjectDesignator &B) {\n  if (A.Entries.size() != B.Entries.size())\n    return false;\n\n  bool IsArray = A.MostDerivedIsArrayElement;\n  if (IsArray && A.MostDerivedPathLength != A.Entries.size())\n    // A is a subobject of the array element.\n    return false;\n\n  // If A (and B) designates an array element, the last entry will be the array\n  // index. That doesn't have to match. Otherwise, we're in the 'implicit array\n  // of length 1' case, and the entire path must match.\n  bool WasArrayIndex;\n  unsigned CommonLength = FindDesignatorMismatch(ObjType, A, B, WasArrayIndex);\n  return CommonLength >= A.Entries.size() - IsArray;\n}\n\n/// Find the complete object to which an LValue refers.\nstatic CompleteObject findCompleteObject(EvalInfo &Info, const Expr *E,\n                                         AccessKinds AK, const LValue &LVal,\n                                         QualType LValType) {\n  if (LVal.InvalidBase) {\n    Info.FFDiag(E);\n    return CompleteObject();\n  }\n\n  if (!LVal.Base) {\n    Info.FFDiag(E, diag::note_constexpr_access_null) << AK;\n    return CompleteObject();\n  }\n\n  CallStackFrame *Frame = nullptr;\n  unsigned Depth = 0;\n  if (LVal.getLValueCallIndex()) {\n    std::tie(Frame, Depth) =\n        Info.getCallFrameAndDepth(LVal.getLValueCallIndex());\n    if (!Frame) {\n      Info.FFDiag(E, diag::note_constexpr_lifetime_ended, 1)\n        << AK << LVal.Base.is<const ValueDecl*>();\n      NoteLValueLocation(Info, LVal.Base);\n      return CompleteObject();\n    }\n  }\n\n  bool IsAccess = isAnyAccess(AK);\n\n  // C++11 DR1311: An lvalue-to-rvalue conversion on a volatile-qualified type\n  // is not a constant expression (even if the object is non-volatile). We also\n  // apply this rule to C++98, in order to conform to the expected 'volatile'\n  // semantics.\n  if (isFormalAccess(AK) && LValType.isVolatileQualified()) {\n    if (Info.getLangOpts().CPlusPlus)\n      Info.FFDiag(E, diag::note_constexpr_access_volatile_type)\n        << AK << LValType;\n    else\n      Info.FFDiag(E);\n    return CompleteObject();\n  }\n\n  // Compute value storage location and type of base object.\n  APValue *BaseVal = nullptr;\n  QualType BaseType = getType(LVal.Base);\n\n  if (Info.getLangOpts().CPlusPlus14 && LVal.Base == Info.EvaluatingDecl &&\n      lifetimeStartedInEvaluation(Info, LVal.Base)) {\n    // This is the object whose initializer we're evaluating, so its lifetime\n    // started in the current evaluation.\n    BaseVal = Info.EvaluatingDeclValue;\n  } else if (const ValueDecl *D = LVal.Base.dyn_cast<const ValueDecl *>()) {\n    // Allow reading from a GUID declaration.\n    if (auto *GD = dyn_cast<MSGuidDecl>(D)) {\n      if (isModification(AK)) {\n        // All the remaining cases do not permit modification of the object.\n        Info.FFDiag(E, diag::note_constexpr_modify_global);\n        return CompleteObject();\n      }\n      APValue &V = GD->getAsAPValue();\n      if (V.isAbsent()) {\n        Info.FFDiag(E, diag::note_constexpr_unsupported_layout)\n            << GD->getType();\n        return CompleteObject();\n      }\n      return CompleteObject(LVal.Base, &V, GD->getType());\n    }\n\n    // Allow reading from template parameter objects.\n    if (auto *TPO = dyn_cast<TemplateParamObjectDecl>(D)) {\n      if (isModification(AK)) {\n        Info.FFDiag(E, diag::note_constexpr_modify_global);\n        return CompleteObject();\n      }\n      return CompleteObject(LVal.Base, const_cast<APValue *>(&TPO->getValue()),\n                            TPO->getType());\n    }\n\n    // In C++98, const, non-volatile integers initialized with ICEs are ICEs.\n    // In C++11, constexpr, non-volatile variables initialized with constant\n    // expressions are constant expressions too. Inside constexpr functions,\n    // parameters are constant expressions even if they're non-const.\n    // In C++1y, objects local to a constant expression (those with a Frame) are\n    // both readable and writable inside constant expressions.\n    // In C, such things can also be folded, although they are not ICEs.\n    const VarDecl *VD = dyn_cast<VarDecl>(D);\n    if (VD) {\n      if (const VarDecl *VDef = VD->getDefinition(Info.Ctx))\n        VD = VDef;\n    }\n    if (!VD || VD->isInvalidDecl()) {\n      Info.FFDiag(E);\n      return CompleteObject();\n    }\n\n    bool IsConstant = BaseType.isConstant(Info.Ctx);\n\n    // Unless we're looking at a local variable or argument in a constexpr call,\n    // the variable we're reading must be const.\n    if (!Frame) {\n      if (IsAccess && isa<ParmVarDecl>(VD)) {\n        // Access of a parameter that's not associated with a frame isn't going\n        // to work out, but we can leave it to evaluateVarDeclInit to provide a\n        // suitable diagnostic.\n      } else if (Info.getLangOpts().CPlusPlus14 &&\n                 lifetimeStartedInEvaluation(Info, LVal.Base)) {\n        // OK, we can read and modify an object if we're in the process of\n        // evaluating its initializer, because its lifetime began in this\n        // evaluation.\n      } else if (isModification(AK)) {\n        // All the remaining cases do not permit modification of the object.\n        Info.FFDiag(E, diag::note_constexpr_modify_global);\n        return CompleteObject();\n      } else if (VD->isConstexpr()) {\n        // OK, we can read this variable.\n      } else if (BaseType->isIntegralOrEnumerationType()) {\n        if (!IsConstant) {\n          if (!IsAccess)\n            return CompleteObject(LVal.getLValueBase(), nullptr, BaseType);\n          if (Info.getLangOpts().CPlusPlus) {\n            Info.FFDiag(E, diag::note_constexpr_ltor_non_const_int, 1) << VD;\n            Info.Note(VD->getLocation(), diag::note_declared_at);\n          } else {\n            Info.FFDiag(E);\n          }\n          return CompleteObject();\n        }\n      } else if (!IsAccess) {\n        return CompleteObject(LVal.getLValueBase(), nullptr, BaseType);\n      } else if (IsConstant && Info.checkingPotentialConstantExpression() &&\n                 BaseType->isLiteralType(Info.Ctx) && !VD->hasDefinition()) {\n        // This variable might end up being constexpr. Don't diagnose it yet.\n      } else if (IsConstant) {\n        // Keep evaluating to see what we can do. In particular, we support\n        // folding of const floating-point types, in order to make static const\n        // data members of such types (supported as an extension) more useful.\n        if (Info.getLangOpts().CPlusPlus) {\n          Info.CCEDiag(E, Info.getLangOpts().CPlusPlus11\n                              ? diag::note_constexpr_ltor_non_constexpr\n                              : diag::note_constexpr_ltor_non_integral, 1)\n              << VD << BaseType;\n          Info.Note(VD->getLocation(), diag::note_declared_at);\n        } else {\n          Info.CCEDiag(E);\n        }\n      } else {\n        // Never allow reading a non-const value.\n        if (Info.getLangOpts().CPlusPlus) {\n          Info.FFDiag(E, Info.getLangOpts().CPlusPlus11\n                             ? diag::note_constexpr_ltor_non_constexpr\n                             : diag::note_constexpr_ltor_non_integral, 1)\n              << VD << BaseType;\n          Info.Note(VD->getLocation(), diag::note_declared_at);\n        } else {\n          Info.FFDiag(E);\n        }\n        return CompleteObject();\n      }\n    }\n\n    if (!evaluateVarDeclInit(Info, E, VD, Frame, LVal.getLValueVersion(), BaseVal))\n      return CompleteObject();\n  } else if (DynamicAllocLValue DA = LVal.Base.dyn_cast<DynamicAllocLValue>()) {\n    Optional<DynAlloc*> Alloc = Info.lookupDynamicAlloc(DA);\n    if (!Alloc) {\n      Info.FFDiag(E, diag::note_constexpr_access_deleted_object) << AK;\n      return CompleteObject();\n    }\n    return CompleteObject(LVal.Base, &(*Alloc)->Value,\n                          LVal.Base.getDynamicAllocType());\n  } else {\n    const Expr *Base = LVal.Base.dyn_cast<const Expr*>();\n\n    if (!Frame) {\n      if (const MaterializeTemporaryExpr *MTE =\n              dyn_cast_or_null<MaterializeTemporaryExpr>(Base)) {\n        assert(MTE->getStorageDuration() == SD_Static &&\n               \"should have a frame for a non-global materialized temporary\");\n\n        // C++20 [expr.const]p4: [DR2126]\n        //   An object or reference is usable in constant expressions if it is\n        //   - a temporary object of non-volatile const-qualified literal type\n        //     whose lifetime is extended to that of a variable that is usable\n        //     in constant expressions\n        //\n        // C++20 [expr.const]p5:\n        //  an lvalue-to-rvalue conversion [is not allowed unless it applies to]\n        //   - a non-volatile glvalue that refers to an object that is usable\n        //     in constant expressions, or\n        //   - a non-volatile glvalue of literal type that refers to a\n        //     non-volatile object whose lifetime began within the evaluation\n        //     of E;\n        //\n        // C++11 misses the 'began within the evaluation of e' check and\n        // instead allows all temporaries, including things like:\n        //   int &&r = 1;\n        //   int x = ++r;\n        //   constexpr int k = r;\n        // Therefore we use the C++14-onwards rules in C++11 too.\n        //\n        // Note that temporaries whose lifetimes began while evaluating a\n        // variable's constructor are not usable while evaluating the\n        // corresponding destructor, not even if they're of const-qualified\n        // types.\n        if (!MTE->isUsableInConstantExpressions(Info.Ctx) &&\n            !lifetimeStartedInEvaluation(Info, LVal.Base)) {\n          if (!IsAccess)\n            return CompleteObject(LVal.getLValueBase(), nullptr, BaseType);\n          Info.FFDiag(E, diag::note_constexpr_access_static_temporary, 1) << AK;\n          Info.Note(MTE->getExprLoc(), diag::note_constexpr_temporary_here);\n          return CompleteObject();\n        }\n\n        BaseVal = MTE->getOrCreateValue(false);\n        assert(BaseVal && \"got reference to unevaluated temporary\");\n      } else {\n        if (!IsAccess)\n          return CompleteObject(LVal.getLValueBase(), nullptr, BaseType);\n        APValue Val;\n        LVal.moveInto(Val);\n        Info.FFDiag(E, diag::note_constexpr_access_unreadable_object)\n            << AK\n            << Val.getAsString(Info.Ctx,\n                               Info.Ctx.getLValueReferenceType(LValType));\n        NoteLValueLocation(Info, LVal.Base);\n        return CompleteObject();\n      }\n    } else {\n      BaseVal = Frame->getTemporary(Base, LVal.Base.getVersion());\n      assert(BaseVal && \"missing value for temporary\");\n    }\n  }\n\n  // In C++14, we can't safely access any mutable state when we might be\n  // evaluating after an unmodeled side effect. Parameters are modeled as state\n  // in the caller, but aren't visible once the call returns, so they can be\n  // modified in a speculatively-evaluated call.\n  //\n  // FIXME: Not all local state is mutable. Allow local constant subobjects\n  // to be read here (but take care with 'mutable' fields).\n  unsigned VisibleDepth = Depth;\n  if (llvm::isa_and_nonnull<ParmVarDecl>(\n          LVal.Base.dyn_cast<const ValueDecl *>()))\n    ++VisibleDepth;\n  if ((Frame && Info.getLangOpts().CPlusPlus14 &&\n       Info.EvalStatus.HasSideEffects) ||\n      (isModification(AK) && VisibleDepth < Info.SpeculativeEvaluationDepth))\n    return CompleteObject();\n\n  return CompleteObject(LVal.getLValueBase(), BaseVal, BaseType);\n}\n\n/// Perform an lvalue-to-rvalue conversion on the given glvalue. This\n/// can also be used for 'lvalue-to-lvalue' conversions for looking up the\n/// glvalue referred to by an entity of reference type.\n///\n/// \\param Info - Information about the ongoing evaluation.\n/// \\param Conv - The expression for which we are performing the conversion.\n///               Used for diagnostics.\n/// \\param Type - The type of the glvalue (before stripping cv-qualifiers in the\n///               case of a non-class type).\n/// \\param LVal - The glvalue on which we are attempting to perform this action.\n/// \\param RVal - The produced value will be placed here.\n/// \\param WantObjectRepresentation - If true, we're looking for the object\n///               representation rather than the value, and in particular,\n///               there is no requirement that the result be fully initialized.\nstatic bool\nhandleLValueToRValueConversion(EvalInfo &Info, const Expr *Conv, QualType Type,\n                               const LValue &LVal, APValue &RVal,\n                               bool WantObjectRepresentation = false) {\n  if (LVal.Designator.Invalid)\n    return false;\n\n  // Check for special cases where there is no existing APValue to look at.\n  const Expr *Base = LVal.Base.dyn_cast<const Expr*>();\n\n  AccessKinds AK =\n      WantObjectRepresentation ? AK_ReadObjectRepresentation : AK_Read;\n\n  if (Base && !LVal.getLValueCallIndex() && !Type.isVolatileQualified()) {\n    if (const CompoundLiteralExpr *CLE = dyn_cast<CompoundLiteralExpr>(Base)) {\n      // In C99, a CompoundLiteralExpr is an lvalue, and we defer evaluating the\n      // initializer until now for such expressions. Such an expression can't be\n      // an ICE in C, so this only matters for fold.\n      if (Type.isVolatileQualified()) {\n        Info.FFDiag(Conv);\n        return false;\n      }\n      APValue Lit;\n      if (!Evaluate(Lit, Info, CLE->getInitializer()))\n        return false;\n      CompleteObject LitObj(LVal.Base, &Lit, Base->getType());\n      return extractSubobject(Info, Conv, LitObj, LVal.Designator, RVal, AK);\n    } else if (isa<StringLiteral>(Base) || isa<PredefinedExpr>(Base)) {\n      // Special-case character extraction so we don't have to construct an\n      // APValue for the whole string.\n      assert(LVal.Designator.Entries.size() <= 1 &&\n             \"Can only read characters from string literals\");\n      if (LVal.Designator.Entries.empty()) {\n        // Fail for now for LValue to RValue conversion of an array.\n        // (This shouldn't show up in C/C++, but it could be triggered by a\n        // weird EvaluateAsRValue call from a tool.)\n        Info.FFDiag(Conv);\n        return false;\n      }\n      if (LVal.Designator.isOnePastTheEnd()) {\n        if (Info.getLangOpts().CPlusPlus11)\n          Info.FFDiag(Conv, diag::note_constexpr_access_past_end) << AK;\n        else\n          Info.FFDiag(Conv);\n        return false;\n      }\n      uint64_t CharIndex = LVal.Designator.Entries[0].getAsArrayIndex();\n      RVal = APValue(extractStringLiteralCharacter(Info, Base, CharIndex));\n      return true;\n    }\n  }\n\n  CompleteObject Obj = findCompleteObject(Info, Conv, AK, LVal, Type);\n  return Obj && extractSubobject(Info, Conv, Obj, LVal.Designator, RVal, AK);\n}\n\n/// Perform an assignment of Val to LVal. Takes ownership of Val.\nstatic bool handleAssignment(EvalInfo &Info, const Expr *E, const LValue &LVal,\n                             QualType LValType, APValue &Val) {\n  if (LVal.Designator.Invalid)\n    return false;\n\n  if (!Info.getLangOpts().CPlusPlus14) {\n    Info.FFDiag(E);\n    return false;\n  }\n\n  CompleteObject Obj = findCompleteObject(Info, E, AK_Assign, LVal, LValType);\n  return Obj && modifySubobject(Info, E, Obj, LVal.Designator, Val);\n}\n\nnamespace {\nstruct CompoundAssignSubobjectHandler {\n  EvalInfo &Info;\n  const CompoundAssignOperator *E;\n  QualType PromotedLHSType;\n  BinaryOperatorKind Opcode;\n  const APValue &RHS;\n\n  static const AccessKinds AccessKind = AK_Assign;\n\n  typedef bool result_type;\n\n  bool checkConst(QualType QT) {\n    // Assigning to a const object has undefined behavior.\n    if (QT.isConstQualified()) {\n      Info.FFDiag(E, diag::note_constexpr_modify_const_type) << QT;\n      return false;\n    }\n    return true;\n  }\n\n  bool failed() { return false; }\n  bool found(APValue &Subobj, QualType SubobjType) {\n    switch (Subobj.getKind()) {\n    case APValue::Int:\n      return found(Subobj.getInt(), SubobjType);\n    case APValue::Float:\n      return found(Subobj.getFloat(), SubobjType);\n    case APValue::ComplexInt:\n    case APValue::ComplexFloat:\n      // FIXME: Implement complex compound assignment.\n      Info.FFDiag(E);\n      return false;\n    case APValue::LValue:\n      return foundPointer(Subobj, SubobjType);\n    case APValue::Vector:\n      return foundVector(Subobj, SubobjType);\n    default:\n      // FIXME: can this happen?\n      Info.FFDiag(E);\n      return false;\n    }\n  }\n\n  bool foundVector(APValue &Value, QualType SubobjType) {\n    if (!checkConst(SubobjType))\n      return false;\n\n    if (!SubobjType->isVectorType()) {\n      Info.FFDiag(E);\n      return false;\n    }\n    return handleVectorVectorBinOp(Info, E, Opcode, Value, RHS);\n  }\n\n  bool found(APSInt &Value, QualType SubobjType) {\n    if (!checkConst(SubobjType))\n      return false;\n\n    if (!SubobjType->isIntegerType()) {\n      // We don't support compound assignment on integer-cast-to-pointer\n      // values.\n      Info.FFDiag(E);\n      return false;\n    }\n\n    if (RHS.isInt()) {\n      APSInt LHS =\n          HandleIntToIntCast(Info, E, PromotedLHSType, SubobjType, Value);\n      if (!handleIntIntBinOp(Info, E, LHS, Opcode, RHS.getInt(), LHS))\n        return false;\n      Value = HandleIntToIntCast(Info, E, SubobjType, PromotedLHSType, LHS);\n      return true;\n    } else if (RHS.isFloat()) {\n      const FPOptions FPO = E->getFPFeaturesInEffect(\n                                    Info.Ctx.getLangOpts());\n      APFloat FValue(0.0);\n      return HandleIntToFloatCast(Info, E, FPO, SubobjType, Value,\n                                  PromotedLHSType, FValue) &&\n             handleFloatFloatBinOp(Info, E, FValue, Opcode, RHS.getFloat()) &&\n             HandleFloatToIntCast(Info, E, PromotedLHSType, FValue, SubobjType,\n                                  Value);\n    }\n\n    Info.FFDiag(E);\n    return false;\n  }\n  bool found(APFloat &Value, QualType SubobjType) {\n    return checkConst(SubobjType) &&\n           HandleFloatToFloatCast(Info, E, SubobjType, PromotedLHSType,\n                                  Value) &&\n           handleFloatFloatBinOp(Info, E, Value, Opcode, RHS.getFloat()) &&\n           HandleFloatToFloatCast(Info, E, PromotedLHSType, SubobjType, Value);\n  }\n  bool foundPointer(APValue &Subobj, QualType SubobjType) {\n    if (!checkConst(SubobjType))\n      return false;\n\n    QualType PointeeType;\n    if (const PointerType *PT = SubobjType->getAs<PointerType>())\n      PointeeType = PT->getPointeeType();\n\n    if (PointeeType.isNull() || !RHS.isInt() ||\n        (Opcode != BO_Add && Opcode != BO_Sub)) {\n      Info.FFDiag(E);\n      return false;\n    }\n\n    APSInt Offset = RHS.getInt();\n    if (Opcode == BO_Sub)\n      negateAsSigned(Offset);\n\n    LValue LVal;\n    LVal.setFrom(Info.Ctx, Subobj);\n    if (!HandleLValueArrayAdjustment(Info, E, LVal, PointeeType, Offset))\n      return false;\n    LVal.moveInto(Subobj);\n    return true;\n  }\n};\n} // end anonymous namespace\n\nconst AccessKinds CompoundAssignSubobjectHandler::AccessKind;\n\n/// Perform a compound assignment of LVal <op>= RVal.\nstatic bool handleCompoundAssignment(EvalInfo &Info,\n                                     const CompoundAssignOperator *E,\n                                     const LValue &LVal, QualType LValType,\n                                     QualType PromotedLValType,\n                                     BinaryOperatorKind Opcode,\n                                     const APValue &RVal) {\n  if (LVal.Designator.Invalid)\n    return false;\n\n  if (!Info.getLangOpts().CPlusPlus14) {\n    Info.FFDiag(E);\n    return false;\n  }\n\n  CompleteObject Obj = findCompleteObject(Info, E, AK_Assign, LVal, LValType);\n  CompoundAssignSubobjectHandler Handler = { Info, E, PromotedLValType, Opcode,\n                                             RVal };\n  return Obj && findSubobject(Info, E, Obj, LVal.Designator, Handler);\n}\n\nnamespace {\nstruct IncDecSubobjectHandler {\n  EvalInfo &Info;\n  const UnaryOperator *E;\n  AccessKinds AccessKind;\n  APValue *Old;\n\n  typedef bool result_type;\n\n  bool checkConst(QualType QT) {\n    // Assigning to a const object has undefined behavior.\n    if (QT.isConstQualified()) {\n      Info.FFDiag(E, diag::note_constexpr_modify_const_type) << QT;\n      return false;\n    }\n    return true;\n  }\n\n  bool failed() { return false; }\n  bool found(APValue &Subobj, QualType SubobjType) {\n    // Stash the old value. Also clear Old, so we don't clobber it later\n    // if we're post-incrementing a complex.\n    if (Old) {\n      *Old = Subobj;\n      Old = nullptr;\n    }\n\n    switch (Subobj.getKind()) {\n    case APValue::Int:\n      return found(Subobj.getInt(), SubobjType);\n    case APValue::Float:\n      return found(Subobj.getFloat(), SubobjType);\n    case APValue::ComplexInt:\n      return found(Subobj.getComplexIntReal(),\n                   SubobjType->castAs<ComplexType>()->getElementType()\n                     .withCVRQualifiers(SubobjType.getCVRQualifiers()));\n    case APValue::ComplexFloat:\n      return found(Subobj.getComplexFloatReal(),\n                   SubobjType->castAs<ComplexType>()->getElementType()\n                     .withCVRQualifiers(SubobjType.getCVRQualifiers()));\n    case APValue::LValue:\n      return foundPointer(Subobj, SubobjType);\n    default:\n      // FIXME: can this happen?\n      Info.FFDiag(E);\n      return false;\n    }\n  }\n  bool found(APSInt &Value, QualType SubobjType) {\n    if (!checkConst(SubobjType))\n      return false;\n\n    if (!SubobjType->isIntegerType()) {\n      // We don't support increment / decrement on integer-cast-to-pointer\n      // values.\n      Info.FFDiag(E);\n      return false;\n    }\n\n    if (Old) *Old = APValue(Value);\n\n    // bool arithmetic promotes to int, and the conversion back to bool\n    // doesn't reduce mod 2^n, so special-case it.\n    if (SubobjType->isBooleanType()) {\n      if (AccessKind == AK_Increment)\n        Value = 1;\n      else\n        Value = !Value;\n      return true;\n    }\n\n    bool WasNegative = Value.isNegative();\n    if (AccessKind == AK_Increment) {\n      ++Value;\n\n      if (!WasNegative && Value.isNegative() && E->canOverflow()) {\n        APSInt ActualValue(Value, /*IsUnsigned*/true);\n        return HandleOverflow(Info, E, ActualValue, SubobjType);\n      }\n    } else {\n      --Value;\n\n      if (WasNegative && !Value.isNegative() && E->canOverflow()) {\n        unsigned BitWidth = Value.getBitWidth();\n        APSInt ActualValue(Value.sext(BitWidth + 1), /*IsUnsigned*/false);\n        ActualValue.setBit(BitWidth);\n        return HandleOverflow(Info, E, ActualValue, SubobjType);\n      }\n    }\n    return true;\n  }\n  bool found(APFloat &Value, QualType SubobjType) {\n    if (!checkConst(SubobjType))\n      return false;\n\n    if (Old) *Old = APValue(Value);\n\n    APFloat One(Value.getSemantics(), 1);\n    if (AccessKind == AK_Increment)\n      Value.add(One, APFloat::rmNearestTiesToEven);\n    else\n      Value.subtract(One, APFloat::rmNearestTiesToEven);\n    return true;\n  }\n  bool foundPointer(APValue &Subobj, QualType SubobjType) {\n    if (!checkConst(SubobjType))\n      return false;\n\n    QualType PointeeType;\n    if (const PointerType *PT = SubobjType->getAs<PointerType>())\n      PointeeType = PT->getPointeeType();\n    else {\n      Info.FFDiag(E);\n      return false;\n    }\n\n    LValue LVal;\n    LVal.setFrom(Info.Ctx, Subobj);\n    if (!HandleLValueArrayAdjustment(Info, E, LVal, PointeeType,\n                                     AccessKind == AK_Increment ? 1 : -1))\n      return false;\n    LVal.moveInto(Subobj);\n    return true;\n  }\n};\n} // end anonymous namespace\n\n/// Perform an increment or decrement on LVal.\nstatic bool handleIncDec(EvalInfo &Info, const Expr *E, const LValue &LVal,\n                         QualType LValType, bool IsIncrement, APValue *Old) {\n  if (LVal.Designator.Invalid)\n    return false;\n\n  if (!Info.getLangOpts().CPlusPlus14) {\n    Info.FFDiag(E);\n    return false;\n  }\n\n  AccessKinds AK = IsIncrement ? AK_Increment : AK_Decrement;\n  CompleteObject Obj = findCompleteObject(Info, E, AK, LVal, LValType);\n  IncDecSubobjectHandler Handler = {Info, cast<UnaryOperator>(E), AK, Old};\n  return Obj && findSubobject(Info, E, Obj, LVal.Designator, Handler);\n}\n\n/// Build an lvalue for the object argument of a member function call.\nstatic bool EvaluateObjectArgument(EvalInfo &Info, const Expr *Object,\n                                   LValue &This) {\n  if (Object->getType()->isPointerType() && Object->isRValue())\n    return EvaluatePointer(Object, This, Info);\n\n  if (Object->isGLValue())\n    return EvaluateLValue(Object, This, Info);\n\n  if (Object->getType()->isLiteralType(Info.Ctx))\n    return EvaluateTemporary(Object, This, Info);\n\n  Info.FFDiag(Object, diag::note_constexpr_nonliteral) << Object->getType();\n  return false;\n}\n\n/// HandleMemberPointerAccess - Evaluate a member access operation and build an\n/// lvalue referring to the result.\n///\n/// \\param Info - Information about the ongoing evaluation.\n/// \\param LV - An lvalue referring to the base of the member pointer.\n/// \\param RHS - The member pointer expression.\n/// \\param IncludeMember - Specifies whether the member itself is included in\n///        the resulting LValue subobject designator. This is not possible when\n///        creating a bound member function.\n/// \\return The field or method declaration to which the member pointer refers,\n///         or 0 if evaluation fails.\nstatic const ValueDecl *HandleMemberPointerAccess(EvalInfo &Info,\n                                                  QualType LVType,\n                                                  LValue &LV,\n                                                  const Expr *RHS,\n                                                  bool IncludeMember = true) {\n  MemberPtr MemPtr;\n  if (!EvaluateMemberPointer(RHS, MemPtr, Info))\n    return nullptr;\n\n  // C++11 [expr.mptr.oper]p6: If the second operand is the null pointer to\n  // member value, the behavior is undefined.\n  if (!MemPtr.getDecl()) {\n    // FIXME: Specific diagnostic.\n    Info.FFDiag(RHS);\n    return nullptr;\n  }\n\n  if (MemPtr.isDerivedMember()) {\n    // This is a member of some derived class. Truncate LV appropriately.\n    // The end of the derived-to-base path for the base object must match the\n    // derived-to-base path for the member pointer.\n    if (LV.Designator.MostDerivedPathLength + MemPtr.Path.size() >\n        LV.Designator.Entries.size()) {\n      Info.FFDiag(RHS);\n      return nullptr;\n    }\n    unsigned PathLengthToMember =\n        LV.Designator.Entries.size() - MemPtr.Path.size();\n    for (unsigned I = 0, N = MemPtr.Path.size(); I != N; ++I) {\n      const CXXRecordDecl *LVDecl = getAsBaseClass(\n          LV.Designator.Entries[PathLengthToMember + I]);\n      const CXXRecordDecl *MPDecl = MemPtr.Path[I];\n      if (LVDecl->getCanonicalDecl() != MPDecl->getCanonicalDecl()) {\n        Info.FFDiag(RHS);\n        return nullptr;\n      }\n    }\n\n    // Truncate the lvalue to the appropriate derived class.\n    if (!CastToDerivedClass(Info, RHS, LV, MemPtr.getContainingRecord(),\n                            PathLengthToMember))\n      return nullptr;\n  } else if (!MemPtr.Path.empty()) {\n    // Extend the LValue path with the member pointer's path.\n    LV.Designator.Entries.reserve(LV.Designator.Entries.size() +\n                                  MemPtr.Path.size() + IncludeMember);\n\n    // Walk down to the appropriate base class.\n    if (const PointerType *PT = LVType->getAs<PointerType>())\n      LVType = PT->getPointeeType();\n    const CXXRecordDecl *RD = LVType->getAsCXXRecordDecl();\n    assert(RD && \"member pointer access on non-class-type expression\");\n    // The first class in the path is that of the lvalue.\n    for (unsigned I = 1, N = MemPtr.Path.size(); I != N; ++I) {\n      const CXXRecordDecl *Base = MemPtr.Path[N - I - 1];\n      if (!HandleLValueDirectBase(Info, RHS, LV, RD, Base))\n        return nullptr;\n      RD = Base;\n    }\n    // Finally cast to the class containing the member.\n    if (!HandleLValueDirectBase(Info, RHS, LV, RD,\n                                MemPtr.getContainingRecord()))\n      return nullptr;\n  }\n\n  // Add the member. Note that we cannot build bound member functions here.\n  if (IncludeMember) {\n    if (const FieldDecl *FD = dyn_cast<FieldDecl>(MemPtr.getDecl())) {\n      if (!HandleLValueMember(Info, RHS, LV, FD))\n        return nullptr;\n    } else if (const IndirectFieldDecl *IFD =\n                 dyn_cast<IndirectFieldDecl>(MemPtr.getDecl())) {\n      if (!HandleLValueIndirectMember(Info, RHS, LV, IFD))\n        return nullptr;\n    } else {\n      llvm_unreachable(\"can't construct reference to bound member function\");\n    }\n  }\n\n  return MemPtr.getDecl();\n}\n\nstatic const ValueDecl *HandleMemberPointerAccess(EvalInfo &Info,\n                                                  const BinaryOperator *BO,\n                                                  LValue &LV,\n                                                  bool IncludeMember = true) {\n  assert(BO->getOpcode() == BO_PtrMemD || BO->getOpcode() == BO_PtrMemI);\n\n  if (!EvaluateObjectArgument(Info, BO->getLHS(), LV)) {\n    if (Info.noteFailure()) {\n      MemberPtr MemPtr;\n      EvaluateMemberPointer(BO->getRHS(), MemPtr, Info);\n    }\n    return nullptr;\n  }\n\n  return HandleMemberPointerAccess(Info, BO->getLHS()->getType(), LV,\n                                   BO->getRHS(), IncludeMember);\n}\n\n/// HandleBaseToDerivedCast - Apply the given base-to-derived cast operation on\n/// the provided lvalue, which currently refers to the base object.\nstatic bool HandleBaseToDerivedCast(EvalInfo &Info, const CastExpr *E,\n                                    LValue &Result) {\n  SubobjectDesignator &D = Result.Designator;\n  if (D.Invalid || !Result.checkNullPointer(Info, E, CSK_Derived))\n    return false;\n\n  QualType TargetQT = E->getType();\n  if (const PointerType *PT = TargetQT->getAs<PointerType>())\n    TargetQT = PT->getPointeeType();\n\n  // Check this cast lands within the final derived-to-base subobject path.\n  if (D.MostDerivedPathLength + E->path_size() > D.Entries.size()) {\n    Info.CCEDiag(E, diag::note_constexpr_invalid_downcast)\n      << D.MostDerivedType << TargetQT;\n    return false;\n  }\n\n  // Check the type of the final cast. We don't need to check the path,\n  // since a cast can only be formed if the path is unique.\n  unsigned NewEntriesSize = D.Entries.size() - E->path_size();\n  const CXXRecordDecl *TargetType = TargetQT->getAsCXXRecordDecl();\n  const CXXRecordDecl *FinalType;\n  if (NewEntriesSize == D.MostDerivedPathLength)\n    FinalType = D.MostDerivedType->getAsCXXRecordDecl();\n  else\n    FinalType = getAsBaseClass(D.Entries[NewEntriesSize - 1]);\n  if (FinalType->getCanonicalDecl() != TargetType->getCanonicalDecl()) {\n    Info.CCEDiag(E, diag::note_constexpr_invalid_downcast)\n      << D.MostDerivedType << TargetQT;\n    return false;\n  }\n\n  // Truncate the lvalue to the appropriate derived class.\n  return CastToDerivedClass(Info, E, Result, TargetType, NewEntriesSize);\n}\n\n/// Get the value to use for a default-initialized object of type T.\n/// Return false if it encounters something invalid.\nstatic bool getDefaultInitValue(QualType T, APValue &Result) {\n  bool Success = true;\n  if (auto *RD = T->getAsCXXRecordDecl()) {\n    if (RD->isInvalidDecl()) {\n      Result = APValue();\n      return false;\n    }\n    if (RD->isUnion()) {\n      Result = APValue((const FieldDecl *)nullptr);\n      return true;\n    }\n    Result = APValue(APValue::UninitStruct(), RD->getNumBases(),\n                     std::distance(RD->field_begin(), RD->field_end()));\n\n    unsigned Index = 0;\n    for (CXXRecordDecl::base_class_const_iterator I = RD->bases_begin(),\n                                                  End = RD->bases_end();\n         I != End; ++I, ++Index)\n      Success &= getDefaultInitValue(I->getType(), Result.getStructBase(Index));\n\n    for (const auto *I : RD->fields()) {\n      if (I->isUnnamedBitfield())\n        continue;\n      Success &= getDefaultInitValue(I->getType(),\n                                     Result.getStructField(I->getFieldIndex()));\n    }\n    return Success;\n  }\n\n  if (auto *AT =\n          dyn_cast_or_null<ConstantArrayType>(T->getAsArrayTypeUnsafe())) {\n    Result = APValue(APValue::UninitArray(), 0, AT->getSize().getZExtValue());\n    if (Result.hasArrayFiller())\n      Success &=\n          getDefaultInitValue(AT->getElementType(), Result.getArrayFiller());\n\n    return Success;\n  }\n\n  Result = APValue::IndeterminateValue();\n  return true;\n}\n\nnamespace {\nenum EvalStmtResult {\n  /// Evaluation failed.\n  ESR_Failed,\n  /// Hit a 'return' statement.\n  ESR_Returned,\n  /// Evaluation succeeded.\n  ESR_Succeeded,\n  /// Hit a 'continue' statement.\n  ESR_Continue,\n  /// Hit a 'break' statement.\n  ESR_Break,\n  /// Still scanning for 'case' or 'default' statement.\n  ESR_CaseNotFound\n};\n}\n\nstatic bool EvaluateVarDecl(EvalInfo &Info, const VarDecl *VD) {\n  // We don't need to evaluate the initializer for a static local.\n  if (!VD->hasLocalStorage())\n    return true;\n\n  LValue Result;\n  APValue &Val = Info.CurrentCall->createTemporary(VD, VD->getType(),\n                                                   ScopeKind::Block, Result);\n\n  const Expr *InitE = VD->getInit();\n  if (!InitE) {\n    if (VD->getType()->isDependentType())\n      return Info.noteSideEffect();\n    return getDefaultInitValue(VD->getType(), Val);\n  }\n  if (InitE->isValueDependent())\n    return false;\n\n  if (!EvaluateInPlace(Val, Info, Result, InitE)) {\n    // Wipe out any partially-computed value, to allow tracking that this\n    // evaluation failed.\n    Val = APValue();\n    return false;\n  }\n\n  return true;\n}\n\nstatic bool EvaluateDecl(EvalInfo &Info, const Decl *D) {\n  bool OK = true;\n\n  if (const VarDecl *VD = dyn_cast<VarDecl>(D))\n    OK &= EvaluateVarDecl(Info, VD);\n\n  if (const DecompositionDecl *DD = dyn_cast<DecompositionDecl>(D))\n    for (auto *BD : DD->bindings())\n      if (auto *VD = BD->getHoldingVar())\n        OK &= EvaluateDecl(Info, VD);\n\n  return OK;\n}\n\nstatic bool EvaluateDependentExpr(const Expr *E, EvalInfo &Info) {\n  assert(E->isValueDependent());\n  if (Info.noteSideEffect())\n    return true;\n  assert(E->containsErrors() && \"valid value-dependent expression should never \"\n                                \"reach invalid code path.\");\n  return false;\n}\n\n/// Evaluate a condition (either a variable declaration or an expression).\nstatic bool EvaluateCond(EvalInfo &Info, const VarDecl *CondDecl,\n                         const Expr *Cond, bool &Result) {\n  if (Cond->isValueDependent())\n    return false;\n  FullExpressionRAII Scope(Info);\n  if (CondDecl && !EvaluateDecl(Info, CondDecl))\n    return false;\n  if (!EvaluateAsBooleanCondition(Cond, Result, Info))\n    return false;\n  return Scope.destroy();\n}\n\nnamespace {\n/// A location where the result (returned value) of evaluating a\n/// statement should be stored.\nstruct StmtResult {\n  /// The APValue that should be filled in with the returned value.\n  APValue &Value;\n  /// The location containing the result, if any (used to support RVO).\n  const LValue *Slot;\n};\n\nstruct TempVersionRAII {\n  CallStackFrame &Frame;\n\n  TempVersionRAII(CallStackFrame &Frame) : Frame(Frame) {\n    Frame.pushTempVersion();\n  }\n\n  ~TempVersionRAII() {\n    Frame.popTempVersion();\n  }\n};\n\n}\n\nstatic EvalStmtResult EvaluateStmt(StmtResult &Result, EvalInfo &Info,\n                                   const Stmt *S,\n                                   const SwitchCase *SC = nullptr);\n\n/// Evaluate the body of a loop, and translate the result as appropriate.\nstatic EvalStmtResult EvaluateLoopBody(StmtResult &Result, EvalInfo &Info,\n                                       const Stmt *Body,\n                                       const SwitchCase *Case = nullptr) {\n  BlockScopeRAII Scope(Info);\n\n  EvalStmtResult ESR = EvaluateStmt(Result, Info, Body, Case);\n  if (ESR != ESR_Failed && ESR != ESR_CaseNotFound && !Scope.destroy())\n    ESR = ESR_Failed;\n\n  switch (ESR) {\n  case ESR_Break:\n    return ESR_Succeeded;\n  case ESR_Succeeded:\n  case ESR_Continue:\n    return ESR_Continue;\n  case ESR_Failed:\n  case ESR_Returned:\n  case ESR_CaseNotFound:\n    return ESR;\n  }\n  llvm_unreachable(\"Invalid EvalStmtResult!\");\n}\n\n/// Evaluate a switch statement.\nstatic EvalStmtResult EvaluateSwitch(StmtResult &Result, EvalInfo &Info,\n                                     const SwitchStmt *SS) {\n  BlockScopeRAII Scope(Info);\n\n  // Evaluate the switch condition.\n  APSInt Value;\n  {\n    if (const Stmt *Init = SS->getInit()) {\n      EvalStmtResult ESR = EvaluateStmt(Result, Info, Init);\n      if (ESR != ESR_Succeeded) {\n        if (ESR != ESR_Failed && !Scope.destroy())\n          ESR = ESR_Failed;\n        return ESR;\n      }\n    }\n\n    FullExpressionRAII CondScope(Info);\n    if (SS->getConditionVariable() &&\n        !EvaluateDecl(Info, SS->getConditionVariable()))\n      return ESR_Failed;\n    if (!EvaluateInteger(SS->getCond(), Value, Info))\n      return ESR_Failed;\n    if (!CondScope.destroy())\n      return ESR_Failed;\n  }\n\n  // Find the switch case corresponding to the value of the condition.\n  // FIXME: Cache this lookup.\n  const SwitchCase *Found = nullptr;\n  for (const SwitchCase *SC = SS->getSwitchCaseList(); SC;\n       SC = SC->getNextSwitchCase()) {\n    if (isa<DefaultStmt>(SC)) {\n      Found = SC;\n      continue;\n    }\n\n    const CaseStmt *CS = cast<CaseStmt>(SC);\n    APSInt LHS = CS->getLHS()->EvaluateKnownConstInt(Info.Ctx);\n    APSInt RHS = CS->getRHS() ? CS->getRHS()->EvaluateKnownConstInt(Info.Ctx)\n                              : LHS;\n    if (LHS <= Value && Value <= RHS) {\n      Found = SC;\n      break;\n    }\n  }\n\n  if (!Found)\n    return Scope.destroy() ? ESR_Succeeded : ESR_Failed;\n\n  // Search the switch body for the switch case and evaluate it from there.\n  EvalStmtResult ESR = EvaluateStmt(Result, Info, SS->getBody(), Found);\n  if (ESR != ESR_Failed && ESR != ESR_CaseNotFound && !Scope.destroy())\n    return ESR_Failed;\n\n  switch (ESR) {\n  case ESR_Break:\n    return ESR_Succeeded;\n  case ESR_Succeeded:\n  case ESR_Continue:\n  case ESR_Failed:\n  case ESR_Returned:\n    return ESR;\n  case ESR_CaseNotFound:\n    // This can only happen if the switch case is nested within a statement\n    // expression. We have no intention of supporting that.\n    Info.FFDiag(Found->getBeginLoc(),\n                diag::note_constexpr_stmt_expr_unsupported);\n    return ESR_Failed;\n  }\n  llvm_unreachable(\"Invalid EvalStmtResult!\");\n}\n\n// Evaluate a statement.\nstatic EvalStmtResult EvaluateStmt(StmtResult &Result, EvalInfo &Info,\n                                   const Stmt *S, const SwitchCase *Case) {\n  if (!Info.nextStep(S))\n    return ESR_Failed;\n\n  // If we're hunting down a 'case' or 'default' label, recurse through\n  // substatements until we hit the label.\n  if (Case) {\n    switch (S->getStmtClass()) {\n    case Stmt::CompoundStmtClass:\n      // FIXME: Precompute which substatement of a compound statement we\n      // would jump to, and go straight there rather than performing a\n      // linear scan each time.\n    case Stmt::LabelStmtClass:\n    case Stmt::AttributedStmtClass:\n    case Stmt::DoStmtClass:\n      break;\n\n    case Stmt::CaseStmtClass:\n    case Stmt::DefaultStmtClass:\n      if (Case == S)\n        Case = nullptr;\n      break;\n\n    case Stmt::IfStmtClass: {\n      // FIXME: Precompute which side of an 'if' we would jump to, and go\n      // straight there rather than scanning both sides.\n      const IfStmt *IS = cast<IfStmt>(S);\n\n      // Wrap the evaluation in a block scope, in case it's a DeclStmt\n      // preceded by our switch label.\n      BlockScopeRAII Scope(Info);\n\n      // Step into the init statement in case it brings an (uninitialized)\n      // variable into scope.\n      if (const Stmt *Init = IS->getInit()) {\n        EvalStmtResult ESR = EvaluateStmt(Result, Info, Init, Case);\n        if (ESR != ESR_CaseNotFound) {\n          assert(ESR != ESR_Succeeded);\n          return ESR;\n        }\n      }\n\n      // Condition variable must be initialized if it exists.\n      // FIXME: We can skip evaluating the body if there's a condition\n      // variable, as there can't be any case labels within it.\n      // (The same is true for 'for' statements.)\n\n      EvalStmtResult ESR = EvaluateStmt(Result, Info, IS->getThen(), Case);\n      if (ESR == ESR_Failed)\n        return ESR;\n      if (ESR != ESR_CaseNotFound)\n        return Scope.destroy() ? ESR : ESR_Failed;\n      if (!IS->getElse())\n        return ESR_CaseNotFound;\n\n      ESR = EvaluateStmt(Result, Info, IS->getElse(), Case);\n      if (ESR == ESR_Failed)\n        return ESR;\n      if (ESR != ESR_CaseNotFound)\n        return Scope.destroy() ? ESR : ESR_Failed;\n      return ESR_CaseNotFound;\n    }\n\n    case Stmt::WhileStmtClass: {\n      EvalStmtResult ESR =\n          EvaluateLoopBody(Result, Info, cast<WhileStmt>(S)->getBody(), Case);\n      if (ESR != ESR_Continue)\n        return ESR;\n      break;\n    }\n\n    case Stmt::ForStmtClass: {\n      const ForStmt *FS = cast<ForStmt>(S);\n      BlockScopeRAII Scope(Info);\n\n      // Step into the init statement in case it brings an (uninitialized)\n      // variable into scope.\n      if (const Stmt *Init = FS->getInit()) {\n        EvalStmtResult ESR = EvaluateStmt(Result, Info, Init, Case);\n        if (ESR != ESR_CaseNotFound) {\n          assert(ESR != ESR_Succeeded);\n          return ESR;\n        }\n      }\n\n      EvalStmtResult ESR =\n          EvaluateLoopBody(Result, Info, FS->getBody(), Case);\n      if (ESR != ESR_Continue)\n        return ESR;\n      if (const auto *Inc = FS->getInc()) {\n        if (Inc->isValueDependent()) {\n          if (!EvaluateDependentExpr(Inc, Info))\n            return ESR_Failed;\n        } else {\n          FullExpressionRAII IncScope(Info);\n          if (!EvaluateIgnoredValue(Info, Inc) || !IncScope.destroy())\n            return ESR_Failed;\n        }\n      }\n      break;\n    }\n\n    case Stmt::DeclStmtClass: {\n      // Start the lifetime of any uninitialized variables we encounter. They\n      // might be used by the selected branch of the switch.\n      const DeclStmt *DS = cast<DeclStmt>(S);\n      for (const auto *D : DS->decls()) {\n        if (const auto *VD = dyn_cast<VarDecl>(D)) {\n          if (VD->hasLocalStorage() && !VD->getInit())\n            if (!EvaluateVarDecl(Info, VD))\n              return ESR_Failed;\n          // FIXME: If the variable has initialization that can't be jumped\n          // over, bail out of any immediately-surrounding compound-statement\n          // too. There can't be any case labels here.\n        }\n      }\n      return ESR_CaseNotFound;\n    }\n\n    default:\n      return ESR_CaseNotFound;\n    }\n  }\n\n  switch (S->getStmtClass()) {\n  default:\n    if (const Expr *E = dyn_cast<Expr>(S)) {\n      if (E->isValueDependent()) {\n        if (!EvaluateDependentExpr(E, Info))\n          return ESR_Failed;\n      } else {\n        // Don't bother evaluating beyond an expression-statement which couldn't\n        // be evaluated.\n        // FIXME: Do we need the FullExpressionRAII object here?\n        // VisitExprWithCleanups should create one when necessary.\n        FullExpressionRAII Scope(Info);\n        if (!EvaluateIgnoredValue(Info, E) || !Scope.destroy())\n          return ESR_Failed;\n      }\n      return ESR_Succeeded;\n    }\n\n    Info.FFDiag(S->getBeginLoc());\n    return ESR_Failed;\n\n  case Stmt::NullStmtClass:\n    return ESR_Succeeded;\n\n  case Stmt::DeclStmtClass: {\n    const DeclStmt *DS = cast<DeclStmt>(S);\n    for (const auto *D : DS->decls()) {\n      // Each declaration initialization is its own full-expression.\n      FullExpressionRAII Scope(Info);\n      if (!EvaluateDecl(Info, D) && !Info.noteFailure())\n        return ESR_Failed;\n      if (!Scope.destroy())\n        return ESR_Failed;\n    }\n    return ESR_Succeeded;\n  }\n\n  case Stmt::ReturnStmtClass: {\n    const Expr *RetExpr = cast<ReturnStmt>(S)->getRetValue();\n    FullExpressionRAII Scope(Info);\n    if (RetExpr && RetExpr->isValueDependent()) {\n      EvaluateDependentExpr(RetExpr, Info);\n      // We know we returned, but we don't know what the value is.\n      return ESR_Failed;\n    }\n    if (RetExpr &&\n        !(Result.Slot\n              ? EvaluateInPlace(Result.Value, Info, *Result.Slot, RetExpr)\n              : Evaluate(Result.Value, Info, RetExpr)))\n      return ESR_Failed;\n    return Scope.destroy() ? ESR_Returned : ESR_Failed;\n  }\n\n  case Stmt::CompoundStmtClass: {\n    BlockScopeRAII Scope(Info);\n\n    const CompoundStmt *CS = cast<CompoundStmt>(S);\n    for (const auto *BI : CS->body()) {\n      EvalStmtResult ESR = EvaluateStmt(Result, Info, BI, Case);\n      if (ESR == ESR_Succeeded)\n        Case = nullptr;\n      else if (ESR != ESR_CaseNotFound) {\n        if (ESR != ESR_Failed && !Scope.destroy())\n          return ESR_Failed;\n        return ESR;\n      }\n    }\n    if (Case)\n      return ESR_CaseNotFound;\n    return Scope.destroy() ? ESR_Succeeded : ESR_Failed;\n  }\n\n  case Stmt::IfStmtClass: {\n    const IfStmt *IS = cast<IfStmt>(S);\n\n    // Evaluate the condition, as either a var decl or as an expression.\n    BlockScopeRAII Scope(Info);\n    if (const Stmt *Init = IS->getInit()) {\n      EvalStmtResult ESR = EvaluateStmt(Result, Info, Init);\n      if (ESR != ESR_Succeeded) {\n        if (ESR != ESR_Failed && !Scope.destroy())\n          return ESR_Failed;\n        return ESR;\n      }\n    }\n    bool Cond;\n    if (!EvaluateCond(Info, IS->getConditionVariable(), IS->getCond(), Cond))\n      return ESR_Failed;\n\n    if (const Stmt *SubStmt = Cond ? IS->getThen() : IS->getElse()) {\n      EvalStmtResult ESR = EvaluateStmt(Result, Info, SubStmt);\n      if (ESR != ESR_Succeeded) {\n        if (ESR != ESR_Failed && !Scope.destroy())\n          return ESR_Failed;\n        return ESR;\n      }\n    }\n    return Scope.destroy() ? ESR_Succeeded : ESR_Failed;\n  }\n\n  case Stmt::WhileStmtClass: {\n    const WhileStmt *WS = cast<WhileStmt>(S);\n    while (true) {\n      BlockScopeRAII Scope(Info);\n      bool Continue;\n      if (!EvaluateCond(Info, WS->getConditionVariable(), WS->getCond(),\n                        Continue))\n        return ESR_Failed;\n      if (!Continue)\n        break;\n\n      EvalStmtResult ESR = EvaluateLoopBody(Result, Info, WS->getBody());\n      if (ESR != ESR_Continue) {\n        if (ESR != ESR_Failed && !Scope.destroy())\n          return ESR_Failed;\n        return ESR;\n      }\n      if (!Scope.destroy())\n        return ESR_Failed;\n    }\n    return ESR_Succeeded;\n  }\n\n  case Stmt::DoStmtClass: {\n    const DoStmt *DS = cast<DoStmt>(S);\n    bool Continue;\n    do {\n      EvalStmtResult ESR = EvaluateLoopBody(Result, Info, DS->getBody(), Case);\n      if (ESR != ESR_Continue)\n        return ESR;\n      Case = nullptr;\n\n      if (DS->getCond()->isValueDependent()) {\n        EvaluateDependentExpr(DS->getCond(), Info);\n        // Bailout as we don't know whether to keep going or terminate the loop.\n        return ESR_Failed;\n      }\n      FullExpressionRAII CondScope(Info);\n      if (!EvaluateAsBooleanCondition(DS->getCond(), Continue, Info) ||\n          !CondScope.destroy())\n        return ESR_Failed;\n    } while (Continue);\n    return ESR_Succeeded;\n  }\n\n  case Stmt::ForStmtClass: {\n    const ForStmt *FS = cast<ForStmt>(S);\n    BlockScopeRAII ForScope(Info);\n    if (FS->getInit()) {\n      EvalStmtResult ESR = EvaluateStmt(Result, Info, FS->getInit());\n      if (ESR != ESR_Succeeded) {\n        if (ESR != ESR_Failed && !ForScope.destroy())\n          return ESR_Failed;\n        return ESR;\n      }\n    }\n    while (true) {\n      BlockScopeRAII IterScope(Info);\n      bool Continue = true;\n      if (FS->getCond() && !EvaluateCond(Info, FS->getConditionVariable(),\n                                         FS->getCond(), Continue))\n        return ESR_Failed;\n      if (!Continue)\n        break;\n\n      EvalStmtResult ESR = EvaluateLoopBody(Result, Info, FS->getBody());\n      if (ESR != ESR_Continue) {\n        if (ESR != ESR_Failed && (!IterScope.destroy() || !ForScope.destroy()))\n          return ESR_Failed;\n        return ESR;\n      }\n\n      if (const auto *Inc = FS->getInc()) {\n        if (Inc->isValueDependent()) {\n          if (!EvaluateDependentExpr(Inc, Info))\n            return ESR_Failed;\n        } else {\n          FullExpressionRAII IncScope(Info);\n          if (!EvaluateIgnoredValue(Info, Inc) || !IncScope.destroy())\n            return ESR_Failed;\n        }\n      }\n\n      if (!IterScope.destroy())\n        return ESR_Failed;\n    }\n    return ForScope.destroy() ? ESR_Succeeded : ESR_Failed;\n  }\n\n  case Stmt::CXXForRangeStmtClass: {\n    const CXXForRangeStmt *FS = cast<CXXForRangeStmt>(S);\n    BlockScopeRAII Scope(Info);\n\n    // Evaluate the init-statement if present.\n    if (FS->getInit()) {\n      EvalStmtResult ESR = EvaluateStmt(Result, Info, FS->getInit());\n      if (ESR != ESR_Succeeded) {\n        if (ESR != ESR_Failed && !Scope.destroy())\n          return ESR_Failed;\n        return ESR;\n      }\n    }\n\n    // Initialize the __range variable.\n    EvalStmtResult ESR = EvaluateStmt(Result, Info, FS->getRangeStmt());\n    if (ESR != ESR_Succeeded) {\n      if (ESR != ESR_Failed && !Scope.destroy())\n        return ESR_Failed;\n      return ESR;\n    }\n\n    // Create the __begin and __end iterators.\n    ESR = EvaluateStmt(Result, Info, FS->getBeginStmt());\n    if (ESR != ESR_Succeeded) {\n      if (ESR != ESR_Failed && !Scope.destroy())\n        return ESR_Failed;\n      return ESR;\n    }\n    ESR = EvaluateStmt(Result, Info, FS->getEndStmt());\n    if (ESR != ESR_Succeeded) {\n      if (ESR != ESR_Failed && !Scope.destroy())\n        return ESR_Failed;\n      return ESR;\n    }\n\n    while (true) {\n      // Condition: __begin != __end.\n      {\n        if (FS->getCond()->isValueDependent()) {\n          EvaluateDependentExpr(FS->getCond(), Info);\n          // We don't know whether to keep going or terminate the loop.\n          return ESR_Failed;\n        }\n        bool Continue = true;\n        FullExpressionRAII CondExpr(Info);\n        if (!EvaluateAsBooleanCondition(FS->getCond(), Continue, Info))\n          return ESR_Failed;\n        if (!Continue)\n          break;\n      }\n\n      // User's variable declaration, initialized by *__begin.\n      BlockScopeRAII InnerScope(Info);\n      ESR = EvaluateStmt(Result, Info, FS->getLoopVarStmt());\n      if (ESR != ESR_Succeeded) {\n        if (ESR != ESR_Failed && (!InnerScope.destroy() || !Scope.destroy()))\n          return ESR_Failed;\n        return ESR;\n      }\n\n      // Loop body.\n      ESR = EvaluateLoopBody(Result, Info, FS->getBody());\n      if (ESR != ESR_Continue) {\n        if (ESR != ESR_Failed && (!InnerScope.destroy() || !Scope.destroy()))\n          return ESR_Failed;\n        return ESR;\n      }\n      if (FS->getInc()->isValueDependent()) {\n        if (!EvaluateDependentExpr(FS->getInc(), Info))\n          return ESR_Failed;\n      } else {\n        // Increment: ++__begin\n        if (!EvaluateIgnoredValue(Info, FS->getInc()))\n          return ESR_Failed;\n      }\n\n      if (!InnerScope.destroy())\n        return ESR_Failed;\n    }\n\n    return Scope.destroy() ? ESR_Succeeded : ESR_Failed;\n  }\n\n  case Stmt::SwitchStmtClass:\n    return EvaluateSwitch(Result, Info, cast<SwitchStmt>(S));\n\n  case Stmt::ContinueStmtClass:\n    return ESR_Continue;\n\n  case Stmt::BreakStmtClass:\n    return ESR_Break;\n\n  case Stmt::LabelStmtClass:\n    return EvaluateStmt(Result, Info, cast<LabelStmt>(S)->getSubStmt(), Case);\n\n  case Stmt::AttributedStmtClass:\n    // As a general principle, C++11 attributes can be ignored without\n    // any semantic impact.\n    return EvaluateStmt(Result, Info, cast<AttributedStmt>(S)->getSubStmt(),\n                        Case);\n\n  case Stmt::CaseStmtClass:\n  case Stmt::DefaultStmtClass:\n    return EvaluateStmt(Result, Info, cast<SwitchCase>(S)->getSubStmt(), Case);\n  case Stmt::CXXTryStmtClass:\n    // Evaluate try blocks by evaluating all sub statements.\n    return EvaluateStmt(Result, Info, cast<CXXTryStmt>(S)->getTryBlock(), Case);\n  }\n}\n\n/// CheckTrivialDefaultConstructor - Check whether a constructor is a trivial\n/// default constructor. If so, we'll fold it whether or not it's marked as\n/// constexpr. If it is marked as constexpr, we will never implicitly define it,\n/// so we need special handling.\nstatic bool CheckTrivialDefaultConstructor(EvalInfo &Info, SourceLocation Loc,\n                                           const CXXConstructorDecl *CD,\n                                           bool IsValueInitialization) {\n  if (!CD->isTrivial() || !CD->isDefaultConstructor())\n    return false;\n\n  // Value-initialization does not call a trivial default constructor, so such a\n  // call is a core constant expression whether or not the constructor is\n  // constexpr.\n  if (!CD->isConstexpr() && !IsValueInitialization) {\n    if (Info.getLangOpts().CPlusPlus11) {\n      // FIXME: If DiagDecl is an implicitly-declared special member function,\n      // we should be much more explicit about why it's not constexpr.\n      Info.CCEDiag(Loc, diag::note_constexpr_invalid_function, 1)\n        << /*IsConstexpr*/0 << /*IsConstructor*/1 << CD;\n      Info.Note(CD->getLocation(), diag::note_declared_at);\n    } else {\n      Info.CCEDiag(Loc, diag::note_invalid_subexpr_in_const_expr);\n    }\n  }\n  return true;\n}\n\n/// CheckConstexprFunction - Check that a function can be called in a constant\n/// expression.\nstatic bool CheckConstexprFunction(EvalInfo &Info, SourceLocation CallLoc,\n                                   const FunctionDecl *Declaration,\n                                   const FunctionDecl *Definition,\n                                   const Stmt *Body) {\n  // Potential constant expressions can contain calls to declared, but not yet\n  // defined, constexpr functions.\n  if (Info.checkingPotentialConstantExpression() && !Definition &&\n      Declaration->isConstexpr())\n    return false;\n\n  // Bail out if the function declaration itself is invalid.  We will\n  // have produced a relevant diagnostic while parsing it, so just\n  // note the problematic sub-expression.\n  if (Declaration->isInvalidDecl()) {\n    Info.FFDiag(CallLoc, diag::note_invalid_subexpr_in_const_expr);\n    return false;\n  }\n\n  // DR1872: An instantiated virtual constexpr function can't be called in a\n  // constant expression (prior to C++20). We can still constant-fold such a\n  // call.\n  if (!Info.Ctx.getLangOpts().CPlusPlus20 && isa<CXXMethodDecl>(Declaration) &&\n      cast<CXXMethodDecl>(Declaration)->isVirtual())\n    Info.CCEDiag(CallLoc, diag::note_constexpr_virtual_call);\n\n  if (Definition && Definition->isInvalidDecl()) {\n    Info.FFDiag(CallLoc, diag::note_invalid_subexpr_in_const_expr);\n    return false;\n  }\n\n  // Can we evaluate this function call?\n  if (Definition && Definition->isConstexpr() && Body)\n    return true;\n\n  if (Info.getLangOpts().CPlusPlus11) {\n    const FunctionDecl *DiagDecl = Definition ? Definition : Declaration;\n\n    // If this function is not constexpr because it is an inherited\n    // non-constexpr constructor, diagnose that directly.\n    auto *CD = dyn_cast<CXXConstructorDecl>(DiagDecl);\n    if (CD && CD->isInheritingConstructor()) {\n      auto *Inherited = CD->getInheritedConstructor().getConstructor();\n      if (!Inherited->isConstexpr())\n        DiagDecl = CD = Inherited;\n    }\n\n    // FIXME: If DiagDecl is an implicitly-declared special member function\n    // or an inheriting constructor, we should be much more explicit about why\n    // it's not constexpr.\n    if (CD && CD->isInheritingConstructor())\n      Info.FFDiag(CallLoc, diag::note_constexpr_invalid_inhctor, 1)\n        << CD->getInheritedConstructor().getConstructor()->getParent();\n    else\n      Info.FFDiag(CallLoc, diag::note_constexpr_invalid_function, 1)\n        << DiagDecl->isConstexpr() << (bool)CD << DiagDecl;\n    Info.Note(DiagDecl->getLocation(), diag::note_declared_at);\n  } else {\n    Info.FFDiag(CallLoc, diag::note_invalid_subexpr_in_const_expr);\n  }\n  return false;\n}\n\nnamespace {\nstruct CheckDynamicTypeHandler {\n  AccessKinds AccessKind;\n  typedef bool result_type;\n  bool failed() { return false; }\n  bool found(APValue &Subobj, QualType SubobjType) { return true; }\n  bool found(APSInt &Value, QualType SubobjType) { return true; }\n  bool found(APFloat &Value, QualType SubobjType) { return true; }\n};\n} // end anonymous namespace\n\n/// Check that we can access the notional vptr of an object / determine its\n/// dynamic type.\nstatic bool checkDynamicType(EvalInfo &Info, const Expr *E, const LValue &This,\n                             AccessKinds AK, bool Polymorphic) {\n  if (This.Designator.Invalid)\n    return false;\n\n  CompleteObject Obj = findCompleteObject(Info, E, AK, This, QualType());\n\n  if (!Obj)\n    return false;\n\n  if (!Obj.Value) {\n    // The object is not usable in constant expressions, so we can't inspect\n    // its value to see if it's in-lifetime or what the active union members\n    // are. We can still check for a one-past-the-end lvalue.\n    if (This.Designator.isOnePastTheEnd() ||\n        This.Designator.isMostDerivedAnUnsizedArray()) {\n      Info.FFDiag(E, This.Designator.isOnePastTheEnd()\n                         ? diag::note_constexpr_access_past_end\n                         : diag::note_constexpr_access_unsized_array)\n          << AK;\n      return false;\n    } else if (Polymorphic) {\n      // Conservatively refuse to perform a polymorphic operation if we would\n      // not be able to read a notional 'vptr' value.\n      APValue Val;\n      This.moveInto(Val);\n      QualType StarThisType =\n          Info.Ctx.getLValueReferenceType(This.Designator.getType(Info.Ctx));\n      Info.FFDiag(E, diag::note_constexpr_polymorphic_unknown_dynamic_type)\n          << AK << Val.getAsString(Info.Ctx, StarThisType);\n      return false;\n    }\n    return true;\n  }\n\n  CheckDynamicTypeHandler Handler{AK};\n  return Obj && findSubobject(Info, E, Obj, This.Designator, Handler);\n}\n\n/// Check that the pointee of the 'this' pointer in a member function call is\n/// either within its lifetime or in its period of construction or destruction.\nstatic bool\ncheckNonVirtualMemberCallThisPointer(EvalInfo &Info, const Expr *E,\n                                     const LValue &This,\n                                     const CXXMethodDecl *NamedMember) {\n  return checkDynamicType(\n      Info, E, This,\n      isa<CXXDestructorDecl>(NamedMember) ? AK_Destroy : AK_MemberCall, false);\n}\n\nstruct DynamicType {\n  /// The dynamic class type of the object.\n  const CXXRecordDecl *Type;\n  /// The corresponding path length in the lvalue.\n  unsigned PathLength;\n};\n\nstatic const CXXRecordDecl *getBaseClassType(SubobjectDesignator &Designator,\n                                             unsigned PathLength) {\n  assert(PathLength >= Designator.MostDerivedPathLength && PathLength <=\n      Designator.Entries.size() && \"invalid path length\");\n  return (PathLength == Designator.MostDerivedPathLength)\n             ? Designator.MostDerivedType->getAsCXXRecordDecl()\n             : getAsBaseClass(Designator.Entries[PathLength - 1]);\n}\n\n/// Determine the dynamic type of an object.\nstatic Optional<DynamicType> ComputeDynamicType(EvalInfo &Info, const Expr *E,\n                                                LValue &This, AccessKinds AK) {\n  // If we don't have an lvalue denoting an object of class type, there is no\n  // meaningful dynamic type. (We consider objects of non-class type to have no\n  // dynamic type.)\n  if (!checkDynamicType(Info, E, This, AK, true))\n    return None;\n\n  // Refuse to compute a dynamic type in the presence of virtual bases. This\n  // shouldn't happen other than in constant-folding situations, since literal\n  // types can't have virtual bases.\n  //\n  // Note that consumers of DynamicType assume that the type has no virtual\n  // bases, and will need modifications if this restriction is relaxed.\n  const CXXRecordDecl *Class =\n      This.Designator.MostDerivedType->getAsCXXRecordDecl();\n  if (!Class || Class->getNumVBases()) {\n    Info.FFDiag(E);\n    return None;\n  }\n\n  // FIXME: For very deep class hierarchies, it might be beneficial to use a\n  // binary search here instead. But the overwhelmingly common case is that\n  // we're not in the middle of a constructor, so it probably doesn't matter\n  // in practice.\n  ArrayRef<APValue::LValuePathEntry> Path = This.Designator.Entries;\n  for (unsigned PathLength = This.Designator.MostDerivedPathLength;\n       PathLength <= Path.size(); ++PathLength) {\n    switch (Info.isEvaluatingCtorDtor(This.getLValueBase(),\n                                      Path.slice(0, PathLength))) {\n    case ConstructionPhase::Bases:\n    case ConstructionPhase::DestroyingBases:\n      // We're constructing or destroying a base class. This is not the dynamic\n      // type.\n      break;\n\n    case ConstructionPhase::None:\n    case ConstructionPhase::AfterBases:\n    case ConstructionPhase::AfterFields:\n    case ConstructionPhase::Destroying:\n      // We've finished constructing the base classes and not yet started\n      // destroying them again, so this is the dynamic type.\n      return DynamicType{getBaseClassType(This.Designator, PathLength),\n                         PathLength};\n    }\n  }\n\n  // CWG issue 1517: we're constructing a base class of the object described by\n  // 'This', so that object has not yet begun its period of construction and\n  // any polymorphic operation on it results in undefined behavior.\n  Info.FFDiag(E);\n  return None;\n}\n\n/// Perform virtual dispatch.\nstatic const CXXMethodDecl *HandleVirtualDispatch(\n    EvalInfo &Info, const Expr *E, LValue &This, const CXXMethodDecl *Found,\n    llvm::SmallVectorImpl<QualType> &CovariantAdjustmentPath) {\n  Optional<DynamicType> DynType = ComputeDynamicType(\n      Info, E, This,\n      isa<CXXDestructorDecl>(Found) ? AK_Destroy : AK_MemberCall);\n  if (!DynType)\n    return nullptr;\n\n  // Find the final overrider. It must be declared in one of the classes on the\n  // path from the dynamic type to the static type.\n  // FIXME: If we ever allow literal types to have virtual base classes, that\n  // won't be true.\n  const CXXMethodDecl *Callee = Found;\n  unsigned PathLength = DynType->PathLength;\n  for (/**/; PathLength <= This.Designator.Entries.size(); ++PathLength) {\n    const CXXRecordDecl *Class = getBaseClassType(This.Designator, PathLength);\n    const CXXMethodDecl *Overrider =\n        Found->getCorrespondingMethodDeclaredInClass(Class, false);\n    if (Overrider) {\n      Callee = Overrider;\n      break;\n    }\n  }\n\n  // C++2a [class.abstract]p6:\n  //   the effect of making a virtual call to a pure virtual function [...] is\n  //   undefined\n  if (Callee->isPure()) {\n    Info.FFDiag(E, diag::note_constexpr_pure_virtual_call, 1) << Callee;\n    Info.Note(Callee->getLocation(), diag::note_declared_at);\n    return nullptr;\n  }\n\n  // If necessary, walk the rest of the path to determine the sequence of\n  // covariant adjustment steps to apply.\n  if (!Info.Ctx.hasSameUnqualifiedType(Callee->getReturnType(),\n                                       Found->getReturnType())) {\n    CovariantAdjustmentPath.push_back(Callee->getReturnType());\n    for (unsigned CovariantPathLength = PathLength + 1;\n         CovariantPathLength != This.Designator.Entries.size();\n         ++CovariantPathLength) {\n      const CXXRecordDecl *NextClass =\n          getBaseClassType(This.Designator, CovariantPathLength);\n      const CXXMethodDecl *Next =\n          Found->getCorrespondingMethodDeclaredInClass(NextClass, false);\n      if (Next && !Info.Ctx.hasSameUnqualifiedType(\n                      Next->getReturnType(), CovariantAdjustmentPath.back()))\n        CovariantAdjustmentPath.push_back(Next->getReturnType());\n    }\n    if (!Info.Ctx.hasSameUnqualifiedType(Found->getReturnType(),\n                                         CovariantAdjustmentPath.back()))\n      CovariantAdjustmentPath.push_back(Found->getReturnType());\n  }\n\n  // Perform 'this' adjustment.\n  if (!CastToDerivedClass(Info, E, This, Callee->getParent(), PathLength))\n    return nullptr;\n\n  return Callee;\n}\n\n/// Perform the adjustment from a value returned by a virtual function to\n/// a value of the statically expected type, which may be a pointer or\n/// reference to a base class of the returned type.\nstatic bool HandleCovariantReturnAdjustment(EvalInfo &Info, const Expr *E,\n                                            APValue &Result,\n                                            ArrayRef<QualType> Path) {\n  assert(Result.isLValue() &&\n         \"unexpected kind of APValue for covariant return\");\n  if (Result.isNullPointer())\n    return true;\n\n  LValue LVal;\n  LVal.setFrom(Info.Ctx, Result);\n\n  const CXXRecordDecl *OldClass = Path[0]->getPointeeCXXRecordDecl();\n  for (unsigned I = 1; I != Path.size(); ++I) {\n    const CXXRecordDecl *NewClass = Path[I]->getPointeeCXXRecordDecl();\n    assert(OldClass && NewClass && \"unexpected kind of covariant return\");\n    if (OldClass != NewClass &&\n        !CastToBaseClass(Info, E, LVal, OldClass, NewClass))\n      return false;\n    OldClass = NewClass;\n  }\n\n  LVal.moveInto(Result);\n  return true;\n}\n\n/// Determine whether \\p Base, which is known to be a direct base class of\n/// \\p Derived, is a public base class.\nstatic bool isBaseClassPublic(const CXXRecordDecl *Derived,\n                              const CXXRecordDecl *Base) {\n  for (const CXXBaseSpecifier &BaseSpec : Derived->bases()) {\n    auto *BaseClass = BaseSpec.getType()->getAsCXXRecordDecl();\n    if (BaseClass && declaresSameEntity(BaseClass, Base))\n      return BaseSpec.getAccessSpecifier() == AS_public;\n  }\n  llvm_unreachable(\"Base is not a direct base of Derived\");\n}\n\n/// Apply the given dynamic cast operation on the provided lvalue.\n///\n/// This implements the hard case of dynamic_cast, requiring a \"runtime check\"\n/// to find a suitable target subobject.\nstatic bool HandleDynamicCast(EvalInfo &Info, const ExplicitCastExpr *E,\n                              LValue &Ptr) {\n  // We can't do anything with a non-symbolic pointer value.\n  SubobjectDesignator &D = Ptr.Designator;\n  if (D.Invalid)\n    return false;\n\n  // C++ [expr.dynamic.cast]p6:\n  //   If v is a null pointer value, the result is a null pointer value.\n  if (Ptr.isNullPointer() && !E->isGLValue())\n    return true;\n\n  // For all the other cases, we need the pointer to point to an object within\n  // its lifetime / period of construction / destruction, and we need to know\n  // its dynamic type.\n  Optional<DynamicType> DynType =\n      ComputeDynamicType(Info, E, Ptr, AK_DynamicCast);\n  if (!DynType)\n    return false;\n\n  // C++ [expr.dynamic.cast]p7:\n  //   If T is \"pointer to cv void\", then the result is a pointer to the most\n  //   derived object\n  if (E->getType()->isVoidPointerType())\n    return CastToDerivedClass(Info, E, Ptr, DynType->Type, DynType->PathLength);\n\n  const CXXRecordDecl *C = E->getTypeAsWritten()->getPointeeCXXRecordDecl();\n  assert(C && \"dynamic_cast target is not void pointer nor class\");\n  CanQualType CQT = Info.Ctx.getCanonicalType(Info.Ctx.getRecordType(C));\n\n  auto RuntimeCheckFailed = [&] (CXXBasePaths *Paths) {\n    // C++ [expr.dynamic.cast]p9:\n    if (!E->isGLValue()) {\n      //   The value of a failed cast to pointer type is the null pointer value\n      //   of the required result type.\n      Ptr.setNull(Info.Ctx, E->getType());\n      return true;\n    }\n\n    //   A failed cast to reference type throws [...] std::bad_cast.\n    unsigned DiagKind;\n    if (!Paths && (declaresSameEntity(DynType->Type, C) ||\n                   DynType->Type->isDerivedFrom(C)))\n      DiagKind = 0;\n    else if (!Paths || Paths->begin() == Paths->end())\n      DiagKind = 1;\n    else if (Paths->isAmbiguous(CQT))\n      DiagKind = 2;\n    else {\n      assert(Paths->front().Access != AS_public && \"why did the cast fail?\");\n      DiagKind = 3;\n    }\n    Info.FFDiag(E, diag::note_constexpr_dynamic_cast_to_reference_failed)\n        << DiagKind << Ptr.Designator.getType(Info.Ctx)\n        << Info.Ctx.getRecordType(DynType->Type)\n        << E->getType().getUnqualifiedType();\n    return false;\n  };\n\n  // Runtime check, phase 1:\n  //   Walk from the base subobject towards the derived object looking for the\n  //   target type.\n  for (int PathLength = Ptr.Designator.Entries.size();\n       PathLength >= (int)DynType->PathLength; --PathLength) {\n    const CXXRecordDecl *Class = getBaseClassType(Ptr.Designator, PathLength);\n    if (declaresSameEntity(Class, C))\n      return CastToDerivedClass(Info, E, Ptr, Class, PathLength);\n    // We can only walk across public inheritance edges.\n    if (PathLength > (int)DynType->PathLength &&\n        !isBaseClassPublic(getBaseClassType(Ptr.Designator, PathLength - 1),\n                           Class))\n      return RuntimeCheckFailed(nullptr);\n  }\n\n  // Runtime check, phase 2:\n  //   Search the dynamic type for an unambiguous public base of type C.\n  CXXBasePaths Paths(/*FindAmbiguities=*/true,\n                     /*RecordPaths=*/true, /*DetectVirtual=*/false);\n  if (DynType->Type->isDerivedFrom(C, Paths) && !Paths.isAmbiguous(CQT) &&\n      Paths.front().Access == AS_public) {\n    // Downcast to the dynamic type...\n    if (!CastToDerivedClass(Info, E, Ptr, DynType->Type, DynType->PathLength))\n      return false;\n    // ... then upcast to the chosen base class subobject.\n    for (CXXBasePathElement &Elem : Paths.front())\n      if (!HandleLValueBase(Info, E, Ptr, Elem.Class, Elem.Base))\n        return false;\n    return true;\n  }\n\n  // Otherwise, the runtime check fails.\n  return RuntimeCheckFailed(&Paths);\n}\n\nnamespace {\nstruct StartLifetimeOfUnionMemberHandler {\n  EvalInfo &Info;\n  const Expr *LHSExpr;\n  const FieldDecl *Field;\n  bool DuringInit;\n  bool Failed = false;\n  static const AccessKinds AccessKind = AK_Assign;\n\n  typedef bool result_type;\n  bool failed() { return Failed; }\n  bool found(APValue &Subobj, QualType SubobjType) {\n    // We are supposed to perform no initialization but begin the lifetime of\n    // the object. We interpret that as meaning to do what default\n    // initialization of the object would do if all constructors involved were\n    // trivial:\n    //  * All base, non-variant member, and array element subobjects' lifetimes\n    //    begin\n    //  * No variant members' lifetimes begin\n    //  * All scalar subobjects whose lifetimes begin have indeterminate values\n    assert(SubobjType->isUnionType());\n    if (declaresSameEntity(Subobj.getUnionField(), Field)) {\n      // This union member is already active. If it's also in-lifetime, there's\n      // nothing to do.\n      if (Subobj.getUnionValue().hasValue())\n        return true;\n    } else if (DuringInit) {\n      // We're currently in the process of initializing a different union\n      // member.  If we carried on, that initialization would attempt to\n      // store to an inactive union member, resulting in undefined behavior.\n      Info.FFDiag(LHSExpr,\n                  diag::note_constexpr_union_member_change_during_init);\n      return false;\n    }\n    APValue Result;\n    Failed = !getDefaultInitValue(Field->getType(), Result);\n    Subobj.setUnion(Field, Result);\n    return true;\n  }\n  bool found(APSInt &Value, QualType SubobjType) {\n    llvm_unreachable(\"wrong value kind for union object\");\n  }\n  bool found(APFloat &Value, QualType SubobjType) {\n    llvm_unreachable(\"wrong value kind for union object\");\n  }\n};\n} // end anonymous namespace\n\nconst AccessKinds StartLifetimeOfUnionMemberHandler::AccessKind;\n\n/// Handle a builtin simple-assignment or a call to a trivial assignment\n/// operator whose left-hand side might involve a union member access. If it\n/// does, implicitly start the lifetime of any accessed union elements per\n/// C++20 [class.union]5.\nstatic bool HandleUnionActiveMemberChange(EvalInfo &Info, const Expr *LHSExpr,\n                                          const LValue &LHS) {\n  if (LHS.InvalidBase || LHS.Designator.Invalid)\n    return false;\n\n  llvm::SmallVector<std::pair<unsigned, const FieldDecl*>, 4> UnionPathLengths;\n  // C++ [class.union]p5:\n  //   define the set S(E) of subexpressions of E as follows:\n  unsigned PathLength = LHS.Designator.Entries.size();\n  for (const Expr *E = LHSExpr; E != nullptr;) {\n    //   -- If E is of the form A.B, S(E) contains the elements of S(A)...\n    if (auto *ME = dyn_cast<MemberExpr>(E)) {\n      auto *FD = dyn_cast<FieldDecl>(ME->getMemberDecl());\n      // Note that we can't implicitly start the lifetime of a reference,\n      // so we don't need to proceed any further if we reach one.\n      if (!FD || FD->getType()->isReferenceType())\n        break;\n\n      //    ... and also contains A.B if B names a union member ...\n      if (FD->getParent()->isUnion()) {\n        //    ... of a non-class, non-array type, or of a class type with a\n        //    trivial default constructor that is not deleted, or an array of\n        //    such types.\n        auto *RD =\n            FD->getType()->getBaseElementTypeUnsafe()->getAsCXXRecordDecl();\n        if (!RD || RD->hasTrivialDefaultConstructor())\n          UnionPathLengths.push_back({PathLength - 1, FD});\n      }\n\n      E = ME->getBase();\n      --PathLength;\n      assert(declaresSameEntity(FD,\n                                LHS.Designator.Entries[PathLength]\n                                    .getAsBaseOrMember().getPointer()));\n\n      //   -- If E is of the form A[B] and is interpreted as a built-in array\n      //      subscripting operator, S(E) is [S(the array operand, if any)].\n    } else if (auto *ASE = dyn_cast<ArraySubscriptExpr>(E)) {\n      // Step over an ArrayToPointerDecay implicit cast.\n      auto *Base = ASE->getBase()->IgnoreImplicit();\n      if (!Base->getType()->isArrayType())\n        break;\n\n      E = Base;\n      --PathLength;\n\n    } else if (auto *ICE = dyn_cast<ImplicitCastExpr>(E)) {\n      // Step over a derived-to-base conversion.\n      E = ICE->getSubExpr();\n      if (ICE->getCastKind() == CK_NoOp)\n        continue;\n      if (ICE->getCastKind() != CK_DerivedToBase &&\n          ICE->getCastKind() != CK_UncheckedDerivedToBase)\n        break;\n      // Walk path backwards as we walk up from the base to the derived class.\n      for (const CXXBaseSpecifier *Elt : llvm::reverse(ICE->path())) {\n        --PathLength;\n        (void)Elt;\n        assert(declaresSameEntity(Elt->getType()->getAsCXXRecordDecl(),\n                                  LHS.Designator.Entries[PathLength]\n                                      .getAsBaseOrMember().getPointer()));\n      }\n\n    //   -- Otherwise, S(E) is empty.\n    } else {\n      break;\n    }\n  }\n\n  // Common case: no unions' lifetimes are started.\n  if (UnionPathLengths.empty())\n    return true;\n\n  //   if modification of X [would access an inactive union member], an object\n  //   of the type of X is implicitly created\n  CompleteObject Obj =\n      findCompleteObject(Info, LHSExpr, AK_Assign, LHS, LHSExpr->getType());\n  if (!Obj)\n    return false;\n  for (std::pair<unsigned, const FieldDecl *> LengthAndField :\n           llvm::reverse(UnionPathLengths)) {\n    // Form a designator for the union object.\n    SubobjectDesignator D = LHS.Designator;\n    D.truncate(Info.Ctx, LHS.Base, LengthAndField.first);\n\n    bool DuringInit = Info.isEvaluatingCtorDtor(LHS.Base, D.Entries) ==\n                      ConstructionPhase::AfterBases;\n    StartLifetimeOfUnionMemberHandler StartLifetime{\n        Info, LHSExpr, LengthAndField.second, DuringInit};\n    if (!findSubobject(Info, LHSExpr, Obj, D, StartLifetime))\n      return false;\n  }\n\n  return true;\n}\n\nstatic bool EvaluateCallArg(const ParmVarDecl *PVD, const Expr *Arg,\n                            CallRef Call, EvalInfo &Info,\n                            bool NonNull = false) {\n  LValue LV;\n  // Create the parameter slot and register its destruction. For a vararg\n  // argument, create a temporary.\n  // FIXME: For calling conventions that destroy parameters in the callee,\n  // should we consider performing destruction when the function returns\n  // instead?\n  APValue &V = PVD ? Info.CurrentCall->createParam(Call, PVD, LV)\n                   : Info.CurrentCall->createTemporary(Arg, Arg->getType(),\n                                                       ScopeKind::Call, LV);\n  if (!EvaluateInPlace(V, Info, LV, Arg))\n    return false;\n\n  // Passing a null pointer to an __attribute__((nonnull)) parameter results in\n  // undefined behavior, so is non-constant.\n  if (NonNull && V.isLValue() && V.isNullPointer()) {\n    Info.CCEDiag(Arg, diag::note_non_null_attribute_failed);\n    return false;\n  }\n\n  return true;\n}\n\n/// Evaluate the arguments to a function call.\nstatic bool EvaluateArgs(ArrayRef<const Expr *> Args, CallRef Call,\n                         EvalInfo &Info, const FunctionDecl *Callee,\n                         bool RightToLeft = false) {\n  bool Success = true;\n  llvm::SmallBitVector ForbiddenNullArgs;\n  if (Callee->hasAttr<NonNullAttr>()) {\n    ForbiddenNullArgs.resize(Args.size());\n    for (const auto *Attr : Callee->specific_attrs<NonNullAttr>()) {\n      if (!Attr->args_size()) {\n        ForbiddenNullArgs.set();\n        break;\n      } else\n        for (auto Idx : Attr->args()) {\n          unsigned ASTIdx = Idx.getASTIndex();\n          if (ASTIdx >= Args.size())\n            continue;\n          ForbiddenNullArgs[ASTIdx] = 1;\n        }\n    }\n  }\n  for (unsigned I = 0; I < Args.size(); I++) {\n    unsigned Idx = RightToLeft ? Args.size() - I - 1 : I;\n    const ParmVarDecl *PVD =\n        Idx < Callee->getNumParams() ? Callee->getParamDecl(Idx) : nullptr;\n    bool NonNull = !ForbiddenNullArgs.empty() && ForbiddenNullArgs[Idx];\n    if (!EvaluateCallArg(PVD, Args[Idx], Call, Info, NonNull)) {\n      // If we're checking for a potential constant expression, evaluate all\n      // initializers even if some of them fail.\n      if (!Info.noteFailure())\n        return false;\n      Success = false;\n    }\n  }\n  return Success;\n}\n\n/// Perform a trivial copy from Param, which is the parameter of a copy or move\n/// constructor or assignment operator.\nstatic bool handleTrivialCopy(EvalInfo &Info, const ParmVarDecl *Param,\n                              const Expr *E, APValue &Result,\n                              bool CopyObjectRepresentation) {\n  // Find the reference argument.\n  CallStackFrame *Frame = Info.CurrentCall;\n  APValue *RefValue = Info.getParamSlot(Frame->Arguments, Param);\n  if (!RefValue) {\n    Info.FFDiag(E);\n    return false;\n  }\n\n  // Copy out the contents of the RHS object.\n  LValue RefLValue;\n  RefLValue.setFrom(Info.Ctx, *RefValue);\n  return handleLValueToRValueConversion(\n      Info, E, Param->getType().getNonReferenceType(), RefLValue, Result,\n      CopyObjectRepresentation);\n}\n\n/// Evaluate a function call.\nstatic bool HandleFunctionCall(SourceLocation CallLoc,\n                               const FunctionDecl *Callee, const LValue *This,\n                               ArrayRef<const Expr *> Args, CallRef Call,\n                               const Stmt *Body, EvalInfo &Info,\n                               APValue &Result, const LValue *ResultSlot) {\n  if (!Info.CheckCallLimit(CallLoc))\n    return false;\n\n  CallStackFrame Frame(Info, CallLoc, Callee, This, Call);\n\n  // For a trivial copy or move assignment, perform an APValue copy. This is\n  // essential for unions, where the operations performed by the assignment\n  // operator cannot be represented as statements.\n  //\n  // Skip this for non-union classes with no fields; in that case, the defaulted\n  // copy/move does not actually read the object.\n  const CXXMethodDecl *MD = dyn_cast<CXXMethodDecl>(Callee);\n  if (MD && MD->isDefaulted() &&\n      (MD->getParent()->isUnion() ||\n       (MD->isTrivial() &&\n        isReadByLvalueToRvalueConversion(MD->getParent())))) {\n    assert(This &&\n           (MD->isCopyAssignmentOperator() || MD->isMoveAssignmentOperator()));\n    APValue RHSValue;\n    if (!handleTrivialCopy(Info, MD->getParamDecl(0), Args[0], RHSValue,\n                           MD->getParent()->isUnion()))\n      return false;\n    if (Info.getLangOpts().CPlusPlus20 && MD->isTrivial() &&\n        !HandleUnionActiveMemberChange(Info, Args[0], *This))\n      return false;\n    if (!handleAssignment(Info, Args[0], *This, MD->getThisType(),\n                          RHSValue))\n      return false;\n    This->moveInto(Result);\n    return true;\n  } else if (MD && isLambdaCallOperator(MD)) {\n    // We're in a lambda; determine the lambda capture field maps unless we're\n    // just constexpr checking a lambda's call operator. constexpr checking is\n    // done before the captures have been added to the closure object (unless\n    // we're inferring constexpr-ness), so we don't have access to them in this\n    // case. But since we don't need the captures to constexpr check, we can\n    // just ignore them.\n    if (!Info.checkingPotentialConstantExpression())\n      MD->getParent()->getCaptureFields(Frame.LambdaCaptureFields,\n                                        Frame.LambdaThisCaptureField);\n  }\n\n  StmtResult Ret = {Result, ResultSlot};\n  EvalStmtResult ESR = EvaluateStmt(Ret, Info, Body);\n  if (ESR == ESR_Succeeded) {\n    if (Callee->getReturnType()->isVoidType())\n      return true;\n    Info.FFDiag(Callee->getEndLoc(), diag::note_constexpr_no_return);\n  }\n  return ESR == ESR_Returned;\n}\n\n/// Evaluate a constructor call.\nstatic bool HandleConstructorCall(const Expr *E, const LValue &This,\n                                  CallRef Call,\n                                  const CXXConstructorDecl *Definition,\n                                  EvalInfo &Info, APValue &Result) {\n  SourceLocation CallLoc = E->getExprLoc();\n  if (!Info.CheckCallLimit(CallLoc))\n    return false;\n\n  const CXXRecordDecl *RD = Definition->getParent();\n  if (RD->getNumVBases()) {\n    Info.FFDiag(CallLoc, diag::note_constexpr_virtual_base) << RD;\n    return false;\n  }\n\n  EvalInfo::EvaluatingConstructorRAII EvalObj(\n      Info,\n      ObjectUnderConstruction{This.getLValueBase(), This.Designator.Entries},\n      RD->getNumBases());\n  CallStackFrame Frame(Info, CallLoc, Definition, &This, Call);\n\n  // FIXME: Creating an APValue just to hold a nonexistent return value is\n  // wasteful.\n  APValue RetVal;\n  StmtResult Ret = {RetVal, nullptr};\n\n  // If it's a delegating constructor, delegate.\n  if (Definition->isDelegatingConstructor()) {\n    CXXConstructorDecl::init_const_iterator I = Definition->init_begin();\n    if ((*I)->getInit()->isValueDependent()) {\n      if (!EvaluateDependentExpr((*I)->getInit(), Info))\n        return false;\n    } else {\n      FullExpressionRAII InitScope(Info);\n      if (!EvaluateInPlace(Result, Info, This, (*I)->getInit()) ||\n          !InitScope.destroy())\n        return false;\n    }\n    return EvaluateStmt(Ret, Info, Definition->getBody()) != ESR_Failed;\n  }\n\n  // For a trivial copy or move constructor, perform an APValue copy. This is\n  // essential for unions (or classes with anonymous union members), where the\n  // operations performed by the constructor cannot be represented by\n  // ctor-initializers.\n  //\n  // Skip this for empty non-union classes; we should not perform an\n  // lvalue-to-rvalue conversion on them because their copy constructor does not\n  // actually read them.\n  if (Definition->isDefaulted() && Definition->isCopyOrMoveConstructor() &&\n      (Definition->getParent()->isUnion() ||\n       (Definition->isTrivial() &&\n        isReadByLvalueToRvalueConversion(Definition->getParent())))) {\n    return handleTrivialCopy(Info, Definition->getParamDecl(0), E, Result,\n                             Definition->getParent()->isUnion());\n  }\n\n  // Reserve space for the struct members.\n  if (!Result.hasValue()) {\n    if (!RD->isUnion())\n      Result = APValue(APValue::UninitStruct(), RD->getNumBases(),\n                       std::distance(RD->field_begin(), RD->field_end()));\n    else\n      // A union starts with no active member.\n      Result = APValue((const FieldDecl*)nullptr);\n  }\n\n  if (RD->isInvalidDecl()) return false;\n  const ASTRecordLayout &Layout = Info.Ctx.getASTRecordLayout(RD);\n\n  // A scope for temporaries lifetime-extended by reference members.\n  BlockScopeRAII LifetimeExtendedScope(Info);\n\n  bool Success = true;\n  unsigned BasesSeen = 0;\n#ifndef NDEBUG\n  CXXRecordDecl::base_class_const_iterator BaseIt = RD->bases_begin();\n#endif\n  CXXRecordDecl::field_iterator FieldIt = RD->field_begin();\n  auto SkipToField = [&](FieldDecl *FD, bool Indirect) {\n    // We might be initializing the same field again if this is an indirect\n    // field initialization.\n    if (FieldIt == RD->field_end() ||\n        FieldIt->getFieldIndex() > FD->getFieldIndex()) {\n      assert(Indirect && \"fields out of order?\");\n      return;\n    }\n\n    // Default-initialize any fields with no explicit initializer.\n    for (; !declaresSameEntity(*FieldIt, FD); ++FieldIt) {\n      assert(FieldIt != RD->field_end() && \"missing field?\");\n      if (!FieldIt->isUnnamedBitfield())\n        Success &= getDefaultInitValue(\n            FieldIt->getType(),\n            Result.getStructField(FieldIt->getFieldIndex()));\n    }\n    ++FieldIt;\n  };\n  for (const auto *I : Definition->inits()) {\n    LValue Subobject = This;\n    LValue SubobjectParent = This;\n    APValue *Value = &Result;\n\n    // Determine the subobject to initialize.\n    FieldDecl *FD = nullptr;\n    if (I->isBaseInitializer()) {\n      QualType BaseType(I->getBaseClass(), 0);\n#ifndef NDEBUG\n      // Non-virtual base classes are initialized in the order in the class\n      // definition. We have already checked for virtual base classes.\n      assert(!BaseIt->isVirtual() && \"virtual base for literal type\");\n      assert(Info.Ctx.hasSameType(BaseIt->getType(), BaseType) &&\n             \"base class initializers not in expected order\");\n      ++BaseIt;\n#endif\n      if (!HandleLValueDirectBase(Info, I->getInit(), Subobject, RD,\n                                  BaseType->getAsCXXRecordDecl(), &Layout))\n        return false;\n      Value = &Result.getStructBase(BasesSeen++);\n    } else if ((FD = I->getMember())) {\n      if (!HandleLValueMember(Info, I->getInit(), Subobject, FD, &Layout))\n        return false;\n      if (RD->isUnion()) {\n        Result = APValue(FD);\n        Value = &Result.getUnionValue();\n      } else {\n        SkipToField(FD, false);\n        Value = &Result.getStructField(FD->getFieldIndex());\n      }\n    } else if (IndirectFieldDecl *IFD = I->getIndirectMember()) {\n      // Walk the indirect field decl's chain to find the object to initialize,\n      // and make sure we've initialized every step along it.\n      auto IndirectFieldChain = IFD->chain();\n      for (auto *C : IndirectFieldChain) {\n        FD = cast<FieldDecl>(C);\n        CXXRecordDecl *CD = cast<CXXRecordDecl>(FD->getParent());\n        // Switch the union field if it differs. This happens if we had\n        // preceding zero-initialization, and we're now initializing a union\n        // subobject other than the first.\n        // FIXME: In this case, the values of the other subobjects are\n        // specified, since zero-initialization sets all padding bits to zero.\n        if (!Value->hasValue() ||\n            (Value->isUnion() && Value->getUnionField() != FD)) {\n          if (CD->isUnion())\n            *Value = APValue(FD);\n          else\n            // FIXME: This immediately starts the lifetime of all members of\n            // an anonymous struct. It would be preferable to strictly start\n            // member lifetime in initialization order.\n            Success &= getDefaultInitValue(Info.Ctx.getRecordType(CD), *Value);\n        }\n        // Store Subobject as its parent before updating it for the last element\n        // in the chain.\n        if (C == IndirectFieldChain.back())\n          SubobjectParent = Subobject;\n        if (!HandleLValueMember(Info, I->getInit(), Subobject, FD))\n          return false;\n        if (CD->isUnion())\n          Value = &Value->getUnionValue();\n        else {\n          if (C == IndirectFieldChain.front() && !RD->isUnion())\n            SkipToField(FD, true);\n          Value = &Value->getStructField(FD->getFieldIndex());\n        }\n      }\n    } else {\n      llvm_unreachable(\"unknown base initializer kind\");\n    }\n\n    // Need to override This for implicit field initializers as in this case\n    // This refers to innermost anonymous struct/union containing initializer,\n    // not to currently constructed class.\n    const Expr *Init = I->getInit();\n    if (Init->isValueDependent()) {\n      if (!EvaluateDependentExpr(Init, Info))\n        return false;\n    } else {\n      ThisOverrideRAII ThisOverride(*Info.CurrentCall, &SubobjectParent,\n                                    isa<CXXDefaultInitExpr>(Init));\n      FullExpressionRAII InitScope(Info);\n      if (!EvaluateInPlace(*Value, Info, Subobject, Init) ||\n          (FD && FD->isBitField() &&\n           !truncateBitfieldValue(Info, Init, *Value, FD))) {\n        // If we're checking for a potential constant expression, evaluate all\n        // initializers even if some of them fail.\n        if (!Info.noteFailure())\n          return false;\n        Success = false;\n      }\n    }\n\n    // This is the point at which the dynamic type of the object becomes this\n    // class type.\n    if (I->isBaseInitializer() && BasesSeen == RD->getNumBases())\n      EvalObj.finishedConstructingBases();\n  }\n\n  // Default-initialize any remaining fields.\n  if (!RD->isUnion()) {\n    for (; FieldIt != RD->field_end(); ++FieldIt) {\n      if (!FieldIt->isUnnamedBitfield())\n        Success &= getDefaultInitValue(\n            FieldIt->getType(),\n            Result.getStructField(FieldIt->getFieldIndex()));\n    }\n  }\n\n  EvalObj.finishedConstructingFields();\n\n  return Success &&\n         EvaluateStmt(Ret, Info, Definition->getBody()) != ESR_Failed &&\n         LifetimeExtendedScope.destroy();\n}\n\nstatic bool HandleConstructorCall(const Expr *E, const LValue &This,\n                                  ArrayRef<const Expr*> Args,\n                                  const CXXConstructorDecl *Definition,\n                                  EvalInfo &Info, APValue &Result) {\n  CallScopeRAII CallScope(Info);\n  CallRef Call = Info.CurrentCall->createCall(Definition);\n  if (!EvaluateArgs(Args, Call, Info, Definition))\n    return false;\n\n  return HandleConstructorCall(E, This, Call, Definition, Info, Result) &&\n         CallScope.destroy();\n}\n\nstatic bool HandleDestructionImpl(EvalInfo &Info, SourceLocation CallLoc,\n                                  const LValue &This, APValue &Value,\n                                  QualType T) {\n  // Objects can only be destroyed while they're within their lifetimes.\n  // FIXME: We have no representation for whether an object of type nullptr_t\n  // is in its lifetime; it usually doesn't matter. Perhaps we should model it\n  // as indeterminate instead?\n  if (Value.isAbsent() && !T->isNullPtrType()) {\n    APValue Printable;\n    This.moveInto(Printable);\n    Info.FFDiag(CallLoc, diag::note_constexpr_destroy_out_of_lifetime)\n      << Printable.getAsString(Info.Ctx, Info.Ctx.getLValueReferenceType(T));\n    return false;\n  }\n\n  // Invent an expression for location purposes.\n  // FIXME: We shouldn't need to do this.\n  OpaqueValueExpr LocE(CallLoc, Info.Ctx.IntTy, VK_RValue);\n\n  // For arrays, destroy elements right-to-left.\n  if (const ConstantArrayType *CAT = Info.Ctx.getAsConstantArrayType(T)) {\n    uint64_t Size = CAT->getSize().getZExtValue();\n    QualType ElemT = CAT->getElementType();\n\n    LValue ElemLV = This;\n    ElemLV.addArray(Info, &LocE, CAT);\n    if (!HandleLValueArrayAdjustment(Info, &LocE, ElemLV, ElemT, Size))\n      return false;\n\n    // Ensure that we have actual array elements available to destroy; the\n    // destructors might mutate the value, so we can't run them on the array\n    // filler.\n    if (Size && Size > Value.getArrayInitializedElts())\n      expandArray(Value, Value.getArraySize() - 1);\n\n    for (; Size != 0; --Size) {\n      APValue &Elem = Value.getArrayInitializedElt(Size - 1);\n      if (!HandleLValueArrayAdjustment(Info, &LocE, ElemLV, ElemT, -1) ||\n          !HandleDestructionImpl(Info, CallLoc, ElemLV, Elem, ElemT))\n        return false;\n    }\n\n    // End the lifetime of this array now.\n    Value = APValue();\n    return true;\n  }\n\n  const CXXRecordDecl *RD = T->getAsCXXRecordDecl();\n  if (!RD) {\n    if (T.isDestructedType()) {\n      Info.FFDiag(CallLoc, diag::note_constexpr_unsupported_destruction) << T;\n      return false;\n    }\n\n    Value = APValue();\n    return true;\n  }\n\n  if (RD->getNumVBases()) {\n    Info.FFDiag(CallLoc, diag::note_constexpr_virtual_base) << RD;\n    return false;\n  }\n\n  const CXXDestructorDecl *DD = RD->getDestructor();\n  if (!DD && !RD->hasTrivialDestructor()) {\n    Info.FFDiag(CallLoc);\n    return false;\n  }\n\n  if (!DD || DD->isTrivial() ||\n      (RD->isAnonymousStructOrUnion() && RD->isUnion())) {\n    // A trivial destructor just ends the lifetime of the object. Check for\n    // this case before checking for a body, because we might not bother\n    // building a body for a trivial destructor. Note that it doesn't matter\n    // whether the destructor is constexpr in this case; all trivial\n    // destructors are constexpr.\n    //\n    // If an anonymous union would be destroyed, some enclosing destructor must\n    // have been explicitly defined, and the anonymous union destruction should\n    // have no effect.\n    Value = APValue();\n    return true;\n  }\n\n  if (!Info.CheckCallLimit(CallLoc))\n    return false;\n\n  const FunctionDecl *Definition = nullptr;\n  const Stmt *Body = DD->getBody(Definition);\n\n  if (!CheckConstexprFunction(Info, CallLoc, DD, Definition, Body))\n    return false;\n\n  CallStackFrame Frame(Info, CallLoc, Definition, &This, CallRef());\n\n  // We're now in the period of destruction of this object.\n  unsigned BasesLeft = RD->getNumBases();\n  EvalInfo::EvaluatingDestructorRAII EvalObj(\n      Info,\n      ObjectUnderConstruction{This.getLValueBase(), This.Designator.Entries});\n  if (!EvalObj.DidInsert) {\n    // C++2a [class.dtor]p19:\n    //   the behavior is undefined if the destructor is invoked for an object\n    //   whose lifetime has ended\n    // (Note that formally the lifetime ends when the period of destruction\n    // begins, even though certain uses of the object remain valid until the\n    // period of destruction ends.)\n    Info.FFDiag(CallLoc, diag::note_constexpr_double_destroy);\n    return false;\n  }\n\n  // FIXME: Creating an APValue just to hold a nonexistent return value is\n  // wasteful.\n  APValue RetVal;\n  StmtResult Ret = {RetVal, nullptr};\n  if (EvaluateStmt(Ret, Info, Definition->getBody()) == ESR_Failed)\n    return false;\n\n  // A union destructor does not implicitly destroy its members.\n  if (RD->isUnion())\n    return true;\n\n  const ASTRecordLayout &Layout = Info.Ctx.getASTRecordLayout(RD);\n\n  // We don't have a good way to iterate fields in reverse, so collect all the\n  // fields first and then walk them backwards.\n  SmallVector<FieldDecl*, 16> Fields(RD->field_begin(), RD->field_end());\n  for (const FieldDecl *FD : llvm::reverse(Fields)) {\n    if (FD->isUnnamedBitfield())\n      continue;\n\n    LValue Subobject = This;\n    if (!HandleLValueMember(Info, &LocE, Subobject, FD, &Layout))\n      return false;\n\n    APValue *SubobjectValue = &Value.getStructField(FD->getFieldIndex());\n    if (!HandleDestructionImpl(Info, CallLoc, Subobject, *SubobjectValue,\n                               FD->getType()))\n      return false;\n  }\n\n  if (BasesLeft != 0)\n    EvalObj.startedDestroyingBases();\n\n  // Destroy base classes in reverse order.\n  for (const CXXBaseSpecifier &Base : llvm::reverse(RD->bases())) {\n    --BasesLeft;\n\n    QualType BaseType = Base.getType();\n    LValue Subobject = This;\n    if (!HandleLValueDirectBase(Info, &LocE, Subobject, RD,\n                                BaseType->getAsCXXRecordDecl(), &Layout))\n      return false;\n\n    APValue *SubobjectValue = &Value.getStructBase(BasesLeft);\n    if (!HandleDestructionImpl(Info, CallLoc, Subobject, *SubobjectValue,\n                               BaseType))\n      return false;\n  }\n  assert(BasesLeft == 0 && \"NumBases was wrong?\");\n\n  // The period of destruction ends now. The object is gone.\n  Value = APValue();\n  return true;\n}\n\nnamespace {\nstruct DestroyObjectHandler {\n  EvalInfo &Info;\n  const Expr *E;\n  const LValue &This;\n  const AccessKinds AccessKind;\n\n  typedef bool result_type;\n  bool failed() { return false; }\n  bool found(APValue &Subobj, QualType SubobjType) {\n    return HandleDestructionImpl(Info, E->getExprLoc(), This, Subobj,\n                                 SubobjType);\n  }\n  bool found(APSInt &Value, QualType SubobjType) {\n    Info.FFDiag(E, diag::note_constexpr_destroy_complex_elem);\n    return false;\n  }\n  bool found(APFloat &Value, QualType SubobjType) {\n    Info.FFDiag(E, diag::note_constexpr_destroy_complex_elem);\n    return false;\n  }\n};\n}\n\n/// Perform a destructor or pseudo-destructor call on the given object, which\n/// might in general not be a complete object.\nstatic bool HandleDestruction(EvalInfo &Info, const Expr *E,\n                              const LValue &This, QualType ThisType) {\n  CompleteObject Obj = findCompleteObject(Info, E, AK_Destroy, This, ThisType);\n  DestroyObjectHandler Handler = {Info, E, This, AK_Destroy};\n  return Obj && findSubobject(Info, E, Obj, This.Designator, Handler);\n}\n\n/// Destroy and end the lifetime of the given complete object.\nstatic bool HandleDestruction(EvalInfo &Info, SourceLocation Loc,\n                              APValue::LValueBase LVBase, APValue &Value,\n                              QualType T) {\n  // If we've had an unmodeled side-effect, we can't rely on mutable state\n  // (such as the object we're about to destroy) being correct.\n  if (Info.EvalStatus.HasSideEffects)\n    return false;\n\n  LValue LV;\n  LV.set({LVBase});\n  return HandleDestructionImpl(Info, Loc, LV, Value, T);\n}\n\n/// Perform a call to 'perator new' or to `__builtin_operator_new'.\nstatic bool HandleOperatorNewCall(EvalInfo &Info, const CallExpr *E,\n                                  LValue &Result) {\n  if (Info.checkingPotentialConstantExpression() ||\n      Info.SpeculativeEvaluationDepth)\n    return false;\n\n  // This is permitted only within a call to std::allocator<T>::allocate.\n  auto Caller = Info.getStdAllocatorCaller(\"allocate\");\n  if (!Caller) {\n    Info.FFDiag(E->getExprLoc(), Info.getLangOpts().CPlusPlus20\n                                     ? diag::note_constexpr_new_untyped\n                                     : diag::note_constexpr_new);\n    return false;\n  }\n\n  QualType ElemType = Caller.ElemType;\n  if (ElemType->isIncompleteType() || ElemType->isFunctionType()) {\n    Info.FFDiag(E->getExprLoc(),\n                diag::note_constexpr_new_not_complete_object_type)\n        << (ElemType->isIncompleteType() ? 0 : 1) << ElemType;\n    return false;\n  }\n\n  APSInt ByteSize;\n  if (!EvaluateInteger(E->getArg(0), ByteSize, Info))\n    return false;\n  bool IsNothrow = false;\n  for (unsigned I = 1, N = E->getNumArgs(); I != N; ++I) {\n    EvaluateIgnoredValue(Info, E->getArg(I));\n    IsNothrow |= E->getType()->isNothrowT();\n  }\n\n  CharUnits ElemSize;\n  if (!HandleSizeof(Info, E->getExprLoc(), ElemType, ElemSize))\n    return false;\n  APInt Size, Remainder;\n  APInt ElemSizeAP(ByteSize.getBitWidth(), ElemSize.getQuantity());\n  APInt::udivrem(ByteSize, ElemSizeAP, Size, Remainder);\n  if (Remainder != 0) {\n    // This likely indicates a bug in the implementation of 'std::allocator'.\n    Info.FFDiag(E->getExprLoc(), diag::note_constexpr_operator_new_bad_size)\n        << ByteSize << APSInt(ElemSizeAP, true) << ElemType;\n    return false;\n  }\n\n  if (ByteSize.getActiveBits() > ConstantArrayType::getMaxSizeBits(Info.Ctx)) {\n    if (IsNothrow) {\n      Result.setNull(Info.Ctx, E->getType());\n      return true;\n    }\n\n    Info.FFDiag(E, diag::note_constexpr_new_too_large) << APSInt(Size, true);\n    return false;\n  }\n\n  QualType AllocType = Info.Ctx.getConstantArrayType(ElemType, Size, nullptr,\n                                                     ArrayType::Normal, 0);\n  APValue *Val = Info.createHeapAlloc(E, AllocType, Result);\n  *Val = APValue(APValue::UninitArray(), 0, Size.getZExtValue());\n  Result.addArray(Info, E, cast<ConstantArrayType>(AllocType));\n  return true;\n}\n\nstatic bool hasVirtualDestructor(QualType T) {\n  if (CXXRecordDecl *RD = T->getAsCXXRecordDecl())\n    if (CXXDestructorDecl *DD = RD->getDestructor())\n      return DD->isVirtual();\n  return false;\n}\n\nstatic const FunctionDecl *getVirtualOperatorDelete(QualType T) {\n  if (CXXRecordDecl *RD = T->getAsCXXRecordDecl())\n    if (CXXDestructorDecl *DD = RD->getDestructor())\n      return DD->isVirtual() ? DD->getOperatorDelete() : nullptr;\n  return nullptr;\n}\n\n/// Check that the given object is a suitable pointer to a heap allocation that\n/// still exists and is of the right kind for the purpose of a deletion.\n///\n/// On success, returns the heap allocation to deallocate. On failure, produces\n/// a diagnostic and returns None.\nstatic Optional<DynAlloc *> CheckDeleteKind(EvalInfo &Info, const Expr *E,\n                                            const LValue &Pointer,\n                                            DynAlloc::Kind DeallocKind) {\n  auto PointerAsString = [&] {\n    return Pointer.toString(Info.Ctx, Info.Ctx.VoidPtrTy);\n  };\n\n  DynamicAllocLValue DA = Pointer.Base.dyn_cast<DynamicAllocLValue>();\n  if (!DA) {\n    Info.FFDiag(E, diag::note_constexpr_delete_not_heap_alloc)\n        << PointerAsString();\n    if (Pointer.Base)\n      NoteLValueLocation(Info, Pointer.Base);\n    return None;\n  }\n\n  Optional<DynAlloc *> Alloc = Info.lookupDynamicAlloc(DA);\n  if (!Alloc) {\n    Info.FFDiag(E, diag::note_constexpr_double_delete);\n    return None;\n  }\n\n  QualType AllocType = Pointer.Base.getDynamicAllocType();\n  if (DeallocKind != (*Alloc)->getKind()) {\n    Info.FFDiag(E, diag::note_constexpr_new_delete_mismatch)\n        << DeallocKind << (*Alloc)->getKind() << AllocType;\n    NoteLValueLocation(Info, Pointer.Base);\n    return None;\n  }\n\n  bool Subobject = false;\n  if (DeallocKind == DynAlloc::New) {\n    Subobject = Pointer.Designator.MostDerivedPathLength != 0 ||\n                Pointer.Designator.isOnePastTheEnd();\n  } else {\n    Subobject = Pointer.Designator.Entries.size() != 1 ||\n                Pointer.Designator.Entries[0].getAsArrayIndex() != 0;\n  }\n  if (Subobject) {\n    Info.FFDiag(E, diag::note_constexpr_delete_subobject)\n        << PointerAsString() << Pointer.Designator.isOnePastTheEnd();\n    return None;\n  }\n\n  return Alloc;\n}\n\n// Perform a call to 'operator delete' or '__builtin_operator_delete'.\nbool HandleOperatorDeleteCall(EvalInfo &Info, const CallExpr *E) {\n  if (Info.checkingPotentialConstantExpression() ||\n      Info.SpeculativeEvaluationDepth)\n    return false;\n\n  // This is permitted only within a call to std::allocator<T>::deallocate.\n  if (!Info.getStdAllocatorCaller(\"deallocate\")) {\n    Info.FFDiag(E->getExprLoc());\n    return true;\n  }\n\n  LValue Pointer;\n  if (!EvaluatePointer(E->getArg(0), Pointer, Info))\n    return false;\n  for (unsigned I = 1, N = E->getNumArgs(); I != N; ++I)\n    EvaluateIgnoredValue(Info, E->getArg(I));\n\n  if (Pointer.Designator.Invalid)\n    return false;\n\n  // Deleting a null pointer would have no effect, but it's not permitted by\n  // std::allocator<T>::deallocate's contract.\n  if (Pointer.isNullPointer()) {\n    Info.CCEDiag(E->getExprLoc(), diag::note_constexpr_deallocate_null);\n    return true;\n  }\n\n  if (!CheckDeleteKind(Info, E, Pointer, DynAlloc::StdAllocator))\n    return false;\n\n  Info.HeapAllocs.erase(Pointer.Base.get<DynamicAllocLValue>());\n  return true;\n}\n\n//===----------------------------------------------------------------------===//\n// Generic Evaluation\n//===----------------------------------------------------------------------===//\nnamespace {\n\nclass BitCastBuffer {\n  // FIXME: We're going to need bit-level granularity when we support\n  // bit-fields.\n  // FIXME: Its possible under the C++ standard for 'char' to not be 8 bits, but\n  // we don't support a host or target where that is the case. Still, we should\n  // use a more generic type in case we ever do.\n  SmallVector<Optional<unsigned char>, 32> Bytes;\n\n  static_assert(std::numeric_limits<unsigned char>::digits >= 8,\n                \"Need at least 8 bit unsigned char\");\n\n  bool TargetIsLittleEndian;\n\npublic:\n  BitCastBuffer(CharUnits Width, bool TargetIsLittleEndian)\n      : Bytes(Width.getQuantity()),\n        TargetIsLittleEndian(TargetIsLittleEndian) {}\n\n  LLVM_NODISCARD\n  bool readObject(CharUnits Offset, CharUnits Width,\n                  SmallVectorImpl<unsigned char> &Output) const {\n    for (CharUnits I = Offset, E = Offset + Width; I != E; ++I) {\n      // If a byte of an integer is uninitialized, then the whole integer is\n      // uninitalized.\n      if (!Bytes[I.getQuantity()])\n        return false;\n      Output.push_back(*Bytes[I.getQuantity()]);\n    }\n    if (llvm::sys::IsLittleEndianHost != TargetIsLittleEndian)\n      std::reverse(Output.begin(), Output.end());\n    return true;\n  }\n\n  void writeObject(CharUnits Offset, SmallVectorImpl<unsigned char> &Input) {\n    if (llvm::sys::IsLittleEndianHost != TargetIsLittleEndian)\n      std::reverse(Input.begin(), Input.end());\n\n    size_t Index = 0;\n    for (unsigned char Byte : Input) {\n      assert(!Bytes[Offset.getQuantity() + Index] && \"overwriting a byte?\");\n      Bytes[Offset.getQuantity() + Index] = Byte;\n      ++Index;\n    }\n  }\n\n  size_t size() { return Bytes.size(); }\n};\n\n/// Traverse an APValue to produce an BitCastBuffer, emulating how the current\n/// target would represent the value at runtime.\nclass APValueToBufferConverter {\n  EvalInfo &Info;\n  BitCastBuffer Buffer;\n  const CastExpr *BCE;\n\n  APValueToBufferConverter(EvalInfo &Info, CharUnits ObjectWidth,\n                           const CastExpr *BCE)\n      : Info(Info),\n        Buffer(ObjectWidth, Info.Ctx.getTargetInfo().isLittleEndian()),\n        BCE(BCE) {}\n\n  bool visit(const APValue &Val, QualType Ty) {\n    return visit(Val, Ty, CharUnits::fromQuantity(0));\n  }\n\n  // Write out Val with type Ty into Buffer starting at Offset.\n  bool visit(const APValue &Val, QualType Ty, CharUnits Offset) {\n    assert((size_t)Offset.getQuantity() <= Buffer.size());\n\n    // As a special case, nullptr_t has an indeterminate value.\n    if (Ty->isNullPtrType())\n      return true;\n\n    // Dig through Src to find the byte at SrcOffset.\n    switch (Val.getKind()) {\n    case APValue::Indeterminate:\n    case APValue::None:\n      return true;\n\n    case APValue::Int:\n      return visitInt(Val.getInt(), Ty, Offset);\n    case APValue::Float:\n      return visitFloat(Val.getFloat(), Ty, Offset);\n    case APValue::Array:\n      return visitArray(Val, Ty, Offset);\n    case APValue::Struct:\n      return visitRecord(Val, Ty, Offset);\n\n    case APValue::ComplexInt:\n    case APValue::ComplexFloat:\n    case APValue::Vector:\n    case APValue::FixedPoint:\n      // FIXME: We should support these.\n\n    case APValue::Union:\n    case APValue::MemberPointer:\n    case APValue::AddrLabelDiff: {\n      Info.FFDiag(BCE->getBeginLoc(),\n                  diag::note_constexpr_bit_cast_unsupported_type)\n          << Ty;\n      return false;\n    }\n\n    case APValue::LValue:\n      llvm_unreachable(\"LValue subobject in bit_cast?\");\n    }\n    llvm_unreachable(\"Unhandled APValue::ValueKind\");\n  }\n\n  bool visitRecord(const APValue &Val, QualType Ty, CharUnits Offset) {\n    const RecordDecl *RD = Ty->getAsRecordDecl();\n    const ASTRecordLayout &Layout = Info.Ctx.getASTRecordLayout(RD);\n\n    // Visit the base classes.\n    if (auto *CXXRD = dyn_cast<CXXRecordDecl>(RD)) {\n      for (size_t I = 0, E = CXXRD->getNumBases(); I != E; ++I) {\n        const CXXBaseSpecifier &BS = CXXRD->bases_begin()[I];\n        CXXRecordDecl *BaseDecl = BS.getType()->getAsCXXRecordDecl();\n\n        if (!visitRecord(Val.getStructBase(I), BS.getType(),\n                         Layout.getBaseClassOffset(BaseDecl) + Offset))\n          return false;\n      }\n    }\n\n    // Visit the fields.\n    unsigned FieldIdx = 0;\n    for (FieldDecl *FD : RD->fields()) {\n      if (FD->isBitField()) {\n        Info.FFDiag(BCE->getBeginLoc(),\n                    diag::note_constexpr_bit_cast_unsupported_bitfield);\n        return false;\n      }\n\n      uint64_t FieldOffsetBits = Layout.getFieldOffset(FieldIdx);\n\n      assert(FieldOffsetBits % Info.Ctx.getCharWidth() == 0 &&\n             \"only bit-fields can have sub-char alignment\");\n      CharUnits FieldOffset =\n          Info.Ctx.toCharUnitsFromBits(FieldOffsetBits) + Offset;\n      QualType FieldTy = FD->getType();\n      if (!visit(Val.getStructField(FieldIdx), FieldTy, FieldOffset))\n        return false;\n      ++FieldIdx;\n    }\n\n    return true;\n  }\n\n  bool visitArray(const APValue &Val, QualType Ty, CharUnits Offset) {\n    const auto *CAT =\n        dyn_cast_or_null<ConstantArrayType>(Ty->getAsArrayTypeUnsafe());\n    if (!CAT)\n      return false;\n\n    CharUnits ElemWidth = Info.Ctx.getTypeSizeInChars(CAT->getElementType());\n    unsigned NumInitializedElts = Val.getArrayInitializedElts();\n    unsigned ArraySize = Val.getArraySize();\n    // First, initialize the initialized elements.\n    for (unsigned I = 0; I != NumInitializedElts; ++I) {\n      const APValue &SubObj = Val.getArrayInitializedElt(I);\n      if (!visit(SubObj, CAT->getElementType(), Offset + I * ElemWidth))\n        return false;\n    }\n\n    // Next, initialize the rest of the array using the filler.\n    if (Val.hasArrayFiller()) {\n      const APValue &Filler = Val.getArrayFiller();\n      for (unsigned I = NumInitializedElts; I != ArraySize; ++I) {\n        if (!visit(Filler, CAT->getElementType(), Offset + I * ElemWidth))\n          return false;\n      }\n    }\n\n    return true;\n  }\n\n  bool visitInt(const APSInt &Val, QualType Ty, CharUnits Offset) {\n    APSInt AdjustedVal = Val;\n    unsigned Width = AdjustedVal.getBitWidth();\n    if (Ty->isBooleanType()) {\n      Width = Info.Ctx.getTypeSize(Ty);\n      AdjustedVal = AdjustedVal.extend(Width);\n    }\n\n    SmallVector<unsigned char, 8> Bytes(Width / 8);\n    llvm::StoreIntToMemory(AdjustedVal, &*Bytes.begin(), Width / 8);\n    Buffer.writeObject(Offset, Bytes);\n    return true;\n  }\n\n  bool visitFloat(const APFloat &Val, QualType Ty, CharUnits Offset) {\n    APSInt AsInt(Val.bitcastToAPInt());\n    return visitInt(AsInt, Ty, Offset);\n  }\n\npublic:\n  static Optional<BitCastBuffer> convert(EvalInfo &Info, const APValue &Src,\n                                         const CastExpr *BCE) {\n    CharUnits DstSize = Info.Ctx.getTypeSizeInChars(BCE->getType());\n    APValueToBufferConverter Converter(Info, DstSize, BCE);\n    if (!Converter.visit(Src, BCE->getSubExpr()->getType()))\n      return None;\n    return Converter.Buffer;\n  }\n};\n\n/// Write an BitCastBuffer into an APValue.\nclass BufferToAPValueConverter {\n  EvalInfo &Info;\n  const BitCastBuffer &Buffer;\n  const CastExpr *BCE;\n\n  BufferToAPValueConverter(EvalInfo &Info, const BitCastBuffer &Buffer,\n                           const CastExpr *BCE)\n      : Info(Info), Buffer(Buffer), BCE(BCE) {}\n\n  // Emit an unsupported bit_cast type error. Sema refuses to build a bit_cast\n  // with an invalid type, so anything left is a deficiency on our part (FIXME).\n  // Ideally this will be unreachable.\n  llvm::NoneType unsupportedType(QualType Ty) {\n    Info.FFDiag(BCE->getBeginLoc(),\n                diag::note_constexpr_bit_cast_unsupported_type)\n        << Ty;\n    return None;\n  }\n\n  llvm::NoneType unrepresentableValue(QualType Ty, const APSInt &Val) {\n    Info.FFDiag(BCE->getBeginLoc(),\n                diag::note_constexpr_bit_cast_unrepresentable_value)\n        << Ty << Val.toString(/*Radix=*/10);\n    return None;\n  }\n\n  Optional<APValue> visit(const BuiltinType *T, CharUnits Offset,\n                          const EnumType *EnumSugar = nullptr) {\n    if (T->isNullPtrType()) {\n      uint64_t NullValue = Info.Ctx.getTargetNullPointerValue(QualType(T, 0));\n      return APValue((Expr *)nullptr,\n                     /*Offset=*/CharUnits::fromQuantity(NullValue),\n                     APValue::NoLValuePath{}, /*IsNullPtr=*/true);\n    }\n\n    CharUnits SizeOf = Info.Ctx.getTypeSizeInChars(T);\n\n    // Work around floating point types that contain unused padding bytes. This\n    // is really just `long double` on x86, which is the only fundamental type\n    // with padding bytes.\n    if (T->isRealFloatingType()) {\n      const llvm::fltSemantics &Semantics =\n          Info.Ctx.getFloatTypeSemantics(QualType(T, 0));\n      unsigned NumBits = llvm::APFloatBase::getSizeInBits(Semantics);\n      assert(NumBits % 8 == 0);\n      CharUnits NumBytes = CharUnits::fromQuantity(NumBits / 8);\n      if (NumBytes != SizeOf)\n        SizeOf = NumBytes;\n    }\n\n    SmallVector<uint8_t, 8> Bytes;\n    if (!Buffer.readObject(Offset, SizeOf, Bytes)) {\n      // If this is std::byte or unsigned char, then its okay to store an\n      // indeterminate value.\n      bool IsStdByte = EnumSugar && EnumSugar->isStdByteType();\n      bool IsUChar =\n          !EnumSugar && (T->isSpecificBuiltinType(BuiltinType::UChar) ||\n                         T->isSpecificBuiltinType(BuiltinType::Char_U));\n      if (!IsStdByte && !IsUChar) {\n        QualType DisplayType(EnumSugar ? (const Type *)EnumSugar : T, 0);\n        Info.FFDiag(BCE->getExprLoc(),\n                    diag::note_constexpr_bit_cast_indet_dest)\n            << DisplayType << Info.Ctx.getLangOpts().CharIsSigned;\n        return None;\n      }\n\n      return APValue::IndeterminateValue();\n    }\n\n    APSInt Val(SizeOf.getQuantity() * Info.Ctx.getCharWidth(), true);\n    llvm::LoadIntFromMemory(Val, &*Bytes.begin(), Bytes.size());\n\n    if (T->isIntegralOrEnumerationType()) {\n      Val.setIsSigned(T->isSignedIntegerOrEnumerationType());\n\n      unsigned IntWidth = Info.Ctx.getIntWidth(QualType(T, 0));\n      if (IntWidth != Val.getBitWidth()) {\n        APSInt Truncated = Val.trunc(IntWidth);\n        if (Truncated.extend(Val.getBitWidth()) != Val)\n          return unrepresentableValue(QualType(T, 0), Val);\n        Val = Truncated;\n      }\n\n      return APValue(Val);\n    }\n\n    if (T->isRealFloatingType()) {\n      const llvm::fltSemantics &Semantics =\n          Info.Ctx.getFloatTypeSemantics(QualType(T, 0));\n      return APValue(APFloat(Semantics, Val));\n    }\n\n    return unsupportedType(QualType(T, 0));\n  }\n\n  Optional<APValue> visit(const RecordType *RTy, CharUnits Offset) {\n    const RecordDecl *RD = RTy->getAsRecordDecl();\n    const ASTRecordLayout &Layout = Info.Ctx.getASTRecordLayout(RD);\n\n    unsigned NumBases = 0;\n    if (auto *CXXRD = dyn_cast<CXXRecordDecl>(RD))\n      NumBases = CXXRD->getNumBases();\n\n    APValue ResultVal(APValue::UninitStruct(), NumBases,\n                      std::distance(RD->field_begin(), RD->field_end()));\n\n    // Visit the base classes.\n    if (auto *CXXRD = dyn_cast<CXXRecordDecl>(RD)) {\n      for (size_t I = 0, E = CXXRD->getNumBases(); I != E; ++I) {\n        const CXXBaseSpecifier &BS = CXXRD->bases_begin()[I];\n        CXXRecordDecl *BaseDecl = BS.getType()->getAsCXXRecordDecl();\n        if (BaseDecl->isEmpty() ||\n            Info.Ctx.getASTRecordLayout(BaseDecl).getNonVirtualSize().isZero())\n          continue;\n\n        Optional<APValue> SubObj = visitType(\n            BS.getType(), Layout.getBaseClassOffset(BaseDecl) + Offset);\n        if (!SubObj)\n          return None;\n        ResultVal.getStructBase(I) = *SubObj;\n      }\n    }\n\n    // Visit the fields.\n    unsigned FieldIdx = 0;\n    for (FieldDecl *FD : RD->fields()) {\n      // FIXME: We don't currently support bit-fields. A lot of the logic for\n      // this is in CodeGen, so we need to factor it around.\n      if (FD->isBitField()) {\n        Info.FFDiag(BCE->getBeginLoc(),\n                    diag::note_constexpr_bit_cast_unsupported_bitfield);\n        return None;\n      }\n\n      uint64_t FieldOffsetBits = Layout.getFieldOffset(FieldIdx);\n      assert(FieldOffsetBits % Info.Ctx.getCharWidth() == 0);\n\n      CharUnits FieldOffset =\n          CharUnits::fromQuantity(FieldOffsetBits / Info.Ctx.getCharWidth()) +\n          Offset;\n      QualType FieldTy = FD->getType();\n      Optional<APValue> SubObj = visitType(FieldTy, FieldOffset);\n      if (!SubObj)\n        return None;\n      ResultVal.getStructField(FieldIdx) = *SubObj;\n      ++FieldIdx;\n    }\n\n    return ResultVal;\n  }\n\n  Optional<APValue> visit(const EnumType *Ty, CharUnits Offset) {\n    QualType RepresentationType = Ty->getDecl()->getIntegerType();\n    assert(!RepresentationType.isNull() &&\n           \"enum forward decl should be caught by Sema\");\n    const auto *AsBuiltin =\n        RepresentationType.getCanonicalType()->castAs<BuiltinType>();\n    // Recurse into the underlying type. Treat std::byte transparently as\n    // unsigned char.\n    return visit(AsBuiltin, Offset, /*EnumTy=*/Ty);\n  }\n\n  Optional<APValue> visit(const ConstantArrayType *Ty, CharUnits Offset) {\n    size_t Size = Ty->getSize().getLimitedValue();\n    CharUnits ElementWidth = Info.Ctx.getTypeSizeInChars(Ty->getElementType());\n\n    APValue ArrayValue(APValue::UninitArray(), Size, Size);\n    for (size_t I = 0; I != Size; ++I) {\n      Optional<APValue> ElementValue =\n          visitType(Ty->getElementType(), Offset + I * ElementWidth);\n      if (!ElementValue)\n        return None;\n      ArrayValue.getArrayInitializedElt(I) = std::move(*ElementValue);\n    }\n\n    return ArrayValue;\n  }\n\n  Optional<APValue> visit(const Type *Ty, CharUnits Offset) {\n    return unsupportedType(QualType(Ty, 0));\n  }\n\n  Optional<APValue> visitType(QualType Ty, CharUnits Offset) {\n    QualType Can = Ty.getCanonicalType();\n\n    switch (Can->getTypeClass()) {\n#define TYPE(Class, Base)                                                      \\\n  case Type::Class:                                                            \\\n    return visit(cast<Class##Type>(Can.getTypePtr()), Offset);\n#define ABSTRACT_TYPE(Class, Base)\n#define NON_CANONICAL_TYPE(Class, Base)                                        \\\n  case Type::Class:                                                            \\\n    llvm_unreachable(\"non-canonical type should be impossible!\");\n#define DEPENDENT_TYPE(Class, Base)                                            \\\n  case Type::Class:                                                            \\\n    llvm_unreachable(                                                          \\\n        \"dependent types aren't supported in the constant evaluator!\");\n#define NON_CANONICAL_UNLESS_DEPENDENT(Class, Base)                            \\\n  case Type::Class:                                                            \\\n    llvm_unreachable(\"either dependent or not canonical!\");\n#include \"clang/AST/TypeNodes.inc\"\n    }\n    llvm_unreachable(\"Unhandled Type::TypeClass\");\n  }\n\npublic:\n  // Pull out a full value of type DstType.\n  static Optional<APValue> convert(EvalInfo &Info, BitCastBuffer &Buffer,\n                                   const CastExpr *BCE) {\n    BufferToAPValueConverter Converter(Info, Buffer, BCE);\n    return Converter.visitType(BCE->getType(), CharUnits::fromQuantity(0));\n  }\n};\n\nstatic bool checkBitCastConstexprEligibilityType(SourceLocation Loc,\n                                                 QualType Ty, EvalInfo *Info,\n                                                 const ASTContext &Ctx,\n                                                 bool CheckingDest) {\n  Ty = Ty.getCanonicalType();\n\n  auto diag = [&](int Reason) {\n    if (Info)\n      Info->FFDiag(Loc, diag::note_constexpr_bit_cast_invalid_type)\n          << CheckingDest << (Reason == 4) << Reason;\n    return false;\n  };\n  auto note = [&](int Construct, QualType NoteTy, SourceLocation NoteLoc) {\n    if (Info)\n      Info->Note(NoteLoc, diag::note_constexpr_bit_cast_invalid_subtype)\n          << NoteTy << Construct << Ty;\n    return false;\n  };\n\n  if (Ty->isUnionType())\n    return diag(0);\n  if (Ty->isPointerType())\n    return diag(1);\n  if (Ty->isMemberPointerType())\n    return diag(2);\n  if (Ty.isVolatileQualified())\n    return diag(3);\n\n  if (RecordDecl *Record = Ty->getAsRecordDecl()) {\n    if (auto *CXXRD = dyn_cast<CXXRecordDecl>(Record)) {\n      for (CXXBaseSpecifier &BS : CXXRD->bases())\n        if (!checkBitCastConstexprEligibilityType(Loc, BS.getType(), Info, Ctx,\n                                                  CheckingDest))\n          return note(1, BS.getType(), BS.getBeginLoc());\n    }\n    for (FieldDecl *FD : Record->fields()) {\n      if (FD->getType()->isReferenceType())\n        return diag(4);\n      if (!checkBitCastConstexprEligibilityType(Loc, FD->getType(), Info, Ctx,\n                                                CheckingDest))\n        return note(0, FD->getType(), FD->getBeginLoc());\n    }\n  }\n\n  if (Ty->isArrayType() &&\n      !checkBitCastConstexprEligibilityType(Loc, Ctx.getBaseElementType(Ty),\n                                            Info, Ctx, CheckingDest))\n    return false;\n\n  return true;\n}\n\nstatic bool checkBitCastConstexprEligibility(EvalInfo *Info,\n                                             const ASTContext &Ctx,\n                                             const CastExpr *BCE) {\n  bool DestOK = checkBitCastConstexprEligibilityType(\n      BCE->getBeginLoc(), BCE->getType(), Info, Ctx, true);\n  bool SourceOK = DestOK && checkBitCastConstexprEligibilityType(\n                                BCE->getBeginLoc(),\n                                BCE->getSubExpr()->getType(), Info, Ctx, false);\n  return SourceOK;\n}\n\nstatic bool handleLValueToRValueBitCast(EvalInfo &Info, APValue &DestValue,\n                                        APValue &SourceValue,\n                                        const CastExpr *BCE) {\n  assert(CHAR_BIT == 8 && Info.Ctx.getTargetInfo().getCharWidth() == 8 &&\n         \"no host or target supports non 8-bit chars\");\n  assert(SourceValue.isLValue() &&\n         \"LValueToRValueBitcast requires an lvalue operand!\");\n\n  if (!checkBitCastConstexprEligibility(&Info, Info.Ctx, BCE))\n    return false;\n\n  LValue SourceLValue;\n  APValue SourceRValue;\n  SourceLValue.setFrom(Info.Ctx, SourceValue);\n  if (!handleLValueToRValueConversion(\n          Info, BCE, BCE->getSubExpr()->getType().withConst(), SourceLValue,\n          SourceRValue, /*WantObjectRepresentation=*/true))\n    return false;\n\n  // Read out SourceValue into a char buffer.\n  Optional<BitCastBuffer> Buffer =\n      APValueToBufferConverter::convert(Info, SourceRValue, BCE);\n  if (!Buffer)\n    return false;\n\n  // Write out the buffer into a new APValue.\n  Optional<APValue> MaybeDestValue =\n      BufferToAPValueConverter::convert(Info, *Buffer, BCE);\n  if (!MaybeDestValue)\n    return false;\n\n  DestValue = std::move(*MaybeDestValue);\n  return true;\n}\n\ntemplate <class Derived>\nclass ExprEvaluatorBase\n  : public ConstStmtVisitor<Derived, bool> {\nprivate:\n  Derived &getDerived() { return static_cast<Derived&>(*this); }\n  bool DerivedSuccess(const APValue &V, const Expr *E) {\n    return getDerived().Success(V, E);\n  }\n  bool DerivedZeroInitialization(const Expr *E) {\n    return getDerived().ZeroInitialization(E);\n  }\n\n  // Check whether a conditional operator with a non-constant condition is a\n  // potential constant expression. If neither arm is a potential constant\n  // expression, then the conditional operator is not either.\n  template<typename ConditionalOperator>\n  void CheckPotentialConstantConditional(const ConditionalOperator *E) {\n    assert(Info.checkingPotentialConstantExpression());\n\n    // Speculatively evaluate both arms.\n    SmallVector<PartialDiagnosticAt, 8> Diag;\n    {\n      SpeculativeEvaluationRAII Speculate(Info, &Diag);\n      StmtVisitorTy::Visit(E->getFalseExpr());\n      if (Diag.empty())\n        return;\n    }\n\n    {\n      SpeculativeEvaluationRAII Speculate(Info, &Diag);\n      Diag.clear();\n      StmtVisitorTy::Visit(E->getTrueExpr());\n      if (Diag.empty())\n        return;\n    }\n\n    Error(E, diag::note_constexpr_conditional_never_const);\n  }\n\n\n  template<typename ConditionalOperator>\n  bool HandleConditionalOperator(const ConditionalOperator *E) {\n    bool BoolResult;\n    if (!EvaluateAsBooleanCondition(E->getCond(), BoolResult, Info)) {\n      if (Info.checkingPotentialConstantExpression() && Info.noteFailure()) {\n        CheckPotentialConstantConditional(E);\n        return false;\n      }\n      if (Info.noteFailure()) {\n        StmtVisitorTy::Visit(E->getTrueExpr());\n        StmtVisitorTy::Visit(E->getFalseExpr());\n      }\n      return false;\n    }\n\n    Expr *EvalExpr = BoolResult ? E->getTrueExpr() : E->getFalseExpr();\n    return StmtVisitorTy::Visit(EvalExpr);\n  }\n\nprotected:\n  EvalInfo &Info;\n  typedef ConstStmtVisitor<Derived, bool> StmtVisitorTy;\n  typedef ExprEvaluatorBase ExprEvaluatorBaseTy;\n\n  OptionalDiagnostic CCEDiag(const Expr *E, diag::kind D) {\n    return Info.CCEDiag(E, D);\n  }\n\n  bool ZeroInitialization(const Expr *E) { return Error(E); }\n\npublic:\n  ExprEvaluatorBase(EvalInfo &Info) : Info(Info) {}\n\n  EvalInfo &getEvalInfo() { return Info; }\n\n  /// Report an evaluation error. This should only be called when an error is\n  /// first discovered. When propagating an error, just return false.\n  bool Error(const Expr *E, diag::kind D) {\n    Info.FFDiag(E, D);\n    return false;\n  }\n  bool Error(const Expr *E) {\n    return Error(E, diag::note_invalid_subexpr_in_const_expr);\n  }\n\n  bool VisitStmt(const Stmt *) {\n    llvm_unreachable(\"Expression evaluator should not be called on stmts\");\n  }\n  bool VisitExpr(const Expr *E) {\n    return Error(E);\n  }\n\n  bool VisitConstantExpr(const ConstantExpr *E) {\n    if (E->hasAPValueResult())\n      return DerivedSuccess(E->getAPValueResult(), E);\n\n    return StmtVisitorTy::Visit(E->getSubExpr());\n  }\n\n  bool VisitParenExpr(const ParenExpr *E)\n    { return StmtVisitorTy::Visit(E->getSubExpr()); }\n  bool VisitUnaryExtension(const UnaryOperator *E)\n    { return StmtVisitorTy::Visit(E->getSubExpr()); }\n  bool VisitUnaryPlus(const UnaryOperator *E)\n    { return StmtVisitorTy::Visit(E->getSubExpr()); }\n  bool VisitChooseExpr(const ChooseExpr *E)\n    { return StmtVisitorTy::Visit(E->getChosenSubExpr()); }\n  bool VisitGenericSelectionExpr(const GenericSelectionExpr *E)\n    { return StmtVisitorTy::Visit(E->getResultExpr()); }\n  bool VisitSubstNonTypeTemplateParmExpr(const SubstNonTypeTemplateParmExpr *E)\n    { return StmtVisitorTy::Visit(E->getReplacement()); }\n  bool VisitCXXDefaultArgExpr(const CXXDefaultArgExpr *E) {\n    TempVersionRAII RAII(*Info.CurrentCall);\n    SourceLocExprScopeGuard Guard(E, Info.CurrentCall->CurSourceLocExprScope);\n    return StmtVisitorTy::Visit(E->getExpr());\n  }\n  bool VisitCXXDefaultInitExpr(const CXXDefaultInitExpr *E) {\n    TempVersionRAII RAII(*Info.CurrentCall);\n    // The initializer may not have been parsed yet, or might be erroneous.\n    if (!E->getExpr())\n      return Error(E);\n    SourceLocExprScopeGuard Guard(E, Info.CurrentCall->CurSourceLocExprScope);\n    return StmtVisitorTy::Visit(E->getExpr());\n  }\n\n  bool VisitExprWithCleanups(const ExprWithCleanups *E) {\n    FullExpressionRAII Scope(Info);\n    return StmtVisitorTy::Visit(E->getSubExpr()) && Scope.destroy();\n  }\n\n  // Temporaries are registered when created, so we don't care about\n  // CXXBindTemporaryExpr.\n  bool VisitCXXBindTemporaryExpr(const CXXBindTemporaryExpr *E) {\n    return StmtVisitorTy::Visit(E->getSubExpr());\n  }\n\n  bool VisitCXXReinterpretCastExpr(const CXXReinterpretCastExpr *E) {\n    CCEDiag(E, diag::note_constexpr_invalid_cast) << 0;\n    return static_cast<Derived*>(this)->VisitCastExpr(E);\n  }\n  bool VisitCXXDynamicCastExpr(const CXXDynamicCastExpr *E) {\n    if (!Info.Ctx.getLangOpts().CPlusPlus20)\n      CCEDiag(E, diag::note_constexpr_invalid_cast) << 1;\n    return static_cast<Derived*>(this)->VisitCastExpr(E);\n  }\n  bool VisitBuiltinBitCastExpr(const BuiltinBitCastExpr *E) {\n    return static_cast<Derived*>(this)->VisitCastExpr(E);\n  }\n\n  bool VisitBinaryOperator(const BinaryOperator *E) {\n    switch (E->getOpcode()) {\n    default:\n      return Error(E);\n\n    case BO_Comma:\n      VisitIgnoredValue(E->getLHS());\n      return StmtVisitorTy::Visit(E->getRHS());\n\n    case BO_PtrMemD:\n    case BO_PtrMemI: {\n      LValue Obj;\n      if (!HandleMemberPointerAccess(Info, E, Obj))\n        return false;\n      APValue Result;\n      if (!handleLValueToRValueConversion(Info, E, E->getType(), Obj, Result))\n        return false;\n      return DerivedSuccess(Result, E);\n    }\n    }\n  }\n\n  bool VisitCXXRewrittenBinaryOperator(const CXXRewrittenBinaryOperator *E) {\n    return StmtVisitorTy::Visit(E->getSemanticForm());\n  }\n\n  bool VisitBinaryConditionalOperator(const BinaryConditionalOperator *E) {\n    // Evaluate and cache the common expression. We treat it as a temporary,\n    // even though it's not quite the same thing.\n    LValue CommonLV;\n    if (!Evaluate(Info.CurrentCall->createTemporary(\n                      E->getOpaqueValue(),\n                      getStorageType(Info.Ctx, E->getOpaqueValue()),\n                      ScopeKind::FullExpression, CommonLV),\n                  Info, E->getCommon()))\n      return false;\n\n    return HandleConditionalOperator(E);\n  }\n\n  bool VisitConditionalOperator(const ConditionalOperator *E) {\n    bool IsBcpCall = false;\n    // If the condition (ignoring parens) is a __builtin_constant_p call,\n    // the result is a constant expression if it can be folded without\n    // side-effects. This is an important GNU extension. See GCC PR38377\n    // for discussion.\n    if (const CallExpr *CallCE =\n          dyn_cast<CallExpr>(E->getCond()->IgnoreParenCasts()))\n      if (CallCE->getBuiltinCallee() == Builtin::BI__builtin_constant_p)\n        IsBcpCall = true;\n\n    // Always assume __builtin_constant_p(...) ? ... : ... is a potential\n    // constant expression; we can't check whether it's potentially foldable.\n    // FIXME: We should instead treat __builtin_constant_p as non-constant if\n    // it would return 'false' in this mode.\n    if (Info.checkingPotentialConstantExpression() && IsBcpCall)\n      return false;\n\n    FoldConstant Fold(Info, IsBcpCall);\n    if (!HandleConditionalOperator(E)) {\n      Fold.keepDiagnostics();\n      return false;\n    }\n\n    return true;\n  }\n\n  bool VisitOpaqueValueExpr(const OpaqueValueExpr *E) {\n    if (APValue *Value = Info.CurrentCall->getCurrentTemporary(E))\n      return DerivedSuccess(*Value, E);\n\n    const Expr *Source = E->getSourceExpr();\n    if (!Source)\n      return Error(E);\n    if (Source == E) { // sanity checking.\n      assert(0 && \"OpaqueValueExpr recursively refers to itself\");\n      return Error(E);\n    }\n    return StmtVisitorTy::Visit(Source);\n  }\n\n  bool VisitPseudoObjectExpr(const PseudoObjectExpr *E) {\n    for (const Expr *SemE : E->semantics()) {\n      if (auto *OVE = dyn_cast<OpaqueValueExpr>(SemE)) {\n        // FIXME: We can't handle the case where an OpaqueValueExpr is also the\n        // result expression: there could be two different LValues that would\n        // refer to the same object in that case, and we can't model that.\n        if (SemE == E->getResultExpr())\n          return Error(E);\n\n        // Unique OVEs get evaluated if and when we encounter them when\n        // emitting the rest of the semantic form, rather than eagerly.\n        if (OVE->isUnique())\n          continue;\n\n        LValue LV;\n        if (!Evaluate(Info.CurrentCall->createTemporary(\n                          OVE, getStorageType(Info.Ctx, OVE),\n                          ScopeKind::FullExpression, LV),\n                      Info, OVE->getSourceExpr()))\n          return false;\n      } else if (SemE == E->getResultExpr()) {\n        if (!StmtVisitorTy::Visit(SemE))\n          return false;\n      } else {\n        if (!EvaluateIgnoredValue(Info, SemE))\n          return false;\n      }\n    }\n    return true;\n  }\n\n  bool VisitCallExpr(const CallExpr *E) {\n    APValue Result;\n    if (!handleCallExpr(E, Result, nullptr))\n      return false;\n    return DerivedSuccess(Result, E);\n  }\n\n  bool handleCallExpr(const CallExpr *E, APValue &Result,\n                     const LValue *ResultSlot) {\n    CallScopeRAII CallScope(Info);\n\n    const Expr *Callee = E->getCallee()->IgnoreParens();\n    QualType CalleeType = Callee->getType();\n\n    const FunctionDecl *FD = nullptr;\n    LValue *This = nullptr, ThisVal;\n    auto Args = llvm::makeArrayRef(E->getArgs(), E->getNumArgs());\n    bool HasQualifier = false;\n\n    CallRef Call;\n\n    // Extract function decl and 'this' pointer from the callee.\n    if (CalleeType->isSpecificBuiltinType(BuiltinType::BoundMember)) {\n      const CXXMethodDecl *Member = nullptr;\n      if (const MemberExpr *ME = dyn_cast<MemberExpr>(Callee)) {\n        // Explicit bound member calls, such as x.f() or p->g();\n        if (!EvaluateObjectArgument(Info, ME->getBase(), ThisVal))\n          return false;\n        Member = dyn_cast<CXXMethodDecl>(ME->getMemberDecl());\n        if (!Member)\n          return Error(Callee);\n        This = &ThisVal;\n        HasQualifier = ME->hasQualifier();\n      } else if (const BinaryOperator *BE = dyn_cast<BinaryOperator>(Callee)) {\n        // Indirect bound member calls ('.*' or '->*').\n        const ValueDecl *D =\n            HandleMemberPointerAccess(Info, BE, ThisVal, false);\n        if (!D)\n          return false;\n        Member = dyn_cast<CXXMethodDecl>(D);\n        if (!Member)\n          return Error(Callee);\n        This = &ThisVal;\n      } else if (const auto *PDE = dyn_cast<CXXPseudoDestructorExpr>(Callee)) {\n        if (!Info.getLangOpts().CPlusPlus20)\n          Info.CCEDiag(PDE, diag::note_constexpr_pseudo_destructor);\n        return EvaluateObjectArgument(Info, PDE->getBase(), ThisVal) &&\n               HandleDestruction(Info, PDE, ThisVal, PDE->getDestroyedType());\n      } else\n        return Error(Callee);\n      FD = Member;\n    } else if (CalleeType->isFunctionPointerType()) {\n      LValue CalleeLV;\n      if (!EvaluatePointer(Callee, CalleeLV, Info))\n        return false;\n\n      if (!CalleeLV.getLValueOffset().isZero())\n        return Error(Callee);\n      FD = dyn_cast_or_null<FunctionDecl>(\n          CalleeLV.getLValueBase().dyn_cast<const ValueDecl *>());\n      if (!FD)\n        return Error(Callee);\n      // Don't call function pointers which have been cast to some other type.\n      // Per DR (no number yet), the caller and callee can differ in noexcept.\n      if (!Info.Ctx.hasSameFunctionTypeIgnoringExceptionSpec(\n        CalleeType->getPointeeType(), FD->getType())) {\n        return Error(E);\n      }\n\n      // For an (overloaded) assignment expression, evaluate the RHS before the\n      // LHS.\n      auto *OCE = dyn_cast<CXXOperatorCallExpr>(E);\n      if (OCE && OCE->isAssignmentOp()) {\n        assert(Args.size() == 2 && \"wrong number of arguments in assignment\");\n        Call = Info.CurrentCall->createCall(FD);\n        if (!EvaluateArgs(isa<CXXMethodDecl>(FD) ? Args.slice(1) : Args, Call,\n                          Info, FD, /*RightToLeft=*/true))\n          return false;\n      }\n\n      // Overloaded operator calls to member functions are represented as normal\n      // calls with '*this' as the first argument.\n      const CXXMethodDecl *MD = dyn_cast<CXXMethodDecl>(FD);\n      if (MD && !MD->isStatic()) {\n        // FIXME: When selecting an implicit conversion for an overloaded\n        // operator delete, we sometimes try to evaluate calls to conversion\n        // operators without a 'this' parameter!\n        if (Args.empty())\n          return Error(E);\n\n        if (!EvaluateObjectArgument(Info, Args[0], ThisVal))\n          return false;\n        This = &ThisVal;\n        Args = Args.slice(1);\n      } else if (MD && MD->isLambdaStaticInvoker()) {\n        // Map the static invoker for the lambda back to the call operator.\n        // Conveniently, we don't have to slice out the 'this' argument (as is\n        // being done for the non-static case), since a static member function\n        // doesn't have an implicit argument passed in.\n        const CXXRecordDecl *ClosureClass = MD->getParent();\n        assert(\n            ClosureClass->captures_begin() == ClosureClass->captures_end() &&\n            \"Number of captures must be zero for conversion to function-ptr\");\n\n        const CXXMethodDecl *LambdaCallOp =\n            ClosureClass->getLambdaCallOperator();\n\n        // Set 'FD', the function that will be called below, to the call\n        // operator.  If the closure object represents a generic lambda, find\n        // the corresponding specialization of the call operator.\n\n        if (ClosureClass->isGenericLambda()) {\n          assert(MD->isFunctionTemplateSpecialization() &&\n                 \"A generic lambda's static-invoker function must be a \"\n                 \"template specialization\");\n          const TemplateArgumentList *TAL = MD->getTemplateSpecializationArgs();\n          FunctionTemplateDecl *CallOpTemplate =\n              LambdaCallOp->getDescribedFunctionTemplate();\n          void *InsertPos = nullptr;\n          FunctionDecl *CorrespondingCallOpSpecialization =\n              CallOpTemplate->findSpecialization(TAL->asArray(), InsertPos);\n          assert(CorrespondingCallOpSpecialization &&\n                 \"We must always have a function call operator specialization \"\n                 \"that corresponds to our static invoker specialization\");\n          FD = cast<CXXMethodDecl>(CorrespondingCallOpSpecialization);\n        } else\n          FD = LambdaCallOp;\n      } else if (FD->isReplaceableGlobalAllocationFunction()) {\n        if (FD->getDeclName().getCXXOverloadedOperator() == OO_New ||\n            FD->getDeclName().getCXXOverloadedOperator() == OO_Array_New) {\n          LValue Ptr;\n          if (!HandleOperatorNewCall(Info, E, Ptr))\n            return false;\n          Ptr.moveInto(Result);\n          return CallScope.destroy();\n        } else {\n          return HandleOperatorDeleteCall(Info, E) && CallScope.destroy();\n        }\n      }\n    } else\n      return Error(E);\n\n    // Evaluate the arguments now if we've not already done so.\n    if (!Call) {\n      Call = Info.CurrentCall->createCall(FD);\n      if (!EvaluateArgs(Args, Call, Info, FD))\n        return false;\n    }\n\n    SmallVector<QualType, 4> CovariantAdjustmentPath;\n    if (This) {\n      auto *NamedMember = dyn_cast<CXXMethodDecl>(FD);\n      if (NamedMember && NamedMember->isVirtual() && !HasQualifier) {\n        // Perform virtual dispatch, if necessary.\n        FD = HandleVirtualDispatch(Info, E, *This, NamedMember,\n                                   CovariantAdjustmentPath);\n        if (!FD)\n          return false;\n      } else {\n        // Check that the 'this' pointer points to an object of the right type.\n        // FIXME: If this is an assignment operator call, we may need to change\n        // the active union member before we check this.\n        if (!checkNonVirtualMemberCallThisPointer(Info, E, *This, NamedMember))\n          return false;\n      }\n    }\n\n    // Destructor calls are different enough that they have their own codepath.\n    if (auto *DD = dyn_cast<CXXDestructorDecl>(FD)) {\n      assert(This && \"no 'this' pointer for destructor call\");\n      return HandleDestruction(Info, E, *This,\n                               Info.Ctx.getRecordType(DD->getParent())) &&\n             CallScope.destroy();\n    }\n\n    const FunctionDecl *Definition = nullptr;\n    Stmt *Body = FD->getBody(Definition);\n\n    if (!CheckConstexprFunction(Info, E->getExprLoc(), FD, Definition, Body) ||\n        !HandleFunctionCall(E->getExprLoc(), Definition, This, Args, Call,\n                            Body, Info, Result, ResultSlot))\n      return false;\n\n    if (!CovariantAdjustmentPath.empty() &&\n        !HandleCovariantReturnAdjustment(Info, E, Result,\n                                         CovariantAdjustmentPath))\n      return false;\n\n    return CallScope.destroy();\n  }\n\n  bool VisitCompoundLiteralExpr(const CompoundLiteralExpr *E) {\n    return StmtVisitorTy::Visit(E->getInitializer());\n  }\n  bool VisitInitListExpr(const InitListExpr *E) {\n    if (E->getNumInits() == 0)\n      return DerivedZeroInitialization(E);\n    if (E->getNumInits() == 1)\n      return StmtVisitorTy::Visit(E->getInit(0));\n    return Error(E);\n  }\n  bool VisitImplicitValueInitExpr(const ImplicitValueInitExpr *E) {\n    return DerivedZeroInitialization(E);\n  }\n  bool VisitCXXScalarValueInitExpr(const CXXScalarValueInitExpr *E) {\n    return DerivedZeroInitialization(E);\n  }\n  bool VisitCXXNullPtrLiteralExpr(const CXXNullPtrLiteralExpr *E) {\n    return DerivedZeroInitialization(E);\n  }\n\n  /// A member expression where the object is a prvalue is itself a prvalue.\n  bool VisitMemberExpr(const MemberExpr *E) {\n    assert(!Info.Ctx.getLangOpts().CPlusPlus11 &&\n           \"missing temporary materialization conversion\");\n    assert(!E->isArrow() && \"missing call to bound member function?\");\n\n    APValue Val;\n    if (!Evaluate(Val, Info, E->getBase()))\n      return false;\n\n    QualType BaseTy = E->getBase()->getType();\n\n    const FieldDecl *FD = dyn_cast<FieldDecl>(E->getMemberDecl());\n    if (!FD) return Error(E);\n    assert(!FD->getType()->isReferenceType() && \"prvalue reference?\");\n    assert(BaseTy->castAs<RecordType>()->getDecl()->getCanonicalDecl() ==\n           FD->getParent()->getCanonicalDecl() && \"record / field mismatch\");\n\n    // Note: there is no lvalue base here. But this case should only ever\n    // happen in C or in C++98, where we cannot be evaluating a constexpr\n    // constructor, which is the only case the base matters.\n    CompleteObject Obj(APValue::LValueBase(), &Val, BaseTy);\n    SubobjectDesignator Designator(BaseTy);\n    Designator.addDeclUnchecked(FD);\n\n    APValue Result;\n    return extractSubobject(Info, E, Obj, Designator, Result) &&\n           DerivedSuccess(Result, E);\n  }\n\n  bool VisitExtVectorElementExpr(const ExtVectorElementExpr *E) {\n    APValue Val;\n    if (!Evaluate(Val, Info, E->getBase()))\n      return false;\n\n    if (Val.isVector()) {\n      SmallVector<uint32_t, 4> Indices;\n      E->getEncodedElementAccess(Indices);\n      if (Indices.size() == 1) {\n        // Return scalar.\n        return DerivedSuccess(Val.getVectorElt(Indices[0]), E);\n      } else {\n        // Construct new APValue vector.\n        SmallVector<APValue, 4> Elts;\n        for (unsigned I = 0; I < Indices.size(); ++I) {\n          Elts.push_back(Val.getVectorElt(Indices[I]));\n        }\n        APValue VecResult(Elts.data(), Indices.size());\n        return DerivedSuccess(VecResult, E);\n      }\n    }\n\n    return false;\n  }\n\n  bool VisitCastExpr(const CastExpr *E) {\n    switch (E->getCastKind()) {\n    default:\n      break;\n\n    case CK_AtomicToNonAtomic: {\n      APValue AtomicVal;\n      // This does not need to be done in place even for class/array types:\n      // atomic-to-non-atomic conversion implies copying the object\n      // representation.\n      if (!Evaluate(AtomicVal, Info, E->getSubExpr()))\n        return false;\n      return DerivedSuccess(AtomicVal, E);\n    }\n\n    case CK_NoOp:\n    case CK_UserDefinedConversion:\n      return StmtVisitorTy::Visit(E->getSubExpr());\n\n    case CK_LValueToRValue: {\n      LValue LVal;\n      if (!EvaluateLValue(E->getSubExpr(), LVal, Info))\n        return false;\n      APValue RVal;\n      // Note, we use the subexpression's type in order to retain cv-qualifiers.\n      if (!handleLValueToRValueConversion(Info, E, E->getSubExpr()->getType(),\n                                          LVal, RVal))\n        return false;\n      return DerivedSuccess(RVal, E);\n    }\n    case CK_LValueToRValueBitCast: {\n      APValue DestValue, SourceValue;\n      if (!Evaluate(SourceValue, Info, E->getSubExpr()))\n        return false;\n      if (!handleLValueToRValueBitCast(Info, DestValue, SourceValue, E))\n        return false;\n      return DerivedSuccess(DestValue, E);\n    }\n\n    case CK_AddressSpaceConversion: {\n      APValue Value;\n      if (!Evaluate(Value, Info, E->getSubExpr()))\n        return false;\n      return DerivedSuccess(Value, E);\n    }\n    }\n\n    return Error(E);\n  }\n\n  bool VisitUnaryPostInc(const UnaryOperator *UO) {\n    return VisitUnaryPostIncDec(UO);\n  }\n  bool VisitUnaryPostDec(const UnaryOperator *UO) {\n    return VisitUnaryPostIncDec(UO);\n  }\n  bool VisitUnaryPostIncDec(const UnaryOperator *UO) {\n    if (!Info.getLangOpts().CPlusPlus14 && !Info.keepEvaluatingAfterFailure())\n      return Error(UO);\n\n    LValue LVal;\n    if (!EvaluateLValue(UO->getSubExpr(), LVal, Info))\n      return false;\n    APValue RVal;\n    if (!handleIncDec(this->Info, UO, LVal, UO->getSubExpr()->getType(),\n                      UO->isIncrementOp(), &RVal))\n      return false;\n    return DerivedSuccess(RVal, UO);\n  }\n\n  bool VisitStmtExpr(const StmtExpr *E) {\n    // We will have checked the full-expressions inside the statement expression\n    // when they were completed, and don't need to check them again now.\n    llvm::SaveAndRestore<bool> NotCheckingForUB(\n        Info.CheckingForUndefinedBehavior, false);\n\n    const CompoundStmt *CS = E->getSubStmt();\n    if (CS->body_empty())\n      return true;\n\n    BlockScopeRAII Scope(Info);\n    for (CompoundStmt::const_body_iterator BI = CS->body_begin(),\n                                           BE = CS->body_end();\n         /**/; ++BI) {\n      if (BI + 1 == BE) {\n        const Expr *FinalExpr = dyn_cast<Expr>(*BI);\n        if (!FinalExpr) {\n          Info.FFDiag((*BI)->getBeginLoc(),\n                      diag::note_constexpr_stmt_expr_unsupported);\n          return false;\n        }\n        return this->Visit(FinalExpr) && Scope.destroy();\n      }\n\n      APValue ReturnValue;\n      StmtResult Result = { ReturnValue, nullptr };\n      EvalStmtResult ESR = EvaluateStmt(Result, Info, *BI);\n      if (ESR != ESR_Succeeded) {\n        // FIXME: If the statement-expression terminated due to 'return',\n        // 'break', or 'continue', it would be nice to propagate that to\n        // the outer statement evaluation rather than bailing out.\n        if (ESR != ESR_Failed)\n          Info.FFDiag((*BI)->getBeginLoc(),\n                      diag::note_constexpr_stmt_expr_unsupported);\n        return false;\n      }\n    }\n\n    llvm_unreachable(\"Return from function from the loop above.\");\n  }\n\n  /// Visit a value which is evaluated, but whose value is ignored.\n  void VisitIgnoredValue(const Expr *E) {\n    EvaluateIgnoredValue(Info, E);\n  }\n\n  /// Potentially visit a MemberExpr's base expression.\n  void VisitIgnoredBaseExpression(const Expr *E) {\n    // While MSVC doesn't evaluate the base expression, it does diagnose the\n    // presence of side-effecting behavior.\n    if (Info.getLangOpts().MSVCCompat && !E->HasSideEffects(Info.Ctx))\n      return;\n    VisitIgnoredValue(E);\n  }\n};\n\n} // namespace\n\n//===----------------------------------------------------------------------===//\n// Common base class for lvalue and temporary evaluation.\n//===----------------------------------------------------------------------===//\nnamespace {\ntemplate<class Derived>\nclass LValueExprEvaluatorBase\n  : public ExprEvaluatorBase<Derived> {\nprotected:\n  LValue &Result;\n  bool InvalidBaseOK;\n  typedef LValueExprEvaluatorBase LValueExprEvaluatorBaseTy;\n  typedef ExprEvaluatorBase<Derived> ExprEvaluatorBaseTy;\n\n  bool Success(APValue::LValueBase B) {\n    Result.set(B);\n    return true;\n  }\n\n  bool evaluatePointer(const Expr *E, LValue &Result) {\n    return EvaluatePointer(E, Result, this->Info, InvalidBaseOK);\n  }\n\npublic:\n  LValueExprEvaluatorBase(EvalInfo &Info, LValue &Result, bool InvalidBaseOK)\n      : ExprEvaluatorBaseTy(Info), Result(Result),\n        InvalidBaseOK(InvalidBaseOK) {}\n\n  bool Success(const APValue &V, const Expr *E) {\n    Result.setFrom(this->Info.Ctx, V);\n    return true;\n  }\n\n  bool VisitMemberExpr(const MemberExpr *E) {\n    // Handle non-static data members.\n    QualType BaseTy;\n    bool EvalOK;\n    if (E->isArrow()) {\n      EvalOK = evaluatePointer(E->getBase(), Result);\n      BaseTy = E->getBase()->getType()->castAs<PointerType>()->getPointeeType();\n    } else if (E->getBase()->isRValue()) {\n      assert(E->getBase()->getType()->isRecordType());\n      EvalOK = EvaluateTemporary(E->getBase(), Result, this->Info);\n      BaseTy = E->getBase()->getType();\n    } else {\n      EvalOK = this->Visit(E->getBase());\n      BaseTy = E->getBase()->getType();\n    }\n    if (!EvalOK) {\n      if (!InvalidBaseOK)\n        return false;\n      Result.setInvalid(E);\n      return true;\n    }\n\n    const ValueDecl *MD = E->getMemberDecl();\n    if (const FieldDecl *FD = dyn_cast<FieldDecl>(E->getMemberDecl())) {\n      assert(BaseTy->castAs<RecordType>()->getDecl()->getCanonicalDecl() ==\n             FD->getParent()->getCanonicalDecl() && \"record / field mismatch\");\n      (void)BaseTy;\n      if (!HandleLValueMember(this->Info, E, Result, FD))\n        return false;\n    } else if (const IndirectFieldDecl *IFD = dyn_cast<IndirectFieldDecl>(MD)) {\n      if (!HandleLValueIndirectMember(this->Info, E, Result, IFD))\n        return false;\n    } else\n      return this->Error(E);\n\n    if (MD->getType()->isReferenceType()) {\n      APValue RefValue;\n      if (!handleLValueToRValueConversion(this->Info, E, MD->getType(), Result,\n                                          RefValue))\n        return false;\n      return Success(RefValue, E);\n    }\n    return true;\n  }\n\n  bool VisitBinaryOperator(const BinaryOperator *E) {\n    switch (E->getOpcode()) {\n    default:\n      return ExprEvaluatorBaseTy::VisitBinaryOperator(E);\n\n    case BO_PtrMemD:\n    case BO_PtrMemI:\n      return HandleMemberPointerAccess(this->Info, E, Result);\n    }\n  }\n\n  bool VisitCastExpr(const CastExpr *E) {\n    switch (E->getCastKind()) {\n    default:\n      return ExprEvaluatorBaseTy::VisitCastExpr(E);\n\n    case CK_DerivedToBase:\n    case CK_UncheckedDerivedToBase:\n      if (!this->Visit(E->getSubExpr()))\n        return false;\n\n      // Now figure out the necessary offset to add to the base LV to get from\n      // the derived class to the base class.\n      return HandleLValueBasePath(this->Info, E, E->getSubExpr()->getType(),\n                                  Result);\n    }\n  }\n};\n}\n\n//===----------------------------------------------------------------------===//\n// LValue Evaluation\n//\n// This is used for evaluating lvalues (in C and C++), xvalues (in C++11),\n// function designators (in C), decl references to void objects (in C), and\n// temporaries (if building with -Wno-address-of-temporary).\n//\n// LValue evaluation produces values comprising a base expression of one of the\n// following types:\n// - Declarations\n//  * VarDecl\n//  * FunctionDecl\n// - Literals\n//  * CompoundLiteralExpr in C (and in global scope in C++)\n//  * StringLiteral\n//  * PredefinedExpr\n//  * ObjCStringLiteralExpr\n//  * ObjCEncodeExpr\n//  * AddrLabelExpr\n//  * BlockExpr\n//  * CallExpr for a MakeStringConstant builtin\n// - typeid(T) expressions, as TypeInfoLValues\n// - Locals and temporaries\n//  * MaterializeTemporaryExpr\n//  * Any Expr, with a CallIndex indicating the function in which the temporary\n//    was evaluated, for cases where the MaterializeTemporaryExpr is missing\n//    from the AST (FIXME).\n//  * A MaterializeTemporaryExpr that has static storage duration, with no\n//    CallIndex, for a lifetime-extended temporary.\n//  * The ConstantExpr that is currently being evaluated during evaluation of an\n//    immediate invocation.\n// plus an offset in bytes.\n//===----------------------------------------------------------------------===//\nnamespace {\nclass LValueExprEvaluator\n  : public LValueExprEvaluatorBase<LValueExprEvaluator> {\npublic:\n  LValueExprEvaluator(EvalInfo &Info, LValue &Result, bool InvalidBaseOK) :\n    LValueExprEvaluatorBaseTy(Info, Result, InvalidBaseOK) {}\n\n  bool VisitVarDecl(const Expr *E, const VarDecl *VD);\n  bool VisitUnaryPreIncDec(const UnaryOperator *UO);\n\n  bool VisitDeclRefExpr(const DeclRefExpr *E);\n  bool VisitPredefinedExpr(const PredefinedExpr *E) { return Success(E); }\n  bool VisitMaterializeTemporaryExpr(const MaterializeTemporaryExpr *E);\n  bool VisitCompoundLiteralExpr(const CompoundLiteralExpr *E);\n  bool VisitMemberExpr(const MemberExpr *E);\n  bool VisitStringLiteral(const StringLiteral *E) { return Success(E); }\n  bool VisitObjCEncodeExpr(const ObjCEncodeExpr *E) { return Success(E); }\n  bool VisitCXXTypeidExpr(const CXXTypeidExpr *E);\n  bool VisitCXXUuidofExpr(const CXXUuidofExpr *E);\n  bool VisitArraySubscriptExpr(const ArraySubscriptExpr *E);\n  bool VisitUnaryDeref(const UnaryOperator *E);\n  bool VisitUnaryReal(const UnaryOperator *E);\n  bool VisitUnaryImag(const UnaryOperator *E);\n  bool VisitUnaryPreInc(const UnaryOperator *UO) {\n    return VisitUnaryPreIncDec(UO);\n  }\n  bool VisitUnaryPreDec(const UnaryOperator *UO) {\n    return VisitUnaryPreIncDec(UO);\n  }\n  bool VisitBinAssign(const BinaryOperator *BO);\n  bool VisitCompoundAssignOperator(const CompoundAssignOperator *CAO);\n\n  bool VisitCastExpr(const CastExpr *E) {\n    switch (E->getCastKind()) {\n    default:\n      return LValueExprEvaluatorBaseTy::VisitCastExpr(E);\n\n    case CK_LValueBitCast:\n      this->CCEDiag(E, diag::note_constexpr_invalid_cast) << 2;\n      if (!Visit(E->getSubExpr()))\n        return false;\n      Result.Designator.setInvalid();\n      return true;\n\n    case CK_BaseToDerived:\n      if (!Visit(E->getSubExpr()))\n        return false;\n      return HandleBaseToDerivedCast(Info, E, Result);\n\n    case CK_Dynamic:\n      if (!Visit(E->getSubExpr()))\n        return false;\n      return HandleDynamicCast(Info, cast<ExplicitCastExpr>(E), Result);\n    }\n  }\n};\n} // end anonymous namespace\n\n/// Evaluate an expression as an lvalue. This can be legitimately called on\n/// expressions which are not glvalues, in three cases:\n///  * function designators in C, and\n///  * \"extern void\" objects\n///  * @selector() expressions in Objective-C\nstatic bool EvaluateLValue(const Expr *E, LValue &Result, EvalInfo &Info,\n                           bool InvalidBaseOK) {\n  assert(!E->isValueDependent());\n  assert(E->isGLValue() || E->getType()->isFunctionType() ||\n         E->getType()->isVoidType() || isa<ObjCSelectorExpr>(E));\n  return LValueExprEvaluator(Info, Result, InvalidBaseOK).Visit(E);\n}\n\nbool LValueExprEvaluator::VisitDeclRefExpr(const DeclRefExpr *E) {\n  const NamedDecl *D = E->getDecl();\n  if (isa<FunctionDecl, MSGuidDecl, TemplateParamObjectDecl>(D))\n    return Success(cast<ValueDecl>(D));\n  if (const VarDecl *VD = dyn_cast<VarDecl>(D))\n    return VisitVarDecl(E, VD);\n  if (const BindingDecl *BD = dyn_cast<BindingDecl>(D))\n    return Visit(BD->getBinding());\n  return Error(E);\n}\n\n\nbool LValueExprEvaluator::VisitVarDecl(const Expr *E, const VarDecl *VD) {\n\n  // If we are within a lambda's call operator, check whether the 'VD' referred\n  // to within 'E' actually represents a lambda-capture that maps to a\n  // data-member/field within the closure object, and if so, evaluate to the\n  // field or what the field refers to.\n  if (Info.CurrentCall && isLambdaCallOperator(Info.CurrentCall->Callee) &&\n      isa<DeclRefExpr>(E) &&\n      cast<DeclRefExpr>(E)->refersToEnclosingVariableOrCapture()) {\n    // We don't always have a complete capture-map when checking or inferring if\n    // the function call operator meets the requirements of a constexpr function\n    // - but we don't need to evaluate the captures to determine constexprness\n    // (dcl.constexpr C++17).\n    if (Info.checkingPotentialConstantExpression())\n      return false;\n\n    if (auto *FD = Info.CurrentCall->LambdaCaptureFields.lookup(VD)) {\n      // Start with 'Result' referring to the complete closure object...\n      Result = *Info.CurrentCall->This;\n      // ... then update it to refer to the field of the closure object\n      // that represents the capture.\n      if (!HandleLValueMember(Info, E, Result, FD))\n        return false;\n      // And if the field is of reference type, update 'Result' to refer to what\n      // the field refers to.\n      if (FD->getType()->isReferenceType()) {\n        APValue RVal;\n        if (!handleLValueToRValueConversion(Info, E, FD->getType(), Result,\n                                            RVal))\n          return false;\n        Result.setFrom(Info.Ctx, RVal);\n      }\n      return true;\n    }\n  }\n\n  CallStackFrame *Frame = nullptr;\n  unsigned Version = 0;\n  if (VD->hasLocalStorage()) {\n    // Only if a local variable was declared in the function currently being\n    // evaluated, do we expect to be able to find its value in the current\n    // frame. (Otherwise it was likely declared in an enclosing context and\n    // could either have a valid evaluatable value (for e.g. a constexpr\n    // variable) or be ill-formed (and trigger an appropriate evaluation\n    // diagnostic)).\n    CallStackFrame *CurrFrame = Info.CurrentCall;\n    if (CurrFrame->Callee && CurrFrame->Callee->Equals(VD->getDeclContext())) {\n      // Function parameters are stored in some caller's frame. (Usually the\n      // immediate caller, but for an inherited constructor they may be more\n      // distant.)\n      if (auto *PVD = dyn_cast<ParmVarDecl>(VD)) {\n        if (CurrFrame->Arguments) {\n          VD = CurrFrame->Arguments.getOrigParam(PVD);\n          Frame =\n              Info.getCallFrameAndDepth(CurrFrame->Arguments.CallIndex).first;\n          Version = CurrFrame->Arguments.Version;\n        }\n      } else {\n        Frame = CurrFrame;\n        Version = CurrFrame->getCurrentTemporaryVersion(VD);\n      }\n    }\n  }\n\n  if (!VD->getType()->isReferenceType()) {\n    if (Frame) {\n      Result.set({VD, Frame->Index, Version});\n      return true;\n    }\n    return Success(VD);\n  }\n\n  if (!Info.getLangOpts().CPlusPlus11) {\n    Info.CCEDiag(E, diag::note_constexpr_ltor_non_integral, 1)\n        << VD << VD->getType();\n    Info.Note(VD->getLocation(), diag::note_declared_at);\n  }\n\n  APValue *V;\n  if (!evaluateVarDeclInit(Info, E, VD, Frame, Version, V))\n    return false;\n  if (!V->hasValue()) {\n    // FIXME: Is it possible for V to be indeterminate here? If so, we should\n    // adjust the diagnostic to say that.\n    if (!Info.checkingPotentialConstantExpression())\n      Info.FFDiag(E, diag::note_constexpr_use_uninit_reference);\n    return false;\n  }\n  return Success(*V, E);\n}\n\nbool LValueExprEvaluator::VisitMaterializeTemporaryExpr(\n    const MaterializeTemporaryExpr *E) {\n  // Walk through the expression to find the materialized temporary itself.\n  SmallVector<const Expr *, 2> CommaLHSs;\n  SmallVector<SubobjectAdjustment, 2> Adjustments;\n  const Expr *Inner =\n      E->getSubExpr()->skipRValueSubobjectAdjustments(CommaLHSs, Adjustments);\n\n  // If we passed any comma operators, evaluate their LHSs.\n  for (unsigned I = 0, N = CommaLHSs.size(); I != N; ++I)\n    if (!EvaluateIgnoredValue(Info, CommaLHSs[I]))\n      return false;\n\n  // A materialized temporary with static storage duration can appear within the\n  // result of a constant expression evaluation, so we need to preserve its\n  // value for use outside this evaluation.\n  APValue *Value;\n  if (E->getStorageDuration() == SD_Static) {\n    // FIXME: What about SD_Thread?\n    Value = E->getOrCreateValue(true);\n    *Value = APValue();\n    Result.set(E);\n  } else {\n    Value = &Info.CurrentCall->createTemporary(\n        E, E->getType(),\n        E->getStorageDuration() == SD_FullExpression ? ScopeKind::FullExpression\n                                                     : ScopeKind::Block,\n        Result);\n  }\n\n  QualType Type = Inner->getType();\n\n  // Materialize the temporary itself.\n  if (!EvaluateInPlace(*Value, Info, Result, Inner)) {\n    *Value = APValue();\n    return false;\n  }\n\n  // Adjust our lvalue to refer to the desired subobject.\n  for (unsigned I = Adjustments.size(); I != 0; /**/) {\n    --I;\n    switch (Adjustments[I].Kind) {\n    case SubobjectAdjustment::DerivedToBaseAdjustment:\n      if (!HandleLValueBasePath(Info, Adjustments[I].DerivedToBase.BasePath,\n                                Type, Result))\n        return false;\n      Type = Adjustments[I].DerivedToBase.BasePath->getType();\n      break;\n\n    case SubobjectAdjustment::FieldAdjustment:\n      if (!HandleLValueMember(Info, E, Result, Adjustments[I].Field))\n        return false;\n      Type = Adjustments[I].Field->getType();\n      break;\n\n    case SubobjectAdjustment::MemberPointerAdjustment:\n      if (!HandleMemberPointerAccess(this->Info, Type, Result,\n                                     Adjustments[I].Ptr.RHS))\n        return false;\n      Type = Adjustments[I].Ptr.MPT->getPointeeType();\n      break;\n    }\n  }\n\n  return true;\n}\n\nbool\nLValueExprEvaluator::VisitCompoundLiteralExpr(const CompoundLiteralExpr *E) {\n  assert((!Info.getLangOpts().CPlusPlus || E->isFileScope()) &&\n         \"lvalue compound literal in c++?\");\n  // Defer visiting the literal until the lvalue-to-rvalue conversion. We can\n  // only see this when folding in C, so there's no standard to follow here.\n  return Success(E);\n}\n\nbool LValueExprEvaluator::VisitCXXTypeidExpr(const CXXTypeidExpr *E) {\n  TypeInfoLValue TypeInfo;\n\n  if (!E->isPotentiallyEvaluated()) {\n    if (E->isTypeOperand())\n      TypeInfo = TypeInfoLValue(E->getTypeOperand(Info.Ctx).getTypePtr());\n    else\n      TypeInfo = TypeInfoLValue(E->getExprOperand()->getType().getTypePtr());\n  } else {\n    if (!Info.Ctx.getLangOpts().CPlusPlus20) {\n      Info.CCEDiag(E, diag::note_constexpr_typeid_polymorphic)\n        << E->getExprOperand()->getType()\n        << E->getExprOperand()->getSourceRange();\n    }\n\n    if (!Visit(E->getExprOperand()))\n      return false;\n\n    Optional<DynamicType> DynType =\n        ComputeDynamicType(Info, E, Result, AK_TypeId);\n    if (!DynType)\n      return false;\n\n    TypeInfo =\n        TypeInfoLValue(Info.Ctx.getRecordType(DynType->Type).getTypePtr());\n  }\n\n  return Success(APValue::LValueBase::getTypeInfo(TypeInfo, E->getType()));\n}\n\nbool LValueExprEvaluator::VisitCXXUuidofExpr(const CXXUuidofExpr *E) {\n  return Success(E->getGuidDecl());\n}\n\nbool LValueExprEvaluator::VisitMemberExpr(const MemberExpr *E) {\n  // Handle static data members.\n  if (const VarDecl *VD = dyn_cast<VarDecl>(E->getMemberDecl())) {\n    VisitIgnoredBaseExpression(E->getBase());\n    return VisitVarDecl(E, VD);\n  }\n\n  // Handle static member functions.\n  if (const CXXMethodDecl *MD = dyn_cast<CXXMethodDecl>(E->getMemberDecl())) {\n    if (MD->isStatic()) {\n      VisitIgnoredBaseExpression(E->getBase());\n      return Success(MD);\n    }\n  }\n\n  // Handle non-static data members.\n  return LValueExprEvaluatorBaseTy::VisitMemberExpr(E);\n}\n\nbool LValueExprEvaluator::VisitArraySubscriptExpr(const ArraySubscriptExpr *E) {\n  // FIXME: Deal with vectors as array subscript bases.\n  if (E->getBase()->getType()->isVectorType())\n    return Error(E);\n\n  APSInt Index;\n  bool Success = true;\n\n  // C++17's rules require us to evaluate the LHS first, regardless of which\n  // side is the base.\n  for (const Expr *SubExpr : {E->getLHS(), E->getRHS()}) {\n    if (SubExpr == E->getBase() ? !evaluatePointer(SubExpr, Result)\n                                : !EvaluateInteger(SubExpr, Index, Info)) {\n      if (!Info.noteFailure())\n        return false;\n      Success = false;\n    }\n  }\n\n  return Success &&\n         HandleLValueArrayAdjustment(Info, E, Result, E->getType(), Index);\n}\n\nbool LValueExprEvaluator::VisitUnaryDeref(const UnaryOperator *E) {\n  return evaluatePointer(E->getSubExpr(), Result);\n}\n\nbool LValueExprEvaluator::VisitUnaryReal(const UnaryOperator *E) {\n  if (!Visit(E->getSubExpr()))\n    return false;\n  // __real is a no-op on scalar lvalues.\n  if (E->getSubExpr()->getType()->isAnyComplexType())\n    HandleLValueComplexElement(Info, E, Result, E->getType(), false);\n  return true;\n}\n\nbool LValueExprEvaluator::VisitUnaryImag(const UnaryOperator *E) {\n  assert(E->getSubExpr()->getType()->isAnyComplexType() &&\n         \"lvalue __imag__ on scalar?\");\n  if (!Visit(E->getSubExpr()))\n    return false;\n  HandleLValueComplexElement(Info, E, Result, E->getType(), true);\n  return true;\n}\n\nbool LValueExprEvaluator::VisitUnaryPreIncDec(const UnaryOperator *UO) {\n  if (!Info.getLangOpts().CPlusPlus14 && !Info.keepEvaluatingAfterFailure())\n    return Error(UO);\n\n  if (!this->Visit(UO->getSubExpr()))\n    return false;\n\n  return handleIncDec(\n      this->Info, UO, Result, UO->getSubExpr()->getType(),\n      UO->isIncrementOp(), nullptr);\n}\n\nbool LValueExprEvaluator::VisitCompoundAssignOperator(\n    const CompoundAssignOperator *CAO) {\n  if (!Info.getLangOpts().CPlusPlus14 && !Info.keepEvaluatingAfterFailure())\n    return Error(CAO);\n\n  bool Success = true;\n\n  // C++17 onwards require that we evaluate the RHS first.\n  APValue RHS;\n  if (!Evaluate(RHS, this->Info, CAO->getRHS())) {\n    if (!Info.noteFailure())\n      return false;\n    Success = false;\n  }\n\n  // The overall lvalue result is the result of evaluating the LHS.\n  if (!this->Visit(CAO->getLHS()) || !Success)\n    return false;\n\n  return handleCompoundAssignment(\n      this->Info, CAO,\n      Result, CAO->getLHS()->getType(), CAO->getComputationLHSType(),\n      CAO->getOpForCompoundAssignment(CAO->getOpcode()), RHS);\n}\n\nbool LValueExprEvaluator::VisitBinAssign(const BinaryOperator *E) {\n  if (!Info.getLangOpts().CPlusPlus14 && !Info.keepEvaluatingAfterFailure())\n    return Error(E);\n\n  bool Success = true;\n\n  // C++17 onwards require that we evaluate the RHS first.\n  APValue NewVal;\n  if (!Evaluate(NewVal, this->Info, E->getRHS())) {\n    if (!Info.noteFailure())\n      return false;\n    Success = false;\n  }\n\n  if (!this->Visit(E->getLHS()) || !Success)\n    return false;\n\n  if (Info.getLangOpts().CPlusPlus20 &&\n      !HandleUnionActiveMemberChange(Info, E->getLHS(), Result))\n    return false;\n\n  return handleAssignment(this->Info, E, Result, E->getLHS()->getType(),\n                          NewVal);\n}\n\n//===----------------------------------------------------------------------===//\n// Pointer Evaluation\n//===----------------------------------------------------------------------===//\n\n/// Attempts to compute the number of bytes available at the pointer\n/// returned by a function with the alloc_size attribute. Returns true if we\n/// were successful. Places an unsigned number into `Result`.\n///\n/// This expects the given CallExpr to be a call to a function with an\n/// alloc_size attribute.\nstatic bool getBytesReturnedByAllocSizeCall(const ASTContext &Ctx,\n                                            const CallExpr *Call,\n                                            llvm::APInt &Result) {\n  const AllocSizeAttr *AllocSize = getAllocSizeAttr(Call);\n\n  assert(AllocSize && AllocSize->getElemSizeParam().isValid());\n  unsigned SizeArgNo = AllocSize->getElemSizeParam().getASTIndex();\n  unsigned BitsInSizeT = Ctx.getTypeSize(Ctx.getSizeType());\n  if (Call->getNumArgs() <= SizeArgNo)\n    return false;\n\n  auto EvaluateAsSizeT = [&](const Expr *E, APSInt &Into) {\n    Expr::EvalResult ExprResult;\n    if (!E->EvaluateAsInt(ExprResult, Ctx, Expr::SE_AllowSideEffects))\n      return false;\n    Into = ExprResult.Val.getInt();\n    if (Into.isNegative() || !Into.isIntN(BitsInSizeT))\n      return false;\n    Into = Into.zextOrSelf(BitsInSizeT);\n    return true;\n  };\n\n  APSInt SizeOfElem;\n  if (!EvaluateAsSizeT(Call->getArg(SizeArgNo), SizeOfElem))\n    return false;\n\n  if (!AllocSize->getNumElemsParam().isValid()) {\n    Result = std::move(SizeOfElem);\n    return true;\n  }\n\n  APSInt NumberOfElems;\n  unsigned NumArgNo = AllocSize->getNumElemsParam().getASTIndex();\n  if (!EvaluateAsSizeT(Call->getArg(NumArgNo), NumberOfElems))\n    return false;\n\n  bool Overflow;\n  llvm::APInt BytesAvailable = SizeOfElem.umul_ov(NumberOfElems, Overflow);\n  if (Overflow)\n    return false;\n\n  Result = std::move(BytesAvailable);\n  return true;\n}\n\n/// Convenience function. LVal's base must be a call to an alloc_size\n/// function.\nstatic bool getBytesReturnedByAllocSizeCall(const ASTContext &Ctx,\n                                            const LValue &LVal,\n                                            llvm::APInt &Result) {\n  assert(isBaseAnAllocSizeCall(LVal.getLValueBase()) &&\n         \"Can't get the size of a non alloc_size function\");\n  const auto *Base = LVal.getLValueBase().get<const Expr *>();\n  const CallExpr *CE = tryUnwrapAllocSizeCall(Base);\n  return getBytesReturnedByAllocSizeCall(Ctx, CE, Result);\n}\n\n/// Attempts to evaluate the given LValueBase as the result of a call to\n/// a function with the alloc_size attribute. If it was possible to do so, this\n/// function will return true, make Result's Base point to said function call,\n/// and mark Result's Base as invalid.\nstatic bool evaluateLValueAsAllocSize(EvalInfo &Info, APValue::LValueBase Base,\n                                      LValue &Result) {\n  if (Base.isNull())\n    return false;\n\n  // Because we do no form of static analysis, we only support const variables.\n  //\n  // Additionally, we can't support parameters, nor can we support static\n  // variables (in the latter case, use-before-assign isn't UB; in the former,\n  // we have no clue what they'll be assigned to).\n  const auto *VD =\n      dyn_cast_or_null<VarDecl>(Base.dyn_cast<const ValueDecl *>());\n  if (!VD || !VD->isLocalVarDecl() || !VD->getType().isConstQualified())\n    return false;\n\n  const Expr *Init = VD->getAnyInitializer();\n  if (!Init)\n    return false;\n\n  const Expr *E = Init->IgnoreParens();\n  if (!tryUnwrapAllocSizeCall(E))\n    return false;\n\n  // Store E instead of E unwrapped so that the type of the LValue's base is\n  // what the user wanted.\n  Result.setInvalid(E);\n\n  QualType Pointee = E->getType()->castAs<PointerType>()->getPointeeType();\n  Result.addUnsizedArray(Info, E, Pointee);\n  return true;\n}\n\nnamespace {\nclass PointerExprEvaluator\n  : public ExprEvaluatorBase<PointerExprEvaluator> {\n  LValue &Result;\n  bool InvalidBaseOK;\n\n  bool Success(const Expr *E) {\n    Result.set(E);\n    return true;\n  }\n\n  bool evaluateLValue(const Expr *E, LValue &Result) {\n    return EvaluateLValue(E, Result, Info, InvalidBaseOK);\n  }\n\n  bool evaluatePointer(const Expr *E, LValue &Result) {\n    return EvaluatePointer(E, Result, Info, InvalidBaseOK);\n  }\n\n  bool visitNonBuiltinCallExpr(const CallExpr *E);\npublic:\n\n  PointerExprEvaluator(EvalInfo &info, LValue &Result, bool InvalidBaseOK)\n      : ExprEvaluatorBaseTy(info), Result(Result),\n        InvalidBaseOK(InvalidBaseOK) {}\n\n  bool Success(const APValue &V, const Expr *E) {\n    Result.setFrom(Info.Ctx, V);\n    return true;\n  }\n  bool ZeroInitialization(const Expr *E) {\n    Result.setNull(Info.Ctx, E->getType());\n    return true;\n  }\n\n  bool VisitBinaryOperator(const BinaryOperator *E);\n  bool VisitCastExpr(const CastExpr* E);\n  bool VisitUnaryAddrOf(const UnaryOperator *E);\n  bool VisitObjCStringLiteral(const ObjCStringLiteral *E)\n      { return Success(E); }\n  bool VisitObjCBoxedExpr(const ObjCBoxedExpr *E) {\n    if (E->isExpressibleAsConstantInitializer())\n      return Success(E);\n    if (Info.noteFailure())\n      EvaluateIgnoredValue(Info, E->getSubExpr());\n    return Error(E);\n  }\n  bool VisitAddrLabelExpr(const AddrLabelExpr *E)\n      { return Success(E); }\n  bool VisitCallExpr(const CallExpr *E);\n  bool VisitBuiltinCallExpr(const CallExpr *E, unsigned BuiltinOp);\n  bool VisitBlockExpr(const BlockExpr *E) {\n    if (!E->getBlockDecl()->hasCaptures())\n      return Success(E);\n    return Error(E);\n  }\n  bool VisitCXXThisExpr(const CXXThisExpr *E) {\n    // Can't look at 'this' when checking a potential constant expression.\n    if (Info.checkingPotentialConstantExpression())\n      return false;\n    if (!Info.CurrentCall->This) {\n      if (Info.getLangOpts().CPlusPlus11)\n        Info.FFDiag(E, diag::note_constexpr_this) << E->isImplicit();\n      else\n        Info.FFDiag(E);\n      return false;\n    }\n    Result = *Info.CurrentCall->This;\n    // If we are inside a lambda's call operator, the 'this' expression refers\n    // to the enclosing '*this' object (either by value or reference) which is\n    // either copied into the closure object's field that represents the '*this'\n    // or refers to '*this'.\n    if (isLambdaCallOperator(Info.CurrentCall->Callee)) {\n      // Ensure we actually have captured 'this'. (an error will have\n      // been previously reported if not).\n      if (!Info.CurrentCall->LambdaThisCaptureField)\n        return false;\n\n      // Update 'Result' to refer to the data member/field of the closure object\n      // that represents the '*this' capture.\n      if (!HandleLValueMember(Info, E, Result,\n                             Info.CurrentCall->LambdaThisCaptureField))\n        return false;\n      // If we captured '*this' by reference, replace the field with its referent.\n      if (Info.CurrentCall->LambdaThisCaptureField->getType()\n              ->isPointerType()) {\n        APValue RVal;\n        if (!handleLValueToRValueConversion(Info, E, E->getType(), Result,\n                                            RVal))\n          return false;\n\n        Result.setFrom(Info.Ctx, RVal);\n      }\n    }\n    return true;\n  }\n\n  bool VisitCXXNewExpr(const CXXNewExpr *E);\n\n  bool VisitSourceLocExpr(const SourceLocExpr *E) {\n    assert(E->isStringType() && \"SourceLocExpr isn't a pointer type?\");\n    APValue LValResult = E->EvaluateInContext(\n        Info.Ctx, Info.CurrentCall->CurSourceLocExprScope.getDefaultExpr());\n    Result.setFrom(Info.Ctx, LValResult);\n    return true;\n  }\n\n  // FIXME: Missing: @protocol, @selector\n};\n} // end anonymous namespace\n\nstatic bool EvaluatePointer(const Expr* E, LValue& Result, EvalInfo &Info,\n                            bool InvalidBaseOK) {\n  assert(!E->isValueDependent());\n  assert(E->isRValue() && E->getType()->hasPointerRepresentation());\n  return PointerExprEvaluator(Info, Result, InvalidBaseOK).Visit(E);\n}\n\nbool PointerExprEvaluator::VisitBinaryOperator(const BinaryOperator *E) {\n  if (E->getOpcode() != BO_Add &&\n      E->getOpcode() != BO_Sub)\n    return ExprEvaluatorBaseTy::VisitBinaryOperator(E);\n\n  const Expr *PExp = E->getLHS();\n  const Expr *IExp = E->getRHS();\n  if (IExp->getType()->isPointerType())\n    std::swap(PExp, IExp);\n\n  bool EvalPtrOK = evaluatePointer(PExp, Result);\n  if (!EvalPtrOK && !Info.noteFailure())\n    return false;\n\n  llvm::APSInt Offset;\n  if (!EvaluateInteger(IExp, Offset, Info) || !EvalPtrOK)\n    return false;\n\n  if (E->getOpcode() == BO_Sub)\n    negateAsSigned(Offset);\n\n  QualType Pointee = PExp->getType()->castAs<PointerType>()->getPointeeType();\n  return HandleLValueArrayAdjustment(Info, E, Result, Pointee, Offset);\n}\n\nbool PointerExprEvaluator::VisitUnaryAddrOf(const UnaryOperator *E) {\n  return evaluateLValue(E->getSubExpr(), Result);\n}\n\nbool PointerExprEvaluator::VisitCastExpr(const CastExpr *E) {\n  const Expr *SubExpr = E->getSubExpr();\n\n  switch (E->getCastKind()) {\n  default:\n    break;\n  case CK_BitCast:\n  case CK_CPointerToObjCPointerCast:\n  case CK_BlockPointerToObjCPointerCast:\n  case CK_AnyPointerToBlockPointerCast:\n  case CK_AddressSpaceConversion:\n    if (!Visit(SubExpr))\n      return false;\n    // Bitcasts to cv void* are static_casts, not reinterpret_casts, so are\n    // permitted in constant expressions in C++11. Bitcasts from cv void* are\n    // also static_casts, but we disallow them as a resolution to DR1312.\n    if (!E->getType()->isVoidPointerType()) {\n      if (!Result.InvalidBase && !Result.Designator.Invalid &&\n          !Result.IsNullPtr &&\n          Info.Ctx.hasSameUnqualifiedType(Result.Designator.getType(Info.Ctx),\n                                          E->getType()->getPointeeType()) &&\n          Info.getStdAllocatorCaller(\"allocate\")) {\n        // Inside a call to std::allocator::allocate and friends, we permit\n        // casting from void* back to cv1 T* for a pointer that points to a\n        // cv2 T.\n      } else {\n        Result.Designator.setInvalid();\n        if (SubExpr->getType()->isVoidPointerType())\n          CCEDiag(E, diag::note_constexpr_invalid_cast)\n            << 3 << SubExpr->getType();\n        else\n          CCEDiag(E, diag::note_constexpr_invalid_cast) << 2;\n      }\n    }\n    if (E->getCastKind() == CK_AddressSpaceConversion && Result.IsNullPtr)\n      ZeroInitialization(E);\n    return true;\n\n  case CK_DerivedToBase:\n  case CK_UncheckedDerivedToBase:\n    if (!evaluatePointer(E->getSubExpr(), Result))\n      return false;\n    if (!Result.Base && Result.Offset.isZero())\n      return true;\n\n    // Now figure out the necessary offset to add to the base LV to get from\n    // the derived class to the base class.\n    return HandleLValueBasePath(Info, E, E->getSubExpr()->getType()->\n                                  castAs<PointerType>()->getPointeeType(),\n                                Result);\n\n  case CK_BaseToDerived:\n    if (!Visit(E->getSubExpr()))\n      return false;\n    if (!Result.Base && Result.Offset.isZero())\n      return true;\n    return HandleBaseToDerivedCast(Info, E, Result);\n\n  case CK_Dynamic:\n    if (!Visit(E->getSubExpr()))\n      return false;\n    return HandleDynamicCast(Info, cast<ExplicitCastExpr>(E), Result);\n\n  case CK_NullToPointer:\n    VisitIgnoredValue(E->getSubExpr());\n    return ZeroInitialization(E);\n\n  case CK_IntegralToPointer: {\n    CCEDiag(E, diag::note_constexpr_invalid_cast) << 2;\n\n    APValue Value;\n    if (!EvaluateIntegerOrLValue(SubExpr, Value, Info))\n      break;\n\n    if (Value.isInt()) {\n      unsigned Size = Info.Ctx.getTypeSize(E->getType());\n      uint64_t N = Value.getInt().extOrTrunc(Size).getZExtValue();\n      Result.Base = (Expr*)nullptr;\n      Result.InvalidBase = false;\n      Result.Offset = CharUnits::fromQuantity(N);\n      Result.Designator.setInvalid();\n      Result.IsNullPtr = false;\n      return true;\n    } else {\n      // Cast is of an lvalue, no need to change value.\n      Result.setFrom(Info.Ctx, Value);\n      return true;\n    }\n  }\n\n  case CK_ArrayToPointerDecay: {\n    if (SubExpr->isGLValue()) {\n      if (!evaluateLValue(SubExpr, Result))\n        return false;\n    } else {\n      APValue &Value = Info.CurrentCall->createTemporary(\n          SubExpr, SubExpr->getType(), ScopeKind::FullExpression, Result);\n      if (!EvaluateInPlace(Value, Info, Result, SubExpr))\n        return false;\n    }\n    // The result is a pointer to the first element of the array.\n    auto *AT = Info.Ctx.getAsArrayType(SubExpr->getType());\n    if (auto *CAT = dyn_cast<ConstantArrayType>(AT))\n      Result.addArray(Info, E, CAT);\n    else\n      Result.addUnsizedArray(Info, E, AT->getElementType());\n    return true;\n  }\n\n  case CK_FunctionToPointerDecay:\n    return evaluateLValue(SubExpr, Result);\n\n  case CK_LValueToRValue: {\n    LValue LVal;\n    if (!evaluateLValue(E->getSubExpr(), LVal))\n      return false;\n\n    APValue RVal;\n    // Note, we use the subexpression's type in order to retain cv-qualifiers.\n    if (!handleLValueToRValueConversion(Info, E, E->getSubExpr()->getType(),\n                                        LVal, RVal))\n      return InvalidBaseOK &&\n             evaluateLValueAsAllocSize(Info, LVal.Base, Result);\n    return Success(RVal, E);\n  }\n  }\n\n  return ExprEvaluatorBaseTy::VisitCastExpr(E);\n}\n\nstatic CharUnits GetAlignOfType(EvalInfo &Info, QualType T,\n                                UnaryExprOrTypeTrait ExprKind) {\n  // C++ [expr.alignof]p3:\n  //     When alignof is applied to a reference type, the result is the\n  //     alignment of the referenced type.\n  if (const ReferenceType *Ref = T->getAs<ReferenceType>())\n    T = Ref->getPointeeType();\n\n  if (T.getQualifiers().hasUnaligned())\n    return CharUnits::One();\n\n  const bool AlignOfReturnsPreferred =\n      Info.Ctx.getLangOpts().getClangABICompat() <= LangOptions::ClangABI::Ver7;\n\n  // __alignof is defined to return the preferred alignment.\n  // Before 8, clang returned the preferred alignment for alignof and _Alignof\n  // as well.\n  if (ExprKind == UETT_PreferredAlignOf || AlignOfReturnsPreferred)\n    return Info.Ctx.toCharUnitsFromBits(\n      Info.Ctx.getPreferredTypeAlign(T.getTypePtr()));\n  // alignof and _Alignof are defined to return the ABI alignment.\n  else if (ExprKind == UETT_AlignOf)\n    return Info.Ctx.getTypeAlignInChars(T.getTypePtr());\n  else\n    llvm_unreachable(\"GetAlignOfType on a non-alignment ExprKind\");\n}\n\nstatic CharUnits GetAlignOfExpr(EvalInfo &Info, const Expr *E,\n                                UnaryExprOrTypeTrait ExprKind) {\n  E = E->IgnoreParens();\n\n  // The kinds of expressions that we have special-case logic here for\n  // should be kept up to date with the special checks for those\n  // expressions in Sema.\n\n  // alignof decl is always accepted, even if it doesn't make sense: we default\n  // to 1 in those cases.\n  if (const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(E))\n    return Info.Ctx.getDeclAlign(DRE->getDecl(),\n                                 /*RefAsPointee*/true);\n\n  if (const MemberExpr *ME = dyn_cast<MemberExpr>(E))\n    return Info.Ctx.getDeclAlign(ME->getMemberDecl(),\n                                 /*RefAsPointee*/true);\n\n  return GetAlignOfType(Info, E->getType(), ExprKind);\n}\n\nstatic CharUnits getBaseAlignment(EvalInfo &Info, const LValue &Value) {\n  if (const auto *VD = Value.Base.dyn_cast<const ValueDecl *>())\n    return Info.Ctx.getDeclAlign(VD);\n  if (const auto *E = Value.Base.dyn_cast<const Expr *>())\n    return GetAlignOfExpr(Info, E, UETT_AlignOf);\n  return GetAlignOfType(Info, Value.Base.getTypeInfoType(), UETT_AlignOf);\n}\n\n/// Evaluate the value of the alignment argument to __builtin_align_{up,down},\n/// __builtin_is_aligned and __builtin_assume_aligned.\nstatic bool getAlignmentArgument(const Expr *E, QualType ForType,\n                                 EvalInfo &Info, APSInt &Alignment) {\n  if (!EvaluateInteger(E, Alignment, Info))\n    return false;\n  if (Alignment < 0 || !Alignment.isPowerOf2()) {\n    Info.FFDiag(E, diag::note_constexpr_invalid_alignment) << Alignment;\n    return false;\n  }\n  unsigned SrcWidth = Info.Ctx.getIntWidth(ForType);\n  APSInt MaxValue(APInt::getOneBitSet(SrcWidth, SrcWidth - 1));\n  if (APSInt::compareValues(Alignment, MaxValue) > 0) {\n    Info.FFDiag(E, diag::note_constexpr_alignment_too_big)\n        << MaxValue << ForType << Alignment;\n    return false;\n  }\n  // Ensure both alignment and source value have the same bit width so that we\n  // don't assert when computing the resulting value.\n  APSInt ExtAlignment =\n      APSInt(Alignment.zextOrTrunc(SrcWidth), /*isUnsigned=*/true);\n  assert(APSInt::compareValues(Alignment, ExtAlignment) == 0 &&\n         \"Alignment should not be changed by ext/trunc\");\n  Alignment = ExtAlignment;\n  assert(Alignment.getBitWidth() == SrcWidth);\n  return true;\n}\n\n// To be clear: this happily visits unsupported builtins. Better name welcomed.\nbool PointerExprEvaluator::visitNonBuiltinCallExpr(const CallExpr *E) {\n  if (ExprEvaluatorBaseTy::VisitCallExpr(E))\n    return true;\n\n  if (!(InvalidBaseOK && getAllocSizeAttr(E)))\n    return false;\n\n  Result.setInvalid(E);\n  QualType PointeeTy = E->getType()->castAs<PointerType>()->getPointeeType();\n  Result.addUnsizedArray(Info, E, PointeeTy);\n  return true;\n}\n\nbool PointerExprEvaluator::VisitCallExpr(const CallExpr *E) {\n  if (IsStringLiteralCall(E))\n    return Success(E);\n\n  if (unsigned BuiltinOp = E->getBuiltinCallee())\n    return VisitBuiltinCallExpr(E, BuiltinOp);\n\n  return visitNonBuiltinCallExpr(E);\n}\n\n// Determine if T is a character type for which we guarantee that\n// sizeof(T) == 1.\nstatic bool isOneByteCharacterType(QualType T) {\n  return T->isCharType() || T->isChar8Type();\n}\n\nbool PointerExprEvaluator::VisitBuiltinCallExpr(const CallExpr *E,\n                                                unsigned BuiltinOp) {\n  switch (BuiltinOp) {\n  case Builtin::BI__builtin_addressof:\n    return evaluateLValue(E->getArg(0), Result);\n  case Builtin::BI__builtin_assume_aligned: {\n    // We need to be very careful here because: if the pointer does not have the\n    // asserted alignment, then the behavior is undefined, and undefined\n    // behavior is non-constant.\n    if (!evaluatePointer(E->getArg(0), Result))\n      return false;\n\n    LValue OffsetResult(Result);\n    APSInt Alignment;\n    if (!getAlignmentArgument(E->getArg(1), E->getArg(0)->getType(), Info,\n                              Alignment))\n      return false;\n    CharUnits Align = CharUnits::fromQuantity(Alignment.getZExtValue());\n\n    if (E->getNumArgs() > 2) {\n      APSInt Offset;\n      if (!EvaluateInteger(E->getArg(2), Offset, Info))\n        return false;\n\n      int64_t AdditionalOffset = -Offset.getZExtValue();\n      OffsetResult.Offset += CharUnits::fromQuantity(AdditionalOffset);\n    }\n\n    // If there is a base object, then it must have the correct alignment.\n    if (OffsetResult.Base) {\n      CharUnits BaseAlignment = getBaseAlignment(Info, OffsetResult);\n\n      if (BaseAlignment < Align) {\n        Result.Designator.setInvalid();\n        // FIXME: Add support to Diagnostic for long / long long.\n        CCEDiag(E->getArg(0),\n                diag::note_constexpr_baa_insufficient_alignment) << 0\n          << (unsigned)BaseAlignment.getQuantity()\n          << (unsigned)Align.getQuantity();\n        return false;\n      }\n    }\n\n    // The offset must also have the correct alignment.\n    if (OffsetResult.Offset.alignTo(Align) != OffsetResult.Offset) {\n      Result.Designator.setInvalid();\n\n      (OffsetResult.Base\n           ? CCEDiag(E->getArg(0),\n                     diag::note_constexpr_baa_insufficient_alignment) << 1\n           : CCEDiag(E->getArg(0),\n                     diag::note_constexpr_baa_value_insufficient_alignment))\n        << (int)OffsetResult.Offset.getQuantity()\n        << (unsigned)Align.getQuantity();\n      return false;\n    }\n\n    return true;\n  }\n  case Builtin::BI__builtin_align_up:\n  case Builtin::BI__builtin_align_down: {\n    if (!evaluatePointer(E->getArg(0), Result))\n      return false;\n    APSInt Alignment;\n    if (!getAlignmentArgument(E->getArg(1), E->getArg(0)->getType(), Info,\n                              Alignment))\n      return false;\n    CharUnits BaseAlignment = getBaseAlignment(Info, Result);\n    CharUnits PtrAlign = BaseAlignment.alignmentAtOffset(Result.Offset);\n    // For align_up/align_down, we can return the same value if the alignment\n    // is known to be greater or equal to the requested value.\n    if (PtrAlign.getQuantity() >= Alignment)\n      return true;\n\n    // The alignment could be greater than the minimum at run-time, so we cannot\n    // infer much about the resulting pointer value. One case is possible:\n    // For `_Alignas(32) char buf[N]; __builtin_align_down(&buf[idx], 32)` we\n    // can infer the correct index if the requested alignment is smaller than\n    // the base alignment so we can perform the computation on the offset.\n    if (BaseAlignment.getQuantity() >= Alignment) {\n      assert(Alignment.getBitWidth() <= 64 &&\n             \"Cannot handle > 64-bit address-space\");\n      uint64_t Alignment64 = Alignment.getZExtValue();\n      CharUnits NewOffset = CharUnits::fromQuantity(\n          BuiltinOp == Builtin::BI__builtin_align_down\n              ? llvm::alignDown(Result.Offset.getQuantity(), Alignment64)\n              : llvm::alignTo(Result.Offset.getQuantity(), Alignment64));\n      Result.adjustOffset(NewOffset - Result.Offset);\n      // TODO: diagnose out-of-bounds values/only allow for arrays?\n      return true;\n    }\n    // Otherwise, we cannot constant-evaluate the result.\n    Info.FFDiag(E->getArg(0), diag::note_constexpr_alignment_adjust)\n        << Alignment;\n    return false;\n  }\n  case Builtin::BI__builtin_operator_new:\n    return HandleOperatorNewCall(Info, E, Result);\n  case Builtin::BI__builtin_launder:\n    return evaluatePointer(E->getArg(0), Result);\n  case Builtin::BIstrchr:\n  case Builtin::BIwcschr:\n  case Builtin::BImemchr:\n  case Builtin::BIwmemchr:\n    if (Info.getLangOpts().CPlusPlus11)\n      Info.CCEDiag(E, diag::note_constexpr_invalid_function)\n        << /*isConstexpr*/0 << /*isConstructor*/0\n        << (std::string(\"'\") + Info.Ctx.BuiltinInfo.getName(BuiltinOp) + \"'\");\n    else\n      Info.CCEDiag(E, diag::note_invalid_subexpr_in_const_expr);\n    LLVM_FALLTHROUGH;\n  case Builtin::BI__builtin_strchr:\n  case Builtin::BI__builtin_wcschr:\n  case Builtin::BI__builtin_memchr:\n  case Builtin::BI__builtin_char_memchr:\n  case Builtin::BI__builtin_wmemchr: {\n    if (!Visit(E->getArg(0)))\n      return false;\n    APSInt Desired;\n    if (!EvaluateInteger(E->getArg(1), Desired, Info))\n      return false;\n    uint64_t MaxLength = uint64_t(-1);\n    if (BuiltinOp != Builtin::BIstrchr &&\n        BuiltinOp != Builtin::BIwcschr &&\n        BuiltinOp != Builtin::BI__builtin_strchr &&\n        BuiltinOp != Builtin::BI__builtin_wcschr) {\n      APSInt N;\n      if (!EvaluateInteger(E->getArg(2), N, Info))\n        return false;\n      MaxLength = N.getExtValue();\n    }\n    // We cannot find the value if there are no candidates to match against.\n    if (MaxLength == 0u)\n      return ZeroInitialization(E);\n    if (!Result.checkNullPointerForFoldAccess(Info, E, AK_Read) ||\n        Result.Designator.Invalid)\n      return false;\n    QualType CharTy = Result.Designator.getType(Info.Ctx);\n    bool IsRawByte = BuiltinOp == Builtin::BImemchr ||\n                     BuiltinOp == Builtin::BI__builtin_memchr;\n    assert(IsRawByte ||\n           Info.Ctx.hasSameUnqualifiedType(\n               CharTy, E->getArg(0)->getType()->getPointeeType()));\n    // Pointers to const void may point to objects of incomplete type.\n    if (IsRawByte && CharTy->isIncompleteType()) {\n      Info.FFDiag(E, diag::note_constexpr_ltor_incomplete_type) << CharTy;\n      return false;\n    }\n    // Give up on byte-oriented matching against multibyte elements.\n    // FIXME: We can compare the bytes in the correct order.\n    if (IsRawByte && !isOneByteCharacterType(CharTy)) {\n      Info.FFDiag(E, diag::note_constexpr_memchr_unsupported)\n          << (std::string(\"'\") + Info.Ctx.BuiltinInfo.getName(BuiltinOp) + \"'\")\n          << CharTy;\n      return false;\n    }\n    // Figure out what value we're actually looking for (after converting to\n    // the corresponding unsigned type if necessary).\n    uint64_t DesiredVal;\n    bool StopAtNull = false;\n    switch (BuiltinOp) {\n    case Builtin::BIstrchr:\n    case Builtin::BI__builtin_strchr:\n      // strchr compares directly to the passed integer, and therefore\n      // always fails if given an int that is not a char.\n      if (!APSInt::isSameValue(HandleIntToIntCast(Info, E, CharTy,\n                                                  E->getArg(1)->getType(),\n                                                  Desired),\n                               Desired))\n        return ZeroInitialization(E);\n      StopAtNull = true;\n      LLVM_FALLTHROUGH;\n    case Builtin::BImemchr:\n    case Builtin::BI__builtin_memchr:\n    case Builtin::BI__builtin_char_memchr:\n      // memchr compares by converting both sides to unsigned char. That's also\n      // correct for strchr if we get this far (to cope with plain char being\n      // unsigned in the strchr case).\n      DesiredVal = Desired.trunc(Info.Ctx.getCharWidth()).getZExtValue();\n      break;\n\n    case Builtin::BIwcschr:\n    case Builtin::BI__builtin_wcschr:\n      StopAtNull = true;\n      LLVM_FALLTHROUGH;\n    case Builtin::BIwmemchr:\n    case Builtin::BI__builtin_wmemchr:\n      // wcschr and wmemchr are given a wchar_t to look for. Just use it.\n      DesiredVal = Desired.getZExtValue();\n      break;\n    }\n\n    for (; MaxLength; --MaxLength) {\n      APValue Char;\n      if (!handleLValueToRValueConversion(Info, E, CharTy, Result, Char) ||\n          !Char.isInt())\n        return false;\n      if (Char.getInt().getZExtValue() == DesiredVal)\n        return true;\n      if (StopAtNull && !Char.getInt())\n        break;\n      if (!HandleLValueArrayAdjustment(Info, E, Result, CharTy, 1))\n        return false;\n    }\n    // Not found: return nullptr.\n    return ZeroInitialization(E);\n  }\n\n  case Builtin::BImemcpy:\n  case Builtin::BImemmove:\n  case Builtin::BIwmemcpy:\n  case Builtin::BIwmemmove:\n    if (Info.getLangOpts().CPlusPlus11)\n      Info.CCEDiag(E, diag::note_constexpr_invalid_function)\n        << /*isConstexpr*/0 << /*isConstructor*/0\n        << (std::string(\"'\") + Info.Ctx.BuiltinInfo.getName(BuiltinOp) + \"'\");\n    else\n      Info.CCEDiag(E, diag::note_invalid_subexpr_in_const_expr);\n    LLVM_FALLTHROUGH;\n  case Builtin::BI__builtin_memcpy:\n  case Builtin::BI__builtin_memmove:\n  case Builtin::BI__builtin_wmemcpy:\n  case Builtin::BI__builtin_wmemmove: {\n    bool WChar = BuiltinOp == Builtin::BIwmemcpy ||\n                 BuiltinOp == Builtin::BIwmemmove ||\n                 BuiltinOp == Builtin::BI__builtin_wmemcpy ||\n                 BuiltinOp == Builtin::BI__builtin_wmemmove;\n    bool Move = BuiltinOp == Builtin::BImemmove ||\n                BuiltinOp == Builtin::BIwmemmove ||\n                BuiltinOp == Builtin::BI__builtin_memmove ||\n                BuiltinOp == Builtin::BI__builtin_wmemmove;\n\n    // The result of mem* is the first argument.\n    if (!Visit(E->getArg(0)))\n      return false;\n    LValue Dest = Result;\n\n    LValue Src;\n    if (!EvaluatePointer(E->getArg(1), Src, Info))\n      return false;\n\n    APSInt N;\n    if (!EvaluateInteger(E->getArg(2), N, Info))\n      return false;\n    assert(!N.isSigned() && \"memcpy and friends take an unsigned size\");\n\n    // If the size is zero, we treat this as always being a valid no-op.\n    // (Even if one of the src and dest pointers is null.)\n    if (!N)\n      return true;\n\n    // Otherwise, if either of the operands is null, we can't proceed. Don't\n    // try to determine the type of the copied objects, because there aren't\n    // any.\n    if (!Src.Base || !Dest.Base) {\n      APValue Val;\n      (!Src.Base ? Src : Dest).moveInto(Val);\n      Info.FFDiag(E, diag::note_constexpr_memcpy_null)\n          << Move << WChar << !!Src.Base\n          << Val.getAsString(Info.Ctx, E->getArg(0)->getType());\n      return false;\n    }\n    if (Src.Designator.Invalid || Dest.Designator.Invalid)\n      return false;\n\n    // We require that Src and Dest are both pointers to arrays of\n    // trivially-copyable type. (For the wide version, the designator will be\n    // invalid if the designated object is not a wchar_t.)\n    QualType T = Dest.Designator.getType(Info.Ctx);\n    QualType SrcT = Src.Designator.getType(Info.Ctx);\n    if (!Info.Ctx.hasSameUnqualifiedType(T, SrcT)) {\n      // FIXME: Consider using our bit_cast implementation to support this.\n      Info.FFDiag(E, diag::note_constexpr_memcpy_type_pun) << Move << SrcT << T;\n      return false;\n    }\n    if (T->isIncompleteType()) {\n      Info.FFDiag(E, diag::note_constexpr_memcpy_incomplete_type) << Move << T;\n      return false;\n    }\n    if (!T.isTriviallyCopyableType(Info.Ctx)) {\n      Info.FFDiag(E, diag::note_constexpr_memcpy_nontrivial) << Move << T;\n      return false;\n    }\n\n    // Figure out how many T's we're copying.\n    uint64_t TSize = Info.Ctx.getTypeSizeInChars(T).getQuantity();\n    if (!WChar) {\n      uint64_t Remainder;\n      llvm::APInt OrigN = N;\n      llvm::APInt::udivrem(OrigN, TSize, N, Remainder);\n      if (Remainder) {\n        Info.FFDiag(E, diag::note_constexpr_memcpy_unsupported)\n            << Move << WChar << 0 << T << OrigN.toString(10, /*Signed*/false)\n            << (unsigned)TSize;\n        return false;\n      }\n    }\n\n    // Check that the copying will remain within the arrays, just so that we\n    // can give a more meaningful diagnostic. This implicitly also checks that\n    // N fits into 64 bits.\n    uint64_t RemainingSrcSize = Src.Designator.validIndexAdjustments().second;\n    uint64_t RemainingDestSize = Dest.Designator.validIndexAdjustments().second;\n    if (N.ugt(RemainingSrcSize) || N.ugt(RemainingDestSize)) {\n      Info.FFDiag(E, diag::note_constexpr_memcpy_unsupported)\n          << Move << WChar << (N.ugt(RemainingSrcSize) ? 1 : 2) << T\n          << N.toString(10, /*Signed*/false);\n      return false;\n    }\n    uint64_t NElems = N.getZExtValue();\n    uint64_t NBytes = NElems * TSize;\n\n    // Check for overlap.\n    int Direction = 1;\n    if (HasSameBase(Src, Dest)) {\n      uint64_t SrcOffset = Src.getLValueOffset().getQuantity();\n      uint64_t DestOffset = Dest.getLValueOffset().getQuantity();\n      if (DestOffset >= SrcOffset && DestOffset - SrcOffset < NBytes) {\n        // Dest is inside the source region.\n        if (!Move) {\n          Info.FFDiag(E, diag::note_constexpr_memcpy_overlap) << WChar;\n          return false;\n        }\n        // For memmove and friends, copy backwards.\n        if (!HandleLValueArrayAdjustment(Info, E, Src, T, NElems - 1) ||\n            !HandleLValueArrayAdjustment(Info, E, Dest, T, NElems - 1))\n          return false;\n        Direction = -1;\n      } else if (!Move && SrcOffset >= DestOffset &&\n                 SrcOffset - DestOffset < NBytes) {\n        // Src is inside the destination region for memcpy: invalid.\n        Info.FFDiag(E, diag::note_constexpr_memcpy_overlap) << WChar;\n        return false;\n      }\n    }\n\n    while (true) {\n      APValue Val;\n      // FIXME: Set WantObjectRepresentation to true if we're copying a\n      // char-like type?\n      if (!handleLValueToRValueConversion(Info, E, T, Src, Val) ||\n          !handleAssignment(Info, E, Dest, T, Val))\n        return false;\n      // Do not iterate past the last element; if we're copying backwards, that\n      // might take us off the start of the array.\n      if (--NElems == 0)\n        return true;\n      if (!HandleLValueArrayAdjustment(Info, E, Src, T, Direction) ||\n          !HandleLValueArrayAdjustment(Info, E, Dest, T, Direction))\n        return false;\n    }\n  }\n\n  default:\n    break;\n  }\n\n  return visitNonBuiltinCallExpr(E);\n}\n\nstatic bool EvaluateArrayNewInitList(EvalInfo &Info, LValue &This,\n                                     APValue &Result, const InitListExpr *ILE,\n                                     QualType AllocType);\nstatic bool EvaluateArrayNewConstructExpr(EvalInfo &Info, LValue &This,\n                                          APValue &Result,\n                                          const CXXConstructExpr *CCE,\n                                          QualType AllocType);\n\nbool PointerExprEvaluator::VisitCXXNewExpr(const CXXNewExpr *E) {\n  if (!Info.getLangOpts().CPlusPlus20)\n    Info.CCEDiag(E, diag::note_constexpr_new);\n\n  // We cannot speculatively evaluate a delete expression.\n  if (Info.SpeculativeEvaluationDepth)\n    return false;\n\n  FunctionDecl *OperatorNew = E->getOperatorNew();\n\n  bool IsNothrow = false;\n  bool IsPlacement = false;\n  if (OperatorNew->isReservedGlobalPlacementOperator() &&\n      Info.CurrentCall->isStdFunction() && !E->isArray()) {\n    // FIXME Support array placement new.\n    assert(E->getNumPlacementArgs() == 1);\n    if (!EvaluatePointer(E->getPlacementArg(0), Result, Info))\n      return false;\n    if (Result.Designator.Invalid)\n      return false;\n    IsPlacement = true;\n  } else if (!OperatorNew->isReplaceableGlobalAllocationFunction()) {\n    Info.FFDiag(E, diag::note_constexpr_new_non_replaceable)\n        << isa<CXXMethodDecl>(OperatorNew) << OperatorNew;\n    return false;\n  } else if (E->getNumPlacementArgs()) {\n    // The only new-placement list we support is of the form (std::nothrow).\n    //\n    // FIXME: There is no restriction on this, but it's not clear that any\n    // other form makes any sense. We get here for cases such as:\n    //\n    //   new (std::align_val_t{N}) X(int)\n    //\n    // (which should presumably be valid only if N is a multiple of\n    // alignof(int), and in any case can't be deallocated unless N is\n    // alignof(X) and X has new-extended alignment).\n    if (E->getNumPlacementArgs() != 1 ||\n        !E->getPlacementArg(0)->getType()->isNothrowT())\n      return Error(E, diag::note_constexpr_new_placement);\n\n    LValue Nothrow;\n    if (!EvaluateLValue(E->getPlacementArg(0), Nothrow, Info))\n      return false;\n    IsNothrow = true;\n  }\n\n  const Expr *Init = E->getInitializer();\n  const InitListExpr *ResizedArrayILE = nullptr;\n  const CXXConstructExpr *ResizedArrayCCE = nullptr;\n  bool ValueInit = false;\n\n  QualType AllocType = E->getAllocatedType();\n  if (Optional<const Expr*> ArraySize = E->getArraySize()) {\n    const Expr *Stripped = *ArraySize;\n    for (; auto *ICE = dyn_cast<ImplicitCastExpr>(Stripped);\n         Stripped = ICE->getSubExpr())\n      if (ICE->getCastKind() != CK_NoOp &&\n          ICE->getCastKind() != CK_IntegralCast)\n        break;\n\n    llvm::APSInt ArrayBound;\n    if (!EvaluateInteger(Stripped, ArrayBound, Info))\n      return false;\n\n    // C++ [expr.new]p9:\n    //   The expression is erroneous if:\n    //   -- [...] its value before converting to size_t [or] applying the\n    //      second standard conversion sequence is less than zero\n    if (ArrayBound.isSigned() && ArrayBound.isNegative()) {\n      if (IsNothrow)\n        return ZeroInitialization(E);\n\n      Info.FFDiag(*ArraySize, diag::note_constexpr_new_negative)\n          << ArrayBound << (*ArraySize)->getSourceRange();\n      return false;\n    }\n\n    //   -- its value is such that the size of the allocated object would\n    //      exceed the implementation-defined limit\n    if (ConstantArrayType::getNumAddressingBits(Info.Ctx, AllocType,\n                                                ArrayBound) >\n        ConstantArrayType::getMaxSizeBits(Info.Ctx)) {\n      if (IsNothrow)\n        return ZeroInitialization(E);\n\n      Info.FFDiag(*ArraySize, diag::note_constexpr_new_too_large)\n        << ArrayBound << (*ArraySize)->getSourceRange();\n      return false;\n    }\n\n    //   -- the new-initializer is a braced-init-list and the number of\n    //      array elements for which initializers are provided [...]\n    //      exceeds the number of elements to initialize\n    if (!Init) {\n      // No initialization is performed.\n    } else if (isa<CXXScalarValueInitExpr>(Init) ||\n               isa<ImplicitValueInitExpr>(Init)) {\n      ValueInit = true;\n    } else if (auto *CCE = dyn_cast<CXXConstructExpr>(Init)) {\n      ResizedArrayCCE = CCE;\n    } else {\n      auto *CAT = Info.Ctx.getAsConstantArrayType(Init->getType());\n      assert(CAT && \"unexpected type for array initializer\");\n\n      unsigned Bits =\n          std::max(CAT->getSize().getBitWidth(), ArrayBound.getBitWidth());\n      llvm::APInt InitBound = CAT->getSize().zextOrSelf(Bits);\n      llvm::APInt AllocBound = ArrayBound.zextOrSelf(Bits);\n      if (InitBound.ugt(AllocBound)) {\n        if (IsNothrow)\n          return ZeroInitialization(E);\n\n        Info.FFDiag(*ArraySize, diag::note_constexpr_new_too_small)\n            << AllocBound.toString(10, /*Signed=*/false)\n            << InitBound.toString(10, /*Signed=*/false)\n            << (*ArraySize)->getSourceRange();\n        return false;\n      }\n\n      // If the sizes differ, we must have an initializer list, and we need\n      // special handling for this case when we initialize.\n      if (InitBound != AllocBound)\n        ResizedArrayILE = cast<InitListExpr>(Init);\n    }\n\n    AllocType = Info.Ctx.getConstantArrayType(AllocType, ArrayBound, nullptr,\n                                              ArrayType::Normal, 0);\n  } else {\n    assert(!AllocType->isArrayType() &&\n           \"array allocation with non-array new\");\n  }\n\n  APValue *Val;\n  if (IsPlacement) {\n    AccessKinds AK = AK_Construct;\n    struct FindObjectHandler {\n      EvalInfo &Info;\n      const Expr *E;\n      QualType AllocType;\n      const AccessKinds AccessKind;\n      APValue *Value;\n\n      typedef bool result_type;\n      bool failed() { return false; }\n      bool found(APValue &Subobj, QualType SubobjType) {\n        // FIXME: Reject the cases where [basic.life]p8 would not permit the\n        // old name of the object to be used to name the new object.\n        if (!Info.Ctx.hasSameUnqualifiedType(SubobjType, AllocType)) {\n          Info.FFDiag(E, diag::note_constexpr_placement_new_wrong_type) <<\n            SubobjType << AllocType;\n          return false;\n        }\n        Value = &Subobj;\n        return true;\n      }\n      bool found(APSInt &Value, QualType SubobjType) {\n        Info.FFDiag(E, diag::note_constexpr_construct_complex_elem);\n        return false;\n      }\n      bool found(APFloat &Value, QualType SubobjType) {\n        Info.FFDiag(E, diag::note_constexpr_construct_complex_elem);\n        return false;\n      }\n    } Handler = {Info, E, AllocType, AK, nullptr};\n\n    CompleteObject Obj = findCompleteObject(Info, E, AK, Result, AllocType);\n    if (!Obj || !findSubobject(Info, E, Obj, Result.Designator, Handler))\n      return false;\n\n    Val = Handler.Value;\n\n    // [basic.life]p1:\n    //   The lifetime of an object o of type T ends when [...] the storage\n    //   which the object occupies is [...] reused by an object that is not\n    //   nested within o (6.6.2).\n    *Val = APValue();\n  } else {\n    // Perform the allocation and obtain a pointer to the resulting object.\n    Val = Info.createHeapAlloc(E, AllocType, Result);\n    if (!Val)\n      return false;\n  }\n\n  if (ValueInit) {\n    ImplicitValueInitExpr VIE(AllocType);\n    if (!EvaluateInPlace(*Val, Info, Result, &VIE))\n      return false;\n  } else if (ResizedArrayILE) {\n    if (!EvaluateArrayNewInitList(Info, Result, *Val, ResizedArrayILE,\n                                  AllocType))\n      return false;\n  } else if (ResizedArrayCCE) {\n    if (!EvaluateArrayNewConstructExpr(Info, Result, *Val, ResizedArrayCCE,\n                                       AllocType))\n      return false;\n  } else if (Init) {\n    if (!EvaluateInPlace(*Val, Info, Result, Init))\n      return false;\n  } else if (!getDefaultInitValue(AllocType, *Val)) {\n    return false;\n  }\n\n  // Array new returns a pointer to the first element, not a pointer to the\n  // array.\n  if (auto *AT = AllocType->getAsArrayTypeUnsafe())\n    Result.addArray(Info, E, cast<ConstantArrayType>(AT));\n\n  return true;\n}\n//===----------------------------------------------------------------------===//\n// Member Pointer Evaluation\n//===----------------------------------------------------------------------===//\n\nnamespace {\nclass MemberPointerExprEvaluator\n  : public ExprEvaluatorBase<MemberPointerExprEvaluator> {\n  MemberPtr &Result;\n\n  bool Success(const ValueDecl *D) {\n    Result = MemberPtr(D);\n    return true;\n  }\npublic:\n\n  MemberPointerExprEvaluator(EvalInfo &Info, MemberPtr &Result)\n    : ExprEvaluatorBaseTy(Info), Result(Result) {}\n\n  bool Success(const APValue &V, const Expr *E) {\n    Result.setFrom(V);\n    return true;\n  }\n  bool ZeroInitialization(const Expr *E) {\n    return Success((const ValueDecl*)nullptr);\n  }\n\n  bool VisitCastExpr(const CastExpr *E);\n  bool VisitUnaryAddrOf(const UnaryOperator *E);\n};\n} // end anonymous namespace\n\nstatic bool EvaluateMemberPointer(const Expr *E, MemberPtr &Result,\n                                  EvalInfo &Info) {\n  assert(!E->isValueDependent());\n  assert(E->isRValue() && E->getType()->isMemberPointerType());\n  return MemberPointerExprEvaluator(Info, Result).Visit(E);\n}\n\nbool MemberPointerExprEvaluator::VisitCastExpr(const CastExpr *E) {\n  switch (E->getCastKind()) {\n  default:\n    return ExprEvaluatorBaseTy::VisitCastExpr(E);\n\n  case CK_NullToMemberPointer:\n    VisitIgnoredValue(E->getSubExpr());\n    return ZeroInitialization(E);\n\n  case CK_BaseToDerivedMemberPointer: {\n    if (!Visit(E->getSubExpr()))\n      return false;\n    if (E->path_empty())\n      return true;\n    // Base-to-derived member pointer casts store the path in derived-to-base\n    // order, so iterate backwards. The CXXBaseSpecifier also provides us with\n    // the wrong end of the derived->base arc, so stagger the path by one class.\n    typedef std::reverse_iterator<CastExpr::path_const_iterator> ReverseIter;\n    for (ReverseIter PathI(E->path_end() - 1), PathE(E->path_begin());\n         PathI != PathE; ++PathI) {\n      assert(!(*PathI)->isVirtual() && \"memptr cast through vbase\");\n      const CXXRecordDecl *Derived = (*PathI)->getType()->getAsCXXRecordDecl();\n      if (!Result.castToDerived(Derived))\n        return Error(E);\n    }\n    const Type *FinalTy = E->getType()->castAs<MemberPointerType>()->getClass();\n    if (!Result.castToDerived(FinalTy->getAsCXXRecordDecl()))\n      return Error(E);\n    return true;\n  }\n\n  case CK_DerivedToBaseMemberPointer:\n    if (!Visit(E->getSubExpr()))\n      return false;\n    for (CastExpr::path_const_iterator PathI = E->path_begin(),\n         PathE = E->path_end(); PathI != PathE; ++PathI) {\n      assert(!(*PathI)->isVirtual() && \"memptr cast through vbase\");\n      const CXXRecordDecl *Base = (*PathI)->getType()->getAsCXXRecordDecl();\n      if (!Result.castToBase(Base))\n        return Error(E);\n    }\n    return true;\n  }\n}\n\nbool MemberPointerExprEvaluator::VisitUnaryAddrOf(const UnaryOperator *E) {\n  // C++11 [expr.unary.op]p3 has very strict rules on how the address of a\n  // member can be formed.\n  return Success(cast<DeclRefExpr>(E->getSubExpr())->getDecl());\n}\n\n//===----------------------------------------------------------------------===//\n// Record Evaluation\n//===----------------------------------------------------------------------===//\n\nnamespace {\n  class RecordExprEvaluator\n  : public ExprEvaluatorBase<RecordExprEvaluator> {\n    const LValue &This;\n    APValue &Result;\n  public:\n\n    RecordExprEvaluator(EvalInfo &info, const LValue &This, APValue &Result)\n      : ExprEvaluatorBaseTy(info), This(This), Result(Result) {}\n\n    bool Success(const APValue &V, const Expr *E) {\n      Result = V;\n      return true;\n    }\n    bool ZeroInitialization(const Expr *E) {\n      return ZeroInitialization(E, E->getType());\n    }\n    bool ZeroInitialization(const Expr *E, QualType T);\n\n    bool VisitCallExpr(const CallExpr *E) {\n      return handleCallExpr(E, Result, &This);\n    }\n    bool VisitCastExpr(const CastExpr *E);\n    bool VisitInitListExpr(const InitListExpr *E);\n    bool VisitCXXConstructExpr(const CXXConstructExpr *E) {\n      return VisitCXXConstructExpr(E, E->getType());\n    }\n    bool VisitLambdaExpr(const LambdaExpr *E);\n    bool VisitCXXInheritedCtorInitExpr(const CXXInheritedCtorInitExpr *E);\n    bool VisitCXXConstructExpr(const CXXConstructExpr *E, QualType T);\n    bool VisitCXXStdInitializerListExpr(const CXXStdInitializerListExpr *E);\n    bool VisitBinCmp(const BinaryOperator *E);\n  };\n}\n\n/// Perform zero-initialization on an object of non-union class type.\n/// C++11 [dcl.init]p5:\n///  To zero-initialize an object or reference of type T means:\n///    [...]\n///    -- if T is a (possibly cv-qualified) non-union class type,\n///       each non-static data member and each base-class subobject is\n///       zero-initialized\nstatic bool HandleClassZeroInitialization(EvalInfo &Info, const Expr *E,\n                                          const RecordDecl *RD,\n                                          const LValue &This, APValue &Result) {\n  assert(!RD->isUnion() && \"Expected non-union class type\");\n  const CXXRecordDecl *CD = dyn_cast<CXXRecordDecl>(RD);\n  Result = APValue(APValue::UninitStruct(), CD ? CD->getNumBases() : 0,\n                   std::distance(RD->field_begin(), RD->field_end()));\n\n  if (RD->isInvalidDecl()) return false;\n  const ASTRecordLayout &Layout = Info.Ctx.getASTRecordLayout(RD);\n\n  if (CD) {\n    unsigned Index = 0;\n    for (CXXRecordDecl::base_class_const_iterator I = CD->bases_begin(),\n           End = CD->bases_end(); I != End; ++I, ++Index) {\n      const CXXRecordDecl *Base = I->getType()->getAsCXXRecordDecl();\n      LValue Subobject = This;\n      if (!HandleLValueDirectBase(Info, E, Subobject, CD, Base, &Layout))\n        return false;\n      if (!HandleClassZeroInitialization(Info, E, Base, Subobject,\n                                         Result.getStructBase(Index)))\n        return false;\n    }\n  }\n\n  for (const auto *I : RD->fields()) {\n    // -- if T is a reference type, no initialization is performed.\n    if (I->isUnnamedBitfield() || I->getType()->isReferenceType())\n      continue;\n\n    LValue Subobject = This;\n    if (!HandleLValueMember(Info, E, Subobject, I, &Layout))\n      return false;\n\n    ImplicitValueInitExpr VIE(I->getType());\n    if (!EvaluateInPlace(\n          Result.getStructField(I->getFieldIndex()), Info, Subobject, &VIE))\n      return false;\n  }\n\n  return true;\n}\n\nbool RecordExprEvaluator::ZeroInitialization(const Expr *E, QualType T) {\n  const RecordDecl *RD = T->castAs<RecordType>()->getDecl();\n  if (RD->isInvalidDecl()) return false;\n  if (RD->isUnion()) {\n    // C++11 [dcl.init]p5: If T is a (possibly cv-qualified) union type, the\n    // object's first non-static named data member is zero-initialized\n    RecordDecl::field_iterator I = RD->field_begin();\n    while (I != RD->field_end() && (*I)->isUnnamedBitfield())\n      ++I;\n    if (I == RD->field_end()) {\n      Result = APValue((const FieldDecl*)nullptr);\n      return true;\n    }\n\n    LValue Subobject = This;\n    if (!HandleLValueMember(Info, E, Subobject, *I))\n      return false;\n    Result = APValue(*I);\n    ImplicitValueInitExpr VIE(I->getType());\n    return EvaluateInPlace(Result.getUnionValue(), Info, Subobject, &VIE);\n  }\n\n  if (isa<CXXRecordDecl>(RD) && cast<CXXRecordDecl>(RD)->getNumVBases()) {\n    Info.FFDiag(E, diag::note_constexpr_virtual_base) << RD;\n    return false;\n  }\n\n  return HandleClassZeroInitialization(Info, E, RD, This, Result);\n}\n\nbool RecordExprEvaluator::VisitCastExpr(const CastExpr *E) {\n  switch (E->getCastKind()) {\n  default:\n    return ExprEvaluatorBaseTy::VisitCastExpr(E);\n\n  case CK_ConstructorConversion:\n    return Visit(E->getSubExpr());\n\n  case CK_DerivedToBase:\n  case CK_UncheckedDerivedToBase: {\n    APValue DerivedObject;\n    if (!Evaluate(DerivedObject, Info, E->getSubExpr()))\n      return false;\n    if (!DerivedObject.isStruct())\n      return Error(E->getSubExpr());\n\n    // Derived-to-base rvalue conversion: just slice off the derived part.\n    APValue *Value = &DerivedObject;\n    const CXXRecordDecl *RD = E->getSubExpr()->getType()->getAsCXXRecordDecl();\n    for (CastExpr::path_const_iterator PathI = E->path_begin(),\n         PathE = E->path_end(); PathI != PathE; ++PathI) {\n      assert(!(*PathI)->isVirtual() && \"record rvalue with virtual base\");\n      const CXXRecordDecl *Base = (*PathI)->getType()->getAsCXXRecordDecl();\n      Value = &Value->getStructBase(getBaseIndex(RD, Base));\n      RD = Base;\n    }\n    Result = *Value;\n    return true;\n  }\n  }\n}\n\nbool RecordExprEvaluator::VisitInitListExpr(const InitListExpr *E) {\n  if (E->isTransparent())\n    return Visit(E->getInit(0));\n\n  const RecordDecl *RD = E->getType()->castAs<RecordType>()->getDecl();\n  if (RD->isInvalidDecl()) return false;\n  const ASTRecordLayout &Layout = Info.Ctx.getASTRecordLayout(RD);\n  auto *CXXRD = dyn_cast<CXXRecordDecl>(RD);\n\n  EvalInfo::EvaluatingConstructorRAII EvalObj(\n      Info,\n      ObjectUnderConstruction{This.getLValueBase(), This.Designator.Entries},\n      CXXRD && CXXRD->getNumBases());\n\n  if (RD->isUnion()) {\n    const FieldDecl *Field = E->getInitializedFieldInUnion();\n    Result = APValue(Field);\n    if (!Field)\n      return true;\n\n    // If the initializer list for a union does not contain any elements, the\n    // first element of the union is value-initialized.\n    // FIXME: The element should be initialized from an initializer list.\n    //        Is this difference ever observable for initializer lists which\n    //        we don't build?\n    ImplicitValueInitExpr VIE(Field->getType());\n    const Expr *InitExpr = E->getNumInits() ? E->getInit(0) : &VIE;\n\n    LValue Subobject = This;\n    if (!HandleLValueMember(Info, InitExpr, Subobject, Field, &Layout))\n      return false;\n\n    // Temporarily override This, in case there's a CXXDefaultInitExpr in here.\n    ThisOverrideRAII ThisOverride(*Info.CurrentCall, &This,\n                                  isa<CXXDefaultInitExpr>(InitExpr));\n\n    if (EvaluateInPlace(Result.getUnionValue(), Info, Subobject, InitExpr)) {\n      if (Field->isBitField())\n        return truncateBitfieldValue(Info, InitExpr, Result.getUnionValue(),\n                                     Field);\n      return true;\n    }\n\n    return false;\n  }\n\n  if (!Result.hasValue())\n    Result = APValue(APValue::UninitStruct(), CXXRD ? CXXRD->getNumBases() : 0,\n                     std::distance(RD->field_begin(), RD->field_end()));\n  unsigned ElementNo = 0;\n  bool Success = true;\n\n  // Initialize base classes.\n  if (CXXRD && CXXRD->getNumBases()) {\n    for (const auto &Base : CXXRD->bases()) {\n      assert(ElementNo < E->getNumInits() && \"missing init for base class\");\n      const Expr *Init = E->getInit(ElementNo);\n\n      LValue Subobject = This;\n      if (!HandleLValueBase(Info, Init, Subobject, CXXRD, &Base))\n        return false;\n\n      APValue &FieldVal = Result.getStructBase(ElementNo);\n      if (!EvaluateInPlace(FieldVal, Info, Subobject, Init)) {\n        if (!Info.noteFailure())\n          return false;\n        Success = false;\n      }\n      ++ElementNo;\n    }\n\n    EvalObj.finishedConstructingBases();\n  }\n\n  // Initialize members.\n  for (const auto *Field : RD->fields()) {\n    // Anonymous bit-fields are not considered members of the class for\n    // purposes of aggregate initialization.\n    if (Field->isUnnamedBitfield())\n      continue;\n\n    LValue Subobject = This;\n\n    bool HaveInit = ElementNo < E->getNumInits();\n\n    // FIXME: Diagnostics here should point to the end of the initializer\n    // list, not the start.\n    if (!HandleLValueMember(Info, HaveInit ? E->getInit(ElementNo) : E,\n                            Subobject, Field, &Layout))\n      return false;\n\n    // Perform an implicit value-initialization for members beyond the end of\n    // the initializer list.\n    ImplicitValueInitExpr VIE(HaveInit ? Info.Ctx.IntTy : Field->getType());\n    const Expr *Init = HaveInit ? E->getInit(ElementNo++) : &VIE;\n\n    // Temporarily override This, in case there's a CXXDefaultInitExpr in here.\n    ThisOverrideRAII ThisOverride(*Info.CurrentCall, &This,\n                                  isa<CXXDefaultInitExpr>(Init));\n\n    APValue &FieldVal = Result.getStructField(Field->getFieldIndex());\n    if (!EvaluateInPlace(FieldVal, Info, Subobject, Init) ||\n        (Field->isBitField() && !truncateBitfieldValue(Info, Init,\n                                                       FieldVal, Field))) {\n      if (!Info.noteFailure())\n        return false;\n      Success = false;\n    }\n  }\n\n  EvalObj.finishedConstructingFields();\n\n  return Success;\n}\n\nbool RecordExprEvaluator::VisitCXXConstructExpr(const CXXConstructExpr *E,\n                                                QualType T) {\n  // Note that E's type is not necessarily the type of our class here; we might\n  // be initializing an array element instead.\n  const CXXConstructorDecl *FD = E->getConstructor();\n  if (FD->isInvalidDecl() || FD->getParent()->isInvalidDecl()) return false;\n\n  bool ZeroInit = E->requiresZeroInitialization();\n  if (CheckTrivialDefaultConstructor(Info, E->getExprLoc(), FD, ZeroInit)) {\n    // If we've already performed zero-initialization, we're already done.\n    if (Result.hasValue())\n      return true;\n\n    if (ZeroInit)\n      return ZeroInitialization(E, T);\n\n    return getDefaultInitValue(T, Result);\n  }\n\n  const FunctionDecl *Definition = nullptr;\n  auto Body = FD->getBody(Definition);\n\n  if (!CheckConstexprFunction(Info, E->getExprLoc(), FD, Definition, Body))\n    return false;\n\n  // Avoid materializing a temporary for an elidable copy/move constructor.\n  if (E->isElidable() && !ZeroInit)\n    if (const MaterializeTemporaryExpr *ME\n          = dyn_cast<MaterializeTemporaryExpr>(E->getArg(0)))\n      return Visit(ME->getSubExpr());\n\n  if (ZeroInit && !ZeroInitialization(E, T))\n    return false;\n\n  auto Args = llvm::makeArrayRef(E->getArgs(), E->getNumArgs());\n  return HandleConstructorCall(E, This, Args,\n                               cast<CXXConstructorDecl>(Definition), Info,\n                               Result);\n}\n\nbool RecordExprEvaluator::VisitCXXInheritedCtorInitExpr(\n    const CXXInheritedCtorInitExpr *E) {\n  if (!Info.CurrentCall) {\n    assert(Info.checkingPotentialConstantExpression());\n    return false;\n  }\n\n  const CXXConstructorDecl *FD = E->getConstructor();\n  if (FD->isInvalidDecl() || FD->getParent()->isInvalidDecl())\n    return false;\n\n  const FunctionDecl *Definition = nullptr;\n  auto Body = FD->getBody(Definition);\n\n  if (!CheckConstexprFunction(Info, E->getExprLoc(), FD, Definition, Body))\n    return false;\n\n  return HandleConstructorCall(E, This, Info.CurrentCall->Arguments,\n                               cast<CXXConstructorDecl>(Definition), Info,\n                               Result);\n}\n\nbool RecordExprEvaluator::VisitCXXStdInitializerListExpr(\n    const CXXStdInitializerListExpr *E) {\n  const ConstantArrayType *ArrayType =\n      Info.Ctx.getAsConstantArrayType(E->getSubExpr()->getType());\n\n  LValue Array;\n  if (!EvaluateLValue(E->getSubExpr(), Array, Info))\n    return false;\n\n  // Get a pointer to the first element of the array.\n  Array.addArray(Info, E, ArrayType);\n\n  auto InvalidType = [&] {\n    Info.FFDiag(E, diag::note_constexpr_unsupported_layout)\n      << E->getType();\n    return false;\n  };\n\n  // FIXME: Perform the checks on the field types in SemaInit.\n  RecordDecl *Record = E->getType()->castAs<RecordType>()->getDecl();\n  RecordDecl::field_iterator Field = Record->field_begin();\n  if (Field == Record->field_end())\n    return InvalidType();\n\n  // Start pointer.\n  if (!Field->getType()->isPointerType() ||\n      !Info.Ctx.hasSameType(Field->getType()->getPointeeType(),\n                            ArrayType->getElementType()))\n    return InvalidType();\n\n  // FIXME: What if the initializer_list type has base classes, etc?\n  Result = APValue(APValue::UninitStruct(), 0, 2);\n  Array.moveInto(Result.getStructField(0));\n\n  if (++Field == Record->field_end())\n    return InvalidType();\n\n  if (Field->getType()->isPointerType() &&\n      Info.Ctx.hasSameType(Field->getType()->getPointeeType(),\n                           ArrayType->getElementType())) {\n    // End pointer.\n    if (!HandleLValueArrayAdjustment(Info, E, Array,\n                                     ArrayType->getElementType(),\n                                     ArrayType->getSize().getZExtValue()))\n      return false;\n    Array.moveInto(Result.getStructField(1));\n  } else if (Info.Ctx.hasSameType(Field->getType(), Info.Ctx.getSizeType()))\n    // Length.\n    Result.getStructField(1) = APValue(APSInt(ArrayType->getSize()));\n  else\n    return InvalidType();\n\n  if (++Field != Record->field_end())\n    return InvalidType();\n\n  return true;\n}\n\nbool RecordExprEvaluator::VisitLambdaExpr(const LambdaExpr *E) {\n  const CXXRecordDecl *ClosureClass = E->getLambdaClass();\n  if (ClosureClass->isInvalidDecl())\n    return false;\n\n  const size_t NumFields =\n      std::distance(ClosureClass->field_begin(), ClosureClass->field_end());\n\n  assert(NumFields == (size_t)std::distance(E->capture_init_begin(),\n                                            E->capture_init_end()) &&\n         \"The number of lambda capture initializers should equal the number of \"\n         \"fields within the closure type\");\n\n  Result = APValue(APValue::UninitStruct(), /*NumBases*/0, NumFields);\n  // Iterate through all the lambda's closure object's fields and initialize\n  // them.\n  auto *CaptureInitIt = E->capture_init_begin();\n  const LambdaCapture *CaptureIt = ClosureClass->captures_begin();\n  bool Success = true;\n  const ASTRecordLayout &Layout = Info.Ctx.getASTRecordLayout(ClosureClass);\n  for (const auto *Field : ClosureClass->fields()) {\n    assert(CaptureInitIt != E->capture_init_end());\n    // Get the initializer for this field\n    Expr *const CurFieldInit = *CaptureInitIt++;\n\n    // If there is no initializer, either this is a VLA or an error has\n    // occurred.\n    if (!CurFieldInit)\n      return Error(E);\n\n    LValue Subobject = This;\n\n    if (!HandleLValueMember(Info, E, Subobject, Field, &Layout))\n      return false;\n\n    APValue &FieldVal = Result.getStructField(Field->getFieldIndex());\n    if (!EvaluateInPlace(FieldVal, Info, Subobject, CurFieldInit)) {\n      if (!Info.keepEvaluatingAfterFailure())\n        return false;\n      Success = false;\n    }\n    ++CaptureIt;\n  }\n  return Success;\n}\n\nstatic bool EvaluateRecord(const Expr *E, const LValue &This,\n                           APValue &Result, EvalInfo &Info) {\n  assert(!E->isValueDependent());\n  assert(E->isRValue() && E->getType()->isRecordType() &&\n         \"can't evaluate expression as a record rvalue\");\n  return RecordExprEvaluator(Info, This, Result).Visit(E);\n}\n\n//===----------------------------------------------------------------------===//\n// Temporary Evaluation\n//\n// Temporaries are represented in the AST as rvalues, but generally behave like\n// lvalues. The full-object of which the temporary is a subobject is implicitly\n// materialized so that a reference can bind to it.\n//===----------------------------------------------------------------------===//\nnamespace {\nclass TemporaryExprEvaluator\n  : public LValueExprEvaluatorBase<TemporaryExprEvaluator> {\npublic:\n  TemporaryExprEvaluator(EvalInfo &Info, LValue &Result) :\n    LValueExprEvaluatorBaseTy(Info, Result, false) {}\n\n  /// Visit an expression which constructs the value of this temporary.\n  bool VisitConstructExpr(const Expr *E) {\n    APValue &Value = Info.CurrentCall->createTemporary(\n        E, E->getType(), ScopeKind::FullExpression, Result);\n    return EvaluateInPlace(Value, Info, Result, E);\n  }\n\n  bool VisitCastExpr(const CastExpr *E) {\n    switch (E->getCastKind()) {\n    default:\n      return LValueExprEvaluatorBaseTy::VisitCastExpr(E);\n\n    case CK_ConstructorConversion:\n      return VisitConstructExpr(E->getSubExpr());\n    }\n  }\n  bool VisitInitListExpr(const InitListExpr *E) {\n    return VisitConstructExpr(E);\n  }\n  bool VisitCXXConstructExpr(const CXXConstructExpr *E) {\n    return VisitConstructExpr(E);\n  }\n  bool VisitCallExpr(const CallExpr *E) {\n    return VisitConstructExpr(E);\n  }\n  bool VisitCXXStdInitializerListExpr(const CXXStdInitializerListExpr *E) {\n    return VisitConstructExpr(E);\n  }\n  bool VisitLambdaExpr(const LambdaExpr *E) {\n    return VisitConstructExpr(E);\n  }\n};\n} // end anonymous namespace\n\n/// Evaluate an expression of record type as a temporary.\nstatic bool EvaluateTemporary(const Expr *E, LValue &Result, EvalInfo &Info) {\n  assert(!E->isValueDependent());\n  assert(E->isRValue() && E->getType()->isRecordType());\n  return TemporaryExprEvaluator(Info, Result).Visit(E);\n}\n\n//===----------------------------------------------------------------------===//\n// Vector Evaluation\n//===----------------------------------------------------------------------===//\n\nnamespace {\n  class VectorExprEvaluator\n  : public ExprEvaluatorBase<VectorExprEvaluator> {\n    APValue &Result;\n  public:\n\n    VectorExprEvaluator(EvalInfo &info, APValue &Result)\n      : ExprEvaluatorBaseTy(info), Result(Result) {}\n\n    bool Success(ArrayRef<APValue> V, const Expr *E) {\n      assert(V.size() == E->getType()->castAs<VectorType>()->getNumElements());\n      // FIXME: remove this APValue copy.\n      Result = APValue(V.data(), V.size());\n      return true;\n    }\n    bool Success(const APValue &V, const Expr *E) {\n      assert(V.isVector());\n      Result = V;\n      return true;\n    }\n    bool ZeroInitialization(const Expr *E);\n\n    bool VisitUnaryReal(const UnaryOperator *E)\n      { return Visit(E->getSubExpr()); }\n    bool VisitCastExpr(const CastExpr* E);\n    bool VisitInitListExpr(const InitListExpr *E);\n    bool VisitUnaryImag(const UnaryOperator *E);\n    bool VisitBinaryOperator(const BinaryOperator *E);\n    // FIXME: Missing: unary -, unary ~, conditional operator (for GNU\n    //                 conditional select), shufflevector, ExtVectorElementExpr\n  };\n} // end anonymous namespace\n\nstatic bool EvaluateVector(const Expr* E, APValue& Result, EvalInfo &Info) {\n  assert(E->isRValue() && E->getType()->isVectorType() &&\"not a vector rvalue\");\n  return VectorExprEvaluator(Info, Result).Visit(E);\n}\n\nbool VectorExprEvaluator::VisitCastExpr(const CastExpr *E) {\n  const VectorType *VTy = E->getType()->castAs<VectorType>();\n  unsigned NElts = VTy->getNumElements();\n\n  const Expr *SE = E->getSubExpr();\n  QualType SETy = SE->getType();\n\n  switch (E->getCastKind()) {\n  case CK_VectorSplat: {\n    APValue Val = APValue();\n    if (SETy->isIntegerType()) {\n      APSInt IntResult;\n      if (!EvaluateInteger(SE, IntResult, Info))\n        return false;\n      Val = APValue(std::move(IntResult));\n    } else if (SETy->isRealFloatingType()) {\n      APFloat FloatResult(0.0);\n      if (!EvaluateFloat(SE, FloatResult, Info))\n        return false;\n      Val = APValue(std::move(FloatResult));\n    } else {\n      return Error(E);\n    }\n\n    // Splat and create vector APValue.\n    SmallVector<APValue, 4> Elts(NElts, Val);\n    return Success(Elts, E);\n  }\n  case CK_BitCast: {\n    // Evaluate the operand into an APInt we can extract from.\n    llvm::APInt SValInt;\n    if (!EvalAndBitcastToAPInt(Info, SE, SValInt))\n      return false;\n    // Extract the elements\n    QualType EltTy = VTy->getElementType();\n    unsigned EltSize = Info.Ctx.getTypeSize(EltTy);\n    bool BigEndian = Info.Ctx.getTargetInfo().isBigEndian();\n    SmallVector<APValue, 4> Elts;\n    if (EltTy->isRealFloatingType()) {\n      const llvm::fltSemantics &Sem = Info.Ctx.getFloatTypeSemantics(EltTy);\n      unsigned FloatEltSize = EltSize;\n      if (&Sem == &APFloat::x87DoubleExtended())\n        FloatEltSize = 80;\n      for (unsigned i = 0; i < NElts; i++) {\n        llvm::APInt Elt;\n        if (BigEndian)\n          Elt = SValInt.rotl(i*EltSize+FloatEltSize).trunc(FloatEltSize);\n        else\n          Elt = SValInt.rotr(i*EltSize).trunc(FloatEltSize);\n        Elts.push_back(APValue(APFloat(Sem, Elt)));\n      }\n    } else if (EltTy->isIntegerType()) {\n      for (unsigned i = 0; i < NElts; i++) {\n        llvm::APInt Elt;\n        if (BigEndian)\n          Elt = SValInt.rotl(i*EltSize+EltSize).zextOrTrunc(EltSize);\n        else\n          Elt = SValInt.rotr(i*EltSize).zextOrTrunc(EltSize);\n        Elts.push_back(APValue(APSInt(Elt, !EltTy->isSignedIntegerType())));\n      }\n    } else {\n      return Error(E);\n    }\n    return Success(Elts, E);\n  }\n  default:\n    return ExprEvaluatorBaseTy::VisitCastExpr(E);\n  }\n}\n\nbool\nVectorExprEvaluator::VisitInitListExpr(const InitListExpr *E) {\n  const VectorType *VT = E->getType()->castAs<VectorType>();\n  unsigned NumInits = E->getNumInits();\n  unsigned NumElements = VT->getNumElements();\n\n  QualType EltTy = VT->getElementType();\n  SmallVector<APValue, 4> Elements;\n\n  // The number of initializers can be less than the number of\n  // vector elements. For OpenCL, this can be due to nested vector\n  // initialization. For GCC compatibility, missing trailing elements\n  // should be initialized with zeroes.\n  unsigned CountInits = 0, CountElts = 0;\n  while (CountElts < NumElements) {\n    // Handle nested vector initialization.\n    if (CountInits < NumInits\n        && E->getInit(CountInits)->getType()->isVectorType()) {\n      APValue v;\n      if (!EvaluateVector(E->getInit(CountInits), v, Info))\n        return Error(E);\n      unsigned vlen = v.getVectorLength();\n      for (unsigned j = 0; j < vlen; j++)\n        Elements.push_back(v.getVectorElt(j));\n      CountElts += vlen;\n    } else if (EltTy->isIntegerType()) {\n      llvm::APSInt sInt(32);\n      if (CountInits < NumInits) {\n        if (!EvaluateInteger(E->getInit(CountInits), sInt, Info))\n          return false;\n      } else // trailing integer zero.\n        sInt = Info.Ctx.MakeIntValue(0, EltTy);\n      Elements.push_back(APValue(sInt));\n      CountElts++;\n    } else {\n      llvm::APFloat f(0.0);\n      if (CountInits < NumInits) {\n        if (!EvaluateFloat(E->getInit(CountInits), f, Info))\n          return false;\n      } else // trailing float zero.\n        f = APFloat::getZero(Info.Ctx.getFloatTypeSemantics(EltTy));\n      Elements.push_back(APValue(f));\n      CountElts++;\n    }\n    CountInits++;\n  }\n  return Success(Elements, E);\n}\n\nbool\nVectorExprEvaluator::ZeroInitialization(const Expr *E) {\n  const auto *VT = E->getType()->castAs<VectorType>();\n  QualType EltTy = VT->getElementType();\n  APValue ZeroElement;\n  if (EltTy->isIntegerType())\n    ZeroElement = APValue(Info.Ctx.MakeIntValue(0, EltTy));\n  else\n    ZeroElement =\n        APValue(APFloat::getZero(Info.Ctx.getFloatTypeSemantics(EltTy)));\n\n  SmallVector<APValue, 4> Elements(VT->getNumElements(), ZeroElement);\n  return Success(Elements, E);\n}\n\nbool VectorExprEvaluator::VisitUnaryImag(const UnaryOperator *E) {\n  VisitIgnoredValue(E->getSubExpr());\n  return ZeroInitialization(E);\n}\n\nbool VectorExprEvaluator::VisitBinaryOperator(const BinaryOperator *E) {\n  BinaryOperatorKind Op = E->getOpcode();\n  assert(Op != BO_PtrMemD && Op != BO_PtrMemI && Op != BO_Cmp &&\n         \"Operation not supported on vector types\");\n\n  if (Op == BO_Comma)\n    return ExprEvaluatorBaseTy::VisitBinaryOperator(E);\n\n  Expr *LHS = E->getLHS();\n  Expr *RHS = E->getRHS();\n\n  assert(LHS->getType()->isVectorType() && RHS->getType()->isVectorType() &&\n         \"Must both be vector types\");\n  // Checking JUST the types are the same would be fine, except shifts don't\n  // need to have their types be the same (since you always shift by an int).\n  assert(LHS->getType()->getAs<VectorType>()->getNumElements() ==\n             E->getType()->getAs<VectorType>()->getNumElements() &&\n         RHS->getType()->getAs<VectorType>()->getNumElements() ==\n             E->getType()->getAs<VectorType>()->getNumElements() &&\n         \"All operands must be the same size.\");\n\n  APValue LHSValue;\n  APValue RHSValue;\n  bool LHSOK = Evaluate(LHSValue, Info, LHS);\n  if (!LHSOK && !Info.noteFailure())\n    return false;\n  if (!Evaluate(RHSValue, Info, RHS) || !LHSOK)\n    return false;\n\n  if (!handleVectorVectorBinOp(Info, E, Op, LHSValue, RHSValue))\n    return false;\n\n  return Success(LHSValue, E);\n}\n\n//===----------------------------------------------------------------------===//\n// Array Evaluation\n//===----------------------------------------------------------------------===//\n\nnamespace {\n  class ArrayExprEvaluator\n  : public ExprEvaluatorBase<ArrayExprEvaluator> {\n    const LValue &This;\n    APValue &Result;\n  public:\n\n    ArrayExprEvaluator(EvalInfo &Info, const LValue &This, APValue &Result)\n      : ExprEvaluatorBaseTy(Info), This(This), Result(Result) {}\n\n    bool Success(const APValue &V, const Expr *E) {\n      assert(V.isArray() && \"expected array\");\n      Result = V;\n      return true;\n    }\n\n    bool ZeroInitialization(const Expr *E) {\n      const ConstantArrayType *CAT =\n          Info.Ctx.getAsConstantArrayType(E->getType());\n      if (!CAT) {\n        if (E->getType()->isIncompleteArrayType()) {\n          // We can be asked to zero-initialize a flexible array member; this\n          // is represented as an ImplicitValueInitExpr of incomplete array\n          // type. In this case, the array has zero elements.\n          Result = APValue(APValue::UninitArray(), 0, 0);\n          return true;\n        }\n        // FIXME: We could handle VLAs here.\n        return Error(E);\n      }\n\n      Result = APValue(APValue::UninitArray(), 0,\n                       CAT->getSize().getZExtValue());\n      if (!Result.hasArrayFiller()) return true;\n\n      // Zero-initialize all elements.\n      LValue Subobject = This;\n      Subobject.addArray(Info, E, CAT);\n      ImplicitValueInitExpr VIE(CAT->getElementType());\n      return EvaluateInPlace(Result.getArrayFiller(), Info, Subobject, &VIE);\n    }\n\n    bool VisitCallExpr(const CallExpr *E) {\n      return handleCallExpr(E, Result, &This);\n    }\n    bool VisitInitListExpr(const InitListExpr *E,\n                           QualType AllocType = QualType());\n    bool VisitArrayInitLoopExpr(const ArrayInitLoopExpr *E);\n    bool VisitCXXConstructExpr(const CXXConstructExpr *E);\n    bool VisitCXXConstructExpr(const CXXConstructExpr *E,\n                               const LValue &Subobject,\n                               APValue *Value, QualType Type);\n    bool VisitStringLiteral(const StringLiteral *E,\n                            QualType AllocType = QualType()) {\n      expandStringLiteral(Info, E, Result, AllocType);\n      return true;\n    }\n  };\n} // end anonymous namespace\n\nstatic bool EvaluateArray(const Expr *E, const LValue &This,\n                          APValue &Result, EvalInfo &Info) {\n  assert(!E->isValueDependent());\n  assert(E->isRValue() && E->getType()->isArrayType() && \"not an array rvalue\");\n  return ArrayExprEvaluator(Info, This, Result).Visit(E);\n}\n\nstatic bool EvaluateArrayNewInitList(EvalInfo &Info, LValue &This,\n                                     APValue &Result, const InitListExpr *ILE,\n                                     QualType AllocType) {\n  assert(!ILE->isValueDependent());\n  assert(ILE->isRValue() && ILE->getType()->isArrayType() &&\n         \"not an array rvalue\");\n  return ArrayExprEvaluator(Info, This, Result)\n      .VisitInitListExpr(ILE, AllocType);\n}\n\nstatic bool EvaluateArrayNewConstructExpr(EvalInfo &Info, LValue &This,\n                                          APValue &Result,\n                                          const CXXConstructExpr *CCE,\n                                          QualType AllocType) {\n  assert(!CCE->isValueDependent());\n  assert(CCE->isRValue() && CCE->getType()->isArrayType() &&\n         \"not an array rvalue\");\n  return ArrayExprEvaluator(Info, This, Result)\n      .VisitCXXConstructExpr(CCE, This, &Result, AllocType);\n}\n\n// Return true iff the given array filler may depend on the element index.\nstatic bool MaybeElementDependentArrayFiller(const Expr *FillerExpr) {\n  // For now, just allow non-class value-initialization and initialization\n  // lists comprised of them.\n  if (isa<ImplicitValueInitExpr>(FillerExpr))\n    return false;\n  if (const InitListExpr *ILE = dyn_cast<InitListExpr>(FillerExpr)) {\n    for (unsigned I = 0, E = ILE->getNumInits(); I != E; ++I) {\n      if (MaybeElementDependentArrayFiller(ILE->getInit(I)))\n        return true;\n    }\n    return false;\n  }\n  return true;\n}\n\nbool ArrayExprEvaluator::VisitInitListExpr(const InitListExpr *E,\n                                           QualType AllocType) {\n  const ConstantArrayType *CAT = Info.Ctx.getAsConstantArrayType(\n      AllocType.isNull() ? E->getType() : AllocType);\n  if (!CAT)\n    return Error(E);\n\n  // C++11 [dcl.init.string]p1: A char array [...] can be initialized by [...]\n  // an appropriately-typed string literal enclosed in braces.\n  if (E->isStringLiteralInit()) {\n    auto *SL = dyn_cast<StringLiteral>(E->getInit(0)->IgnoreParens());\n    // FIXME: Support ObjCEncodeExpr here once we support it in\n    // ArrayExprEvaluator generally.\n    if (!SL)\n      return Error(E);\n    return VisitStringLiteral(SL, AllocType);\n  }\n\n  bool Success = true;\n\n  assert((!Result.isArray() || Result.getArrayInitializedElts() == 0) &&\n         \"zero-initialized array shouldn't have any initialized elts\");\n  APValue Filler;\n  if (Result.isArray() && Result.hasArrayFiller())\n    Filler = Result.getArrayFiller();\n\n  unsigned NumEltsToInit = E->getNumInits();\n  unsigned NumElts = CAT->getSize().getZExtValue();\n  const Expr *FillerExpr = E->hasArrayFiller() ? E->getArrayFiller() : nullptr;\n\n  // If the initializer might depend on the array index, run it for each\n  // array element.\n  if (NumEltsToInit != NumElts && MaybeElementDependentArrayFiller(FillerExpr))\n    NumEltsToInit = NumElts;\n\n  LLVM_DEBUG(llvm::dbgs() << \"The number of elements to initialize: \"\n                          << NumEltsToInit << \".\\n\");\n\n  Result = APValue(APValue::UninitArray(), NumEltsToInit, NumElts);\n\n  // If the array was previously zero-initialized, preserve the\n  // zero-initialized values.\n  if (Filler.hasValue()) {\n    for (unsigned I = 0, E = Result.getArrayInitializedElts(); I != E; ++I)\n      Result.getArrayInitializedElt(I) = Filler;\n    if (Result.hasArrayFiller())\n      Result.getArrayFiller() = Filler;\n  }\n\n  LValue Subobject = This;\n  Subobject.addArray(Info, E, CAT);\n  for (unsigned Index = 0; Index != NumEltsToInit; ++Index) {\n    const Expr *Init =\n        Index < E->getNumInits() ? E->getInit(Index) : FillerExpr;\n    if (!EvaluateInPlace(Result.getArrayInitializedElt(Index),\n                         Info, Subobject, Init) ||\n        !HandleLValueArrayAdjustment(Info, Init, Subobject,\n                                     CAT->getElementType(), 1)) {\n      if (!Info.noteFailure())\n        return false;\n      Success = false;\n    }\n  }\n\n  if (!Result.hasArrayFiller())\n    return Success;\n\n  // If we get here, we have a trivial filler, which we can just evaluate\n  // once and splat over the rest of the array elements.\n  assert(FillerExpr && \"no array filler for incomplete init list\");\n  return EvaluateInPlace(Result.getArrayFiller(), Info, Subobject,\n                         FillerExpr) && Success;\n}\n\nbool ArrayExprEvaluator::VisitArrayInitLoopExpr(const ArrayInitLoopExpr *E) {\n  LValue CommonLV;\n  if (E->getCommonExpr() &&\n      !Evaluate(Info.CurrentCall->createTemporary(\n                    E->getCommonExpr(),\n                    getStorageType(Info.Ctx, E->getCommonExpr()),\n                    ScopeKind::FullExpression, CommonLV),\n                Info, E->getCommonExpr()->getSourceExpr()))\n    return false;\n\n  auto *CAT = cast<ConstantArrayType>(E->getType()->castAsArrayTypeUnsafe());\n\n  uint64_t Elements = CAT->getSize().getZExtValue();\n  Result = APValue(APValue::UninitArray(), Elements, Elements);\n\n  LValue Subobject = This;\n  Subobject.addArray(Info, E, CAT);\n\n  bool Success = true;\n  for (EvalInfo::ArrayInitLoopIndex Index(Info); Index != Elements; ++Index) {\n    if (!EvaluateInPlace(Result.getArrayInitializedElt(Index),\n                         Info, Subobject, E->getSubExpr()) ||\n        !HandleLValueArrayAdjustment(Info, E, Subobject,\n                                     CAT->getElementType(), 1)) {\n      if (!Info.noteFailure())\n        return false;\n      Success = false;\n    }\n  }\n\n  return Success;\n}\n\nbool ArrayExprEvaluator::VisitCXXConstructExpr(const CXXConstructExpr *E) {\n  return VisitCXXConstructExpr(E, This, &Result, E->getType());\n}\n\nbool ArrayExprEvaluator::VisitCXXConstructExpr(const CXXConstructExpr *E,\n                                               const LValue &Subobject,\n                                               APValue *Value,\n                                               QualType Type) {\n  bool HadZeroInit = Value->hasValue();\n\n  if (const ConstantArrayType *CAT = Info.Ctx.getAsConstantArrayType(Type)) {\n    unsigned N = CAT->getSize().getZExtValue();\n\n    // Preserve the array filler if we had prior zero-initialization.\n    APValue Filler =\n      HadZeroInit && Value->hasArrayFiller() ? Value->getArrayFiller()\n                                             : APValue();\n\n    *Value = APValue(APValue::UninitArray(), N, N);\n\n    if (HadZeroInit)\n      for (unsigned I = 0; I != N; ++I)\n        Value->getArrayInitializedElt(I) = Filler;\n\n    // Initialize the elements.\n    LValue ArrayElt = Subobject;\n    ArrayElt.addArray(Info, E, CAT);\n    for (unsigned I = 0; I != N; ++I)\n      if (!VisitCXXConstructExpr(E, ArrayElt, &Value->getArrayInitializedElt(I),\n                                 CAT->getElementType()) ||\n          !HandleLValueArrayAdjustment(Info, E, ArrayElt,\n                                       CAT->getElementType(), 1))\n        return false;\n\n    return true;\n  }\n\n  if (!Type->isRecordType())\n    return Error(E);\n\n  return RecordExprEvaluator(Info, Subobject, *Value)\n             .VisitCXXConstructExpr(E, Type);\n}\n\n//===----------------------------------------------------------------------===//\n// Integer Evaluation\n//\n// As a GNU extension, we support casting pointers to sufficiently-wide integer\n// types and back in constant folding. Integer values are thus represented\n// either as an integer-valued APValue, or as an lvalue-valued APValue.\n//===----------------------------------------------------------------------===//\n\nnamespace {\nclass IntExprEvaluator\n        : public ExprEvaluatorBase<IntExprEvaluator> {\n  APValue &Result;\npublic:\n  IntExprEvaluator(EvalInfo &info, APValue &result)\n      : ExprEvaluatorBaseTy(info), Result(result) {}\n\n  bool Success(const llvm::APSInt &SI, const Expr *E, APValue &Result) {\n    assert(E->getType()->isIntegralOrEnumerationType() &&\n           \"Invalid evaluation result.\");\n    assert(SI.isSigned() == E->getType()->isSignedIntegerOrEnumerationType() &&\n           \"Invalid evaluation result.\");\n    assert(SI.getBitWidth() == Info.Ctx.getIntWidth(E->getType()) &&\n           \"Invalid evaluation result.\");\n    Result = APValue(SI);\n    return true;\n  }\n  bool Success(const llvm::APSInt &SI, const Expr *E) {\n    return Success(SI, E, Result);\n  }\n\n  bool Success(const llvm::APInt &I, const Expr *E, APValue &Result) {\n    assert(E->getType()->isIntegralOrEnumerationType() &&\n           \"Invalid evaluation result.\");\n    assert(I.getBitWidth() == Info.Ctx.getIntWidth(E->getType()) &&\n           \"Invalid evaluation result.\");\n    Result = APValue(APSInt(I));\n    Result.getInt().setIsUnsigned(\n                            E->getType()->isUnsignedIntegerOrEnumerationType());\n    return true;\n  }\n  bool Success(const llvm::APInt &I, const Expr *E) {\n    return Success(I, E, Result);\n  }\n\n  bool Success(uint64_t Value, const Expr *E, APValue &Result) {\n    assert(E->getType()->isIntegralOrEnumerationType() &&\n           \"Invalid evaluation result.\");\n    Result = APValue(Info.Ctx.MakeIntValue(Value, E->getType()));\n    return true;\n  }\n  bool Success(uint64_t Value, const Expr *E) {\n    return Success(Value, E, Result);\n  }\n\n  bool Success(CharUnits Size, const Expr *E) {\n    return Success(Size.getQuantity(), E);\n  }\n\n  bool Success(const APValue &V, const Expr *E) {\n    if (V.isLValue() || V.isAddrLabelDiff() || V.isIndeterminate()) {\n      Result = V;\n      return true;\n    }\n    return Success(V.getInt(), E);\n  }\n\n  bool ZeroInitialization(const Expr *E) { return Success(0, E); }\n\n  //===--------------------------------------------------------------------===//\n  //                            Visitor Methods\n  //===--------------------------------------------------------------------===//\n\n  bool VisitIntegerLiteral(const IntegerLiteral *E) {\n    return Success(E->getValue(), E);\n  }\n  bool VisitCharacterLiteral(const CharacterLiteral *E) {\n    return Success(E->getValue(), E);\n  }\n\n  bool CheckReferencedDecl(const Expr *E, const Decl *D);\n  bool VisitDeclRefExpr(const DeclRefExpr *E) {\n    if (CheckReferencedDecl(E, E->getDecl()))\n      return true;\n\n    return ExprEvaluatorBaseTy::VisitDeclRefExpr(E);\n  }\n  bool VisitMemberExpr(const MemberExpr *E) {\n    if (CheckReferencedDecl(E, E->getMemberDecl())) {\n      VisitIgnoredBaseExpression(E->getBase());\n      return true;\n    }\n\n    return ExprEvaluatorBaseTy::VisitMemberExpr(E);\n  }\n\n  bool VisitCallExpr(const CallExpr *E);\n  bool VisitBuiltinCallExpr(const CallExpr *E, unsigned BuiltinOp);\n  bool VisitBinaryOperator(const BinaryOperator *E);\n  bool VisitOffsetOfExpr(const OffsetOfExpr *E);\n  bool VisitUnaryOperator(const UnaryOperator *E);\n\n  bool VisitCastExpr(const CastExpr* E);\n  bool VisitUnaryExprOrTypeTraitExpr(const UnaryExprOrTypeTraitExpr *E);\n\n  bool VisitCXXBoolLiteralExpr(const CXXBoolLiteralExpr *E) {\n    return Success(E->getValue(), E);\n  }\n\n  bool VisitObjCBoolLiteralExpr(const ObjCBoolLiteralExpr *E) {\n    return Success(E->getValue(), E);\n  }\n\n  bool VisitArrayInitIndexExpr(const ArrayInitIndexExpr *E) {\n    if (Info.ArrayInitIndex == uint64_t(-1)) {\n      // We were asked to evaluate this subexpression independent of the\n      // enclosing ArrayInitLoopExpr. We can't do that.\n      Info.FFDiag(E);\n      return false;\n    }\n    return Success(Info.ArrayInitIndex, E);\n  }\n\n  // Note, GNU defines __null as an integer, not a pointer.\n  bool VisitGNUNullExpr(const GNUNullExpr *E) {\n    return ZeroInitialization(E);\n  }\n\n  bool VisitTypeTraitExpr(const TypeTraitExpr *E) {\n    return Success(E->getValue(), E);\n  }\n\n  bool VisitArrayTypeTraitExpr(const ArrayTypeTraitExpr *E) {\n    return Success(E->getValue(), E);\n  }\n\n  bool VisitExpressionTraitExpr(const ExpressionTraitExpr *E) {\n    return Success(E->getValue(), E);\n  }\n\n  bool VisitUnaryReal(const UnaryOperator *E);\n  bool VisitUnaryImag(const UnaryOperator *E);\n\n  bool VisitCXXNoexceptExpr(const CXXNoexceptExpr *E);\n  bool VisitSizeOfPackExpr(const SizeOfPackExpr *E);\n  bool VisitSourceLocExpr(const SourceLocExpr *E);\n  bool VisitConceptSpecializationExpr(const ConceptSpecializationExpr *E);\n  bool VisitRequiresExpr(const RequiresExpr *E);\n  // FIXME: Missing: array subscript of vector, member of vector\n};\n\nclass FixedPointExprEvaluator\n    : public ExprEvaluatorBase<FixedPointExprEvaluator> {\n  APValue &Result;\n\n public:\n  FixedPointExprEvaluator(EvalInfo &info, APValue &result)\n      : ExprEvaluatorBaseTy(info), Result(result) {}\n\n  bool Success(const llvm::APInt &I, const Expr *E) {\n    return Success(\n        APFixedPoint(I, Info.Ctx.getFixedPointSemantics(E->getType())), E);\n  }\n\n  bool Success(uint64_t Value, const Expr *E) {\n    return Success(\n        APFixedPoint(Value, Info.Ctx.getFixedPointSemantics(E->getType())), E);\n  }\n\n  bool Success(const APValue &V, const Expr *E) {\n    return Success(V.getFixedPoint(), E);\n  }\n\n  bool Success(const APFixedPoint &V, const Expr *E) {\n    assert(E->getType()->isFixedPointType() && \"Invalid evaluation result.\");\n    assert(V.getWidth() == Info.Ctx.getIntWidth(E->getType()) &&\n           \"Invalid evaluation result.\");\n    Result = APValue(V);\n    return true;\n  }\n\n  //===--------------------------------------------------------------------===//\n  //                            Visitor Methods\n  //===--------------------------------------------------------------------===//\n\n  bool VisitFixedPointLiteral(const FixedPointLiteral *E) {\n    return Success(E->getValue(), E);\n  }\n\n  bool VisitCastExpr(const CastExpr *E);\n  bool VisitUnaryOperator(const UnaryOperator *E);\n  bool VisitBinaryOperator(const BinaryOperator *E);\n};\n} // end anonymous namespace\n\n/// EvaluateIntegerOrLValue - Evaluate an rvalue integral-typed expression, and\n/// produce either the integer value or a pointer.\n///\n/// GCC has a heinous extension which folds casts between pointer types and\n/// pointer-sized integral types. We support this by allowing the evaluation of\n/// an integer rvalue to produce a pointer (represented as an lvalue) instead.\n/// Some simple arithmetic on such values is supported (they are treated much\n/// like char*).\nstatic bool EvaluateIntegerOrLValue(const Expr *E, APValue &Result,\n                                    EvalInfo &Info) {\n  assert(!E->isValueDependent());\n  assert(E->isRValue() && E->getType()->isIntegralOrEnumerationType());\n  return IntExprEvaluator(Info, Result).Visit(E);\n}\n\nstatic bool EvaluateInteger(const Expr *E, APSInt &Result, EvalInfo &Info) {\n  assert(!E->isValueDependent());\n  APValue Val;\n  if (!EvaluateIntegerOrLValue(E, Val, Info))\n    return false;\n  if (!Val.isInt()) {\n    // FIXME: It would be better to produce the diagnostic for casting\n    //        a pointer to an integer.\n    Info.FFDiag(E, diag::note_invalid_subexpr_in_const_expr);\n    return false;\n  }\n  Result = Val.getInt();\n  return true;\n}\n\nbool IntExprEvaluator::VisitSourceLocExpr(const SourceLocExpr *E) {\n  APValue Evaluated = E->EvaluateInContext(\n      Info.Ctx, Info.CurrentCall->CurSourceLocExprScope.getDefaultExpr());\n  return Success(Evaluated, E);\n}\n\nstatic bool EvaluateFixedPoint(const Expr *E, APFixedPoint &Result,\n                               EvalInfo &Info) {\n  assert(!E->isValueDependent());\n  if (E->getType()->isFixedPointType()) {\n    APValue Val;\n    if (!FixedPointExprEvaluator(Info, Val).Visit(E))\n      return false;\n    if (!Val.isFixedPoint())\n      return false;\n\n    Result = Val.getFixedPoint();\n    return true;\n  }\n  return false;\n}\n\nstatic bool EvaluateFixedPointOrInteger(const Expr *E, APFixedPoint &Result,\n                                        EvalInfo &Info) {\n  assert(!E->isValueDependent());\n  if (E->getType()->isIntegerType()) {\n    auto FXSema = Info.Ctx.getFixedPointSemantics(E->getType());\n    APSInt Val;\n    if (!EvaluateInteger(E, Val, Info))\n      return false;\n    Result = APFixedPoint(Val, FXSema);\n    return true;\n  } else if (E->getType()->isFixedPointType()) {\n    return EvaluateFixedPoint(E, Result, Info);\n  }\n  return false;\n}\n\n/// Check whether the given declaration can be directly converted to an integral\n/// rvalue. If not, no diagnostic is produced; there are other things we can\n/// try.\nbool IntExprEvaluator::CheckReferencedDecl(const Expr* E, const Decl* D) {\n  // Enums are integer constant exprs.\n  if (const EnumConstantDecl *ECD = dyn_cast<EnumConstantDecl>(D)) {\n    // Check for signedness/width mismatches between E type and ECD value.\n    bool SameSign = (ECD->getInitVal().isSigned()\n                     == E->getType()->isSignedIntegerOrEnumerationType());\n    bool SameWidth = (ECD->getInitVal().getBitWidth()\n                      == Info.Ctx.getIntWidth(E->getType()));\n    if (SameSign && SameWidth)\n      return Success(ECD->getInitVal(), E);\n    else {\n      // Get rid of mismatch (otherwise Success assertions will fail)\n      // by computing a new value matching the type of E.\n      llvm::APSInt Val = ECD->getInitVal();\n      if (!SameSign)\n        Val.setIsSigned(!ECD->getInitVal().isSigned());\n      if (!SameWidth)\n        Val = Val.extOrTrunc(Info.Ctx.getIntWidth(E->getType()));\n      return Success(Val, E);\n    }\n  }\n  return false;\n}\n\n/// Values returned by __builtin_classify_type, chosen to match the values\n/// produced by GCC's builtin.\nenum class GCCTypeClass {\n  None = -1,\n  Void = 0,\n  Integer = 1,\n  // GCC reserves 2 for character types, but instead classifies them as\n  // integers.\n  Enum = 3,\n  Bool = 4,\n  Pointer = 5,\n  // GCC reserves 6 for references, but appears to never use it (because\n  // expressions never have reference type, presumably).\n  PointerToDataMember = 7,\n  RealFloat = 8,\n  Complex = 9,\n  // GCC reserves 10 for functions, but does not use it since GCC version 6 due\n  // to decay to pointer. (Prior to version 6 it was only used in C++ mode).\n  // GCC claims to reserve 11 for pointers to member functions, but *actually*\n  // uses 12 for that purpose, same as for a class or struct. Maybe it\n  // internally implements a pointer to member as a struct?  Who knows.\n  PointerToMemberFunction = 12, // Not a bug, see above.\n  ClassOrStruct = 12,\n  Union = 13,\n  // GCC reserves 14 for arrays, but does not use it since GCC version 6 due to\n  // decay to pointer. (Prior to version 6 it was only used in C++ mode).\n  // GCC reserves 15 for strings, but actually uses 5 (pointer) for string\n  // literals.\n};\n\n/// EvaluateBuiltinClassifyType - Evaluate __builtin_classify_type the same way\n/// as GCC.\nstatic GCCTypeClass\nEvaluateBuiltinClassifyType(QualType T, const LangOptions &LangOpts) {\n  assert(!T->isDependentType() && \"unexpected dependent type\");\n\n  QualType CanTy = T.getCanonicalType();\n  const BuiltinType *BT = dyn_cast<BuiltinType>(CanTy);\n\n  switch (CanTy->getTypeClass()) {\n#define TYPE(ID, BASE)\n#define DEPENDENT_TYPE(ID, BASE) case Type::ID:\n#define NON_CANONICAL_TYPE(ID, BASE) case Type::ID:\n#define NON_CANONICAL_UNLESS_DEPENDENT_TYPE(ID, BASE) case Type::ID:\n#include \"clang/AST/TypeNodes.inc\"\n  case Type::Auto:\n  case Type::DeducedTemplateSpecialization:\n      llvm_unreachable(\"unexpected non-canonical or dependent type\");\n\n  case Type::Builtin:\n    switch (BT->getKind()) {\n#define BUILTIN_TYPE(ID, SINGLETON_ID)\n#define SIGNED_TYPE(ID, SINGLETON_ID) \\\n    case BuiltinType::ID: return GCCTypeClass::Integer;\n#define FLOATING_TYPE(ID, SINGLETON_ID) \\\n    case BuiltinType::ID: return GCCTypeClass::RealFloat;\n#define PLACEHOLDER_TYPE(ID, SINGLETON_ID) \\\n    case BuiltinType::ID: break;\n#include \"clang/AST/BuiltinTypes.def\"\n    case BuiltinType::Void:\n      return GCCTypeClass::Void;\n\n    case BuiltinType::Bool:\n      return GCCTypeClass::Bool;\n\n    case BuiltinType::Char_U:\n    case BuiltinType::UChar:\n    case BuiltinType::WChar_U:\n    case BuiltinType::Char8:\n    case BuiltinType::Char16:\n    case BuiltinType::Char32:\n    case BuiltinType::UShort:\n    case BuiltinType::UInt:\n    case BuiltinType::ULong:\n    case BuiltinType::ULongLong:\n    case BuiltinType::UInt128:\n      return GCCTypeClass::Integer;\n\n    case BuiltinType::UShortAccum:\n    case BuiltinType::UAccum:\n    case BuiltinType::ULongAccum:\n    case BuiltinType::UShortFract:\n    case BuiltinType::UFract:\n    case BuiltinType::ULongFract:\n    case BuiltinType::SatUShortAccum:\n    case BuiltinType::SatUAccum:\n    case BuiltinType::SatULongAccum:\n    case BuiltinType::SatUShortFract:\n    case BuiltinType::SatUFract:\n    case BuiltinType::SatULongFract:\n      return GCCTypeClass::None;\n\n    case BuiltinType::NullPtr:\n\n    case BuiltinType::ObjCId:\n    case BuiltinType::ObjCClass:\n    case BuiltinType::ObjCSel:\n#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \\\n    case BuiltinType::Id:\n#include \"clang/Basic/OpenCLImageTypes.def\"\n#define EXT_OPAQUE_TYPE(ExtType, Id, Ext) \\\n    case BuiltinType::Id:\n#include \"clang/Basic/OpenCLExtensionTypes.def\"\n    case BuiltinType::OCLSampler:\n    case BuiltinType::OCLEvent:\n    case BuiltinType::OCLClkEvent:\n    case BuiltinType::OCLQueue:\n    case BuiltinType::OCLReserveID:\n#define SVE_TYPE(Name, Id, SingletonId) \\\n    case BuiltinType::Id:\n#include \"clang/Basic/AArch64SVEACLETypes.def\"\n#define PPC_VECTOR_TYPE(Name, Id, Size) \\\n    case BuiltinType::Id:\n#include \"clang/Basic/PPCTypes.def\"\n#define RVV_TYPE(Name, Id, SingletonId) case BuiltinType::Id:\n#include \"clang/Basic/RISCVVTypes.def\"\n      return GCCTypeClass::None;\n\n    case BuiltinType::Dependent:\n      llvm_unreachable(\"unexpected dependent type\");\n    };\n    llvm_unreachable(\"unexpected placeholder type\");\n\n  case Type::Enum:\n    return LangOpts.CPlusPlus ? GCCTypeClass::Enum : GCCTypeClass::Integer;\n\n  case Type::Pointer:\n  case Type::ConstantArray:\n  case Type::VariableArray:\n  case Type::IncompleteArray:\n  case Type::FunctionNoProto:\n  case Type::FunctionProto:\n    return GCCTypeClass::Pointer;\n\n  case Type::MemberPointer:\n    return CanTy->isMemberDataPointerType()\n               ? GCCTypeClass::PointerToDataMember\n               : GCCTypeClass::PointerToMemberFunction;\n\n  case Type::Complex:\n    return GCCTypeClass::Complex;\n\n  case Type::Record:\n    return CanTy->isUnionType() ? GCCTypeClass::Union\n                                : GCCTypeClass::ClassOrStruct;\n\n  case Type::Atomic:\n    // GCC classifies _Atomic T the same as T.\n    return EvaluateBuiltinClassifyType(\n        CanTy->castAs<AtomicType>()->getValueType(), LangOpts);\n\n  case Type::BlockPointer:\n  case Type::Vector:\n  case Type::ExtVector:\n  case Type::ConstantMatrix:\n  case Type::ObjCObject:\n  case Type::ObjCInterface:\n  case Type::ObjCObjectPointer:\n  case Type::Pipe:\n  case Type::ExtInt:\n    // GCC classifies vectors as None. We follow its lead and classify all\n    // other types that don't fit into the regular classification the same way.\n    return GCCTypeClass::None;\n\n  case Type::LValueReference:\n  case Type::RValueReference:\n    llvm_unreachable(\"invalid type for expression\");\n  }\n\n  llvm_unreachable(\"unexpected type class\");\n}\n\n/// EvaluateBuiltinClassifyType - Evaluate __builtin_classify_type the same way\n/// as GCC.\nstatic GCCTypeClass\nEvaluateBuiltinClassifyType(const CallExpr *E, const LangOptions &LangOpts) {\n  // If no argument was supplied, default to None. This isn't\n  // ideal, however it is what gcc does.\n  if (E->getNumArgs() == 0)\n    return GCCTypeClass::None;\n\n  // FIXME: Bizarrely, GCC treats a call with more than one argument as not\n  // being an ICE, but still folds it to a constant using the type of the first\n  // argument.\n  return EvaluateBuiltinClassifyType(E->getArg(0)->getType(), LangOpts);\n}\n\n/// EvaluateBuiltinConstantPForLValue - Determine the result of\n/// __builtin_constant_p when applied to the given pointer.\n///\n/// A pointer is only \"constant\" if it is null (or a pointer cast to integer)\n/// or it points to the first character of a string literal.\nstatic bool EvaluateBuiltinConstantPForLValue(const APValue &LV) {\n  APValue::LValueBase Base = LV.getLValueBase();\n  if (Base.isNull()) {\n    // A null base is acceptable.\n    return true;\n  } else if (const Expr *E = Base.dyn_cast<const Expr *>()) {\n    if (!isa<StringLiteral>(E))\n      return false;\n    return LV.getLValueOffset().isZero();\n  } else if (Base.is<TypeInfoLValue>()) {\n    // Surprisingly, GCC considers __builtin_constant_p(&typeid(int)) to\n    // evaluate to true.\n    return true;\n  } else {\n    // Any other base is not constant enough for GCC.\n    return false;\n  }\n}\n\n/// EvaluateBuiltinConstantP - Evaluate __builtin_constant_p as similarly to\n/// GCC as we can manage.\nstatic bool EvaluateBuiltinConstantP(EvalInfo &Info, const Expr *Arg) {\n  // This evaluation is not permitted to have side-effects, so evaluate it in\n  // a speculative evaluation context.\n  SpeculativeEvaluationRAII SpeculativeEval(Info);\n\n  // Constant-folding is always enabled for the operand of __builtin_constant_p\n  // (even when the enclosing evaluation context otherwise requires a strict\n  // language-specific constant expression).\n  FoldConstant Fold(Info, true);\n\n  QualType ArgType = Arg->getType();\n\n  // __builtin_constant_p always has one operand. The rules which gcc follows\n  // are not precisely documented, but are as follows:\n  //\n  //  - If the operand is of integral, floating, complex or enumeration type,\n  //    and can be folded to a known value of that type, it returns 1.\n  //  - If the operand can be folded to a pointer to the first character\n  //    of a string literal (or such a pointer cast to an integral type)\n  //    or to a null pointer or an integer cast to a pointer, it returns 1.\n  //\n  // Otherwise, it returns 0.\n  //\n  // FIXME: GCC also intends to return 1 for literals of aggregate types, but\n  // its support for this did not work prior to GCC 9 and is not yet well\n  // understood.\n  if (ArgType->isIntegralOrEnumerationType() || ArgType->isFloatingType() ||\n      ArgType->isAnyComplexType() || ArgType->isPointerType() ||\n      ArgType->isNullPtrType()) {\n    APValue V;\n    if (!::EvaluateAsRValue(Info, Arg, V) || Info.EvalStatus.HasSideEffects) {\n      Fold.keepDiagnostics();\n      return false;\n    }\n\n    // For a pointer (possibly cast to integer), there are special rules.\n    if (V.getKind() == APValue::LValue)\n      return EvaluateBuiltinConstantPForLValue(V);\n\n    // Otherwise, any constant value is good enough.\n    return V.hasValue();\n  }\n\n  // Anything else isn't considered to be sufficiently constant.\n  return false;\n}\n\n/// Retrieves the \"underlying object type\" of the given expression,\n/// as used by __builtin_object_size.\nstatic QualType getObjectType(APValue::LValueBase B) {\n  if (const ValueDecl *D = B.dyn_cast<const ValueDecl*>()) {\n    if (const VarDecl *VD = dyn_cast<VarDecl>(D))\n      return VD->getType();\n  } else if (const Expr *E = B.dyn_cast<const Expr*>()) {\n    if (isa<CompoundLiteralExpr>(E))\n      return E->getType();\n  } else if (B.is<TypeInfoLValue>()) {\n    return B.getTypeInfoType();\n  } else if (B.is<DynamicAllocLValue>()) {\n    return B.getDynamicAllocType();\n  }\n\n  return QualType();\n}\n\n/// A more selective version of E->IgnoreParenCasts for\n/// tryEvaluateBuiltinObjectSize. This ignores some casts/parens that serve only\n/// to change the type of E.\n/// Ex. For E = `(short*)((char*)(&foo))`, returns `&foo`\n///\n/// Always returns an RValue with a pointer representation.\nstatic const Expr *ignorePointerCastsAndParens(const Expr *E) {\n  assert(E->isRValue() && E->getType()->hasPointerRepresentation());\n\n  auto *NoParens = E->IgnoreParens();\n  auto *Cast = dyn_cast<CastExpr>(NoParens);\n  if (Cast == nullptr)\n    return NoParens;\n\n  // We only conservatively allow a few kinds of casts, because this code is\n  // inherently a simple solution that seeks to support the common case.\n  auto CastKind = Cast->getCastKind();\n  if (CastKind != CK_NoOp && CastKind != CK_BitCast &&\n      CastKind != CK_AddressSpaceConversion)\n    return NoParens;\n\n  auto *SubExpr = Cast->getSubExpr();\n  if (!SubExpr->getType()->hasPointerRepresentation() || !SubExpr->isRValue())\n    return NoParens;\n  return ignorePointerCastsAndParens(SubExpr);\n}\n\n/// Checks to see if the given LValue's Designator is at the end of the LValue's\n/// record layout. e.g.\n///   struct { struct { int a, b; } fst, snd; } obj;\n///   obj.fst   // no\n///   obj.snd   // yes\n///   obj.fst.a // no\n///   obj.fst.b // no\n///   obj.snd.a // no\n///   obj.snd.b // yes\n///\n/// Please note: this function is specialized for how __builtin_object_size\n/// views \"objects\".\n///\n/// If this encounters an invalid RecordDecl or otherwise cannot determine the\n/// correct result, it will always return true.\nstatic bool isDesignatorAtObjectEnd(const ASTContext &Ctx, const LValue &LVal) {\n  assert(!LVal.Designator.Invalid);\n\n  auto IsLastOrInvalidFieldDecl = [&Ctx](const FieldDecl *FD, bool &Invalid) {\n    const RecordDecl *Parent = FD->getParent();\n    Invalid = Parent->isInvalidDecl();\n    if (Invalid || Parent->isUnion())\n      return true;\n    const ASTRecordLayout &Layout = Ctx.getASTRecordLayout(Parent);\n    return FD->getFieldIndex() + 1 == Layout.getFieldCount();\n  };\n\n  auto &Base = LVal.getLValueBase();\n  if (auto *ME = dyn_cast_or_null<MemberExpr>(Base.dyn_cast<const Expr *>())) {\n    if (auto *FD = dyn_cast<FieldDecl>(ME->getMemberDecl())) {\n      bool Invalid;\n      if (!IsLastOrInvalidFieldDecl(FD, Invalid))\n        return Invalid;\n    } else if (auto *IFD = dyn_cast<IndirectFieldDecl>(ME->getMemberDecl())) {\n      for (auto *FD : IFD->chain()) {\n        bool Invalid;\n        if (!IsLastOrInvalidFieldDecl(cast<FieldDecl>(FD), Invalid))\n          return Invalid;\n      }\n    }\n  }\n\n  unsigned I = 0;\n  QualType BaseType = getType(Base);\n  if (LVal.Designator.FirstEntryIsAnUnsizedArray) {\n    // If we don't know the array bound, conservatively assume we're looking at\n    // the final array element.\n    ++I;\n    if (BaseType->isIncompleteArrayType())\n      BaseType = Ctx.getAsArrayType(BaseType)->getElementType();\n    else\n      BaseType = BaseType->castAs<PointerType>()->getPointeeType();\n  }\n\n  for (unsigned E = LVal.Designator.Entries.size(); I != E; ++I) {\n    const auto &Entry = LVal.Designator.Entries[I];\n    if (BaseType->isArrayType()) {\n      // Because __builtin_object_size treats arrays as objects, we can ignore\n      // the index iff this is the last array in the Designator.\n      if (I + 1 == E)\n        return true;\n      const auto *CAT = cast<ConstantArrayType>(Ctx.getAsArrayType(BaseType));\n      uint64_t Index = Entry.getAsArrayIndex();\n      if (Index + 1 != CAT->getSize())\n        return false;\n      BaseType = CAT->getElementType();\n    } else if (BaseType->isAnyComplexType()) {\n      const auto *CT = BaseType->castAs<ComplexType>();\n      uint64_t Index = Entry.getAsArrayIndex();\n      if (Index != 1)\n        return false;\n      BaseType = CT->getElementType();\n    } else if (auto *FD = getAsField(Entry)) {\n      bool Invalid;\n      if (!IsLastOrInvalidFieldDecl(FD, Invalid))\n        return Invalid;\n      BaseType = FD->getType();\n    } else {\n      assert(getAsBaseClass(Entry) && \"Expecting cast to a base class\");\n      return false;\n    }\n  }\n  return true;\n}\n\n/// Tests to see if the LValue has a user-specified designator (that isn't\n/// necessarily valid). Note that this always returns 'true' if the LValue has\n/// an unsized array as its first designator entry, because there's currently no\n/// way to tell if the user typed *foo or foo[0].\nstatic bool refersToCompleteObject(const LValue &LVal) {\n  if (LVal.Designator.Invalid)\n    return false;\n\n  if (!LVal.Designator.Entries.empty())\n    return LVal.Designator.isMostDerivedAnUnsizedArray();\n\n  if (!LVal.InvalidBase)\n    return true;\n\n  // If `E` is a MemberExpr, then the first part of the designator is hiding in\n  // the LValueBase.\n  const auto *E = LVal.Base.dyn_cast<const Expr *>();\n  return !E || !isa<MemberExpr>(E);\n}\n\n/// Attempts to detect a user writing into a piece of memory that's impossible\n/// to figure out the size of by just using types.\nstatic bool isUserWritingOffTheEnd(const ASTContext &Ctx, const LValue &LVal) {\n  const SubobjectDesignator &Designator = LVal.Designator;\n  // Notes:\n  // - Users can only write off of the end when we have an invalid base. Invalid\n  //   bases imply we don't know where the memory came from.\n  // - We used to be a bit more aggressive here; we'd only be conservative if\n  //   the array at the end was flexible, or if it had 0 or 1 elements. This\n  //   broke some common standard library extensions (PR30346), but was\n  //   otherwise seemingly fine. It may be useful to reintroduce this behavior\n  //   with some sort of list. OTOH, it seems that GCC is always\n  //   conservative with the last element in structs (if it's an array), so our\n  //   current behavior is more compatible than an explicit list approach would\n  //   be.\n  return LVal.InvalidBase &&\n         Designator.Entries.size() == Designator.MostDerivedPathLength &&\n         Designator.MostDerivedIsArrayElement &&\n         isDesignatorAtObjectEnd(Ctx, LVal);\n}\n\n/// Converts the given APInt to CharUnits, assuming the APInt is unsigned.\n/// Fails if the conversion would cause loss of precision.\nstatic bool convertUnsignedAPIntToCharUnits(const llvm::APInt &Int,\n                                            CharUnits &Result) {\n  auto CharUnitsMax = std::numeric_limits<CharUnits::QuantityType>::max();\n  if (Int.ugt(CharUnitsMax))\n    return false;\n  Result = CharUnits::fromQuantity(Int.getZExtValue());\n  return true;\n}\n\n/// Helper for tryEvaluateBuiltinObjectSize -- Given an LValue, this will\n/// determine how many bytes exist from the beginning of the object to either\n/// the end of the current subobject, or the end of the object itself, depending\n/// on what the LValue looks like + the value of Type.\n///\n/// If this returns false, the value of Result is undefined.\nstatic bool determineEndOffset(EvalInfo &Info, SourceLocation ExprLoc,\n                               unsigned Type, const LValue &LVal,\n                               CharUnits &EndOffset) {\n  bool DetermineForCompleteObject = refersToCompleteObject(LVal);\n\n  auto CheckedHandleSizeof = [&](QualType Ty, CharUnits &Result) {\n    if (Ty.isNull() || Ty->isIncompleteType() || Ty->isFunctionType())\n      return false;\n    return HandleSizeof(Info, ExprLoc, Ty, Result);\n  };\n\n  // We want to evaluate the size of the entire object. This is a valid fallback\n  // for when Type=1 and the designator is invalid, because we're asked for an\n  // upper-bound.\n  if (!(Type & 1) || LVal.Designator.Invalid || DetermineForCompleteObject) {\n    // Type=3 wants a lower bound, so we can't fall back to this.\n    if (Type == 3 && !DetermineForCompleteObject)\n      return false;\n\n    llvm::APInt APEndOffset;\n    if (isBaseAnAllocSizeCall(LVal.getLValueBase()) &&\n        getBytesReturnedByAllocSizeCall(Info.Ctx, LVal, APEndOffset))\n      return convertUnsignedAPIntToCharUnits(APEndOffset, EndOffset);\n\n    if (LVal.InvalidBase)\n      return false;\n\n    QualType BaseTy = getObjectType(LVal.getLValueBase());\n    return CheckedHandleSizeof(BaseTy, EndOffset);\n  }\n\n  // We want to evaluate the size of a subobject.\n  const SubobjectDesignator &Designator = LVal.Designator;\n\n  // The following is a moderately common idiom in C:\n  //\n  // struct Foo { int a; char c[1]; };\n  // struct Foo *F = (struct Foo *)malloc(sizeof(struct Foo) + strlen(Bar));\n  // strcpy(&F->c[0], Bar);\n  //\n  // In order to not break too much legacy code, we need to support it.\n  if (isUserWritingOffTheEnd(Info.Ctx, LVal)) {\n    // If we can resolve this to an alloc_size call, we can hand that back,\n    // because we know for certain how many bytes there are to write to.\n    llvm::APInt APEndOffset;\n    if (isBaseAnAllocSizeCall(LVal.getLValueBase()) &&\n        getBytesReturnedByAllocSizeCall(Info.Ctx, LVal, APEndOffset))\n      return convertUnsignedAPIntToCharUnits(APEndOffset, EndOffset);\n\n    // If we cannot determine the size of the initial allocation, then we can't\n    // given an accurate upper-bound. However, we are still able to give\n    // conservative lower-bounds for Type=3.\n    if (Type == 1)\n      return false;\n  }\n\n  CharUnits BytesPerElem;\n  if (!CheckedHandleSizeof(Designator.MostDerivedType, BytesPerElem))\n    return false;\n\n  // According to the GCC documentation, we want the size of the subobject\n  // denoted by the pointer. But that's not quite right -- what we actually\n  // want is the size of the immediately-enclosing array, if there is one.\n  int64_t ElemsRemaining;\n  if (Designator.MostDerivedIsArrayElement &&\n      Designator.Entries.size() == Designator.MostDerivedPathLength) {\n    uint64_t ArraySize = Designator.getMostDerivedArraySize();\n    uint64_t ArrayIndex = Designator.Entries.back().getAsArrayIndex();\n    ElemsRemaining = ArraySize <= ArrayIndex ? 0 : ArraySize - ArrayIndex;\n  } else {\n    ElemsRemaining = Designator.isOnePastTheEnd() ? 0 : 1;\n  }\n\n  EndOffset = LVal.getLValueOffset() + BytesPerElem * ElemsRemaining;\n  return true;\n}\n\n/// Tries to evaluate the __builtin_object_size for @p E. If successful,\n/// returns true and stores the result in @p Size.\n///\n/// If @p WasError is non-null, this will report whether the failure to evaluate\n/// is to be treated as an Error in IntExprEvaluator.\nstatic bool tryEvaluateBuiltinObjectSize(const Expr *E, unsigned Type,\n                                         EvalInfo &Info, uint64_t &Size) {\n  // Determine the denoted object.\n  LValue LVal;\n  {\n    // The operand of __builtin_object_size is never evaluated for side-effects.\n    // If there are any, but we can determine the pointed-to object anyway, then\n    // ignore the side-effects.\n    SpeculativeEvaluationRAII SpeculativeEval(Info);\n    IgnoreSideEffectsRAII Fold(Info);\n\n    if (E->isGLValue()) {\n      // It's possible for us to be given GLValues if we're called via\n      // Expr::tryEvaluateObjectSize.\n      APValue RVal;\n      if (!EvaluateAsRValue(Info, E, RVal))\n        return false;\n      LVal.setFrom(Info.Ctx, RVal);\n    } else if (!EvaluatePointer(ignorePointerCastsAndParens(E), LVal, Info,\n                                /*InvalidBaseOK=*/true))\n      return false;\n  }\n\n  // If we point to before the start of the object, there are no accessible\n  // bytes.\n  if (LVal.getLValueOffset().isNegative()) {\n    Size = 0;\n    return true;\n  }\n\n  CharUnits EndOffset;\n  if (!determineEndOffset(Info, E->getExprLoc(), Type, LVal, EndOffset))\n    return false;\n\n  // If we've fallen outside of the end offset, just pretend there's nothing to\n  // write to/read from.\n  if (EndOffset <= LVal.getLValueOffset())\n    Size = 0;\n  else\n    Size = (EndOffset - LVal.getLValueOffset()).getQuantity();\n  return true;\n}\n\nbool IntExprEvaluator::VisitCallExpr(const CallExpr *E) {\n  if (unsigned BuiltinOp = E->getBuiltinCallee())\n    return VisitBuiltinCallExpr(E, BuiltinOp);\n\n  return ExprEvaluatorBaseTy::VisitCallExpr(E);\n}\n\nstatic bool getBuiltinAlignArguments(const CallExpr *E, EvalInfo &Info,\n                                     APValue &Val, APSInt &Alignment) {\n  QualType SrcTy = E->getArg(0)->getType();\n  if (!getAlignmentArgument(E->getArg(1), SrcTy, Info, Alignment))\n    return false;\n  // Even though we are evaluating integer expressions we could get a pointer\n  // argument for the __builtin_is_aligned() case.\n  if (SrcTy->isPointerType()) {\n    LValue Ptr;\n    if (!EvaluatePointer(E->getArg(0), Ptr, Info))\n      return false;\n    Ptr.moveInto(Val);\n  } else if (!SrcTy->isIntegralOrEnumerationType()) {\n    Info.FFDiag(E->getArg(0));\n    return false;\n  } else {\n    APSInt SrcInt;\n    if (!EvaluateInteger(E->getArg(0), SrcInt, Info))\n      return false;\n    assert(SrcInt.getBitWidth() >= Alignment.getBitWidth() &&\n           \"Bit widths must be the same\");\n    Val = APValue(SrcInt);\n  }\n  assert(Val.hasValue());\n  return true;\n}\n\nbool IntExprEvaluator::VisitBuiltinCallExpr(const CallExpr *E,\n                                            unsigned BuiltinOp) {\n  switch (BuiltinOp) {\n  default:\n    return ExprEvaluatorBaseTy::VisitCallExpr(E);\n\n  case Builtin::BI__builtin_dynamic_object_size:\n  case Builtin::BI__builtin_object_size: {\n    // The type was checked when we built the expression.\n    unsigned Type =\n        E->getArg(1)->EvaluateKnownConstInt(Info.Ctx).getZExtValue();\n    assert(Type <= 3 && \"unexpected type\");\n\n    uint64_t Size;\n    if (tryEvaluateBuiltinObjectSize(E->getArg(0), Type, Info, Size))\n      return Success(Size, E);\n\n    if (E->getArg(0)->HasSideEffects(Info.Ctx))\n      return Success((Type & 2) ? 0 : -1, E);\n\n    // Expression had no side effects, but we couldn't statically determine the\n    // size of the referenced object.\n    switch (Info.EvalMode) {\n    case EvalInfo::EM_ConstantExpression:\n    case EvalInfo::EM_ConstantFold:\n    case EvalInfo::EM_IgnoreSideEffects:\n      // Leave it to IR generation.\n      return Error(E);\n    case EvalInfo::EM_ConstantExpressionUnevaluated:\n      // Reduce it to a constant now.\n      return Success((Type & 2) ? 0 : -1, E);\n    }\n\n    llvm_unreachable(\"unexpected EvalMode\");\n  }\n\n  case Builtin::BI__builtin_os_log_format_buffer_size: {\n    analyze_os_log::OSLogBufferLayout Layout;\n    analyze_os_log::computeOSLogBufferLayout(Info.Ctx, E, Layout);\n    return Success(Layout.size().getQuantity(), E);\n  }\n\n  case Builtin::BI__builtin_is_aligned: {\n    APValue Src;\n    APSInt Alignment;\n    if (!getBuiltinAlignArguments(E, Info, Src, Alignment))\n      return false;\n    if (Src.isLValue()) {\n      // If we evaluated a pointer, check the minimum known alignment.\n      LValue Ptr;\n      Ptr.setFrom(Info.Ctx, Src);\n      CharUnits BaseAlignment = getBaseAlignment(Info, Ptr);\n      CharUnits PtrAlign = BaseAlignment.alignmentAtOffset(Ptr.Offset);\n      // We can return true if the known alignment at the computed offset is\n      // greater than the requested alignment.\n      assert(PtrAlign.isPowerOfTwo());\n      assert(Alignment.isPowerOf2());\n      if (PtrAlign.getQuantity() >= Alignment)\n        return Success(1, E);\n      // If the alignment is not known to be sufficient, some cases could still\n      // be aligned at run time. However, if the requested alignment is less or\n      // equal to the base alignment and the offset is not aligned, we know that\n      // the run-time value can never be aligned.\n      if (BaseAlignment.getQuantity() >= Alignment &&\n          PtrAlign.getQuantity() < Alignment)\n        return Success(0, E);\n      // Otherwise we can't infer whether the value is sufficiently aligned.\n      // TODO: __builtin_is_aligned(__builtin_align_{down,up{(expr, N), N)\n      //  in cases where we can't fully evaluate the pointer.\n      Info.FFDiag(E->getArg(0), diag::note_constexpr_alignment_compute)\n          << Alignment;\n      return false;\n    }\n    assert(Src.isInt());\n    return Success((Src.getInt() & (Alignment - 1)) == 0 ? 1 : 0, E);\n  }\n  case Builtin::BI__builtin_align_up: {\n    APValue Src;\n    APSInt Alignment;\n    if (!getBuiltinAlignArguments(E, Info, Src, Alignment))\n      return false;\n    if (!Src.isInt())\n      return Error(E);\n    APSInt AlignedVal =\n        APSInt((Src.getInt() + (Alignment - 1)) & ~(Alignment - 1),\n               Src.getInt().isUnsigned());\n    assert(AlignedVal.getBitWidth() == Src.getInt().getBitWidth());\n    return Success(AlignedVal, E);\n  }\n  case Builtin::BI__builtin_align_down: {\n    APValue Src;\n    APSInt Alignment;\n    if (!getBuiltinAlignArguments(E, Info, Src, Alignment))\n      return false;\n    if (!Src.isInt())\n      return Error(E);\n    APSInt AlignedVal =\n        APSInt(Src.getInt() & ~(Alignment - 1), Src.getInt().isUnsigned());\n    assert(AlignedVal.getBitWidth() == Src.getInt().getBitWidth());\n    return Success(AlignedVal, E);\n  }\n\n  case Builtin::BI__builtin_bitreverse8:\n  case Builtin::BI__builtin_bitreverse16:\n  case Builtin::BI__builtin_bitreverse32:\n  case Builtin::BI__builtin_bitreverse64: {\n    APSInt Val;\n    if (!EvaluateInteger(E->getArg(0), Val, Info))\n      return false;\n\n    return Success(Val.reverseBits(), E);\n  }\n\n  case Builtin::BI__builtin_bswap16:\n  case Builtin::BI__builtin_bswap32:\n  case Builtin::BI__builtin_bswap64: {\n    APSInt Val;\n    if (!EvaluateInteger(E->getArg(0), Val, Info))\n      return false;\n\n    return Success(Val.byteSwap(), E);\n  }\n\n  case Builtin::BI__builtin_classify_type:\n    return Success((int)EvaluateBuiltinClassifyType(E, Info.getLangOpts()), E);\n\n  case Builtin::BI__builtin_clrsb:\n  case Builtin::BI__builtin_clrsbl:\n  case Builtin::BI__builtin_clrsbll: {\n    APSInt Val;\n    if (!EvaluateInteger(E->getArg(0), Val, Info))\n      return false;\n\n    return Success(Val.getBitWidth() - Val.getMinSignedBits(), E);\n  }\n\n  case Builtin::BI__builtin_clz:\n  case Builtin::BI__builtin_clzl:\n  case Builtin::BI__builtin_clzll:\n  case Builtin::BI__builtin_clzs: {\n    APSInt Val;\n    if (!EvaluateInteger(E->getArg(0), Val, Info))\n      return false;\n    if (!Val)\n      return Error(E);\n\n    return Success(Val.countLeadingZeros(), E);\n  }\n\n  case Builtin::BI__builtin_constant_p: {\n    const Expr *Arg = E->getArg(0);\n    if (EvaluateBuiltinConstantP(Info, Arg))\n      return Success(true, E);\n    if (Info.InConstantContext || Arg->HasSideEffects(Info.Ctx)) {\n      // Outside a constant context, eagerly evaluate to false in the presence\n      // of side-effects in order to avoid -Wunsequenced false-positives in\n      // a branch on __builtin_constant_p(expr).\n      return Success(false, E);\n    }\n    Info.FFDiag(E, diag::note_invalid_subexpr_in_const_expr);\n    return false;\n  }\n\n  case Builtin::BI__builtin_is_constant_evaluated: {\n    const auto *Callee = Info.CurrentCall->getCallee();\n    if (Info.InConstantContext && !Info.CheckingPotentialConstantExpression &&\n        (Info.CallStackDepth == 1 ||\n         (Info.CallStackDepth == 2 && Callee->isInStdNamespace() &&\n          Callee->getIdentifier() &&\n          Callee->getIdentifier()->isStr(\"is_constant_evaluated\")))) {\n      // FIXME: Find a better way to avoid duplicated diagnostics.\n      if (Info.EvalStatus.Diag)\n        Info.report((Info.CallStackDepth == 1) ? E->getExprLoc()\n                                               : Info.CurrentCall->CallLoc,\n                    diag::warn_is_constant_evaluated_always_true_constexpr)\n            << (Info.CallStackDepth == 1 ? \"__builtin_is_constant_evaluated\"\n                                         : \"std::is_constant_evaluated\");\n    }\n\n    return Success(Info.InConstantContext, E);\n  }\n\n  case Builtin::BI__builtin_ctz:\n  case Builtin::BI__builtin_ctzl:\n  case Builtin::BI__builtin_ctzll:\n  case Builtin::BI__builtin_ctzs: {\n    APSInt Val;\n    if (!EvaluateInteger(E->getArg(0), Val, Info))\n      return false;\n    if (!Val)\n      return Error(E);\n\n    return Success(Val.countTrailingZeros(), E);\n  }\n\n  case Builtin::BI__builtin_eh_return_data_regno: {\n    int Operand = E->getArg(0)->EvaluateKnownConstInt(Info.Ctx).getZExtValue();\n    Operand = Info.Ctx.getTargetInfo().getEHDataRegisterNumber(Operand);\n    return Success(Operand, E);\n  }\n\n  case Builtin::BI__builtin_expect:\n  case Builtin::BI__builtin_expect_with_probability:\n    return Visit(E->getArg(0));\n\n  case Builtin::BI__builtin_ffs:\n  case Builtin::BI__builtin_ffsl:\n  case Builtin::BI__builtin_ffsll: {\n    APSInt Val;\n    if (!EvaluateInteger(E->getArg(0), Val, Info))\n      return false;\n\n    unsigned N = Val.countTrailingZeros();\n    return Success(N == Val.getBitWidth() ? 0 : N + 1, E);\n  }\n\n  case Builtin::BI__builtin_fpclassify: {\n    APFloat Val(0.0);\n    if (!EvaluateFloat(E->getArg(5), Val, Info))\n      return false;\n    unsigned Arg;\n    switch (Val.getCategory()) {\n    case APFloat::fcNaN: Arg = 0; break;\n    case APFloat::fcInfinity: Arg = 1; break;\n    case APFloat::fcNormal: Arg = Val.isDenormal() ? 3 : 2; break;\n    case APFloat::fcZero: Arg = 4; break;\n    }\n    return Visit(E->getArg(Arg));\n  }\n\n  case Builtin::BI__builtin_isinf_sign: {\n    APFloat Val(0.0);\n    return EvaluateFloat(E->getArg(0), Val, Info) &&\n           Success(Val.isInfinity() ? (Val.isNegative() ? -1 : 1) : 0, E);\n  }\n\n  case Builtin::BI__builtin_isinf: {\n    APFloat Val(0.0);\n    return EvaluateFloat(E->getArg(0), Val, Info) &&\n           Success(Val.isInfinity() ? 1 : 0, E);\n  }\n\n  case Builtin::BI__builtin_isfinite: {\n    APFloat Val(0.0);\n    return EvaluateFloat(E->getArg(0), Val, Info) &&\n           Success(Val.isFinite() ? 1 : 0, E);\n  }\n\n  case Builtin::BI__builtin_isnan: {\n    APFloat Val(0.0);\n    return EvaluateFloat(E->getArg(0), Val, Info) &&\n           Success(Val.isNaN() ? 1 : 0, E);\n  }\n\n  case Builtin::BI__builtin_isnormal: {\n    APFloat Val(0.0);\n    return EvaluateFloat(E->getArg(0), Val, Info) &&\n           Success(Val.isNormal() ? 1 : 0, E);\n  }\n\n  case Builtin::BI__builtin_parity:\n  case Builtin::BI__builtin_parityl:\n  case Builtin::BI__builtin_parityll: {\n    APSInt Val;\n    if (!EvaluateInteger(E->getArg(0), Val, Info))\n      return false;\n\n    return Success(Val.countPopulation() % 2, E);\n  }\n\n  case Builtin::BI__builtin_popcount:\n  case Builtin::BI__builtin_popcountl:\n  case Builtin::BI__builtin_popcountll: {\n    APSInt Val;\n    if (!EvaluateInteger(E->getArg(0), Val, Info))\n      return false;\n\n    return Success(Val.countPopulation(), E);\n  }\n\n  case Builtin::BI__builtin_rotateleft8:\n  case Builtin::BI__builtin_rotateleft16:\n  case Builtin::BI__builtin_rotateleft32:\n  case Builtin::BI__builtin_rotateleft64:\n  case Builtin::BI_rotl8: // Microsoft variants of rotate right\n  case Builtin::BI_rotl16:\n  case Builtin::BI_rotl:\n  case Builtin::BI_lrotl:\n  case Builtin::BI_rotl64: {\n    APSInt Val, Amt;\n    if (!EvaluateInteger(E->getArg(0), Val, Info) ||\n        !EvaluateInteger(E->getArg(1), Amt, Info))\n      return false;\n\n    return Success(Val.rotl(Amt.urem(Val.getBitWidth())), E);\n  }\n\n  case Builtin::BI__builtin_rotateright8:\n  case Builtin::BI__builtin_rotateright16:\n  case Builtin::BI__builtin_rotateright32:\n  case Builtin::BI__builtin_rotateright64:\n  case Builtin::BI_rotr8: // Microsoft variants of rotate right\n  case Builtin::BI_rotr16:\n  case Builtin::BI_rotr:\n  case Builtin::BI_lrotr:\n  case Builtin::BI_rotr64: {\n    APSInt Val, Amt;\n    if (!EvaluateInteger(E->getArg(0), Val, Info) ||\n        !EvaluateInteger(E->getArg(1), Amt, Info))\n      return false;\n\n    return Success(Val.rotr(Amt.urem(Val.getBitWidth())), E);\n  }\n\n  case Builtin::BIstrlen:\n  case Builtin::BIwcslen:\n    // A call to strlen is not a constant expression.\n    if (Info.getLangOpts().CPlusPlus11)\n      Info.CCEDiag(E, diag::note_constexpr_invalid_function)\n        << /*isConstexpr*/0 << /*isConstructor*/0\n        << (std::string(\"'\") + Info.Ctx.BuiltinInfo.getName(BuiltinOp) + \"'\");\n    else\n      Info.CCEDiag(E, diag::note_invalid_subexpr_in_const_expr);\n    LLVM_FALLTHROUGH;\n  case Builtin::BI__builtin_strlen:\n  case Builtin::BI__builtin_wcslen: {\n    // As an extension, we support __builtin_strlen() as a constant expression,\n    // and support folding strlen() to a constant.\n    LValue String;\n    if (!EvaluatePointer(E->getArg(0), String, Info))\n      return false;\n\n    QualType CharTy = E->getArg(0)->getType()->getPointeeType();\n\n    // Fast path: if it's a string literal, search the string value.\n    if (const StringLiteral *S = dyn_cast_or_null<StringLiteral>(\n            String.getLValueBase().dyn_cast<const Expr *>())) {\n      // The string literal may have embedded null characters. Find the first\n      // one and truncate there.\n      StringRef Str = S->getBytes();\n      int64_t Off = String.Offset.getQuantity();\n      if (Off >= 0 && (uint64_t)Off <= (uint64_t)Str.size() &&\n          S->getCharByteWidth() == 1 &&\n          // FIXME: Add fast-path for wchar_t too.\n          Info.Ctx.hasSameUnqualifiedType(CharTy, Info.Ctx.CharTy)) {\n        Str = Str.substr(Off);\n\n        StringRef::size_type Pos = Str.find(0);\n        if (Pos != StringRef::npos)\n          Str = Str.substr(0, Pos);\n\n        return Success(Str.size(), E);\n      }\n\n      // Fall through to slow path to issue appropriate diagnostic.\n    }\n\n    // Slow path: scan the bytes of the string looking for the terminating 0.\n    for (uint64_t Strlen = 0; /**/; ++Strlen) {\n      APValue Char;\n      if (!handleLValueToRValueConversion(Info, E, CharTy, String, Char) ||\n          !Char.isInt())\n        return false;\n      if (!Char.getInt())\n        return Success(Strlen, E);\n      if (!HandleLValueArrayAdjustment(Info, E, String, CharTy, 1))\n        return false;\n    }\n  }\n\n  case Builtin::BIstrcmp:\n  case Builtin::BIwcscmp:\n  case Builtin::BIstrncmp:\n  case Builtin::BIwcsncmp:\n  case Builtin::BImemcmp:\n  case Builtin::BIbcmp:\n  case Builtin::BIwmemcmp:\n    // A call to strlen is not a constant expression.\n    if (Info.getLangOpts().CPlusPlus11)\n      Info.CCEDiag(E, diag::note_constexpr_invalid_function)\n        << /*isConstexpr*/0 << /*isConstructor*/0\n        << (std::string(\"'\") + Info.Ctx.BuiltinInfo.getName(BuiltinOp) + \"'\");\n    else\n      Info.CCEDiag(E, diag::note_invalid_subexpr_in_const_expr);\n    LLVM_FALLTHROUGH;\n  case Builtin::BI__builtin_strcmp:\n  case Builtin::BI__builtin_wcscmp:\n  case Builtin::BI__builtin_strncmp:\n  case Builtin::BI__builtin_wcsncmp:\n  case Builtin::BI__builtin_memcmp:\n  case Builtin::BI__builtin_bcmp:\n  case Builtin::BI__builtin_wmemcmp: {\n    LValue String1, String2;\n    if (!EvaluatePointer(E->getArg(0), String1, Info) ||\n        !EvaluatePointer(E->getArg(1), String2, Info))\n      return false;\n\n    uint64_t MaxLength = uint64_t(-1);\n    if (BuiltinOp != Builtin::BIstrcmp &&\n        BuiltinOp != Builtin::BIwcscmp &&\n        BuiltinOp != Builtin::BI__builtin_strcmp &&\n        BuiltinOp != Builtin::BI__builtin_wcscmp) {\n      APSInt N;\n      if (!EvaluateInteger(E->getArg(2), N, Info))\n        return false;\n      MaxLength = N.getExtValue();\n    }\n\n    // Empty substrings compare equal by definition.\n    if (MaxLength == 0u)\n      return Success(0, E);\n\n    if (!String1.checkNullPointerForFoldAccess(Info, E, AK_Read) ||\n        !String2.checkNullPointerForFoldAccess(Info, E, AK_Read) ||\n        String1.Designator.Invalid || String2.Designator.Invalid)\n      return false;\n\n    QualType CharTy1 = String1.Designator.getType(Info.Ctx);\n    QualType CharTy2 = String2.Designator.getType(Info.Ctx);\n\n    bool IsRawByte = BuiltinOp == Builtin::BImemcmp ||\n                     BuiltinOp == Builtin::BIbcmp ||\n                     BuiltinOp == Builtin::BI__builtin_memcmp ||\n                     BuiltinOp == Builtin::BI__builtin_bcmp;\n\n    assert(IsRawByte ||\n           (Info.Ctx.hasSameUnqualifiedType(\n                CharTy1, E->getArg(0)->getType()->getPointeeType()) &&\n            Info.Ctx.hasSameUnqualifiedType(CharTy1, CharTy2)));\n\n    // For memcmp, allow comparing any arrays of '[[un]signed] char' or\n    // 'char8_t', but no other types.\n    if (IsRawByte &&\n        !(isOneByteCharacterType(CharTy1) && isOneByteCharacterType(CharTy2))) {\n      // FIXME: Consider using our bit_cast implementation to support this.\n      Info.FFDiag(E, diag::note_constexpr_memcmp_unsupported)\n          << (std::string(\"'\") + Info.Ctx.BuiltinInfo.getName(BuiltinOp) + \"'\")\n          << CharTy1 << CharTy2;\n      return false;\n    }\n\n    const auto &ReadCurElems = [&](APValue &Char1, APValue &Char2) {\n      return handleLValueToRValueConversion(Info, E, CharTy1, String1, Char1) &&\n             handleLValueToRValueConversion(Info, E, CharTy2, String2, Char2) &&\n             Char1.isInt() && Char2.isInt();\n    };\n    const auto &AdvanceElems = [&] {\n      return HandleLValueArrayAdjustment(Info, E, String1, CharTy1, 1) &&\n             HandleLValueArrayAdjustment(Info, E, String2, CharTy2, 1);\n    };\n\n    bool StopAtNull =\n        (BuiltinOp != Builtin::BImemcmp && BuiltinOp != Builtin::BIbcmp &&\n         BuiltinOp != Builtin::BIwmemcmp &&\n         BuiltinOp != Builtin::BI__builtin_memcmp &&\n         BuiltinOp != Builtin::BI__builtin_bcmp &&\n         BuiltinOp != Builtin::BI__builtin_wmemcmp);\n    bool IsWide = BuiltinOp == Builtin::BIwcscmp ||\n                  BuiltinOp == Builtin::BIwcsncmp ||\n                  BuiltinOp == Builtin::BIwmemcmp ||\n                  BuiltinOp == Builtin::BI__builtin_wcscmp ||\n                  BuiltinOp == Builtin::BI__builtin_wcsncmp ||\n                  BuiltinOp == Builtin::BI__builtin_wmemcmp;\n\n    for (; MaxLength; --MaxLength) {\n      APValue Char1, Char2;\n      if (!ReadCurElems(Char1, Char2))\n        return false;\n      if (Char1.getInt().ne(Char2.getInt())) {\n        if (IsWide) // wmemcmp compares with wchar_t signedness.\n          return Success(Char1.getInt() < Char2.getInt() ? -1 : 1, E);\n        // memcmp always compares unsigned chars.\n        return Success(Char1.getInt().ult(Char2.getInt()) ? -1 : 1, E);\n      }\n      if (StopAtNull && !Char1.getInt())\n        return Success(0, E);\n      assert(!(StopAtNull && !Char2.getInt()));\n      if (!AdvanceElems())\n        return false;\n    }\n    // We hit the strncmp / memcmp limit.\n    return Success(0, E);\n  }\n\n  case Builtin::BI__atomic_always_lock_free:\n  case Builtin::BI__atomic_is_lock_free:\n  case Builtin::BI__c11_atomic_is_lock_free: {\n    APSInt SizeVal;\n    if (!EvaluateInteger(E->getArg(0), SizeVal, Info))\n      return false;\n\n    // For __atomic_is_lock_free(sizeof(_Atomic(T))), if the size is a power\n    // of two less than or equal to the maximum inline atomic width, we know it\n    // is lock-free.  If the size isn't a power of two, or greater than the\n    // maximum alignment where we promote atomics, we know it is not lock-free\n    // (at least not in the sense of atomic_is_lock_free).  Otherwise,\n    // the answer can only be determined at runtime; for example, 16-byte\n    // atomics have lock-free implementations on some, but not all,\n    // x86-64 processors.\n\n    // Check power-of-two.\n    CharUnits Size = CharUnits::fromQuantity(SizeVal.getZExtValue());\n    if (Size.isPowerOfTwo()) {\n      // Check against inlining width.\n      unsigned InlineWidthBits =\n          Info.Ctx.getTargetInfo().getMaxAtomicInlineWidth();\n      if (Size <= Info.Ctx.toCharUnitsFromBits(InlineWidthBits)) {\n        if (BuiltinOp == Builtin::BI__c11_atomic_is_lock_free ||\n            Size == CharUnits::One() ||\n            E->getArg(1)->isNullPointerConstant(Info.Ctx,\n                                                Expr::NPC_NeverValueDependent))\n          // OK, we will inline appropriately-aligned operations of this size,\n          // and _Atomic(T) is appropriately-aligned.\n          return Success(1, E);\n\n        QualType PointeeType = E->getArg(1)->IgnoreImpCasts()->getType()->\n          castAs<PointerType>()->getPointeeType();\n        if (!PointeeType->isIncompleteType() &&\n            Info.Ctx.getTypeAlignInChars(PointeeType) >= Size) {\n          // OK, we will inline operations on this object.\n          return Success(1, E);\n        }\n      }\n    }\n\n    return BuiltinOp == Builtin::BI__atomic_always_lock_free ?\n        Success(0, E) : Error(E);\n  }\n  case Builtin::BIomp_is_initial_device:\n    // We can decide statically which value the runtime would return if called.\n    return Success(Info.getLangOpts().OpenMPIsDevice ? 0 : 1, E);\n  case Builtin::BI__builtin_add_overflow:\n  case Builtin::BI__builtin_sub_overflow:\n  case Builtin::BI__builtin_mul_overflow:\n  case Builtin::BI__builtin_sadd_overflow:\n  case Builtin::BI__builtin_uadd_overflow:\n  case Builtin::BI__builtin_uaddl_overflow:\n  case Builtin::BI__builtin_uaddll_overflow:\n  case Builtin::BI__builtin_usub_overflow:\n  case Builtin::BI__builtin_usubl_overflow:\n  case Builtin::BI__builtin_usubll_overflow:\n  case Builtin::BI__builtin_umul_overflow:\n  case Builtin::BI__builtin_umull_overflow:\n  case Builtin::BI__builtin_umulll_overflow:\n  case Builtin::BI__builtin_saddl_overflow:\n  case Builtin::BI__builtin_saddll_overflow:\n  case Builtin::BI__builtin_ssub_overflow:\n  case Builtin::BI__builtin_ssubl_overflow:\n  case Builtin::BI__builtin_ssubll_overflow:\n  case Builtin::BI__builtin_smul_overflow:\n  case Builtin::BI__builtin_smull_overflow:\n  case Builtin::BI__builtin_smulll_overflow: {\n    LValue ResultLValue;\n    APSInt LHS, RHS;\n\n    QualType ResultType = E->getArg(2)->getType()->getPointeeType();\n    if (!EvaluateInteger(E->getArg(0), LHS, Info) ||\n        !EvaluateInteger(E->getArg(1), RHS, Info) ||\n        !EvaluatePointer(E->getArg(2), ResultLValue, Info))\n      return false;\n\n    APSInt Result;\n    bool DidOverflow = false;\n\n    // If the types don't have to match, enlarge all 3 to the largest of them.\n    if (BuiltinOp == Builtin::BI__builtin_add_overflow ||\n        BuiltinOp == Builtin::BI__builtin_sub_overflow ||\n        BuiltinOp == Builtin::BI__builtin_mul_overflow) {\n      bool IsSigned = LHS.isSigned() || RHS.isSigned() ||\n                      ResultType->isSignedIntegerOrEnumerationType();\n      bool AllSigned = LHS.isSigned() && RHS.isSigned() &&\n                      ResultType->isSignedIntegerOrEnumerationType();\n      uint64_t LHSSize = LHS.getBitWidth();\n      uint64_t RHSSize = RHS.getBitWidth();\n      uint64_t ResultSize = Info.Ctx.getTypeSize(ResultType);\n      uint64_t MaxBits = std::max(std::max(LHSSize, RHSSize), ResultSize);\n\n      // Add an additional bit if the signedness isn't uniformly agreed to. We\n      // could do this ONLY if there is a signed and an unsigned that both have\n      // MaxBits, but the code to check that is pretty nasty.  The issue will be\n      // caught in the shrink-to-result later anyway.\n      if (IsSigned && !AllSigned)\n        ++MaxBits;\n\n      LHS = APSInt(LHS.extOrTrunc(MaxBits), !IsSigned);\n      RHS = APSInt(RHS.extOrTrunc(MaxBits), !IsSigned);\n      Result = APSInt(MaxBits, !IsSigned);\n    }\n\n    // Find largest int.\n    switch (BuiltinOp) {\n    default:\n      llvm_unreachable(\"Invalid value for BuiltinOp\");\n    case Builtin::BI__builtin_add_overflow:\n    case Builtin::BI__builtin_sadd_overflow:\n    case Builtin::BI__builtin_saddl_overflow:\n    case Builtin::BI__builtin_saddll_overflow:\n    case Builtin::BI__builtin_uadd_overflow:\n    case Builtin::BI__builtin_uaddl_overflow:\n    case Builtin::BI__builtin_uaddll_overflow:\n      Result = LHS.isSigned() ? LHS.sadd_ov(RHS, DidOverflow)\n                              : LHS.uadd_ov(RHS, DidOverflow);\n      break;\n    case Builtin::BI__builtin_sub_overflow:\n    case Builtin::BI__builtin_ssub_overflow:\n    case Builtin::BI__builtin_ssubl_overflow:\n    case Builtin::BI__builtin_ssubll_overflow:\n    case Builtin::BI__builtin_usub_overflow:\n    case Builtin::BI__builtin_usubl_overflow:\n    case Builtin::BI__builtin_usubll_overflow:\n      Result = LHS.isSigned() ? LHS.ssub_ov(RHS, DidOverflow)\n                              : LHS.usub_ov(RHS, DidOverflow);\n      break;\n    case Builtin::BI__builtin_mul_overflow:\n    case Builtin::BI__builtin_smul_overflow:\n    case Builtin::BI__builtin_smull_overflow:\n    case Builtin::BI__builtin_smulll_overflow:\n    case Builtin::BI__builtin_umul_overflow:\n    case Builtin::BI__builtin_umull_overflow:\n    case Builtin::BI__builtin_umulll_overflow:\n      Result = LHS.isSigned() ? LHS.smul_ov(RHS, DidOverflow)\n                              : LHS.umul_ov(RHS, DidOverflow);\n      break;\n    }\n\n    // In the case where multiple sizes are allowed, truncate and see if\n    // the values are the same.\n    if (BuiltinOp == Builtin::BI__builtin_add_overflow ||\n        BuiltinOp == Builtin::BI__builtin_sub_overflow ||\n        BuiltinOp == Builtin::BI__builtin_mul_overflow) {\n      // APSInt doesn't have a TruncOrSelf, so we use extOrTrunc instead,\n      // since it will give us the behavior of a TruncOrSelf in the case where\n      // its parameter <= its size.  We previously set Result to be at least the\n      // type-size of the result, so getTypeSize(ResultType) <= Result.BitWidth\n      // will work exactly like TruncOrSelf.\n      APSInt Temp = Result.extOrTrunc(Info.Ctx.getTypeSize(ResultType));\n      Temp.setIsSigned(ResultType->isSignedIntegerOrEnumerationType());\n\n      if (!APSInt::isSameValue(Temp, Result))\n        DidOverflow = true;\n      Result = Temp;\n    }\n\n    APValue APV{Result};\n    if (!handleAssignment(Info, E, ResultLValue, ResultType, APV))\n      return false;\n    return Success(DidOverflow, E);\n  }\n  }\n}\n\n/// Determine whether this is a pointer past the end of the complete\n/// object referred to by the lvalue.\nstatic bool isOnePastTheEndOfCompleteObject(const ASTContext &Ctx,\n                                            const LValue &LV) {\n  // A null pointer can be viewed as being \"past the end\" but we don't\n  // choose to look at it that way here.\n  if (!LV.getLValueBase())\n    return false;\n\n  // If the designator is valid and refers to a subobject, we're not pointing\n  // past the end.\n  if (!LV.getLValueDesignator().Invalid &&\n      !LV.getLValueDesignator().isOnePastTheEnd())\n    return false;\n\n  // A pointer to an incomplete type might be past-the-end if the type's size is\n  // zero.  We cannot tell because the type is incomplete.\n  QualType Ty = getType(LV.getLValueBase());\n  if (Ty->isIncompleteType())\n    return true;\n\n  // We're a past-the-end pointer if we point to the byte after the object,\n  // no matter what our type or path is.\n  auto Size = Ctx.getTypeSizeInChars(Ty);\n  return LV.getLValueOffset() == Size;\n}\n\nnamespace {\n\n/// Data recursive integer evaluator of certain binary operators.\n///\n/// We use a data recursive algorithm for binary operators so that we are able\n/// to handle extreme cases of chained binary operators without causing stack\n/// overflow.\nclass DataRecursiveIntBinOpEvaluator {\n  struct EvalResult {\n    APValue Val;\n    bool Failed;\n\n    EvalResult() : Failed(false) { }\n\n    void swap(EvalResult &RHS) {\n      Val.swap(RHS.Val);\n      Failed = RHS.Failed;\n      RHS.Failed = false;\n    }\n  };\n\n  struct Job {\n    const Expr *E;\n    EvalResult LHSResult; // meaningful only for binary operator expression.\n    enum { AnyExprKind, BinOpKind, BinOpVisitedLHSKind } Kind;\n\n    Job() = default;\n    Job(Job &&) = default;\n\n    void startSpeculativeEval(EvalInfo &Info) {\n      SpecEvalRAII = SpeculativeEvaluationRAII(Info);\n    }\n\n  private:\n    SpeculativeEvaluationRAII SpecEvalRAII;\n  };\n\n  SmallVector<Job, 16> Queue;\n\n  IntExprEvaluator &IntEval;\n  EvalInfo &Info;\n  APValue &FinalResult;\n\npublic:\n  DataRecursiveIntBinOpEvaluator(IntExprEvaluator &IntEval, APValue &Result)\n    : IntEval(IntEval), Info(IntEval.getEvalInfo()), FinalResult(Result) { }\n\n  /// True if \\param E is a binary operator that we are going to handle\n  /// data recursively.\n  /// We handle binary operators that are comma, logical, or that have operands\n  /// with integral or enumeration type.\n  static bool shouldEnqueue(const BinaryOperator *E) {\n    return E->getOpcode() == BO_Comma || E->isLogicalOp() ||\n           (E->isRValue() && E->getType()->isIntegralOrEnumerationType() &&\n            E->getLHS()->getType()->isIntegralOrEnumerationType() &&\n            E->getRHS()->getType()->isIntegralOrEnumerationType());\n  }\n\n  bool Traverse(const BinaryOperator *E) {\n    enqueue(E);\n    EvalResult PrevResult;\n    while (!Queue.empty())\n      process(PrevResult);\n\n    if (PrevResult.Failed) return false;\n\n    FinalResult.swap(PrevResult.Val);\n    return true;\n  }\n\nprivate:\n  bool Success(uint64_t Value, const Expr *E, APValue &Result) {\n    return IntEval.Success(Value, E, Result);\n  }\n  bool Success(const APSInt &Value, const Expr *E, APValue &Result) {\n    return IntEval.Success(Value, E, Result);\n  }\n  bool Error(const Expr *E) {\n    return IntEval.Error(E);\n  }\n  bool Error(const Expr *E, diag::kind D) {\n    return IntEval.Error(E, D);\n  }\n\n  OptionalDiagnostic CCEDiag(const Expr *E, diag::kind D) {\n    return Info.CCEDiag(E, D);\n  }\n\n  // Returns true if visiting the RHS is necessary, false otherwise.\n  bool VisitBinOpLHSOnly(EvalResult &LHSResult, const BinaryOperator *E,\n                         bool &SuppressRHSDiags);\n\n  bool VisitBinOp(const EvalResult &LHSResult, const EvalResult &RHSResult,\n                  const BinaryOperator *E, APValue &Result);\n\n  void EvaluateExpr(const Expr *E, EvalResult &Result) {\n    Result.Failed = !Evaluate(Result.Val, Info, E);\n    if (Result.Failed)\n      Result.Val = APValue();\n  }\n\n  void process(EvalResult &Result);\n\n  void enqueue(const Expr *E) {\n    E = E->IgnoreParens();\n    Queue.resize(Queue.size()+1);\n    Queue.back().E = E;\n    Queue.back().Kind = Job::AnyExprKind;\n  }\n};\n\n}\n\nbool DataRecursiveIntBinOpEvaluator::\n       VisitBinOpLHSOnly(EvalResult &LHSResult, const BinaryOperator *E,\n                         bool &SuppressRHSDiags) {\n  if (E->getOpcode() == BO_Comma) {\n    // Ignore LHS but note if we could not evaluate it.\n    if (LHSResult.Failed)\n      return Info.noteSideEffect();\n    return true;\n  }\n\n  if (E->isLogicalOp()) {\n    bool LHSAsBool;\n    if (!LHSResult.Failed && HandleConversionToBool(LHSResult.Val, LHSAsBool)) {\n      // We were able to evaluate the LHS, see if we can get away with not\n      // evaluating the RHS: 0 && X -> 0, 1 || X -> 1\n      if (LHSAsBool == (E->getOpcode() == BO_LOr)) {\n        Success(LHSAsBool, E, LHSResult.Val);\n        return false; // Ignore RHS\n      }\n    } else {\n      LHSResult.Failed = true;\n\n      // Since we weren't able to evaluate the left hand side, it\n      // might have had side effects.\n      if (!Info.noteSideEffect())\n        return false;\n\n      // We can't evaluate the LHS; however, sometimes the result\n      // is determined by the RHS: X && 0 -> 0, X || 1 -> 1.\n      // Don't ignore RHS and suppress diagnostics from this arm.\n      SuppressRHSDiags = true;\n    }\n\n    return true;\n  }\n\n  assert(E->getLHS()->getType()->isIntegralOrEnumerationType() &&\n         E->getRHS()->getType()->isIntegralOrEnumerationType());\n\n  if (LHSResult.Failed && !Info.noteFailure())\n    return false; // Ignore RHS;\n\n  return true;\n}\n\nstatic void addOrSubLValueAsInteger(APValue &LVal, const APSInt &Index,\n                                    bool IsSub) {\n  // Compute the new offset in the appropriate width, wrapping at 64 bits.\n  // FIXME: When compiling for a 32-bit target, we should use 32-bit\n  // offsets.\n  assert(!LVal.hasLValuePath() && \"have designator for integer lvalue\");\n  CharUnits &Offset = LVal.getLValueOffset();\n  uint64_t Offset64 = Offset.getQuantity();\n  uint64_t Index64 = Index.extOrTrunc(64).getZExtValue();\n  Offset = CharUnits::fromQuantity(IsSub ? Offset64 - Index64\n                                         : Offset64 + Index64);\n}\n\nbool DataRecursiveIntBinOpEvaluator::\n       VisitBinOp(const EvalResult &LHSResult, const EvalResult &RHSResult,\n                  const BinaryOperator *E, APValue &Result) {\n  if (E->getOpcode() == BO_Comma) {\n    if (RHSResult.Failed)\n      return false;\n    Result = RHSResult.Val;\n    return true;\n  }\n\n  if (E->isLogicalOp()) {\n    bool lhsResult, rhsResult;\n    bool LHSIsOK = HandleConversionToBool(LHSResult.Val, lhsResult);\n    bool RHSIsOK = HandleConversionToBool(RHSResult.Val, rhsResult);\n\n    if (LHSIsOK) {\n      if (RHSIsOK) {\n        if (E->getOpcode() == BO_LOr)\n          return Success(lhsResult || rhsResult, E, Result);\n        else\n          return Success(lhsResult && rhsResult, E, Result);\n      }\n    } else {\n      if (RHSIsOK) {\n        // We can't evaluate the LHS; however, sometimes the result\n        // is determined by the RHS: X && 0 -> 0, X || 1 -> 1.\n        if (rhsResult == (E->getOpcode() == BO_LOr))\n          return Success(rhsResult, E, Result);\n      }\n    }\n\n    return false;\n  }\n\n  assert(E->getLHS()->getType()->isIntegralOrEnumerationType() &&\n         E->getRHS()->getType()->isIntegralOrEnumerationType());\n\n  if (LHSResult.Failed || RHSResult.Failed)\n    return false;\n\n  const APValue &LHSVal = LHSResult.Val;\n  const APValue &RHSVal = RHSResult.Val;\n\n  // Handle cases like (unsigned long)&a + 4.\n  if (E->isAdditiveOp() && LHSVal.isLValue() && RHSVal.isInt()) {\n    Result = LHSVal;\n    addOrSubLValueAsInteger(Result, RHSVal.getInt(), E->getOpcode() == BO_Sub);\n    return true;\n  }\n\n  // Handle cases like 4 + (unsigned long)&a\n  if (E->getOpcode() == BO_Add &&\n      RHSVal.isLValue() && LHSVal.isInt()) {\n    Result = RHSVal;\n    addOrSubLValueAsInteger(Result, LHSVal.getInt(), /*IsSub*/false);\n    return true;\n  }\n\n  if (E->getOpcode() == BO_Sub && LHSVal.isLValue() && RHSVal.isLValue()) {\n    // Handle (intptr_t)&&A - (intptr_t)&&B.\n    if (!LHSVal.getLValueOffset().isZero() ||\n        !RHSVal.getLValueOffset().isZero())\n      return false;\n    const Expr *LHSExpr = LHSVal.getLValueBase().dyn_cast<const Expr*>();\n    const Expr *RHSExpr = RHSVal.getLValueBase().dyn_cast<const Expr*>();\n    if (!LHSExpr || !RHSExpr)\n      return false;\n    const AddrLabelExpr *LHSAddrExpr = dyn_cast<AddrLabelExpr>(LHSExpr);\n    const AddrLabelExpr *RHSAddrExpr = dyn_cast<AddrLabelExpr>(RHSExpr);\n    if (!LHSAddrExpr || !RHSAddrExpr)\n      return false;\n    // Make sure both labels come from the same function.\n    if (LHSAddrExpr->getLabel()->getDeclContext() !=\n        RHSAddrExpr->getLabel()->getDeclContext())\n      return false;\n    Result = APValue(LHSAddrExpr, RHSAddrExpr);\n    return true;\n  }\n\n  // All the remaining cases expect both operands to be an integer\n  if (!LHSVal.isInt() || !RHSVal.isInt())\n    return Error(E);\n\n  // Set up the width and signedness manually, in case it can't be deduced\n  // from the operation we're performing.\n  // FIXME: Don't do this in the cases where we can deduce it.\n  APSInt Value(Info.Ctx.getIntWidth(E->getType()),\n               E->getType()->isUnsignedIntegerOrEnumerationType());\n  if (!handleIntIntBinOp(Info, E, LHSVal.getInt(), E->getOpcode(),\n                         RHSVal.getInt(), Value))\n    return false;\n  return Success(Value, E, Result);\n}\n\nvoid DataRecursiveIntBinOpEvaluator::process(EvalResult &Result) {\n  Job &job = Queue.back();\n\n  switch (job.Kind) {\n    case Job::AnyExprKind: {\n      if (const BinaryOperator *Bop = dyn_cast<BinaryOperator>(job.E)) {\n        if (shouldEnqueue(Bop)) {\n          job.Kind = Job::BinOpKind;\n          enqueue(Bop->getLHS());\n          return;\n        }\n      }\n\n      EvaluateExpr(job.E, Result);\n      Queue.pop_back();\n      return;\n    }\n\n    case Job::BinOpKind: {\n      const BinaryOperator *Bop = cast<BinaryOperator>(job.E);\n      bool SuppressRHSDiags = false;\n      if (!VisitBinOpLHSOnly(Result, Bop, SuppressRHSDiags)) {\n        Queue.pop_back();\n        return;\n      }\n      if (SuppressRHSDiags)\n        job.startSpeculativeEval(Info);\n      job.LHSResult.swap(Result);\n      job.Kind = Job::BinOpVisitedLHSKind;\n      enqueue(Bop->getRHS());\n      return;\n    }\n\n    case Job::BinOpVisitedLHSKind: {\n      const BinaryOperator *Bop = cast<BinaryOperator>(job.E);\n      EvalResult RHS;\n      RHS.swap(Result);\n      Result.Failed = !VisitBinOp(job.LHSResult, RHS, Bop, Result.Val);\n      Queue.pop_back();\n      return;\n    }\n  }\n\n  llvm_unreachable(\"Invalid Job::Kind!\");\n}\n\nnamespace {\nenum class CmpResult {\n  Unequal,\n  Less,\n  Equal,\n  Greater,\n  Unordered,\n};\n}\n\ntemplate <class SuccessCB, class AfterCB>\nstatic bool\nEvaluateComparisonBinaryOperator(EvalInfo &Info, const BinaryOperator *E,\n                                 SuccessCB &&Success, AfterCB &&DoAfter) {\n  assert(!E->isValueDependent());\n  assert(E->isComparisonOp() && \"expected comparison operator\");\n  assert((E->getOpcode() == BO_Cmp ||\n          E->getType()->isIntegralOrEnumerationType()) &&\n         \"unsupported binary expression evaluation\");\n  auto Error = [&](const Expr *E) {\n    Info.FFDiag(E, diag::note_invalid_subexpr_in_const_expr);\n    return false;\n  };\n\n  bool IsRelational = E->isRelationalOp() || E->getOpcode() == BO_Cmp;\n  bool IsEquality = E->isEqualityOp();\n\n  QualType LHSTy = E->getLHS()->getType();\n  QualType RHSTy = E->getRHS()->getType();\n\n  if (LHSTy->isIntegralOrEnumerationType() &&\n      RHSTy->isIntegralOrEnumerationType()) {\n    APSInt LHS, RHS;\n    bool LHSOK = EvaluateInteger(E->getLHS(), LHS, Info);\n    if (!LHSOK && !Info.noteFailure())\n      return false;\n    if (!EvaluateInteger(E->getRHS(), RHS, Info) || !LHSOK)\n      return false;\n    if (LHS < RHS)\n      return Success(CmpResult::Less, E);\n    if (LHS > RHS)\n      return Success(CmpResult::Greater, E);\n    return Success(CmpResult::Equal, E);\n  }\n\n  if (LHSTy->isFixedPointType() || RHSTy->isFixedPointType()) {\n    APFixedPoint LHSFX(Info.Ctx.getFixedPointSemantics(LHSTy));\n    APFixedPoint RHSFX(Info.Ctx.getFixedPointSemantics(RHSTy));\n\n    bool LHSOK = EvaluateFixedPointOrInteger(E->getLHS(), LHSFX, Info);\n    if (!LHSOK && !Info.noteFailure())\n      return false;\n    if (!EvaluateFixedPointOrInteger(E->getRHS(), RHSFX, Info) || !LHSOK)\n      return false;\n    if (LHSFX < RHSFX)\n      return Success(CmpResult::Less, E);\n    if (LHSFX > RHSFX)\n      return Success(CmpResult::Greater, E);\n    return Success(CmpResult::Equal, E);\n  }\n\n  if (LHSTy->isAnyComplexType() || RHSTy->isAnyComplexType()) {\n    ComplexValue LHS, RHS;\n    bool LHSOK;\n    if (E->isAssignmentOp()) {\n      LValue LV;\n      EvaluateLValue(E->getLHS(), LV, Info);\n      LHSOK = false;\n    } else if (LHSTy->isRealFloatingType()) {\n      LHSOK = EvaluateFloat(E->getLHS(), LHS.FloatReal, Info);\n      if (LHSOK) {\n        LHS.makeComplexFloat();\n        LHS.FloatImag = APFloat(LHS.FloatReal.getSemantics());\n      }\n    } else {\n      LHSOK = EvaluateComplex(E->getLHS(), LHS, Info);\n    }\n    if (!LHSOK && !Info.noteFailure())\n      return false;\n\n    if (E->getRHS()->getType()->isRealFloatingType()) {\n      if (!EvaluateFloat(E->getRHS(), RHS.FloatReal, Info) || !LHSOK)\n        return false;\n      RHS.makeComplexFloat();\n      RHS.FloatImag = APFloat(RHS.FloatReal.getSemantics());\n    } else if (!EvaluateComplex(E->getRHS(), RHS, Info) || !LHSOK)\n      return false;\n\n    if (LHS.isComplexFloat()) {\n      APFloat::cmpResult CR_r =\n        LHS.getComplexFloatReal().compare(RHS.getComplexFloatReal());\n      APFloat::cmpResult CR_i =\n        LHS.getComplexFloatImag().compare(RHS.getComplexFloatImag());\n      bool IsEqual = CR_r == APFloat::cmpEqual && CR_i == APFloat::cmpEqual;\n      return Success(IsEqual ? CmpResult::Equal : CmpResult::Unequal, E);\n    } else {\n      assert(IsEquality && \"invalid complex comparison\");\n      bool IsEqual = LHS.getComplexIntReal() == RHS.getComplexIntReal() &&\n                     LHS.getComplexIntImag() == RHS.getComplexIntImag();\n      return Success(IsEqual ? CmpResult::Equal : CmpResult::Unequal, E);\n    }\n  }\n\n  if (LHSTy->isRealFloatingType() &&\n      RHSTy->isRealFloatingType()) {\n    APFloat RHS(0.0), LHS(0.0);\n\n    bool LHSOK = EvaluateFloat(E->getRHS(), RHS, Info);\n    if (!LHSOK && !Info.noteFailure())\n      return false;\n\n    if (!EvaluateFloat(E->getLHS(), LHS, Info) || !LHSOK)\n      return false;\n\n    assert(E->isComparisonOp() && \"Invalid binary operator!\");\n    llvm::APFloatBase::cmpResult APFloatCmpResult = LHS.compare(RHS);\n    if (!Info.InConstantContext &&\n        APFloatCmpResult == APFloat::cmpUnordered &&\n        E->getFPFeaturesInEffect(Info.Ctx.getLangOpts()).isFPConstrained()) {\n      // Note: Compares may raise invalid in some cases involving NaN or sNaN.\n      Info.FFDiag(E, diag::note_constexpr_float_arithmetic_strict);\n      return false;\n    }\n    auto GetCmpRes = [&]() {\n      switch (APFloatCmpResult) {\n      case APFloat::cmpEqual:\n        return CmpResult::Equal;\n      case APFloat::cmpLessThan:\n        return CmpResult::Less;\n      case APFloat::cmpGreaterThan:\n        return CmpResult::Greater;\n      case APFloat::cmpUnordered:\n        return CmpResult::Unordered;\n      }\n      llvm_unreachable(\"Unrecognised APFloat::cmpResult enum\");\n    };\n    return Success(GetCmpRes(), E);\n  }\n\n  if (LHSTy->isPointerType() && RHSTy->isPointerType()) {\n    LValue LHSValue, RHSValue;\n\n    bool LHSOK = EvaluatePointer(E->getLHS(), LHSValue, Info);\n    if (!LHSOK && !Info.noteFailure())\n      return false;\n\n    if (!EvaluatePointer(E->getRHS(), RHSValue, Info) || !LHSOK)\n      return false;\n\n    // Reject differing bases from the normal codepath; we special-case\n    // comparisons to null.\n    if (!HasSameBase(LHSValue, RHSValue)) {\n      // Inequalities and subtractions between unrelated pointers have\n      // unspecified or undefined behavior.\n      if (!IsEquality) {\n        Info.FFDiag(E, diag::note_constexpr_pointer_comparison_unspecified);\n        return false;\n      }\n      // A constant address may compare equal to the address of a symbol.\n      // The one exception is that address of an object cannot compare equal\n      // to a null pointer constant.\n      if ((!LHSValue.Base && !LHSValue.Offset.isZero()) ||\n          (!RHSValue.Base && !RHSValue.Offset.isZero()))\n        return Error(E);\n      // It's implementation-defined whether distinct literals will have\n      // distinct addresses. In clang, the result of such a comparison is\n      // unspecified, so it is not a constant expression. However, we do know\n      // that the address of a literal will be non-null.\n      if ((IsLiteralLValue(LHSValue) || IsLiteralLValue(RHSValue)) &&\n          LHSValue.Base && RHSValue.Base)\n        return Error(E);\n      // We can't tell whether weak symbols will end up pointing to the same\n      // object.\n      if (IsWeakLValue(LHSValue) || IsWeakLValue(RHSValue))\n        return Error(E);\n      // We can't compare the address of the start of one object with the\n      // past-the-end address of another object, per C++ DR1652.\n      if ((LHSValue.Base && LHSValue.Offset.isZero() &&\n           isOnePastTheEndOfCompleteObject(Info.Ctx, RHSValue)) ||\n          (RHSValue.Base && RHSValue.Offset.isZero() &&\n           isOnePastTheEndOfCompleteObject(Info.Ctx, LHSValue)))\n        return Error(E);\n      // We can't tell whether an object is at the same address as another\n      // zero sized object.\n      if ((RHSValue.Base && isZeroSized(LHSValue)) ||\n          (LHSValue.Base && isZeroSized(RHSValue)))\n        return Error(E);\n      return Success(CmpResult::Unequal, E);\n    }\n\n    const CharUnits &LHSOffset = LHSValue.getLValueOffset();\n    const CharUnits &RHSOffset = RHSValue.getLValueOffset();\n\n    SubobjectDesignator &LHSDesignator = LHSValue.getLValueDesignator();\n    SubobjectDesignator &RHSDesignator = RHSValue.getLValueDesignator();\n\n    // C++11 [expr.rel]p3:\n    //   Pointers to void (after pointer conversions) can be compared, with a\n    //   result defined as follows: If both pointers represent the same\n    //   address or are both the null pointer value, the result is true if the\n    //   operator is <= or >= and false otherwise; otherwise the result is\n    //   unspecified.\n    // We interpret this as applying to pointers to *cv* void.\n    if (LHSTy->isVoidPointerType() && LHSOffset != RHSOffset && IsRelational)\n      Info.CCEDiag(E, diag::note_constexpr_void_comparison);\n\n    // C++11 [expr.rel]p2:\n    // - If two pointers point to non-static data members of the same object,\n    //   or to subobjects or array elements fo such members, recursively, the\n    //   pointer to the later declared member compares greater provided the\n    //   two members have the same access control and provided their class is\n    //   not a union.\n    //   [...]\n    // - Otherwise pointer comparisons are unspecified.\n    if (!LHSDesignator.Invalid && !RHSDesignator.Invalid && IsRelational) {\n      bool WasArrayIndex;\n      unsigned Mismatch = FindDesignatorMismatch(\n          getType(LHSValue.Base), LHSDesignator, RHSDesignator, WasArrayIndex);\n      // At the point where the designators diverge, the comparison has a\n      // specified value if:\n      //  - we are comparing array indices\n      //  - we are comparing fields of a union, or fields with the same access\n      // Otherwise, the result is unspecified and thus the comparison is not a\n      // constant expression.\n      if (!WasArrayIndex && Mismatch < LHSDesignator.Entries.size() &&\n          Mismatch < RHSDesignator.Entries.size()) {\n        const FieldDecl *LF = getAsField(LHSDesignator.Entries[Mismatch]);\n        const FieldDecl *RF = getAsField(RHSDesignator.Entries[Mismatch]);\n        if (!LF && !RF)\n          Info.CCEDiag(E, diag::note_constexpr_pointer_comparison_base_classes);\n        else if (!LF)\n          Info.CCEDiag(E, diag::note_constexpr_pointer_comparison_base_field)\n              << getAsBaseClass(LHSDesignator.Entries[Mismatch])\n              << RF->getParent() << RF;\n        else if (!RF)\n          Info.CCEDiag(E, diag::note_constexpr_pointer_comparison_base_field)\n              << getAsBaseClass(RHSDesignator.Entries[Mismatch])\n              << LF->getParent() << LF;\n        else if (!LF->getParent()->isUnion() &&\n                 LF->getAccess() != RF->getAccess())\n          Info.CCEDiag(E,\n                       diag::note_constexpr_pointer_comparison_differing_access)\n              << LF << LF->getAccess() << RF << RF->getAccess()\n              << LF->getParent();\n      }\n    }\n\n    // The comparison here must be unsigned, and performed with the same\n    // width as the pointer.\n    unsigned PtrSize = Info.Ctx.getTypeSize(LHSTy);\n    uint64_t CompareLHS = LHSOffset.getQuantity();\n    uint64_t CompareRHS = RHSOffset.getQuantity();\n    assert(PtrSize <= 64 && \"Unexpected pointer width\");\n    uint64_t Mask = ~0ULL >> (64 - PtrSize);\n    CompareLHS &= Mask;\n    CompareRHS &= Mask;\n\n    // If there is a base and this is a relational operator, we can only\n    // compare pointers within the object in question; otherwise, the result\n    // depends on where the object is located in memory.\n    if (!LHSValue.Base.isNull() && IsRelational) {\n      QualType BaseTy = getType(LHSValue.Base);\n      if (BaseTy->isIncompleteType())\n        return Error(E);\n      CharUnits Size = Info.Ctx.getTypeSizeInChars(BaseTy);\n      uint64_t OffsetLimit = Size.getQuantity();\n      if (CompareLHS > OffsetLimit || CompareRHS > OffsetLimit)\n        return Error(E);\n    }\n\n    if (CompareLHS < CompareRHS)\n      return Success(CmpResult::Less, E);\n    if (CompareLHS > CompareRHS)\n      return Success(CmpResult::Greater, E);\n    return Success(CmpResult::Equal, E);\n  }\n\n  if (LHSTy->isMemberPointerType()) {\n    assert(IsEquality && \"unexpected member pointer operation\");\n    assert(RHSTy->isMemberPointerType() && \"invalid comparison\");\n\n    MemberPtr LHSValue, RHSValue;\n\n    bool LHSOK = EvaluateMemberPointer(E->getLHS(), LHSValue, Info);\n    if (!LHSOK && !Info.noteFailure())\n      return false;\n\n    if (!EvaluateMemberPointer(E->getRHS(), RHSValue, Info) || !LHSOK)\n      return false;\n\n    // C++11 [expr.eq]p2:\n    //   If both operands are null, they compare equal. Otherwise if only one is\n    //   null, they compare unequal.\n    if (!LHSValue.getDecl() || !RHSValue.getDecl()) {\n      bool Equal = !LHSValue.getDecl() && !RHSValue.getDecl();\n      return Success(Equal ? CmpResult::Equal : CmpResult::Unequal, E);\n    }\n\n    //   Otherwise if either is a pointer to a virtual member function, the\n    //   result is unspecified.\n    if (const CXXMethodDecl *MD = dyn_cast<CXXMethodDecl>(LHSValue.getDecl()))\n      if (MD->isVirtual())\n        Info.CCEDiag(E, diag::note_constexpr_compare_virtual_mem_ptr) << MD;\n    if (const CXXMethodDecl *MD = dyn_cast<CXXMethodDecl>(RHSValue.getDecl()))\n      if (MD->isVirtual())\n        Info.CCEDiag(E, diag::note_constexpr_compare_virtual_mem_ptr) << MD;\n\n    //   Otherwise they compare equal if and only if they would refer to the\n    //   same member of the same most derived object or the same subobject if\n    //   they were dereferenced with a hypothetical object of the associated\n    //   class type.\n    bool Equal = LHSValue == RHSValue;\n    return Success(Equal ? CmpResult::Equal : CmpResult::Unequal, E);\n  }\n\n  if (LHSTy->isNullPtrType()) {\n    assert(E->isComparisonOp() && \"unexpected nullptr operation\");\n    assert(RHSTy->isNullPtrType() && \"missing pointer conversion\");\n    // C++11 [expr.rel]p4, [expr.eq]p3: If two operands of type std::nullptr_t\n    // are compared, the result is true of the operator is <=, >= or ==, and\n    // false otherwise.\n    return Success(CmpResult::Equal, E);\n  }\n\n  return DoAfter();\n}\n\nbool RecordExprEvaluator::VisitBinCmp(const BinaryOperator *E) {\n  if (!CheckLiteralType(Info, E))\n    return false;\n\n  auto OnSuccess = [&](CmpResult CR, const BinaryOperator *E) {\n    ComparisonCategoryResult CCR;\n    switch (CR) {\n    case CmpResult::Unequal:\n      llvm_unreachable(\"should never produce Unequal for three-way comparison\");\n    case CmpResult::Less:\n      CCR = ComparisonCategoryResult::Less;\n      break;\n    case CmpResult::Equal:\n      CCR = ComparisonCategoryResult::Equal;\n      break;\n    case CmpResult::Greater:\n      CCR = ComparisonCategoryResult::Greater;\n      break;\n    case CmpResult::Unordered:\n      CCR = ComparisonCategoryResult::Unordered;\n      break;\n    }\n    // Evaluation succeeded. Lookup the information for the comparison category\n    // type and fetch the VarDecl for the result.\n    const ComparisonCategoryInfo &CmpInfo =\n        Info.Ctx.CompCategories.getInfoForType(E->getType());\n    const VarDecl *VD = CmpInfo.getValueInfo(CmpInfo.makeWeakResult(CCR))->VD;\n    // Check and evaluate the result as a constant expression.\n    LValue LV;\n    LV.set(VD);\n    if (!handleLValueToRValueConversion(Info, E, E->getType(), LV, Result))\n      return false;\n    return CheckConstantExpression(Info, E->getExprLoc(), E->getType(), Result,\n                                   ConstantExprKind::Normal);\n  };\n  return EvaluateComparisonBinaryOperator(Info, E, OnSuccess, [&]() {\n    return ExprEvaluatorBaseTy::VisitBinCmp(E);\n  });\n}\n\nbool IntExprEvaluator::VisitBinaryOperator(const BinaryOperator *E) {\n  // We don't support assignment in C. C++ assignments don't get here because\n  // assignment is an lvalue in C++.\n  if (E->isAssignmentOp()) {\n    Error(E);\n    if (!Info.noteFailure())\n      return false;\n  }\n\n  if (DataRecursiveIntBinOpEvaluator::shouldEnqueue(E))\n    return DataRecursiveIntBinOpEvaluator(*this, Result).Traverse(E);\n\n  assert((!E->getLHS()->getType()->isIntegralOrEnumerationType() ||\n          !E->getRHS()->getType()->isIntegralOrEnumerationType()) &&\n         \"DataRecursiveIntBinOpEvaluator should have handled integral types\");\n\n  if (E->isComparisonOp()) {\n    // Evaluate builtin binary comparisons by evaluating them as three-way\n    // comparisons and then translating the result.\n    auto OnSuccess = [&](CmpResult CR, const BinaryOperator *E) {\n      assert((CR != CmpResult::Unequal || E->isEqualityOp()) &&\n             \"should only produce Unequal for equality comparisons\");\n      bool IsEqual   = CR == CmpResult::Equal,\n           IsLess    = CR == CmpResult::Less,\n           IsGreater = CR == CmpResult::Greater;\n      auto Op = E->getOpcode();\n      switch (Op) {\n      default:\n        llvm_unreachable(\"unsupported binary operator\");\n      case BO_EQ:\n      case BO_NE:\n        return Success(IsEqual == (Op == BO_EQ), E);\n      case BO_LT:\n        return Success(IsLess, E);\n      case BO_GT:\n        return Success(IsGreater, E);\n      case BO_LE:\n        return Success(IsEqual || IsLess, E);\n      case BO_GE:\n        return Success(IsEqual || IsGreater, E);\n      }\n    };\n    return EvaluateComparisonBinaryOperator(Info, E, OnSuccess, [&]() {\n      return ExprEvaluatorBaseTy::VisitBinaryOperator(E);\n    });\n  }\n\n  QualType LHSTy = E->getLHS()->getType();\n  QualType RHSTy = E->getRHS()->getType();\n\n  if (LHSTy->isPointerType() && RHSTy->isPointerType() &&\n      E->getOpcode() == BO_Sub) {\n    LValue LHSValue, RHSValue;\n\n    bool LHSOK = EvaluatePointer(E->getLHS(), LHSValue, Info);\n    if (!LHSOK && !Info.noteFailure())\n      return false;\n\n    if (!EvaluatePointer(E->getRHS(), RHSValue, Info) || !LHSOK)\n      return false;\n\n    // Reject differing bases from the normal codepath; we special-case\n    // comparisons to null.\n    if (!HasSameBase(LHSValue, RHSValue)) {\n      // Handle &&A - &&B.\n      if (!LHSValue.Offset.isZero() || !RHSValue.Offset.isZero())\n        return Error(E);\n      const Expr *LHSExpr = LHSValue.Base.dyn_cast<const Expr *>();\n      const Expr *RHSExpr = RHSValue.Base.dyn_cast<const Expr *>();\n      if (!LHSExpr || !RHSExpr)\n        return Error(E);\n      const AddrLabelExpr *LHSAddrExpr = dyn_cast<AddrLabelExpr>(LHSExpr);\n      const AddrLabelExpr *RHSAddrExpr = dyn_cast<AddrLabelExpr>(RHSExpr);\n      if (!LHSAddrExpr || !RHSAddrExpr)\n        return Error(E);\n      // Make sure both labels come from the same function.\n      if (LHSAddrExpr->getLabel()->getDeclContext() !=\n          RHSAddrExpr->getLabel()->getDeclContext())\n        return Error(E);\n      return Success(APValue(LHSAddrExpr, RHSAddrExpr), E);\n    }\n    const CharUnits &LHSOffset = LHSValue.getLValueOffset();\n    const CharUnits &RHSOffset = RHSValue.getLValueOffset();\n\n    SubobjectDesignator &LHSDesignator = LHSValue.getLValueDesignator();\n    SubobjectDesignator &RHSDesignator = RHSValue.getLValueDesignator();\n\n    // C++11 [expr.add]p6:\n    //   Unless both pointers point to elements of the same array object, or\n    //   one past the last element of the array object, the behavior is\n    //   undefined.\n    if (!LHSDesignator.Invalid && !RHSDesignator.Invalid &&\n        !AreElementsOfSameArray(getType(LHSValue.Base), LHSDesignator,\n                                RHSDesignator))\n      Info.CCEDiag(E, diag::note_constexpr_pointer_subtraction_not_same_array);\n\n    QualType Type = E->getLHS()->getType();\n    QualType ElementType = Type->castAs<PointerType>()->getPointeeType();\n\n    CharUnits ElementSize;\n    if (!HandleSizeof(Info, E->getExprLoc(), ElementType, ElementSize))\n      return false;\n\n    // As an extension, a type may have zero size (empty struct or union in\n    // C, array of zero length). Pointer subtraction in such cases has\n    // undefined behavior, so is not constant.\n    if (ElementSize.isZero()) {\n      Info.FFDiag(E, diag::note_constexpr_pointer_subtraction_zero_size)\n          << ElementType;\n      return false;\n    }\n\n    // FIXME: LLVM and GCC both compute LHSOffset - RHSOffset at runtime,\n    // and produce incorrect results when it overflows. Such behavior\n    // appears to be non-conforming, but is common, so perhaps we should\n    // assume the standard intended for such cases to be undefined behavior\n    // and check for them.\n\n    // Compute (LHSOffset - RHSOffset) / Size carefully, checking for\n    // overflow in the final conversion to ptrdiff_t.\n    APSInt LHS(llvm::APInt(65, (int64_t)LHSOffset.getQuantity(), true), false);\n    APSInt RHS(llvm::APInt(65, (int64_t)RHSOffset.getQuantity(), true), false);\n    APSInt ElemSize(llvm::APInt(65, (int64_t)ElementSize.getQuantity(), true),\n                    false);\n    APSInt TrueResult = (LHS - RHS) / ElemSize;\n    APSInt Result = TrueResult.trunc(Info.Ctx.getIntWidth(E->getType()));\n\n    if (Result.extend(65) != TrueResult &&\n        !HandleOverflow(Info, E, TrueResult, E->getType()))\n      return false;\n    return Success(Result, E);\n  }\n\n  return ExprEvaluatorBaseTy::VisitBinaryOperator(E);\n}\n\n/// VisitUnaryExprOrTypeTraitExpr - Evaluate a sizeof, alignof or vec_step with\n/// a result as the expression's type.\nbool IntExprEvaluator::VisitUnaryExprOrTypeTraitExpr(\n                                    const UnaryExprOrTypeTraitExpr *E) {\n  switch(E->getKind()) {\n  case UETT_PreferredAlignOf:\n  case UETT_AlignOf: {\n    if (E->isArgumentType())\n      return Success(GetAlignOfType(Info, E->getArgumentType(), E->getKind()),\n                     E);\n    else\n      return Success(GetAlignOfExpr(Info, E->getArgumentExpr(), E->getKind()),\n                     E);\n  }\n\n  case UETT_VecStep: {\n    QualType Ty = E->getTypeOfArgument();\n\n    if (Ty->isVectorType()) {\n      unsigned n = Ty->castAs<VectorType>()->getNumElements();\n\n      // The vec_step built-in functions that take a 3-component\n      // vector return 4. (OpenCL 1.1 spec 6.11.12)\n      if (n == 3)\n        n = 4;\n\n      return Success(n, E);\n    } else\n      return Success(1, E);\n  }\n\n  case UETT_SizeOf: {\n    QualType SrcTy = E->getTypeOfArgument();\n    // C++ [expr.sizeof]p2: \"When applied to a reference or a reference type,\n    //   the result is the size of the referenced type.\"\n    if (const ReferenceType *Ref = SrcTy->getAs<ReferenceType>())\n      SrcTy = Ref->getPointeeType();\n\n    CharUnits Sizeof;\n    if (!HandleSizeof(Info, E->getExprLoc(), SrcTy, Sizeof))\n      return false;\n    return Success(Sizeof, E);\n  }\n  case UETT_OpenMPRequiredSimdAlign:\n    assert(E->isArgumentType());\n    return Success(\n        Info.Ctx.toCharUnitsFromBits(\n                    Info.Ctx.getOpenMPDefaultSimdAlign(E->getArgumentType()))\n            .getQuantity(),\n        E);\n  }\n\n  llvm_unreachable(\"unknown expr/type trait\");\n}\n\nbool IntExprEvaluator::VisitOffsetOfExpr(const OffsetOfExpr *OOE) {\n  CharUnits Result;\n  unsigned n = OOE->getNumComponents();\n  if (n == 0)\n    return Error(OOE);\n  QualType CurrentType = OOE->getTypeSourceInfo()->getType();\n  for (unsigned i = 0; i != n; ++i) {\n    OffsetOfNode ON = OOE->getComponent(i);\n    switch (ON.getKind()) {\n    case OffsetOfNode::Array: {\n      const Expr *Idx = OOE->getIndexExpr(ON.getArrayExprIndex());\n      APSInt IdxResult;\n      if (!EvaluateInteger(Idx, IdxResult, Info))\n        return false;\n      const ArrayType *AT = Info.Ctx.getAsArrayType(CurrentType);\n      if (!AT)\n        return Error(OOE);\n      CurrentType = AT->getElementType();\n      CharUnits ElementSize = Info.Ctx.getTypeSizeInChars(CurrentType);\n      Result += IdxResult.getSExtValue() * ElementSize;\n      break;\n    }\n\n    case OffsetOfNode::Field: {\n      FieldDecl *MemberDecl = ON.getField();\n      const RecordType *RT = CurrentType->getAs<RecordType>();\n      if (!RT)\n        return Error(OOE);\n      RecordDecl *RD = RT->getDecl();\n      if (RD->isInvalidDecl()) return false;\n      const ASTRecordLayout &RL = Info.Ctx.getASTRecordLayout(RD);\n      unsigned i = MemberDecl->getFieldIndex();\n      assert(i < RL.getFieldCount() && \"offsetof field in wrong type\");\n      Result += Info.Ctx.toCharUnitsFromBits(RL.getFieldOffset(i));\n      CurrentType = MemberDecl->getType().getNonReferenceType();\n      break;\n    }\n\n    case OffsetOfNode::Identifier:\n      llvm_unreachable(\"dependent __builtin_offsetof\");\n\n    case OffsetOfNode::Base: {\n      CXXBaseSpecifier *BaseSpec = ON.getBase();\n      if (BaseSpec->isVirtual())\n        return Error(OOE);\n\n      // Find the layout of the class whose base we are looking into.\n      const RecordType *RT = CurrentType->getAs<RecordType>();\n      if (!RT)\n        return Error(OOE);\n      RecordDecl *RD = RT->getDecl();\n      if (RD->isInvalidDecl()) return false;\n      const ASTRecordLayout &RL = Info.Ctx.getASTRecordLayout(RD);\n\n      // Find the base class itself.\n      CurrentType = BaseSpec->getType();\n      const RecordType *BaseRT = CurrentType->getAs<RecordType>();\n      if (!BaseRT)\n        return Error(OOE);\n\n      // Add the offset to the base.\n      Result += RL.getBaseClassOffset(cast<CXXRecordDecl>(BaseRT->getDecl()));\n      break;\n    }\n    }\n  }\n  return Success(Result, OOE);\n}\n\nbool IntExprEvaluator::VisitUnaryOperator(const UnaryOperator *E) {\n  switch (E->getOpcode()) {\n  default:\n    // Address, indirect, pre/post inc/dec, etc are not valid constant exprs.\n    // See C99 6.6p3.\n    return Error(E);\n  case UO_Extension:\n    // FIXME: Should extension allow i-c-e extension expressions in its scope?\n    // If so, we could clear the diagnostic ID.\n    return Visit(E->getSubExpr());\n  case UO_Plus:\n    // The result is just the value.\n    return Visit(E->getSubExpr());\n  case UO_Minus: {\n    if (!Visit(E->getSubExpr()))\n      return false;\n    if (!Result.isInt()) return Error(E);\n    const APSInt &Value = Result.getInt();\n    if (Value.isSigned() && Value.isMinSignedValue() && E->canOverflow() &&\n        !HandleOverflow(Info, E, -Value.extend(Value.getBitWidth() + 1),\n                        E->getType()))\n      return false;\n    return Success(-Value, E);\n  }\n  case UO_Not: {\n    if (!Visit(E->getSubExpr()))\n      return false;\n    if (!Result.isInt()) return Error(E);\n    return Success(~Result.getInt(), E);\n  }\n  case UO_LNot: {\n    bool bres;\n    if (!EvaluateAsBooleanCondition(E->getSubExpr(), bres, Info))\n      return false;\n    return Success(!bres, E);\n  }\n  }\n}\n\n/// HandleCast - This is used to evaluate implicit or explicit casts where the\n/// result type is integer.\nbool IntExprEvaluator::VisitCastExpr(const CastExpr *E) {\n  const Expr *SubExpr = E->getSubExpr();\n  QualType DestType = E->getType();\n  QualType SrcType = SubExpr->getType();\n\n  switch (E->getCastKind()) {\n  case CK_BaseToDerived:\n  case CK_DerivedToBase:\n  case CK_UncheckedDerivedToBase:\n  case CK_Dynamic:\n  case CK_ToUnion:\n  case CK_ArrayToPointerDecay:\n  case CK_FunctionToPointerDecay:\n  case CK_NullToPointer:\n  case CK_NullToMemberPointer:\n  case CK_BaseToDerivedMemberPointer:\n  case CK_DerivedToBaseMemberPointer:\n  case CK_ReinterpretMemberPointer:\n  case CK_ConstructorConversion:\n  case CK_IntegralToPointer:\n  case CK_ToVoid:\n  case CK_VectorSplat:\n  case CK_IntegralToFloating:\n  case CK_FloatingCast:\n  case CK_CPointerToObjCPointerCast:\n  case CK_BlockPointerToObjCPointerCast:\n  case CK_AnyPointerToBlockPointerCast:\n  case CK_ObjCObjectLValueCast:\n  case CK_FloatingRealToComplex:\n  case CK_FloatingComplexToReal:\n  case CK_FloatingComplexCast:\n  case CK_FloatingComplexToIntegralComplex:\n  case CK_IntegralRealToComplex:\n  case CK_IntegralComplexCast:\n  case CK_IntegralComplexToFloatingComplex:\n  case CK_BuiltinFnToFnPtr:\n  case CK_ZeroToOCLOpaqueType:\n  case CK_NonAtomicToAtomic:\n  case CK_AddressSpaceConversion:\n  case CK_IntToOCLSampler:\n  case CK_FloatingToFixedPoint:\n  case CK_FixedPointToFloating:\n  case CK_FixedPointCast:\n  case CK_IntegralToFixedPoint:\n    llvm_unreachable(\"invalid cast kind for integral value\");\n\n  case CK_BitCast:\n  case CK_Dependent:\n  case CK_LValueBitCast:\n  case CK_ARCProduceObject:\n  case CK_ARCConsumeObject:\n  case CK_ARCReclaimReturnedObject:\n  case CK_ARCExtendBlockObject:\n  case CK_CopyAndAutoreleaseBlockObject:\n    return Error(E);\n\n  case CK_UserDefinedConversion:\n  case CK_LValueToRValue:\n  case CK_AtomicToNonAtomic:\n  case CK_NoOp:\n  case CK_LValueToRValueBitCast:\n    return ExprEvaluatorBaseTy::VisitCastExpr(E);\n\n  case CK_MemberPointerToBoolean:\n  case CK_PointerToBoolean:\n  case CK_IntegralToBoolean:\n  case CK_FloatingToBoolean:\n  case CK_BooleanToSignedIntegral:\n  case CK_FloatingComplexToBoolean:\n  case CK_IntegralComplexToBoolean: {\n    bool BoolResult;\n    if (!EvaluateAsBooleanCondition(SubExpr, BoolResult, Info))\n      return false;\n    uint64_t IntResult = BoolResult;\n    if (BoolResult && E->getCastKind() == CK_BooleanToSignedIntegral)\n      IntResult = (uint64_t)-1;\n    return Success(IntResult, E);\n  }\n\n  case CK_FixedPointToIntegral: {\n    APFixedPoint Src(Info.Ctx.getFixedPointSemantics(SrcType));\n    if (!EvaluateFixedPoint(SubExpr, Src, Info))\n      return false;\n    bool Overflowed;\n    llvm::APSInt Result = Src.convertToInt(\n        Info.Ctx.getIntWidth(DestType),\n        DestType->isSignedIntegerOrEnumerationType(), &Overflowed);\n    if (Overflowed && !HandleOverflow(Info, E, Result, DestType))\n      return false;\n    return Success(Result, E);\n  }\n\n  case CK_FixedPointToBoolean: {\n    // Unsigned padding does not affect this.\n    APValue Val;\n    if (!Evaluate(Val, Info, SubExpr))\n      return false;\n    return Success(Val.getFixedPoint().getBoolValue(), E);\n  }\n\n  case CK_IntegralCast: {\n    if (!Visit(SubExpr))\n      return false;\n\n    if (!Result.isInt()) {\n      // Allow casts of address-of-label differences if they are no-ops\n      // or narrowing.  (The narrowing case isn't actually guaranteed to\n      // be constant-evaluatable except in some narrow cases which are hard\n      // to detect here.  We let it through on the assumption the user knows\n      // what they are doing.)\n      if (Result.isAddrLabelDiff())\n        return Info.Ctx.getTypeSize(DestType) <= Info.Ctx.getTypeSize(SrcType);\n      // Only allow casts of lvalues if they are lossless.\n      return Info.Ctx.getTypeSize(DestType) == Info.Ctx.getTypeSize(SrcType);\n    }\n\n    return Success(HandleIntToIntCast(Info, E, DestType, SrcType,\n                                      Result.getInt()), E);\n  }\n\n  case CK_PointerToIntegral: {\n    CCEDiag(E, diag::note_constexpr_invalid_cast) << 2;\n\n    LValue LV;\n    if (!EvaluatePointer(SubExpr, LV, Info))\n      return false;\n\n    if (LV.getLValueBase()) {\n      // Only allow based lvalue casts if they are lossless.\n      // FIXME: Allow a larger integer size than the pointer size, and allow\n      // narrowing back down to pointer width in subsequent integral casts.\n      // FIXME: Check integer type's active bits, not its type size.\n      if (Info.Ctx.getTypeSize(DestType) != Info.Ctx.getTypeSize(SrcType))\n        return Error(E);\n\n      LV.Designator.setInvalid();\n      LV.moveInto(Result);\n      return true;\n    }\n\n    APSInt AsInt;\n    APValue V;\n    LV.moveInto(V);\n    if (!V.toIntegralConstant(AsInt, SrcType, Info.Ctx))\n      llvm_unreachable(\"Can't cast this!\");\n\n    return Success(HandleIntToIntCast(Info, E, DestType, SrcType, AsInt), E);\n  }\n\n  case CK_IntegralComplexToReal: {\n    ComplexValue C;\n    if (!EvaluateComplex(SubExpr, C, Info))\n      return false;\n    return Success(C.getComplexIntReal(), E);\n  }\n\n  case CK_FloatingToIntegral: {\n    APFloat F(0.0);\n    if (!EvaluateFloat(SubExpr, F, Info))\n      return false;\n\n    APSInt Value;\n    if (!HandleFloatToIntCast(Info, E, SrcType, F, DestType, Value))\n      return false;\n    return Success(Value, E);\n  }\n  }\n\n  llvm_unreachable(\"unknown cast resulting in integral value\");\n}\n\nbool IntExprEvaluator::VisitUnaryReal(const UnaryOperator *E) {\n  if (E->getSubExpr()->getType()->isAnyComplexType()) {\n    ComplexValue LV;\n    if (!EvaluateComplex(E->getSubExpr(), LV, Info))\n      return false;\n    if (!LV.isComplexInt())\n      return Error(E);\n    return Success(LV.getComplexIntReal(), E);\n  }\n\n  return Visit(E->getSubExpr());\n}\n\nbool IntExprEvaluator::VisitUnaryImag(const UnaryOperator *E) {\n  if (E->getSubExpr()->getType()->isComplexIntegerType()) {\n    ComplexValue LV;\n    if (!EvaluateComplex(E->getSubExpr(), LV, Info))\n      return false;\n    if (!LV.isComplexInt())\n      return Error(E);\n    return Success(LV.getComplexIntImag(), E);\n  }\n\n  VisitIgnoredValue(E->getSubExpr());\n  return Success(0, E);\n}\n\nbool IntExprEvaluator::VisitSizeOfPackExpr(const SizeOfPackExpr *E) {\n  return Success(E->getPackLength(), E);\n}\n\nbool IntExprEvaluator::VisitCXXNoexceptExpr(const CXXNoexceptExpr *E) {\n  return Success(E->getValue(), E);\n}\n\nbool IntExprEvaluator::VisitConceptSpecializationExpr(\n       const ConceptSpecializationExpr *E) {\n  return Success(E->isSatisfied(), E);\n}\n\nbool IntExprEvaluator::VisitRequiresExpr(const RequiresExpr *E) {\n  return Success(E->isSatisfied(), E);\n}\n\nbool FixedPointExprEvaluator::VisitUnaryOperator(const UnaryOperator *E) {\n  switch (E->getOpcode()) {\n    default:\n      // Invalid unary operators\n      return Error(E);\n    case UO_Plus:\n      // The result is just the value.\n      return Visit(E->getSubExpr());\n    case UO_Minus: {\n      if (!Visit(E->getSubExpr())) return false;\n      if (!Result.isFixedPoint())\n        return Error(E);\n      bool Overflowed;\n      APFixedPoint Negated = Result.getFixedPoint().negate(&Overflowed);\n      if (Overflowed && !HandleOverflow(Info, E, Negated, E->getType()))\n        return false;\n      return Success(Negated, E);\n    }\n    case UO_LNot: {\n      bool bres;\n      if (!EvaluateAsBooleanCondition(E->getSubExpr(), bres, Info))\n        return false;\n      return Success(!bres, E);\n    }\n  }\n}\n\nbool FixedPointExprEvaluator::VisitCastExpr(const CastExpr *E) {\n  const Expr *SubExpr = E->getSubExpr();\n  QualType DestType = E->getType();\n  assert(DestType->isFixedPointType() &&\n         \"Expected destination type to be a fixed point type\");\n  auto DestFXSema = Info.Ctx.getFixedPointSemantics(DestType);\n\n  switch (E->getCastKind()) {\n  case CK_FixedPointCast: {\n    APFixedPoint Src(Info.Ctx.getFixedPointSemantics(SubExpr->getType()));\n    if (!EvaluateFixedPoint(SubExpr, Src, Info))\n      return false;\n    bool Overflowed;\n    APFixedPoint Result = Src.convert(DestFXSema, &Overflowed);\n    if (Overflowed) {\n      if (Info.checkingForUndefinedBehavior())\n        Info.Ctx.getDiagnostics().Report(E->getExprLoc(),\n                                         diag::warn_fixedpoint_constant_overflow)\n          << Result.toString() << E->getType();\n      if (!HandleOverflow(Info, E, Result, E->getType()))\n        return false;\n    }\n    return Success(Result, E);\n  }\n  case CK_IntegralToFixedPoint: {\n    APSInt Src;\n    if (!EvaluateInteger(SubExpr, Src, Info))\n      return false;\n\n    bool Overflowed;\n    APFixedPoint IntResult = APFixedPoint::getFromIntValue(\n        Src, Info.Ctx.getFixedPointSemantics(DestType), &Overflowed);\n\n    if (Overflowed) {\n      if (Info.checkingForUndefinedBehavior())\n        Info.Ctx.getDiagnostics().Report(E->getExprLoc(),\n                                         diag::warn_fixedpoint_constant_overflow)\n          << IntResult.toString() << E->getType();\n      if (!HandleOverflow(Info, E, IntResult, E->getType()))\n        return false;\n    }\n\n    return Success(IntResult, E);\n  }\n  case CK_FloatingToFixedPoint: {\n    APFloat Src(0.0);\n    if (!EvaluateFloat(SubExpr, Src, Info))\n      return false;\n\n    bool Overflowed;\n    APFixedPoint Result = APFixedPoint::getFromFloatValue(\n        Src, Info.Ctx.getFixedPointSemantics(DestType), &Overflowed);\n\n    if (Overflowed) {\n      if (Info.checkingForUndefinedBehavior())\n        Info.Ctx.getDiagnostics().Report(E->getExprLoc(),\n                                         diag::warn_fixedpoint_constant_overflow)\n          << Result.toString() << E->getType();\n      if (!HandleOverflow(Info, E, Result, E->getType()))\n        return false;\n    }\n\n    return Success(Result, E);\n  }\n  case CK_NoOp:\n  case CK_LValueToRValue:\n    return ExprEvaluatorBaseTy::VisitCastExpr(E);\n  default:\n    return Error(E);\n  }\n}\n\nbool FixedPointExprEvaluator::VisitBinaryOperator(const BinaryOperator *E) {\n  if (E->isPtrMemOp() || E->isAssignmentOp() || E->getOpcode() == BO_Comma)\n    return ExprEvaluatorBaseTy::VisitBinaryOperator(E);\n\n  const Expr *LHS = E->getLHS();\n  const Expr *RHS = E->getRHS();\n  FixedPointSemantics ResultFXSema =\n      Info.Ctx.getFixedPointSemantics(E->getType());\n\n  APFixedPoint LHSFX(Info.Ctx.getFixedPointSemantics(LHS->getType()));\n  if (!EvaluateFixedPointOrInteger(LHS, LHSFX, Info))\n    return false;\n  APFixedPoint RHSFX(Info.Ctx.getFixedPointSemantics(RHS->getType()));\n  if (!EvaluateFixedPointOrInteger(RHS, RHSFX, Info))\n    return false;\n\n  bool OpOverflow = false, ConversionOverflow = false;\n  APFixedPoint Result(LHSFX.getSemantics());\n  switch (E->getOpcode()) {\n  case BO_Add: {\n    Result = LHSFX.add(RHSFX, &OpOverflow)\n                  .convert(ResultFXSema, &ConversionOverflow);\n    break;\n  }\n  case BO_Sub: {\n    Result = LHSFX.sub(RHSFX, &OpOverflow)\n                  .convert(ResultFXSema, &ConversionOverflow);\n    break;\n  }\n  case BO_Mul: {\n    Result = LHSFX.mul(RHSFX, &OpOverflow)\n                  .convert(ResultFXSema, &ConversionOverflow);\n    break;\n  }\n  case BO_Div: {\n    if (RHSFX.getValue() == 0) {\n      Info.FFDiag(E, diag::note_expr_divide_by_zero);\n      return false;\n    }\n    Result = LHSFX.div(RHSFX, &OpOverflow)\n                  .convert(ResultFXSema, &ConversionOverflow);\n    break;\n  }\n  case BO_Shl:\n  case BO_Shr: {\n    FixedPointSemantics LHSSema = LHSFX.getSemantics();\n    llvm::APSInt RHSVal = RHSFX.getValue();\n\n    unsigned ShiftBW =\n        LHSSema.getWidth() - (unsigned)LHSSema.hasUnsignedPadding();\n    unsigned Amt = RHSVal.getLimitedValue(ShiftBW - 1);\n    // Embedded-C 4.1.6.2.2:\n    //   The right operand must be nonnegative and less than the total number\n    //   of (nonpadding) bits of the fixed-point operand ...\n    if (RHSVal.isNegative())\n      Info.CCEDiag(E, diag::note_constexpr_negative_shift) << RHSVal;\n    else if (Amt != RHSVal)\n      Info.CCEDiag(E, diag::note_constexpr_large_shift)\n          << RHSVal << E->getType() << ShiftBW;\n\n    if (E->getOpcode() == BO_Shl)\n      Result = LHSFX.shl(Amt, &OpOverflow);\n    else\n      Result = LHSFX.shr(Amt, &OpOverflow);\n    break;\n  }\n  default:\n    return false;\n  }\n  if (OpOverflow || ConversionOverflow) {\n    if (Info.checkingForUndefinedBehavior())\n      Info.Ctx.getDiagnostics().Report(E->getExprLoc(),\n                                       diag::warn_fixedpoint_constant_overflow)\n        << Result.toString() << E->getType();\n    if (!HandleOverflow(Info, E, Result, E->getType()))\n      return false;\n  }\n  return Success(Result, E);\n}\n\n//===----------------------------------------------------------------------===//\n// Float Evaluation\n//===----------------------------------------------------------------------===//\n\nnamespace {\nclass FloatExprEvaluator\n  : public ExprEvaluatorBase<FloatExprEvaluator> {\n  APFloat &Result;\npublic:\n  FloatExprEvaluator(EvalInfo &info, APFloat &result)\n    : ExprEvaluatorBaseTy(info), Result(result) {}\n\n  bool Success(const APValue &V, const Expr *e) {\n    Result = V.getFloat();\n    return true;\n  }\n\n  bool ZeroInitialization(const Expr *E) {\n    Result = APFloat::getZero(Info.Ctx.getFloatTypeSemantics(E->getType()));\n    return true;\n  }\n\n  bool VisitCallExpr(const CallExpr *E);\n\n  bool VisitUnaryOperator(const UnaryOperator *E);\n  bool VisitBinaryOperator(const BinaryOperator *E);\n  bool VisitFloatingLiteral(const FloatingLiteral *E);\n  bool VisitCastExpr(const CastExpr *E);\n\n  bool VisitUnaryReal(const UnaryOperator *E);\n  bool VisitUnaryImag(const UnaryOperator *E);\n\n  // FIXME: Missing: array subscript of vector, member of vector\n};\n} // end anonymous namespace\n\nstatic bool EvaluateFloat(const Expr* E, APFloat& Result, EvalInfo &Info) {\n  assert(!E->isValueDependent());\n  assert(E->isRValue() && E->getType()->isRealFloatingType());\n  return FloatExprEvaluator(Info, Result).Visit(E);\n}\n\nstatic bool TryEvaluateBuiltinNaN(const ASTContext &Context,\n                                  QualType ResultTy,\n                                  const Expr *Arg,\n                                  bool SNaN,\n                                  llvm::APFloat &Result) {\n  const StringLiteral *S = dyn_cast<StringLiteral>(Arg->IgnoreParenCasts());\n  if (!S) return false;\n\n  const llvm::fltSemantics &Sem = Context.getFloatTypeSemantics(ResultTy);\n\n  llvm::APInt fill;\n\n  // Treat empty strings as if they were zero.\n  if (S->getString().empty())\n    fill = llvm::APInt(32, 0);\n  else if (S->getString().getAsInteger(0, fill))\n    return false;\n\n  if (Context.getTargetInfo().isNan2008()) {\n    if (SNaN)\n      Result = llvm::APFloat::getSNaN(Sem, false, &fill);\n    else\n      Result = llvm::APFloat::getQNaN(Sem, false, &fill);\n  } else {\n    // Prior to IEEE 754-2008, architectures were allowed to choose whether\n    // the first bit of their significand was set for qNaN or sNaN. MIPS chose\n    // a different encoding to what became a standard in 2008, and for pre-\n    // 2008 revisions, MIPS interpreted sNaN-2008 as qNan and qNaN-2008 as\n    // sNaN. This is now known as \"legacy NaN\" encoding.\n    if (SNaN)\n      Result = llvm::APFloat::getQNaN(Sem, false, &fill);\n    else\n      Result = llvm::APFloat::getSNaN(Sem, false, &fill);\n  }\n\n  return true;\n}\n\nbool FloatExprEvaluator::VisitCallExpr(const CallExpr *E) {\n  switch (E->getBuiltinCallee()) {\n  default:\n    return ExprEvaluatorBaseTy::VisitCallExpr(E);\n\n  case Builtin::BI__builtin_huge_val:\n  case Builtin::BI__builtin_huge_valf:\n  case Builtin::BI__builtin_huge_vall:\n  case Builtin::BI__builtin_huge_valf128:\n  case Builtin::BI__builtin_inf:\n  case Builtin::BI__builtin_inff:\n  case Builtin::BI__builtin_infl:\n  case Builtin::BI__builtin_inff128: {\n    const llvm::fltSemantics &Sem =\n      Info.Ctx.getFloatTypeSemantics(E->getType());\n    Result = llvm::APFloat::getInf(Sem);\n    return true;\n  }\n\n  case Builtin::BI__builtin_nans:\n  case Builtin::BI__builtin_nansf:\n  case Builtin::BI__builtin_nansl:\n  case Builtin::BI__builtin_nansf128:\n    if (!TryEvaluateBuiltinNaN(Info.Ctx, E->getType(), E->getArg(0),\n                               true, Result))\n      return Error(E);\n    return true;\n\n  case Builtin::BI__builtin_nan:\n  case Builtin::BI__builtin_nanf:\n  case Builtin::BI__builtin_nanl:\n  case Builtin::BI__builtin_nanf128:\n    // If this is __builtin_nan() turn this into a nan, otherwise we\n    // can't constant fold it.\n    if (!TryEvaluateBuiltinNaN(Info.Ctx, E->getType(), E->getArg(0),\n                               false, Result))\n      return Error(E);\n    return true;\n\n  case Builtin::BI__builtin_fabs:\n  case Builtin::BI__builtin_fabsf:\n  case Builtin::BI__builtin_fabsl:\n  case Builtin::BI__builtin_fabsf128:\n    // The C standard says \"fabs raises no floating-point exceptions,\n    // even if x is a signaling NaN. The returned value is independent of\n    // the current rounding direction mode.\"  Therefore constant folding can\n    // proceed without regard to the floating point settings.\n    // Reference, WG14 N2478 F.10.4.3\n    if (!EvaluateFloat(E->getArg(0), Result, Info))\n      return false;\n\n    if (Result.isNegative())\n      Result.changeSign();\n    return true;\n\n  // FIXME: Builtin::BI__builtin_powi\n  // FIXME: Builtin::BI__builtin_powif\n  // FIXME: Builtin::BI__builtin_powil\n\n  case Builtin::BI__builtin_copysign:\n  case Builtin::BI__builtin_copysignf:\n  case Builtin::BI__builtin_copysignl:\n  case Builtin::BI__builtin_copysignf128: {\n    APFloat RHS(0.);\n    if (!EvaluateFloat(E->getArg(0), Result, Info) ||\n        !EvaluateFloat(E->getArg(1), RHS, Info))\n      return false;\n    Result.copySign(RHS);\n    return true;\n  }\n  }\n}\n\nbool FloatExprEvaluator::VisitUnaryReal(const UnaryOperator *E) {\n  if (E->getSubExpr()->getType()->isAnyComplexType()) {\n    ComplexValue CV;\n    if (!EvaluateComplex(E->getSubExpr(), CV, Info))\n      return false;\n    Result = CV.FloatReal;\n    return true;\n  }\n\n  return Visit(E->getSubExpr());\n}\n\nbool FloatExprEvaluator::VisitUnaryImag(const UnaryOperator *E) {\n  if (E->getSubExpr()->getType()->isAnyComplexType()) {\n    ComplexValue CV;\n    if (!EvaluateComplex(E->getSubExpr(), CV, Info))\n      return false;\n    Result = CV.FloatImag;\n    return true;\n  }\n\n  VisitIgnoredValue(E->getSubExpr());\n  const llvm::fltSemantics &Sem = Info.Ctx.getFloatTypeSemantics(E->getType());\n  Result = llvm::APFloat::getZero(Sem);\n  return true;\n}\n\nbool FloatExprEvaluator::VisitUnaryOperator(const UnaryOperator *E) {\n  switch (E->getOpcode()) {\n  default: return Error(E);\n  case UO_Plus:\n    return EvaluateFloat(E->getSubExpr(), Result, Info);\n  case UO_Minus:\n    // In C standard, WG14 N2478 F.3 p4\n    // \"the unary - raises no floating point exceptions,\n    // even if the operand is signalling.\"\n    if (!EvaluateFloat(E->getSubExpr(), Result, Info))\n      return false;\n    Result.changeSign();\n    return true;\n  }\n}\n\nbool FloatExprEvaluator::VisitBinaryOperator(const BinaryOperator *E) {\n  if (E->isPtrMemOp() || E->isAssignmentOp() || E->getOpcode() == BO_Comma)\n    return ExprEvaluatorBaseTy::VisitBinaryOperator(E);\n\n  APFloat RHS(0.0);\n  bool LHSOK = EvaluateFloat(E->getLHS(), Result, Info);\n  if (!LHSOK && !Info.noteFailure())\n    return false;\n  return EvaluateFloat(E->getRHS(), RHS, Info) && LHSOK &&\n         handleFloatFloatBinOp(Info, E, Result, E->getOpcode(), RHS);\n}\n\nbool FloatExprEvaluator::VisitFloatingLiteral(const FloatingLiteral *E) {\n  Result = E->getValue();\n  return true;\n}\n\nbool FloatExprEvaluator::VisitCastExpr(const CastExpr *E) {\n  const Expr* SubExpr = E->getSubExpr();\n\n  switch (E->getCastKind()) {\n  default:\n    return ExprEvaluatorBaseTy::VisitCastExpr(E);\n\n  case CK_IntegralToFloating: {\n    APSInt IntResult;\n    const FPOptions FPO = E->getFPFeaturesInEffect(\n                                  Info.Ctx.getLangOpts());\n    return EvaluateInteger(SubExpr, IntResult, Info) &&\n           HandleIntToFloatCast(Info, E, FPO, SubExpr->getType(),\n                                IntResult, E->getType(), Result);\n  }\n\n  case CK_FixedPointToFloating: {\n    APFixedPoint FixResult(Info.Ctx.getFixedPointSemantics(SubExpr->getType()));\n    if (!EvaluateFixedPoint(SubExpr, FixResult, Info))\n      return false;\n    Result =\n        FixResult.convertToFloat(Info.Ctx.getFloatTypeSemantics(E->getType()));\n    return true;\n  }\n\n  case CK_FloatingCast: {\n    if (!Visit(SubExpr))\n      return false;\n    return HandleFloatToFloatCast(Info, E, SubExpr->getType(), E->getType(),\n                                  Result);\n  }\n\n  case CK_FloatingComplexToReal: {\n    ComplexValue V;\n    if (!EvaluateComplex(SubExpr, V, Info))\n      return false;\n    Result = V.getComplexFloatReal();\n    return true;\n  }\n  }\n}\n\n//===----------------------------------------------------------------------===//\n// Complex Evaluation (for float and integer)\n//===----------------------------------------------------------------------===//\n\nnamespace {\nclass ComplexExprEvaluator\n  : public ExprEvaluatorBase<ComplexExprEvaluator> {\n  ComplexValue &Result;\n\npublic:\n  ComplexExprEvaluator(EvalInfo &info, ComplexValue &Result)\n    : ExprEvaluatorBaseTy(info), Result(Result) {}\n\n  bool Success(const APValue &V, const Expr *e) {\n    Result.setFrom(V);\n    return true;\n  }\n\n  bool ZeroInitialization(const Expr *E);\n\n  //===--------------------------------------------------------------------===//\n  //                            Visitor Methods\n  //===--------------------------------------------------------------------===//\n\n  bool VisitImaginaryLiteral(const ImaginaryLiteral *E);\n  bool VisitCastExpr(const CastExpr *E);\n  bool VisitBinaryOperator(const BinaryOperator *E);\n  bool VisitUnaryOperator(const UnaryOperator *E);\n  bool VisitInitListExpr(const InitListExpr *E);\n  bool VisitCallExpr(const CallExpr *E);\n};\n} // end anonymous namespace\n\nstatic bool EvaluateComplex(const Expr *E, ComplexValue &Result,\n                            EvalInfo &Info) {\n  assert(!E->isValueDependent());\n  assert(E->isRValue() && E->getType()->isAnyComplexType());\n  return ComplexExprEvaluator(Info, Result).Visit(E);\n}\n\nbool ComplexExprEvaluator::ZeroInitialization(const Expr *E) {\n  QualType ElemTy = E->getType()->castAs<ComplexType>()->getElementType();\n  if (ElemTy->isRealFloatingType()) {\n    Result.makeComplexFloat();\n    APFloat Zero = APFloat::getZero(Info.Ctx.getFloatTypeSemantics(ElemTy));\n    Result.FloatReal = Zero;\n    Result.FloatImag = Zero;\n  } else {\n    Result.makeComplexInt();\n    APSInt Zero = Info.Ctx.MakeIntValue(0, ElemTy);\n    Result.IntReal = Zero;\n    Result.IntImag = Zero;\n  }\n  return true;\n}\n\nbool ComplexExprEvaluator::VisitImaginaryLiteral(const ImaginaryLiteral *E) {\n  const Expr* SubExpr = E->getSubExpr();\n\n  if (SubExpr->getType()->isRealFloatingType()) {\n    Result.makeComplexFloat();\n    APFloat &Imag = Result.FloatImag;\n    if (!EvaluateFloat(SubExpr, Imag, Info))\n      return false;\n\n    Result.FloatReal = APFloat(Imag.getSemantics());\n    return true;\n  } else {\n    assert(SubExpr->getType()->isIntegerType() &&\n           \"Unexpected imaginary literal.\");\n\n    Result.makeComplexInt();\n    APSInt &Imag = Result.IntImag;\n    if (!EvaluateInteger(SubExpr, Imag, Info))\n      return false;\n\n    Result.IntReal = APSInt(Imag.getBitWidth(), !Imag.isSigned());\n    return true;\n  }\n}\n\nbool ComplexExprEvaluator::VisitCastExpr(const CastExpr *E) {\n\n  switch (E->getCastKind()) {\n  case CK_BitCast:\n  case CK_BaseToDerived:\n  case CK_DerivedToBase:\n  case CK_UncheckedDerivedToBase:\n  case CK_Dynamic:\n  case CK_ToUnion:\n  case CK_ArrayToPointerDecay:\n  case CK_FunctionToPointerDecay:\n  case CK_NullToPointer:\n  case CK_NullToMemberPointer:\n  case CK_BaseToDerivedMemberPointer:\n  case CK_DerivedToBaseMemberPointer:\n  case CK_MemberPointerToBoolean:\n  case CK_ReinterpretMemberPointer:\n  case CK_ConstructorConversion:\n  case CK_IntegralToPointer:\n  case CK_PointerToIntegral:\n  case CK_PointerToBoolean:\n  case CK_ToVoid:\n  case CK_VectorSplat:\n  case CK_IntegralCast:\n  case CK_BooleanToSignedIntegral:\n  case CK_IntegralToBoolean:\n  case CK_IntegralToFloating:\n  case CK_FloatingToIntegral:\n  case CK_FloatingToBoolean:\n  case CK_FloatingCast:\n  case CK_CPointerToObjCPointerCast:\n  case CK_BlockPointerToObjCPointerCast:\n  case CK_AnyPointerToBlockPointerCast:\n  case CK_ObjCObjectLValueCast:\n  case CK_FloatingComplexToReal:\n  case CK_FloatingComplexToBoolean:\n  case CK_IntegralComplexToReal:\n  case CK_IntegralComplexToBoolean:\n  case CK_ARCProduceObject:\n  case CK_ARCConsumeObject:\n  case CK_ARCReclaimReturnedObject:\n  case CK_ARCExtendBlockObject:\n  case CK_CopyAndAutoreleaseBlockObject:\n  case CK_BuiltinFnToFnPtr:\n  case CK_ZeroToOCLOpaqueType:\n  case CK_NonAtomicToAtomic:\n  case CK_AddressSpaceConversion:\n  case CK_IntToOCLSampler:\n  case CK_FloatingToFixedPoint:\n  case CK_FixedPointToFloating:\n  case CK_FixedPointCast:\n  case CK_FixedPointToBoolean:\n  case CK_FixedPointToIntegral:\n  case CK_IntegralToFixedPoint:\n    llvm_unreachable(\"invalid cast kind for complex value\");\n\n  case CK_LValueToRValue:\n  case CK_AtomicToNonAtomic:\n  case CK_NoOp:\n  case CK_LValueToRValueBitCast:\n    return ExprEvaluatorBaseTy::VisitCastExpr(E);\n\n  case CK_Dependent:\n  case CK_LValueBitCast:\n  case CK_UserDefinedConversion:\n    return Error(E);\n\n  case CK_FloatingRealToComplex: {\n    APFloat &Real = Result.FloatReal;\n    if (!EvaluateFloat(E->getSubExpr(), Real, Info))\n      return false;\n\n    Result.makeComplexFloat();\n    Result.FloatImag = APFloat(Real.getSemantics());\n    return true;\n  }\n\n  case CK_FloatingComplexCast: {\n    if (!Visit(E->getSubExpr()))\n      return false;\n\n    QualType To = E->getType()->castAs<ComplexType>()->getElementType();\n    QualType From\n      = E->getSubExpr()->getType()->castAs<ComplexType>()->getElementType();\n\n    return HandleFloatToFloatCast(Info, E, From, To, Result.FloatReal) &&\n           HandleFloatToFloatCast(Info, E, From, To, Result.FloatImag);\n  }\n\n  case CK_FloatingComplexToIntegralComplex: {\n    if (!Visit(E->getSubExpr()))\n      return false;\n\n    QualType To = E->getType()->castAs<ComplexType>()->getElementType();\n    QualType From\n      = E->getSubExpr()->getType()->castAs<ComplexType>()->getElementType();\n    Result.makeComplexInt();\n    return HandleFloatToIntCast(Info, E, From, Result.FloatReal,\n                                To, Result.IntReal) &&\n           HandleFloatToIntCast(Info, E, From, Result.FloatImag,\n                                To, Result.IntImag);\n  }\n\n  case CK_IntegralRealToComplex: {\n    APSInt &Real = Result.IntReal;\n    if (!EvaluateInteger(E->getSubExpr(), Real, Info))\n      return false;\n\n    Result.makeComplexInt();\n    Result.IntImag = APSInt(Real.getBitWidth(), !Real.isSigned());\n    return true;\n  }\n\n  case CK_IntegralComplexCast: {\n    if (!Visit(E->getSubExpr()))\n      return false;\n\n    QualType To = E->getType()->castAs<ComplexType>()->getElementType();\n    QualType From\n      = E->getSubExpr()->getType()->castAs<ComplexType>()->getElementType();\n\n    Result.IntReal = HandleIntToIntCast(Info, E, To, From, Result.IntReal);\n    Result.IntImag = HandleIntToIntCast(Info, E, To, From, Result.IntImag);\n    return true;\n  }\n\n  case CK_IntegralComplexToFloatingComplex: {\n    if (!Visit(E->getSubExpr()))\n      return false;\n\n    const FPOptions FPO = E->getFPFeaturesInEffect(\n                                  Info.Ctx.getLangOpts());\n    QualType To = E->getType()->castAs<ComplexType>()->getElementType();\n    QualType From\n      = E->getSubExpr()->getType()->castAs<ComplexType>()->getElementType();\n    Result.makeComplexFloat();\n    return HandleIntToFloatCast(Info, E, FPO, From, Result.IntReal,\n                                To, Result.FloatReal) &&\n           HandleIntToFloatCast(Info, E, FPO, From, Result.IntImag,\n                                To, Result.FloatImag);\n  }\n  }\n\n  llvm_unreachable(\"unknown cast resulting in complex value\");\n}\n\nbool ComplexExprEvaluator::VisitBinaryOperator(const BinaryOperator *E) {\n  if (E->isPtrMemOp() || E->isAssignmentOp() || E->getOpcode() == BO_Comma)\n    return ExprEvaluatorBaseTy::VisitBinaryOperator(E);\n\n  // Track whether the LHS or RHS is real at the type system level. When this is\n  // the case we can simplify our evaluation strategy.\n  bool LHSReal = false, RHSReal = false;\n\n  bool LHSOK;\n  if (E->getLHS()->getType()->isRealFloatingType()) {\n    LHSReal = true;\n    APFloat &Real = Result.FloatReal;\n    LHSOK = EvaluateFloat(E->getLHS(), Real, Info);\n    if (LHSOK) {\n      Result.makeComplexFloat();\n      Result.FloatImag = APFloat(Real.getSemantics());\n    }\n  } else {\n    LHSOK = Visit(E->getLHS());\n  }\n  if (!LHSOK && !Info.noteFailure())\n    return false;\n\n  ComplexValue RHS;\n  if (E->getRHS()->getType()->isRealFloatingType()) {\n    RHSReal = true;\n    APFloat &Real = RHS.FloatReal;\n    if (!EvaluateFloat(E->getRHS(), Real, Info) || !LHSOK)\n      return false;\n    RHS.makeComplexFloat();\n    RHS.FloatImag = APFloat(Real.getSemantics());\n  } else if (!EvaluateComplex(E->getRHS(), RHS, Info) || !LHSOK)\n    return false;\n\n  assert(!(LHSReal && RHSReal) &&\n         \"Cannot have both operands of a complex operation be real.\");\n  switch (E->getOpcode()) {\n  default: return Error(E);\n  case BO_Add:\n    if (Result.isComplexFloat()) {\n      Result.getComplexFloatReal().add(RHS.getComplexFloatReal(),\n                                       APFloat::rmNearestTiesToEven);\n      if (LHSReal)\n        Result.getComplexFloatImag() = RHS.getComplexFloatImag();\n      else if (!RHSReal)\n        Result.getComplexFloatImag().add(RHS.getComplexFloatImag(),\n                                         APFloat::rmNearestTiesToEven);\n    } else {\n      Result.getComplexIntReal() += RHS.getComplexIntReal();\n      Result.getComplexIntImag() += RHS.getComplexIntImag();\n    }\n    break;\n  case BO_Sub:\n    if (Result.isComplexFloat()) {\n      Result.getComplexFloatReal().subtract(RHS.getComplexFloatReal(),\n                                            APFloat::rmNearestTiesToEven);\n      if (LHSReal) {\n        Result.getComplexFloatImag() = RHS.getComplexFloatImag();\n        Result.getComplexFloatImag().changeSign();\n      } else if (!RHSReal) {\n        Result.getComplexFloatImag().subtract(RHS.getComplexFloatImag(),\n                                              APFloat::rmNearestTiesToEven);\n      }\n    } else {\n      Result.getComplexIntReal() -= RHS.getComplexIntReal();\n      Result.getComplexIntImag() -= RHS.getComplexIntImag();\n    }\n    break;\n  case BO_Mul:\n    if (Result.isComplexFloat()) {\n      // This is an implementation of complex multiplication according to the\n      // constraints laid out in C11 Annex G. The implementation uses the\n      // following naming scheme:\n      //   (a + ib) * (c + id)\n      ComplexValue LHS = Result;\n      APFloat &A = LHS.getComplexFloatReal();\n      APFloat &B = LHS.getComplexFloatImag();\n      APFloat &C = RHS.getComplexFloatReal();\n      APFloat &D = RHS.getComplexFloatImag();\n      APFloat &ResR = Result.getComplexFloatReal();\n      APFloat &ResI = Result.getComplexFloatImag();\n      if (LHSReal) {\n        assert(!RHSReal && \"Cannot have two real operands for a complex op!\");\n        ResR = A * C;\n        ResI = A * D;\n      } else if (RHSReal) {\n        ResR = C * A;\n        ResI = C * B;\n      } else {\n        // In the fully general case, we need to handle NaNs and infinities\n        // robustly.\n        APFloat AC = A * C;\n        APFloat BD = B * D;\n        APFloat AD = A * D;\n        APFloat BC = B * C;\n        ResR = AC - BD;\n        ResI = AD + BC;\n        if (ResR.isNaN() && ResI.isNaN()) {\n          bool Recalc = false;\n          if (A.isInfinity() || B.isInfinity()) {\n            A = APFloat::copySign(\n                APFloat(A.getSemantics(), A.isInfinity() ? 1 : 0), A);\n            B = APFloat::copySign(\n                APFloat(B.getSemantics(), B.isInfinity() ? 1 : 0), B);\n            if (C.isNaN())\n              C = APFloat::copySign(APFloat(C.getSemantics()), C);\n            if (D.isNaN())\n              D = APFloat::copySign(APFloat(D.getSemantics()), D);\n            Recalc = true;\n          }\n          if (C.isInfinity() || D.isInfinity()) {\n            C = APFloat::copySign(\n                APFloat(C.getSemantics(), C.isInfinity() ? 1 : 0), C);\n            D = APFloat::copySign(\n                APFloat(D.getSemantics(), D.isInfinity() ? 1 : 0), D);\n            if (A.isNaN())\n              A = APFloat::copySign(APFloat(A.getSemantics()), A);\n            if (B.isNaN())\n              B = APFloat::copySign(APFloat(B.getSemantics()), B);\n            Recalc = true;\n          }\n          if (!Recalc && (AC.isInfinity() || BD.isInfinity() ||\n                          AD.isInfinity() || BC.isInfinity())) {\n            if (A.isNaN())\n              A = APFloat::copySign(APFloat(A.getSemantics()), A);\n            if (B.isNaN())\n              B = APFloat::copySign(APFloat(B.getSemantics()), B);\n            if (C.isNaN())\n              C = APFloat::copySign(APFloat(C.getSemantics()), C);\n            if (D.isNaN())\n              D = APFloat::copySign(APFloat(D.getSemantics()), D);\n            Recalc = true;\n          }\n          if (Recalc) {\n            ResR = APFloat::getInf(A.getSemantics()) * (A * C - B * D);\n            ResI = APFloat::getInf(A.getSemantics()) * (A * D + B * C);\n          }\n        }\n      }\n    } else {\n      ComplexValue LHS = Result;\n      Result.getComplexIntReal() =\n        (LHS.getComplexIntReal() * RHS.getComplexIntReal() -\n         LHS.getComplexIntImag() * RHS.getComplexIntImag());\n      Result.getComplexIntImag() =\n        (LHS.getComplexIntReal() * RHS.getComplexIntImag() +\n         LHS.getComplexIntImag() * RHS.getComplexIntReal());\n    }\n    break;\n  case BO_Div:\n    if (Result.isComplexFloat()) {\n      // This is an implementation of complex division according to the\n      // constraints laid out in C11 Annex G. The implementation uses the\n      // following naming scheme:\n      //   (a + ib) / (c + id)\n      ComplexValue LHS = Result;\n      APFloat &A = LHS.getComplexFloatReal();\n      APFloat &B = LHS.getComplexFloatImag();\n      APFloat &C = RHS.getComplexFloatReal();\n      APFloat &D = RHS.getComplexFloatImag();\n      APFloat &ResR = Result.getComplexFloatReal();\n      APFloat &ResI = Result.getComplexFloatImag();\n      if (RHSReal) {\n        ResR = A / C;\n        ResI = B / C;\n      } else {\n        if (LHSReal) {\n          // No real optimizations we can do here, stub out with zero.\n          B = APFloat::getZero(A.getSemantics());\n        }\n        int DenomLogB = 0;\n        APFloat MaxCD = maxnum(abs(C), abs(D));\n        if (MaxCD.isFinite()) {\n          DenomLogB = ilogb(MaxCD);\n          C = scalbn(C, -DenomLogB, APFloat::rmNearestTiesToEven);\n          D = scalbn(D, -DenomLogB, APFloat::rmNearestTiesToEven);\n        }\n        APFloat Denom = C * C + D * D;\n        ResR = scalbn((A * C + B * D) / Denom, -DenomLogB,\n                      APFloat::rmNearestTiesToEven);\n        ResI = scalbn((B * C - A * D) / Denom, -DenomLogB,\n                      APFloat::rmNearestTiesToEven);\n        if (ResR.isNaN() && ResI.isNaN()) {\n          if (Denom.isPosZero() && (!A.isNaN() || !B.isNaN())) {\n            ResR = APFloat::getInf(ResR.getSemantics(), C.isNegative()) * A;\n            ResI = APFloat::getInf(ResR.getSemantics(), C.isNegative()) * B;\n          } else if ((A.isInfinity() || B.isInfinity()) && C.isFinite() &&\n                     D.isFinite()) {\n            A = APFloat::copySign(\n                APFloat(A.getSemantics(), A.isInfinity() ? 1 : 0), A);\n            B = APFloat::copySign(\n                APFloat(B.getSemantics(), B.isInfinity() ? 1 : 0), B);\n            ResR = APFloat::getInf(ResR.getSemantics()) * (A * C + B * D);\n            ResI = APFloat::getInf(ResI.getSemantics()) * (B * C - A * D);\n          } else if (MaxCD.isInfinity() && A.isFinite() && B.isFinite()) {\n            C = APFloat::copySign(\n                APFloat(C.getSemantics(), C.isInfinity() ? 1 : 0), C);\n            D = APFloat::copySign(\n                APFloat(D.getSemantics(), D.isInfinity() ? 1 : 0), D);\n            ResR = APFloat::getZero(ResR.getSemantics()) * (A * C + B * D);\n            ResI = APFloat::getZero(ResI.getSemantics()) * (B * C - A * D);\n          }\n        }\n      }\n    } else {\n      if (RHS.getComplexIntReal() == 0 && RHS.getComplexIntImag() == 0)\n        return Error(E, diag::note_expr_divide_by_zero);\n\n      ComplexValue LHS = Result;\n      APSInt Den = RHS.getComplexIntReal() * RHS.getComplexIntReal() +\n        RHS.getComplexIntImag() * RHS.getComplexIntImag();\n      Result.getComplexIntReal() =\n        (LHS.getComplexIntReal() * RHS.getComplexIntReal() +\n         LHS.getComplexIntImag() * RHS.getComplexIntImag()) / Den;\n      Result.getComplexIntImag() =\n        (LHS.getComplexIntImag() * RHS.getComplexIntReal() -\n         LHS.getComplexIntReal() * RHS.getComplexIntImag()) / Den;\n    }\n    break;\n  }\n\n  return true;\n}\n\nbool ComplexExprEvaluator::VisitUnaryOperator(const UnaryOperator *E) {\n  // Get the operand value into 'Result'.\n  if (!Visit(E->getSubExpr()))\n    return false;\n\n  switch (E->getOpcode()) {\n  default:\n    return Error(E);\n  case UO_Extension:\n    return true;\n  case UO_Plus:\n    // The result is always just the subexpr.\n    return true;\n  case UO_Minus:\n    if (Result.isComplexFloat()) {\n      Result.getComplexFloatReal().changeSign();\n      Result.getComplexFloatImag().changeSign();\n    }\n    else {\n      Result.getComplexIntReal() = -Result.getComplexIntReal();\n      Result.getComplexIntImag() = -Result.getComplexIntImag();\n    }\n    return true;\n  case UO_Not:\n    if (Result.isComplexFloat())\n      Result.getComplexFloatImag().changeSign();\n    else\n      Result.getComplexIntImag() = -Result.getComplexIntImag();\n    return true;\n  }\n}\n\nbool ComplexExprEvaluator::VisitInitListExpr(const InitListExpr *E) {\n  if (E->getNumInits() == 2) {\n    if (E->getType()->isComplexType()) {\n      Result.makeComplexFloat();\n      if (!EvaluateFloat(E->getInit(0), Result.FloatReal, Info))\n        return false;\n      if (!EvaluateFloat(E->getInit(1), Result.FloatImag, Info))\n        return false;\n    } else {\n      Result.makeComplexInt();\n      if (!EvaluateInteger(E->getInit(0), Result.IntReal, Info))\n        return false;\n      if (!EvaluateInteger(E->getInit(1), Result.IntImag, Info))\n        return false;\n    }\n    return true;\n  }\n  return ExprEvaluatorBaseTy::VisitInitListExpr(E);\n}\n\nbool ComplexExprEvaluator::VisitCallExpr(const CallExpr *E) {\n  switch (E->getBuiltinCallee()) {\n  case Builtin::BI__builtin_complex:\n    Result.makeComplexFloat();\n    if (!EvaluateFloat(E->getArg(0), Result.FloatReal, Info))\n      return false;\n    if (!EvaluateFloat(E->getArg(1), Result.FloatImag, Info))\n      return false;\n    return true;\n\n  default:\n    break;\n  }\n\n  return ExprEvaluatorBaseTy::VisitCallExpr(E);\n}\n\n//===----------------------------------------------------------------------===//\n// Atomic expression evaluation, essentially just handling the NonAtomicToAtomic\n// implicit conversion.\n//===----------------------------------------------------------------------===//\n\nnamespace {\nclass AtomicExprEvaluator :\n    public ExprEvaluatorBase<AtomicExprEvaluator> {\n  const LValue *This;\n  APValue &Result;\npublic:\n  AtomicExprEvaluator(EvalInfo &Info, const LValue *This, APValue &Result)\n      : ExprEvaluatorBaseTy(Info), This(This), Result(Result) {}\n\n  bool Success(const APValue &V, const Expr *E) {\n    Result = V;\n    return true;\n  }\n\n  bool ZeroInitialization(const Expr *E) {\n    ImplicitValueInitExpr VIE(\n        E->getType()->castAs<AtomicType>()->getValueType());\n    // For atomic-qualified class (and array) types in C++, initialize the\n    // _Atomic-wrapped subobject directly, in-place.\n    return This ? EvaluateInPlace(Result, Info, *This, &VIE)\n                : Evaluate(Result, Info, &VIE);\n  }\n\n  bool VisitCastExpr(const CastExpr *E) {\n    switch (E->getCastKind()) {\n    default:\n      return ExprEvaluatorBaseTy::VisitCastExpr(E);\n    case CK_NonAtomicToAtomic:\n      return This ? EvaluateInPlace(Result, Info, *This, E->getSubExpr())\n                  : Evaluate(Result, Info, E->getSubExpr());\n    }\n  }\n};\n} // end anonymous namespace\n\nstatic bool EvaluateAtomic(const Expr *E, const LValue *This, APValue &Result,\n                           EvalInfo &Info) {\n  assert(!E->isValueDependent());\n  assert(E->isRValue() && E->getType()->isAtomicType());\n  return AtomicExprEvaluator(Info, This, Result).Visit(E);\n}\n\n//===----------------------------------------------------------------------===//\n// Void expression evaluation, primarily for a cast to void on the LHS of a\n// comma operator\n//===----------------------------------------------------------------------===//\n\nnamespace {\nclass VoidExprEvaluator\n  : public ExprEvaluatorBase<VoidExprEvaluator> {\npublic:\n  VoidExprEvaluator(EvalInfo &Info) : ExprEvaluatorBaseTy(Info) {}\n\n  bool Success(const APValue &V, const Expr *e) { return true; }\n\n  bool ZeroInitialization(const Expr *E) { return true; }\n\n  bool VisitCastExpr(const CastExpr *E) {\n    switch (E->getCastKind()) {\n    default:\n      return ExprEvaluatorBaseTy::VisitCastExpr(E);\n    case CK_ToVoid:\n      VisitIgnoredValue(E->getSubExpr());\n      return true;\n    }\n  }\n\n  bool VisitCallExpr(const CallExpr *E) {\n    switch (E->getBuiltinCallee()) {\n    case Builtin::BI__assume:\n    case Builtin::BI__builtin_assume:\n      // The argument is not evaluated!\n      return true;\n\n    case Builtin::BI__builtin_operator_delete:\n      return HandleOperatorDeleteCall(Info, E);\n\n    default:\n      break;\n    }\n\n    return ExprEvaluatorBaseTy::VisitCallExpr(E);\n  }\n\n  bool VisitCXXDeleteExpr(const CXXDeleteExpr *E);\n};\n} // end anonymous namespace\n\nbool VoidExprEvaluator::VisitCXXDeleteExpr(const CXXDeleteExpr *E) {\n  // We cannot speculatively evaluate a delete expression.\n  if (Info.SpeculativeEvaluationDepth)\n    return false;\n\n  FunctionDecl *OperatorDelete = E->getOperatorDelete();\n  if (!OperatorDelete->isReplaceableGlobalAllocationFunction()) {\n    Info.FFDiag(E, diag::note_constexpr_new_non_replaceable)\n        << isa<CXXMethodDecl>(OperatorDelete) << OperatorDelete;\n    return false;\n  }\n\n  const Expr *Arg = E->getArgument();\n\n  LValue Pointer;\n  if (!EvaluatePointer(Arg, Pointer, Info))\n    return false;\n  if (Pointer.Designator.Invalid)\n    return false;\n\n  // Deleting a null pointer has no effect.\n  if (Pointer.isNullPointer()) {\n    // This is the only case where we need to produce an extension warning:\n    // the only other way we can succeed is if we find a dynamic allocation,\n    // and we will have warned when we allocated it in that case.\n    if (!Info.getLangOpts().CPlusPlus20)\n      Info.CCEDiag(E, diag::note_constexpr_new);\n    return true;\n  }\n\n  Optional<DynAlloc *> Alloc = CheckDeleteKind(\n      Info, E, Pointer, E->isArrayForm() ? DynAlloc::ArrayNew : DynAlloc::New);\n  if (!Alloc)\n    return false;\n  QualType AllocType = Pointer.Base.getDynamicAllocType();\n\n  // For the non-array case, the designator must be empty if the static type\n  // does not have a virtual destructor.\n  if (!E->isArrayForm() && Pointer.Designator.Entries.size() != 0 &&\n      !hasVirtualDestructor(Arg->getType()->getPointeeType())) {\n    Info.FFDiag(E, diag::note_constexpr_delete_base_nonvirt_dtor)\n        << Arg->getType()->getPointeeType() << AllocType;\n    return false;\n  }\n\n  // For a class type with a virtual destructor, the selected operator delete\n  // is the one looked up when building the destructor.\n  if (!E->isArrayForm() && !E->isGlobalDelete()) {\n    const FunctionDecl *VirtualDelete = getVirtualOperatorDelete(AllocType);\n    if (VirtualDelete &&\n        !VirtualDelete->isReplaceableGlobalAllocationFunction()) {\n      Info.FFDiag(E, diag::note_constexpr_new_non_replaceable)\n          << isa<CXXMethodDecl>(VirtualDelete) << VirtualDelete;\n      return false;\n    }\n  }\n\n  if (!HandleDestruction(Info, E->getExprLoc(), Pointer.getLValueBase(),\n                         (*Alloc)->Value, AllocType))\n    return false;\n\n  if (!Info.HeapAllocs.erase(Pointer.Base.dyn_cast<DynamicAllocLValue>())) {\n    // The element was already erased. This means the destructor call also\n    // deleted the object.\n    // FIXME: This probably results in undefined behavior before we get this\n    // far, and should be diagnosed elsewhere first.\n    Info.FFDiag(E, diag::note_constexpr_double_delete);\n    return false;\n  }\n\n  return true;\n}\n\nstatic bool EvaluateVoid(const Expr *E, EvalInfo &Info) {\n  assert(!E->isValueDependent());\n  assert(E->isRValue() && E->getType()->isVoidType());\n  return VoidExprEvaluator(Info).Visit(E);\n}\n\n//===----------------------------------------------------------------------===//\n// Top level Expr::EvaluateAsRValue method.\n//===----------------------------------------------------------------------===//\n\nstatic bool Evaluate(APValue &Result, EvalInfo &Info, const Expr *E) {\n  assert(!E->isValueDependent());\n  // In C, function designators are not lvalues, but we evaluate them as if they\n  // are.\n  QualType T = E->getType();\n  if (E->isGLValue() || T->isFunctionType()) {\n    LValue LV;\n    if (!EvaluateLValue(E, LV, Info))\n      return false;\n    LV.moveInto(Result);\n  } else if (T->isVectorType()) {\n    if (!EvaluateVector(E, Result, Info))\n      return false;\n  } else if (T->isIntegralOrEnumerationType()) {\n    if (!IntExprEvaluator(Info, Result).Visit(E))\n      return false;\n  } else if (T->hasPointerRepresentation()) {\n    LValue LV;\n    if (!EvaluatePointer(E, LV, Info))\n      return false;\n    LV.moveInto(Result);\n  } else if (T->isRealFloatingType()) {\n    llvm::APFloat F(0.0);\n    if (!EvaluateFloat(E, F, Info))\n      return false;\n    Result = APValue(F);\n  } else if (T->isAnyComplexType()) {\n    ComplexValue C;\n    if (!EvaluateComplex(E, C, Info))\n      return false;\n    C.moveInto(Result);\n  } else if (T->isFixedPointType()) {\n    if (!FixedPointExprEvaluator(Info, Result).Visit(E)) return false;\n  } else if (T->isMemberPointerType()) {\n    MemberPtr P;\n    if (!EvaluateMemberPointer(E, P, Info))\n      return false;\n    P.moveInto(Result);\n    return true;\n  } else if (T->isArrayType()) {\n    LValue LV;\n    APValue &Value =\n        Info.CurrentCall->createTemporary(E, T, ScopeKind::FullExpression, LV);\n    if (!EvaluateArray(E, LV, Value, Info))\n      return false;\n    Result = Value;\n  } else if (T->isRecordType()) {\n    LValue LV;\n    APValue &Value =\n        Info.CurrentCall->createTemporary(E, T, ScopeKind::FullExpression, LV);\n    if (!EvaluateRecord(E, LV, Value, Info))\n      return false;\n    Result = Value;\n  } else if (T->isVoidType()) {\n    if (!Info.getLangOpts().CPlusPlus11)\n      Info.CCEDiag(E, diag::note_constexpr_nonliteral)\n        << E->getType();\n    if (!EvaluateVoid(E, Info))\n      return false;\n  } else if (T->isAtomicType()) {\n    QualType Unqual = T.getAtomicUnqualifiedType();\n    if (Unqual->isArrayType() || Unqual->isRecordType()) {\n      LValue LV;\n      APValue &Value = Info.CurrentCall->createTemporary(\n          E, Unqual, ScopeKind::FullExpression, LV);\n      if (!EvaluateAtomic(E, &LV, Value, Info))\n        return false;\n    } else {\n      if (!EvaluateAtomic(E, nullptr, Result, Info))\n        return false;\n    }\n  } else if (Info.getLangOpts().CPlusPlus11) {\n    Info.FFDiag(E, diag::note_constexpr_nonliteral) << E->getType();\n    return false;\n  } else {\n    Info.FFDiag(E, diag::note_invalid_subexpr_in_const_expr);\n    return false;\n  }\n\n  return true;\n}\n\n/// EvaluateInPlace - Evaluate an expression in-place in an APValue. In some\n/// cases, the in-place evaluation is essential, since later initializers for\n/// an object can indirectly refer to subobjects which were initialized earlier.\nstatic bool EvaluateInPlace(APValue &Result, EvalInfo &Info, const LValue &This,\n                            const Expr *E, bool AllowNonLiteralTypes) {\n  assert(!E->isValueDependent());\n\n  if (!AllowNonLiteralTypes && !CheckLiteralType(Info, E, &This))\n    return false;\n\n  if (E->isRValue()) {\n    // Evaluate arrays and record types in-place, so that later initializers can\n    // refer to earlier-initialized members of the object.\n    QualType T = E->getType();\n    if (T->isArrayType())\n      return EvaluateArray(E, This, Result, Info);\n    else if (T->isRecordType())\n      return EvaluateRecord(E, This, Result, Info);\n    else if (T->isAtomicType()) {\n      QualType Unqual = T.getAtomicUnqualifiedType();\n      if (Unqual->isArrayType() || Unqual->isRecordType())\n        return EvaluateAtomic(E, &This, Result, Info);\n    }\n  }\n\n  // For any other type, in-place evaluation is unimportant.\n  return Evaluate(Result, Info, E);\n}\n\n/// EvaluateAsRValue - Try to evaluate this expression, performing an implicit\n/// lvalue-to-rvalue cast if it is an lvalue.\nstatic bool EvaluateAsRValue(EvalInfo &Info, const Expr *E, APValue &Result) {\n  assert(!E->isValueDependent());\n  if (Info.EnableNewConstInterp) {\n    if (!Info.Ctx.getInterpContext().evaluateAsRValue(Info, E, Result))\n      return false;\n  } else {\n    if (E->getType().isNull())\n      return false;\n\n    if (!CheckLiteralType(Info, E))\n      return false;\n\n    if (!::Evaluate(Result, Info, E))\n      return false;\n\n    if (E->isGLValue()) {\n      LValue LV;\n      LV.setFrom(Info.Ctx, Result);\n      if (!handleLValueToRValueConversion(Info, E, E->getType(), LV, Result))\n        return false;\n    }\n  }\n\n  // Check this core constant expression is a constant expression.\n  return CheckConstantExpression(Info, E->getExprLoc(), E->getType(), Result,\n                                 ConstantExprKind::Normal) &&\n         CheckMemoryLeaks(Info);\n}\n\nstatic bool FastEvaluateAsRValue(const Expr *Exp, Expr::EvalResult &Result,\n                                 const ASTContext &Ctx, bool &IsConst) {\n  // Fast-path evaluations of integer literals, since we sometimes see files\n  // containing vast quantities of these.\n  if (const IntegerLiteral *L = dyn_cast<IntegerLiteral>(Exp)) {\n    Result.Val = APValue(APSInt(L->getValue(),\n                                L->getType()->isUnsignedIntegerType()));\n    IsConst = true;\n    return true;\n  }\n\n  // This case should be rare, but we need to check it before we check on\n  // the type below.\n  if (Exp->getType().isNull()) {\n    IsConst = false;\n    return true;\n  }\n\n  // FIXME: Evaluating values of large array and record types can cause\n  // performance problems. Only do so in C++11 for now.\n  if (Exp->isRValue() && (Exp->getType()->isArrayType() ||\n                          Exp->getType()->isRecordType()) &&\n      !Ctx.getLangOpts().CPlusPlus11) {\n    IsConst = false;\n    return true;\n  }\n  return false;\n}\n\nstatic bool hasUnacceptableSideEffect(Expr::EvalStatus &Result,\n                                      Expr::SideEffectsKind SEK) {\n  return (SEK < Expr::SE_AllowSideEffects && Result.HasSideEffects) ||\n         (SEK < Expr::SE_AllowUndefinedBehavior && Result.HasUndefinedBehavior);\n}\n\nstatic bool EvaluateAsRValue(const Expr *E, Expr::EvalResult &Result,\n                             const ASTContext &Ctx, EvalInfo &Info) {\n  assert(!E->isValueDependent());\n  bool IsConst;\n  if (FastEvaluateAsRValue(E, Result, Ctx, IsConst))\n    return IsConst;\n\n  return EvaluateAsRValue(Info, E, Result.Val);\n}\n\nstatic bool EvaluateAsInt(const Expr *E, Expr::EvalResult &ExprResult,\n                          const ASTContext &Ctx,\n                          Expr::SideEffectsKind AllowSideEffects,\n                          EvalInfo &Info) {\n  assert(!E->isValueDependent());\n  if (!E->getType()->isIntegralOrEnumerationType())\n    return false;\n\n  if (!::EvaluateAsRValue(E, ExprResult, Ctx, Info) ||\n      !ExprResult.Val.isInt() ||\n      hasUnacceptableSideEffect(ExprResult, AllowSideEffects))\n    return false;\n\n  return true;\n}\n\nstatic bool EvaluateAsFixedPoint(const Expr *E, Expr::EvalResult &ExprResult,\n                                 const ASTContext &Ctx,\n                                 Expr::SideEffectsKind AllowSideEffects,\n                                 EvalInfo &Info) {\n  assert(!E->isValueDependent());\n  if (!E->getType()->isFixedPointType())\n    return false;\n\n  if (!::EvaluateAsRValue(E, ExprResult, Ctx, Info))\n    return false;\n\n  if (!ExprResult.Val.isFixedPoint() ||\n      hasUnacceptableSideEffect(ExprResult, AllowSideEffects))\n    return false;\n\n  return true;\n}\n\n/// EvaluateAsRValue - Return true if this is a constant which we can fold using\n/// any crazy technique (that has nothing to do with language standards) that\n/// we want to.  If this function returns true, it returns the folded constant\n/// in Result. If this expression is a glvalue, an lvalue-to-rvalue conversion\n/// will be applied to the result.\nbool Expr::EvaluateAsRValue(EvalResult &Result, const ASTContext &Ctx,\n                            bool InConstantContext) const {\n  assert(!isValueDependent() &&\n         \"Expression evaluator can't be called on a dependent expression.\");\n  EvalInfo Info(Ctx, Result, EvalInfo::EM_IgnoreSideEffects);\n  Info.InConstantContext = InConstantContext;\n  return ::EvaluateAsRValue(this, Result, Ctx, Info);\n}\n\nbool Expr::EvaluateAsBooleanCondition(bool &Result, const ASTContext &Ctx,\n                                      bool InConstantContext) const {\n  assert(!isValueDependent() &&\n         \"Expression evaluator can't be called on a dependent expression.\");\n  EvalResult Scratch;\n  return EvaluateAsRValue(Scratch, Ctx, InConstantContext) &&\n         HandleConversionToBool(Scratch.Val, Result);\n}\n\nbool Expr::EvaluateAsInt(EvalResult &Result, const ASTContext &Ctx,\n                         SideEffectsKind AllowSideEffects,\n                         bool InConstantContext) const {\n  assert(!isValueDependent() &&\n         \"Expression evaluator can't be called on a dependent expression.\");\n  EvalInfo Info(Ctx, Result, EvalInfo::EM_IgnoreSideEffects);\n  Info.InConstantContext = InConstantContext;\n  return ::EvaluateAsInt(this, Result, Ctx, AllowSideEffects, Info);\n}\n\nbool Expr::EvaluateAsFixedPoint(EvalResult &Result, const ASTContext &Ctx,\n                                SideEffectsKind AllowSideEffects,\n                                bool InConstantContext) const {\n  assert(!isValueDependent() &&\n         \"Expression evaluator can't be called on a dependent expression.\");\n  EvalInfo Info(Ctx, Result, EvalInfo::EM_IgnoreSideEffects);\n  Info.InConstantContext = InConstantContext;\n  return ::EvaluateAsFixedPoint(this, Result, Ctx, AllowSideEffects, Info);\n}\n\nbool Expr::EvaluateAsFloat(APFloat &Result, const ASTContext &Ctx,\n                           SideEffectsKind AllowSideEffects,\n                           bool InConstantContext) const {\n  assert(!isValueDependent() &&\n         \"Expression evaluator can't be called on a dependent expression.\");\n\n  if (!getType()->isRealFloatingType())\n    return false;\n\n  EvalResult ExprResult;\n  if (!EvaluateAsRValue(ExprResult, Ctx, InConstantContext) ||\n      !ExprResult.Val.isFloat() ||\n      hasUnacceptableSideEffect(ExprResult, AllowSideEffects))\n    return false;\n\n  Result = ExprResult.Val.getFloat();\n  return true;\n}\n\nbool Expr::EvaluateAsLValue(EvalResult &Result, const ASTContext &Ctx,\n                            bool InConstantContext) const {\n  assert(!isValueDependent() &&\n         \"Expression evaluator can't be called on a dependent expression.\");\n\n  EvalInfo Info(Ctx, Result, EvalInfo::EM_ConstantFold);\n  Info.InConstantContext = InConstantContext;\n  LValue LV;\n  CheckedTemporaries CheckedTemps;\n  if (!EvaluateLValue(this, LV, Info) || !Info.discardCleanups() ||\n      Result.HasSideEffects ||\n      !CheckLValueConstantExpression(Info, getExprLoc(),\n                                     Ctx.getLValueReferenceType(getType()), LV,\n                                     ConstantExprKind::Normal, CheckedTemps))\n    return false;\n\n  LV.moveInto(Result.Val);\n  return true;\n}\n\nstatic bool EvaluateDestruction(const ASTContext &Ctx, APValue::LValueBase Base,\n                                APValue DestroyedValue, QualType Type,\n                                SourceLocation Loc, Expr::EvalStatus &EStatus,\n                                bool IsConstantDestruction) {\n  EvalInfo Info(Ctx, EStatus,\n                IsConstantDestruction ? EvalInfo::EM_ConstantExpression\n                                      : EvalInfo::EM_ConstantFold);\n  Info.setEvaluatingDecl(Base, DestroyedValue,\n                         EvalInfo::EvaluatingDeclKind::Dtor);\n  Info.InConstantContext = IsConstantDestruction;\n\n  LValue LVal;\n  LVal.set(Base);\n\n  if (!HandleDestruction(Info, Loc, Base, DestroyedValue, Type) ||\n      EStatus.HasSideEffects)\n    return false;\n\n  if (!Info.discardCleanups())\n    llvm_unreachable(\"Unhandled cleanup; missing full expression marker?\");\n\n  return true;\n}\n\nbool Expr::EvaluateAsConstantExpr(EvalResult &Result, const ASTContext &Ctx,\n                                  ConstantExprKind Kind) const {\n  assert(!isValueDependent() &&\n         \"Expression evaluator can't be called on a dependent expression.\");\n\n  EvalInfo::EvaluationMode EM = EvalInfo::EM_ConstantExpression;\n  EvalInfo Info(Ctx, Result, EM);\n  Info.InConstantContext = true;\n\n  // The type of the object we're initializing is 'const T' for a class NTTP.\n  QualType T = getType();\n  if (Kind == ConstantExprKind::ClassTemplateArgument)\n    T.addConst();\n\n  // If we're evaluating a prvalue, fake up a MaterializeTemporaryExpr to\n  // represent the result of the evaluation. CheckConstantExpression ensures\n  // this doesn't escape.\n  MaterializeTemporaryExpr BaseMTE(T, const_cast<Expr*>(this), true);\n  APValue::LValueBase Base(&BaseMTE);\n\n  Info.setEvaluatingDecl(Base, Result.Val);\n  LValue LVal;\n  LVal.set(Base);\n\n  if (!::EvaluateInPlace(Result.Val, Info, LVal, this) || Result.HasSideEffects)\n    return false;\n\n  if (!Info.discardCleanups())\n    llvm_unreachable(\"Unhandled cleanup; missing full expression marker?\");\n\n  if (!CheckConstantExpression(Info, getExprLoc(), getStorageType(Ctx, this),\n                               Result.Val, Kind))\n    return false;\n  if (!CheckMemoryLeaks(Info))\n    return false;\n\n  // If this is a class template argument, it's required to have constant\n  // destruction too.\n  if (Kind == ConstantExprKind::ClassTemplateArgument &&\n      (!EvaluateDestruction(Ctx, Base, Result.Val, T, getBeginLoc(), Result,\n                            true) ||\n       Result.HasSideEffects)) {\n    // FIXME: Prefix a note to indicate that the problem is lack of constant\n    // destruction.\n    return false;\n  }\n\n  return true;\n}\n\nbool Expr::EvaluateAsInitializer(APValue &Value, const ASTContext &Ctx,\n                                 const VarDecl *VD,\n                                 SmallVectorImpl<PartialDiagnosticAt> &Notes,\n                                 bool IsConstantInitialization) const {\n  assert(!isValueDependent() &&\n         \"Expression evaluator can't be called on a dependent expression.\");\n\n  // FIXME: Evaluating initializers for large array and record types can cause\n  // performance problems. Only do so in C++11 for now.\n  if (isRValue() && (getType()->isArrayType() || getType()->isRecordType()) &&\n      !Ctx.getLangOpts().CPlusPlus11)\n    return false;\n\n  Expr::EvalStatus EStatus;\n  EStatus.Diag = &Notes;\n\n  EvalInfo Info(Ctx, EStatus,\n                (IsConstantInitialization && Ctx.getLangOpts().CPlusPlus11)\n                    ? EvalInfo::EM_ConstantExpression\n                    : EvalInfo::EM_ConstantFold);\n  Info.setEvaluatingDecl(VD, Value);\n  Info.InConstantContext = IsConstantInitialization;\n\n  SourceLocation DeclLoc = VD->getLocation();\n  QualType DeclTy = VD->getType();\n\n  if (Info.EnableNewConstInterp) {\n    auto &InterpCtx = const_cast<ASTContext &>(Ctx).getInterpContext();\n    if (!InterpCtx.evaluateAsInitializer(Info, VD, Value))\n      return false;\n  } else {\n    LValue LVal;\n    LVal.set(VD);\n\n    if (!EvaluateInPlace(Value, Info, LVal, this,\n                         /*AllowNonLiteralTypes=*/true) ||\n        EStatus.HasSideEffects)\n      return false;\n\n    // At this point, any lifetime-extended temporaries are completely\n    // initialized.\n    Info.performLifetimeExtension();\n\n    if (!Info.discardCleanups())\n      llvm_unreachable(\"Unhandled cleanup; missing full expression marker?\");\n  }\n  return CheckConstantExpression(Info, DeclLoc, DeclTy, Value,\n                                 ConstantExprKind::Normal) &&\n         CheckMemoryLeaks(Info);\n}\n\nbool VarDecl::evaluateDestruction(\n    SmallVectorImpl<PartialDiagnosticAt> &Notes) const {\n  Expr::EvalStatus EStatus;\n  EStatus.Diag = &Notes;\n\n  // Only treat the destruction as constant destruction if we formally have\n  // constant initialization (or are usable in a constant expression).\n  bool IsConstantDestruction = hasConstantInitialization();\n\n  // Make a copy of the value for the destructor to mutate, if we know it.\n  // Otherwise, treat the value as default-initialized; if the destructor works\n  // anyway, then the destruction is constant (and must be essentially empty).\n  APValue DestroyedValue;\n  if (getEvaluatedValue() && !getEvaluatedValue()->isAbsent())\n    DestroyedValue = *getEvaluatedValue();\n  else if (!getDefaultInitValue(getType(), DestroyedValue))\n    return false;\n\n  if (!EvaluateDestruction(getASTContext(), this, std::move(DestroyedValue),\n                           getType(), getLocation(), EStatus,\n                           IsConstantDestruction) ||\n      EStatus.HasSideEffects)\n    return false;\n\n  ensureEvaluatedStmt()->HasConstantDestruction = true;\n  return true;\n}\n\n/// isEvaluatable - Call EvaluateAsRValue to see if this expression can be\n/// constant folded, but discard the result.\nbool Expr::isEvaluatable(const ASTContext &Ctx, SideEffectsKind SEK) const {\n  assert(!isValueDependent() &&\n         \"Expression evaluator can't be called on a dependent expression.\");\n\n  EvalResult Result;\n  return EvaluateAsRValue(Result, Ctx, /* in constant context */ true) &&\n         !hasUnacceptableSideEffect(Result, SEK);\n}\n\nAPSInt Expr::EvaluateKnownConstInt(const ASTContext &Ctx,\n                    SmallVectorImpl<PartialDiagnosticAt> *Diag) const {\n  assert(!isValueDependent() &&\n         \"Expression evaluator can't be called on a dependent expression.\");\n\n  EvalResult EVResult;\n  EVResult.Diag = Diag;\n  EvalInfo Info(Ctx, EVResult, EvalInfo::EM_IgnoreSideEffects);\n  Info.InConstantContext = true;\n\n  bool Result = ::EvaluateAsRValue(this, EVResult, Ctx, Info);\n  (void)Result;\n  assert(Result && \"Could not evaluate expression\");\n  assert(EVResult.Val.isInt() && \"Expression did not evaluate to integer\");\n\n  return EVResult.Val.getInt();\n}\n\nAPSInt Expr::EvaluateKnownConstIntCheckOverflow(\n    const ASTContext &Ctx, SmallVectorImpl<PartialDiagnosticAt> *Diag) const {\n  assert(!isValueDependent() &&\n         \"Expression evaluator can't be called on a dependent expression.\");\n\n  EvalResult EVResult;\n  EVResult.Diag = Diag;\n  EvalInfo Info(Ctx, EVResult, EvalInfo::EM_IgnoreSideEffects);\n  Info.InConstantContext = true;\n  Info.CheckingForUndefinedBehavior = true;\n\n  bool Result = ::EvaluateAsRValue(Info, this, EVResult.Val);\n  (void)Result;\n  assert(Result && \"Could not evaluate expression\");\n  assert(EVResult.Val.isInt() && \"Expression did not evaluate to integer\");\n\n  return EVResult.Val.getInt();\n}\n\nvoid Expr::EvaluateForOverflow(const ASTContext &Ctx) const {\n  assert(!isValueDependent() &&\n         \"Expression evaluator can't be called on a dependent expression.\");\n\n  bool IsConst;\n  EvalResult EVResult;\n  if (!FastEvaluateAsRValue(this, EVResult, Ctx, IsConst)) {\n    EvalInfo Info(Ctx, EVResult, EvalInfo::EM_IgnoreSideEffects);\n    Info.CheckingForUndefinedBehavior = true;\n    (void)::EvaluateAsRValue(Info, this, EVResult.Val);\n  }\n}\n\nbool Expr::EvalResult::isGlobalLValue() const {\n  assert(Val.isLValue());\n  return IsGlobalLValue(Val.getLValueBase());\n}\n\n/// isIntegerConstantExpr - this recursive routine will test if an expression is\n/// an integer constant expression.\n\n/// FIXME: Pass up a reason why! Invalid operation in i-c-e, division by zero,\n/// comma, etc\n\n// CheckICE - This function does the fundamental ICE checking: the returned\n// ICEDiag contains an ICEKind indicating whether the expression is an ICE,\n// and a (possibly null) SourceLocation indicating the location of the problem.\n//\n// Note that to reduce code duplication, this helper does no evaluation\n// itself; the caller checks whether the expression is evaluatable, and\n// in the rare cases where CheckICE actually cares about the evaluated\n// value, it calls into Evaluate.\n\nnamespace {\n\nenum ICEKind {\n  /// This expression is an ICE.\n  IK_ICE,\n  /// This expression is not an ICE, but if it isn't evaluated, it's\n  /// a legal subexpression for an ICE. This return value is used to handle\n  /// the comma operator in C99 mode, and non-constant subexpressions.\n  IK_ICEIfUnevaluated,\n  /// This expression is not an ICE, and is not a legal subexpression for one.\n  IK_NotICE\n};\n\nstruct ICEDiag {\n  ICEKind Kind;\n  SourceLocation Loc;\n\n  ICEDiag(ICEKind IK, SourceLocation l) : Kind(IK), Loc(l) {}\n};\n\n}\n\nstatic ICEDiag NoDiag() { return ICEDiag(IK_ICE, SourceLocation()); }\n\nstatic ICEDiag Worst(ICEDiag A, ICEDiag B) { return A.Kind >= B.Kind ? A : B; }\n\nstatic ICEDiag CheckEvalInICE(const Expr* E, const ASTContext &Ctx) {\n  Expr::EvalResult EVResult;\n  Expr::EvalStatus Status;\n  EvalInfo Info(Ctx, Status, EvalInfo::EM_ConstantExpression);\n\n  Info.InConstantContext = true;\n  if (!::EvaluateAsRValue(E, EVResult, Ctx, Info) || EVResult.HasSideEffects ||\n      !EVResult.Val.isInt())\n    return ICEDiag(IK_NotICE, E->getBeginLoc());\n\n  return NoDiag();\n}\n\nstatic ICEDiag CheckICE(const Expr* E, const ASTContext &Ctx) {\n  assert(!E->isValueDependent() && \"Should not see value dependent exprs!\");\n  if (!E->getType()->isIntegralOrEnumerationType())\n    return ICEDiag(IK_NotICE, E->getBeginLoc());\n\n  switch (E->getStmtClass()) {\n#define ABSTRACT_STMT(Node)\n#define STMT(Node, Base) case Expr::Node##Class:\n#define EXPR(Node, Base)\n#include \"clang/AST/StmtNodes.inc\"\n  case Expr::PredefinedExprClass:\n  case Expr::FloatingLiteralClass:\n  case Expr::ImaginaryLiteralClass:\n  case Expr::StringLiteralClass:\n  case Expr::ArraySubscriptExprClass:\n  case Expr::MatrixSubscriptExprClass:\n  case Expr::OMPArraySectionExprClass:\n  case Expr::OMPArrayShapingExprClass:\n  case Expr::OMPIteratorExprClass:\n  case Expr::MemberExprClass:\n  case Expr::CompoundAssignOperatorClass:\n  case Expr::CompoundLiteralExprClass:\n  case Expr::ExtVectorElementExprClass:\n  case Expr::DesignatedInitExprClass:\n  case Expr::ArrayInitLoopExprClass:\n  case Expr::ArrayInitIndexExprClass:\n  case Expr::NoInitExprClass:\n  case Expr::DesignatedInitUpdateExprClass:\n  case Expr::ImplicitValueInitExprClass:\n  case Expr::ParenListExprClass:\n  case Expr::VAArgExprClass:\n  case Expr::AddrLabelExprClass:\n  case Expr::StmtExprClass:\n  case Expr::CXXMemberCallExprClass:\n  case Expr::CUDAKernelCallExprClass:\n  case Expr::CXXAddrspaceCastExprClass:\n  case Expr::CXXDynamicCastExprClass:\n  case Expr::CXXTypeidExprClass:\n  case Expr::CXXUuidofExprClass:\n  case Expr::MSPropertyRefExprClass:\n  case Expr::MSPropertySubscriptExprClass:\n  case Expr::CXXNullPtrLiteralExprClass:\n  case Expr::UserDefinedLiteralClass:\n  case Expr::CXXThisExprClass:\n  case Expr::CXXThrowExprClass:\n  case Expr::CXXNewExprClass:\n  case Expr::CXXDeleteExprClass:\n  case Expr::CXXPseudoDestructorExprClass:\n  case Expr::UnresolvedLookupExprClass:\n  case Expr::TypoExprClass:\n  case Expr::RecoveryExprClass:\n  case Expr::DependentScopeDeclRefExprClass:\n  case Expr::CXXConstructExprClass:\n  case Expr::CXXInheritedCtorInitExprClass:\n  case Expr::CXXStdInitializerListExprClass:\n  case Expr::CXXBindTemporaryExprClass:\n  case Expr::ExprWithCleanupsClass:\n  case Expr::CXXTemporaryObjectExprClass:\n  case Expr::CXXUnresolvedConstructExprClass:\n  case Expr::CXXDependentScopeMemberExprClass:\n  case Expr::UnresolvedMemberExprClass:\n  case Expr::ObjCStringLiteralClass:\n  case Expr::ObjCBoxedExprClass:\n  case Expr::ObjCArrayLiteralClass:\n  case Expr::ObjCDictionaryLiteralClass:\n  case Expr::ObjCEncodeExprClass:\n  case Expr::ObjCMessageExprClass:\n  case Expr::ObjCSelectorExprClass:\n  case Expr::ObjCProtocolExprClass:\n  case Expr::ObjCIvarRefExprClass:\n  case Expr::ObjCPropertyRefExprClass:\n  case Expr::ObjCSubscriptRefExprClass:\n  case Expr::ObjCIsaExprClass:\n  case Expr::ObjCAvailabilityCheckExprClass:\n  case Expr::ShuffleVectorExprClass:\n  case Expr::ConvertVectorExprClass:\n  case Expr::BlockExprClass:\n  case Expr::NoStmtClass:\n  case Expr::OpaqueValueExprClass:\n  case Expr::PackExpansionExprClass:\n  case Expr::SubstNonTypeTemplateParmPackExprClass:\n  case Expr::FunctionParmPackExprClass:\n  case Expr::AsTypeExprClass:\n  case Expr::ObjCIndirectCopyRestoreExprClass:\n  case Expr::MaterializeTemporaryExprClass:\n  case Expr::PseudoObjectExprClass:\n  case Expr::AtomicExprClass:\n  case Expr::LambdaExprClass:\n  case Expr::CXXFoldExprClass:\n  case Expr::CoawaitExprClass:\n  case Expr::DependentCoawaitExprClass:\n  case Expr::CoyieldExprClass:\n    return ICEDiag(IK_NotICE, E->getBeginLoc());\n\n  case Expr::InitListExprClass: {\n    // C++03 [dcl.init]p13: If T is a scalar type, then a declaration of the\n    // form \"T x = { a };\" is equivalent to \"T x = a;\".\n    // Unless we're initializing a reference, T is a scalar as it is known to be\n    // of integral or enumeration type.\n    if (E->isRValue())\n      if (cast<InitListExpr>(E)->getNumInits() == 1)\n        return CheckICE(cast<InitListExpr>(E)->getInit(0), Ctx);\n    return ICEDiag(IK_NotICE, E->getBeginLoc());\n  }\n\n  case Expr::SizeOfPackExprClass:\n  case Expr::GNUNullExprClass:\n  case Expr::SourceLocExprClass:\n    return NoDiag();\n\n  case Expr::SubstNonTypeTemplateParmExprClass:\n    return\n      CheckICE(cast<SubstNonTypeTemplateParmExpr>(E)->getReplacement(), Ctx);\n\n  case Expr::ConstantExprClass:\n    return CheckICE(cast<ConstantExpr>(E)->getSubExpr(), Ctx);\n\n  case Expr::ParenExprClass:\n    return CheckICE(cast<ParenExpr>(E)->getSubExpr(), Ctx);\n  case Expr::GenericSelectionExprClass:\n    return CheckICE(cast<GenericSelectionExpr>(E)->getResultExpr(), Ctx);\n  case Expr::IntegerLiteralClass:\n  case Expr::FixedPointLiteralClass:\n  case Expr::CharacterLiteralClass:\n  case Expr::ObjCBoolLiteralExprClass:\n  case Expr::CXXBoolLiteralExprClass:\n  case Expr::CXXScalarValueInitExprClass:\n  case Expr::TypeTraitExprClass:\n  case Expr::ConceptSpecializationExprClass:\n  case Expr::RequiresExprClass:\n  case Expr::ArrayTypeTraitExprClass:\n  case Expr::ExpressionTraitExprClass:\n  case Expr::CXXNoexceptExprClass:\n    return NoDiag();\n  case Expr::CallExprClass:\n  case Expr::CXXOperatorCallExprClass: {\n    // C99 6.6/3 allows function calls within unevaluated subexpressions of\n    // constant expressions, but they can never be ICEs because an ICE cannot\n    // contain an operand of (pointer to) function type.\n    const CallExpr *CE = cast<CallExpr>(E);\n    if (CE->getBuiltinCallee())\n      return CheckEvalInICE(E, Ctx);\n    return ICEDiag(IK_NotICE, E->getBeginLoc());\n  }\n  case Expr::CXXRewrittenBinaryOperatorClass:\n    return CheckICE(cast<CXXRewrittenBinaryOperator>(E)->getSemanticForm(),\n                    Ctx);\n  case Expr::DeclRefExprClass: {\n    const NamedDecl *D = cast<DeclRefExpr>(E)->getDecl();\n    if (isa<EnumConstantDecl>(D))\n      return NoDiag();\n\n    // C++ and OpenCL (FIXME: spec reference?) allow reading const-qualified\n    // integer variables in constant expressions:\n    //\n    // C++ 7.1.5.1p2\n    //   A variable of non-volatile const-qualified integral or enumeration\n    //   type initialized by an ICE can be used in ICEs.\n    //\n    // We sometimes use CheckICE to check the C++98 rules in C++11 mode. In\n    // that mode, use of reference variables should not be allowed.\n    const VarDecl *VD = dyn_cast<VarDecl>(D);\n    if (VD && VD->isUsableInConstantExpressions(Ctx) &&\n        !VD->getType()->isReferenceType())\n      return NoDiag();\n\n    return ICEDiag(IK_NotICE, E->getBeginLoc());\n  }\n  case Expr::UnaryOperatorClass: {\n    const UnaryOperator *Exp = cast<UnaryOperator>(E);\n    switch (Exp->getOpcode()) {\n    case UO_PostInc:\n    case UO_PostDec:\n    case UO_PreInc:\n    case UO_PreDec:\n    case UO_AddrOf:\n    case UO_Deref:\n    case UO_Coawait:\n      // C99 6.6/3 allows increment and decrement within unevaluated\n      // subexpressions of constant expressions, but they can never be ICEs\n      // because an ICE cannot contain an lvalue operand.\n      return ICEDiag(IK_NotICE, E->getBeginLoc());\n    case UO_Extension:\n    case UO_LNot:\n    case UO_Plus:\n    case UO_Minus:\n    case UO_Not:\n    case UO_Real:\n    case UO_Imag:\n      return CheckICE(Exp->getSubExpr(), Ctx);\n    }\n    llvm_unreachable(\"invalid unary operator class\");\n  }\n  case Expr::OffsetOfExprClass: {\n    // Note that per C99, offsetof must be an ICE. And AFAIK, using\n    // EvaluateAsRValue matches the proposed gcc behavior for cases like\n    // \"offsetof(struct s{int x[4];}, x[1.0])\".  This doesn't affect\n    // compliance: we should warn earlier for offsetof expressions with\n    // array subscripts that aren't ICEs, and if the array subscripts\n    // are ICEs, the value of the offsetof must be an integer constant.\n    return CheckEvalInICE(E, Ctx);\n  }\n  case Expr::UnaryExprOrTypeTraitExprClass: {\n    const UnaryExprOrTypeTraitExpr *Exp = cast<UnaryExprOrTypeTraitExpr>(E);\n    if ((Exp->getKind() ==  UETT_SizeOf) &&\n        Exp->getTypeOfArgument()->isVariableArrayType())\n      return ICEDiag(IK_NotICE, E->getBeginLoc());\n    return NoDiag();\n  }\n  case Expr::BinaryOperatorClass: {\n    const BinaryOperator *Exp = cast<BinaryOperator>(E);\n    switch (Exp->getOpcode()) {\n    case BO_PtrMemD:\n    case BO_PtrMemI:\n    case BO_Assign:\n    case BO_MulAssign:\n    case BO_DivAssign:\n    case BO_RemAssign:\n    case BO_AddAssign:\n    case BO_SubAssign:\n    case BO_ShlAssign:\n    case BO_ShrAssign:\n    case BO_AndAssign:\n    case BO_XorAssign:\n    case BO_OrAssign:\n      // C99 6.6/3 allows assignments within unevaluated subexpressions of\n      // constant expressions, but they can never be ICEs because an ICE cannot\n      // contain an lvalue operand.\n      return ICEDiag(IK_NotICE, E->getBeginLoc());\n\n    case BO_Mul:\n    case BO_Div:\n    case BO_Rem:\n    case BO_Add:\n    case BO_Sub:\n    case BO_Shl:\n    case BO_Shr:\n    case BO_LT:\n    case BO_GT:\n    case BO_LE:\n    case BO_GE:\n    case BO_EQ:\n    case BO_NE:\n    case BO_And:\n    case BO_Xor:\n    case BO_Or:\n    case BO_Comma:\n    case BO_Cmp: {\n      ICEDiag LHSResult = CheckICE(Exp->getLHS(), Ctx);\n      ICEDiag RHSResult = CheckICE(Exp->getRHS(), Ctx);\n      if (Exp->getOpcode() == BO_Div ||\n          Exp->getOpcode() == BO_Rem) {\n        // EvaluateAsRValue gives an error for undefined Div/Rem, so make sure\n        // we don't evaluate one.\n        if (LHSResult.Kind == IK_ICE && RHSResult.Kind == IK_ICE) {\n          llvm::APSInt REval = Exp->getRHS()->EvaluateKnownConstInt(Ctx);\n          if (REval == 0)\n            return ICEDiag(IK_ICEIfUnevaluated, E->getBeginLoc());\n          if (REval.isSigned() && REval.isAllOnesValue()) {\n            llvm::APSInt LEval = Exp->getLHS()->EvaluateKnownConstInt(Ctx);\n            if (LEval.isMinSignedValue())\n              return ICEDiag(IK_ICEIfUnevaluated, E->getBeginLoc());\n          }\n        }\n      }\n      if (Exp->getOpcode() == BO_Comma) {\n        if (Ctx.getLangOpts().C99) {\n          // C99 6.6p3 introduces a strange edge case: comma can be in an ICE\n          // if it isn't evaluated.\n          if (LHSResult.Kind == IK_ICE && RHSResult.Kind == IK_ICE)\n            return ICEDiag(IK_ICEIfUnevaluated, E->getBeginLoc());\n        } else {\n          // In both C89 and C++, commas in ICEs are illegal.\n          return ICEDiag(IK_NotICE, E->getBeginLoc());\n        }\n      }\n      return Worst(LHSResult, RHSResult);\n    }\n    case BO_LAnd:\n    case BO_LOr: {\n      ICEDiag LHSResult = CheckICE(Exp->getLHS(), Ctx);\n      ICEDiag RHSResult = CheckICE(Exp->getRHS(), Ctx);\n      if (LHSResult.Kind == IK_ICE && RHSResult.Kind == IK_ICEIfUnevaluated) {\n        // Rare case where the RHS has a comma \"side-effect\"; we need\n        // to actually check the condition to see whether the side\n        // with the comma is evaluated.\n        if ((Exp->getOpcode() == BO_LAnd) !=\n            (Exp->getLHS()->EvaluateKnownConstInt(Ctx) == 0))\n          return RHSResult;\n        return NoDiag();\n      }\n\n      return Worst(LHSResult, RHSResult);\n    }\n    }\n    llvm_unreachable(\"invalid binary operator kind\");\n  }\n  case Expr::ImplicitCastExprClass:\n  case Expr::CStyleCastExprClass:\n  case Expr::CXXFunctionalCastExprClass:\n  case Expr::CXXStaticCastExprClass:\n  case Expr::CXXReinterpretCastExprClass:\n  case Expr::CXXConstCastExprClass:\n  case Expr::ObjCBridgedCastExprClass: {\n    const Expr *SubExpr = cast<CastExpr>(E)->getSubExpr();\n    if (isa<ExplicitCastExpr>(E)) {\n      if (const FloatingLiteral *FL\n            = dyn_cast<FloatingLiteral>(SubExpr->IgnoreParenImpCasts())) {\n        unsigned DestWidth = Ctx.getIntWidth(E->getType());\n        bool DestSigned = E->getType()->isSignedIntegerOrEnumerationType();\n        APSInt IgnoredVal(DestWidth, !DestSigned);\n        bool Ignored;\n        // If the value does not fit in the destination type, the behavior is\n        // undefined, so we are not required to treat it as a constant\n        // expression.\n        if (FL->getValue().convertToInteger(IgnoredVal,\n                                            llvm::APFloat::rmTowardZero,\n                                            &Ignored) & APFloat::opInvalidOp)\n          return ICEDiag(IK_NotICE, E->getBeginLoc());\n        return NoDiag();\n      }\n    }\n    switch (cast<CastExpr>(E)->getCastKind()) {\n    case CK_LValueToRValue:\n    case CK_AtomicToNonAtomic:\n    case CK_NonAtomicToAtomic:\n    case CK_NoOp:\n    case CK_IntegralToBoolean:\n    case CK_IntegralCast:\n      return CheckICE(SubExpr, Ctx);\n    default:\n      return ICEDiag(IK_NotICE, E->getBeginLoc());\n    }\n  }\n  case Expr::BinaryConditionalOperatorClass: {\n    const BinaryConditionalOperator *Exp = cast<BinaryConditionalOperator>(E);\n    ICEDiag CommonResult = CheckICE(Exp->getCommon(), Ctx);\n    if (CommonResult.Kind == IK_NotICE) return CommonResult;\n    ICEDiag FalseResult = CheckICE(Exp->getFalseExpr(), Ctx);\n    if (FalseResult.Kind == IK_NotICE) return FalseResult;\n    if (CommonResult.Kind == IK_ICEIfUnevaluated) return CommonResult;\n    if (FalseResult.Kind == IK_ICEIfUnevaluated &&\n        Exp->getCommon()->EvaluateKnownConstInt(Ctx) != 0) return NoDiag();\n    return FalseResult;\n  }\n  case Expr::ConditionalOperatorClass: {\n    const ConditionalOperator *Exp = cast<ConditionalOperator>(E);\n    // If the condition (ignoring parens) is a __builtin_constant_p call,\n    // then only the true side is actually considered in an integer constant\n    // expression, and it is fully evaluated.  This is an important GNU\n    // extension.  See GCC PR38377 for discussion.\n    if (const CallExpr *CallCE\n        = dyn_cast<CallExpr>(Exp->getCond()->IgnoreParenCasts()))\n      if (CallCE->getBuiltinCallee() == Builtin::BI__builtin_constant_p)\n        return CheckEvalInICE(E, Ctx);\n    ICEDiag CondResult = CheckICE(Exp->getCond(), Ctx);\n    if (CondResult.Kind == IK_NotICE)\n      return CondResult;\n\n    ICEDiag TrueResult = CheckICE(Exp->getTrueExpr(), Ctx);\n    ICEDiag FalseResult = CheckICE(Exp->getFalseExpr(), Ctx);\n\n    if (TrueResult.Kind == IK_NotICE)\n      return TrueResult;\n    if (FalseResult.Kind == IK_NotICE)\n      return FalseResult;\n    if (CondResult.Kind == IK_ICEIfUnevaluated)\n      return CondResult;\n    if (TrueResult.Kind == IK_ICE && FalseResult.Kind == IK_ICE)\n      return NoDiag();\n    // Rare case where the diagnostics depend on which side is evaluated\n    // Note that if we get here, CondResult is 0, and at least one of\n    // TrueResult and FalseResult is non-zero.\n    if (Exp->getCond()->EvaluateKnownConstInt(Ctx) == 0)\n      return FalseResult;\n    return TrueResult;\n  }\n  case Expr::CXXDefaultArgExprClass:\n    return CheckICE(cast<CXXDefaultArgExpr>(E)->getExpr(), Ctx);\n  case Expr::CXXDefaultInitExprClass:\n    return CheckICE(cast<CXXDefaultInitExpr>(E)->getExpr(), Ctx);\n  case Expr::ChooseExprClass: {\n    return CheckICE(cast<ChooseExpr>(E)->getChosenSubExpr(), Ctx);\n  }\n  case Expr::BuiltinBitCastExprClass: {\n    if (!checkBitCastConstexprEligibility(nullptr, Ctx, cast<CastExpr>(E)))\n      return ICEDiag(IK_NotICE, E->getBeginLoc());\n    return CheckICE(cast<CastExpr>(E)->getSubExpr(), Ctx);\n  }\n  }\n\n  llvm_unreachable(\"Invalid StmtClass!\");\n}\n\n/// Evaluate an expression as a C++11 integral constant expression.\nstatic bool EvaluateCPlusPlus11IntegralConstantExpr(const ASTContext &Ctx,\n                                                    const Expr *E,\n                                                    llvm::APSInt *Value,\n                                                    SourceLocation *Loc) {\n  if (!E->getType()->isIntegralOrUnscopedEnumerationType()) {\n    if (Loc) *Loc = E->getExprLoc();\n    return false;\n  }\n\n  APValue Result;\n  if (!E->isCXX11ConstantExpr(Ctx, &Result, Loc))\n    return false;\n\n  if (!Result.isInt()) {\n    if (Loc) *Loc = E->getExprLoc();\n    return false;\n  }\n\n  if (Value) *Value = Result.getInt();\n  return true;\n}\n\nbool Expr::isIntegerConstantExpr(const ASTContext &Ctx,\n                                 SourceLocation *Loc) const {\n  assert(!isValueDependent() &&\n         \"Expression evaluator can't be called on a dependent expression.\");\n\n  if (Ctx.getLangOpts().CPlusPlus11)\n    return EvaluateCPlusPlus11IntegralConstantExpr(Ctx, this, nullptr, Loc);\n\n  ICEDiag D = CheckICE(this, Ctx);\n  if (D.Kind != IK_ICE) {\n    if (Loc) *Loc = D.Loc;\n    return false;\n  }\n  return true;\n}\n\nOptional<llvm::APSInt> Expr::getIntegerConstantExpr(const ASTContext &Ctx,\n                                                    SourceLocation *Loc,\n                                                    bool isEvaluated) const {\n  assert(!isValueDependent() &&\n         \"Expression evaluator can't be called on a dependent expression.\");\n\n  APSInt Value;\n\n  if (Ctx.getLangOpts().CPlusPlus11) {\n    if (EvaluateCPlusPlus11IntegralConstantExpr(Ctx, this, &Value, Loc))\n      return Value;\n    return None;\n  }\n\n  if (!isIntegerConstantExpr(Ctx, Loc))\n    return None;\n\n  // The only possible side-effects here are due to UB discovered in the\n  // evaluation (for instance, INT_MAX + 1). In such a case, we are still\n  // required to treat the expression as an ICE, so we produce the folded\n  // value.\n  EvalResult ExprResult;\n  Expr::EvalStatus Status;\n  EvalInfo Info(Ctx, Status, EvalInfo::EM_IgnoreSideEffects);\n  Info.InConstantContext = true;\n\n  if (!::EvaluateAsInt(this, ExprResult, Ctx, SE_AllowSideEffects, Info))\n    llvm_unreachable(\"ICE cannot be evaluated!\");\n\n  return ExprResult.Val.getInt();\n}\n\nbool Expr::isCXX98IntegralConstantExpr(const ASTContext &Ctx) const {\n  assert(!isValueDependent() &&\n         \"Expression evaluator can't be called on a dependent expression.\");\n\n  return CheckICE(this, Ctx).Kind == IK_ICE;\n}\n\nbool Expr::isCXX11ConstantExpr(const ASTContext &Ctx, APValue *Result,\n                               SourceLocation *Loc) const {\n  assert(!isValueDependent() &&\n         \"Expression evaluator can't be called on a dependent expression.\");\n\n  // We support this checking in C++98 mode in order to diagnose compatibility\n  // issues.\n  assert(Ctx.getLangOpts().CPlusPlus);\n\n  // Build evaluation settings.\n  Expr::EvalStatus Status;\n  SmallVector<PartialDiagnosticAt, 8> Diags;\n  Status.Diag = &Diags;\n  EvalInfo Info(Ctx, Status, EvalInfo::EM_ConstantExpression);\n\n  APValue Scratch;\n  bool IsConstExpr =\n      ::EvaluateAsRValue(Info, this, Result ? *Result : Scratch) &&\n      // FIXME: We don't produce a diagnostic for this, but the callers that\n      // call us on arbitrary full-expressions should generally not care.\n      Info.discardCleanups() && !Status.HasSideEffects;\n\n  if (!Diags.empty()) {\n    IsConstExpr = false;\n    if (Loc) *Loc = Diags[0].first;\n  } else if (!IsConstExpr) {\n    // FIXME: This shouldn't happen.\n    if (Loc) *Loc = getExprLoc();\n  }\n\n  return IsConstExpr;\n}\n\nbool Expr::EvaluateWithSubstitution(APValue &Value, ASTContext &Ctx,\n                                    const FunctionDecl *Callee,\n                                    ArrayRef<const Expr*> Args,\n                                    const Expr *This) const {\n  assert(!isValueDependent() &&\n         \"Expression evaluator can't be called on a dependent expression.\");\n\n  Expr::EvalStatus Status;\n  EvalInfo Info(Ctx, Status, EvalInfo::EM_ConstantExpressionUnevaluated);\n  Info.InConstantContext = true;\n\n  LValue ThisVal;\n  const LValue *ThisPtr = nullptr;\n  if (This) {\n#ifndef NDEBUG\n    auto *MD = dyn_cast<CXXMethodDecl>(Callee);\n    assert(MD && \"Don't provide `this` for non-methods.\");\n    assert(!MD->isStatic() && \"Don't provide `this` for static methods.\");\n#endif\n    if (!This->isValueDependent() &&\n        EvaluateObjectArgument(Info, This, ThisVal) &&\n        !Info.EvalStatus.HasSideEffects)\n      ThisPtr = &ThisVal;\n\n    // Ignore any side-effects from a failed evaluation. This is safe because\n    // they can't interfere with any other argument evaluation.\n    Info.EvalStatus.HasSideEffects = false;\n  }\n\n  CallRef Call = Info.CurrentCall->createCall(Callee);\n  for (ArrayRef<const Expr*>::iterator I = Args.begin(), E = Args.end();\n       I != E; ++I) {\n    unsigned Idx = I - Args.begin();\n    if (Idx >= Callee->getNumParams())\n      break;\n    const ParmVarDecl *PVD = Callee->getParamDecl(Idx);\n    if ((*I)->isValueDependent() ||\n        !EvaluateCallArg(PVD, *I, Call, Info) ||\n        Info.EvalStatus.HasSideEffects) {\n      // If evaluation fails, throw away the argument entirely.\n      if (APValue *Slot = Info.getParamSlot(Call, PVD))\n        *Slot = APValue();\n    }\n\n    // Ignore any side-effects from a failed evaluation. This is safe because\n    // they can't interfere with any other argument evaluation.\n    Info.EvalStatus.HasSideEffects = false;\n  }\n\n  // Parameter cleanups happen in the caller and are not part of this\n  // evaluation.\n  Info.discardCleanups();\n  Info.EvalStatus.HasSideEffects = false;\n\n  // Build fake call to Callee.\n  CallStackFrame Frame(Info, Callee->getLocation(), Callee, ThisPtr, Call);\n  // FIXME: Missing ExprWithCleanups in enable_if conditions?\n  FullExpressionRAII Scope(Info);\n  return Evaluate(Value, Info, this) && Scope.destroy() &&\n         !Info.EvalStatus.HasSideEffects;\n}\n\nbool Expr::isPotentialConstantExpr(const FunctionDecl *FD,\n                                   SmallVectorImpl<\n                                     PartialDiagnosticAt> &Diags) {\n  // FIXME: It would be useful to check constexpr function templates, but at the\n  // moment the constant expression evaluator cannot cope with the non-rigorous\n  // ASTs which we build for dependent expressions.\n  if (FD->isDependentContext())\n    return true;\n\n  Expr::EvalStatus Status;\n  Status.Diag = &Diags;\n\n  EvalInfo Info(FD->getASTContext(), Status, EvalInfo::EM_ConstantExpression);\n  Info.InConstantContext = true;\n  Info.CheckingPotentialConstantExpression = true;\n\n  // The constexpr VM attempts to compile all methods to bytecode here.\n  if (Info.EnableNewConstInterp) {\n    Info.Ctx.getInterpContext().isPotentialConstantExpr(Info, FD);\n    return Diags.empty();\n  }\n\n  const CXXMethodDecl *MD = dyn_cast<CXXMethodDecl>(FD);\n  const CXXRecordDecl *RD = MD ? MD->getParent()->getCanonicalDecl() : nullptr;\n\n  // Fabricate an arbitrary expression on the stack and pretend that it\n  // is a temporary being used as the 'this' pointer.\n  LValue This;\n  ImplicitValueInitExpr VIE(RD ? Info.Ctx.getRecordType(RD) : Info.Ctx.IntTy);\n  This.set({&VIE, Info.CurrentCall->Index});\n\n  ArrayRef<const Expr*> Args;\n\n  APValue Scratch;\n  if (const CXXConstructorDecl *CD = dyn_cast<CXXConstructorDecl>(FD)) {\n    // Evaluate the call as a constant initializer, to allow the construction\n    // of objects of non-literal types.\n    Info.setEvaluatingDecl(This.getLValueBase(), Scratch);\n    HandleConstructorCall(&VIE, This, Args, CD, Info, Scratch);\n  } else {\n    SourceLocation Loc = FD->getLocation();\n    HandleFunctionCall(Loc, FD, (MD && MD->isInstance()) ? &This : nullptr,\n                       Args, CallRef(), FD->getBody(), Info, Scratch, nullptr);\n  }\n\n  return Diags.empty();\n}\n\nbool Expr::isPotentialConstantExprUnevaluated(Expr *E,\n                                              const FunctionDecl *FD,\n                                              SmallVectorImpl<\n                                                PartialDiagnosticAt> &Diags) {\n  assert(!E->isValueDependent() &&\n         \"Expression evaluator can't be called on a dependent expression.\");\n\n  Expr::EvalStatus Status;\n  Status.Diag = &Diags;\n\n  EvalInfo Info(FD->getASTContext(), Status,\n                EvalInfo::EM_ConstantExpressionUnevaluated);\n  Info.InConstantContext = true;\n  Info.CheckingPotentialConstantExpression = true;\n\n  // Fabricate a call stack frame to give the arguments a plausible cover story.\n  CallStackFrame Frame(Info, SourceLocation(), FD, /*This*/ nullptr, CallRef());\n\n  APValue ResultScratch;\n  Evaluate(ResultScratch, Info, E);\n  return Diags.empty();\n}\n\nbool Expr::tryEvaluateObjectSize(uint64_t &Result, ASTContext &Ctx,\n                                 unsigned Type) const {\n  if (!getType()->isPointerType())\n    return false;\n\n  Expr::EvalStatus Status;\n  EvalInfo Info(Ctx, Status, EvalInfo::EM_ConstantFold);\n  return tryEvaluateBuiltinObjectSize(this, Type, Info, Result);\n}\n"}}, "reports": [{"events": [{"location": {"col": 17, "file": 18, "line": 707}, "message": "mark 'noexcept'"}, {"location": {"col": 17, "file": 18, "line": 707}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/AST/ExprConstant.cpp", "reportHash": "88499e3fa61324f01aeeb8518f8fdac7", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 59, "file": 18, "line": 707}, "message": "'LHS' of type '(anonymous namespace)::ObjectUnderConstruction' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/AST/ExprConstant.cpp", "reportHash": "c8174aff26e54280035039d7b6c57e50", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 59, "file": 18, "line": 708}, "message": "'RHS' of type '(anonymous namespace)::ObjectUnderConstruction' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/AST/ExprConstant.cpp", "reportHash": "8121e0c735aa7ea9ad92ea62e11bb41e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 18, "line": 1798}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 18, "line": 1798}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/AST/ExprConstant.cpp", "reportHash": "32a740c599d13bb9b8d738a377787017", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 43, "file": 18, "line": 1798}, "message": "'LHS' of type '(anonymous namespace)::MemberPtr' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/AST/ExprConstant.cpp", "reportHash": "c2562c88e89372cee1c752aadb6eafff", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 65, "file": 18, "line": 1798}, "message": "'RHS' of type '(anonymous namespace)::MemberPtr' is cheap to copy, should be passed by value"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/AST/ExprConstant.cpp", "reportHash": "11d7ae830f146d9f97273ffe9ed5f9a7", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
