<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"62": {"id": 62, "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp", "content": "//===- AttributorAttributes.cpp - Attributes for Attributor deduction -----===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// See the Attributor.h file comment and the class descriptions in that file for\n// more information.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/Transforms/IPO/Attributor.h\"\n\n#include \"llvm/ADT/SCCIterator.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/Statistic.h\"\n#include \"llvm/Analysis/AliasAnalysis.h\"\n#include \"llvm/Analysis/AssumeBundleQueries.h\"\n#include \"llvm/Analysis/AssumptionCache.h\"\n#include \"llvm/Analysis/CaptureTracking.h\"\n#include \"llvm/Analysis/LazyValueInfo.h\"\n#include \"llvm/Analysis/MemoryBuiltins.h\"\n#include \"llvm/Analysis/ScalarEvolution.h\"\n#include \"llvm/Analysis/TargetTransformInfo.h\"\n#include \"llvm/Analysis/ValueTracking.h\"\n#include \"llvm/IR/IRBuilder.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/IntrinsicInst.h\"\n#include \"llvm/IR/NoFolder.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Transforms/IPO/ArgumentPromotion.h\"\n#include \"llvm/Transforms/Utils/Local.h\"\n\n#include <cassert>\n\nusing namespace llvm;\n\n#define DEBUG_TYPE \"attributor\"\n\nstatic cl::opt<bool> ManifestInternal(\n    \"attributor-manifest-internal\", cl::Hidden,\n    cl::desc(\"Manifest Attributor internal string attributes.\"),\n    cl::init(false));\n\nstatic cl::opt<int> MaxHeapToStackSize(\"max-heap-to-stack-size\", cl::init(128),\n                                       cl::Hidden);\n\ntemplate <>\nunsigned llvm::PotentialConstantIntValuesState::MaxPotentialValues = 0;\n\nstatic cl::opt<unsigned, true> MaxPotentialValues(\n    \"attributor-max-potential-values\", cl::Hidden,\n    cl::desc(\"Maximum number of potential values to be \"\n             \"tracked for each position.\"),\n    cl::location(llvm::PotentialConstantIntValuesState::MaxPotentialValues),\n    cl::init(7));\n\nSTATISTIC(NumAAs, \"Number of abstract attributes created\");\n\n// Some helper macros to deal with statistics tracking.\n//\n// Usage:\n// For simple IR attribute tracking overload trackStatistics in the abstract\n// attribute and choose the right STATS_DECLTRACK_********* macro,\n// e.g.,:\n//  void trackStatistics() const override {\n//    STATS_DECLTRACK_ARG_ATTR(returned)\n//  }\n// If there is a single \"increment\" side one can use the macro\n// STATS_DECLTRACK with a custom message. If there are multiple increment\n// sides, STATS_DECL and STATS_TRACK can also be used separately.\n//\n#define BUILD_STAT_MSG_IR_ATTR(TYPE, NAME)                                     \\\n  (\"Number of \" #TYPE \" marked '\" #NAME \"'\")\n#define BUILD_STAT_NAME(NAME, TYPE) NumIR##TYPE##_##NAME\n#define STATS_DECL_(NAME, MSG) STATISTIC(NAME, MSG);\n#define STATS_DECL(NAME, TYPE, MSG)                                            \\\n  STATS_DECL_(BUILD_STAT_NAME(NAME, TYPE), MSG);\n#define STATS_TRACK(NAME, TYPE) ++(BUILD_STAT_NAME(NAME, TYPE));\n#define STATS_DECLTRACK(NAME, TYPE, MSG)                                       \\\n  {                                                                            \\\n    STATS_DECL(NAME, TYPE, MSG)                                                \\\n    STATS_TRACK(NAME, TYPE)                                                    \\\n  }\n#define STATS_DECLTRACK_ARG_ATTR(NAME)                                         \\\n  STATS_DECLTRACK(NAME, Arguments, BUILD_STAT_MSG_IR_ATTR(arguments, NAME))\n#define STATS_DECLTRACK_CSARG_ATTR(NAME)                                       \\\n  STATS_DECLTRACK(NAME, CSArguments,                                           \\\n                  BUILD_STAT_MSG_IR_ATTR(call site arguments, NAME))\n#define STATS_DECLTRACK_FN_ATTR(NAME)                                          \\\n  STATS_DECLTRACK(NAME, Function, BUILD_STAT_MSG_IR_ATTR(functions, NAME))\n#define STATS_DECLTRACK_CS_ATTR(NAME)                                          \\\n  STATS_DECLTRACK(NAME, CS, BUILD_STAT_MSG_IR_ATTR(call site, NAME))\n#define STATS_DECLTRACK_FNRET_ATTR(NAME)                                       \\\n  STATS_DECLTRACK(NAME, FunctionReturn,                                        \\\n                  BUILD_STAT_MSG_IR_ATTR(function returns, NAME))\n#define STATS_DECLTRACK_CSRET_ATTR(NAME)                                       \\\n  STATS_DECLTRACK(NAME, CSReturn,                                              \\\n                  BUILD_STAT_MSG_IR_ATTR(call site returns, NAME))\n#define STATS_DECLTRACK_FLOATING_ATTR(NAME)                                    \\\n  STATS_DECLTRACK(NAME, Floating,                                              \\\n                  (\"Number of floating values known to be '\" #NAME \"'\"))\n\n// Specialization of the operator<< for abstract attributes subclasses. This\n// disambiguates situations where multiple operators are applicable.\nnamespace llvm {\n#define PIPE_OPERATOR(CLASS)                                                   \\\n  raw_ostream &operator<<(raw_ostream &OS, const CLASS &AA) {                  \\\n    return OS << static_cast<const AbstractAttribute &>(AA);                   \\\n  }\n\nPIPE_OPERATOR(AAIsDead)\nPIPE_OPERATOR(AANoUnwind)\nPIPE_OPERATOR(AANoSync)\nPIPE_OPERATOR(AANoRecurse)\nPIPE_OPERATOR(AAWillReturn)\nPIPE_OPERATOR(AANoReturn)\nPIPE_OPERATOR(AAReturnedValues)\nPIPE_OPERATOR(AANonNull)\nPIPE_OPERATOR(AANoAlias)\nPIPE_OPERATOR(AADereferenceable)\nPIPE_OPERATOR(AAAlign)\nPIPE_OPERATOR(AANoCapture)\nPIPE_OPERATOR(AAValueSimplify)\nPIPE_OPERATOR(AANoFree)\nPIPE_OPERATOR(AAHeapToStack)\nPIPE_OPERATOR(AAReachability)\nPIPE_OPERATOR(AAMemoryBehavior)\nPIPE_OPERATOR(AAMemoryLocation)\nPIPE_OPERATOR(AAValueConstantRange)\nPIPE_OPERATOR(AAPrivatizablePtr)\nPIPE_OPERATOR(AAUndefinedBehavior)\nPIPE_OPERATOR(AAPotentialValues)\nPIPE_OPERATOR(AANoUndef)\n\n#undef PIPE_OPERATOR\n} // namespace llvm\n\nnamespace {\n\nstatic Optional<ConstantInt *>\ngetAssumedConstantInt(Attributor &A, const Value &V,\n                      const AbstractAttribute &AA,\n                      bool &UsedAssumedInformation) {\n  Optional<Constant *> C = A.getAssumedConstant(V, AA, UsedAssumedInformation);\n  if (C.hasValue())\n    return dyn_cast_or_null<ConstantInt>(C.getValue());\n  return llvm::None;\n}\n\n/// Get pointer operand of memory accessing instruction. If \\p I is\n/// not a memory accessing instruction, return nullptr. If \\p AllowVolatile,\n/// is set to false and the instruction is volatile, return nullptr.\nstatic const Value *getPointerOperand(const Instruction *I,\n                                      bool AllowVolatile) {\n  if (auto *LI = dyn_cast<LoadInst>(I)) {\n    if (!AllowVolatile && LI->isVolatile())\n      return nullptr;\n    return LI->getPointerOperand();\n  }\n\n  if (auto *SI = dyn_cast<StoreInst>(I)) {\n    if (!AllowVolatile && SI->isVolatile())\n      return nullptr;\n    return SI->getPointerOperand();\n  }\n\n  if (auto *CXI = dyn_cast<AtomicCmpXchgInst>(I)) {\n    if (!AllowVolatile && CXI->isVolatile())\n      return nullptr;\n    return CXI->getPointerOperand();\n  }\n\n  if (auto *RMWI = dyn_cast<AtomicRMWInst>(I)) {\n    if (!AllowVolatile && RMWI->isVolatile())\n      return nullptr;\n    return RMWI->getPointerOperand();\n  }\n\n  return nullptr;\n}\n\n/// Helper function to create a pointer of type \\p ResTy, based on \\p Ptr, and\n/// advanced by \\p Offset bytes. To aid later analysis the method tries to build\n/// getelement pointer instructions that traverse the natural type of \\p Ptr if\n/// possible. If that fails, the remaining offset is adjusted byte-wise, hence\n/// through a cast to i8*.\n///\n/// TODO: This could probably live somewhere more prominantly if it doesn't\n///       already exist.\nstatic Value *constructPointer(Type *ResTy, Type *PtrElemTy, Value *Ptr,\n                               int64_t Offset, IRBuilder<NoFolder> &IRB,\n                               const DataLayout &DL) {\n  assert(Offset >= 0 && \"Negative offset not supported yet!\");\n  LLVM_DEBUG(dbgs() << \"Construct pointer: \" << *Ptr << \" + \" << Offset\n                    << \"-bytes as \" << *ResTy << \"\\n\");\n\n  if (Offset) {\n    SmallVector<Value *, 4> Indices;\n    std::string GEPName = Ptr->getName().str() + \".0\";\n\n    // Add 0 index to look through the pointer.\n    assert((uint64_t)Offset < DL.getTypeAllocSize(PtrElemTy) &&\n           \"Offset out of bounds\");\n    Indices.push_back(Constant::getNullValue(IRB.getInt32Ty()));\n\n    Type *Ty = PtrElemTy;\n    do {\n      auto *STy = dyn_cast<StructType>(Ty);\n      if (!STy)\n        // Non-aggregate type, we cast and make byte-wise progress now.\n        break;\n\n      const StructLayout *SL = DL.getStructLayout(STy);\n      if (int64_t(SL->getSizeInBytes()) < Offset)\n        break;\n\n      uint64_t Idx = SL->getElementContainingOffset(Offset);\n      assert(Idx < STy->getNumElements() && \"Offset calculation error!\");\n      uint64_t Rem = Offset - SL->getElementOffset(Idx);\n      Ty = STy->getElementType(Idx);\n\n      LLVM_DEBUG(errs() << \"Ty: \" << *Ty << \" Offset: \" << Offset\n                        << \" Idx: \" << Idx << \" Rem: \" << Rem << \"\\n\");\n\n      GEPName += \".\" + std::to_string(Idx);\n      Indices.push_back(ConstantInt::get(IRB.getInt32Ty(), Idx));\n      Offset = Rem;\n    } while (Offset);\n\n    // Create a GEP for the indices collected above.\n    Ptr = IRB.CreateGEP(PtrElemTy, Ptr, Indices, GEPName);\n\n    // If an offset is left we use byte-wise adjustment.\n    if (Offset) {\n      Ptr = IRB.CreateBitCast(Ptr, IRB.getInt8PtrTy());\n      Ptr = IRB.CreateGEP(IRB.getInt8Ty(), Ptr, IRB.getInt32(Offset),\n                          GEPName + \".b\" + Twine(Offset));\n    }\n  }\n\n  // Ensure the result has the requested type.\n  Ptr = IRB.CreateBitOrPointerCast(Ptr, ResTy, Ptr->getName() + \".cast\");\n\n  LLVM_DEBUG(dbgs() << \"Constructed pointer: \" << *Ptr << \"\\n\");\n  return Ptr;\n}\n\n/// Recursively visit all values that might become \\p IRP at some point. This\n/// will be done by looking through cast instructions, selects, phis, and calls\n/// with the \"returned\" attribute. Once we cannot look through the value any\n/// further, the callback \\p VisitValueCB is invoked and passed the current\n/// value, the \\p State, and a flag to indicate if we stripped anything.\n/// Stripped means that we unpacked the value associated with \\p IRP at least\n/// once. Note that the value used for the callback may still be the value\n/// associated with \\p IRP (due to PHIs). To limit how much effort is invested,\n/// we will never visit more values than specified by \\p MaxValues.\ntemplate <typename AAType, typename StateTy>\nstatic bool genericValueTraversal(\n    Attributor &A, IRPosition IRP, const AAType &QueryingAA, StateTy &State,\n    function_ref<bool(Value &, const Instruction *, StateTy &, bool)>\n        VisitValueCB,\n    const Instruction *CtxI, bool UseValueSimplify = true, int MaxValues = 16,\n    function_ref<Value *(Value *)> StripCB = nullptr) {\n\n  const AAIsDead *LivenessAA = nullptr;\n  if (IRP.getAnchorScope())\n    LivenessAA = &A.getAAFor<AAIsDead>(\n        QueryingAA, IRPosition::function(*IRP.getAnchorScope()),\n        DepClassTy::NONE);\n  bool AnyDead = false;\n\n  using Item = std::pair<Value *, const Instruction *>;\n  SmallSet<Item, 16> Visited;\n  SmallVector<Item, 16> Worklist;\n  Worklist.push_back({&IRP.getAssociatedValue(), CtxI});\n\n  int Iteration = 0;\n  do {\n    Item I = Worklist.pop_back_val();\n    Value *V = I.first;\n    CtxI = I.second;\n    if (StripCB)\n      V = StripCB(V);\n\n    // Check if we should process the current value. To prevent endless\n    // recursion keep a record of the values we followed!\n    if (!Visited.insert(I).second)\n      continue;\n\n    // Make sure we limit the compile time for complex expressions.\n    if (Iteration++ >= MaxValues)\n      return false;\n\n    // Explicitly look through calls with a \"returned\" attribute if we do\n    // not have a pointer as stripPointerCasts only works on them.\n    Value *NewV = nullptr;\n    if (V->getType()->isPointerTy()) {\n      NewV = V->stripPointerCasts();\n    } else {\n      auto *CB = dyn_cast<CallBase>(V);\n      if (CB && CB->getCalledFunction()) {\n        for (Argument &Arg : CB->getCalledFunction()->args())\n          if (Arg.hasReturnedAttr()) {\n            NewV = CB->getArgOperand(Arg.getArgNo());\n            break;\n          }\n      }\n    }\n    if (NewV && NewV != V) {\n      Worklist.push_back({NewV, CtxI});\n      continue;\n    }\n\n    // Look through select instructions, visit both potential values.\n    if (auto *SI = dyn_cast<SelectInst>(V)) {\n      Worklist.push_back({SI->getTrueValue(), CtxI});\n      Worklist.push_back({SI->getFalseValue(), CtxI});\n      continue;\n    }\n\n    // Look through phi nodes, visit all live operands.\n    if (auto *PHI = dyn_cast<PHINode>(V)) {\n      assert(LivenessAA &&\n             \"Expected liveness in the presence of instructions!\");\n      for (unsigned u = 0, e = PHI->getNumIncomingValues(); u < e; u++) {\n        BasicBlock *IncomingBB = PHI->getIncomingBlock(u);\n        if (A.isAssumedDead(*IncomingBB->getTerminator(), &QueryingAA,\n                            LivenessAA,\n                            /* CheckBBLivenessOnly */ true)) {\n          AnyDead = true;\n          continue;\n        }\n        Worklist.push_back(\n            {PHI->getIncomingValue(u), IncomingBB->getTerminator()});\n      }\n      continue;\n    }\n\n    if (UseValueSimplify && !isa<Constant>(V)) {\n      bool UsedAssumedInformation = false;\n      Optional<Constant *> C =\n          A.getAssumedConstant(*V, QueryingAA, UsedAssumedInformation);\n      if (!C.hasValue())\n        continue;\n      if (Value *NewV = C.getValue()) {\n        Worklist.push_back({NewV, CtxI});\n        continue;\n      }\n    }\n\n    // Once a leaf is reached we inform the user through the callback.\n    if (!VisitValueCB(*V, CtxI, State, Iteration > 1))\n      return false;\n  } while (!Worklist.empty());\n\n  // If we actually used liveness information so we have to record a dependence.\n  if (AnyDead)\n    A.recordDependence(*LivenessAA, QueryingAA, DepClassTy::OPTIONAL);\n\n  // All values have been visited.\n  return true;\n}\n\nconst Value *stripAndAccumulateMinimalOffsets(\n    Attributor &A, const AbstractAttribute &QueryingAA, const Value *Val,\n    const DataLayout &DL, APInt &Offset, bool AllowNonInbounds,\n    bool UseAssumed = false) {\n\n  auto AttributorAnalysis = [&](Value &V, APInt &ROffset) -> bool {\n    const IRPosition &Pos = IRPosition::value(V);\n    // Only track dependence if we are going to use the assumed info.\n    const AAValueConstantRange &ValueConstantRangeAA =\n        A.getAAFor<AAValueConstantRange>(QueryingAA, Pos,\n                                         UseAssumed ? DepClassTy::OPTIONAL\n                                                    : DepClassTy::NONE);\n    ConstantRange Range = UseAssumed ? ValueConstantRangeAA.getAssumed()\n                                     : ValueConstantRangeAA.getKnown();\n    // We can only use the lower part of the range because the upper part can\n    // be higher than what the value can really be.\n    ROffset = Range.getSignedMin();\n    return true;\n  };\n\n  return Val->stripAndAccumulateConstantOffsets(DL, Offset, AllowNonInbounds,\n                                                AttributorAnalysis);\n}\n\nstatic const Value *getMinimalBaseOfAccsesPointerOperand(\n    Attributor &A, const AbstractAttribute &QueryingAA, const Instruction *I,\n    int64_t &BytesOffset, const DataLayout &DL, bool AllowNonInbounds = false) {\n  const Value *Ptr = getPointerOperand(I, /* AllowVolatile */ false);\n  if (!Ptr)\n    return nullptr;\n  APInt OffsetAPInt(DL.getIndexTypeSizeInBits(Ptr->getType()), 0);\n  const Value *Base = stripAndAccumulateMinimalOffsets(\n      A, QueryingAA, Ptr, DL, OffsetAPInt, AllowNonInbounds);\n\n  BytesOffset = OffsetAPInt.getSExtValue();\n  return Base;\n}\n\nstatic const Value *\ngetBasePointerOfAccessPointerOperand(const Instruction *I, int64_t &BytesOffset,\n                                     const DataLayout &DL,\n                                     bool AllowNonInbounds = false) {\n  const Value *Ptr = getPointerOperand(I, /* AllowVolatile */ false);\n  if (!Ptr)\n    return nullptr;\n\n  return GetPointerBaseWithConstantOffset(Ptr, BytesOffset, DL,\n                                          AllowNonInbounds);\n}\n\n/// Helper function to clamp a state \\p S of type \\p StateType with the\n/// information in \\p R and indicate/return if \\p S did change (as-in update is\n/// required to be run again).\ntemplate <typename StateType>\nChangeStatus clampStateAndIndicateChange(StateType &S, const StateType &R) {\n  auto Assumed = S.getAssumed();\n  S ^= R;\n  return Assumed == S.getAssumed() ? ChangeStatus::UNCHANGED\n                                   : ChangeStatus::CHANGED;\n}\n\n/// Clamp the information known for all returned values of a function\n/// (identified by \\p QueryingAA) into \\p S.\ntemplate <typename AAType, typename StateType = typename AAType::StateType>\nstatic void clampReturnedValueStates(\n    Attributor &A, const AAType &QueryingAA, StateType &S,\n    const IRPosition::CallBaseContext *CBContext = nullptr) {\n  LLVM_DEBUG(dbgs() << \"[Attributor] Clamp return value states for \"\n                    << QueryingAA << \" into \" << S << \"\\n\");\n\n  assert((QueryingAA.getIRPosition().getPositionKind() ==\n              IRPosition::IRP_RETURNED ||\n          QueryingAA.getIRPosition().getPositionKind() ==\n              IRPosition::IRP_CALL_SITE_RETURNED) &&\n         \"Can only clamp returned value states for a function returned or call \"\n         \"site returned position!\");\n\n  // Use an optional state as there might not be any return values and we want\n  // to join (IntegerState::operator&) the state of all there are.\n  Optional<StateType> T;\n\n  // Callback for each possibly returned value.\n  auto CheckReturnValue = [&](Value &RV) -> bool {\n    const IRPosition &RVPos = IRPosition::value(RV, CBContext);\n    const AAType &AA =\n        A.getAAFor<AAType>(QueryingAA, RVPos, DepClassTy::REQUIRED);\n    LLVM_DEBUG(dbgs() << \"[Attributor] RV: \" << RV << \" AA: \" << AA.getAsStr()\n                      << \" @ \" << RVPos << \"\\n\");\n    const StateType &AAS = AA.getState();\n    if (T.hasValue())\n      *T &= AAS;\n    else\n      T = AAS;\n    LLVM_DEBUG(dbgs() << \"[Attributor] AA State: \" << AAS << \" RV State: \" << T\n                      << \"\\n\");\n    return T->isValidState();\n  };\n\n  if (!A.checkForAllReturnedValues(CheckReturnValue, QueryingAA))\n    S.indicatePessimisticFixpoint();\n  else if (T.hasValue())\n    S ^= *T;\n}\n\n/// Helper class for generic deduction: return value -> returned position.\ntemplate <typename AAType, typename BaseType,\n          typename StateType = typename BaseType::StateType,\n          bool PropagateCallBaseContext = false>\nstruct AAReturnedFromReturnedValues : public BaseType {\n  AAReturnedFromReturnedValues(const IRPosition &IRP, Attributor &A)\n      : BaseType(IRP, A) {}\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    StateType S(StateType::getBestState(this->getState()));\n    clampReturnedValueStates<AAType, StateType>(\n        A, *this, S,\n        PropagateCallBaseContext ? this->getCallBaseContext() : nullptr);\n    // TODO: If we know we visited all returned values, thus no are assumed\n    // dead, we can take the known information from the state T.\n    return clampStateAndIndicateChange<StateType>(this->getState(), S);\n  }\n};\n\n/// Clamp the information known at all call sites for a given argument\n/// (identified by \\p QueryingAA) into \\p S.\ntemplate <typename AAType, typename StateType = typename AAType::StateType>\nstatic void clampCallSiteArgumentStates(Attributor &A, const AAType &QueryingAA,\n                                        StateType &S) {\n  LLVM_DEBUG(dbgs() << \"[Attributor] Clamp call site argument states for \"\n                    << QueryingAA << \" into \" << S << \"\\n\");\n\n  assert(QueryingAA.getIRPosition().getPositionKind() ==\n             IRPosition::IRP_ARGUMENT &&\n         \"Can only clamp call site argument states for an argument position!\");\n\n  // Use an optional state as there might not be any return values and we want\n  // to join (IntegerState::operator&) the state of all there are.\n  Optional<StateType> T;\n\n  // The argument number which is also the call site argument number.\n  unsigned ArgNo = QueryingAA.getIRPosition().getCallSiteArgNo();\n\n  auto CallSiteCheck = [&](AbstractCallSite ACS) {\n    const IRPosition &ACSArgPos = IRPosition::callsite_argument(ACS, ArgNo);\n    // Check if a coresponding argument was found or if it is on not associated\n    // (which can happen for callback calls).\n    if (ACSArgPos.getPositionKind() == IRPosition::IRP_INVALID)\n      return false;\n\n    const AAType &AA =\n        A.getAAFor<AAType>(QueryingAA, ACSArgPos, DepClassTy::REQUIRED);\n    LLVM_DEBUG(dbgs() << \"[Attributor] ACS: \" << *ACS.getInstruction()\n                      << \" AA: \" << AA.getAsStr() << \" @\" << ACSArgPos << \"\\n\");\n    const StateType &AAS = AA.getState();\n    if (T.hasValue())\n      *T &= AAS;\n    else\n      T = AAS;\n    LLVM_DEBUG(dbgs() << \"[Attributor] AA State: \" << AAS << \" CSA State: \" << T\n                      << \"\\n\");\n    return T->isValidState();\n  };\n\n  bool AllCallSitesKnown;\n  if (!A.checkForAllCallSites(CallSiteCheck, QueryingAA, true,\n                              AllCallSitesKnown))\n    S.indicatePessimisticFixpoint();\n  else if (T.hasValue())\n    S ^= *T;\n}\n\n/// This function is the bridge between argument position and the call base\n/// context.\ntemplate <typename AAType, typename BaseType,\n          typename StateType = typename AAType::StateType>\nbool getArgumentStateFromCallBaseContext(Attributor &A,\n                                         BaseType &QueryingAttribute,\n                                         IRPosition &Pos, StateType &State) {\n  assert((Pos.getPositionKind() == IRPosition::IRP_ARGUMENT) &&\n         \"Expected an 'argument' position !\");\n  const CallBase *CBContext = Pos.getCallBaseContext();\n  if (!CBContext)\n    return false;\n\n  int ArgNo = Pos.getCallSiteArgNo();\n  assert(ArgNo >= 0 && \"Invalid Arg No!\");\n\n  const auto &AA = A.getAAFor<AAType>(\n      QueryingAttribute, IRPosition::callsite_argument(*CBContext, ArgNo),\n      DepClassTy::REQUIRED);\n  const StateType &CBArgumentState =\n      static_cast<const StateType &>(AA.getState());\n\n  LLVM_DEBUG(dbgs() << \"[Attributor] Briding Call site context to argument\"\n                    << \"Position:\" << Pos << \"CB Arg state:\" << CBArgumentState\n                    << \"\\n\");\n\n  // NOTE: If we want to do call site grouping it should happen here.\n  State ^= CBArgumentState;\n  return true;\n}\n\n/// Helper class for generic deduction: call site argument -> argument position.\ntemplate <typename AAType, typename BaseType,\n          typename StateType = typename AAType::StateType,\n          bool BridgeCallBaseContext = false>\nstruct AAArgumentFromCallSiteArguments : public BaseType {\n  AAArgumentFromCallSiteArguments(const IRPosition &IRP, Attributor &A)\n      : BaseType(IRP, A) {}\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    StateType S = StateType::getBestState(this->getState());\n\n    if (BridgeCallBaseContext) {\n      bool Success =\n          getArgumentStateFromCallBaseContext<AAType, BaseType, StateType>(\n              A, *this, this->getIRPosition(), S);\n      if (Success)\n        return clampStateAndIndicateChange<StateType>(this->getState(), S);\n    }\n    clampCallSiteArgumentStates<AAType, StateType>(A, *this, S);\n\n    // TODO: If we know we visited all incoming values, thus no are assumed\n    // dead, we can take the known information from the state T.\n    return clampStateAndIndicateChange<StateType>(this->getState(), S);\n  }\n};\n\n/// Helper class for generic replication: function returned -> cs returned.\ntemplate <typename AAType, typename BaseType,\n          typename StateType = typename BaseType::StateType,\n          bool IntroduceCallBaseContext = false>\nstruct AACallSiteReturnedFromReturned : public BaseType {\n  AACallSiteReturnedFromReturned(const IRPosition &IRP, Attributor &A)\n      : BaseType(IRP, A) {}\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    assert(this->getIRPosition().getPositionKind() ==\n               IRPosition::IRP_CALL_SITE_RETURNED &&\n           \"Can only wrap function returned positions for call site returned \"\n           \"positions!\");\n    auto &S = this->getState();\n\n    const Function *AssociatedFunction =\n        this->getIRPosition().getAssociatedFunction();\n    if (!AssociatedFunction)\n      return S.indicatePessimisticFixpoint();\n\n    CallBase &CBContext = static_cast<CallBase &>(this->getAnchorValue());\n    if (IntroduceCallBaseContext)\n      LLVM_DEBUG(dbgs() << \"[Attributor] Introducing call base context:\"\n                        << CBContext << \"\\n\");\n\n    IRPosition FnPos = IRPosition::returned(\n        *AssociatedFunction, IntroduceCallBaseContext ? &CBContext : nullptr);\n    const AAType &AA = A.getAAFor<AAType>(*this, FnPos, DepClassTy::REQUIRED);\n    return clampStateAndIndicateChange(S, AA.getState());\n  }\n};\n\n/// Helper function to accumulate uses.\ntemplate <class AAType, typename StateType = typename AAType::StateType>\nstatic void followUsesInContext(AAType &AA, Attributor &A,\n                                MustBeExecutedContextExplorer &Explorer,\n                                const Instruction *CtxI,\n                                SetVector<const Use *> &Uses,\n                                StateType &State) {\n  auto EIt = Explorer.begin(CtxI), EEnd = Explorer.end(CtxI);\n  for (unsigned u = 0; u < Uses.size(); ++u) {\n    const Use *U = Uses[u];\n    if (const Instruction *UserI = dyn_cast<Instruction>(U->getUser())) {\n      bool Found = Explorer.findInContextOf(UserI, EIt, EEnd);\n      if (Found && AA.followUseInMBEC(A, U, UserI, State))\n        for (const Use &Us : UserI->uses())\n          Uses.insert(&Us);\n    }\n  }\n}\n\n/// Use the must-be-executed-context around \\p I to add information into \\p S.\n/// The AAType class is required to have `followUseInMBEC` method with the\n/// following signature and behaviour:\n///\n/// bool followUseInMBEC(Attributor &A, const Use *U, const Instruction *I)\n/// U - Underlying use.\n/// I - The user of the \\p U.\n/// Returns true if the value should be tracked transitively.\n///\ntemplate <class AAType, typename StateType = typename AAType::StateType>\nstatic void followUsesInMBEC(AAType &AA, Attributor &A, StateType &S,\n                             Instruction &CtxI) {\n\n  // Container for (transitive) uses of the associated value.\n  SetVector<const Use *> Uses;\n  for (const Use &U : AA.getIRPosition().getAssociatedValue().uses())\n    Uses.insert(&U);\n\n  MustBeExecutedContextExplorer &Explorer =\n      A.getInfoCache().getMustBeExecutedContextExplorer();\n\n  followUsesInContext<AAType>(AA, A, Explorer, &CtxI, Uses, S);\n\n  if (S.isAtFixpoint())\n    return;\n\n  SmallVector<const BranchInst *, 4> BrInsts;\n  auto Pred = [&](const Instruction *I) {\n    if (const BranchInst *Br = dyn_cast<BranchInst>(I))\n      if (Br->isConditional())\n        BrInsts.push_back(Br);\n    return true;\n  };\n\n  // Here, accumulate conditional branch instructions in the context. We\n  // explore the child paths and collect the known states. The disjunction of\n  // those states can be merged to its own state. Let ParentState_i be a state\n  // to indicate the known information for an i-th branch instruction in the\n  // context. ChildStates are created for its successors respectively.\n  //\n  // ParentS_1 = ChildS_{1, 1} /\\ ChildS_{1, 2} /\\ ... /\\ ChildS_{1, n_1}\n  // ParentS_2 = ChildS_{2, 1} /\\ ChildS_{2, 2} /\\ ... /\\ ChildS_{2, n_2}\n  //      ...\n  // ParentS_m = ChildS_{m, 1} /\\ ChildS_{m, 2} /\\ ... /\\ ChildS_{m, n_m}\n  //\n  // Known State |= ParentS_1 \\/ ParentS_2 \\/... \\/ ParentS_m\n  //\n  // FIXME: Currently, recursive branches are not handled. For example, we\n  // can't deduce that ptr must be dereferenced in below function.\n  //\n  // void f(int a, int c, int *ptr) {\n  //    if(a)\n  //      if (b) {\n  //        *ptr = 0;\n  //      } else {\n  //        *ptr = 1;\n  //      }\n  //    else {\n  //      if (b) {\n  //        *ptr = 0;\n  //      } else {\n  //        *ptr = 1;\n  //      }\n  //    }\n  // }\n\n  Explorer.checkForAllContext(&CtxI, Pred);\n  for (const BranchInst *Br : BrInsts) {\n    StateType ParentState;\n\n    // The known state of the parent state is a conjunction of children's\n    // known states so it is initialized with a best state.\n    ParentState.indicateOptimisticFixpoint();\n\n    for (const BasicBlock *BB : Br->successors()) {\n      StateType ChildState;\n\n      size_t BeforeSize = Uses.size();\n      followUsesInContext(AA, A, Explorer, &BB->front(), Uses, ChildState);\n\n      // Erase uses which only appear in the child.\n      for (auto It = Uses.begin() + BeforeSize; It != Uses.end();)\n        It = Uses.erase(It);\n\n      ParentState &= ChildState;\n    }\n\n    // Use only known state.\n    S += ParentState;\n  }\n}\n\n/// -----------------------NoUnwind Function Attribute--------------------------\n\nstruct AANoUnwindImpl : AANoUnwind {\n  AANoUnwindImpl(const IRPosition &IRP, Attributor &A) : AANoUnwind(IRP, A) {}\n\n  const std::string getAsStr() const override {\n    return getAssumed() ? \"nounwind\" : \"may-unwind\";\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    auto Opcodes = {\n        (unsigned)Instruction::Invoke,      (unsigned)Instruction::CallBr,\n        (unsigned)Instruction::Call,        (unsigned)Instruction::CleanupRet,\n        (unsigned)Instruction::CatchSwitch, (unsigned)Instruction::Resume};\n\n    auto CheckForNoUnwind = [&](Instruction &I) {\n      if (!I.mayThrow())\n        return true;\n\n      if (const auto *CB = dyn_cast<CallBase>(&I)) {\n        const auto &NoUnwindAA = A.getAAFor<AANoUnwind>(\n            *this, IRPosition::callsite_function(*CB), DepClassTy::REQUIRED);\n        return NoUnwindAA.isAssumedNoUnwind();\n      }\n      return false;\n    };\n\n    if (!A.checkForAllInstructions(CheckForNoUnwind, *this, Opcodes))\n      return indicatePessimisticFixpoint();\n\n    return ChangeStatus::UNCHANGED;\n  }\n};\n\nstruct AANoUnwindFunction final : public AANoUnwindImpl {\n  AANoUnwindFunction(const IRPosition &IRP, Attributor &A)\n      : AANoUnwindImpl(IRP, A) {}\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_FN_ATTR(nounwind) }\n};\n\n/// NoUnwind attribute deduction for a call sites.\nstruct AANoUnwindCallSite final : AANoUnwindImpl {\n  AANoUnwindCallSite(const IRPosition &IRP, Attributor &A)\n      : AANoUnwindImpl(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    AANoUnwindImpl::initialize(A);\n    Function *F = getAssociatedFunction();\n    if (!F || F->isDeclaration())\n      indicatePessimisticFixpoint();\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    // TODO: Once we have call site specific value information we can provide\n    //       call site specific liveness information and then it makes\n    //       sense to specialize attributes for call sites arguments instead of\n    //       redirecting requests to the callee argument.\n    Function *F = getAssociatedFunction();\n    const IRPosition &FnPos = IRPosition::function(*F);\n    auto &FnAA = A.getAAFor<AANoUnwind>(*this, FnPos, DepClassTy::REQUIRED);\n    return clampStateAndIndicateChange(getState(), FnAA.getState());\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_CS_ATTR(nounwind); }\n};\n\n/// --------------------- Function Return Values -------------------------------\n\n/// \"Attribute\" that collects all potential returned values and the return\n/// instructions that they arise from.\n///\n/// If there is a unique returned value R, the manifest method will:\n///   - mark R with the \"returned\" attribute, if R is an argument.\nclass AAReturnedValuesImpl : public AAReturnedValues, public AbstractState {\n\n  /// Mapping of values potentially returned by the associated function to the\n  /// return instructions that might return them.\n  MapVector<Value *, SmallSetVector<ReturnInst *, 4>> ReturnedValues;\n\n  /// Mapping to remember the number of returned values for a call site such\n  /// that we can avoid updates if nothing changed.\n  DenseMap<const CallBase *, unsigned> NumReturnedValuesPerKnownAA;\n\n  /// Set of unresolved calls returned by the associated function.\n  SmallSetVector<CallBase *, 4> UnresolvedCalls;\n\n  /// State flags\n  ///\n  ///{\n  bool IsFixed = false;\n  bool IsValidState = true;\n  ///}\n\npublic:\n  AAReturnedValuesImpl(const IRPosition &IRP, Attributor &A)\n      : AAReturnedValues(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    // Reset the state.\n    IsFixed = false;\n    IsValidState = true;\n    ReturnedValues.clear();\n\n    Function *F = getAssociatedFunction();\n    if (!F || F->isDeclaration()) {\n      indicatePessimisticFixpoint();\n      return;\n    }\n    assert(!F->getReturnType()->isVoidTy() &&\n           \"Did not expect a void return type!\");\n\n    // The map from instruction opcodes to those instructions in the function.\n    auto &OpcodeInstMap = A.getInfoCache().getOpcodeInstMapForFunction(*F);\n\n    // Look through all arguments, if one is marked as returned we are done.\n    for (Argument &Arg : F->args()) {\n      if (Arg.hasReturnedAttr()) {\n        auto &ReturnInstSet = ReturnedValues[&Arg];\n        if (auto *Insts = OpcodeInstMap.lookup(Instruction::Ret))\n          for (Instruction *RI : *Insts)\n            ReturnInstSet.insert(cast<ReturnInst>(RI));\n\n        indicateOptimisticFixpoint();\n        return;\n      }\n    }\n\n    if (!A.isFunctionIPOAmendable(*F))\n      indicatePessimisticFixpoint();\n  }\n\n  /// See AbstractAttribute::manifest(...).\n  ChangeStatus manifest(Attributor &A) override;\n\n  /// See AbstractAttribute::getState(...).\n  AbstractState &getState() override { return *this; }\n\n  /// See AbstractAttribute::getState(...).\n  const AbstractState &getState() const override { return *this; }\n\n  /// See AbstractAttribute::updateImpl(Attributor &A).\n  ChangeStatus updateImpl(Attributor &A) override;\n\n  llvm::iterator_range<iterator> returned_values() override {\n    return llvm::make_range(ReturnedValues.begin(), ReturnedValues.end());\n  }\n\n  llvm::iterator_range<const_iterator> returned_values() const override {\n    return llvm::make_range(ReturnedValues.begin(), ReturnedValues.end());\n  }\n\n  const SmallSetVector<CallBase *, 4> &getUnresolvedCalls() const override {\n    return UnresolvedCalls;\n  }\n\n  /// Return the number of potential return values, -1 if unknown.\n  size_t getNumReturnValues() const override {\n    return isValidState() ? ReturnedValues.size() : -1;\n  }\n\n  /// Return an assumed unique return value if a single candidate is found. If\n  /// there cannot be one, return a nullptr. If it is not clear yet, return the\n  /// Optional::NoneType.\n  Optional<Value *> getAssumedUniqueReturnValue(Attributor &A) const;\n\n  /// See AbstractState::checkForAllReturnedValues(...).\n  bool checkForAllReturnedValuesAndReturnInsts(\n      function_ref<bool(Value &, const SmallSetVector<ReturnInst *, 4> &)> Pred)\n      const override;\n\n  /// Pretty print the attribute similar to the IR representation.\n  const std::string getAsStr() const override;\n\n  /// See AbstractState::isAtFixpoint().\n  bool isAtFixpoint() const override { return IsFixed; }\n\n  /// See AbstractState::isValidState().\n  bool isValidState() const override { return IsValidState; }\n\n  /// See AbstractState::indicateOptimisticFixpoint(...).\n  ChangeStatus indicateOptimisticFixpoint() override {\n    IsFixed = true;\n    return ChangeStatus::UNCHANGED;\n  }\n\n  ChangeStatus indicatePessimisticFixpoint() override {\n    IsFixed = true;\n    IsValidState = false;\n    return ChangeStatus::CHANGED;\n  }\n};\n\nChangeStatus AAReturnedValuesImpl::manifest(Attributor &A) {\n  ChangeStatus Changed = ChangeStatus::UNCHANGED;\n\n  // Bookkeeping.\n  assert(isValidState());\n  STATS_DECLTRACK(KnownReturnValues, FunctionReturn,\n                  \"Number of function with known return values\");\n\n  // Check if we have an assumed unique return value that we could manifest.\n  Optional<Value *> UniqueRV = getAssumedUniqueReturnValue(A);\n\n  if (!UniqueRV.hasValue() || !UniqueRV.getValue())\n    return Changed;\n\n  // Bookkeeping.\n  STATS_DECLTRACK(UniqueReturnValue, FunctionReturn,\n                  \"Number of function with unique return\");\n\n  // Callback to replace the uses of CB with the constant C.\n  auto ReplaceCallSiteUsersWith = [&A](CallBase &CB, Constant &C) {\n    if (CB.use_empty())\n      return ChangeStatus::UNCHANGED;\n    if (A.changeValueAfterManifest(CB, C))\n      return ChangeStatus::CHANGED;\n    return ChangeStatus::UNCHANGED;\n  };\n\n  // If the assumed unique return value is an argument, annotate it.\n  if (auto *UniqueRVArg = dyn_cast<Argument>(UniqueRV.getValue())) {\n    if (UniqueRVArg->getType()->canLosslesslyBitCastTo(\n            getAssociatedFunction()->getReturnType())) {\n      getIRPosition() = IRPosition::argument(*UniqueRVArg);\n      Changed = IRAttribute::manifest(A);\n    }\n  } else if (auto *RVC = dyn_cast<Constant>(UniqueRV.getValue())) {\n    // We can replace the returned value with the unique returned constant.\n    Value &AnchorValue = getAnchorValue();\n    if (Function *F = dyn_cast<Function>(&AnchorValue)) {\n      for (const Use &U : F->uses())\n        if (CallBase *CB = dyn_cast<CallBase>(U.getUser()))\n          if (CB->isCallee(&U)) {\n            Constant *RVCCast =\n                CB->getType() == RVC->getType()\n                    ? RVC\n                    : ConstantExpr::getTruncOrBitCast(RVC, CB->getType());\n            Changed = ReplaceCallSiteUsersWith(*CB, *RVCCast) | Changed;\n          }\n    } else {\n      assert(isa<CallBase>(AnchorValue) &&\n             \"Expcected a function or call base anchor!\");\n      Constant *RVCCast =\n          AnchorValue.getType() == RVC->getType()\n              ? RVC\n              : ConstantExpr::getTruncOrBitCast(RVC, AnchorValue.getType());\n      Changed = ReplaceCallSiteUsersWith(cast<CallBase>(AnchorValue), *RVCCast);\n    }\n    if (Changed == ChangeStatus::CHANGED)\n      STATS_DECLTRACK(UniqueConstantReturnValue, FunctionReturn,\n                      \"Number of function returns replaced by constant return\");\n  }\n\n  return Changed;\n}\n\nconst std::string AAReturnedValuesImpl::getAsStr() const {\n  return (isAtFixpoint() ? \"returns(#\" : \"may-return(#\") +\n         (isValidState() ? std::to_string(getNumReturnValues()) : \"?\") +\n         \")[#UC: \" + std::to_string(UnresolvedCalls.size()) + \"]\";\n}\n\nOptional<Value *>\nAAReturnedValuesImpl::getAssumedUniqueReturnValue(Attributor &A) const {\n  // If checkForAllReturnedValues provides a unique value, ignoring potential\n  // undef values that can also be present, it is assumed to be the actual\n  // return value and forwarded to the caller of this method. If there are\n  // multiple, a nullptr is returned indicating there cannot be a unique\n  // returned value.\n  Optional<Value *> UniqueRV;\n\n  auto Pred = [&](Value &RV) -> bool {\n    // If we found a second returned value and neither the current nor the saved\n    // one is an undef, there is no unique returned value. Undefs are special\n    // since we can pretend they have any value.\n    if (UniqueRV.hasValue() && UniqueRV != &RV &&\n        !(isa<UndefValue>(RV) || isa<UndefValue>(UniqueRV.getValue()))) {\n      UniqueRV = nullptr;\n      return false;\n    }\n\n    // Do not overwrite a value with an undef.\n    if (!UniqueRV.hasValue() || !isa<UndefValue>(RV))\n      UniqueRV = &RV;\n\n    return true;\n  };\n\n  if (!A.checkForAllReturnedValues(Pred, *this))\n    UniqueRV = nullptr;\n\n  return UniqueRV;\n}\n\nbool AAReturnedValuesImpl::checkForAllReturnedValuesAndReturnInsts(\n    function_ref<bool(Value &, const SmallSetVector<ReturnInst *, 4> &)> Pred)\n    const {\n  if (!isValidState())\n    return false;\n\n  // Check all returned values but ignore call sites as long as we have not\n  // encountered an overdefined one during an update.\n  for (auto &It : ReturnedValues) {\n    Value *RV = It.first;\n\n    CallBase *CB = dyn_cast<CallBase>(RV);\n    if (CB && !UnresolvedCalls.count(CB))\n      continue;\n\n    if (!Pred(*RV, It.second))\n      return false;\n  }\n\n  return true;\n}\n\nChangeStatus AAReturnedValuesImpl::updateImpl(Attributor &A) {\n  size_t NumUnresolvedCalls = UnresolvedCalls.size();\n  bool Changed = false;\n\n  // State used in the value traversals starting in returned values.\n  struct RVState {\n    // The map in which we collect return values -> return instrs.\n    decltype(ReturnedValues) &RetValsMap;\n    // The flag to indicate a change.\n    bool &Changed;\n    // The return instrs we come from.\n    SmallSetVector<ReturnInst *, 4> RetInsts;\n  };\n\n  // Callback for a leaf value returned by the associated function.\n  auto VisitValueCB = [](Value &Val, const Instruction *, RVState &RVS,\n                         bool) -> bool {\n    auto Size = RVS.RetValsMap[&Val].size();\n    RVS.RetValsMap[&Val].insert(RVS.RetInsts.begin(), RVS.RetInsts.end());\n    bool Inserted = RVS.RetValsMap[&Val].size() != Size;\n    RVS.Changed |= Inserted;\n    LLVM_DEBUG({\n      if (Inserted)\n        dbgs() << \"[AAReturnedValues] 1 Add new returned value \" << Val\n               << \" => \" << RVS.RetInsts.size() << \"\\n\";\n    });\n    return true;\n  };\n\n  // Helper method to invoke the generic value traversal.\n  auto VisitReturnedValue = [&](Value &RV, RVState &RVS,\n                                const Instruction *CtxI) {\n    IRPosition RetValPos = IRPosition::value(RV);\n    return genericValueTraversal<AAReturnedValues, RVState>(\n        A, RetValPos, *this, RVS, VisitValueCB, CtxI,\n        /* UseValueSimplify */ false);\n  };\n\n  // Callback for all \"return intructions\" live in the associated function.\n  auto CheckReturnInst = [this, &VisitReturnedValue, &Changed](Instruction &I) {\n    ReturnInst &Ret = cast<ReturnInst>(I);\n    RVState RVS({ReturnedValues, Changed, {}});\n    RVS.RetInsts.insert(&Ret);\n    return VisitReturnedValue(*Ret.getReturnValue(), RVS, &I);\n  };\n\n  // Start by discovering returned values from all live returned instructions in\n  // the associated function.\n  if (!A.checkForAllInstructions(CheckReturnInst, *this, {Instruction::Ret}))\n    return indicatePessimisticFixpoint();\n\n  // Once returned values \"directly\" present in the code are handled we try to\n  // resolve returned calls. To avoid modifications to the ReturnedValues map\n  // while we iterate over it we kept record of potential new entries in a copy\n  // map, NewRVsMap.\n  decltype(ReturnedValues) NewRVsMap;\n\n  auto HandleReturnValue = [&](Value *RV,\n                               SmallSetVector<ReturnInst *, 4> &RIs) {\n    LLVM_DEBUG(dbgs() << \"[AAReturnedValues] Returned value: \" << *RV << \" by #\"\n                      << RIs.size() << \" RIs\\n\");\n    CallBase *CB = dyn_cast<CallBase>(RV);\n    if (!CB || UnresolvedCalls.count(CB))\n      return;\n\n    if (!CB->getCalledFunction()) {\n      LLVM_DEBUG(dbgs() << \"[AAReturnedValues] Unresolved call: \" << *CB\n                        << \"\\n\");\n      UnresolvedCalls.insert(CB);\n      return;\n    }\n\n    // TODO: use the function scope once we have call site AAReturnedValues.\n    const auto &RetValAA = A.getAAFor<AAReturnedValues>(\n        *this, IRPosition::function(*CB->getCalledFunction()),\n        DepClassTy::REQUIRED);\n    LLVM_DEBUG(dbgs() << \"[AAReturnedValues] Found another AAReturnedValues: \"\n                      << RetValAA << \"\\n\");\n\n    // Skip dead ends, thus if we do not know anything about the returned\n    // call we mark it as unresolved and it will stay that way.\n    if (!RetValAA.getState().isValidState()) {\n      LLVM_DEBUG(dbgs() << \"[AAReturnedValues] Unresolved call: \" << *CB\n                        << \"\\n\");\n      UnresolvedCalls.insert(CB);\n      return;\n    }\n\n    // Do not try to learn partial information. If the callee has unresolved\n    // return values we will treat the call as unresolved/opaque.\n    auto &RetValAAUnresolvedCalls = RetValAA.getUnresolvedCalls();\n    if (!RetValAAUnresolvedCalls.empty()) {\n      UnresolvedCalls.insert(CB);\n      return;\n    }\n\n    // Now check if we can track transitively returned values. If possible, thus\n    // if all return value can be represented in the current scope, do so.\n    bool Unresolved = false;\n    for (auto &RetValAAIt : RetValAA.returned_values()) {\n      Value *RetVal = RetValAAIt.first;\n      if (isa<Argument>(RetVal) || isa<CallBase>(RetVal) ||\n          isa<Constant>(RetVal))\n        continue;\n      // Anything that did not fit in the above categories cannot be resolved,\n      // mark the call as unresolved.\n      LLVM_DEBUG(dbgs() << \"[AAReturnedValues] transitively returned value \"\n                           \"cannot be translated: \"\n                        << *RetVal << \"\\n\");\n      UnresolvedCalls.insert(CB);\n      Unresolved = true;\n      break;\n    }\n\n    if (Unresolved)\n      return;\n\n    // Now track transitively returned values.\n    unsigned &NumRetAA = NumReturnedValuesPerKnownAA[CB];\n    if (NumRetAA == RetValAA.getNumReturnValues()) {\n      LLVM_DEBUG(dbgs() << \"[AAReturnedValues] Skip call as it has not \"\n                           \"changed since it was seen last\\n\");\n      return;\n    }\n    NumRetAA = RetValAA.getNumReturnValues();\n\n    for (auto &RetValAAIt : RetValAA.returned_values()) {\n      Value *RetVal = RetValAAIt.first;\n      if (Argument *Arg = dyn_cast<Argument>(RetVal)) {\n        // Arguments are mapped to call site operands and we begin the traversal\n        // again.\n        bool Unused = false;\n        RVState RVS({NewRVsMap, Unused, RetValAAIt.second});\n        VisitReturnedValue(*CB->getArgOperand(Arg->getArgNo()), RVS, CB);\n        continue;\n      }\n      if (isa<CallBase>(RetVal)) {\n        // Call sites are resolved by the callee attribute over time, no need to\n        // do anything for us.\n        continue;\n      }\n      if (isa<Constant>(RetVal)) {\n        // Constants are valid everywhere, we can simply take them.\n        NewRVsMap[RetVal].insert(RIs.begin(), RIs.end());\n        continue;\n      }\n    }\n  };\n\n  for (auto &It : ReturnedValues)\n    HandleReturnValue(It.first, It.second);\n\n  // Because processing the new information can again lead to new return values\n  // we have to be careful and iterate until this iteration is complete. The\n  // idea is that we are in a stable state at the end of an update. All return\n  // values have been handled and properly categorized. We might not update\n  // again if we have not requested a non-fix attribute so we cannot \"wait\" for\n  // the next update to analyze a new return value.\n  while (!NewRVsMap.empty()) {\n    auto It = std::move(NewRVsMap.back());\n    NewRVsMap.pop_back();\n\n    assert(!It.second.empty() && \"Entry does not add anything.\");\n    auto &ReturnInsts = ReturnedValues[It.first];\n    for (ReturnInst *RI : It.second)\n      if (ReturnInsts.insert(RI)) {\n        LLVM_DEBUG(dbgs() << \"[AAReturnedValues] Add new returned value \"\n                          << *It.first << \" => \" << *RI << \"\\n\");\n        HandleReturnValue(It.first, ReturnInsts);\n        Changed = true;\n      }\n  }\n\n  Changed |= (NumUnresolvedCalls != UnresolvedCalls.size());\n  return Changed ? ChangeStatus::CHANGED : ChangeStatus::UNCHANGED;\n}\n\nstruct AAReturnedValuesFunction final : public AAReturnedValuesImpl {\n  AAReturnedValuesFunction(const IRPosition &IRP, Attributor &A)\n      : AAReturnedValuesImpl(IRP, A) {}\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_ARG_ATTR(returned) }\n};\n\n/// Returned values information for a call sites.\nstruct AAReturnedValuesCallSite final : AAReturnedValuesImpl {\n  AAReturnedValuesCallSite(const IRPosition &IRP, Attributor &A)\n      : AAReturnedValuesImpl(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    // TODO: Once we have call site specific value information we can provide\n    //       call site specific liveness information and then it makes\n    //       sense to specialize attributes for call sites instead of\n    //       redirecting requests to the callee.\n    llvm_unreachable(\"Abstract attributes for returned values are not \"\n                     \"supported for call sites yet!\");\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    return indicatePessimisticFixpoint();\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {}\n};\n\n/// ------------------------ NoSync Function Attribute -------------------------\n\nstruct AANoSyncImpl : AANoSync {\n  AANoSyncImpl(const IRPosition &IRP, Attributor &A) : AANoSync(IRP, A) {}\n\n  const std::string getAsStr() const override {\n    return getAssumed() ? \"nosync\" : \"may-sync\";\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override;\n\n  /// Helper function used to determine whether an instruction is non-relaxed\n  /// atomic. In other words, if an atomic instruction does not have unordered\n  /// or monotonic ordering\n  static bool isNonRelaxedAtomic(Instruction *I);\n\n  /// Helper function used to determine whether an instruction is volatile.\n  static bool isVolatile(Instruction *I);\n\n  /// Helper function uset to check if intrinsic is volatile (memcpy, memmove,\n  /// memset).\n  static bool isNoSyncIntrinsic(Instruction *I);\n};\n\nbool AANoSyncImpl::isNonRelaxedAtomic(Instruction *I) {\n  if (!I->isAtomic())\n    return false;\n\n  AtomicOrdering Ordering;\n  switch (I->getOpcode()) {\n  case Instruction::AtomicRMW:\n    Ordering = cast<AtomicRMWInst>(I)->getOrdering();\n    break;\n  case Instruction::Store:\n    Ordering = cast<StoreInst>(I)->getOrdering();\n    break;\n  case Instruction::Load:\n    Ordering = cast<LoadInst>(I)->getOrdering();\n    break;\n  case Instruction::Fence: {\n    auto *FI = cast<FenceInst>(I);\n    if (FI->getSyncScopeID() == SyncScope::SingleThread)\n      return false;\n    Ordering = FI->getOrdering();\n    break;\n  }\n  case Instruction::AtomicCmpXchg: {\n    AtomicOrdering Success = cast<AtomicCmpXchgInst>(I)->getSuccessOrdering();\n    AtomicOrdering Failure = cast<AtomicCmpXchgInst>(I)->getFailureOrdering();\n    // Only if both are relaxed, than it can be treated as relaxed.\n    // Otherwise it is non-relaxed.\n    if (Success != AtomicOrdering::Unordered &&\n        Success != AtomicOrdering::Monotonic)\n      return true;\n    if (Failure != AtomicOrdering::Unordered &&\n        Failure != AtomicOrdering::Monotonic)\n      return true;\n    return false;\n  }\n  default:\n    llvm_unreachable(\n        \"New atomic operations need to be known in the attributor.\");\n  }\n\n  // Relaxed.\n  if (Ordering == AtomicOrdering::Unordered ||\n      Ordering == AtomicOrdering::Monotonic)\n    return false;\n  return true;\n}\n\n/// Checks if an intrinsic is nosync. Currently only checks mem* intrinsics.\n/// FIXME: We should ipmrove the handling of intrinsics.\nbool AANoSyncImpl::isNoSyncIntrinsic(Instruction *I) {\n  if (auto *II = dyn_cast<IntrinsicInst>(I)) {\n    switch (II->getIntrinsicID()) {\n    /// Element wise atomic memory intrinsics are can only be unordered,\n    /// therefore nosync.\n    case Intrinsic::memset_element_unordered_atomic:\n    case Intrinsic::memmove_element_unordered_atomic:\n    case Intrinsic::memcpy_element_unordered_atomic:\n      return true;\n    case Intrinsic::memset:\n    case Intrinsic::memmove:\n    case Intrinsic::memcpy:\n      if (!cast<MemIntrinsic>(II)->isVolatile())\n        return true;\n      return false;\n    default:\n      return false;\n    }\n  }\n  return false;\n}\n\nbool AANoSyncImpl::isVolatile(Instruction *I) {\n  assert(!isa<CallBase>(I) && \"Calls should not be checked here\");\n\n  switch (I->getOpcode()) {\n  case Instruction::AtomicRMW:\n    return cast<AtomicRMWInst>(I)->isVolatile();\n  case Instruction::Store:\n    return cast<StoreInst>(I)->isVolatile();\n  case Instruction::Load:\n    return cast<LoadInst>(I)->isVolatile();\n  case Instruction::AtomicCmpXchg:\n    return cast<AtomicCmpXchgInst>(I)->isVolatile();\n  default:\n    return false;\n  }\n}\n\nChangeStatus AANoSyncImpl::updateImpl(Attributor &A) {\n\n  auto CheckRWInstForNoSync = [&](Instruction &I) {\n    /// We are looking for volatile instructions or Non-Relaxed atomics.\n    /// FIXME: We should improve the handling of intrinsics.\n\n    if (isa<IntrinsicInst>(&I) && isNoSyncIntrinsic(&I))\n      return true;\n\n    if (const auto *CB = dyn_cast<CallBase>(&I)) {\n      if (CB->hasFnAttr(Attribute::NoSync))\n        return true;\n\n      const auto &NoSyncAA = A.getAAFor<AANoSync>(\n          *this, IRPosition::callsite_function(*CB), DepClassTy::REQUIRED);\n      return NoSyncAA.isAssumedNoSync();\n    }\n\n    if (!isVolatile(&I) && !isNonRelaxedAtomic(&I))\n      return true;\n\n    return false;\n  };\n\n  auto CheckForNoSync = [&](Instruction &I) {\n    // At this point we handled all read/write effects and they are all\n    // nosync, so they can be skipped.\n    if (I.mayReadOrWriteMemory())\n      return true;\n\n    // non-convergent and readnone imply nosync.\n    return !cast<CallBase>(I).isConvergent();\n  };\n\n  if (!A.checkForAllReadWriteInstructions(CheckRWInstForNoSync, *this) ||\n      !A.checkForAllCallLikeInstructions(CheckForNoSync, *this))\n    return indicatePessimisticFixpoint();\n\n  return ChangeStatus::UNCHANGED;\n}\n\nstruct AANoSyncFunction final : public AANoSyncImpl {\n  AANoSyncFunction(const IRPosition &IRP, Attributor &A)\n      : AANoSyncImpl(IRP, A) {}\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_FN_ATTR(nosync) }\n};\n\n/// NoSync attribute deduction for a call sites.\nstruct AANoSyncCallSite final : AANoSyncImpl {\n  AANoSyncCallSite(const IRPosition &IRP, Attributor &A)\n      : AANoSyncImpl(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    AANoSyncImpl::initialize(A);\n    Function *F = getAssociatedFunction();\n    if (!F || F->isDeclaration())\n      indicatePessimisticFixpoint();\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    // TODO: Once we have call site specific value information we can provide\n    //       call site specific liveness information and then it makes\n    //       sense to specialize attributes for call sites arguments instead of\n    //       redirecting requests to the callee argument.\n    Function *F = getAssociatedFunction();\n    const IRPosition &FnPos = IRPosition::function(*F);\n    auto &FnAA = A.getAAFor<AANoSync>(*this, FnPos, DepClassTy::REQUIRED);\n    return clampStateAndIndicateChange(getState(), FnAA.getState());\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_CS_ATTR(nosync); }\n};\n\n/// ------------------------ No-Free Attributes ----------------------------\n\nstruct AANoFreeImpl : public AANoFree {\n  AANoFreeImpl(const IRPosition &IRP, Attributor &A) : AANoFree(IRP, A) {}\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    auto CheckForNoFree = [&](Instruction &I) {\n      const auto &CB = cast<CallBase>(I);\n      if (CB.hasFnAttr(Attribute::NoFree))\n        return true;\n\n      const auto &NoFreeAA = A.getAAFor<AANoFree>(\n          *this, IRPosition::callsite_function(CB), DepClassTy::REQUIRED);\n      return NoFreeAA.isAssumedNoFree();\n    };\n\n    if (!A.checkForAllCallLikeInstructions(CheckForNoFree, *this))\n      return indicatePessimisticFixpoint();\n    return ChangeStatus::UNCHANGED;\n  }\n\n  /// See AbstractAttribute::getAsStr().\n  const std::string getAsStr() const override {\n    return getAssumed() ? \"nofree\" : \"may-free\";\n  }\n};\n\nstruct AANoFreeFunction final : public AANoFreeImpl {\n  AANoFreeFunction(const IRPosition &IRP, Attributor &A)\n      : AANoFreeImpl(IRP, A) {}\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_FN_ATTR(nofree) }\n};\n\n/// NoFree attribute deduction for a call sites.\nstruct AANoFreeCallSite final : AANoFreeImpl {\n  AANoFreeCallSite(const IRPosition &IRP, Attributor &A)\n      : AANoFreeImpl(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    AANoFreeImpl::initialize(A);\n    Function *F = getAssociatedFunction();\n    if (!F || F->isDeclaration())\n      indicatePessimisticFixpoint();\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    // TODO: Once we have call site specific value information we can provide\n    //       call site specific liveness information and then it makes\n    //       sense to specialize attributes for call sites arguments instead of\n    //       redirecting requests to the callee argument.\n    Function *F = getAssociatedFunction();\n    const IRPosition &FnPos = IRPosition::function(*F);\n    auto &FnAA = A.getAAFor<AANoFree>(*this, FnPos, DepClassTy::REQUIRED);\n    return clampStateAndIndicateChange(getState(), FnAA.getState());\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_CS_ATTR(nofree); }\n};\n\n/// NoFree attribute for floating values.\nstruct AANoFreeFloating : AANoFreeImpl {\n  AANoFreeFloating(const IRPosition &IRP, Attributor &A)\n      : AANoFreeImpl(IRP, A) {}\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override{STATS_DECLTRACK_FLOATING_ATTR(nofree)}\n\n  /// See Abstract Attribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    const IRPosition &IRP = getIRPosition();\n\n    const auto &NoFreeAA = A.getAAFor<AANoFree>(\n        *this, IRPosition::function_scope(IRP), DepClassTy::OPTIONAL);\n    if (NoFreeAA.isAssumedNoFree())\n      return ChangeStatus::UNCHANGED;\n\n    Value &AssociatedValue = getIRPosition().getAssociatedValue();\n    auto Pred = [&](const Use &U, bool &Follow) -> bool {\n      Instruction *UserI = cast<Instruction>(U.getUser());\n      if (auto *CB = dyn_cast<CallBase>(UserI)) {\n        if (CB->isBundleOperand(&U))\n          return false;\n        if (!CB->isArgOperand(&U))\n          return true;\n        unsigned ArgNo = CB->getArgOperandNo(&U);\n\n        const auto &NoFreeArg = A.getAAFor<AANoFree>(\n            *this, IRPosition::callsite_argument(*CB, ArgNo),\n            DepClassTy::REQUIRED);\n        return NoFreeArg.isAssumedNoFree();\n      }\n\n      if (isa<GetElementPtrInst>(UserI) || isa<BitCastInst>(UserI) ||\n          isa<PHINode>(UserI) || isa<SelectInst>(UserI)) {\n        Follow = true;\n        return true;\n      }\n      if (isa<ReturnInst>(UserI))\n        return true;\n\n      // Unknown user.\n      return false;\n    };\n    if (!A.checkForAllUses(Pred, *this, AssociatedValue))\n      return indicatePessimisticFixpoint();\n\n    return ChangeStatus::UNCHANGED;\n  }\n};\n\n/// NoFree attribute for a call site argument.\nstruct AANoFreeArgument final : AANoFreeFloating {\n  AANoFreeArgument(const IRPosition &IRP, Attributor &A)\n      : AANoFreeFloating(IRP, A) {}\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_ARG_ATTR(nofree) }\n};\n\n/// NoFree attribute for call site arguments.\nstruct AANoFreeCallSiteArgument final : AANoFreeFloating {\n  AANoFreeCallSiteArgument(const IRPosition &IRP, Attributor &A)\n      : AANoFreeFloating(IRP, A) {}\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    // TODO: Once we have call site specific value information we can provide\n    //       call site specific liveness information and then it makes\n    //       sense to specialize attributes for call sites arguments instead of\n    //       redirecting requests to the callee argument.\n    Argument *Arg = getAssociatedArgument();\n    if (!Arg)\n      return indicatePessimisticFixpoint();\n    const IRPosition &ArgPos = IRPosition::argument(*Arg);\n    auto &ArgAA = A.getAAFor<AANoFree>(*this, ArgPos, DepClassTy::REQUIRED);\n    return clampStateAndIndicateChange(getState(), ArgAA.getState());\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override{STATS_DECLTRACK_CSARG_ATTR(nofree)};\n};\n\n/// NoFree attribute for function return value.\nstruct AANoFreeReturned final : AANoFreeFloating {\n  AANoFreeReturned(const IRPosition &IRP, Attributor &A)\n      : AANoFreeFloating(IRP, A) {\n    llvm_unreachable(\"NoFree is not applicable to function returns!\");\n  }\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    llvm_unreachable(\"NoFree is not applicable to function returns!\");\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    llvm_unreachable(\"NoFree is not applicable to function returns!\");\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {}\n};\n\n/// NoFree attribute deduction for a call site return value.\nstruct AANoFreeCallSiteReturned final : AANoFreeFloating {\n  AANoFreeCallSiteReturned(const IRPosition &IRP, Attributor &A)\n      : AANoFreeFloating(IRP, A) {}\n\n  ChangeStatus manifest(Attributor &A) override {\n    return ChangeStatus::UNCHANGED;\n  }\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_CSRET_ATTR(nofree) }\n};\n\n/// ------------------------ NonNull Argument Attribute ------------------------\nstatic int64_t getKnownNonNullAndDerefBytesForUse(\n    Attributor &A, const AbstractAttribute &QueryingAA, Value &AssociatedValue,\n    const Use *U, const Instruction *I, bool &IsNonNull, bool &TrackUse) {\n  TrackUse = false;\n\n  const Value *UseV = U->get();\n  if (!UseV->getType()->isPointerTy())\n    return 0;\n\n  // We need to follow common pointer manipulation uses to the accesses they\n  // feed into. We can try to be smart to avoid looking through things we do not\n  // like for now, e.g., non-inbounds GEPs.\n  if (isa<CastInst>(I)) {\n    TrackUse = true;\n    return 0;\n  }\n\n  if (isa<GetElementPtrInst>(I)) {\n    TrackUse = true;\n    return 0;\n  }\n\n  Type *PtrTy = UseV->getType();\n  const Function *F = I->getFunction();\n  bool NullPointerIsDefined =\n      F ? llvm::NullPointerIsDefined(F, PtrTy->getPointerAddressSpace()) : true;\n  const DataLayout &DL = A.getInfoCache().getDL();\n  if (const auto *CB = dyn_cast<CallBase>(I)) {\n    if (CB->isBundleOperand(U)) {\n      if (RetainedKnowledge RK = getKnowledgeFromUse(\n              U, {Attribute::NonNull, Attribute::Dereferenceable})) {\n        IsNonNull |=\n            (RK.AttrKind == Attribute::NonNull || !NullPointerIsDefined);\n        return RK.ArgValue;\n      }\n      return 0;\n    }\n\n    if (CB->isCallee(U)) {\n      IsNonNull |= !NullPointerIsDefined;\n      return 0;\n    }\n\n    unsigned ArgNo = CB->getArgOperandNo(U);\n    IRPosition IRP = IRPosition::callsite_argument(*CB, ArgNo);\n    // As long as we only use known information there is no need to track\n    // dependences here.\n    auto &DerefAA =\n        A.getAAFor<AADereferenceable>(QueryingAA, IRP, DepClassTy::NONE);\n    IsNonNull |= DerefAA.isKnownNonNull();\n    return DerefAA.getKnownDereferenceableBytes();\n  }\n\n  int64_t Offset;\n  const Value *Base =\n      getMinimalBaseOfAccsesPointerOperand(A, QueryingAA, I, Offset, DL);\n  if (Base) {\n    if (Base == &AssociatedValue &&\n        getPointerOperand(I, /* AllowVolatile */ false) == UseV) {\n      int64_t DerefBytes =\n          (int64_t)DL.getTypeStoreSize(PtrTy->getPointerElementType()) + Offset;\n\n      IsNonNull |= !NullPointerIsDefined;\n      return std::max(int64_t(0), DerefBytes);\n    }\n  }\n\n  /// Corner case when an offset is 0.\n  Base = getBasePointerOfAccessPointerOperand(I, Offset, DL,\n                                              /*AllowNonInbounds*/ true);\n  if (Base) {\n    if (Offset == 0 && Base == &AssociatedValue &&\n        getPointerOperand(I, /* AllowVolatile */ false) == UseV) {\n      int64_t DerefBytes =\n          (int64_t)DL.getTypeStoreSize(PtrTy->getPointerElementType());\n      IsNonNull |= !NullPointerIsDefined;\n      return std::max(int64_t(0), DerefBytes);\n    }\n  }\n\n  return 0;\n}\n\nstruct AANonNullImpl : AANonNull {\n  AANonNullImpl(const IRPosition &IRP, Attributor &A)\n      : AANonNull(IRP, A),\n        NullIsDefined(NullPointerIsDefined(\n            getAnchorScope(),\n            getAssociatedValue().getType()->getPointerAddressSpace())) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    Value &V = getAssociatedValue();\n    if (!NullIsDefined &&\n        hasAttr({Attribute::NonNull, Attribute::Dereferenceable},\n                /* IgnoreSubsumingPositions */ false, &A)) {\n      indicateOptimisticFixpoint();\n      return;\n    }\n\n    if (isa<ConstantPointerNull>(V)) {\n      indicatePessimisticFixpoint();\n      return;\n    }\n\n    AANonNull::initialize(A);\n\n    bool CanBeNull, CanBeFreed;\n    if (V.getPointerDereferenceableBytes(A.getDataLayout(), CanBeNull,\n                                         CanBeFreed)) {\n      if (!CanBeNull) {\n        indicateOptimisticFixpoint();\n        return;\n      }\n    }\n\n    if (isa<GlobalValue>(&getAssociatedValue())) {\n      indicatePessimisticFixpoint();\n      return;\n    }\n\n    if (Instruction *CtxI = getCtxI())\n      followUsesInMBEC(*this, A, getState(), *CtxI);\n  }\n\n  /// See followUsesInMBEC\n  bool followUseInMBEC(Attributor &A, const Use *U, const Instruction *I,\n                       AANonNull::StateType &State) {\n    bool IsNonNull = false;\n    bool TrackUse = false;\n    getKnownNonNullAndDerefBytesForUse(A, *this, getAssociatedValue(), U, I,\n                                       IsNonNull, TrackUse);\n    State.setKnown(IsNonNull);\n    return TrackUse;\n  }\n\n  /// See AbstractAttribute::getAsStr().\n  const std::string getAsStr() const override {\n    return getAssumed() ? \"nonnull\" : \"may-null\";\n  }\n\n  /// Flag to determine if the underlying value can be null and still allow\n  /// valid accesses.\n  const bool NullIsDefined;\n};\n\n/// NonNull attribute for a floating value.\nstruct AANonNullFloating : public AANonNullImpl {\n  AANonNullFloating(const IRPosition &IRP, Attributor &A)\n      : AANonNullImpl(IRP, A) {}\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    const DataLayout &DL = A.getDataLayout();\n\n    DominatorTree *DT = nullptr;\n    AssumptionCache *AC = nullptr;\n    InformationCache &InfoCache = A.getInfoCache();\n    if (const Function *Fn = getAnchorScope()) {\n      DT = InfoCache.getAnalysisResultForFunction<DominatorTreeAnalysis>(*Fn);\n      AC = InfoCache.getAnalysisResultForFunction<AssumptionAnalysis>(*Fn);\n    }\n\n    auto VisitValueCB = [&](Value &V, const Instruction *CtxI,\n                            AANonNull::StateType &T, bool Stripped) -> bool {\n      const auto &AA = A.getAAFor<AANonNull>(*this, IRPosition::value(V),\n                                             DepClassTy::REQUIRED);\n      if (!Stripped && this == &AA) {\n        if (!isKnownNonZero(&V, DL, 0, AC, CtxI, DT))\n          T.indicatePessimisticFixpoint();\n      } else {\n        // Use abstract attribute information.\n        const AANonNull::StateType &NS = AA.getState();\n        T ^= NS;\n      }\n      return T.isValidState();\n    };\n\n    StateType T;\n    if (!genericValueTraversal<AANonNull, StateType>(\n            A, getIRPosition(), *this, T, VisitValueCB, getCtxI()))\n      return indicatePessimisticFixpoint();\n\n    return clampStateAndIndicateChange(getState(), T);\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_FNRET_ATTR(nonnull) }\n};\n\n/// NonNull attribute for function return value.\nstruct AANonNullReturned final\n    : AAReturnedFromReturnedValues<AANonNull, AANonNull> {\n  AANonNullReturned(const IRPosition &IRP, Attributor &A)\n      : AAReturnedFromReturnedValues<AANonNull, AANonNull>(IRP, A) {}\n\n  /// See AbstractAttribute::getAsStr().\n  const std::string getAsStr() const override {\n    return getAssumed() ? \"nonnull\" : \"may-null\";\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_FNRET_ATTR(nonnull) }\n};\n\n/// NonNull attribute for function argument.\nstruct AANonNullArgument final\n    : AAArgumentFromCallSiteArguments<AANonNull, AANonNullImpl> {\n  AANonNullArgument(const IRPosition &IRP, Attributor &A)\n      : AAArgumentFromCallSiteArguments<AANonNull, AANonNullImpl>(IRP, A) {}\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_ARG_ATTR(nonnull) }\n};\n\nstruct AANonNullCallSiteArgument final : AANonNullFloating {\n  AANonNullCallSiteArgument(const IRPosition &IRP, Attributor &A)\n      : AANonNullFloating(IRP, A) {}\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_CSARG_ATTR(nonnull) }\n};\n\n/// NonNull attribute for a call site return position.\nstruct AANonNullCallSiteReturned final\n    : AACallSiteReturnedFromReturned<AANonNull, AANonNullImpl> {\n  AANonNullCallSiteReturned(const IRPosition &IRP, Attributor &A)\n      : AACallSiteReturnedFromReturned<AANonNull, AANonNullImpl>(IRP, A) {}\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_CSRET_ATTR(nonnull) }\n};\n\n/// ------------------------ No-Recurse Attributes ----------------------------\n\nstruct AANoRecurseImpl : public AANoRecurse {\n  AANoRecurseImpl(const IRPosition &IRP, Attributor &A) : AANoRecurse(IRP, A) {}\n\n  /// See AbstractAttribute::getAsStr()\n  const std::string getAsStr() const override {\n    return getAssumed() ? \"norecurse\" : \"may-recurse\";\n  }\n};\n\nstruct AANoRecurseFunction final : AANoRecurseImpl {\n  AANoRecurseFunction(const IRPosition &IRP, Attributor &A)\n      : AANoRecurseImpl(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    AANoRecurseImpl::initialize(A);\n    if (const Function *F = getAnchorScope())\n      if (A.getInfoCache().getSccSize(*F) != 1)\n        indicatePessimisticFixpoint();\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n\n    // If all live call sites are known to be no-recurse, we are as well.\n    auto CallSitePred = [&](AbstractCallSite ACS) {\n      const auto &NoRecurseAA = A.getAAFor<AANoRecurse>(\n          *this, IRPosition::function(*ACS.getInstruction()->getFunction()),\n          DepClassTy::NONE);\n      return NoRecurseAA.isKnownNoRecurse();\n    };\n    bool AllCallSitesKnown;\n    if (A.checkForAllCallSites(CallSitePred, *this, true, AllCallSitesKnown)) {\n      // If we know all call sites and all are known no-recurse, we are done.\n      // If all known call sites, which might not be all that exist, are known\n      // to be no-recurse, we are not done but we can continue to assume\n      // no-recurse. If one of the call sites we have not visited will become\n      // live, another update is triggered.\n      if (AllCallSitesKnown)\n        indicateOptimisticFixpoint();\n      return ChangeStatus::UNCHANGED;\n    }\n\n    // If the above check does not hold anymore we look at the calls.\n    auto CheckForNoRecurse = [&](Instruction &I) {\n      const auto &CB = cast<CallBase>(I);\n      if (CB.hasFnAttr(Attribute::NoRecurse))\n        return true;\n\n      const auto &NoRecurseAA = A.getAAFor<AANoRecurse>(\n          *this, IRPosition::callsite_function(CB), DepClassTy::REQUIRED);\n      if (!NoRecurseAA.isAssumedNoRecurse())\n        return false;\n\n      // Recursion to the same function\n      if (CB.getCalledFunction() == getAnchorScope())\n        return false;\n\n      return true;\n    };\n\n    if (!A.checkForAllCallLikeInstructions(CheckForNoRecurse, *this))\n      return indicatePessimisticFixpoint();\n    return ChangeStatus::UNCHANGED;\n  }\n\n  void trackStatistics() const override { STATS_DECLTRACK_FN_ATTR(norecurse) }\n};\n\n/// NoRecurse attribute deduction for a call sites.\nstruct AANoRecurseCallSite final : AANoRecurseImpl {\n  AANoRecurseCallSite(const IRPosition &IRP, Attributor &A)\n      : AANoRecurseImpl(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    AANoRecurseImpl::initialize(A);\n    Function *F = getAssociatedFunction();\n    if (!F || F->isDeclaration())\n      indicatePessimisticFixpoint();\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    // TODO: Once we have call site specific value information we can provide\n    //       call site specific liveness information and then it makes\n    //       sense to specialize attributes for call sites arguments instead of\n    //       redirecting requests to the callee argument.\n    Function *F = getAssociatedFunction();\n    const IRPosition &FnPos = IRPosition::function(*F);\n    auto &FnAA = A.getAAFor<AANoRecurse>(*this, FnPos, DepClassTy::REQUIRED);\n    return clampStateAndIndicateChange(getState(), FnAA.getState());\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_CS_ATTR(norecurse); }\n};\n\n/// -------------------- Undefined-Behavior Attributes ------------------------\n\nstruct AAUndefinedBehaviorImpl : public AAUndefinedBehavior {\n  AAUndefinedBehaviorImpl(const IRPosition &IRP, Attributor &A)\n      : AAUndefinedBehavior(IRP, A) {}\n\n  /// See AbstractAttribute::updateImpl(...).\n  // through a pointer (i.e. also branches etc.)\n  ChangeStatus updateImpl(Attributor &A) override {\n    const size_t UBPrevSize = KnownUBInsts.size();\n    const size_t NoUBPrevSize = AssumedNoUBInsts.size();\n\n    auto InspectMemAccessInstForUB = [&](Instruction &I) {\n      // Skip instructions that are already saved.\n      if (AssumedNoUBInsts.count(&I) || KnownUBInsts.count(&I))\n        return true;\n\n      // If we reach here, we know we have an instruction\n      // that accesses memory through a pointer operand,\n      // for which getPointerOperand() should give it to us.\n      const Value *PtrOp = getPointerOperand(&I, /* AllowVolatile */ true);\n      assert(PtrOp &&\n             \"Expected pointer operand of memory accessing instruction\");\n\n      // Either we stopped and the appropriate action was taken,\n      // or we got back a simplified value to continue.\n      Optional<Value *> SimplifiedPtrOp = stopOnUndefOrAssumed(A, PtrOp, &I);\n      if (!SimplifiedPtrOp.hasValue())\n        return true;\n      const Value *PtrOpVal = SimplifiedPtrOp.getValue();\n\n      // A memory access through a pointer is considered UB\n      // only if the pointer has constant null value.\n      // TODO: Expand it to not only check constant values.\n      if (!isa<ConstantPointerNull>(PtrOpVal)) {\n        AssumedNoUBInsts.insert(&I);\n        return true;\n      }\n      const Type *PtrTy = PtrOpVal->getType();\n\n      // Because we only consider instructions inside functions,\n      // assume that a parent function exists.\n      const Function *F = I.getFunction();\n\n      // A memory access using constant null pointer is only considered UB\n      // if null pointer is _not_ defined for the target platform.\n      if (llvm::NullPointerIsDefined(F, PtrTy->getPointerAddressSpace()))\n        AssumedNoUBInsts.insert(&I);\n      else\n        KnownUBInsts.insert(&I);\n      return true;\n    };\n\n    auto InspectBrInstForUB = [&](Instruction &I) {\n      // A conditional branch instruction is considered UB if it has `undef`\n      // condition.\n\n      // Skip instructions that are already saved.\n      if (AssumedNoUBInsts.count(&I) || KnownUBInsts.count(&I))\n        return true;\n\n      // We know we have a branch instruction.\n      auto BrInst = cast<BranchInst>(&I);\n\n      // Unconditional branches are never considered UB.\n      if (BrInst->isUnconditional())\n        return true;\n\n      // Either we stopped and the appropriate action was taken,\n      // or we got back a simplified value to continue.\n      Optional<Value *> SimplifiedCond =\n          stopOnUndefOrAssumed(A, BrInst->getCondition(), BrInst);\n      if (!SimplifiedCond.hasValue())\n        return true;\n      AssumedNoUBInsts.insert(&I);\n      return true;\n    };\n\n    auto InspectCallSiteForUB = [&](Instruction &I) {\n      // Check whether a callsite always cause UB or not\n\n      // Skip instructions that are already saved.\n      if (AssumedNoUBInsts.count(&I) || KnownUBInsts.count(&I))\n        return true;\n\n      // Check nonnull and noundef argument attribute violation for each\n      // callsite.\n      CallBase &CB = cast<CallBase>(I);\n      Function *Callee = CB.getCalledFunction();\n      if (!Callee)\n        return true;\n      for (unsigned idx = 0; idx < CB.getNumArgOperands(); idx++) {\n        // If current argument is known to be simplified to null pointer and the\n        // corresponding argument position is known to have nonnull attribute,\n        // the argument is poison. Furthermore, if the argument is poison and\n        // the position is known to have noundef attriubte, this callsite is\n        // considered UB.\n        if (idx >= Callee->arg_size())\n          break;\n        Value *ArgVal = CB.getArgOperand(idx);\n        if (!ArgVal)\n          continue;\n        // Here, we handle three cases.\n        //   (1) Not having a value means it is dead. (we can replace the value\n        //       with undef)\n        //   (2) Simplified to undef. The argument violate noundef attriubte.\n        //   (3) Simplified to null pointer where known to be nonnull.\n        //       The argument is a poison value and violate noundef attribute.\n        IRPosition CalleeArgumentIRP = IRPosition::callsite_argument(CB, idx);\n        auto &NoUndefAA =\n            A.getAAFor<AANoUndef>(*this, CalleeArgumentIRP, DepClassTy::NONE);\n        if (!NoUndefAA.isKnownNoUndef())\n          continue;\n        auto &ValueSimplifyAA = A.getAAFor<AAValueSimplify>(\n            *this, IRPosition::value(*ArgVal), DepClassTy::NONE);\n        if (!ValueSimplifyAA.isKnown())\n          continue;\n        Optional<Value *> SimplifiedVal =\n            ValueSimplifyAA.getAssumedSimplifiedValue(A);\n        if (!SimplifiedVal.hasValue() ||\n            isa<UndefValue>(*SimplifiedVal.getValue())) {\n          KnownUBInsts.insert(&I);\n          continue;\n        }\n        if (!ArgVal->getType()->isPointerTy() ||\n            !isa<ConstantPointerNull>(*SimplifiedVal.getValue()))\n          continue;\n        auto &NonNullAA =\n            A.getAAFor<AANonNull>(*this, CalleeArgumentIRP, DepClassTy::NONE);\n        if (NonNullAA.isKnownNonNull())\n          KnownUBInsts.insert(&I);\n      }\n      return true;\n    };\n\n    auto InspectReturnInstForUB =\n        [&](Value &V, const SmallSetVector<ReturnInst *, 4> RetInsts) {\n          // Check if a return instruction always cause UB or not\n          // Note: It is guaranteed that the returned position of the anchor\n          //       scope has noundef attribute when this is called.\n          //       We also ensure the return position is not \"assumed dead\"\n          //       because the returned value was then potentially simplified to\n          //       `undef` in AAReturnedValues without removing the `noundef`\n          //       attribute yet.\n\n          // When the returned position has noundef attriubte, UB occur in the\n          // following cases.\n          //   (1) Returned value is known to be undef.\n          //   (2) The value is known to be a null pointer and the returned\n          //       position has nonnull attribute (because the returned value is\n          //       poison).\n          bool FoundUB = false;\n          if (isa<UndefValue>(V)) {\n            FoundUB = true;\n          } else {\n            if (isa<ConstantPointerNull>(V)) {\n              auto &NonNullAA = A.getAAFor<AANonNull>(\n                  *this, IRPosition::returned(*getAnchorScope()),\n                  DepClassTy::NONE);\n              if (NonNullAA.isKnownNonNull())\n                FoundUB = true;\n            }\n          }\n\n          if (FoundUB)\n            for (ReturnInst *RI : RetInsts)\n              KnownUBInsts.insert(RI);\n          return true;\n        };\n\n    A.checkForAllInstructions(InspectMemAccessInstForUB, *this,\n                              {Instruction::Load, Instruction::Store,\n                               Instruction::AtomicCmpXchg,\n                               Instruction::AtomicRMW},\n                              /* CheckBBLivenessOnly */ true);\n    A.checkForAllInstructions(InspectBrInstForUB, *this, {Instruction::Br},\n                              /* CheckBBLivenessOnly */ true);\n    A.checkForAllCallLikeInstructions(InspectCallSiteForUB, *this);\n\n    // If the returned position of the anchor scope has noundef attriubte, check\n    // all returned instructions.\n    if (!getAnchorScope()->getReturnType()->isVoidTy()) {\n      const IRPosition &ReturnIRP = IRPosition::returned(*getAnchorScope());\n      if (!A.isAssumedDead(ReturnIRP, this, nullptr)) {\n        auto &RetPosNoUndefAA =\n            A.getAAFor<AANoUndef>(*this, ReturnIRP, DepClassTy::NONE);\n        if (RetPosNoUndefAA.isKnownNoUndef())\n          A.checkForAllReturnedValuesAndReturnInsts(InspectReturnInstForUB,\n                                                    *this);\n      }\n    }\n\n    if (NoUBPrevSize != AssumedNoUBInsts.size() ||\n        UBPrevSize != KnownUBInsts.size())\n      return ChangeStatus::CHANGED;\n    return ChangeStatus::UNCHANGED;\n  }\n\n  bool isKnownToCauseUB(Instruction *I) const override {\n    return KnownUBInsts.count(I);\n  }\n\n  bool isAssumedToCauseUB(Instruction *I) const override {\n    // In simple words, if an instruction is not in the assumed to _not_\n    // cause UB, then it is assumed UB (that includes those\n    // in the KnownUBInsts set). The rest is boilerplate\n    // is to ensure that it is one of the instructions we test\n    // for UB.\n\n    switch (I->getOpcode()) {\n    case Instruction::Load:\n    case Instruction::Store:\n    case Instruction::AtomicCmpXchg:\n    case Instruction::AtomicRMW:\n      return !AssumedNoUBInsts.count(I);\n    case Instruction::Br: {\n      auto BrInst = cast<BranchInst>(I);\n      if (BrInst->isUnconditional())\n        return false;\n      return !AssumedNoUBInsts.count(I);\n    } break;\n    default:\n      return false;\n    }\n    return false;\n  }\n\n  ChangeStatus manifest(Attributor &A) override {\n    if (KnownUBInsts.empty())\n      return ChangeStatus::UNCHANGED;\n    for (Instruction *I : KnownUBInsts)\n      A.changeToUnreachableAfterManifest(I);\n    return ChangeStatus::CHANGED;\n  }\n\n  /// See AbstractAttribute::getAsStr()\n  const std::string getAsStr() const override {\n    return getAssumed() ? \"undefined-behavior\" : \"no-ub\";\n  }\n\n  /// Note: The correctness of this analysis depends on the fact that the\n  /// following 2 sets will stop changing after some point.\n  /// \"Change\" here means that their size changes.\n  /// The size of each set is monotonically increasing\n  /// (we only add items to them) and it is upper bounded by the number of\n  /// instructions in the processed function (we can never save more\n  /// elements in either set than this number). Hence, at some point,\n  /// they will stop increasing.\n  /// Consequently, at some point, both sets will have stopped\n  /// changing, effectively making the analysis reach a fixpoint.\n\n  /// Note: These 2 sets are disjoint and an instruction can be considered\n  /// one of 3 things:\n  /// 1) Known to cause UB (AAUndefinedBehavior could prove it) and put it in\n  ///    the KnownUBInsts set.\n  /// 2) Assumed to cause UB (in every updateImpl, AAUndefinedBehavior\n  ///    has a reason to assume it).\n  /// 3) Assumed to not cause UB. very other instruction - AAUndefinedBehavior\n  ///    could not find a reason to assume or prove that it can cause UB,\n  ///    hence it assumes it doesn't. We have a set for these instructions\n  ///    so that we don't reprocess them in every update.\n  ///    Note however that instructions in this set may cause UB.\n\nprotected:\n  /// A set of all live instructions _known_ to cause UB.\n  SmallPtrSet<Instruction *, 8> KnownUBInsts;\n\nprivate:\n  /// A set of all the (live) instructions that are assumed to _not_ cause UB.\n  SmallPtrSet<Instruction *, 8> AssumedNoUBInsts;\n\n  // Should be called on updates in which if we're processing an instruction\n  // \\p I that depends on a value \\p V, one of the following has to happen:\n  // - If the value is assumed, then stop.\n  // - If the value is known but undef, then consider it UB.\n  // - Otherwise, do specific processing with the simplified value.\n  // We return None in the first 2 cases to signify that an appropriate\n  // action was taken and the caller should stop.\n  // Otherwise, we return the simplified value that the caller should\n  // use for specific processing.\n  Optional<Value *> stopOnUndefOrAssumed(Attributor &A, const Value *V,\n                                         Instruction *I) {\n    const auto &ValueSimplifyAA = A.getAAFor<AAValueSimplify>(\n        *this, IRPosition::value(*V), DepClassTy::REQUIRED);\n    Optional<Value *> SimplifiedV =\n        ValueSimplifyAA.getAssumedSimplifiedValue(A);\n    if (!ValueSimplifyAA.isKnown()) {\n      // Don't depend on assumed values.\n      return llvm::None;\n    }\n    if (!SimplifiedV.hasValue()) {\n      // If it is known (which we tested above) but it doesn't have a value,\n      // then we can assume `undef` and hence the instruction is UB.\n      KnownUBInsts.insert(I);\n      return llvm::None;\n    }\n    Value *Val = SimplifiedV.getValue();\n    if (isa<UndefValue>(Val)) {\n      KnownUBInsts.insert(I);\n      return llvm::None;\n    }\n    return Val;\n  }\n};\n\nstruct AAUndefinedBehaviorFunction final : AAUndefinedBehaviorImpl {\n  AAUndefinedBehaviorFunction(const IRPosition &IRP, Attributor &A)\n      : AAUndefinedBehaviorImpl(IRP, A) {}\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    STATS_DECL(UndefinedBehaviorInstruction, Instruction,\n               \"Number of instructions known to have UB\");\n    BUILD_STAT_NAME(UndefinedBehaviorInstruction, Instruction) +=\n        KnownUBInsts.size();\n  }\n};\n\n/// ------------------------ Will-Return Attributes ----------------------------\n\n// Helper function that checks whether a function has any cycle which we don't\n// know if it is bounded or not.\n// Loops with maximum trip count are considered bounded, any other cycle not.\nstatic bool mayContainUnboundedCycle(Function &F, Attributor &A) {\n  ScalarEvolution *SE =\n      A.getInfoCache().getAnalysisResultForFunction<ScalarEvolutionAnalysis>(F);\n  LoopInfo *LI = A.getInfoCache().getAnalysisResultForFunction<LoopAnalysis>(F);\n  // If either SCEV or LoopInfo is not available for the function then we assume\n  // any cycle to be unbounded cycle.\n  // We use scc_iterator which uses Tarjan algorithm to find all the maximal\n  // SCCs.To detect if there's a cycle, we only need to find the maximal ones.\n  if (!SE || !LI) {\n    for (scc_iterator<Function *> SCCI = scc_begin(&F); !SCCI.isAtEnd(); ++SCCI)\n      if (SCCI.hasCycle())\n        return true;\n    return false;\n  }\n\n  // If there's irreducible control, the function may contain non-loop cycles.\n  if (mayContainIrreducibleControl(F, LI))\n    return true;\n\n  // Any loop that does not have a max trip count is considered unbounded cycle.\n  for (auto *L : LI->getLoopsInPreorder()) {\n    if (!SE->getSmallConstantMaxTripCount(L))\n      return true;\n  }\n  return false;\n}\n\nstruct AAWillReturnImpl : public AAWillReturn {\n  AAWillReturnImpl(const IRPosition &IRP, Attributor &A)\n      : AAWillReturn(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    AAWillReturn::initialize(A);\n\n    if (isImpliedByMustprogressAndReadonly(A, /* KnownOnly */ true)) {\n      indicateOptimisticFixpoint();\n      return;\n    }\n  }\n\n  /// Check for `mustprogress` and `readonly` as they imply `willreturn`.\n  bool isImpliedByMustprogressAndReadonly(Attributor &A, bool KnownOnly) {\n    // Check for `mustprogress` in the scope and the associated function which\n    // might be different if this is a call site.\n    if ((!getAnchorScope() || !getAnchorScope()->mustProgress()) &&\n        (!getAssociatedFunction() || !getAssociatedFunction()->mustProgress()))\n      return false;\n\n    const auto &MemAA = A.getAAFor<AAMemoryBehavior>(*this, getIRPosition(),\n                                                      DepClassTy::NONE);\n    if (!MemAA.isAssumedReadOnly())\n      return false;\n    if (KnownOnly && !MemAA.isKnownReadOnly())\n      return false;\n    if (!MemAA.isKnownReadOnly())\n      A.recordDependence(MemAA, *this, DepClassTy::OPTIONAL);\n\n    return true;\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    if (isImpliedByMustprogressAndReadonly(A, /* KnownOnly */ false))\n      return ChangeStatus::UNCHANGED;\n\n    auto CheckForWillReturn = [&](Instruction &I) {\n      IRPosition IPos = IRPosition::callsite_function(cast<CallBase>(I));\n      const auto &WillReturnAA =\n          A.getAAFor<AAWillReturn>(*this, IPos, DepClassTy::REQUIRED);\n      if (WillReturnAA.isKnownWillReturn())\n        return true;\n      if (!WillReturnAA.isAssumedWillReturn())\n        return false;\n      const auto &NoRecurseAA =\n          A.getAAFor<AANoRecurse>(*this, IPos, DepClassTy::REQUIRED);\n      return NoRecurseAA.isAssumedNoRecurse();\n    };\n\n    if (!A.checkForAllCallLikeInstructions(CheckForWillReturn, *this))\n      return indicatePessimisticFixpoint();\n\n    return ChangeStatus::UNCHANGED;\n  }\n\n  /// See AbstractAttribute::getAsStr()\n  const std::string getAsStr() const override {\n    return getAssumed() ? \"willreturn\" : \"may-noreturn\";\n  }\n};\n\nstruct AAWillReturnFunction final : AAWillReturnImpl {\n  AAWillReturnFunction(const IRPosition &IRP, Attributor &A)\n      : AAWillReturnImpl(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    AAWillReturnImpl::initialize(A);\n\n    Function *F = getAnchorScope();\n    if (!F || F->isDeclaration() || mayContainUnboundedCycle(*F, A))\n      indicatePessimisticFixpoint();\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_FN_ATTR(willreturn) }\n};\n\n/// WillReturn attribute deduction for a call sites.\nstruct AAWillReturnCallSite final : AAWillReturnImpl {\n  AAWillReturnCallSite(const IRPosition &IRP, Attributor &A)\n      : AAWillReturnImpl(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    AAWillReturnImpl::initialize(A);\n    Function *F = getAssociatedFunction();\n    if (!F || !A.isFunctionIPOAmendable(*F))\n      indicatePessimisticFixpoint();\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    if (isImpliedByMustprogressAndReadonly(A, /* KnownOnly */ false))\n      return ChangeStatus::UNCHANGED;\n\n    // TODO: Once we have call site specific value information we can provide\n    //       call site specific liveness information and then it makes\n    //       sense to specialize attributes for call sites arguments instead of\n    //       redirecting requests to the callee argument.\n    Function *F = getAssociatedFunction();\n    const IRPosition &FnPos = IRPosition::function(*F);\n    auto &FnAA = A.getAAFor<AAWillReturn>(*this, FnPos, DepClassTy::REQUIRED);\n    return clampStateAndIndicateChange(getState(), FnAA.getState());\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_CS_ATTR(willreturn); }\n};\n\n/// -------------------AAReachability Attribute--------------------------\n\nstruct AAReachabilityImpl : AAReachability {\n  AAReachabilityImpl(const IRPosition &IRP, Attributor &A)\n      : AAReachability(IRP, A) {}\n\n  const std::string getAsStr() const override {\n    // TODO: Return the number of reachable queries.\n    return \"reachable\";\n  }\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override { indicatePessimisticFixpoint(); }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    return indicatePessimisticFixpoint();\n  }\n};\n\nstruct AAReachabilityFunction final : public AAReachabilityImpl {\n  AAReachabilityFunction(const IRPosition &IRP, Attributor &A)\n      : AAReachabilityImpl(IRP, A) {}\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_FN_ATTR(reachable); }\n};\n\n/// ------------------------ NoAlias Argument Attribute ------------------------\n\nstruct AANoAliasImpl : AANoAlias {\n  AANoAliasImpl(const IRPosition &IRP, Attributor &A) : AANoAlias(IRP, A) {\n    assert(getAssociatedType()->isPointerTy() &&\n           \"Noalias is a pointer attribute\");\n  }\n\n  const std::string getAsStr() const override {\n    return getAssumed() ? \"noalias\" : \"may-alias\";\n  }\n};\n\n/// NoAlias attribute for a floating value.\nstruct AANoAliasFloating final : AANoAliasImpl {\n  AANoAliasFloating(const IRPosition &IRP, Attributor &A)\n      : AANoAliasImpl(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    AANoAliasImpl::initialize(A);\n    Value *Val = &getAssociatedValue();\n    do {\n      CastInst *CI = dyn_cast<CastInst>(Val);\n      if (!CI)\n        break;\n      Value *Base = CI->getOperand(0);\n      if (!Base->hasOneUse())\n        break;\n      Val = Base;\n    } while (true);\n\n    if (!Val->getType()->isPointerTy()) {\n      indicatePessimisticFixpoint();\n      return;\n    }\n\n    if (isa<AllocaInst>(Val))\n      indicateOptimisticFixpoint();\n    else if (isa<ConstantPointerNull>(Val) &&\n             !NullPointerIsDefined(getAnchorScope(),\n                                   Val->getType()->getPointerAddressSpace()))\n      indicateOptimisticFixpoint();\n    else if (Val != &getAssociatedValue()) {\n      const auto &ValNoAliasAA = A.getAAFor<AANoAlias>(\n          *this, IRPosition::value(*Val), DepClassTy::OPTIONAL);\n      if (ValNoAliasAA.isKnownNoAlias())\n        indicateOptimisticFixpoint();\n    }\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    // TODO: Implement this.\n    return indicatePessimisticFixpoint();\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    STATS_DECLTRACK_FLOATING_ATTR(noalias)\n  }\n};\n\n/// NoAlias attribute for an argument.\nstruct AANoAliasArgument final\n    : AAArgumentFromCallSiteArguments<AANoAlias, AANoAliasImpl> {\n  using Base = AAArgumentFromCallSiteArguments<AANoAlias, AANoAliasImpl>;\n  AANoAliasArgument(const IRPosition &IRP, Attributor &A) : Base(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    Base::initialize(A);\n    // See callsite argument attribute and callee argument attribute.\n    if (hasAttr({Attribute::ByVal}))\n      indicateOptimisticFixpoint();\n  }\n\n  /// See AbstractAttribute::update(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    // We have to make sure no-alias on the argument does not break\n    // synchronization when this is a callback argument, see also [1] below.\n    // If synchronization cannot be affected, we delegate to the base updateImpl\n    // function, otherwise we give up for now.\n\n    // If the function is no-sync, no-alias cannot break synchronization.\n    const auto &NoSyncAA =\n        A.getAAFor<AANoSync>(*this, IRPosition::function_scope(getIRPosition()),\n                             DepClassTy::OPTIONAL);\n    if (NoSyncAA.isAssumedNoSync())\n      return Base::updateImpl(A);\n\n    // If the argument is read-only, no-alias cannot break synchronization.\n    const auto &MemBehaviorAA = A.getAAFor<AAMemoryBehavior>(\n        *this, getIRPosition(), DepClassTy::OPTIONAL);\n    if (MemBehaviorAA.isAssumedReadOnly())\n      return Base::updateImpl(A);\n\n    // If the argument is never passed through callbacks, no-alias cannot break\n    // synchronization.\n    bool AllCallSitesKnown;\n    if (A.checkForAllCallSites(\n            [](AbstractCallSite ACS) { return !ACS.isCallbackCall(); }, *this,\n            true, AllCallSitesKnown))\n      return Base::updateImpl(A);\n\n    // TODO: add no-alias but make sure it doesn't break synchronization by\n    // introducing fake uses. See:\n    // [1] Compiler Optimizations for OpenMP, J. Doerfert and H. Finkel,\n    //     International Workshop on OpenMP 2018,\n    //     http://compilers.cs.uni-saarland.de/people/doerfert/par_opt18.pdf\n\n    return indicatePessimisticFixpoint();\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_ARG_ATTR(noalias) }\n};\n\nstruct AANoAliasCallSiteArgument final : AANoAliasImpl {\n  AANoAliasCallSiteArgument(const IRPosition &IRP, Attributor &A)\n      : AANoAliasImpl(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    // See callsite argument attribute and callee argument attribute.\n    const auto &CB = cast<CallBase>(getAnchorValue());\n    if (CB.paramHasAttr(getCallSiteArgNo(), Attribute::NoAlias))\n      indicateOptimisticFixpoint();\n    Value &Val = getAssociatedValue();\n    if (isa<ConstantPointerNull>(Val) &&\n        !NullPointerIsDefined(getAnchorScope(),\n                              Val.getType()->getPointerAddressSpace()))\n      indicateOptimisticFixpoint();\n  }\n\n  /// Determine if the underlying value may alias with the call site argument\n  /// \\p OtherArgNo of \\p ICS (= the underlying call site).\n  bool mayAliasWithArgument(Attributor &A, AAResults *&AAR,\n                            const AAMemoryBehavior &MemBehaviorAA,\n                            const CallBase &CB, unsigned OtherArgNo) {\n    // We do not need to worry about aliasing with the underlying IRP.\n    if (this->getCalleeArgNo() == (int)OtherArgNo)\n      return false;\n\n    // If it is not a pointer or pointer vector we do not alias.\n    const Value *ArgOp = CB.getArgOperand(OtherArgNo);\n    if (!ArgOp->getType()->isPtrOrPtrVectorTy())\n      return false;\n\n    auto &CBArgMemBehaviorAA = A.getAAFor<AAMemoryBehavior>(\n        *this, IRPosition::callsite_argument(CB, OtherArgNo), DepClassTy::NONE);\n\n    // If the argument is readnone, there is no read-write aliasing.\n    if (CBArgMemBehaviorAA.isAssumedReadNone()) {\n      A.recordDependence(CBArgMemBehaviorAA, *this, DepClassTy::OPTIONAL);\n      return false;\n    }\n\n    // If the argument is readonly and the underlying value is readonly, there\n    // is no read-write aliasing.\n    bool IsReadOnly = MemBehaviorAA.isAssumedReadOnly();\n    if (CBArgMemBehaviorAA.isAssumedReadOnly() && IsReadOnly) {\n      A.recordDependence(MemBehaviorAA, *this, DepClassTy::OPTIONAL);\n      A.recordDependence(CBArgMemBehaviorAA, *this, DepClassTy::OPTIONAL);\n      return false;\n    }\n\n    // We have to utilize actual alias analysis queries so we need the object.\n    if (!AAR)\n      AAR = A.getInfoCache().getAAResultsForFunction(*getAnchorScope());\n\n    // Try to rule it out at the call site.\n    bool IsAliasing = !AAR || !AAR->isNoAlias(&getAssociatedValue(), ArgOp);\n    LLVM_DEBUG(dbgs() << \"[NoAliasCSArg] Check alias between \"\n                         \"callsite arguments: \"\n                      << getAssociatedValue() << \" \" << *ArgOp << \" => \"\n                      << (IsAliasing ? \"\" : \"no-\") << \"alias \\n\");\n\n    return IsAliasing;\n  }\n\n  bool\n  isKnownNoAliasDueToNoAliasPreservation(Attributor &A, AAResults *&AAR,\n                                         const AAMemoryBehavior &MemBehaviorAA,\n                                         const AANoAlias &NoAliasAA) {\n    // We can deduce \"noalias\" if the following conditions hold.\n    // (i)   Associated value is assumed to be noalias in the definition.\n    // (ii)  Associated value is assumed to be no-capture in all the uses\n    //       possibly executed before this callsite.\n    // (iii) There is no other pointer argument which could alias with the\n    //       value.\n\n    bool AssociatedValueIsNoAliasAtDef = NoAliasAA.isAssumedNoAlias();\n    if (!AssociatedValueIsNoAliasAtDef) {\n      LLVM_DEBUG(dbgs() << \"[AANoAlias] \" << getAssociatedValue()\n                        << \" is not no-alias at the definition\\n\");\n      return false;\n    }\n\n    A.recordDependence(NoAliasAA, *this, DepClassTy::OPTIONAL);\n\n    const IRPosition &VIRP = IRPosition::value(getAssociatedValue());\n    const Function *ScopeFn = VIRP.getAnchorScope();\n    auto &NoCaptureAA = A.getAAFor<AANoCapture>(*this, VIRP, DepClassTy::NONE);\n    // Check whether the value is captured in the scope using AANoCapture.\n    //      Look at CFG and check only uses possibly executed before this\n    //      callsite.\n    auto UsePred = [&](const Use &U, bool &Follow) -> bool {\n      Instruction *UserI = cast<Instruction>(U.getUser());\n\n      // If UserI is the curr instruction and there is a single potential use of\n      // the value in UserI we allow the use.\n      // TODO: We should inspect the operands and allow those that cannot alias\n      //       with the value.\n      if (UserI == getCtxI() && UserI->getNumOperands() == 1)\n        return true;\n\n      if (ScopeFn) {\n        const auto &ReachabilityAA = A.getAAFor<AAReachability>(\n            *this, IRPosition::function(*ScopeFn), DepClassTy::OPTIONAL);\n\n        if (!ReachabilityAA.isAssumedReachable(A, *UserI, *getCtxI()))\n          return true;\n\n        if (auto *CB = dyn_cast<CallBase>(UserI)) {\n          if (CB->isArgOperand(&U)) {\n\n            unsigned ArgNo = CB->getArgOperandNo(&U);\n\n            const auto &NoCaptureAA = A.getAAFor<AANoCapture>(\n                *this, IRPosition::callsite_argument(*CB, ArgNo),\n                DepClassTy::OPTIONAL);\n\n            if (NoCaptureAA.isAssumedNoCapture())\n              return true;\n          }\n        }\n      }\n\n      // For cases which can potentially have more users\n      if (isa<GetElementPtrInst>(U) || isa<BitCastInst>(U) || isa<PHINode>(U) ||\n          isa<SelectInst>(U)) {\n        Follow = true;\n        return true;\n      }\n\n      LLVM_DEBUG(dbgs() << \"[AANoAliasCSArg] Unknown user: \" << *U << \"\\n\");\n      return false;\n    };\n\n    if (!NoCaptureAA.isAssumedNoCaptureMaybeReturned()) {\n      if (!A.checkForAllUses(UsePred, *this, getAssociatedValue())) {\n        LLVM_DEBUG(\n            dbgs() << \"[AANoAliasCSArg] \" << getAssociatedValue()\n                   << \" cannot be noalias as it is potentially captured\\n\");\n        return false;\n      }\n    }\n    A.recordDependence(NoCaptureAA, *this, DepClassTy::OPTIONAL);\n\n    // Check there is no other pointer argument which could alias with the\n    // value passed at this call site.\n    // TODO: AbstractCallSite\n    const auto &CB = cast<CallBase>(getAnchorValue());\n    for (unsigned OtherArgNo = 0; OtherArgNo < CB.getNumArgOperands();\n         OtherArgNo++)\n      if (mayAliasWithArgument(A, AAR, MemBehaviorAA, CB, OtherArgNo))\n        return false;\n\n    return true;\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    // If the argument is readnone we are done as there are no accesses via the\n    // argument.\n    auto &MemBehaviorAA =\n        A.getAAFor<AAMemoryBehavior>(*this, getIRPosition(), DepClassTy::NONE);\n    if (MemBehaviorAA.isAssumedReadNone()) {\n      A.recordDependence(MemBehaviorAA, *this, DepClassTy::OPTIONAL);\n      return ChangeStatus::UNCHANGED;\n    }\n\n    const IRPosition &VIRP = IRPosition::value(getAssociatedValue());\n    const auto &NoAliasAA =\n        A.getAAFor<AANoAlias>(*this, VIRP, DepClassTy::NONE);\n\n    AAResults *AAR = nullptr;\n    if (isKnownNoAliasDueToNoAliasPreservation(A, AAR, MemBehaviorAA,\n                                               NoAliasAA)) {\n      LLVM_DEBUG(\n          dbgs() << \"[AANoAlias] No-Alias deduced via no-alias preservation\\n\");\n      return ChangeStatus::UNCHANGED;\n    }\n\n    return indicatePessimisticFixpoint();\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_CSARG_ATTR(noalias) }\n};\n\n/// NoAlias attribute for function return value.\nstruct AANoAliasReturned final : AANoAliasImpl {\n  AANoAliasReturned(const IRPosition &IRP, Attributor &A)\n      : AANoAliasImpl(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    AANoAliasImpl::initialize(A);\n    Function *F = getAssociatedFunction();\n    if (!F || F->isDeclaration())\n      indicatePessimisticFixpoint();\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  virtual ChangeStatus updateImpl(Attributor &A) override {\n\n    auto CheckReturnValue = [&](Value &RV) -> bool {\n      if (Constant *C = dyn_cast<Constant>(&RV))\n        if (C->isNullValue() || isa<UndefValue>(C))\n          return true;\n\n      /// For now, we can only deduce noalias if we have call sites.\n      /// FIXME: add more support.\n      if (!isa<CallBase>(&RV))\n        return false;\n\n      const IRPosition &RVPos = IRPosition::value(RV);\n      const auto &NoAliasAA =\n          A.getAAFor<AANoAlias>(*this, RVPos, DepClassTy::REQUIRED);\n      if (!NoAliasAA.isAssumedNoAlias())\n        return false;\n\n      const auto &NoCaptureAA =\n          A.getAAFor<AANoCapture>(*this, RVPos, DepClassTy::REQUIRED);\n      return NoCaptureAA.isAssumedNoCaptureMaybeReturned();\n    };\n\n    if (!A.checkForAllReturnedValues(CheckReturnValue, *this))\n      return indicatePessimisticFixpoint();\n\n    return ChangeStatus::UNCHANGED;\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_FNRET_ATTR(noalias) }\n};\n\n/// NoAlias attribute deduction for a call site return value.\nstruct AANoAliasCallSiteReturned final : AANoAliasImpl {\n  AANoAliasCallSiteReturned(const IRPosition &IRP, Attributor &A)\n      : AANoAliasImpl(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    AANoAliasImpl::initialize(A);\n    Function *F = getAssociatedFunction();\n    if (!F || F->isDeclaration())\n      indicatePessimisticFixpoint();\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    // TODO: Once we have call site specific value information we can provide\n    //       call site specific liveness information and then it makes\n    //       sense to specialize attributes for call sites arguments instead of\n    //       redirecting requests to the callee argument.\n    Function *F = getAssociatedFunction();\n    const IRPosition &FnPos = IRPosition::returned(*F);\n    auto &FnAA = A.getAAFor<AANoAlias>(*this, FnPos, DepClassTy::REQUIRED);\n    return clampStateAndIndicateChange(getState(), FnAA.getState());\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_CSRET_ATTR(noalias); }\n};\n\n/// -------------------AAIsDead Function Attribute-----------------------\n\nstruct AAIsDeadValueImpl : public AAIsDead {\n  AAIsDeadValueImpl(const IRPosition &IRP, Attributor &A) : AAIsDead(IRP, A) {}\n\n  /// See AAIsDead::isAssumedDead().\n  bool isAssumedDead() const override { return getAssumed(); }\n\n  /// See AAIsDead::isKnownDead().\n  bool isKnownDead() const override { return getKnown(); }\n\n  /// See AAIsDead::isAssumedDead(BasicBlock *).\n  bool isAssumedDead(const BasicBlock *BB) const override { return false; }\n\n  /// See AAIsDead::isKnownDead(BasicBlock *).\n  bool isKnownDead(const BasicBlock *BB) const override { return false; }\n\n  /// See AAIsDead::isAssumedDead(Instruction *I).\n  bool isAssumedDead(const Instruction *I) const override {\n    return I == getCtxI() && isAssumedDead();\n  }\n\n  /// See AAIsDead::isKnownDead(Instruction *I).\n  bool isKnownDead(const Instruction *I) const override {\n    return isAssumedDead(I) && getKnown();\n  }\n\n  /// See AbstractAttribute::getAsStr().\n  const std::string getAsStr() const override {\n    return isAssumedDead() ? \"assumed-dead\" : \"assumed-live\";\n  }\n\n  /// Check if all uses are assumed dead.\n  bool areAllUsesAssumedDead(Attributor &A, Value &V) {\n    auto UsePred = [&](const Use &U, bool &Follow) { return false; };\n    // Explicitly set the dependence class to required because we want a long\n    // chain of N dependent instructions to be considered live as soon as one is\n    // without going through N update cycles. This is not required for\n    // correctness.\n    return A.checkForAllUses(UsePred, *this, V, DepClassTy::REQUIRED);\n  }\n\n  /// Determine if \\p I is assumed to be side-effect free.\n  bool isAssumedSideEffectFree(Attributor &A, Instruction *I) {\n    if (!I || wouldInstructionBeTriviallyDead(I))\n      return true;\n\n    auto *CB = dyn_cast<CallBase>(I);\n    if (!CB || isa<IntrinsicInst>(CB))\n      return false;\n\n    const IRPosition &CallIRP = IRPosition::callsite_function(*CB);\n    const auto &NoUnwindAA =\n        A.getAndUpdateAAFor<AANoUnwind>(*this, CallIRP, DepClassTy::NONE);\n    if (!NoUnwindAA.isAssumedNoUnwind())\n      return false;\n    if (!NoUnwindAA.isKnownNoUnwind())\n      A.recordDependence(NoUnwindAA, *this, DepClassTy::OPTIONAL);\n\n    const auto &MemBehaviorAA =\n        A.getAndUpdateAAFor<AAMemoryBehavior>(*this, CallIRP, DepClassTy::NONE);\n    if (MemBehaviorAA.isAssumedReadOnly()) {\n      if (!MemBehaviorAA.isKnownReadOnly())\n        A.recordDependence(MemBehaviorAA, *this, DepClassTy::OPTIONAL);\n      return true;\n    }\n    return false;\n  }\n};\n\nstruct AAIsDeadFloating : public AAIsDeadValueImpl {\n  AAIsDeadFloating(const IRPosition &IRP, Attributor &A)\n      : AAIsDeadValueImpl(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    if (isa<UndefValue>(getAssociatedValue())) {\n      indicatePessimisticFixpoint();\n      return;\n    }\n\n    Instruction *I = dyn_cast<Instruction>(&getAssociatedValue());\n    if (!isAssumedSideEffectFree(A, I))\n      indicatePessimisticFixpoint();\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    Instruction *I = dyn_cast<Instruction>(&getAssociatedValue());\n    if (!isAssumedSideEffectFree(A, I))\n      return indicatePessimisticFixpoint();\n\n    if (!areAllUsesAssumedDead(A, getAssociatedValue()))\n      return indicatePessimisticFixpoint();\n    return ChangeStatus::UNCHANGED;\n  }\n\n  /// See AbstractAttribute::manifest(...).\n  ChangeStatus manifest(Attributor &A) override {\n    Value &V = getAssociatedValue();\n    if (auto *I = dyn_cast<Instruction>(&V)) {\n      // If we get here we basically know the users are all dead. We check if\n      // isAssumedSideEffectFree returns true here again because it might not be\n      // the case and only the users are dead but the instruction (=call) is\n      // still needed.\n      if (isAssumedSideEffectFree(A, I) && !isa<InvokeInst>(I)) {\n        A.deleteAfterManifest(*I);\n        return ChangeStatus::CHANGED;\n      }\n    }\n    if (V.use_empty())\n      return ChangeStatus::UNCHANGED;\n\n    bool UsedAssumedInformation = false;\n    Optional<Constant *> C =\n        A.getAssumedConstant(V, *this, UsedAssumedInformation);\n    if (C.hasValue() && C.getValue())\n      return ChangeStatus::UNCHANGED;\n\n    // Replace the value with undef as it is dead but keep droppable uses around\n    // as they provide information we don't want to give up on just yet.\n    UndefValue &UV = *UndefValue::get(V.getType());\n    bool AnyChange =\n        A.changeValueAfterManifest(V, UV, /* ChangeDropppable */ false);\n    return AnyChange ? ChangeStatus::CHANGED : ChangeStatus::UNCHANGED;\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    STATS_DECLTRACK_FLOATING_ATTR(IsDead)\n  }\n};\n\nstruct AAIsDeadArgument : public AAIsDeadFloating {\n  AAIsDeadArgument(const IRPosition &IRP, Attributor &A)\n      : AAIsDeadFloating(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    if (!A.isFunctionIPOAmendable(*getAnchorScope()))\n      indicatePessimisticFixpoint();\n  }\n\n  /// See AbstractAttribute::manifest(...).\n  ChangeStatus manifest(Attributor &A) override {\n    ChangeStatus Changed = AAIsDeadFloating::manifest(A);\n    Argument &Arg = *getAssociatedArgument();\n    if (A.isValidFunctionSignatureRewrite(Arg, /* ReplacementTypes */ {}))\n      if (A.registerFunctionSignatureRewrite(\n              Arg, /* ReplacementTypes */ {},\n              Attributor::ArgumentReplacementInfo::CalleeRepairCBTy{},\n              Attributor::ArgumentReplacementInfo::ACSRepairCBTy{})) {\n        Arg.dropDroppableUses();\n        return ChangeStatus::CHANGED;\n      }\n    return Changed;\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_ARG_ATTR(IsDead) }\n};\n\nstruct AAIsDeadCallSiteArgument : public AAIsDeadValueImpl {\n  AAIsDeadCallSiteArgument(const IRPosition &IRP, Attributor &A)\n      : AAIsDeadValueImpl(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    if (isa<UndefValue>(getAssociatedValue()))\n      indicatePessimisticFixpoint();\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    // TODO: Once we have call site specific value information we can provide\n    //       call site specific liveness information and then it makes\n    //       sense to specialize attributes for call sites arguments instead of\n    //       redirecting requests to the callee argument.\n    Argument *Arg = getAssociatedArgument();\n    if (!Arg)\n      return indicatePessimisticFixpoint();\n    const IRPosition &ArgPos = IRPosition::argument(*Arg);\n    auto &ArgAA = A.getAAFor<AAIsDead>(*this, ArgPos, DepClassTy::REQUIRED);\n    return clampStateAndIndicateChange(getState(), ArgAA.getState());\n  }\n\n  /// See AbstractAttribute::manifest(...).\n  ChangeStatus manifest(Attributor &A) override {\n    CallBase &CB = cast<CallBase>(getAnchorValue());\n    Use &U = CB.getArgOperandUse(getCallSiteArgNo());\n    assert(!isa<UndefValue>(U.get()) &&\n           \"Expected undef values to be filtered out!\");\n    UndefValue &UV = *UndefValue::get(U->getType());\n    if (A.changeUseAfterManifest(U, UV))\n      return ChangeStatus::CHANGED;\n    return ChangeStatus::UNCHANGED;\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_CSARG_ATTR(IsDead) }\n};\n\nstruct AAIsDeadCallSiteReturned : public AAIsDeadFloating {\n  AAIsDeadCallSiteReturned(const IRPosition &IRP, Attributor &A)\n      : AAIsDeadFloating(IRP, A), IsAssumedSideEffectFree(true) {}\n\n  /// See AAIsDead::isAssumedDead().\n  bool isAssumedDead() const override {\n    return AAIsDeadFloating::isAssumedDead() && IsAssumedSideEffectFree;\n  }\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    if (isa<UndefValue>(getAssociatedValue())) {\n      indicatePessimisticFixpoint();\n      return;\n    }\n\n    // We track this separately as a secondary state.\n    IsAssumedSideEffectFree = isAssumedSideEffectFree(A, getCtxI());\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    ChangeStatus Changed = ChangeStatus::UNCHANGED;\n    if (IsAssumedSideEffectFree && !isAssumedSideEffectFree(A, getCtxI())) {\n      IsAssumedSideEffectFree = false;\n      Changed = ChangeStatus::CHANGED;\n    }\n\n    if (!areAllUsesAssumedDead(A, getAssociatedValue()))\n      return indicatePessimisticFixpoint();\n    return Changed;\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    if (IsAssumedSideEffectFree)\n      STATS_DECLTRACK_CSRET_ATTR(IsDead)\n    else\n      STATS_DECLTRACK_CSRET_ATTR(UnusedResult)\n  }\n\n  /// See AbstractAttribute::getAsStr().\n  const std::string getAsStr() const override {\n    return isAssumedDead()\n               ? \"assumed-dead\"\n               : (getAssumed() ? \"assumed-dead-users\" : \"assumed-live\");\n  }\n\nprivate:\n  bool IsAssumedSideEffectFree;\n};\n\nstruct AAIsDeadReturned : public AAIsDeadValueImpl {\n  AAIsDeadReturned(const IRPosition &IRP, Attributor &A)\n      : AAIsDeadValueImpl(IRP, A) {}\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n\n    A.checkForAllInstructions([](Instruction &) { return true; }, *this,\n                              {Instruction::Ret});\n\n    auto PredForCallSite = [&](AbstractCallSite ACS) {\n      if (ACS.isCallbackCall() || !ACS.getInstruction())\n        return false;\n      return areAllUsesAssumedDead(A, *ACS.getInstruction());\n    };\n\n    bool AllCallSitesKnown;\n    if (!A.checkForAllCallSites(PredForCallSite, *this, true,\n                                AllCallSitesKnown))\n      return indicatePessimisticFixpoint();\n\n    return ChangeStatus::UNCHANGED;\n  }\n\n  /// See AbstractAttribute::manifest(...).\n  ChangeStatus manifest(Attributor &A) override {\n    // TODO: Rewrite the signature to return void?\n    bool AnyChange = false;\n    UndefValue &UV = *UndefValue::get(getAssociatedFunction()->getReturnType());\n    auto RetInstPred = [&](Instruction &I) {\n      ReturnInst &RI = cast<ReturnInst>(I);\n      if (!isa<UndefValue>(RI.getReturnValue()))\n        AnyChange |= A.changeUseAfterManifest(RI.getOperandUse(0), UV);\n      return true;\n    };\n    A.checkForAllInstructions(RetInstPred, *this, {Instruction::Ret});\n    return AnyChange ? ChangeStatus::CHANGED : ChangeStatus::UNCHANGED;\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_FNRET_ATTR(IsDead) }\n};\n\nstruct AAIsDeadFunction : public AAIsDead {\n  AAIsDeadFunction(const IRPosition &IRP, Attributor &A) : AAIsDead(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    const Function *F = getAnchorScope();\n    if (F && !F->isDeclaration()) {\n      // We only want to compute liveness once. If the function is not part of\n      // the SCC, skip it.\n      if (A.isRunOn(*const_cast<Function *>(F))) {\n        ToBeExploredFrom.insert(&F->getEntryBlock().front());\n        assumeLive(A, F->getEntryBlock());\n      } else {\n        indicatePessimisticFixpoint();\n      }\n    }\n  }\n\n  /// See AbstractAttribute::getAsStr().\n  const std::string getAsStr() const override {\n    return \"Live[#BB \" + std::to_string(AssumedLiveBlocks.size()) + \"/\" +\n           std::to_string(getAnchorScope()->size()) + \"][#TBEP \" +\n           std::to_string(ToBeExploredFrom.size()) + \"][#KDE \" +\n           std::to_string(KnownDeadEnds.size()) + \"]\";\n  }\n\n  /// See AbstractAttribute::manifest(...).\n  ChangeStatus manifest(Attributor &A) override {\n    assert(getState().isValidState() &&\n           \"Attempted to manifest an invalid state!\");\n\n    ChangeStatus HasChanged = ChangeStatus::UNCHANGED;\n    Function &F = *getAnchorScope();\n\n    if (AssumedLiveBlocks.empty()) {\n      A.deleteAfterManifest(F);\n      return ChangeStatus::CHANGED;\n    }\n\n    // Flag to determine if we can change an invoke to a call assuming the\n    // callee is nounwind. This is not possible if the personality of the\n    // function allows to catch asynchronous exceptions.\n    bool Invoke2CallAllowed = !mayCatchAsynchronousExceptions(F);\n\n    KnownDeadEnds.set_union(ToBeExploredFrom);\n    for (const Instruction *DeadEndI : KnownDeadEnds) {\n      auto *CB = dyn_cast<CallBase>(DeadEndI);\n      if (!CB)\n        continue;\n      const auto &NoReturnAA = A.getAndUpdateAAFor<AANoReturn>(\n          *this, IRPosition::callsite_function(*CB), DepClassTy::OPTIONAL);\n      bool MayReturn = !NoReturnAA.isAssumedNoReturn();\n      if (MayReturn && (!Invoke2CallAllowed || !isa<InvokeInst>(CB)))\n        continue;\n\n      if (auto *II = dyn_cast<InvokeInst>(DeadEndI))\n        A.registerInvokeWithDeadSuccessor(const_cast<InvokeInst &>(*II));\n      else\n        A.changeToUnreachableAfterManifest(\n            const_cast<Instruction *>(DeadEndI->getNextNode()));\n      HasChanged = ChangeStatus::CHANGED;\n    }\n\n    STATS_DECL(AAIsDead, BasicBlock, \"Number of dead basic blocks deleted.\");\n    for (BasicBlock &BB : F)\n      if (!AssumedLiveBlocks.count(&BB)) {\n        A.deleteAfterManifest(BB);\n        ++BUILD_STAT_NAME(AAIsDead, BasicBlock);\n      }\n\n    return HasChanged;\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override;\n\n  bool isEdgeDead(const BasicBlock *From, const BasicBlock *To) const override {\n    return !AssumedLiveEdges.count(std::make_pair(From, To));\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {}\n\n  /// Returns true if the function is assumed dead.\n  bool isAssumedDead() const override { return false; }\n\n  /// See AAIsDead::isKnownDead().\n  bool isKnownDead() const override { return false; }\n\n  /// See AAIsDead::isAssumedDead(BasicBlock *).\n  bool isAssumedDead(const BasicBlock *BB) const override {\n    assert(BB->getParent() == getAnchorScope() &&\n           \"BB must be in the same anchor scope function.\");\n\n    if (!getAssumed())\n      return false;\n    return !AssumedLiveBlocks.count(BB);\n  }\n\n  /// See AAIsDead::isKnownDead(BasicBlock *).\n  bool isKnownDead(const BasicBlock *BB) const override {\n    return getKnown() && isAssumedDead(BB);\n  }\n\n  /// See AAIsDead::isAssumed(Instruction *I).\n  bool isAssumedDead(const Instruction *I) const override {\n    assert(I->getParent()->getParent() == getAnchorScope() &&\n           \"Instruction must be in the same anchor scope function.\");\n\n    if (!getAssumed())\n      return false;\n\n    // If it is not in AssumedLiveBlocks then it for sure dead.\n    // Otherwise, it can still be after noreturn call in a live block.\n    if (!AssumedLiveBlocks.count(I->getParent()))\n      return true;\n\n    // If it is not after a liveness barrier it is live.\n    const Instruction *PrevI = I->getPrevNode();\n    while (PrevI) {\n      if (KnownDeadEnds.count(PrevI) || ToBeExploredFrom.count(PrevI))\n        return true;\n      PrevI = PrevI->getPrevNode();\n    }\n    return false;\n  }\n\n  /// See AAIsDead::isKnownDead(Instruction *I).\n  bool isKnownDead(const Instruction *I) const override {\n    return getKnown() && isAssumedDead(I);\n  }\n\n  /// Assume \\p BB is (partially) live now and indicate to the Attributor \\p A\n  /// that internal function called from \\p BB should now be looked at.\n  bool assumeLive(Attributor &A, const BasicBlock &BB) {\n    if (!AssumedLiveBlocks.insert(&BB).second)\n      return false;\n\n    // We assume that all of BB is (probably) live now and if there are calls to\n    // internal functions we will assume that those are now live as well. This\n    // is a performance optimization for blocks with calls to a lot of internal\n    // functions. It can however cause dead functions to be treated as live.\n    for (const Instruction &I : BB)\n      if (const auto *CB = dyn_cast<CallBase>(&I))\n        if (const Function *F = CB->getCalledFunction())\n          if (F->hasLocalLinkage())\n            A.markLiveInternalFunction(*F);\n    return true;\n  }\n\n  /// Collection of instructions that need to be explored again, e.g., we\n  /// did assume they do not transfer control to (one of their) successors.\n  SmallSetVector<const Instruction *, 8> ToBeExploredFrom;\n\n  /// Collection of instructions that are known to not transfer control.\n  SmallSetVector<const Instruction *, 8> KnownDeadEnds;\n\n  /// Collection of all assumed live edges\n  DenseSet<std::pair<const BasicBlock *, const BasicBlock *>> AssumedLiveEdges;\n\n  /// Collection of all assumed live BasicBlocks.\n  DenseSet<const BasicBlock *> AssumedLiveBlocks;\n};\n\nstatic bool\nidentifyAliveSuccessors(Attributor &A, const CallBase &CB,\n                        AbstractAttribute &AA,\n                        SmallVectorImpl<const Instruction *> &AliveSuccessors) {\n  const IRPosition &IPos = IRPosition::callsite_function(CB);\n\n  const auto &NoReturnAA =\n      A.getAndUpdateAAFor<AANoReturn>(AA, IPos, DepClassTy::OPTIONAL);\n  if (NoReturnAA.isAssumedNoReturn())\n    return !NoReturnAA.isKnownNoReturn();\n  if (CB.isTerminator())\n    AliveSuccessors.push_back(&CB.getSuccessor(0)->front());\n  else\n    AliveSuccessors.push_back(CB.getNextNode());\n  return false;\n}\n\nstatic bool\nidentifyAliveSuccessors(Attributor &A, const InvokeInst &II,\n                        AbstractAttribute &AA,\n                        SmallVectorImpl<const Instruction *> &AliveSuccessors) {\n  bool UsedAssumedInformation =\n      identifyAliveSuccessors(A, cast<CallBase>(II), AA, AliveSuccessors);\n\n  // First, determine if we can change an invoke to a call assuming the\n  // callee is nounwind. This is not possible if the personality of the\n  // function allows to catch asynchronous exceptions.\n  if (AAIsDeadFunction::mayCatchAsynchronousExceptions(*II.getFunction())) {\n    AliveSuccessors.push_back(&II.getUnwindDest()->front());\n  } else {\n    const IRPosition &IPos = IRPosition::callsite_function(II);\n    const auto &AANoUnw =\n        A.getAndUpdateAAFor<AANoUnwind>(AA, IPos, DepClassTy::OPTIONAL);\n    if (AANoUnw.isAssumedNoUnwind()) {\n      UsedAssumedInformation |= !AANoUnw.isKnownNoUnwind();\n    } else {\n      AliveSuccessors.push_back(&II.getUnwindDest()->front());\n    }\n  }\n  return UsedAssumedInformation;\n}\n\nstatic bool\nidentifyAliveSuccessors(Attributor &A, const BranchInst &BI,\n                        AbstractAttribute &AA,\n                        SmallVectorImpl<const Instruction *> &AliveSuccessors) {\n  bool UsedAssumedInformation = false;\n  if (BI.getNumSuccessors() == 1) {\n    AliveSuccessors.push_back(&BI.getSuccessor(0)->front());\n  } else {\n    Optional<ConstantInt *> CI = getAssumedConstantInt(\n        A, *BI.getCondition(), AA, UsedAssumedInformation);\n    if (!CI.hasValue()) {\n      // No value yet, assume both edges are dead.\n    } else if (CI.getValue()) {\n      const BasicBlock *SuccBB =\n          BI.getSuccessor(1 - CI.getValue()->getZExtValue());\n      AliveSuccessors.push_back(&SuccBB->front());\n    } else {\n      AliveSuccessors.push_back(&BI.getSuccessor(0)->front());\n      AliveSuccessors.push_back(&BI.getSuccessor(1)->front());\n      UsedAssumedInformation = false;\n    }\n  }\n  return UsedAssumedInformation;\n}\n\nstatic bool\nidentifyAliveSuccessors(Attributor &A, const SwitchInst &SI,\n                        AbstractAttribute &AA,\n                        SmallVectorImpl<const Instruction *> &AliveSuccessors) {\n  bool UsedAssumedInformation = false;\n  Optional<ConstantInt *> CI =\n      getAssumedConstantInt(A, *SI.getCondition(), AA, UsedAssumedInformation);\n  if (!CI.hasValue()) {\n    // No value yet, assume all edges are dead.\n  } else if (CI.getValue()) {\n    for (auto &CaseIt : SI.cases()) {\n      if (CaseIt.getCaseValue() == CI.getValue()) {\n        AliveSuccessors.push_back(&CaseIt.getCaseSuccessor()->front());\n        return UsedAssumedInformation;\n      }\n    }\n    AliveSuccessors.push_back(&SI.getDefaultDest()->front());\n    return UsedAssumedInformation;\n  } else {\n    for (const BasicBlock *SuccBB : successors(SI.getParent()))\n      AliveSuccessors.push_back(&SuccBB->front());\n  }\n  return UsedAssumedInformation;\n}\n\nChangeStatus AAIsDeadFunction::updateImpl(Attributor &A) {\n  ChangeStatus Change = ChangeStatus::UNCHANGED;\n\n  LLVM_DEBUG(dbgs() << \"[AAIsDead] Live [\" << AssumedLiveBlocks.size() << \"/\"\n                    << getAnchorScope()->size() << \"] BBs and \"\n                    << ToBeExploredFrom.size() << \" exploration points and \"\n                    << KnownDeadEnds.size() << \" known dead ends\\n\");\n\n  // Copy and clear the list of instructions we need to explore from. It is\n  // refilled with instructions the next update has to look at.\n  SmallVector<const Instruction *, 8> Worklist(ToBeExploredFrom.begin(),\n                                               ToBeExploredFrom.end());\n  decltype(ToBeExploredFrom) NewToBeExploredFrom;\n\n  SmallVector<const Instruction *, 8> AliveSuccessors;\n  while (!Worklist.empty()) {\n    const Instruction *I = Worklist.pop_back_val();\n    LLVM_DEBUG(dbgs() << \"[AAIsDead] Exploration inst: \" << *I << \"\\n\");\n\n    // Fast forward for uninteresting instructions. We could look for UB here\n    // though.\n    while (!I->isTerminator() && !isa<CallBase>(I)) {\n      Change = ChangeStatus::CHANGED;\n      I = I->getNextNode();\n    }\n\n    AliveSuccessors.clear();\n\n    bool UsedAssumedInformation = false;\n    switch (I->getOpcode()) {\n    // TODO: look for (assumed) UB to backwards propagate \"deadness\".\n    default:\n      assert(I->isTerminator() &&\n             \"Expected non-terminators to be handled already!\");\n      for (const BasicBlock *SuccBB : successors(I->getParent()))\n        AliveSuccessors.push_back(&SuccBB->front());\n      break;\n    case Instruction::Call:\n      UsedAssumedInformation = identifyAliveSuccessors(A, cast<CallInst>(*I),\n                                                       *this, AliveSuccessors);\n      break;\n    case Instruction::Invoke:\n      UsedAssumedInformation = identifyAliveSuccessors(A, cast<InvokeInst>(*I),\n                                                       *this, AliveSuccessors);\n      break;\n    case Instruction::Br:\n      UsedAssumedInformation = identifyAliveSuccessors(A, cast<BranchInst>(*I),\n                                                       *this, AliveSuccessors);\n      break;\n    case Instruction::Switch:\n      UsedAssumedInformation = identifyAliveSuccessors(A, cast<SwitchInst>(*I),\n                                                       *this, AliveSuccessors);\n      break;\n    }\n\n    if (UsedAssumedInformation) {\n      NewToBeExploredFrom.insert(I);\n    } else {\n      Change = ChangeStatus::CHANGED;\n      if (AliveSuccessors.empty() ||\n          (I->isTerminator() && AliveSuccessors.size() < I->getNumSuccessors()))\n        KnownDeadEnds.insert(I);\n    }\n\n    LLVM_DEBUG(dbgs() << \"[AAIsDead] #AliveSuccessors: \"\n                      << AliveSuccessors.size() << \" UsedAssumedInformation: \"\n                      << UsedAssumedInformation << \"\\n\");\n\n    for (const Instruction *AliveSuccessor : AliveSuccessors) {\n      if (!I->isTerminator()) {\n        assert(AliveSuccessors.size() == 1 &&\n               \"Non-terminator expected to have a single successor!\");\n        Worklist.push_back(AliveSuccessor);\n      } else {\n        // record the assumed live edge\n        AssumedLiveEdges.insert(\n            std::make_pair(I->getParent(), AliveSuccessor->getParent()));\n        if (assumeLive(A, *AliveSuccessor->getParent()))\n          Worklist.push_back(AliveSuccessor);\n      }\n    }\n  }\n\n  ToBeExploredFrom = std::move(NewToBeExploredFrom);\n\n  // If we know everything is live there is no need to query for liveness.\n  // Instead, indicating a pessimistic fixpoint will cause the state to be\n  // \"invalid\" and all queries to be answered conservatively without lookups.\n  // To be in this state we have to (1) finished the exploration and (3) not\n  // discovered any non-trivial dead end and (2) not ruled unreachable code\n  // dead.\n  if (ToBeExploredFrom.empty() &&\n      getAnchorScope()->size() == AssumedLiveBlocks.size() &&\n      llvm::all_of(KnownDeadEnds, [](const Instruction *DeadEndI) {\n        return DeadEndI->isTerminator() && DeadEndI->getNumSuccessors() == 0;\n      }))\n    return indicatePessimisticFixpoint();\n  return Change;\n}\n\n/// Liveness information for a call sites.\nstruct AAIsDeadCallSite final : AAIsDeadFunction {\n  AAIsDeadCallSite(const IRPosition &IRP, Attributor &A)\n      : AAIsDeadFunction(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    // TODO: Once we have call site specific value information we can provide\n    //       call site specific liveness information and then it makes\n    //       sense to specialize attributes for call sites instead of\n    //       redirecting requests to the callee.\n    llvm_unreachable(\"Abstract attributes for liveness are not \"\n                     \"supported for call sites yet!\");\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    return indicatePessimisticFixpoint();\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {}\n};\n\n/// -------------------- Dereferenceable Argument Attribute --------------------\n\ntemplate <>\nChangeStatus clampStateAndIndicateChange<DerefState>(DerefState &S,\n                                                     const DerefState &R) {\n  ChangeStatus CS0 =\n      clampStateAndIndicateChange(S.DerefBytesState, R.DerefBytesState);\n  ChangeStatus CS1 = clampStateAndIndicateChange(S.GlobalState, R.GlobalState);\n  return CS0 | CS1;\n}\n\nstruct AADereferenceableImpl : AADereferenceable {\n  AADereferenceableImpl(const IRPosition &IRP, Attributor &A)\n      : AADereferenceable(IRP, A) {}\n  using StateType = DerefState;\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    SmallVector<Attribute, 4> Attrs;\n    getAttrs({Attribute::Dereferenceable, Attribute::DereferenceableOrNull},\n             Attrs, /* IgnoreSubsumingPositions */ false, &A);\n    for (const Attribute &Attr : Attrs)\n      takeKnownDerefBytesMaximum(Attr.getValueAsInt());\n\n    const IRPosition &IRP = this->getIRPosition();\n    NonNullAA = &A.getAAFor<AANonNull>(*this, IRP, DepClassTy::NONE);\n\n    bool CanBeNull, CanBeFreed;\n    takeKnownDerefBytesMaximum(\n        IRP.getAssociatedValue().getPointerDereferenceableBytes(\n            A.getDataLayout(), CanBeNull, CanBeFreed));\n\n    bool IsFnInterface = IRP.isFnInterfaceKind();\n    Function *FnScope = IRP.getAnchorScope();\n    if (IsFnInterface && (!FnScope || !A.isFunctionIPOAmendable(*FnScope))) {\n      indicatePessimisticFixpoint();\n      return;\n    }\n\n    if (Instruction *CtxI = getCtxI())\n      followUsesInMBEC(*this, A, getState(), *CtxI);\n  }\n\n  /// See AbstractAttribute::getState()\n  /// {\n  StateType &getState() override { return *this; }\n  const StateType &getState() const override { return *this; }\n  /// }\n\n  /// Helper function for collecting accessed bytes in must-be-executed-context\n  void addAccessedBytesForUse(Attributor &A, const Use *U, const Instruction *I,\n                              DerefState &State) {\n    const Value *UseV = U->get();\n    if (!UseV->getType()->isPointerTy())\n      return;\n\n    Type *PtrTy = UseV->getType();\n    const DataLayout &DL = A.getDataLayout();\n    int64_t Offset;\n    if (const Value *Base = getBasePointerOfAccessPointerOperand(\n            I, Offset, DL, /*AllowNonInbounds*/ true)) {\n      if (Base == &getAssociatedValue() &&\n          getPointerOperand(I, /* AllowVolatile */ false) == UseV) {\n        uint64_t Size = DL.getTypeStoreSize(PtrTy->getPointerElementType());\n        State.addAccessedBytes(Offset, Size);\n      }\n    }\n  }\n\n  /// See followUsesInMBEC\n  bool followUseInMBEC(Attributor &A, const Use *U, const Instruction *I,\n                       AADereferenceable::StateType &State) {\n    bool IsNonNull = false;\n    bool TrackUse = false;\n    int64_t DerefBytes = getKnownNonNullAndDerefBytesForUse(\n        A, *this, getAssociatedValue(), U, I, IsNonNull, TrackUse);\n    LLVM_DEBUG(dbgs() << \"[AADereferenceable] Deref bytes: \" << DerefBytes\n                      << \" for instruction \" << *I << \"\\n\");\n\n    addAccessedBytesForUse(A, U, I, State);\n    State.takeKnownDerefBytesMaximum(DerefBytes);\n    return TrackUse;\n  }\n\n  /// See AbstractAttribute::manifest(...).\n  ChangeStatus manifest(Attributor &A) override {\n    ChangeStatus Change = AADereferenceable::manifest(A);\n    if (isAssumedNonNull() && hasAttr(Attribute::DereferenceableOrNull)) {\n      removeAttrs({Attribute::DereferenceableOrNull});\n      return ChangeStatus::CHANGED;\n    }\n    return Change;\n  }\n\n  void getDeducedAttributes(LLVMContext &Ctx,\n                            SmallVectorImpl<Attribute> &Attrs) const override {\n    // TODO: Add *_globally support\n    if (isAssumedNonNull())\n      Attrs.emplace_back(Attribute::getWithDereferenceableBytes(\n          Ctx, getAssumedDereferenceableBytes()));\n    else\n      Attrs.emplace_back(Attribute::getWithDereferenceableOrNullBytes(\n          Ctx, getAssumedDereferenceableBytes()));\n  }\n\n  /// See AbstractAttribute::getAsStr().\n  const std::string getAsStr() const override {\n    if (!getAssumedDereferenceableBytes())\n      return \"unknown-dereferenceable\";\n    return std::string(\"dereferenceable\") +\n           (isAssumedNonNull() ? \"\" : \"_or_null\") +\n           (isAssumedGlobal() ? \"_globally\" : \"\") + \"<\" +\n           std::to_string(getKnownDereferenceableBytes()) + \"-\" +\n           std::to_string(getAssumedDereferenceableBytes()) + \">\";\n  }\n};\n\n/// Dereferenceable attribute for a floating value.\nstruct AADereferenceableFloating : AADereferenceableImpl {\n  AADereferenceableFloating(const IRPosition &IRP, Attributor &A)\n      : AADereferenceableImpl(IRP, A) {}\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    const DataLayout &DL = A.getDataLayout();\n\n    auto VisitValueCB = [&](const Value &V, const Instruction *, DerefState &T,\n                            bool Stripped) -> bool {\n      unsigned IdxWidth =\n          DL.getIndexSizeInBits(V.getType()->getPointerAddressSpace());\n      APInt Offset(IdxWidth, 0);\n      const Value *Base =\n          stripAndAccumulateMinimalOffsets(A, *this, &V, DL, Offset, false);\n\n      const auto &AA = A.getAAFor<AADereferenceable>(\n          *this, IRPosition::value(*Base), DepClassTy::REQUIRED);\n      int64_t DerefBytes = 0;\n      if (!Stripped && this == &AA) {\n        // Use IR information if we did not strip anything.\n        // TODO: track globally.\n        bool CanBeNull, CanBeFreed;\n        DerefBytes =\n          Base->getPointerDereferenceableBytes(DL, CanBeNull, CanBeFreed);\n        T.GlobalState.indicatePessimisticFixpoint();\n      } else {\n        const DerefState &DS = AA.getState();\n        DerefBytes = DS.DerefBytesState.getAssumed();\n        T.GlobalState &= DS.GlobalState;\n      }\n\n      // For now we do not try to \"increase\" dereferenceability due to negative\n      // indices as we first have to come up with code to deal with loops and\n      // for overflows of the dereferenceable bytes.\n      int64_t OffsetSExt = Offset.getSExtValue();\n      if (OffsetSExt < 0)\n        OffsetSExt = 0;\n\n      T.takeAssumedDerefBytesMinimum(\n          std::max(int64_t(0), DerefBytes - OffsetSExt));\n\n      if (this == &AA) {\n        if (!Stripped) {\n          // If nothing was stripped IR information is all we got.\n          T.takeKnownDerefBytesMaximum(\n              std::max(int64_t(0), DerefBytes - OffsetSExt));\n          T.indicatePessimisticFixpoint();\n        } else if (OffsetSExt > 0) {\n          // If something was stripped but there is circular reasoning we look\n          // for the offset. If it is positive we basically decrease the\n          // dereferenceable bytes in a circluar loop now, which will simply\n          // drive them down to the known value in a very slow way which we\n          // can accelerate.\n          T.indicatePessimisticFixpoint();\n        }\n      }\n\n      return T.isValidState();\n    };\n\n    DerefState T;\n    if (!genericValueTraversal<AADereferenceable, DerefState>(\n            A, getIRPosition(), *this, T, VisitValueCB, getCtxI()))\n      return indicatePessimisticFixpoint();\n\n    return clampStateAndIndicateChange(getState(), T);\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    STATS_DECLTRACK_FLOATING_ATTR(dereferenceable)\n  }\n};\n\n/// Dereferenceable attribute for a return value.\nstruct AADereferenceableReturned final\n    : AAReturnedFromReturnedValues<AADereferenceable, AADereferenceableImpl> {\n  AADereferenceableReturned(const IRPosition &IRP, Attributor &A)\n      : AAReturnedFromReturnedValues<AADereferenceable, AADereferenceableImpl>(\n            IRP, A) {}\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    STATS_DECLTRACK_FNRET_ATTR(dereferenceable)\n  }\n};\n\n/// Dereferenceable attribute for an argument\nstruct AADereferenceableArgument final\n    : AAArgumentFromCallSiteArguments<AADereferenceable,\n                                      AADereferenceableImpl> {\n  using Base =\n      AAArgumentFromCallSiteArguments<AADereferenceable, AADereferenceableImpl>;\n  AADereferenceableArgument(const IRPosition &IRP, Attributor &A)\n      : Base(IRP, A) {}\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    STATS_DECLTRACK_ARG_ATTR(dereferenceable)\n  }\n};\n\n/// Dereferenceable attribute for a call site argument.\nstruct AADereferenceableCallSiteArgument final : AADereferenceableFloating {\n  AADereferenceableCallSiteArgument(const IRPosition &IRP, Attributor &A)\n      : AADereferenceableFloating(IRP, A) {}\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    STATS_DECLTRACK_CSARG_ATTR(dereferenceable)\n  }\n};\n\n/// Dereferenceable attribute deduction for a call site return value.\nstruct AADereferenceableCallSiteReturned final\n    : AACallSiteReturnedFromReturned<AADereferenceable, AADereferenceableImpl> {\n  using Base =\n      AACallSiteReturnedFromReturned<AADereferenceable, AADereferenceableImpl>;\n  AADereferenceableCallSiteReturned(const IRPosition &IRP, Attributor &A)\n      : Base(IRP, A) {}\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    STATS_DECLTRACK_CS_ATTR(dereferenceable);\n  }\n};\n\n// ------------------------ Align Argument Attribute ------------------------\n\nstatic unsigned getKnownAlignForUse(Attributor &A, AAAlign &QueryingAA,\n                                    Value &AssociatedValue, const Use *U,\n                                    const Instruction *I, bool &TrackUse) {\n  // We need to follow common pointer manipulation uses to the accesses they\n  // feed into.\n  if (isa<CastInst>(I)) {\n    // Follow all but ptr2int casts.\n    TrackUse = !isa<PtrToIntInst>(I);\n    return 0;\n  }\n  if (auto *GEP = dyn_cast<GetElementPtrInst>(I)) {\n    if (GEP->hasAllConstantIndices())\n      TrackUse = true;\n    return 0;\n  }\n\n  MaybeAlign MA;\n  if (const auto *CB = dyn_cast<CallBase>(I)) {\n    if (CB->isBundleOperand(U) || CB->isCallee(U))\n      return 0;\n\n    unsigned ArgNo = CB->getArgOperandNo(U);\n    IRPosition IRP = IRPosition::callsite_argument(*CB, ArgNo);\n    // As long as we only use known information there is no need to track\n    // dependences here.\n    auto &AlignAA = A.getAAFor<AAAlign>(QueryingAA, IRP, DepClassTy::NONE);\n    MA = MaybeAlign(AlignAA.getKnownAlign());\n  }\n\n  const DataLayout &DL = A.getDataLayout();\n  const Value *UseV = U->get();\n  if (auto *SI = dyn_cast<StoreInst>(I)) {\n    if (SI->getPointerOperand() == UseV)\n      MA = SI->getAlign();\n  } else if (auto *LI = dyn_cast<LoadInst>(I)) {\n    if (LI->getPointerOperand() == UseV)\n      MA = LI->getAlign();\n  }\n\n  if (!MA || *MA <= QueryingAA.getKnownAlign())\n    return 0;\n\n  unsigned Alignment = MA->value();\n  int64_t Offset;\n\n  if (const Value *Base = GetPointerBaseWithConstantOffset(UseV, Offset, DL)) {\n    if (Base == &AssociatedValue) {\n      // BasePointerAddr + Offset = Alignment * Q for some integer Q.\n      // So we can say that the maximum power of two which is a divisor of\n      // gcd(Offset, Alignment) is an alignment.\n\n      uint32_t gcd =\n          greatestCommonDivisor(uint32_t(abs((int32_t)Offset)), Alignment);\n      Alignment = llvm::PowerOf2Floor(gcd);\n    }\n  }\n\n  return Alignment;\n}\n\nstruct AAAlignImpl : AAAlign {\n  AAAlignImpl(const IRPosition &IRP, Attributor &A) : AAAlign(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    SmallVector<Attribute, 4> Attrs;\n    getAttrs({Attribute::Alignment}, Attrs);\n    for (const Attribute &Attr : Attrs)\n      takeKnownMaximum(Attr.getValueAsInt());\n\n    Value &V = getAssociatedValue();\n    // TODO: This is a HACK to avoid getPointerAlignment to introduce a ptr2int\n    //       use of the function pointer. This was caused by D73131. We want to\n    //       avoid this for function pointers especially because we iterate\n    //       their uses and int2ptr is not handled. It is not a correctness\n    //       problem though!\n    if (!V.getType()->getPointerElementType()->isFunctionTy())\n      takeKnownMaximum(V.getPointerAlignment(A.getDataLayout()).value());\n\n    if (getIRPosition().isFnInterfaceKind() &&\n        (!getAnchorScope() ||\n         !A.isFunctionIPOAmendable(*getAssociatedFunction()))) {\n      indicatePessimisticFixpoint();\n      return;\n    }\n\n    if (Instruction *CtxI = getCtxI())\n      followUsesInMBEC(*this, A, getState(), *CtxI);\n  }\n\n  /// See AbstractAttribute::manifest(...).\n  ChangeStatus manifest(Attributor &A) override {\n    ChangeStatus LoadStoreChanged = ChangeStatus::UNCHANGED;\n\n    // Check for users that allow alignment annotations.\n    Value &AssociatedValue = getAssociatedValue();\n    for (const Use &U : AssociatedValue.uses()) {\n      if (auto *SI = dyn_cast<StoreInst>(U.getUser())) {\n        if (SI->getPointerOperand() == &AssociatedValue)\n          if (SI->getAlignment() < getAssumedAlign()) {\n            STATS_DECLTRACK(AAAlign, Store,\n                            \"Number of times alignment added to a store\");\n            SI->setAlignment(Align(getAssumedAlign()));\n            LoadStoreChanged = ChangeStatus::CHANGED;\n          }\n      } else if (auto *LI = dyn_cast<LoadInst>(U.getUser())) {\n        if (LI->getPointerOperand() == &AssociatedValue)\n          if (LI->getAlignment() < getAssumedAlign()) {\n            LI->setAlignment(Align(getAssumedAlign()));\n            STATS_DECLTRACK(AAAlign, Load,\n                            \"Number of times alignment added to a load\");\n            LoadStoreChanged = ChangeStatus::CHANGED;\n          }\n      }\n    }\n\n    ChangeStatus Changed = AAAlign::manifest(A);\n\n    Align InheritAlign =\n        getAssociatedValue().getPointerAlignment(A.getDataLayout());\n    if (InheritAlign >= getAssumedAlign())\n      return LoadStoreChanged;\n    return Changed | LoadStoreChanged;\n  }\n\n  // TODO: Provide a helper to determine the implied ABI alignment and check in\n  //       the existing manifest method and a new one for AAAlignImpl that value\n  //       to avoid making the alignment explicit if it did not improve.\n\n  /// See AbstractAttribute::getDeducedAttributes\n  virtual void\n  getDeducedAttributes(LLVMContext &Ctx,\n                       SmallVectorImpl<Attribute> &Attrs) const override {\n    if (getAssumedAlign() > 1)\n      Attrs.emplace_back(\n          Attribute::getWithAlignment(Ctx, Align(getAssumedAlign())));\n  }\n\n  /// See followUsesInMBEC\n  bool followUseInMBEC(Attributor &A, const Use *U, const Instruction *I,\n                       AAAlign::StateType &State) {\n    bool TrackUse = false;\n\n    unsigned int KnownAlign =\n        getKnownAlignForUse(A, *this, getAssociatedValue(), U, I, TrackUse);\n    State.takeKnownMaximum(KnownAlign);\n\n    return TrackUse;\n  }\n\n  /// See AbstractAttribute::getAsStr().\n  const std::string getAsStr() const override {\n    return getAssumedAlign() ? (\"align<\" + std::to_string(getKnownAlign()) +\n                                \"-\" + std::to_string(getAssumedAlign()) + \">\")\n                             : \"unknown-align\";\n  }\n};\n\n/// Align attribute for a floating value.\nstruct AAAlignFloating : AAAlignImpl {\n  AAAlignFloating(const IRPosition &IRP, Attributor &A) : AAAlignImpl(IRP, A) {}\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    const DataLayout &DL = A.getDataLayout();\n\n    auto VisitValueCB = [&](Value &V, const Instruction *,\n                            AAAlign::StateType &T, bool Stripped) -> bool {\n      const auto &AA = A.getAAFor<AAAlign>(*this, IRPosition::value(V),\n                                           DepClassTy::REQUIRED);\n      if (!Stripped && this == &AA) {\n        int64_t Offset;\n        unsigned Alignment = 1;\n        if (const Value *Base =\n                GetPointerBaseWithConstantOffset(&V, Offset, DL)) {\n          Align PA = Base->getPointerAlignment(DL);\n          // BasePointerAddr + Offset = Alignment * Q for some integer Q.\n          // So we can say that the maximum power of two which is a divisor of\n          // gcd(Offset, Alignment) is an alignment.\n\n          uint32_t gcd = greatestCommonDivisor(uint32_t(abs((int32_t)Offset)),\n                                               uint32_t(PA.value()));\n          Alignment = llvm::PowerOf2Floor(gcd);\n        } else {\n          Alignment = V.getPointerAlignment(DL).value();\n        }\n        // Use only IR information if we did not strip anything.\n        T.takeKnownMaximum(Alignment);\n        T.indicatePessimisticFixpoint();\n      } else {\n        // Use abstract attribute information.\n        const AAAlign::StateType &DS = AA.getState();\n        T ^= DS;\n      }\n      return T.isValidState();\n    };\n\n    StateType T;\n    if (!genericValueTraversal<AAAlign, StateType>(A, getIRPosition(), *this, T,\n                                                   VisitValueCB, getCtxI()))\n      return indicatePessimisticFixpoint();\n\n    // TODO: If we know we visited all incoming values, thus no are assumed\n    // dead, we can take the known information from the state T.\n    return clampStateAndIndicateChange(getState(), T);\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_FLOATING_ATTR(align) }\n};\n\n/// Align attribute for function return value.\nstruct AAAlignReturned final\n    : AAReturnedFromReturnedValues<AAAlign, AAAlignImpl> {\n  using Base = AAReturnedFromReturnedValues<AAAlign, AAAlignImpl>;\n  AAAlignReturned(const IRPosition &IRP, Attributor &A) : Base(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    Base::initialize(A);\n    Function *F = getAssociatedFunction();\n    if (!F || F->isDeclaration())\n      indicatePessimisticFixpoint();\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_FNRET_ATTR(aligned) }\n};\n\n/// Align attribute for function argument.\nstruct AAAlignArgument final\n    : AAArgumentFromCallSiteArguments<AAAlign, AAAlignImpl> {\n  using Base = AAArgumentFromCallSiteArguments<AAAlign, AAAlignImpl>;\n  AAAlignArgument(const IRPosition &IRP, Attributor &A) : Base(IRP, A) {}\n\n  /// See AbstractAttribute::manifest(...).\n  ChangeStatus manifest(Attributor &A) override {\n    // If the associated argument is involved in a must-tail call we give up\n    // because we would need to keep the argument alignments of caller and\n    // callee in-sync. Just does not seem worth the trouble right now.\n    if (A.getInfoCache().isInvolvedInMustTailCall(*getAssociatedArgument()))\n      return ChangeStatus::UNCHANGED;\n    return Base::manifest(A);\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_ARG_ATTR(aligned) }\n};\n\nstruct AAAlignCallSiteArgument final : AAAlignFloating {\n  AAAlignCallSiteArgument(const IRPosition &IRP, Attributor &A)\n      : AAAlignFloating(IRP, A) {}\n\n  /// See AbstractAttribute::manifest(...).\n  ChangeStatus manifest(Attributor &A) override {\n    // If the associated argument is involved in a must-tail call we give up\n    // because we would need to keep the argument alignments of caller and\n    // callee in-sync. Just does not seem worth the trouble right now.\n    if (Argument *Arg = getAssociatedArgument())\n      if (A.getInfoCache().isInvolvedInMustTailCall(*Arg))\n        return ChangeStatus::UNCHANGED;\n    ChangeStatus Changed = AAAlignImpl::manifest(A);\n    Align InheritAlign =\n        getAssociatedValue().getPointerAlignment(A.getDataLayout());\n    if (InheritAlign >= getAssumedAlign())\n      Changed = ChangeStatus::UNCHANGED;\n    return Changed;\n  }\n\n  /// See AbstractAttribute::updateImpl(Attributor &A).\n  ChangeStatus updateImpl(Attributor &A) override {\n    ChangeStatus Changed = AAAlignFloating::updateImpl(A);\n    if (Argument *Arg = getAssociatedArgument()) {\n      // We only take known information from the argument\n      // so we do not need to track a dependence.\n      const auto &ArgAlignAA = A.getAAFor<AAAlign>(\n          *this, IRPosition::argument(*Arg), DepClassTy::NONE);\n      takeKnownMaximum(ArgAlignAA.getKnownAlign());\n    }\n    return Changed;\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_CSARG_ATTR(aligned) }\n};\n\n/// Align attribute deduction for a call site return value.\nstruct AAAlignCallSiteReturned final\n    : AACallSiteReturnedFromReturned<AAAlign, AAAlignImpl> {\n  using Base = AACallSiteReturnedFromReturned<AAAlign, AAAlignImpl>;\n  AAAlignCallSiteReturned(const IRPosition &IRP, Attributor &A)\n      : Base(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    Base::initialize(A);\n    Function *F = getAssociatedFunction();\n    if (!F || F->isDeclaration())\n      indicatePessimisticFixpoint();\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_CS_ATTR(align); }\n};\n\n/// ------------------ Function No-Return Attribute ----------------------------\nstruct AANoReturnImpl : public AANoReturn {\n  AANoReturnImpl(const IRPosition &IRP, Attributor &A) : AANoReturn(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    AANoReturn::initialize(A);\n    Function *F = getAssociatedFunction();\n    if (!F || F->isDeclaration())\n      indicatePessimisticFixpoint();\n  }\n\n  /// See AbstractAttribute::getAsStr().\n  const std::string getAsStr() const override {\n    return getAssumed() ? \"noreturn\" : \"may-return\";\n  }\n\n  /// See AbstractAttribute::updateImpl(Attributor &A).\n  virtual ChangeStatus updateImpl(Attributor &A) override {\n    auto CheckForNoReturn = [](Instruction &) { return false; };\n    if (!A.checkForAllInstructions(CheckForNoReturn, *this,\n                                   {(unsigned)Instruction::Ret}))\n      return indicatePessimisticFixpoint();\n    return ChangeStatus::UNCHANGED;\n  }\n};\n\nstruct AANoReturnFunction final : AANoReturnImpl {\n  AANoReturnFunction(const IRPosition &IRP, Attributor &A)\n      : AANoReturnImpl(IRP, A) {}\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_FN_ATTR(noreturn) }\n};\n\n/// NoReturn attribute deduction for a call sites.\nstruct AANoReturnCallSite final : AANoReturnImpl {\n  AANoReturnCallSite(const IRPosition &IRP, Attributor &A)\n      : AANoReturnImpl(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    AANoReturnImpl::initialize(A);\n    if (Function *F = getAssociatedFunction()) {\n      const IRPosition &FnPos = IRPosition::function(*F);\n      auto &FnAA = A.getAAFor<AANoReturn>(*this, FnPos, DepClassTy::REQUIRED);\n      if (!FnAA.isAssumedNoReturn())\n        indicatePessimisticFixpoint();\n    }\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    // TODO: Once we have call site specific value information we can provide\n    //       call site specific liveness information and then it makes\n    //       sense to specialize attributes for call sites arguments instead of\n    //       redirecting requests to the callee argument.\n    Function *F = getAssociatedFunction();\n    const IRPosition &FnPos = IRPosition::function(*F);\n    auto &FnAA = A.getAAFor<AANoReturn>(*this, FnPos, DepClassTy::REQUIRED);\n    return clampStateAndIndicateChange(getState(), FnAA.getState());\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_CS_ATTR(noreturn); }\n};\n\n/// ----------------------- Variable Capturing ---------------------------------\n\n/// A class to hold the state of for no-capture attributes.\nstruct AANoCaptureImpl : public AANoCapture {\n  AANoCaptureImpl(const IRPosition &IRP, Attributor &A) : AANoCapture(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    if (hasAttr(getAttrKind(), /* IgnoreSubsumingPositions */ true)) {\n      indicateOptimisticFixpoint();\n      return;\n    }\n    Function *AnchorScope = getAnchorScope();\n    if (isFnInterfaceKind() &&\n        (!AnchorScope || !A.isFunctionIPOAmendable(*AnchorScope))) {\n      indicatePessimisticFixpoint();\n      return;\n    }\n\n    // You cannot \"capture\" null in the default address space.\n    if (isa<ConstantPointerNull>(getAssociatedValue()) &&\n        getAssociatedValue().getType()->getPointerAddressSpace() == 0) {\n      indicateOptimisticFixpoint();\n      return;\n    }\n\n    const Function *F =\n        isArgumentPosition() ? getAssociatedFunction() : AnchorScope;\n\n    // Check what state the associated function can actually capture.\n    if (F)\n      determineFunctionCaptureCapabilities(getIRPosition(), *F, *this);\n    else\n      indicatePessimisticFixpoint();\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override;\n\n  /// see AbstractAttribute::isAssumedNoCaptureMaybeReturned(...).\n  virtual void\n  getDeducedAttributes(LLVMContext &Ctx,\n                       SmallVectorImpl<Attribute> &Attrs) const override {\n    if (!isAssumedNoCaptureMaybeReturned())\n      return;\n\n    if (isArgumentPosition()) {\n      if (isAssumedNoCapture())\n        Attrs.emplace_back(Attribute::get(Ctx, Attribute::NoCapture));\n      else if (ManifestInternal)\n        Attrs.emplace_back(Attribute::get(Ctx, \"no-capture-maybe-returned\"));\n    }\n  }\n\n  /// Set the NOT_CAPTURED_IN_MEM and NOT_CAPTURED_IN_RET bits in \\p Known\n  /// depending on the ability of the function associated with \\p IRP to capture\n  /// state in memory and through \"returning/throwing\", respectively.\n  static void determineFunctionCaptureCapabilities(const IRPosition &IRP,\n                                                   const Function &F,\n                                                   BitIntegerState &State) {\n    // TODO: Once we have memory behavior attributes we should use them here.\n\n    // If we know we cannot communicate or write to memory, we do not care about\n    // ptr2int anymore.\n    if (F.onlyReadsMemory() && F.doesNotThrow() &&\n        F.getReturnType()->isVoidTy()) {\n      State.addKnownBits(NO_CAPTURE);\n      return;\n    }\n\n    // A function cannot capture state in memory if it only reads memory, it can\n    // however return/throw state and the state might be influenced by the\n    // pointer value, e.g., loading from a returned pointer might reveal a bit.\n    if (F.onlyReadsMemory())\n      State.addKnownBits(NOT_CAPTURED_IN_MEM);\n\n    // A function cannot communicate state back if it does not through\n    // exceptions and doesn not return values.\n    if (F.doesNotThrow() && F.getReturnType()->isVoidTy())\n      State.addKnownBits(NOT_CAPTURED_IN_RET);\n\n    // Check existing \"returned\" attributes.\n    int ArgNo = IRP.getCalleeArgNo();\n    if (F.doesNotThrow() && ArgNo >= 0) {\n      for (unsigned u = 0, e = F.arg_size(); u < e; ++u)\n        if (F.hasParamAttribute(u, Attribute::Returned)) {\n          if (u == unsigned(ArgNo))\n            State.removeAssumedBits(NOT_CAPTURED_IN_RET);\n          else if (F.onlyReadsMemory())\n            State.addKnownBits(NO_CAPTURE);\n          else\n            State.addKnownBits(NOT_CAPTURED_IN_RET);\n          break;\n        }\n    }\n  }\n\n  /// See AbstractState::getAsStr().\n  const std::string getAsStr() const override {\n    if (isKnownNoCapture())\n      return \"known not-captured\";\n    if (isAssumedNoCapture())\n      return \"assumed not-captured\";\n    if (isKnownNoCaptureMaybeReturned())\n      return \"known not-captured-maybe-returned\";\n    if (isAssumedNoCaptureMaybeReturned())\n      return \"assumed not-captured-maybe-returned\";\n    return \"assumed-captured\";\n  }\n};\n\n/// Attributor-aware capture tracker.\nstruct AACaptureUseTracker final : public CaptureTracker {\n\n  /// Create a capture tracker that can lookup in-flight abstract attributes\n  /// through the Attributor \\p A.\n  ///\n  /// If a use leads to a potential capture, \\p CapturedInMemory is set and the\n  /// search is stopped. If a use leads to a return instruction,\n  /// \\p CommunicatedBack is set to true and \\p CapturedInMemory is not changed.\n  /// If a use leads to a ptr2int which may capture the value,\n  /// \\p CapturedInInteger is set. If a use is found that is currently assumed\n  /// \"no-capture-maybe-returned\", the user is added to the \\p PotentialCopies\n  /// set. All values in \\p PotentialCopies are later tracked as well. For every\n  /// explored use we decrement \\p RemainingUsesToExplore. Once it reaches 0,\n  /// the search is stopped with \\p CapturedInMemory and \\p CapturedInInteger\n  /// conservatively set to true.\n  AACaptureUseTracker(Attributor &A, AANoCapture &NoCaptureAA,\n                      const AAIsDead &IsDeadAA, AANoCapture::StateType &State,\n                      SmallVectorImpl<const Value *> &PotentialCopies,\n                      unsigned &RemainingUsesToExplore)\n      : A(A), NoCaptureAA(NoCaptureAA), IsDeadAA(IsDeadAA), State(State),\n        PotentialCopies(PotentialCopies),\n        RemainingUsesToExplore(RemainingUsesToExplore) {}\n\n  /// Determine if \\p V maybe captured. *Also updates the state!*\n  bool valueMayBeCaptured(const Value *V) {\n    if (V->getType()->isPointerTy()) {\n      PointerMayBeCaptured(V, this);\n    } else {\n      State.indicatePessimisticFixpoint();\n    }\n    return State.isAssumed(AANoCapture::NO_CAPTURE_MAYBE_RETURNED);\n  }\n\n  /// See CaptureTracker::tooManyUses().\n  void tooManyUses() override {\n    State.removeAssumedBits(AANoCapture::NO_CAPTURE);\n  }\n\n  bool isDereferenceableOrNull(Value *O, const DataLayout &DL) override {\n    if (CaptureTracker::isDereferenceableOrNull(O, DL))\n      return true;\n    const auto &DerefAA = A.getAAFor<AADereferenceable>(\n        NoCaptureAA, IRPosition::value(*O), DepClassTy::OPTIONAL);\n    return DerefAA.getAssumedDereferenceableBytes();\n  }\n\n  /// See CaptureTracker::captured(...).\n  bool captured(const Use *U) override {\n    Instruction *UInst = cast<Instruction>(U->getUser());\n    LLVM_DEBUG(dbgs() << \"Check use: \" << *U->get() << \" in \" << *UInst\n                      << \"\\n\");\n\n    // Because we may reuse the tracker multiple times we keep track of the\n    // number of explored uses ourselves as well.\n    if (RemainingUsesToExplore-- == 0) {\n      LLVM_DEBUG(dbgs() << \" - too many uses to explore!\\n\");\n      return isCapturedIn(/* Memory */ true, /* Integer */ true,\n                          /* Return */ true);\n    }\n\n    // Deal with ptr2int by following uses.\n    if (isa<PtrToIntInst>(UInst)) {\n      LLVM_DEBUG(dbgs() << \" - ptr2int assume the worst!\\n\");\n      return valueMayBeCaptured(UInst);\n    }\n\n    // Explicitly catch return instructions.\n    if (isa<ReturnInst>(UInst))\n      return isCapturedIn(/* Memory */ false, /* Integer */ false,\n                          /* Return */ true);\n\n    // For now we only use special logic for call sites. However, the tracker\n    // itself knows about a lot of other non-capturing cases already.\n    auto *CB = dyn_cast<CallBase>(UInst);\n    if (!CB || !CB->isArgOperand(U))\n      return isCapturedIn(/* Memory */ true, /* Integer */ true,\n                          /* Return */ true);\n\n    unsigned ArgNo = CB->getArgOperandNo(U);\n    const IRPosition &CSArgPos = IRPosition::callsite_argument(*CB, ArgNo);\n    // If we have a abstract no-capture attribute for the argument we can use\n    // it to justify a non-capture attribute here. This allows recursion!\n    auto &ArgNoCaptureAA =\n        A.getAAFor<AANoCapture>(NoCaptureAA, CSArgPos, DepClassTy::REQUIRED);\n    if (ArgNoCaptureAA.isAssumedNoCapture())\n      return isCapturedIn(/* Memory */ false, /* Integer */ false,\n                          /* Return */ false);\n    if (ArgNoCaptureAA.isAssumedNoCaptureMaybeReturned()) {\n      addPotentialCopy(*CB);\n      return isCapturedIn(/* Memory */ false, /* Integer */ false,\n                          /* Return */ false);\n    }\n\n    // Lastly, we could not find a reason no-capture can be assumed so we don't.\n    return isCapturedIn(/* Memory */ true, /* Integer */ true,\n                        /* Return */ true);\n  }\n\n  /// Register \\p CS as potential copy of the value we are checking.\n  void addPotentialCopy(CallBase &CB) { PotentialCopies.push_back(&CB); }\n\n  /// See CaptureTracker::shouldExplore(...).\n  bool shouldExplore(const Use *U) override {\n    // Check liveness and ignore droppable users.\n    return !U->getUser()->isDroppable() &&\n           !A.isAssumedDead(*U, &NoCaptureAA, &IsDeadAA);\n  }\n\n  /// Update the state according to \\p CapturedInMem, \\p CapturedInInt, and\n  /// \\p CapturedInRet, then return the appropriate value for use in the\n  /// CaptureTracker::captured() interface.\n  bool isCapturedIn(bool CapturedInMem, bool CapturedInInt,\n                    bool CapturedInRet) {\n    LLVM_DEBUG(dbgs() << \" - captures [Mem \" << CapturedInMem << \"|Int \"\n                      << CapturedInInt << \"|Ret \" << CapturedInRet << \"]\\n\");\n    if (CapturedInMem)\n      State.removeAssumedBits(AANoCapture::NOT_CAPTURED_IN_MEM);\n    if (CapturedInInt)\n      State.removeAssumedBits(AANoCapture::NOT_CAPTURED_IN_INT);\n    if (CapturedInRet)\n      State.removeAssumedBits(AANoCapture::NOT_CAPTURED_IN_RET);\n    return !State.isAssumed(AANoCapture::NO_CAPTURE_MAYBE_RETURNED);\n  }\n\nprivate:\n  /// The attributor providing in-flight abstract attributes.\n  Attributor &A;\n\n  /// The abstract attribute currently updated.\n  AANoCapture &NoCaptureAA;\n\n  /// The abstract liveness state.\n  const AAIsDead &IsDeadAA;\n\n  /// The state currently updated.\n  AANoCapture::StateType &State;\n\n  /// Set of potential copies of the tracked value.\n  SmallVectorImpl<const Value *> &PotentialCopies;\n\n  /// Global counter to limit the number of explored uses.\n  unsigned &RemainingUsesToExplore;\n};\n\nChangeStatus AANoCaptureImpl::updateImpl(Attributor &A) {\n  const IRPosition &IRP = getIRPosition();\n  const Value *V = isArgumentPosition() ? IRP.getAssociatedArgument()\n                                        : &IRP.getAssociatedValue();\n  if (!V)\n    return indicatePessimisticFixpoint();\n\n  const Function *F =\n      isArgumentPosition() ? IRP.getAssociatedFunction() : IRP.getAnchorScope();\n  assert(F && \"Expected a function!\");\n  const IRPosition &FnPos = IRPosition::function(*F);\n  const auto &IsDeadAA = A.getAAFor<AAIsDead>(*this, FnPos, DepClassTy::NONE);\n\n  AANoCapture::StateType T;\n\n  // Readonly means we cannot capture through memory.\n  const auto &FnMemAA =\n      A.getAAFor<AAMemoryBehavior>(*this, FnPos, DepClassTy::NONE);\n  if (FnMemAA.isAssumedReadOnly()) {\n    T.addKnownBits(NOT_CAPTURED_IN_MEM);\n    if (FnMemAA.isKnownReadOnly())\n      addKnownBits(NOT_CAPTURED_IN_MEM);\n    else\n      A.recordDependence(FnMemAA, *this, DepClassTy::OPTIONAL);\n  }\n\n  // Make sure all returned values are different than the underlying value.\n  // TODO: we could do this in a more sophisticated way inside\n  //       AAReturnedValues, e.g., track all values that escape through returns\n  //       directly somehow.\n  auto CheckReturnedArgs = [&](const AAReturnedValues &RVAA) {\n    bool SeenConstant = false;\n    for (auto &It : RVAA.returned_values()) {\n      if (isa<Constant>(It.first)) {\n        if (SeenConstant)\n          return false;\n        SeenConstant = true;\n      } else if (!isa<Argument>(It.first) ||\n                 It.first == getAssociatedArgument())\n        return false;\n    }\n    return true;\n  };\n\n  const auto &NoUnwindAA =\n      A.getAAFor<AANoUnwind>(*this, FnPos, DepClassTy::OPTIONAL);\n  if (NoUnwindAA.isAssumedNoUnwind()) {\n    bool IsVoidTy = F->getReturnType()->isVoidTy();\n    const AAReturnedValues *RVAA =\n        IsVoidTy ? nullptr\n                 : &A.getAAFor<AAReturnedValues>(*this, FnPos,\n\n                                                 DepClassTy::OPTIONAL);\n    if (IsVoidTy || CheckReturnedArgs(*RVAA)) {\n      T.addKnownBits(NOT_CAPTURED_IN_RET);\n      if (T.isKnown(NOT_CAPTURED_IN_MEM))\n        return ChangeStatus::UNCHANGED;\n      if (NoUnwindAA.isKnownNoUnwind() &&\n          (IsVoidTy || RVAA->getState().isAtFixpoint())) {\n        addKnownBits(NOT_CAPTURED_IN_RET);\n        if (isKnown(NOT_CAPTURED_IN_MEM))\n          return indicateOptimisticFixpoint();\n      }\n    }\n  }\n\n  // Use the CaptureTracker interface and logic with the specialized tracker,\n  // defined in AACaptureUseTracker, that can look at in-flight abstract\n  // attributes and directly updates the assumed state.\n  SmallVector<const Value *, 4> PotentialCopies;\n  unsigned RemainingUsesToExplore =\n      getDefaultMaxUsesToExploreForCaptureTracking();\n  AACaptureUseTracker Tracker(A, *this, IsDeadAA, T, PotentialCopies,\n                              RemainingUsesToExplore);\n\n  // Check all potential copies of the associated value until we can assume\n  // none will be captured or we have to assume at least one might be.\n  unsigned Idx = 0;\n  PotentialCopies.push_back(V);\n  while (T.isAssumed(NO_CAPTURE_MAYBE_RETURNED) && Idx < PotentialCopies.size())\n    Tracker.valueMayBeCaptured(PotentialCopies[Idx++]);\n\n  AANoCapture::StateType &S = getState();\n  auto Assumed = S.getAssumed();\n  S.intersectAssumedBits(T.getAssumed());\n  if (!isAssumedNoCaptureMaybeReturned())\n    return indicatePessimisticFixpoint();\n  return Assumed == S.getAssumed() ? ChangeStatus::UNCHANGED\n                                   : ChangeStatus::CHANGED;\n}\n\n/// NoCapture attribute for function arguments.\nstruct AANoCaptureArgument final : AANoCaptureImpl {\n  AANoCaptureArgument(const IRPosition &IRP, Attributor &A)\n      : AANoCaptureImpl(IRP, A) {}\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_ARG_ATTR(nocapture) }\n};\n\n/// NoCapture attribute for call site arguments.\nstruct AANoCaptureCallSiteArgument final : AANoCaptureImpl {\n  AANoCaptureCallSiteArgument(const IRPosition &IRP, Attributor &A)\n      : AANoCaptureImpl(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    if (Argument *Arg = getAssociatedArgument())\n      if (Arg->hasByValAttr())\n        indicateOptimisticFixpoint();\n    AANoCaptureImpl::initialize(A);\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    // TODO: Once we have call site specific value information we can provide\n    //       call site specific liveness information and then it makes\n    //       sense to specialize attributes for call sites arguments instead of\n    //       redirecting requests to the callee argument.\n    Argument *Arg = getAssociatedArgument();\n    if (!Arg)\n      return indicatePessimisticFixpoint();\n    const IRPosition &ArgPos = IRPosition::argument(*Arg);\n    auto &ArgAA = A.getAAFor<AANoCapture>(*this, ArgPos, DepClassTy::REQUIRED);\n    return clampStateAndIndicateChange(getState(), ArgAA.getState());\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override{STATS_DECLTRACK_CSARG_ATTR(nocapture)};\n};\n\n/// NoCapture attribute for floating values.\nstruct AANoCaptureFloating final : AANoCaptureImpl {\n  AANoCaptureFloating(const IRPosition &IRP, Attributor &A)\n      : AANoCaptureImpl(IRP, A) {}\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    STATS_DECLTRACK_FLOATING_ATTR(nocapture)\n  }\n};\n\n/// NoCapture attribute for function return value.\nstruct AANoCaptureReturned final : AANoCaptureImpl {\n  AANoCaptureReturned(const IRPosition &IRP, Attributor &A)\n      : AANoCaptureImpl(IRP, A) {\n    llvm_unreachable(\"NoCapture is not applicable to function returns!\");\n  }\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    llvm_unreachable(\"NoCapture is not applicable to function returns!\");\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    llvm_unreachable(\"NoCapture is not applicable to function returns!\");\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {}\n};\n\n/// NoCapture attribute deduction for a call site return value.\nstruct AANoCaptureCallSiteReturned final : AANoCaptureImpl {\n  AANoCaptureCallSiteReturned(const IRPosition &IRP, Attributor &A)\n      : AANoCaptureImpl(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    const Function *F = getAnchorScope();\n    // Check what state the associated function can actually capture.\n    determineFunctionCaptureCapabilities(getIRPosition(), *F, *this);\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    STATS_DECLTRACK_CSRET_ATTR(nocapture)\n  }\n};\n\n/// ------------------ Value Simplify Attribute ----------------------------\nstruct AAValueSimplifyImpl : AAValueSimplify {\n  AAValueSimplifyImpl(const IRPosition &IRP, Attributor &A)\n      : AAValueSimplify(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    if (getAssociatedValue().getType()->isVoidTy())\n      indicatePessimisticFixpoint();\n  }\n\n  /// See AbstractAttribute::getAsStr().\n  const std::string getAsStr() const override {\n    return getAssumed() ? (getKnown() ? \"simplified\" : \"maybe-simple\")\n                        : \"not-simple\";\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {}\n\n  /// See AAValueSimplify::getAssumedSimplifiedValue()\n  Optional<Value *> getAssumedSimplifiedValue(Attributor &A) const override {\n    if (!getAssumed())\n      return const_cast<Value *>(&getAssociatedValue());\n    return SimplifiedAssociatedValue;\n  }\n\n  /// Helper function for querying AAValueSimplify and updating candicate.\n  /// \\param QueryingValue Value trying to unify with SimplifiedValue\n  /// \\param AccumulatedSimplifiedValue Current simplification result.\n  static bool checkAndUpdate(Attributor &A, const AbstractAttribute &QueryingAA,\n                             Value &QueryingValue,\n                             Optional<Value *> &AccumulatedSimplifiedValue) {\n    // FIXME: Add a typecast support.\n\n    auto &ValueSimplifyAA = A.getAAFor<AAValueSimplify>(\n        QueryingAA, IRPosition::value(QueryingValue), DepClassTy::REQUIRED);\n\n    Optional<Value *> QueryingValueSimplified =\n        ValueSimplifyAA.getAssumedSimplifiedValue(A);\n\n    if (!QueryingValueSimplified.hasValue())\n      return true;\n\n    if (!QueryingValueSimplified.getValue())\n      return false;\n\n    Value &QueryingValueSimplifiedUnwrapped =\n        *QueryingValueSimplified.getValue();\n\n    if (AccumulatedSimplifiedValue.hasValue() &&\n        !isa<UndefValue>(AccumulatedSimplifiedValue.getValue()) &&\n        !isa<UndefValue>(QueryingValueSimplifiedUnwrapped))\n      return AccumulatedSimplifiedValue == QueryingValueSimplified;\n    if (AccumulatedSimplifiedValue.hasValue() &&\n        isa<UndefValue>(QueryingValueSimplifiedUnwrapped))\n      return true;\n\n    LLVM_DEBUG(dbgs() << \"[ValueSimplify] \" << QueryingValue\n                      << \" is assumed to be \"\n                      << QueryingValueSimplifiedUnwrapped << \"\\n\");\n\n    AccumulatedSimplifiedValue = QueryingValueSimplified;\n    return true;\n  }\n\n  /// Returns a candidate is found or not\n  template <typename AAType> bool askSimplifiedValueFor(Attributor &A) {\n    if (!getAssociatedValue().getType()->isIntegerTy())\n      return false;\n\n    const auto &AA =\n        A.getAAFor<AAType>(*this, getIRPosition(), DepClassTy::NONE);\n\n    Optional<ConstantInt *> COpt = AA.getAssumedConstantInt(A);\n\n    if (!COpt.hasValue()) {\n      SimplifiedAssociatedValue = llvm::None;\n      A.recordDependence(AA, *this, DepClassTy::OPTIONAL);\n      return true;\n    }\n    if (auto *C = COpt.getValue()) {\n      SimplifiedAssociatedValue = C;\n      A.recordDependence(AA, *this, DepClassTy::OPTIONAL);\n      return true;\n    }\n    return false;\n  }\n\n  bool askSimplifiedValueForOtherAAs(Attributor &A) {\n    if (askSimplifiedValueFor<AAValueConstantRange>(A))\n      return true;\n    if (askSimplifiedValueFor<AAPotentialValues>(A))\n      return true;\n    return false;\n  }\n\n  /// See AbstractAttribute::manifest(...).\n  ChangeStatus manifest(Attributor &A) override {\n    ChangeStatus Changed = ChangeStatus::UNCHANGED;\n\n    if (SimplifiedAssociatedValue.hasValue() &&\n        !SimplifiedAssociatedValue.getValue())\n      return Changed;\n\n    Value &V = getAssociatedValue();\n    auto *C = SimplifiedAssociatedValue.hasValue()\n                  ? dyn_cast<Constant>(SimplifiedAssociatedValue.getValue())\n                  : UndefValue::get(V.getType());\n    if (C) {\n      // We can replace the AssociatedValue with the constant.\n      if (!V.user_empty() && &V != C && V.getType() == C->getType()) {\n        LLVM_DEBUG(dbgs() << \"[ValueSimplify] \" << V << \" -> \" << *C\n                          << \" :: \" << *this << \"\\n\");\n        if (A.changeValueAfterManifest(V, *C))\n          Changed = ChangeStatus::CHANGED;\n      }\n    }\n\n    return Changed | AAValueSimplify::manifest(A);\n  }\n\n  /// See AbstractState::indicatePessimisticFixpoint(...).\n  ChangeStatus indicatePessimisticFixpoint() override {\n    // NOTE: Associated value will be returned in a pessimistic fixpoint and is\n    // regarded as known. That's why`indicateOptimisticFixpoint` is called.\n    SimplifiedAssociatedValue = &getAssociatedValue();\n    indicateOptimisticFixpoint();\n    return ChangeStatus::CHANGED;\n  }\n\nprotected:\n  // An assumed simplified value. Initially, it is set to Optional::None, which\n  // means that the value is not clear under current assumption. If in the\n  // pessimistic state, getAssumedSimplifiedValue doesn't return this value but\n  // returns orignal associated value.\n  Optional<Value *> SimplifiedAssociatedValue;\n};\n\nstruct AAValueSimplifyArgument final : AAValueSimplifyImpl {\n  AAValueSimplifyArgument(const IRPosition &IRP, Attributor &A)\n      : AAValueSimplifyImpl(IRP, A) {}\n\n  void initialize(Attributor &A) override {\n    AAValueSimplifyImpl::initialize(A);\n    if (!getAnchorScope() || getAnchorScope()->isDeclaration())\n      indicatePessimisticFixpoint();\n    if (hasAttr({Attribute::InAlloca, Attribute::Preallocated,\n                 Attribute::StructRet, Attribute::Nest},\n                /* IgnoreSubsumingPositions */ true))\n      indicatePessimisticFixpoint();\n\n    // FIXME: This is a hack to prevent us from propagating function poiner in\n    // the new pass manager CGSCC pass as it creates call edges the\n    // CallGraphUpdater cannot handle yet.\n    Value &V = getAssociatedValue();\n    if (V.getType()->isPointerTy() &&\n        V.getType()->getPointerElementType()->isFunctionTy() &&\n        !A.isModulePass())\n      indicatePessimisticFixpoint();\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    // Byval is only replacable if it is readonly otherwise we would write into\n    // the replaced value and not the copy that byval creates implicitly.\n    Argument *Arg = getAssociatedArgument();\n    if (Arg->hasByValAttr()) {\n      // TODO: We probably need to verify synchronization is not an issue, e.g.,\n      //       there is no race by not copying a constant byval.\n      const auto &MemAA = A.getAAFor<AAMemoryBehavior>(*this, getIRPosition(),\n                                                       DepClassTy::REQUIRED);\n      if (!MemAA.isAssumedReadOnly())\n        return indicatePessimisticFixpoint();\n    }\n\n    bool HasValueBefore = SimplifiedAssociatedValue.hasValue();\n\n    auto PredForCallSite = [&](AbstractCallSite ACS) {\n      const IRPosition &ACSArgPos =\n          IRPosition::callsite_argument(ACS, getCallSiteArgNo());\n      // Check if a coresponding argument was found or if it is on not\n      // associated (which can happen for callback calls).\n      if (ACSArgPos.getPositionKind() == IRPosition::IRP_INVALID)\n        return false;\n\n      // We can only propagate thread independent values through callbacks.\n      // This is different to direct/indirect call sites because for them we\n      // know the thread executing the caller and callee is the same. For\n      // callbacks this is not guaranteed, thus a thread dependent value could\n      // be different for the caller and callee, making it invalid to propagate.\n      Value &ArgOp = ACSArgPos.getAssociatedValue();\n      if (ACS.isCallbackCall())\n        if (auto *C = dyn_cast<Constant>(&ArgOp))\n          if (C->isThreadDependent())\n            return false;\n      return checkAndUpdate(A, *this, ArgOp, SimplifiedAssociatedValue);\n    };\n\n    bool AllCallSitesKnown;\n    if (!A.checkForAllCallSites(PredForCallSite, *this, true,\n                                AllCallSitesKnown))\n      if (!askSimplifiedValueForOtherAAs(A))\n        return indicatePessimisticFixpoint();\n\n    // If a candicate was found in this update, return CHANGED.\n    return HasValueBefore == SimplifiedAssociatedValue.hasValue()\n               ? ChangeStatus::UNCHANGED\n               : ChangeStatus ::CHANGED;\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    STATS_DECLTRACK_ARG_ATTR(value_simplify)\n  }\n};\n\nstruct AAValueSimplifyReturned : AAValueSimplifyImpl {\n  AAValueSimplifyReturned(const IRPosition &IRP, Attributor &A)\n      : AAValueSimplifyImpl(IRP, A) {}\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    bool HasValueBefore = SimplifiedAssociatedValue.hasValue();\n\n    auto PredForReturned = [&](Value &V) {\n      return checkAndUpdate(A, *this, V, SimplifiedAssociatedValue);\n    };\n\n    if (!A.checkForAllReturnedValues(PredForReturned, *this))\n      if (!askSimplifiedValueForOtherAAs(A))\n        return indicatePessimisticFixpoint();\n\n    // If a candicate was found in this update, return CHANGED.\n    return HasValueBefore == SimplifiedAssociatedValue.hasValue()\n               ? ChangeStatus::UNCHANGED\n               : ChangeStatus ::CHANGED;\n  }\n\n  ChangeStatus manifest(Attributor &A) override {\n    ChangeStatus Changed = ChangeStatus::UNCHANGED;\n\n    if (SimplifiedAssociatedValue.hasValue() &&\n        !SimplifiedAssociatedValue.getValue())\n      return Changed;\n\n    Value &V = getAssociatedValue();\n    auto *C = SimplifiedAssociatedValue.hasValue()\n                  ? dyn_cast<Constant>(SimplifiedAssociatedValue.getValue())\n                  : UndefValue::get(V.getType());\n    if (C) {\n      auto PredForReturned =\n          [&](Value &V, const SmallSetVector<ReturnInst *, 4> &RetInsts) {\n            // We can replace the AssociatedValue with the constant.\n            if (&V == C || V.getType() != C->getType() || isa<UndefValue>(V))\n              return true;\n\n            for (ReturnInst *RI : RetInsts) {\n              if (RI->getFunction() != getAnchorScope())\n                continue;\n              auto *RC = C;\n              if (RC->getType() != RI->getReturnValue()->getType())\n                RC = ConstantExpr::getBitCast(RC,\n                                              RI->getReturnValue()->getType());\n              LLVM_DEBUG(dbgs() << \"[ValueSimplify] \" << V << \" -> \" << *RC\n                                << \" in \" << *RI << \" :: \" << *this << \"\\n\");\n              if (A.changeUseAfterManifest(RI->getOperandUse(0), *RC))\n                Changed = ChangeStatus::CHANGED;\n            }\n            return true;\n          };\n      A.checkForAllReturnedValuesAndReturnInsts(PredForReturned, *this);\n    }\n\n    return Changed | AAValueSimplify::manifest(A);\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    STATS_DECLTRACK_FNRET_ATTR(value_simplify)\n  }\n};\n\nstruct AAValueSimplifyFloating : AAValueSimplifyImpl {\n  AAValueSimplifyFloating(const IRPosition &IRP, Attributor &A)\n      : AAValueSimplifyImpl(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    // FIXME: This might have exposed a SCC iterator update bug in the old PM.\n    //        Needs investigation.\n    // AAValueSimplifyImpl::initialize(A);\n    Value &V = getAnchorValue();\n\n    // TODO: add other stuffs\n    if (isa<Constant>(V))\n      indicatePessimisticFixpoint();\n  }\n\n  /// Check if \\p ICmp is an equality comparison (==/!=) with at least one\n  /// nullptr. If so, try to simplify it using AANonNull on the other operand.\n  /// Return true if successful, in that case SimplifiedAssociatedValue will be\n  /// updated and \\p Changed is set appropriately.\n  bool checkForNullPtrCompare(Attributor &A, ICmpInst *ICmp,\n                              ChangeStatus &Changed) {\n    if (!ICmp)\n      return false;\n    if (!ICmp->isEquality())\n      return false;\n\n    // This is a comparison with == or !-. We check for nullptr now.\n    bool Op0IsNull = isa<ConstantPointerNull>(ICmp->getOperand(0));\n    bool Op1IsNull = isa<ConstantPointerNull>(ICmp->getOperand(1));\n    if (!Op0IsNull && !Op1IsNull)\n      return false;\n\n    LLVMContext &Ctx = ICmp->getContext();\n    // Check for `nullptr ==/!= nullptr` first:\n    if (Op0IsNull && Op1IsNull) {\n      Value *NewVal = ConstantInt::get(\n          Type::getInt1Ty(Ctx), ICmp->getPredicate() == CmpInst::ICMP_EQ);\n      assert(!SimplifiedAssociatedValue.hasValue() &&\n             \"Did not expect non-fixed value for constant comparison\");\n      SimplifiedAssociatedValue = NewVal;\n      indicateOptimisticFixpoint();\n      Changed = ChangeStatus::CHANGED;\n      return true;\n    }\n\n    // Left is the nullptr ==/!= non-nullptr case. We'll use AANonNull on the\n    // non-nullptr operand and if we assume it's non-null we can conclude the\n    // result of the comparison.\n    assert((Op0IsNull || Op1IsNull) &&\n           \"Expected nullptr versus non-nullptr comparison at this point\");\n\n    // The index is the operand that we assume is not null.\n    unsigned PtrIdx = Op0IsNull;\n    auto &PtrNonNullAA = A.getAAFor<AANonNull>(\n        *this, IRPosition::value(*ICmp->getOperand(PtrIdx)),\n        DepClassTy::REQUIRED);\n    if (!PtrNonNullAA.isAssumedNonNull())\n      return false;\n\n    // The new value depends on the predicate, true for != and false for ==.\n    Value *NewVal = ConstantInt::get(Type::getInt1Ty(Ctx),\n                                     ICmp->getPredicate() == CmpInst::ICMP_NE);\n\n    assert((!SimplifiedAssociatedValue.hasValue() ||\n            SimplifiedAssociatedValue == NewVal) &&\n           \"Did not expect to change value for zero-comparison\");\n\n    bool HasValueBefore = SimplifiedAssociatedValue.hasValue();\n    SimplifiedAssociatedValue = NewVal;\n\n    if (PtrNonNullAA.isKnownNonNull())\n      indicateOptimisticFixpoint();\n\n    Changed = HasValueBefore ? ChangeStatus::UNCHANGED : ChangeStatus ::CHANGED;\n    return true;\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    bool HasValueBefore = SimplifiedAssociatedValue.hasValue();\n\n    ChangeStatus Changed;\n    if (checkForNullPtrCompare(A, dyn_cast<ICmpInst>(&getAnchorValue()),\n                               Changed))\n      return Changed;\n\n    auto VisitValueCB = [&](Value &V, const Instruction *CtxI, bool &,\n                            bool Stripped) -> bool {\n      auto &AA = A.getAAFor<AAValueSimplify>(*this, IRPosition::value(V),\n                                             DepClassTy::REQUIRED);\n      if (!Stripped && this == &AA) {\n        // TODO: Look the instruction and check recursively.\n\n        LLVM_DEBUG(dbgs() << \"[ValueSimplify] Can't be stripped more : \" << V\n                          << \"\\n\");\n        return false;\n      }\n      return checkAndUpdate(A, *this, V, SimplifiedAssociatedValue);\n    };\n\n    bool Dummy = false;\n    if (!genericValueTraversal<AAValueSimplify, bool>(\n            A, getIRPosition(), *this, Dummy, VisitValueCB, getCtxI(),\n            /* UseValueSimplify */ false))\n      if (!askSimplifiedValueForOtherAAs(A))\n        return indicatePessimisticFixpoint();\n\n    // If a candicate was found in this update, return CHANGED.\n\n    return HasValueBefore == SimplifiedAssociatedValue.hasValue()\n               ? ChangeStatus::UNCHANGED\n               : ChangeStatus ::CHANGED;\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    STATS_DECLTRACK_FLOATING_ATTR(value_simplify)\n  }\n};\n\nstruct AAValueSimplifyFunction : AAValueSimplifyImpl {\n  AAValueSimplifyFunction(const IRPosition &IRP, Attributor &A)\n      : AAValueSimplifyImpl(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    SimplifiedAssociatedValue = &getAnchorValue();\n    indicateOptimisticFixpoint();\n  }\n  /// See AbstractAttribute::initialize(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    llvm_unreachable(\n        \"AAValueSimplify(Function|CallSite)::updateImpl will not be called\");\n  }\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    STATS_DECLTRACK_FN_ATTR(value_simplify)\n  }\n};\n\nstruct AAValueSimplifyCallSite : AAValueSimplifyFunction {\n  AAValueSimplifyCallSite(const IRPosition &IRP, Attributor &A)\n      : AAValueSimplifyFunction(IRP, A) {}\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    STATS_DECLTRACK_CS_ATTR(value_simplify)\n  }\n};\n\nstruct AAValueSimplifyCallSiteReturned : AAValueSimplifyReturned {\n  AAValueSimplifyCallSiteReturned(const IRPosition &IRP, Attributor &A)\n      : AAValueSimplifyReturned(IRP, A) {}\n\n  /// See AbstractAttribute::manifest(...).\n  ChangeStatus manifest(Attributor &A) override {\n    return AAValueSimplifyImpl::manifest(A);\n  }\n\n  void trackStatistics() const override {\n    STATS_DECLTRACK_CSRET_ATTR(value_simplify)\n  }\n};\nstruct AAValueSimplifyCallSiteArgument : AAValueSimplifyFloating {\n  AAValueSimplifyCallSiteArgument(const IRPosition &IRP, Attributor &A)\n      : AAValueSimplifyFloating(IRP, A) {}\n\n  /// See AbstractAttribute::manifest(...).\n  ChangeStatus manifest(Attributor &A) override {\n    ChangeStatus Changed = ChangeStatus::UNCHANGED;\n\n    if (SimplifiedAssociatedValue.hasValue() &&\n        !SimplifiedAssociatedValue.getValue())\n      return Changed;\n\n    Value &V = getAssociatedValue();\n    auto *C = SimplifiedAssociatedValue.hasValue()\n                  ? dyn_cast<Constant>(SimplifiedAssociatedValue.getValue())\n                  : UndefValue::get(V.getType());\n    if (C) {\n      Use &U = cast<CallBase>(&getAnchorValue())\n                   ->getArgOperandUse(getCallSiteArgNo());\n      // We can replace the AssociatedValue with the constant.\n      if (&V != C && V.getType() == C->getType()) {\n        if (A.changeUseAfterManifest(U, *C))\n          Changed = ChangeStatus::CHANGED;\n      }\n    }\n\n    return Changed | AAValueSimplify::manifest(A);\n  }\n\n  void trackStatistics() const override {\n    STATS_DECLTRACK_CSARG_ATTR(value_simplify)\n  }\n};\n\n/// ----------------------- Heap-To-Stack Conversion ---------------------------\nstruct AAHeapToStackImpl : public AAHeapToStack {\n  AAHeapToStackImpl(const IRPosition &IRP, Attributor &A)\n      : AAHeapToStack(IRP, A) {}\n\n  const std::string getAsStr() const override {\n    return \"[H2S] Mallocs: \" + std::to_string(MallocCalls.size());\n  }\n\n  ChangeStatus manifest(Attributor &A) override {\n    assert(getState().isValidState() &&\n           \"Attempted to manifest an invalid state!\");\n\n    ChangeStatus HasChanged = ChangeStatus::UNCHANGED;\n    Function *F = getAnchorScope();\n    const auto *TLI = A.getInfoCache().getTargetLibraryInfoForFunction(*F);\n\n    for (Instruction *MallocCall : MallocCalls) {\n      // This malloc cannot be replaced.\n      if (BadMallocCalls.count(MallocCall))\n        continue;\n\n      for (Instruction *FreeCall : FreesForMalloc[MallocCall]) {\n        LLVM_DEBUG(dbgs() << \"H2S: Removing free call: \" << *FreeCall << \"\\n\");\n        A.deleteAfterManifest(*FreeCall);\n        HasChanged = ChangeStatus::CHANGED;\n      }\n\n      LLVM_DEBUG(dbgs() << \"H2S: Removing malloc call: \" << *MallocCall\n                        << \"\\n\");\n\n      Align Alignment;\n      Value *Size;\n      if (isCallocLikeFn(MallocCall, TLI)) {\n        auto *Num = MallocCall->getOperand(0);\n        auto *SizeT = MallocCall->getOperand(1);\n        IRBuilder<> B(MallocCall);\n        Size = B.CreateMul(Num, SizeT, \"h2s.calloc.size\");\n      } else if (isAlignedAllocLikeFn(MallocCall, TLI)) {\n        Size = MallocCall->getOperand(1);\n        Alignment = MaybeAlign(cast<ConstantInt>(MallocCall->getOperand(0))\n                                   ->getValue()\n                                   .getZExtValue())\n                        .valueOrOne();\n      } else {\n        Size = MallocCall->getOperand(0);\n      }\n\n      unsigned AS = cast<PointerType>(MallocCall->getType())->getAddressSpace();\n      Instruction *AI =\n          new AllocaInst(Type::getInt8Ty(F->getContext()), AS, Size, Alignment,\n                         \"\", MallocCall->getNextNode());\n\n      if (AI->getType() != MallocCall->getType())\n        AI = new BitCastInst(AI, MallocCall->getType(), \"malloc_bc\",\n                             AI->getNextNode());\n\n      A.changeValueAfterManifest(*MallocCall, *AI);\n\n      if (auto *II = dyn_cast<InvokeInst>(MallocCall)) {\n        auto *NBB = II->getNormalDest();\n        BranchInst::Create(NBB, MallocCall->getParent());\n        A.deleteAfterManifest(*MallocCall);\n      } else {\n        A.deleteAfterManifest(*MallocCall);\n      }\n\n      // Zero out the allocated memory if it was a calloc.\n      if (isCallocLikeFn(MallocCall, TLI)) {\n        auto *BI = new BitCastInst(AI, MallocCall->getType(), \"calloc_bc\",\n                                   AI->getNextNode());\n        Value *Ops[] = {\n            BI, ConstantInt::get(F->getContext(), APInt(8, 0, false)), Size,\n            ConstantInt::get(Type::getInt1Ty(F->getContext()), false)};\n\n        Type *Tys[] = {BI->getType(), MallocCall->getOperand(0)->getType()};\n        Module *M = F->getParent();\n        Function *Fn = Intrinsic::getDeclaration(M, Intrinsic::memset, Tys);\n        CallInst::Create(Fn, Ops, \"\", BI->getNextNode());\n      }\n      HasChanged = ChangeStatus::CHANGED;\n    }\n\n    return HasChanged;\n  }\n\n  /// Collection of all malloc calls in a function.\n  SmallSetVector<Instruction *, 4> MallocCalls;\n\n  /// Collection of malloc calls that cannot be converted.\n  DenseSet<const Instruction *> BadMallocCalls;\n\n  /// A map for each malloc call to the set of associated free calls.\n  DenseMap<Instruction *, SmallPtrSet<Instruction *, 4>> FreesForMalloc;\n\n  ChangeStatus updateImpl(Attributor &A) override;\n};\n\nChangeStatus AAHeapToStackImpl::updateImpl(Attributor &A) {\n  const Function *F = getAnchorScope();\n  const auto *TLI = A.getInfoCache().getTargetLibraryInfoForFunction(*F);\n\n  MustBeExecutedContextExplorer &Explorer =\n      A.getInfoCache().getMustBeExecutedContextExplorer();\n\n  auto FreeCheck = [&](Instruction &I) {\n    const auto &Frees = FreesForMalloc.lookup(&I);\n    if (Frees.size() != 1)\n      return false;\n    Instruction *UniqueFree = *Frees.begin();\n    return Explorer.findInContextOf(UniqueFree, I.getNextNode());\n  };\n\n  auto UsesCheck = [&](Instruction &I) {\n    bool ValidUsesOnly = true;\n    bool MustUse = true;\n    auto Pred = [&](const Use &U, bool &Follow) -> bool {\n      Instruction *UserI = cast<Instruction>(U.getUser());\n      if (isa<LoadInst>(UserI))\n        return true;\n      if (auto *SI = dyn_cast<StoreInst>(UserI)) {\n        if (SI->getValueOperand() == U.get()) {\n          LLVM_DEBUG(dbgs()\n                     << \"[H2S] escaping store to memory: \" << *UserI << \"\\n\");\n          ValidUsesOnly = false;\n        } else {\n          // A store into the malloc'ed memory is fine.\n        }\n        return true;\n      }\n      if (auto *CB = dyn_cast<CallBase>(UserI)) {\n        if (!CB->isArgOperand(&U) || CB->isLifetimeStartOrEnd())\n          return true;\n        // Record malloc.\n        if (isFreeCall(UserI, TLI)) {\n          if (MustUse) {\n            FreesForMalloc[&I].insert(UserI);\n          } else {\n            LLVM_DEBUG(dbgs() << \"[H2S] free potentially on different mallocs: \"\n                              << *UserI << \"\\n\");\n            ValidUsesOnly = false;\n          }\n          return true;\n        }\n\n        unsigned ArgNo = CB->getArgOperandNo(&U);\n\n        const auto &NoCaptureAA = A.getAAFor<AANoCapture>(\n            *this, IRPosition::callsite_argument(*CB, ArgNo),\n            DepClassTy::REQUIRED);\n\n        // If a callsite argument use is nofree, we are fine.\n        const auto &ArgNoFreeAA = A.getAAFor<AANoFree>(\n            *this, IRPosition::callsite_argument(*CB, ArgNo),\n            DepClassTy::REQUIRED);\n\n        if (!NoCaptureAA.isAssumedNoCapture() ||\n            !ArgNoFreeAA.isAssumedNoFree()) {\n          LLVM_DEBUG(dbgs() << \"[H2S] Bad user: \" << *UserI << \"\\n\");\n          ValidUsesOnly = false;\n        }\n        return true;\n      }\n\n      if (isa<GetElementPtrInst>(UserI) || isa<BitCastInst>(UserI) ||\n          isa<PHINode>(UserI) || isa<SelectInst>(UserI)) {\n        MustUse &= !(isa<PHINode>(UserI) || isa<SelectInst>(UserI));\n        Follow = true;\n        return true;\n      }\n      // Unknown user for which we can not track uses further (in a way that\n      // makes sense).\n      LLVM_DEBUG(dbgs() << \"[H2S] Unknown user: \" << *UserI << \"\\n\");\n      ValidUsesOnly = false;\n      return true;\n    };\n    A.checkForAllUses(Pred, *this, I);\n    return ValidUsesOnly;\n  };\n\n  auto MallocCallocCheck = [&](Instruction &I) {\n    if (BadMallocCalls.count(&I))\n      return true;\n\n    bool IsMalloc = isMallocLikeFn(&I, TLI);\n    bool IsAlignedAllocLike = isAlignedAllocLikeFn(&I, TLI);\n    bool IsCalloc = !IsMalloc && isCallocLikeFn(&I, TLI);\n    if (!IsMalloc && !IsAlignedAllocLike && !IsCalloc) {\n      BadMallocCalls.insert(&I);\n      return true;\n    }\n\n    if (IsMalloc) {\n      if (MaxHeapToStackSize == -1) {\n        if (UsesCheck(I) || FreeCheck(I)) {\n          MallocCalls.insert(&I);\n          return true;\n        }\n      }\n      if (auto *Size = dyn_cast<ConstantInt>(I.getOperand(0)))\n        if (Size->getValue().ule(MaxHeapToStackSize))\n          if (UsesCheck(I) || FreeCheck(I)) {\n            MallocCalls.insert(&I);\n            return true;\n          }\n    } else if (IsAlignedAllocLike && isa<ConstantInt>(I.getOperand(0))) {\n      if (MaxHeapToStackSize == -1) {\n        if (UsesCheck(I) || FreeCheck(I)) {\n          MallocCalls.insert(&I);\n          return true;\n        }\n      }\n      // Only if the alignment and sizes are constant.\n      if (auto *Size = dyn_cast<ConstantInt>(I.getOperand(1)))\n        if (Size->getValue().ule(MaxHeapToStackSize))\n          if (UsesCheck(I) || FreeCheck(I)) {\n            MallocCalls.insert(&I);\n            return true;\n          }\n    } else if (IsCalloc) {\n      if (MaxHeapToStackSize == -1) {\n        if (UsesCheck(I) || FreeCheck(I)) {\n          MallocCalls.insert(&I);\n          return true;\n        }\n      }\n      bool Overflow = false;\n      if (auto *Num = dyn_cast<ConstantInt>(I.getOperand(0)))\n        if (auto *Size = dyn_cast<ConstantInt>(I.getOperand(1)))\n          if ((Size->getValue().umul_ov(Num->getValue(), Overflow))\n                  .ule(MaxHeapToStackSize))\n            if (!Overflow && (UsesCheck(I) || FreeCheck(I))) {\n              MallocCalls.insert(&I);\n              return true;\n            }\n    }\n\n    BadMallocCalls.insert(&I);\n    return true;\n  };\n\n  size_t NumBadMallocs = BadMallocCalls.size();\n\n  A.checkForAllCallLikeInstructions(MallocCallocCheck, *this);\n\n  if (NumBadMallocs != BadMallocCalls.size())\n    return ChangeStatus::CHANGED;\n\n  return ChangeStatus::UNCHANGED;\n}\n\nstruct AAHeapToStackFunction final : public AAHeapToStackImpl {\n  AAHeapToStackFunction(const IRPosition &IRP, Attributor &A)\n      : AAHeapToStackImpl(IRP, A) {}\n\n  /// See AbstractAttribute::trackStatistics().\n  void trackStatistics() const override {\n    STATS_DECL(\n        MallocCalls, Function,\n        \"Number of malloc/calloc/aligned_alloc calls converted to allocas\");\n    for (auto *C : MallocCalls)\n      if (!BadMallocCalls.count(C))\n        ++BUILD_STAT_NAME(MallocCalls, Function);\n  }\n};\n\n/// ----------------------- Privatizable Pointers ------------------------------\nstruct AAPrivatizablePtrImpl : public AAPrivatizablePtr {\n  AAPrivatizablePtrImpl(const IRPosition &IRP, Attributor &A)\n      : AAPrivatizablePtr(IRP, A), PrivatizableType(llvm::None) {}\n\n  ChangeStatus indicatePessimisticFixpoint() override {\n    AAPrivatizablePtr::indicatePessimisticFixpoint();\n    PrivatizableType = nullptr;\n    return ChangeStatus::CHANGED;\n  }\n\n  /// Identify the type we can chose for a private copy of the underlying\n  /// argument. None means it is not clear yet, nullptr means there is none.\n  virtual Optional<Type *> identifyPrivatizableType(Attributor &A) = 0;\n\n  /// Return a privatizable type that encloses both T0 and T1.\n  /// TODO: This is merely a stub for now as we should manage a mapping as well.\n  Optional<Type *> combineTypes(Optional<Type *> T0, Optional<Type *> T1) {\n    if (!T0.hasValue())\n      return T1;\n    if (!T1.hasValue())\n      return T0;\n    if (T0 == T1)\n      return T0;\n    return nullptr;\n  }\n\n  Optional<Type *> getPrivatizableType() const override {\n    return PrivatizableType;\n  }\n\n  const std::string getAsStr() const override {\n    return isAssumedPrivatizablePtr() ? \"[priv]\" : \"[no-priv]\";\n  }\n\nprotected:\n  Optional<Type *> PrivatizableType;\n};\n\n// TODO: Do this for call site arguments (probably also other values) as well.\n\nstruct AAPrivatizablePtrArgument final : public AAPrivatizablePtrImpl {\n  AAPrivatizablePtrArgument(const IRPosition &IRP, Attributor &A)\n      : AAPrivatizablePtrImpl(IRP, A) {}\n\n  /// See AAPrivatizablePtrImpl::identifyPrivatizableType(...)\n  Optional<Type *> identifyPrivatizableType(Attributor &A) override {\n    // If this is a byval argument and we know all the call sites (so we can\n    // rewrite them), there is no need to check them explicitly.\n    bool AllCallSitesKnown;\n    if (getIRPosition().hasAttr(Attribute::ByVal) &&\n        A.checkForAllCallSites([](AbstractCallSite ACS) { return true; }, *this,\n                               true, AllCallSitesKnown))\n      return getAssociatedValue().getType()->getPointerElementType();\n\n    Optional<Type *> Ty;\n    unsigned ArgNo = getIRPosition().getCallSiteArgNo();\n\n    // Make sure the associated call site argument has the same type at all call\n    // sites and it is an allocation we know is safe to privatize, for now that\n    // means we only allow alloca instructions.\n    // TODO: We can additionally analyze the accesses in the callee to  create\n    //       the type from that information instead. That is a little more\n    //       involved and will be done in a follow up patch.\n    auto CallSiteCheck = [&](AbstractCallSite ACS) {\n      IRPosition ACSArgPos = IRPosition::callsite_argument(ACS, ArgNo);\n      // Check if a coresponding argument was found or if it is one not\n      // associated (which can happen for callback calls).\n      if (ACSArgPos.getPositionKind() == IRPosition::IRP_INVALID)\n        return false;\n\n      // Check that all call sites agree on a type.\n      auto &PrivCSArgAA =\n          A.getAAFor<AAPrivatizablePtr>(*this, ACSArgPos, DepClassTy::REQUIRED);\n      Optional<Type *> CSTy = PrivCSArgAA.getPrivatizableType();\n\n      LLVM_DEBUG({\n        dbgs() << \"[AAPrivatizablePtr] ACSPos: \" << ACSArgPos << \", CSTy: \";\n        if (CSTy.hasValue() && CSTy.getValue())\n          CSTy.getValue()->print(dbgs());\n        else if (CSTy.hasValue())\n          dbgs() << \"<nullptr>\";\n        else\n          dbgs() << \"<none>\";\n      });\n\n      Ty = combineTypes(Ty, CSTy);\n\n      LLVM_DEBUG({\n        dbgs() << \" : New Type: \";\n        if (Ty.hasValue() && Ty.getValue())\n          Ty.getValue()->print(dbgs());\n        else if (Ty.hasValue())\n          dbgs() << \"<nullptr>\";\n        else\n          dbgs() << \"<none>\";\n        dbgs() << \"\\n\";\n      });\n\n      return !Ty.hasValue() || Ty.getValue();\n    };\n\n    if (!A.checkForAllCallSites(CallSiteCheck, *this, true, AllCallSitesKnown))\n      return nullptr;\n    return Ty;\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    PrivatizableType = identifyPrivatizableType(A);\n    if (!PrivatizableType.hasValue())\n      return ChangeStatus::UNCHANGED;\n    if (!PrivatizableType.getValue())\n      return indicatePessimisticFixpoint();\n\n    // The dependence is optional so we don't give up once we give up on the\n    // alignment.\n    A.getAAFor<AAAlign>(*this, IRPosition::value(getAssociatedValue()),\n                        DepClassTy::OPTIONAL);\n\n    // Avoid arguments with padding for now.\n    if (!getIRPosition().hasAttr(Attribute::ByVal) &&\n        !ArgumentPromotionPass::isDenselyPacked(PrivatizableType.getValue(),\n                                                A.getInfoCache().getDL())) {\n      LLVM_DEBUG(dbgs() << \"[AAPrivatizablePtr] Padding detected\\n\");\n      return indicatePessimisticFixpoint();\n    }\n\n    // Verify callee and caller agree on how the promoted argument would be\n    // passed.\n    // TODO: The use of the ArgumentPromotion interface here is ugly, we need a\n    // specialized form of TargetTransformInfo::areFunctionArgsABICompatible\n    // which doesn't require the arguments ArgumentPromotion wanted to pass.\n    Function &Fn = *getIRPosition().getAnchorScope();\n    SmallPtrSet<Argument *, 1> ArgsToPromote, Dummy;\n    ArgsToPromote.insert(getAssociatedArgument());\n    const auto *TTI =\n        A.getInfoCache().getAnalysisResultForFunction<TargetIRAnalysis>(Fn);\n    if (!TTI ||\n        !ArgumentPromotionPass::areFunctionArgsABICompatible(\n            Fn, *TTI, ArgsToPromote, Dummy) ||\n        ArgsToPromote.empty()) {\n      LLVM_DEBUG(\n          dbgs() << \"[AAPrivatizablePtr] ABI incompatibility detected for \"\n                 << Fn.getName() << \"\\n\");\n      return indicatePessimisticFixpoint();\n    }\n\n    // Collect the types that will replace the privatizable type in the function\n    // signature.\n    SmallVector<Type *, 16> ReplacementTypes;\n    identifyReplacementTypes(PrivatizableType.getValue(), ReplacementTypes);\n\n    // Register a rewrite of the argument.\n    Argument *Arg = getAssociatedArgument();\n    if (!A.isValidFunctionSignatureRewrite(*Arg, ReplacementTypes)) {\n      LLVM_DEBUG(dbgs() << \"[AAPrivatizablePtr] Rewrite not valid\\n\");\n      return indicatePessimisticFixpoint();\n    }\n\n    unsigned ArgNo = Arg->getArgNo();\n\n    // Helper to check if for the given call site the associated argument is\n    // passed to a callback where the privatization would be different.\n    auto IsCompatiblePrivArgOfCallback = [&](CallBase &CB) {\n      SmallVector<const Use *, 4> CallbackUses;\n      AbstractCallSite::getCallbackUses(CB, CallbackUses);\n      for (const Use *U : CallbackUses) {\n        AbstractCallSite CBACS(U);\n        assert(CBACS && CBACS.isCallbackCall());\n        for (Argument &CBArg : CBACS.getCalledFunction()->args()) {\n          int CBArgNo = CBACS.getCallArgOperandNo(CBArg);\n\n          LLVM_DEBUG({\n            dbgs()\n                << \"[AAPrivatizablePtr] Argument \" << *Arg\n                << \"check if can be privatized in the context of its parent (\"\n                << Arg->getParent()->getName()\n                << \")\\n[AAPrivatizablePtr] because it is an argument in a \"\n                   \"callback (\"\n                << CBArgNo << \"@\" << CBACS.getCalledFunction()->getName()\n                << \")\\n[AAPrivatizablePtr] \" << CBArg << \" : \"\n                << CBACS.getCallArgOperand(CBArg) << \" vs \"\n                << CB.getArgOperand(ArgNo) << \"\\n\"\n                << \"[AAPrivatizablePtr] \" << CBArg << \" : \"\n                << CBACS.getCallArgOperandNo(CBArg) << \" vs \" << ArgNo << \"\\n\";\n          });\n\n          if (CBArgNo != int(ArgNo))\n            continue;\n          const auto &CBArgPrivAA = A.getAAFor<AAPrivatizablePtr>(\n              *this, IRPosition::argument(CBArg), DepClassTy::REQUIRED);\n          if (CBArgPrivAA.isValidState()) {\n            auto CBArgPrivTy = CBArgPrivAA.getPrivatizableType();\n            if (!CBArgPrivTy.hasValue())\n              continue;\n            if (CBArgPrivTy.getValue() == PrivatizableType)\n              continue;\n          }\n\n          LLVM_DEBUG({\n            dbgs() << \"[AAPrivatizablePtr] Argument \" << *Arg\n                   << \" cannot be privatized in the context of its parent (\"\n                   << Arg->getParent()->getName()\n                   << \")\\n[AAPrivatizablePtr] because it is an argument in a \"\n                      \"callback (\"\n                   << CBArgNo << \"@\" << CBACS.getCalledFunction()->getName()\n                   << \").\\n[AAPrivatizablePtr] for which the argument \"\n                      \"privatization is not compatible.\\n\";\n          });\n          return false;\n        }\n      }\n      return true;\n    };\n\n    // Helper to check if for the given call site the associated argument is\n    // passed to a direct call where the privatization would be different.\n    auto IsCompatiblePrivArgOfDirectCS = [&](AbstractCallSite ACS) {\n      CallBase *DC = cast<CallBase>(ACS.getInstruction());\n      int DCArgNo = ACS.getCallArgOperandNo(ArgNo);\n      assert(DCArgNo >= 0 && unsigned(DCArgNo) < DC->getNumArgOperands() &&\n             \"Expected a direct call operand for callback call operand\");\n\n      LLVM_DEBUG({\n        dbgs() << \"[AAPrivatizablePtr] Argument \" << *Arg\n               << \" check if be privatized in the context of its parent (\"\n               << Arg->getParent()->getName()\n               << \")\\n[AAPrivatizablePtr] because it is an argument in a \"\n                  \"direct call of (\"\n               << DCArgNo << \"@\" << DC->getCalledFunction()->getName()\n               << \").\\n\";\n      });\n\n      Function *DCCallee = DC->getCalledFunction();\n      if (unsigned(DCArgNo) < DCCallee->arg_size()) {\n        const auto &DCArgPrivAA = A.getAAFor<AAPrivatizablePtr>(\n            *this, IRPosition::argument(*DCCallee->getArg(DCArgNo)),\n            DepClassTy::REQUIRED);\n        if (DCArgPrivAA.isValidState()) {\n          auto DCArgPrivTy = DCArgPrivAA.getPrivatizableType();\n          if (!DCArgPrivTy.hasValue())\n            return true;\n          if (DCArgPrivTy.getValue() == PrivatizableType)\n            return true;\n        }\n      }\n\n      LLVM_DEBUG({\n        dbgs() << \"[AAPrivatizablePtr] Argument \" << *Arg\n               << \" cannot be privatized in the context of its parent (\"\n               << Arg->getParent()->getName()\n               << \")\\n[AAPrivatizablePtr] because it is an argument in a \"\n                  \"direct call of (\"\n               << ACS.getInstruction()->getCalledFunction()->getName()\n               << \").\\n[AAPrivatizablePtr] for which the argument \"\n                  \"privatization is not compatible.\\n\";\n      });\n      return false;\n    };\n\n    // Helper to check if the associated argument is used at the given abstract\n    // call site in a way that is incompatible with the privatization assumed\n    // here.\n    auto IsCompatiblePrivArgOfOtherCallSite = [&](AbstractCallSite ACS) {\n      if (ACS.isDirectCall())\n        return IsCompatiblePrivArgOfCallback(*ACS.getInstruction());\n      if (ACS.isCallbackCall())\n        return IsCompatiblePrivArgOfDirectCS(ACS);\n      return false;\n    };\n\n    bool AllCallSitesKnown;\n    if (!A.checkForAllCallSites(IsCompatiblePrivArgOfOtherCallSite, *this, true,\n                                AllCallSitesKnown))\n      return indicatePessimisticFixpoint();\n\n    return ChangeStatus::UNCHANGED;\n  }\n\n  /// Given a type to private \\p PrivType, collect the constituates (which are\n  /// used) in \\p ReplacementTypes.\n  static void\n  identifyReplacementTypes(Type *PrivType,\n                           SmallVectorImpl<Type *> &ReplacementTypes) {\n    // TODO: For now we expand the privatization type to the fullest which can\n    //       lead to dead arguments that need to be removed later.\n    assert(PrivType && \"Expected privatizable type!\");\n\n    // Traverse the type, extract constituate types on the outermost level.\n    if (auto *PrivStructType = dyn_cast<StructType>(PrivType)) {\n      for (unsigned u = 0, e = PrivStructType->getNumElements(); u < e; u++)\n        ReplacementTypes.push_back(PrivStructType->getElementType(u));\n    } else if (auto *PrivArrayType = dyn_cast<ArrayType>(PrivType)) {\n      ReplacementTypes.append(PrivArrayType->getNumElements(),\n                              PrivArrayType->getElementType());\n    } else {\n      ReplacementTypes.push_back(PrivType);\n    }\n  }\n\n  /// Initialize \\p Base according to the type \\p PrivType at position \\p IP.\n  /// The values needed are taken from the arguments of \\p F starting at\n  /// position \\p ArgNo.\n  static void createInitialization(Type *PrivType, Value &Base, Function &F,\n                                   unsigned ArgNo, Instruction &IP) {\n    assert(PrivType && \"Expected privatizable type!\");\n\n    IRBuilder<NoFolder> IRB(&IP);\n    const DataLayout &DL = F.getParent()->getDataLayout();\n\n    // Traverse the type, build GEPs and stores.\n    if (auto *PrivStructType = dyn_cast<StructType>(PrivType)) {\n      const StructLayout *PrivStructLayout = DL.getStructLayout(PrivStructType);\n      for (unsigned u = 0, e = PrivStructType->getNumElements(); u < e; u++) {\n        Type *PointeeTy = PrivStructType->getElementType(u)->getPointerTo();\n        Value *Ptr =\n            constructPointer(PointeeTy, PrivType, &Base,\n                             PrivStructLayout->getElementOffset(u), IRB, DL);\n        new StoreInst(F.getArg(ArgNo + u), Ptr, &IP);\n      }\n    } else if (auto *PrivArrayType = dyn_cast<ArrayType>(PrivType)) {\n      Type *PointeeTy = PrivArrayType->getElementType();\n      Type *PointeePtrTy = PointeeTy->getPointerTo();\n      uint64_t PointeeTySize = DL.getTypeStoreSize(PointeeTy);\n      for (unsigned u = 0, e = PrivArrayType->getNumElements(); u < e; u++) {\n        Value *Ptr = constructPointer(PointeePtrTy, PrivType, &Base,\n                                      u * PointeeTySize, IRB, DL);\n        new StoreInst(F.getArg(ArgNo + u), Ptr, &IP);\n      }\n    } else {\n      new StoreInst(F.getArg(ArgNo), &Base, &IP);\n    }\n  }\n\n  /// Extract values from \\p Base according to the type \\p PrivType at the\n  /// call position \\p ACS. The values are appended to \\p ReplacementValues.\n  void createReplacementValues(Align Alignment, Type *PrivType,\n                               AbstractCallSite ACS, Value *Base,\n                               SmallVectorImpl<Value *> &ReplacementValues) {\n    assert(Base && \"Expected base value!\");\n    assert(PrivType && \"Expected privatizable type!\");\n    Instruction *IP = ACS.getInstruction();\n\n    IRBuilder<NoFolder> IRB(IP);\n    const DataLayout &DL = IP->getModule()->getDataLayout();\n\n    if (Base->getType()->getPointerElementType() != PrivType)\n      Base = BitCastInst::CreateBitOrPointerCast(Base, PrivType->getPointerTo(),\n                                                 \"\", ACS.getInstruction());\n\n    // Traverse the type, build GEPs and loads.\n    if (auto *PrivStructType = dyn_cast<StructType>(PrivType)) {\n      const StructLayout *PrivStructLayout = DL.getStructLayout(PrivStructType);\n      for (unsigned u = 0, e = PrivStructType->getNumElements(); u < e; u++) {\n        Type *PointeeTy = PrivStructType->getElementType(u);\n        Value *Ptr =\n            constructPointer(PointeeTy->getPointerTo(), PrivType, Base,\n                             PrivStructLayout->getElementOffset(u), IRB, DL);\n        LoadInst *L = new LoadInst(PointeeTy, Ptr, \"\", IP);\n        L->setAlignment(Alignment);\n        ReplacementValues.push_back(L);\n      }\n    } else if (auto *PrivArrayType = dyn_cast<ArrayType>(PrivType)) {\n      Type *PointeeTy = PrivArrayType->getElementType();\n      uint64_t PointeeTySize = DL.getTypeStoreSize(PointeeTy);\n      Type *PointeePtrTy = PointeeTy->getPointerTo();\n      for (unsigned u = 0, e = PrivArrayType->getNumElements(); u < e; u++) {\n        Value *Ptr = constructPointer(PointeePtrTy, PrivType, Base,\n                                      u * PointeeTySize, IRB, DL);\n        LoadInst *L = new LoadInst(PointeeTy, Ptr, \"\", IP);\n        L->setAlignment(Alignment);\n        ReplacementValues.push_back(L);\n      }\n    } else {\n      LoadInst *L = new LoadInst(PrivType, Base, \"\", IP);\n      L->setAlignment(Alignment);\n      ReplacementValues.push_back(L);\n    }\n  }\n\n  /// See AbstractAttribute::manifest(...)\n  ChangeStatus manifest(Attributor &A) override {\n    if (!PrivatizableType.hasValue())\n      return ChangeStatus::UNCHANGED;\n    assert(PrivatizableType.getValue() && \"Expected privatizable type!\");\n\n    // Collect all tail calls in the function as we cannot allow new allocas to\n    // escape into tail recursion.\n    // TODO: Be smarter about new allocas escaping into tail calls.\n    SmallVector<CallInst *, 16> TailCalls;\n    if (!A.checkForAllInstructions(\n            [&](Instruction &I) {\n              CallInst &CI = cast<CallInst>(I);\n              if (CI.isTailCall())\n                TailCalls.push_back(&CI);\n              return true;\n            },\n            *this, {Instruction::Call}))\n      return ChangeStatus::UNCHANGED;\n\n    Argument *Arg = getAssociatedArgument();\n    // Query AAAlign attribute for alignment of associated argument to\n    // determine the best alignment of loads.\n    const auto &AlignAA =\n        A.getAAFor<AAAlign>(*this, IRPosition::value(*Arg), DepClassTy::NONE);\n\n    // Callback to repair the associated function. A new alloca is placed at the\n    // beginning and initialized with the values passed through arguments. The\n    // new alloca replaces the use of the old pointer argument.\n    Attributor::ArgumentReplacementInfo::CalleeRepairCBTy FnRepairCB =\n        [=](const Attributor::ArgumentReplacementInfo &ARI,\n            Function &ReplacementFn, Function::arg_iterator ArgIt) {\n          BasicBlock &EntryBB = ReplacementFn.getEntryBlock();\n          Instruction *IP = &*EntryBB.getFirstInsertionPt();\n          Instruction *AI = new AllocaInst(PrivatizableType.getValue(), 0,\n                                           Arg->getName() + \".priv\", IP);\n          createInitialization(PrivatizableType.getValue(), *AI, ReplacementFn,\n                               ArgIt->getArgNo(), *IP);\n\n          if (AI->getType() != Arg->getType())\n            AI =\n                BitCastInst::CreateBitOrPointerCast(AI, Arg->getType(), \"\", IP);\n          Arg->replaceAllUsesWith(AI);\n\n          for (CallInst *CI : TailCalls)\n            CI->setTailCall(false);\n        };\n\n    // Callback to repair a call site of the associated function. The elements\n    // of the privatizable type are loaded prior to the call and passed to the\n    // new function version.\n    Attributor::ArgumentReplacementInfo::ACSRepairCBTy ACSRepairCB =\n        [=, &AlignAA](const Attributor::ArgumentReplacementInfo &ARI,\n                      AbstractCallSite ACS,\n                      SmallVectorImpl<Value *> &NewArgOperands) {\n          // When no alignment is specified for the load instruction,\n          // natural alignment is assumed.\n          createReplacementValues(\n              assumeAligned(AlignAA.getAssumedAlign()),\n              PrivatizableType.getValue(), ACS,\n              ACS.getCallArgOperand(ARI.getReplacedArg().getArgNo()),\n              NewArgOperands);\n        };\n\n    // Collect the types that will replace the privatizable type in the function\n    // signature.\n    SmallVector<Type *, 16> ReplacementTypes;\n    identifyReplacementTypes(PrivatizableType.getValue(), ReplacementTypes);\n\n    // Register a rewrite of the argument.\n    if (A.registerFunctionSignatureRewrite(*Arg, ReplacementTypes,\n                                           std::move(FnRepairCB),\n                                           std::move(ACSRepairCB)))\n      return ChangeStatus::CHANGED;\n    return ChangeStatus::UNCHANGED;\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    STATS_DECLTRACK_ARG_ATTR(privatizable_ptr);\n  }\n};\n\nstruct AAPrivatizablePtrFloating : public AAPrivatizablePtrImpl {\n  AAPrivatizablePtrFloating(const IRPosition &IRP, Attributor &A)\n      : AAPrivatizablePtrImpl(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  virtual void initialize(Attributor &A) override {\n    // TODO: We can privatize more than arguments.\n    indicatePessimisticFixpoint();\n  }\n\n  ChangeStatus updateImpl(Attributor &A) override {\n    llvm_unreachable(\"AAPrivatizablePtr(Floating|Returned|CallSiteReturned)::\"\n                     \"updateImpl will not be called\");\n  }\n\n  /// See AAPrivatizablePtrImpl::identifyPrivatizableType(...)\n  Optional<Type *> identifyPrivatizableType(Attributor &A) override {\n    Value *Obj = getUnderlyingObject(&getAssociatedValue());\n    if (!Obj) {\n      LLVM_DEBUG(dbgs() << \"[AAPrivatizablePtr] No underlying object found!\\n\");\n      return nullptr;\n    }\n\n    if (auto *AI = dyn_cast<AllocaInst>(Obj))\n      if (auto *CI = dyn_cast<ConstantInt>(AI->getArraySize()))\n        if (CI->isOne())\n          return Obj->getType()->getPointerElementType();\n    if (auto *Arg = dyn_cast<Argument>(Obj)) {\n      auto &PrivArgAA = A.getAAFor<AAPrivatizablePtr>(\n          *this, IRPosition::argument(*Arg), DepClassTy::REQUIRED);\n      if (PrivArgAA.isAssumedPrivatizablePtr())\n        return Obj->getType()->getPointerElementType();\n    }\n\n    LLVM_DEBUG(dbgs() << \"[AAPrivatizablePtr] Underlying object neither valid \"\n                         \"alloca nor privatizable argument: \"\n                      << *Obj << \"!\\n\");\n    return nullptr;\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    STATS_DECLTRACK_FLOATING_ATTR(privatizable_ptr);\n  }\n};\n\nstruct AAPrivatizablePtrCallSiteArgument final\n    : public AAPrivatizablePtrFloating {\n  AAPrivatizablePtrCallSiteArgument(const IRPosition &IRP, Attributor &A)\n      : AAPrivatizablePtrFloating(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    if (getIRPosition().hasAttr(Attribute::ByVal))\n      indicateOptimisticFixpoint();\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    PrivatizableType = identifyPrivatizableType(A);\n    if (!PrivatizableType.hasValue())\n      return ChangeStatus::UNCHANGED;\n    if (!PrivatizableType.getValue())\n      return indicatePessimisticFixpoint();\n\n    const IRPosition &IRP = getIRPosition();\n    auto &NoCaptureAA =\n        A.getAAFor<AANoCapture>(*this, IRP, DepClassTy::REQUIRED);\n    if (!NoCaptureAA.isAssumedNoCapture()) {\n      LLVM_DEBUG(dbgs() << \"[AAPrivatizablePtr] pointer might be captured!\\n\");\n      return indicatePessimisticFixpoint();\n    }\n\n    auto &NoAliasAA = A.getAAFor<AANoAlias>(*this, IRP, DepClassTy::REQUIRED);\n    if (!NoAliasAA.isAssumedNoAlias()) {\n      LLVM_DEBUG(dbgs() << \"[AAPrivatizablePtr] pointer might alias!\\n\");\n      return indicatePessimisticFixpoint();\n    }\n\n    const auto &MemBehaviorAA =\n        A.getAAFor<AAMemoryBehavior>(*this, IRP, DepClassTy::REQUIRED);\n    if (!MemBehaviorAA.isAssumedReadOnly()) {\n      LLVM_DEBUG(dbgs() << \"[AAPrivatizablePtr] pointer is written!\\n\");\n      return indicatePessimisticFixpoint();\n    }\n\n    return ChangeStatus::UNCHANGED;\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    STATS_DECLTRACK_CSARG_ATTR(privatizable_ptr);\n  }\n};\n\nstruct AAPrivatizablePtrCallSiteReturned final\n    : public AAPrivatizablePtrFloating {\n  AAPrivatizablePtrCallSiteReturned(const IRPosition &IRP, Attributor &A)\n      : AAPrivatizablePtrFloating(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    // TODO: We can privatize more than arguments.\n    indicatePessimisticFixpoint();\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    STATS_DECLTRACK_CSRET_ATTR(privatizable_ptr);\n  }\n};\n\nstruct AAPrivatizablePtrReturned final : public AAPrivatizablePtrFloating {\n  AAPrivatizablePtrReturned(const IRPosition &IRP, Attributor &A)\n      : AAPrivatizablePtrFloating(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    // TODO: We can privatize more than arguments.\n    indicatePessimisticFixpoint();\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    STATS_DECLTRACK_FNRET_ATTR(privatizable_ptr);\n  }\n};\n\n/// -------------------- Memory Behavior Attributes ----------------------------\n/// Includes read-none, read-only, and write-only.\n/// ----------------------------------------------------------------------------\nstruct AAMemoryBehaviorImpl : public AAMemoryBehavior {\n  AAMemoryBehaviorImpl(const IRPosition &IRP, Attributor &A)\n      : AAMemoryBehavior(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    intersectAssumedBits(BEST_STATE);\n    getKnownStateFromValue(getIRPosition(), getState());\n    AAMemoryBehavior::initialize(A);\n  }\n\n  /// Return the memory behavior information encoded in the IR for \\p IRP.\n  static void getKnownStateFromValue(const IRPosition &IRP,\n                                     BitIntegerState &State,\n                                     bool IgnoreSubsumingPositions = false) {\n    SmallVector<Attribute, 2> Attrs;\n    IRP.getAttrs(AttrKinds, Attrs, IgnoreSubsumingPositions);\n    for (const Attribute &Attr : Attrs) {\n      switch (Attr.getKindAsEnum()) {\n      case Attribute::ReadNone:\n        State.addKnownBits(NO_ACCESSES);\n        break;\n      case Attribute::ReadOnly:\n        State.addKnownBits(NO_WRITES);\n        break;\n      case Attribute::WriteOnly:\n        State.addKnownBits(NO_READS);\n        break;\n      default:\n        llvm_unreachable(\"Unexpected attribute!\");\n      }\n    }\n\n    if (auto *I = dyn_cast<Instruction>(&IRP.getAnchorValue())) {\n      if (!I->mayReadFromMemory())\n        State.addKnownBits(NO_READS);\n      if (!I->mayWriteToMemory())\n        State.addKnownBits(NO_WRITES);\n    }\n  }\n\n  /// See AbstractAttribute::getDeducedAttributes(...).\n  void getDeducedAttributes(LLVMContext &Ctx,\n                            SmallVectorImpl<Attribute> &Attrs) const override {\n    assert(Attrs.size() == 0);\n    if (isAssumedReadNone())\n      Attrs.push_back(Attribute::get(Ctx, Attribute::ReadNone));\n    else if (isAssumedReadOnly())\n      Attrs.push_back(Attribute::get(Ctx, Attribute::ReadOnly));\n    else if (isAssumedWriteOnly())\n      Attrs.push_back(Attribute::get(Ctx, Attribute::WriteOnly));\n    assert(Attrs.size() <= 1);\n  }\n\n  /// See AbstractAttribute::manifest(...).\n  ChangeStatus manifest(Attributor &A) override {\n    if (hasAttr(Attribute::ReadNone, /* IgnoreSubsumingPositions */ true))\n      return ChangeStatus::UNCHANGED;\n\n    const IRPosition &IRP = getIRPosition();\n\n    // Check if we would improve the existing attributes first.\n    SmallVector<Attribute, 4> DeducedAttrs;\n    getDeducedAttributes(IRP.getAnchorValue().getContext(), DeducedAttrs);\n    if (llvm::all_of(DeducedAttrs, [&](const Attribute &Attr) {\n          return IRP.hasAttr(Attr.getKindAsEnum(),\n                             /* IgnoreSubsumingPositions */ true);\n        }))\n      return ChangeStatus::UNCHANGED;\n\n    // Clear existing attributes.\n    IRP.removeAttrs(AttrKinds);\n\n    // Use the generic manifest method.\n    return IRAttribute::manifest(A);\n  }\n\n  /// See AbstractState::getAsStr().\n  const std::string getAsStr() const override {\n    if (isAssumedReadNone())\n      return \"readnone\";\n    if (isAssumedReadOnly())\n      return \"readonly\";\n    if (isAssumedWriteOnly())\n      return \"writeonly\";\n    return \"may-read/write\";\n  }\n\n  /// The set of IR attributes AAMemoryBehavior deals with.\n  static const Attribute::AttrKind AttrKinds[3];\n};\n\nconst Attribute::AttrKind AAMemoryBehaviorImpl::AttrKinds[] = {\n    Attribute::ReadNone, Attribute::ReadOnly, Attribute::WriteOnly};\n\n/// Memory behavior attribute for a floating value.\nstruct AAMemoryBehaviorFloating : AAMemoryBehaviorImpl {\n  AAMemoryBehaviorFloating(const IRPosition &IRP, Attributor &A)\n      : AAMemoryBehaviorImpl(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    AAMemoryBehaviorImpl::initialize(A);\n    addUsesOf(A, getAssociatedValue());\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override;\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    if (isAssumedReadNone())\n      STATS_DECLTRACK_FLOATING_ATTR(readnone)\n    else if (isAssumedReadOnly())\n      STATS_DECLTRACK_FLOATING_ATTR(readonly)\n    else if (isAssumedWriteOnly())\n      STATS_DECLTRACK_FLOATING_ATTR(writeonly)\n  }\n\nprivate:\n  /// Return true if users of \\p UserI might access the underlying\n  /// variable/location described by \\p U and should therefore be analyzed.\n  bool followUsersOfUseIn(Attributor &A, const Use *U,\n                          const Instruction *UserI);\n\n  /// Update the state according to the effect of use \\p U in \\p UserI.\n  void analyzeUseIn(Attributor &A, const Use *U, const Instruction *UserI);\n\nprotected:\n  /// Add the uses of \\p V to the `Uses` set we look at during the update step.\n  void addUsesOf(Attributor &A, const Value &V);\n\n  /// Container for (transitive) uses of the associated argument.\n  SmallVector<const Use *, 8> Uses;\n\n  /// Set to remember the uses we already traversed.\n  SmallPtrSet<const Use *, 8> Visited;\n};\n\n/// Memory behavior attribute for function argument.\nstruct AAMemoryBehaviorArgument : AAMemoryBehaviorFloating {\n  AAMemoryBehaviorArgument(const IRPosition &IRP, Attributor &A)\n      : AAMemoryBehaviorFloating(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    intersectAssumedBits(BEST_STATE);\n    const IRPosition &IRP = getIRPosition();\n    // TODO: Make IgnoreSubsumingPositions a property of an IRAttribute so we\n    // can query it when we use has/getAttr. That would allow us to reuse the\n    // initialize of the base class here.\n    bool HasByVal =\n        IRP.hasAttr({Attribute::ByVal}, /* IgnoreSubsumingPositions */ true);\n    getKnownStateFromValue(IRP, getState(),\n                           /* IgnoreSubsumingPositions */ HasByVal);\n\n    // Initialize the use vector with all direct uses of the associated value.\n    Argument *Arg = getAssociatedArgument();\n    if (!Arg || !A.isFunctionIPOAmendable(*(Arg->getParent()))) {\n      indicatePessimisticFixpoint();\n    } else {\n      addUsesOf(A, *Arg);\n    }\n  }\n\n  ChangeStatus manifest(Attributor &A) override {\n    // TODO: Pointer arguments are not supported on vectors of pointers yet.\n    if (!getAssociatedValue().getType()->isPointerTy())\n      return ChangeStatus::UNCHANGED;\n\n    // TODO: From readattrs.ll: \"inalloca parameters are always\n    //                           considered written\"\n    if (hasAttr({Attribute::InAlloca, Attribute::Preallocated})) {\n      removeKnownBits(NO_WRITES);\n      removeAssumedBits(NO_WRITES);\n    }\n    return AAMemoryBehaviorFloating::manifest(A);\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    if (isAssumedReadNone())\n      STATS_DECLTRACK_ARG_ATTR(readnone)\n    else if (isAssumedReadOnly())\n      STATS_DECLTRACK_ARG_ATTR(readonly)\n    else if (isAssumedWriteOnly())\n      STATS_DECLTRACK_ARG_ATTR(writeonly)\n  }\n};\n\nstruct AAMemoryBehaviorCallSiteArgument final : AAMemoryBehaviorArgument {\n  AAMemoryBehaviorCallSiteArgument(const IRPosition &IRP, Attributor &A)\n      : AAMemoryBehaviorArgument(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    // If we don't have an associated attribute this is either a variadic call\n    // or an indirect call, either way, nothing to do here.\n    Argument *Arg = getAssociatedArgument();\n    if (!Arg) {\n      indicatePessimisticFixpoint();\n      return;\n    }\n    if (Arg->hasByValAttr()) {\n      addKnownBits(NO_WRITES);\n      removeKnownBits(NO_READS);\n      removeAssumedBits(NO_READS);\n    }\n    AAMemoryBehaviorArgument::initialize(A);\n    if (getAssociatedFunction()->isDeclaration())\n      indicatePessimisticFixpoint();\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    // TODO: Once we have call site specific value information we can provide\n    //       call site specific liveness liveness information and then it makes\n    //       sense to specialize attributes for call sites arguments instead of\n    //       redirecting requests to the callee argument.\n    Argument *Arg = getAssociatedArgument();\n    const IRPosition &ArgPos = IRPosition::argument(*Arg);\n    auto &ArgAA =\n        A.getAAFor<AAMemoryBehavior>(*this, ArgPos, DepClassTy::REQUIRED);\n    return clampStateAndIndicateChange(getState(), ArgAA.getState());\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    if (isAssumedReadNone())\n      STATS_DECLTRACK_CSARG_ATTR(readnone)\n    else if (isAssumedReadOnly())\n      STATS_DECLTRACK_CSARG_ATTR(readonly)\n    else if (isAssumedWriteOnly())\n      STATS_DECLTRACK_CSARG_ATTR(writeonly)\n  }\n};\n\n/// Memory behavior attribute for a call site return position.\nstruct AAMemoryBehaviorCallSiteReturned final : AAMemoryBehaviorFloating {\n  AAMemoryBehaviorCallSiteReturned(const IRPosition &IRP, Attributor &A)\n      : AAMemoryBehaviorFloating(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    AAMemoryBehaviorImpl::initialize(A);\n    Function *F = getAssociatedFunction();\n    if (!F || F->isDeclaration())\n      indicatePessimisticFixpoint();\n  }\n\n  /// See AbstractAttribute::manifest(...).\n  ChangeStatus manifest(Attributor &A) override {\n    // We do not annotate returned values.\n    return ChangeStatus::UNCHANGED;\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {}\n};\n\n/// An AA to represent the memory behavior function attributes.\nstruct AAMemoryBehaviorFunction final : public AAMemoryBehaviorImpl {\n  AAMemoryBehaviorFunction(const IRPosition &IRP, Attributor &A)\n      : AAMemoryBehaviorImpl(IRP, A) {}\n\n  /// See AbstractAttribute::updateImpl(Attributor &A).\n  virtual ChangeStatus updateImpl(Attributor &A) override;\n\n  /// See AbstractAttribute::manifest(...).\n  ChangeStatus manifest(Attributor &A) override {\n    Function &F = cast<Function>(getAnchorValue());\n    if (isAssumedReadNone()) {\n      F.removeFnAttr(Attribute::ArgMemOnly);\n      F.removeFnAttr(Attribute::InaccessibleMemOnly);\n      F.removeFnAttr(Attribute::InaccessibleMemOrArgMemOnly);\n    }\n    return AAMemoryBehaviorImpl::manifest(A);\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    if (isAssumedReadNone())\n      STATS_DECLTRACK_FN_ATTR(readnone)\n    else if (isAssumedReadOnly())\n      STATS_DECLTRACK_FN_ATTR(readonly)\n    else if (isAssumedWriteOnly())\n      STATS_DECLTRACK_FN_ATTR(writeonly)\n  }\n};\n\n/// AAMemoryBehavior attribute for call sites.\nstruct AAMemoryBehaviorCallSite final : AAMemoryBehaviorImpl {\n  AAMemoryBehaviorCallSite(const IRPosition &IRP, Attributor &A)\n      : AAMemoryBehaviorImpl(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    AAMemoryBehaviorImpl::initialize(A);\n    Function *F = getAssociatedFunction();\n    if (!F || F->isDeclaration())\n      indicatePessimisticFixpoint();\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    // TODO: Once we have call site specific value information we can provide\n    //       call site specific liveness liveness information and then it makes\n    //       sense to specialize attributes for call sites arguments instead of\n    //       redirecting requests to the callee argument.\n    Function *F = getAssociatedFunction();\n    const IRPosition &FnPos = IRPosition::function(*F);\n    auto &FnAA =\n        A.getAAFor<AAMemoryBehavior>(*this, FnPos, DepClassTy::REQUIRED);\n    return clampStateAndIndicateChange(getState(), FnAA.getState());\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    if (isAssumedReadNone())\n      STATS_DECLTRACK_CS_ATTR(readnone)\n    else if (isAssumedReadOnly())\n      STATS_DECLTRACK_CS_ATTR(readonly)\n    else if (isAssumedWriteOnly())\n      STATS_DECLTRACK_CS_ATTR(writeonly)\n  }\n};\n\nChangeStatus AAMemoryBehaviorFunction::updateImpl(Attributor &A) {\n\n  // The current assumed state used to determine a change.\n  auto AssumedState = getAssumed();\n\n  auto CheckRWInst = [&](Instruction &I) {\n    // If the instruction has an own memory behavior state, use it to restrict\n    // the local state. No further analysis is required as the other memory\n    // state is as optimistic as it gets.\n    if (const auto *CB = dyn_cast<CallBase>(&I)) {\n      const auto &MemBehaviorAA = A.getAAFor<AAMemoryBehavior>(\n          *this, IRPosition::callsite_function(*CB), DepClassTy::REQUIRED);\n      intersectAssumedBits(MemBehaviorAA.getAssumed());\n      return !isAtFixpoint();\n    }\n\n    // Remove access kind modifiers if necessary.\n    if (I.mayReadFromMemory())\n      removeAssumedBits(NO_READS);\n    if (I.mayWriteToMemory())\n      removeAssumedBits(NO_WRITES);\n    return !isAtFixpoint();\n  };\n\n  if (!A.checkForAllReadWriteInstructions(CheckRWInst, *this))\n    return indicatePessimisticFixpoint();\n\n  return (AssumedState != getAssumed()) ? ChangeStatus::CHANGED\n                                        : ChangeStatus::UNCHANGED;\n}\n\nChangeStatus AAMemoryBehaviorFloating::updateImpl(Attributor &A) {\n\n  const IRPosition &IRP = getIRPosition();\n  const IRPosition &FnPos = IRPosition::function_scope(IRP);\n  AAMemoryBehavior::StateType &S = getState();\n\n  // First, check the function scope. We take the known information and we avoid\n  // work if the assumed information implies the current assumed information for\n  // this attribute. This is a valid for all but byval arguments.\n  Argument *Arg = IRP.getAssociatedArgument();\n  AAMemoryBehavior::base_t FnMemAssumedState =\n      AAMemoryBehavior::StateType::getWorstState();\n  if (!Arg || !Arg->hasByValAttr()) {\n    const auto &FnMemAA =\n        A.getAAFor<AAMemoryBehavior>(*this, FnPos, DepClassTy::OPTIONAL);\n    FnMemAssumedState = FnMemAA.getAssumed();\n    S.addKnownBits(FnMemAA.getKnown());\n    if ((S.getAssumed() & FnMemAA.getAssumed()) == S.getAssumed())\n      return ChangeStatus::UNCHANGED;\n  }\n\n  // Make sure the value is not captured (except through \"return\"), if\n  // it is, any information derived would be irrelevant anyway as we cannot\n  // check the potential aliases introduced by the capture. However, no need\n  // to fall back to anythign less optimistic than the function state.\n  const auto &ArgNoCaptureAA =\n      A.getAAFor<AANoCapture>(*this, IRP, DepClassTy::OPTIONAL);\n  if (!ArgNoCaptureAA.isAssumedNoCaptureMaybeReturned()) {\n    S.intersectAssumedBits(FnMemAssumedState);\n    return ChangeStatus::CHANGED;\n  }\n\n  // The current assumed state used to determine a change.\n  auto AssumedState = S.getAssumed();\n\n  // Liveness information to exclude dead users.\n  // TODO: Take the FnPos once we have call site specific liveness information.\n  const auto &LivenessAA = A.getAAFor<AAIsDead>(\n      *this, IRPosition::function(*IRP.getAssociatedFunction()),\n      DepClassTy::NONE);\n\n  // Visit and expand uses until all are analyzed or a fixpoint is reached.\n  for (unsigned i = 0; i < Uses.size() && !isAtFixpoint(); i++) {\n    const Use *U = Uses[i];\n    Instruction *UserI = cast<Instruction>(U->getUser());\n    LLVM_DEBUG(dbgs() << \"[AAMemoryBehavior] Use: \" << **U << \" in \" << *UserI\n                      << \" [Dead: \" << (A.isAssumedDead(*U, this, &LivenessAA))\n                      << \"]\\n\");\n    if (A.isAssumedDead(*U, this, &LivenessAA))\n      continue;\n\n    // Droppable users, e.g., llvm::assume does not actually perform any action.\n    if (UserI->isDroppable())\n      continue;\n\n    // Check if the users of UserI should also be visited.\n    if (followUsersOfUseIn(A, U, UserI))\n      addUsesOf(A, *UserI);\n\n    // If UserI might touch memory we analyze the use in detail.\n    if (UserI->mayReadOrWriteMemory())\n      analyzeUseIn(A, U, UserI);\n  }\n\n  return (AssumedState != getAssumed()) ? ChangeStatus::CHANGED\n                                        : ChangeStatus::UNCHANGED;\n}\n\nvoid AAMemoryBehaviorFloating::addUsesOf(Attributor &A, const Value &V) {\n  SmallVector<const Use *, 8> WL;\n  for (const Use &U : V.uses())\n    WL.push_back(&U);\n\n  while (!WL.empty()) {\n    const Use *U = WL.pop_back_val();\n    if (!Visited.insert(U).second)\n      continue;\n\n    const Instruction *UserI = cast<Instruction>(U->getUser());\n    if (UserI->mayReadOrWriteMemory()) {\n      Uses.push_back(U);\n      continue;\n    }\n    if (!followUsersOfUseIn(A, U, UserI))\n      continue;\n    for (const Use &UU : UserI->uses())\n      WL.push_back(&UU);\n  }\n}\n\nbool AAMemoryBehaviorFloating::followUsersOfUseIn(Attributor &A, const Use *U,\n                                                  const Instruction *UserI) {\n  // The loaded value is unrelated to the pointer argument, no need to\n  // follow the users of the load.\n  if (isa<LoadInst>(UserI))\n    return false;\n\n  // By default we follow all uses assuming UserI might leak information on U,\n  // we have special handling for call sites operands though.\n  const auto *CB = dyn_cast<CallBase>(UserI);\n  if (!CB || !CB->isArgOperand(U))\n    return true;\n\n  // If the use is a call argument known not to be captured, the users of\n  // the call do not need to be visited because they have to be unrelated to\n  // the input. Note that this check is not trivial even though we disallow\n  // general capturing of the underlying argument. The reason is that the\n  // call might the argument \"through return\", which we allow and for which we\n  // need to check call users.\n  if (U->get()->getType()->isPointerTy()) {\n    unsigned ArgNo = CB->getArgOperandNo(U);\n    const auto &ArgNoCaptureAA = A.getAAFor<AANoCapture>(\n        *this, IRPosition::callsite_argument(*CB, ArgNo), DepClassTy::OPTIONAL);\n    return !ArgNoCaptureAA.isAssumedNoCapture();\n  }\n\n  return true;\n}\n\nvoid AAMemoryBehaviorFloating::analyzeUseIn(Attributor &A, const Use *U,\n                                            const Instruction *UserI) {\n  assert(UserI->mayReadOrWriteMemory());\n\n  switch (UserI->getOpcode()) {\n  default:\n    // TODO: Handle all atomics and other side-effect operations we know of.\n    break;\n  case Instruction::Load:\n    // Loads cause the NO_READS property to disappear.\n    removeAssumedBits(NO_READS);\n    return;\n\n  case Instruction::Store:\n    // Stores cause the NO_WRITES property to disappear if the use is the\n    // pointer operand. Note that we do assume that capturing was taken care of\n    // somewhere else.\n    if (cast<StoreInst>(UserI)->getPointerOperand() == U->get())\n      removeAssumedBits(NO_WRITES);\n    return;\n\n  case Instruction::Call:\n  case Instruction::CallBr:\n  case Instruction::Invoke: {\n    // For call sites we look at the argument memory behavior attribute (this\n    // could be recursive!) in order to restrict our own state.\n    const auto *CB = cast<CallBase>(UserI);\n\n    // Give up on operand bundles.\n    if (CB->isBundleOperand(U)) {\n      indicatePessimisticFixpoint();\n      return;\n    }\n\n    // Calling a function does read the function pointer, maybe write it if the\n    // function is self-modifying.\n    if (CB->isCallee(U)) {\n      removeAssumedBits(NO_READS);\n      break;\n    }\n\n    // Adjust the possible access behavior based on the information on the\n    // argument.\n    IRPosition Pos;\n    if (U->get()->getType()->isPointerTy())\n      Pos = IRPosition::callsite_argument(*CB, CB->getArgOperandNo(U));\n    else\n      Pos = IRPosition::callsite_function(*CB);\n    const auto &MemBehaviorAA =\n        A.getAAFor<AAMemoryBehavior>(*this, Pos, DepClassTy::OPTIONAL);\n    // \"assumed\" has at most the same bits as the MemBehaviorAA assumed\n    // and at least \"known\".\n    intersectAssumedBits(MemBehaviorAA.getAssumed());\n    return;\n  }\n  };\n\n  // Generally, look at the \"may-properties\" and adjust the assumed state if we\n  // did not trigger special handling before.\n  if (UserI->mayReadFromMemory())\n    removeAssumedBits(NO_READS);\n  if (UserI->mayWriteToMemory())\n    removeAssumedBits(NO_WRITES);\n}\n\n} // namespace\n\n/// -------------------- Memory Locations Attributes ---------------------------\n/// Includes read-none, argmemonly, inaccessiblememonly,\n/// inaccessiblememorargmemonly\n/// ----------------------------------------------------------------------------\n\nstd::string AAMemoryLocation::getMemoryLocationsAsStr(\n    AAMemoryLocation::MemoryLocationsKind MLK) {\n  if (0 == (MLK & AAMemoryLocation::NO_LOCATIONS))\n    return \"all memory\";\n  if (MLK == AAMemoryLocation::NO_LOCATIONS)\n    return \"no memory\";\n  std::string S = \"memory:\";\n  if (0 == (MLK & AAMemoryLocation::NO_LOCAL_MEM))\n    S += \"stack,\";\n  if (0 == (MLK & AAMemoryLocation::NO_CONST_MEM))\n    S += \"constant,\";\n  if (0 == (MLK & AAMemoryLocation::NO_GLOBAL_INTERNAL_MEM))\n    S += \"internal global,\";\n  if (0 == (MLK & AAMemoryLocation::NO_GLOBAL_EXTERNAL_MEM))\n    S += \"external global,\";\n  if (0 == (MLK & AAMemoryLocation::NO_ARGUMENT_MEM))\n    S += \"argument,\";\n  if (0 == (MLK & AAMemoryLocation::NO_INACCESSIBLE_MEM))\n    S += \"inaccessible,\";\n  if (0 == (MLK & AAMemoryLocation::NO_MALLOCED_MEM))\n    S += \"malloced,\";\n  if (0 == (MLK & AAMemoryLocation::NO_UNKOWN_MEM))\n    S += \"unknown,\";\n  S.pop_back();\n  return S;\n}\n\nnamespace {\nstruct AAMemoryLocationImpl : public AAMemoryLocation {\n\n  AAMemoryLocationImpl(const IRPosition &IRP, Attributor &A)\n      : AAMemoryLocation(IRP, A), Allocator(A.Allocator) {\n    for (unsigned u = 0; u < llvm::CTLog2<VALID_STATE>(); ++u)\n      AccessKind2Accesses[u] = nullptr;\n  }\n\n  ~AAMemoryLocationImpl() {\n    // The AccessSets are allocated via a BumpPtrAllocator, we call\n    // the destructor manually.\n    for (unsigned u = 0; u < llvm::CTLog2<VALID_STATE>(); ++u)\n      if (AccessKind2Accesses[u])\n        AccessKind2Accesses[u]->~AccessSet();\n  }\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    intersectAssumedBits(BEST_STATE);\n    getKnownStateFromValue(A, getIRPosition(), getState());\n    AAMemoryLocation::initialize(A);\n  }\n\n  /// Return the memory behavior information encoded in the IR for \\p IRP.\n  static void getKnownStateFromValue(Attributor &A, const IRPosition &IRP,\n                                     BitIntegerState &State,\n                                     bool IgnoreSubsumingPositions = false) {\n    // For internal functions we ignore `argmemonly` and\n    // `inaccessiblememorargmemonly` as we might break it via interprocedural\n    // constant propagation. It is unclear if this is the best way but it is\n    // unlikely this will cause real performance problems. If we are deriving\n    // attributes for the anchor function we even remove the attribute in\n    // addition to ignoring it.\n    bool UseArgMemOnly = true;\n    Function *AnchorFn = IRP.getAnchorScope();\n    if (AnchorFn && A.isRunOn(*AnchorFn))\n      UseArgMemOnly = !AnchorFn->hasLocalLinkage();\n\n    SmallVector<Attribute, 2> Attrs;\n    IRP.getAttrs(AttrKinds, Attrs, IgnoreSubsumingPositions);\n    for (const Attribute &Attr : Attrs) {\n      switch (Attr.getKindAsEnum()) {\n      case Attribute::ReadNone:\n        State.addKnownBits(NO_LOCAL_MEM | NO_CONST_MEM);\n        break;\n      case Attribute::InaccessibleMemOnly:\n        State.addKnownBits(inverseLocation(NO_INACCESSIBLE_MEM, true, true));\n        break;\n      case Attribute::ArgMemOnly:\n        if (UseArgMemOnly)\n          State.addKnownBits(inverseLocation(NO_ARGUMENT_MEM, true, true));\n        else\n          IRP.removeAttrs({Attribute::ArgMemOnly});\n        break;\n      case Attribute::InaccessibleMemOrArgMemOnly:\n        if (UseArgMemOnly)\n          State.addKnownBits(inverseLocation(\n              NO_INACCESSIBLE_MEM | NO_ARGUMENT_MEM, true, true));\n        else\n          IRP.removeAttrs({Attribute::InaccessibleMemOrArgMemOnly});\n        break;\n      default:\n        llvm_unreachable(\"Unexpected attribute!\");\n      }\n    }\n  }\n\n  /// See AbstractAttribute::getDeducedAttributes(...).\n  void getDeducedAttributes(LLVMContext &Ctx,\n                            SmallVectorImpl<Attribute> &Attrs) const override {\n    assert(Attrs.size() == 0);\n    if (isAssumedReadNone()) {\n      Attrs.push_back(Attribute::get(Ctx, Attribute::ReadNone));\n    } else if (getIRPosition().getPositionKind() == IRPosition::IRP_FUNCTION) {\n      if (isAssumedInaccessibleMemOnly())\n        Attrs.push_back(Attribute::get(Ctx, Attribute::InaccessibleMemOnly));\n      else if (isAssumedArgMemOnly())\n        Attrs.push_back(Attribute::get(Ctx, Attribute::ArgMemOnly));\n      else if (isAssumedInaccessibleOrArgMemOnly())\n        Attrs.push_back(\n            Attribute::get(Ctx, Attribute::InaccessibleMemOrArgMemOnly));\n    }\n    assert(Attrs.size() <= 1);\n  }\n\n  /// See AbstractAttribute::manifest(...).\n  ChangeStatus manifest(Attributor &A) override {\n    const IRPosition &IRP = getIRPosition();\n\n    // Check if we would improve the existing attributes first.\n    SmallVector<Attribute, 4> DeducedAttrs;\n    getDeducedAttributes(IRP.getAnchorValue().getContext(), DeducedAttrs);\n    if (llvm::all_of(DeducedAttrs, [&](const Attribute &Attr) {\n          return IRP.hasAttr(Attr.getKindAsEnum(),\n                             /* IgnoreSubsumingPositions */ true);\n        }))\n      return ChangeStatus::UNCHANGED;\n\n    // Clear existing attributes.\n    IRP.removeAttrs(AttrKinds);\n    if (isAssumedReadNone())\n      IRP.removeAttrs(AAMemoryBehaviorImpl::AttrKinds);\n\n    // Use the generic manifest method.\n    return IRAttribute::manifest(A);\n  }\n\n  /// See AAMemoryLocation::checkForAllAccessesToMemoryKind(...).\n  bool checkForAllAccessesToMemoryKind(\n      function_ref<bool(const Instruction *, const Value *, AccessKind,\n                        MemoryLocationsKind)>\n          Pred,\n      MemoryLocationsKind RequestedMLK) const override {\n    if (!isValidState())\n      return false;\n\n    MemoryLocationsKind AssumedMLK = getAssumedNotAccessedLocation();\n    if (AssumedMLK == NO_LOCATIONS)\n      return true;\n\n    unsigned Idx = 0;\n    for (MemoryLocationsKind CurMLK = 1; CurMLK < NO_LOCATIONS;\n         CurMLK *= 2, ++Idx) {\n      if (CurMLK & RequestedMLK)\n        continue;\n\n      if (const AccessSet *Accesses = AccessKind2Accesses[Idx])\n        for (const AccessInfo &AI : *Accesses)\n          if (!Pred(AI.I, AI.Ptr, AI.Kind, CurMLK))\n            return false;\n    }\n\n    return true;\n  }\n\n  ChangeStatus indicatePessimisticFixpoint() override {\n    // If we give up and indicate a pessimistic fixpoint this instruction will\n    // become an access for all potential access kinds:\n    // TODO: Add pointers for argmemonly and globals to improve the results of\n    //       checkForAllAccessesToMemoryKind.\n    bool Changed = false;\n    MemoryLocationsKind KnownMLK = getKnown();\n    Instruction *I = dyn_cast<Instruction>(&getAssociatedValue());\n    for (MemoryLocationsKind CurMLK = 1; CurMLK < NO_LOCATIONS; CurMLK *= 2)\n      if (!(CurMLK & KnownMLK))\n        updateStateAndAccessesMap(getState(), CurMLK, I, nullptr, Changed,\n                                  getAccessKindFromInst(I));\n    return AAMemoryLocation::indicatePessimisticFixpoint();\n  }\n\nprotected:\n  /// Helper struct to tie together an instruction that has a read or write\n  /// effect with the pointer it accesses (if any).\n  struct AccessInfo {\n\n    /// The instruction that caused the access.\n    const Instruction *I;\n\n    /// The base pointer that is accessed, or null if unknown.\n    const Value *Ptr;\n\n    /// The kind of access (read/write/read+write).\n    AccessKind Kind;\n\n    bool operator==(const AccessInfo &RHS) const {\n      return I == RHS.I && Ptr == RHS.Ptr && Kind == RHS.Kind;\n    }\n    bool operator()(const AccessInfo &LHS, const AccessInfo &RHS) const {\n      if (LHS.I != RHS.I)\n        return LHS.I < RHS.I;\n      if (LHS.Ptr != RHS.Ptr)\n        return LHS.Ptr < RHS.Ptr;\n      if (LHS.Kind != RHS.Kind)\n        return LHS.Kind < RHS.Kind;\n      return false;\n    }\n  };\n\n  /// Mapping from *single* memory location kinds, e.g., LOCAL_MEM with the\n  /// value of NO_LOCAL_MEM, to the accesses encountered for this memory kind.\n  using AccessSet = SmallSet<AccessInfo, 2, AccessInfo>;\n  AccessSet *AccessKind2Accesses[llvm::CTLog2<VALID_STATE>()];\n\n  /// Categorize the pointer arguments of CB that might access memory in\n  /// AccessedLoc and update the state and access map accordingly.\n  void\n  categorizeArgumentPointerLocations(Attributor &A, CallBase &CB,\n                                     AAMemoryLocation::StateType &AccessedLocs,\n                                     bool &Changed);\n\n  /// Return the kind(s) of location that may be accessed by \\p V.\n  AAMemoryLocation::MemoryLocationsKind\n  categorizeAccessedLocations(Attributor &A, Instruction &I, bool &Changed);\n\n  /// Return the access kind as determined by \\p I.\n  AccessKind getAccessKindFromInst(const Instruction *I) {\n    AccessKind AK = READ_WRITE;\n    if (I) {\n      AK = I->mayReadFromMemory() ? READ : NONE;\n      AK = AccessKind(AK | (I->mayWriteToMemory() ? WRITE : NONE));\n    }\n    return AK;\n  }\n\n  /// Update the state \\p State and the AccessKind2Accesses given that \\p I is\n  /// an access of kind \\p AK to a \\p MLK memory location with the access\n  /// pointer \\p Ptr.\n  void updateStateAndAccessesMap(AAMemoryLocation::StateType &State,\n                                 MemoryLocationsKind MLK, const Instruction *I,\n                                 const Value *Ptr, bool &Changed,\n                                 AccessKind AK = READ_WRITE) {\n\n    assert(isPowerOf2_32(MLK) && \"Expected a single location set!\");\n    auto *&Accesses = AccessKind2Accesses[llvm::Log2_32(MLK)];\n    if (!Accesses)\n      Accesses = new (Allocator) AccessSet();\n    Changed |= Accesses->insert(AccessInfo{I, Ptr, AK}).second;\n    State.removeAssumedBits(MLK);\n  }\n\n  /// Determine the underlying locations kinds for \\p Ptr, e.g., globals or\n  /// arguments, and update the state and access map accordingly.\n  void categorizePtrValue(Attributor &A, const Instruction &I, const Value &Ptr,\n                          AAMemoryLocation::StateType &State, bool &Changed);\n\n  /// Used to allocate access sets.\n  BumpPtrAllocator &Allocator;\n\n  /// The set of IR attributes AAMemoryLocation deals with.\n  static const Attribute::AttrKind AttrKinds[4];\n};\n\nconst Attribute::AttrKind AAMemoryLocationImpl::AttrKinds[] = {\n    Attribute::ReadNone, Attribute::InaccessibleMemOnly, Attribute::ArgMemOnly,\n    Attribute::InaccessibleMemOrArgMemOnly};\n\nvoid AAMemoryLocationImpl::categorizePtrValue(\n    Attributor &A, const Instruction &I, const Value &Ptr,\n    AAMemoryLocation::StateType &State, bool &Changed) {\n  LLVM_DEBUG(dbgs() << \"[AAMemoryLocation] Categorize pointer locations for \"\n                    << Ptr << \" [\"\n                    << getMemoryLocationsAsStr(State.getAssumed()) << \"]\\n\");\n\n  auto StripGEPCB = [](Value *V) -> Value * {\n    auto *GEP = dyn_cast<GEPOperator>(V);\n    while (GEP) {\n      V = GEP->getPointerOperand();\n      GEP = dyn_cast<GEPOperator>(V);\n    }\n    return V;\n  };\n\n  auto VisitValueCB = [&](Value &V, const Instruction *,\n                          AAMemoryLocation::StateType &T,\n                          bool Stripped) -> bool {\n    // TODO: recognize the TBAA used for constant accesses.\n    MemoryLocationsKind MLK = NO_LOCATIONS;\n    assert(!isa<GEPOperator>(V) && \"GEPs should have been stripped.\");\n    if (isa<UndefValue>(V))\n      return true;\n    if (auto *Arg = dyn_cast<Argument>(&V)) {\n      if (Arg->hasByValAttr())\n        MLK = NO_LOCAL_MEM;\n      else\n        MLK = NO_ARGUMENT_MEM;\n    } else if (auto *GV = dyn_cast<GlobalValue>(&V)) {\n      // Reading constant memory is not treated as a read \"effect\" by the\n      // function attr pass so we won't neither. Constants defined by TBAA are\n      // similar. (We know we do not write it because it is constant.)\n      if (auto *GVar = dyn_cast<GlobalVariable>(GV))\n        if (GVar->isConstant())\n          return true;\n\n      if (GV->hasLocalLinkage())\n        MLK = NO_GLOBAL_INTERNAL_MEM;\n      else\n        MLK = NO_GLOBAL_EXTERNAL_MEM;\n    } else if (isa<ConstantPointerNull>(V) &&\n               !NullPointerIsDefined(getAssociatedFunction(),\n                                     V.getType()->getPointerAddressSpace())) {\n      return true;\n    } else if (isa<AllocaInst>(V)) {\n      MLK = NO_LOCAL_MEM;\n    } else if (const auto *CB = dyn_cast<CallBase>(&V)) {\n      const auto &NoAliasAA = A.getAAFor<AANoAlias>(\n          *this, IRPosition::callsite_returned(*CB), DepClassTy::OPTIONAL);\n      if (NoAliasAA.isAssumedNoAlias())\n        MLK = NO_MALLOCED_MEM;\n      else\n        MLK = NO_UNKOWN_MEM;\n    } else {\n      MLK = NO_UNKOWN_MEM;\n    }\n\n    assert(MLK != NO_LOCATIONS && \"No location specified!\");\n    updateStateAndAccessesMap(T, MLK, &I, &V, Changed,\n                              getAccessKindFromInst(&I));\n    LLVM_DEBUG(dbgs() << \"[AAMemoryLocation] Ptr value cannot be categorized: \"\n                      << V << \" -> \" << getMemoryLocationsAsStr(T.getAssumed())\n                      << \"\\n\");\n    return true;\n  };\n\n  if (!genericValueTraversal<AAMemoryLocation, AAMemoryLocation::StateType>(\n          A, IRPosition::value(Ptr), *this, State, VisitValueCB, getCtxI(),\n          /* UseValueSimplify */ true,\n          /* MaxValues */ 32, StripGEPCB)) {\n    LLVM_DEBUG(\n        dbgs() << \"[AAMemoryLocation] Pointer locations not categorized\\n\");\n    updateStateAndAccessesMap(State, NO_UNKOWN_MEM, &I, nullptr, Changed,\n                              getAccessKindFromInst(&I));\n  } else {\n    LLVM_DEBUG(\n        dbgs()\n        << \"[AAMemoryLocation] Accessed locations with pointer locations: \"\n        << getMemoryLocationsAsStr(State.getAssumed()) << \"\\n\");\n  }\n}\n\nvoid AAMemoryLocationImpl::categorizeArgumentPointerLocations(\n    Attributor &A, CallBase &CB, AAMemoryLocation::StateType &AccessedLocs,\n    bool &Changed) {\n  for (unsigned ArgNo = 0, E = CB.getNumArgOperands(); ArgNo < E; ++ArgNo) {\n\n    // Skip non-pointer arguments.\n    const Value *ArgOp = CB.getArgOperand(ArgNo);\n    if (!ArgOp->getType()->isPtrOrPtrVectorTy())\n      continue;\n\n    // Skip readnone arguments.\n    const IRPosition &ArgOpIRP = IRPosition::callsite_argument(CB, ArgNo);\n    const auto &ArgOpMemLocationAA =\n        A.getAAFor<AAMemoryBehavior>(*this, ArgOpIRP, DepClassTy::OPTIONAL);\n\n    if (ArgOpMemLocationAA.isAssumedReadNone())\n      continue;\n\n    // Categorize potentially accessed pointer arguments as if there was an\n    // access instruction with them as pointer.\n    categorizePtrValue(A, CB, *ArgOp, AccessedLocs, Changed);\n  }\n}\n\nAAMemoryLocation::MemoryLocationsKind\nAAMemoryLocationImpl::categorizeAccessedLocations(Attributor &A, Instruction &I,\n                                                  bool &Changed) {\n  LLVM_DEBUG(dbgs() << \"[AAMemoryLocation] Categorize accessed locations for \"\n                    << I << \"\\n\");\n\n  AAMemoryLocation::StateType AccessedLocs;\n  AccessedLocs.intersectAssumedBits(NO_LOCATIONS);\n\n  if (auto *CB = dyn_cast<CallBase>(&I)) {\n\n    // First check if we assume any memory is access is visible.\n    const auto &CBMemLocationAA = A.getAAFor<AAMemoryLocation>(\n        *this, IRPosition::callsite_function(*CB), DepClassTy::OPTIONAL);\n    LLVM_DEBUG(dbgs() << \"[AAMemoryLocation] Categorize call site: \" << I\n                      << \" [\" << CBMemLocationAA << \"]\\n\");\n\n    if (CBMemLocationAA.isAssumedReadNone())\n      return NO_LOCATIONS;\n\n    if (CBMemLocationAA.isAssumedInaccessibleMemOnly()) {\n      updateStateAndAccessesMap(AccessedLocs, NO_INACCESSIBLE_MEM, &I, nullptr,\n                                Changed, getAccessKindFromInst(&I));\n      return AccessedLocs.getAssumed();\n    }\n\n    uint32_t CBAssumedNotAccessedLocs =\n        CBMemLocationAA.getAssumedNotAccessedLocation();\n\n    // Set the argmemonly and global bit as we handle them separately below.\n    uint32_t CBAssumedNotAccessedLocsNoArgMem =\n        CBAssumedNotAccessedLocs | NO_ARGUMENT_MEM | NO_GLOBAL_MEM;\n\n    for (MemoryLocationsKind CurMLK = 1; CurMLK < NO_LOCATIONS; CurMLK *= 2) {\n      if (CBAssumedNotAccessedLocsNoArgMem & CurMLK)\n        continue;\n      updateStateAndAccessesMap(AccessedLocs, CurMLK, &I, nullptr, Changed,\n                                getAccessKindFromInst(&I));\n    }\n\n    // Now handle global memory if it might be accessed. This is slightly tricky\n    // as NO_GLOBAL_MEM has multiple bits set.\n    bool HasGlobalAccesses = ((~CBAssumedNotAccessedLocs) & NO_GLOBAL_MEM);\n    if (HasGlobalAccesses) {\n      auto AccessPred = [&](const Instruction *, const Value *Ptr,\n                            AccessKind Kind, MemoryLocationsKind MLK) {\n        updateStateAndAccessesMap(AccessedLocs, MLK, &I, Ptr, Changed,\n                                  getAccessKindFromInst(&I));\n        return true;\n      };\n      if (!CBMemLocationAA.checkForAllAccessesToMemoryKind(\n              AccessPred, inverseLocation(NO_GLOBAL_MEM, false, false)))\n        return AccessedLocs.getWorstState();\n    }\n\n    LLVM_DEBUG(\n        dbgs() << \"[AAMemoryLocation] Accessed state before argument handling: \"\n               << getMemoryLocationsAsStr(AccessedLocs.getAssumed()) << \"\\n\");\n\n    // Now handle argument memory if it might be accessed.\n    bool HasArgAccesses = ((~CBAssumedNotAccessedLocs) & NO_ARGUMENT_MEM);\n    if (HasArgAccesses)\n      categorizeArgumentPointerLocations(A, *CB, AccessedLocs, Changed);\n\n    LLVM_DEBUG(\n        dbgs() << \"[AAMemoryLocation] Accessed state after argument handling: \"\n               << getMemoryLocationsAsStr(AccessedLocs.getAssumed()) << \"\\n\");\n\n    return AccessedLocs.getAssumed();\n  }\n\n  if (const Value *Ptr = getPointerOperand(&I, /* AllowVolatile */ true)) {\n    LLVM_DEBUG(\n        dbgs() << \"[AAMemoryLocation] Categorize memory access with pointer: \"\n               << I << \" [\" << *Ptr << \"]\\n\");\n    categorizePtrValue(A, I, *Ptr, AccessedLocs, Changed);\n    return AccessedLocs.getAssumed();\n  }\n\n  LLVM_DEBUG(dbgs() << \"[AAMemoryLocation] Failed to categorize instruction: \"\n                    << I << \"\\n\");\n  updateStateAndAccessesMap(AccessedLocs, NO_UNKOWN_MEM, &I, nullptr, Changed,\n                            getAccessKindFromInst(&I));\n  return AccessedLocs.getAssumed();\n}\n\n/// An AA to represent the memory behavior function attributes.\nstruct AAMemoryLocationFunction final : public AAMemoryLocationImpl {\n  AAMemoryLocationFunction(const IRPosition &IRP, Attributor &A)\n      : AAMemoryLocationImpl(IRP, A) {}\n\n  /// See AbstractAttribute::updateImpl(Attributor &A).\n  virtual ChangeStatus updateImpl(Attributor &A) override {\n\n    const auto &MemBehaviorAA =\n        A.getAAFor<AAMemoryBehavior>(*this, getIRPosition(), DepClassTy::NONE);\n    if (MemBehaviorAA.isAssumedReadNone()) {\n      if (MemBehaviorAA.isKnownReadNone())\n        return indicateOptimisticFixpoint();\n      assert(isAssumedReadNone() &&\n             \"AAMemoryLocation was not read-none but AAMemoryBehavior was!\");\n      A.recordDependence(MemBehaviorAA, *this, DepClassTy::OPTIONAL);\n      return ChangeStatus::UNCHANGED;\n    }\n\n    // The current assumed state used to determine a change.\n    auto AssumedState = getAssumed();\n    bool Changed = false;\n\n    auto CheckRWInst = [&](Instruction &I) {\n      MemoryLocationsKind MLK = categorizeAccessedLocations(A, I, Changed);\n      LLVM_DEBUG(dbgs() << \"[AAMemoryLocation] Accessed locations for \" << I\n                        << \": \" << getMemoryLocationsAsStr(MLK) << \"\\n\");\n      removeAssumedBits(inverseLocation(MLK, false, false));\n      // Stop once only the valid bit set in the *not assumed location*, thus\n      // once we don't actually exclude any memory locations in the state.\n      return getAssumedNotAccessedLocation() != VALID_STATE;\n    };\n\n    if (!A.checkForAllReadWriteInstructions(CheckRWInst, *this))\n      return indicatePessimisticFixpoint();\n\n    Changed |= AssumedState != getAssumed();\n    return Changed ? ChangeStatus::CHANGED : ChangeStatus::UNCHANGED;\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    if (isAssumedReadNone())\n      STATS_DECLTRACK_FN_ATTR(readnone)\n    else if (isAssumedArgMemOnly())\n      STATS_DECLTRACK_FN_ATTR(argmemonly)\n    else if (isAssumedInaccessibleMemOnly())\n      STATS_DECLTRACK_FN_ATTR(inaccessiblememonly)\n    else if (isAssumedInaccessibleOrArgMemOnly())\n      STATS_DECLTRACK_FN_ATTR(inaccessiblememorargmemonly)\n  }\n};\n\n/// AAMemoryLocation attribute for call sites.\nstruct AAMemoryLocationCallSite final : AAMemoryLocationImpl {\n  AAMemoryLocationCallSite(const IRPosition &IRP, Attributor &A)\n      : AAMemoryLocationImpl(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    AAMemoryLocationImpl::initialize(A);\n    Function *F = getAssociatedFunction();\n    if (!F || F->isDeclaration())\n      indicatePessimisticFixpoint();\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    // TODO: Once we have call site specific value information we can provide\n    //       call site specific liveness liveness information and then it makes\n    //       sense to specialize attributes for call sites arguments instead of\n    //       redirecting requests to the callee argument.\n    Function *F = getAssociatedFunction();\n    const IRPosition &FnPos = IRPosition::function(*F);\n    auto &FnAA =\n        A.getAAFor<AAMemoryLocation>(*this, FnPos, DepClassTy::REQUIRED);\n    bool Changed = false;\n    auto AccessPred = [&](const Instruction *I, const Value *Ptr,\n                          AccessKind Kind, MemoryLocationsKind MLK) {\n      updateStateAndAccessesMap(getState(), MLK, I, Ptr, Changed,\n                                getAccessKindFromInst(I));\n      return true;\n    };\n    if (!FnAA.checkForAllAccessesToMemoryKind(AccessPred, ALL_LOCATIONS))\n      return indicatePessimisticFixpoint();\n    return Changed ? ChangeStatus::CHANGED : ChangeStatus::UNCHANGED;\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    if (isAssumedReadNone())\n      STATS_DECLTRACK_CS_ATTR(readnone)\n  }\n};\n\n/// ------------------ Value Constant Range Attribute -------------------------\n\nstruct AAValueConstantRangeImpl : AAValueConstantRange {\n  using StateType = IntegerRangeState;\n  AAValueConstantRangeImpl(const IRPosition &IRP, Attributor &A)\n      : AAValueConstantRange(IRP, A) {}\n\n  /// See AbstractAttribute::getAsStr().\n  const std::string getAsStr() const override {\n    std::string Str;\n    llvm::raw_string_ostream OS(Str);\n    OS << \"range(\" << getBitWidth() << \")<\";\n    getKnown().print(OS);\n    OS << \" / \";\n    getAssumed().print(OS);\n    OS << \">\";\n    return OS.str();\n  }\n\n  /// Helper function to get a SCEV expr for the associated value at program\n  /// point \\p I.\n  const SCEV *getSCEV(Attributor &A, const Instruction *I = nullptr) const {\n    if (!getAnchorScope())\n      return nullptr;\n\n    ScalarEvolution *SE =\n        A.getInfoCache().getAnalysisResultForFunction<ScalarEvolutionAnalysis>(\n            *getAnchorScope());\n\n    LoopInfo *LI = A.getInfoCache().getAnalysisResultForFunction<LoopAnalysis>(\n        *getAnchorScope());\n\n    if (!SE || !LI)\n      return nullptr;\n\n    const SCEV *S = SE->getSCEV(&getAssociatedValue());\n    if (!I)\n      return S;\n\n    return SE->getSCEVAtScope(S, LI->getLoopFor(I->getParent()));\n  }\n\n  /// Helper function to get a range from SCEV for the associated value at\n  /// program point \\p I.\n  ConstantRange getConstantRangeFromSCEV(Attributor &A,\n                                         const Instruction *I = nullptr) const {\n    if (!getAnchorScope())\n      return getWorstState(getBitWidth());\n\n    ScalarEvolution *SE =\n        A.getInfoCache().getAnalysisResultForFunction<ScalarEvolutionAnalysis>(\n            *getAnchorScope());\n\n    const SCEV *S = getSCEV(A, I);\n    if (!SE || !S)\n      return getWorstState(getBitWidth());\n\n    return SE->getUnsignedRange(S);\n  }\n\n  /// Helper function to get a range from LVI for the associated value at\n  /// program point \\p I.\n  ConstantRange\n  getConstantRangeFromLVI(Attributor &A,\n                          const Instruction *CtxI = nullptr) const {\n    if (!getAnchorScope())\n      return getWorstState(getBitWidth());\n\n    LazyValueInfo *LVI =\n        A.getInfoCache().getAnalysisResultForFunction<LazyValueAnalysis>(\n            *getAnchorScope());\n\n    if (!LVI || !CtxI)\n      return getWorstState(getBitWidth());\n    return LVI->getConstantRange(&getAssociatedValue(),\n                                 const_cast<Instruction *>(CtxI));\n  }\n\n  /// See AAValueConstantRange::getKnownConstantRange(..).\n  ConstantRange\n  getKnownConstantRange(Attributor &A,\n                        const Instruction *CtxI = nullptr) const override {\n    if (!CtxI || CtxI == getCtxI())\n      return getKnown();\n\n    ConstantRange LVIR = getConstantRangeFromLVI(A, CtxI);\n    ConstantRange SCEVR = getConstantRangeFromSCEV(A, CtxI);\n    return getKnown().intersectWith(SCEVR).intersectWith(LVIR);\n  }\n\n  /// See AAValueConstantRange::getAssumedConstantRange(..).\n  ConstantRange\n  getAssumedConstantRange(Attributor &A,\n                          const Instruction *CtxI = nullptr) const override {\n    // TODO: Make SCEV use Attributor assumption.\n    //       We may be able to bound a variable range via assumptions in\n    //       Attributor. ex.) If x is assumed to be in [1, 3] and y is known to\n    //       evolve to x^2 + x, then we can say that y is in [2, 12].\n\n    if (!CtxI || CtxI == getCtxI())\n      return getAssumed();\n\n    ConstantRange LVIR = getConstantRangeFromLVI(A, CtxI);\n    ConstantRange SCEVR = getConstantRangeFromSCEV(A, CtxI);\n    return getAssumed().intersectWith(SCEVR).intersectWith(LVIR);\n  }\n\n  /// See AbstractAttribute::initialize(..).\n  void initialize(Attributor &A) override {\n    // Intersect a range given by SCEV.\n    intersectKnown(getConstantRangeFromSCEV(A, getCtxI()));\n\n    // Intersect a range given by LVI.\n    intersectKnown(getConstantRangeFromLVI(A, getCtxI()));\n  }\n\n  /// Helper function to create MDNode for range metadata.\n  static MDNode *\n  getMDNodeForConstantRange(Type *Ty, LLVMContext &Ctx,\n                            const ConstantRange &AssumedConstantRange) {\n    Metadata *LowAndHigh[] = {ConstantAsMetadata::get(ConstantInt::get(\n                                  Ty, AssumedConstantRange.getLower())),\n                              ConstantAsMetadata::get(ConstantInt::get(\n                                  Ty, AssumedConstantRange.getUpper()))};\n    return MDNode::get(Ctx, LowAndHigh);\n  }\n\n  /// Return true if \\p Assumed is included in \\p KnownRanges.\n  static bool isBetterRange(const ConstantRange &Assumed, MDNode *KnownRanges) {\n\n    if (Assumed.isFullSet())\n      return false;\n\n    if (!KnownRanges)\n      return true;\n\n    // If multiple ranges are annotated in IR, we give up to annotate assumed\n    // range for now.\n\n    // TODO:  If there exists a known range which containts assumed range, we\n    // can say assumed range is better.\n    if (KnownRanges->getNumOperands() > 2)\n      return false;\n\n    ConstantInt *Lower =\n        mdconst::extract<ConstantInt>(KnownRanges->getOperand(0));\n    ConstantInt *Upper =\n        mdconst::extract<ConstantInt>(KnownRanges->getOperand(1));\n\n    ConstantRange Known(Lower->getValue(), Upper->getValue());\n    return Known.contains(Assumed) && Known != Assumed;\n  }\n\n  /// Helper function to set range metadata.\n  static bool\n  setRangeMetadataIfisBetterRange(Instruction *I,\n                                  const ConstantRange &AssumedConstantRange) {\n    auto *OldRangeMD = I->getMetadata(LLVMContext::MD_range);\n    if (isBetterRange(AssumedConstantRange, OldRangeMD)) {\n      if (!AssumedConstantRange.isEmptySet()) {\n        I->setMetadata(LLVMContext::MD_range,\n                       getMDNodeForConstantRange(I->getType(), I->getContext(),\n                                                 AssumedConstantRange));\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /// See AbstractAttribute::manifest()\n  ChangeStatus manifest(Attributor &A) override {\n    ChangeStatus Changed = ChangeStatus::UNCHANGED;\n    ConstantRange AssumedConstantRange = getAssumedConstantRange(A);\n    assert(!AssumedConstantRange.isFullSet() && \"Invalid state\");\n\n    auto &V = getAssociatedValue();\n    if (!AssumedConstantRange.isEmptySet() &&\n        !AssumedConstantRange.isSingleElement()) {\n      if (Instruction *I = dyn_cast<Instruction>(&V)) {\n        assert(I == getCtxI() && \"Should not annotate an instruction which is \"\n                                 \"not the context instruction\");\n        if (isa<CallInst>(I) || isa<LoadInst>(I))\n          if (setRangeMetadataIfisBetterRange(I, AssumedConstantRange))\n            Changed = ChangeStatus::CHANGED;\n      }\n    }\n\n    return Changed;\n  }\n};\n\nstruct AAValueConstantRangeArgument final\n    : AAArgumentFromCallSiteArguments<\n          AAValueConstantRange, AAValueConstantRangeImpl, IntegerRangeState,\n          true /* BridgeCallBaseContext */> {\n  using Base = AAArgumentFromCallSiteArguments<\n      AAValueConstantRange, AAValueConstantRangeImpl, IntegerRangeState,\n      true /* BridgeCallBaseContext */>;\n  AAValueConstantRangeArgument(const IRPosition &IRP, Attributor &A)\n      : Base(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(..).\n  void initialize(Attributor &A) override {\n    if (!getAnchorScope() || getAnchorScope()->isDeclaration()) {\n      indicatePessimisticFixpoint();\n    } else {\n      Base::initialize(A);\n    }\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    STATS_DECLTRACK_ARG_ATTR(value_range)\n  }\n};\n\nstruct AAValueConstantRangeReturned\n    : AAReturnedFromReturnedValues<AAValueConstantRange,\n                                   AAValueConstantRangeImpl,\n                                   AAValueConstantRangeImpl::StateType,\n                                   /* PropogateCallBaseContext */ true> {\n  using Base =\n      AAReturnedFromReturnedValues<AAValueConstantRange,\n                                   AAValueConstantRangeImpl,\n                                   AAValueConstantRangeImpl::StateType,\n                                   /* PropogateCallBaseContext */ true>;\n  AAValueConstantRangeReturned(const IRPosition &IRP, Attributor &A)\n      : Base(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {}\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    STATS_DECLTRACK_FNRET_ATTR(value_range)\n  }\n};\n\nstruct AAValueConstantRangeFloating : AAValueConstantRangeImpl {\n  AAValueConstantRangeFloating(const IRPosition &IRP, Attributor &A)\n      : AAValueConstantRangeImpl(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    AAValueConstantRangeImpl::initialize(A);\n    Value &V = getAssociatedValue();\n\n    if (auto *C = dyn_cast<ConstantInt>(&V)) {\n      unionAssumed(ConstantRange(C->getValue()));\n      indicateOptimisticFixpoint();\n      return;\n    }\n\n    if (isa<UndefValue>(&V)) {\n      // Collapse the undef state to 0.\n      unionAssumed(ConstantRange(APInt(getBitWidth(), 0)));\n      indicateOptimisticFixpoint();\n      return;\n    }\n\n    if (isa<CallBase>(&V))\n      return;\n\n    if (isa<BinaryOperator>(&V) || isa<CmpInst>(&V) || isa<CastInst>(&V))\n      return;\n    // If it is a load instruction with range metadata, use it.\n    if (LoadInst *LI = dyn_cast<LoadInst>(&V))\n      if (auto *RangeMD = LI->getMetadata(LLVMContext::MD_range)) {\n        intersectKnown(getConstantRangeFromMetadata(*RangeMD));\n        return;\n      }\n\n    // We can work with PHI and select instruction as we traverse their operands\n    // during update.\n    if (isa<SelectInst>(V) || isa<PHINode>(V))\n      return;\n\n    // Otherwise we give up.\n    indicatePessimisticFixpoint();\n\n    LLVM_DEBUG(dbgs() << \"[AAValueConstantRange] We give up: \"\n                      << getAssociatedValue() << \"\\n\");\n  }\n\n  bool calculateBinaryOperator(\n      Attributor &A, BinaryOperator *BinOp, IntegerRangeState &T,\n      const Instruction *CtxI,\n      SmallVectorImpl<const AAValueConstantRange *> &QuerriedAAs) {\n    Value *LHS = BinOp->getOperand(0);\n    Value *RHS = BinOp->getOperand(1);\n    // TODO: Allow non integers as well.\n    if (!LHS->getType()->isIntegerTy() || !RHS->getType()->isIntegerTy())\n      return false;\n\n    auto &LHSAA = A.getAAFor<AAValueConstantRange>(\n        *this, IRPosition::value(*LHS, getCallBaseContext()),\n        DepClassTy::REQUIRED);\n    QuerriedAAs.push_back(&LHSAA);\n    auto LHSAARange = LHSAA.getAssumedConstantRange(A, CtxI);\n\n    auto &RHSAA = A.getAAFor<AAValueConstantRange>(\n        *this, IRPosition::value(*RHS, getCallBaseContext()),\n        DepClassTy::REQUIRED);\n    QuerriedAAs.push_back(&RHSAA);\n    auto RHSAARange = RHSAA.getAssumedConstantRange(A, CtxI);\n\n    auto AssumedRange = LHSAARange.binaryOp(BinOp->getOpcode(), RHSAARange);\n\n    T.unionAssumed(AssumedRange);\n\n    // TODO: Track a known state too.\n\n    return T.isValidState();\n  }\n\n  bool calculateCastInst(\n      Attributor &A, CastInst *CastI, IntegerRangeState &T,\n      const Instruction *CtxI,\n      SmallVectorImpl<const AAValueConstantRange *> &QuerriedAAs) {\n    assert(CastI->getNumOperands() == 1 && \"Expected cast to be unary!\");\n    // TODO: Allow non integers as well.\n    Value &OpV = *CastI->getOperand(0);\n    if (!OpV.getType()->isIntegerTy())\n      return false;\n\n    auto &OpAA = A.getAAFor<AAValueConstantRange>(\n        *this, IRPosition::value(OpV, getCallBaseContext()),\n        DepClassTy::REQUIRED);\n    QuerriedAAs.push_back(&OpAA);\n    T.unionAssumed(\n        OpAA.getAssumed().castOp(CastI->getOpcode(), getState().getBitWidth()));\n    return T.isValidState();\n  }\n\n  bool\n  calculateCmpInst(Attributor &A, CmpInst *CmpI, IntegerRangeState &T,\n                   const Instruction *CtxI,\n                   SmallVectorImpl<const AAValueConstantRange *> &QuerriedAAs) {\n    Value *LHS = CmpI->getOperand(0);\n    Value *RHS = CmpI->getOperand(1);\n    // TODO: Allow non integers as well.\n    if (!LHS->getType()->isIntegerTy() || !RHS->getType()->isIntegerTy())\n      return false;\n\n    auto &LHSAA = A.getAAFor<AAValueConstantRange>(\n        *this, IRPosition::value(*LHS, getCallBaseContext()),\n        DepClassTy::REQUIRED);\n    QuerriedAAs.push_back(&LHSAA);\n    auto &RHSAA = A.getAAFor<AAValueConstantRange>(\n        *this, IRPosition::value(*RHS, getCallBaseContext()),\n        DepClassTy::REQUIRED);\n    auto LHSAARange = LHSAA.getAssumedConstantRange(A, CtxI);\n    auto RHSAARange = RHSAA.getAssumedConstantRange(A, CtxI);\n\n    // If one of them is empty set, we can't decide.\n    if (LHSAARange.isEmptySet() || RHSAARange.isEmptySet())\n      return true;\n\n    bool MustTrue = false, MustFalse = false;\n\n    auto AllowedRegion =\n        ConstantRange::makeAllowedICmpRegion(CmpI->getPredicate(), RHSAARange);\n\n    auto SatisfyingRegion = ConstantRange::makeSatisfyingICmpRegion(\n        CmpI->getPredicate(), RHSAARange);\n\n    if (AllowedRegion.intersectWith(LHSAARange).isEmptySet())\n      MustFalse = true;\n\n    if (SatisfyingRegion.contains(LHSAARange))\n      MustTrue = true;\n\n    assert((!MustTrue || !MustFalse) &&\n           \"Either MustTrue or MustFalse should be false!\");\n\n    if (MustTrue)\n      T.unionAssumed(ConstantRange(APInt(/* numBits */ 1, /* val */ 1)));\n    else if (MustFalse)\n      T.unionAssumed(ConstantRange(APInt(/* numBits */ 1, /* val */ 0)));\n    else\n      T.unionAssumed(ConstantRange(/* BitWidth */ 1, /* isFullSet */ true));\n\n    LLVM_DEBUG(dbgs() << \"[AAValueConstantRange] \" << *CmpI << \" \" << LHSAA\n                      << \" \" << RHSAA << \"\\n\");\n\n    // TODO: Track a known state too.\n    return T.isValidState();\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    auto VisitValueCB = [&](Value &V, const Instruction *CtxI,\n                            IntegerRangeState &T, bool Stripped) -> bool {\n      Instruction *I = dyn_cast<Instruction>(&V);\n      if (!I || isa<CallBase>(I)) {\n\n        // If the value is not instruction, we query AA to Attributor.\n        const auto &AA = A.getAAFor<AAValueConstantRange>(\n            *this, IRPosition::value(V), DepClassTy::REQUIRED);\n\n        // Clamp operator is not used to utilize a program point CtxI.\n        T.unionAssumed(AA.getAssumedConstantRange(A, CtxI));\n\n        return T.isValidState();\n      }\n\n      SmallVector<const AAValueConstantRange *, 4> QuerriedAAs;\n      if (auto *BinOp = dyn_cast<BinaryOperator>(I)) {\n        if (!calculateBinaryOperator(A, BinOp, T, CtxI, QuerriedAAs))\n          return false;\n      } else if (auto *CmpI = dyn_cast<CmpInst>(I)) {\n        if (!calculateCmpInst(A, CmpI, T, CtxI, QuerriedAAs))\n          return false;\n      } else if (auto *CastI = dyn_cast<CastInst>(I)) {\n        if (!calculateCastInst(A, CastI, T, CtxI, QuerriedAAs))\n          return false;\n      } else {\n        // Give up with other instructions.\n        // TODO: Add other instructions\n\n        T.indicatePessimisticFixpoint();\n        return false;\n      }\n\n      // Catch circular reasoning in a pessimistic way for now.\n      // TODO: Check how the range evolves and if we stripped anything, see also\n      //       AADereferenceable or AAAlign for similar situations.\n      for (const AAValueConstantRange *QueriedAA : QuerriedAAs) {\n        if (QueriedAA != this)\n          continue;\n        // If we are in a stady state we do not need to worry.\n        if (T.getAssumed() == getState().getAssumed())\n          continue;\n        T.indicatePessimisticFixpoint();\n      }\n\n      return T.isValidState();\n    };\n\n    IntegerRangeState T(getBitWidth());\n\n    if (!genericValueTraversal<AAValueConstantRange, IntegerRangeState>(\n            A, getIRPosition(), *this, T, VisitValueCB, getCtxI(),\n            /* UseValueSimplify */ false))\n      return indicatePessimisticFixpoint();\n\n    return clampStateAndIndicateChange(getState(), T);\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    STATS_DECLTRACK_FLOATING_ATTR(value_range)\n  }\n};\n\nstruct AAValueConstantRangeFunction : AAValueConstantRangeImpl {\n  AAValueConstantRangeFunction(const IRPosition &IRP, Attributor &A)\n      : AAValueConstantRangeImpl(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    llvm_unreachable(\"AAValueConstantRange(Function|CallSite)::updateImpl will \"\n                     \"not be called\");\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_FN_ATTR(value_range) }\n};\n\nstruct AAValueConstantRangeCallSite : AAValueConstantRangeFunction {\n  AAValueConstantRangeCallSite(const IRPosition &IRP, Attributor &A)\n      : AAValueConstantRangeFunction(IRP, A) {}\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_CS_ATTR(value_range) }\n};\n\nstruct AAValueConstantRangeCallSiteReturned\n    : AACallSiteReturnedFromReturned<AAValueConstantRange,\n                                     AAValueConstantRangeImpl,\n                                     AAValueConstantRangeImpl::StateType,\n                                     /* IntroduceCallBaseContext */ true> {\n  AAValueConstantRangeCallSiteReturned(const IRPosition &IRP, Attributor &A)\n      : AACallSiteReturnedFromReturned<AAValueConstantRange,\n                                       AAValueConstantRangeImpl,\n                                       AAValueConstantRangeImpl::StateType,\n                                       /* IntroduceCallBaseContext */ true>(IRP,\n                                                                            A) {\n  }\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    // If it is a load instruction with range metadata, use the metadata.\n    if (CallInst *CI = dyn_cast<CallInst>(&getAssociatedValue()))\n      if (auto *RangeMD = CI->getMetadata(LLVMContext::MD_range))\n        intersectKnown(getConstantRangeFromMetadata(*RangeMD));\n\n    AAValueConstantRangeImpl::initialize(A);\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    STATS_DECLTRACK_CSRET_ATTR(value_range)\n  }\n};\nstruct AAValueConstantRangeCallSiteArgument : AAValueConstantRangeFloating {\n  AAValueConstantRangeCallSiteArgument(const IRPosition &IRP, Attributor &A)\n      : AAValueConstantRangeFloating(IRP, A) {}\n\n  /// See AbstractAttribute::manifest()\n  ChangeStatus manifest(Attributor &A) override {\n    return ChangeStatus::UNCHANGED;\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    STATS_DECLTRACK_CSARG_ATTR(value_range)\n  }\n};\n\n/// ------------------ Potential Values Attribute -------------------------\n\nstruct AAPotentialValuesImpl : AAPotentialValues {\n  using StateType = PotentialConstantIntValuesState;\n\n  AAPotentialValuesImpl(const IRPosition &IRP, Attributor &A)\n      : AAPotentialValues(IRP, A) {}\n\n  /// See AbstractAttribute::getAsStr().\n  const std::string getAsStr() const override {\n    std::string Str;\n    llvm::raw_string_ostream OS(Str);\n    OS << getState();\n    return OS.str();\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    return indicatePessimisticFixpoint();\n  }\n};\n\nstruct AAPotentialValuesArgument final\n    : AAArgumentFromCallSiteArguments<AAPotentialValues, AAPotentialValuesImpl,\n                                      PotentialConstantIntValuesState> {\n  using Base =\n      AAArgumentFromCallSiteArguments<AAPotentialValues, AAPotentialValuesImpl,\n                                      PotentialConstantIntValuesState>;\n  AAPotentialValuesArgument(const IRPosition &IRP, Attributor &A)\n      : Base(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(..).\n  void initialize(Attributor &A) override {\n    if (!getAnchorScope() || getAnchorScope()->isDeclaration()) {\n      indicatePessimisticFixpoint();\n    } else {\n      Base::initialize(A);\n    }\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    STATS_DECLTRACK_ARG_ATTR(potential_values)\n  }\n};\n\nstruct AAPotentialValuesReturned\n    : AAReturnedFromReturnedValues<AAPotentialValues, AAPotentialValuesImpl> {\n  using Base =\n      AAReturnedFromReturnedValues<AAPotentialValues, AAPotentialValuesImpl>;\n  AAPotentialValuesReturned(const IRPosition &IRP, Attributor &A)\n      : Base(IRP, A) {}\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    STATS_DECLTRACK_FNRET_ATTR(potential_values)\n  }\n};\n\nstruct AAPotentialValuesFloating : AAPotentialValuesImpl {\n  AAPotentialValuesFloating(const IRPosition &IRP, Attributor &A)\n      : AAPotentialValuesImpl(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(..).\n  void initialize(Attributor &A) override {\n    Value &V = getAssociatedValue();\n\n    if (auto *C = dyn_cast<ConstantInt>(&V)) {\n      unionAssumed(C->getValue());\n      indicateOptimisticFixpoint();\n      return;\n    }\n\n    if (isa<UndefValue>(&V)) {\n      unionAssumedWithUndef();\n      indicateOptimisticFixpoint();\n      return;\n    }\n\n    if (isa<BinaryOperator>(&V) || isa<ICmpInst>(&V) || isa<CastInst>(&V))\n      return;\n\n    if (isa<SelectInst>(V) || isa<PHINode>(V))\n      return;\n\n    indicatePessimisticFixpoint();\n\n    LLVM_DEBUG(dbgs() << \"[AAPotentialValues] We give up: \"\n                      << getAssociatedValue() << \"\\n\");\n  }\n\n  static bool calculateICmpInst(const ICmpInst *ICI, const APInt &LHS,\n                                const APInt &RHS) {\n    ICmpInst::Predicate Pred = ICI->getPredicate();\n    switch (Pred) {\n    case ICmpInst::ICMP_UGT:\n      return LHS.ugt(RHS);\n    case ICmpInst::ICMP_SGT:\n      return LHS.sgt(RHS);\n    case ICmpInst::ICMP_EQ:\n      return LHS.eq(RHS);\n    case ICmpInst::ICMP_UGE:\n      return LHS.uge(RHS);\n    case ICmpInst::ICMP_SGE:\n      return LHS.sge(RHS);\n    case ICmpInst::ICMP_ULT:\n      return LHS.ult(RHS);\n    case ICmpInst::ICMP_SLT:\n      return LHS.slt(RHS);\n    case ICmpInst::ICMP_NE:\n      return LHS.ne(RHS);\n    case ICmpInst::ICMP_ULE:\n      return LHS.ule(RHS);\n    case ICmpInst::ICMP_SLE:\n      return LHS.sle(RHS);\n    default:\n      llvm_unreachable(\"Invalid ICmp predicate!\");\n    }\n  }\n\n  static APInt calculateCastInst(const CastInst *CI, const APInt &Src,\n                                 uint32_t ResultBitWidth) {\n    Instruction::CastOps CastOp = CI->getOpcode();\n    switch (CastOp) {\n    default:\n      llvm_unreachable(\"unsupported or not integer cast\");\n    case Instruction::Trunc:\n      return Src.trunc(ResultBitWidth);\n    case Instruction::SExt:\n      return Src.sext(ResultBitWidth);\n    case Instruction::ZExt:\n      return Src.zext(ResultBitWidth);\n    case Instruction::BitCast:\n      return Src;\n    }\n  }\n\n  static APInt calculateBinaryOperator(const BinaryOperator *BinOp,\n                                       const APInt &LHS, const APInt &RHS,\n                                       bool &SkipOperation, bool &Unsupported) {\n    Instruction::BinaryOps BinOpcode = BinOp->getOpcode();\n    // Unsupported is set to true when the binary operator is not supported.\n    // SkipOperation is set to true when UB occur with the given operand pair\n    // (LHS, RHS).\n    // TODO: we should look at nsw and nuw keywords to handle operations\n    //       that create poison or undef value.\n    switch (BinOpcode) {\n    default:\n      Unsupported = true;\n      return LHS;\n    case Instruction::Add:\n      return LHS + RHS;\n    case Instruction::Sub:\n      return LHS - RHS;\n    case Instruction::Mul:\n      return LHS * RHS;\n    case Instruction::UDiv:\n      if (RHS.isNullValue()) {\n        SkipOperation = true;\n        return LHS;\n      }\n      return LHS.udiv(RHS);\n    case Instruction::SDiv:\n      if (RHS.isNullValue()) {\n        SkipOperation = true;\n        return LHS;\n      }\n      return LHS.sdiv(RHS);\n    case Instruction::URem:\n      if (RHS.isNullValue()) {\n        SkipOperation = true;\n        return LHS;\n      }\n      return LHS.urem(RHS);\n    case Instruction::SRem:\n      if (RHS.isNullValue()) {\n        SkipOperation = true;\n        return LHS;\n      }\n      return LHS.srem(RHS);\n    case Instruction::Shl:\n      return LHS.shl(RHS);\n    case Instruction::LShr:\n      return LHS.lshr(RHS);\n    case Instruction::AShr:\n      return LHS.ashr(RHS);\n    case Instruction::And:\n      return LHS & RHS;\n    case Instruction::Or:\n      return LHS | RHS;\n    case Instruction::Xor:\n      return LHS ^ RHS;\n    }\n  }\n\n  bool calculateBinaryOperatorAndTakeUnion(const BinaryOperator *BinOp,\n                                           const APInt &LHS, const APInt &RHS) {\n    bool SkipOperation = false;\n    bool Unsupported = false;\n    APInt Result =\n        calculateBinaryOperator(BinOp, LHS, RHS, SkipOperation, Unsupported);\n    if (Unsupported)\n      return false;\n    // If SkipOperation is true, we can ignore this operand pair (L, R).\n    if (!SkipOperation)\n      unionAssumed(Result);\n    return isValidState();\n  }\n\n  ChangeStatus updateWithICmpInst(Attributor &A, ICmpInst *ICI) {\n    auto AssumedBefore = getAssumed();\n    Value *LHS = ICI->getOperand(0);\n    Value *RHS = ICI->getOperand(1);\n    if (!LHS->getType()->isIntegerTy() || !RHS->getType()->isIntegerTy())\n      return indicatePessimisticFixpoint();\n\n    auto &LHSAA = A.getAAFor<AAPotentialValues>(*this, IRPosition::value(*LHS),\n                                                DepClassTy::REQUIRED);\n    if (!LHSAA.isValidState())\n      return indicatePessimisticFixpoint();\n\n    auto &RHSAA = A.getAAFor<AAPotentialValues>(*this, IRPosition::value(*RHS),\n                                                DepClassTy::REQUIRED);\n    if (!RHSAA.isValidState())\n      return indicatePessimisticFixpoint();\n\n    const DenseSet<APInt> &LHSAAPVS = LHSAA.getAssumedSet();\n    const DenseSet<APInt> &RHSAAPVS = RHSAA.getAssumedSet();\n\n    // TODO: make use of undef flag to limit potential values aggressively.\n    bool MaybeTrue = false, MaybeFalse = false;\n    const APInt Zero(RHS->getType()->getIntegerBitWidth(), 0);\n    if (LHSAA.undefIsContained() && RHSAA.undefIsContained()) {\n      // The result of any comparison between undefs can be soundly replaced\n      // with undef.\n      unionAssumedWithUndef();\n    } else if (LHSAA.undefIsContained()) {\n      bool MaybeTrue = false, MaybeFalse = false;\n      for (const APInt &R : RHSAAPVS) {\n        bool CmpResult = calculateICmpInst(ICI, Zero, R);\n        MaybeTrue |= CmpResult;\n        MaybeFalse |= !CmpResult;\n        if (MaybeTrue & MaybeFalse)\n          return indicatePessimisticFixpoint();\n      }\n    } else if (RHSAA.undefIsContained()) {\n      for (const APInt &L : LHSAAPVS) {\n        bool CmpResult = calculateICmpInst(ICI, L, Zero);\n        MaybeTrue |= CmpResult;\n        MaybeFalse |= !CmpResult;\n        if (MaybeTrue & MaybeFalse)\n          return indicatePessimisticFixpoint();\n      }\n    } else {\n      for (const APInt &L : LHSAAPVS) {\n        for (const APInt &R : RHSAAPVS) {\n          bool CmpResult = calculateICmpInst(ICI, L, R);\n          MaybeTrue |= CmpResult;\n          MaybeFalse |= !CmpResult;\n          if (MaybeTrue & MaybeFalse)\n            return indicatePessimisticFixpoint();\n        }\n      }\n    }\n    if (MaybeTrue)\n      unionAssumed(APInt(/* numBits */ 1, /* val */ 1));\n    if (MaybeFalse)\n      unionAssumed(APInt(/* numBits */ 1, /* val */ 0));\n    return AssumedBefore == getAssumed() ? ChangeStatus::UNCHANGED\n                                         : ChangeStatus::CHANGED;\n  }\n\n  ChangeStatus updateWithSelectInst(Attributor &A, SelectInst *SI) {\n    auto AssumedBefore = getAssumed();\n    Value *LHS = SI->getTrueValue();\n    Value *RHS = SI->getFalseValue();\n    if (!LHS->getType()->isIntegerTy() || !RHS->getType()->isIntegerTy())\n      return indicatePessimisticFixpoint();\n\n    // TODO: Use assumed simplified condition value\n    auto &LHSAA = A.getAAFor<AAPotentialValues>(*this, IRPosition::value(*LHS),\n                                                DepClassTy::REQUIRED);\n    if (!LHSAA.isValidState())\n      return indicatePessimisticFixpoint();\n\n    auto &RHSAA = A.getAAFor<AAPotentialValues>(*this, IRPosition::value(*RHS),\n                                                DepClassTy::REQUIRED);\n    if (!RHSAA.isValidState())\n      return indicatePessimisticFixpoint();\n\n    if (LHSAA.undefIsContained() && RHSAA.undefIsContained())\n      // select i1 *, undef , undef => undef\n      unionAssumedWithUndef();\n    else {\n      unionAssumed(LHSAA);\n      unionAssumed(RHSAA);\n    }\n    return AssumedBefore == getAssumed() ? ChangeStatus::UNCHANGED\n                                         : ChangeStatus::CHANGED;\n  }\n\n  ChangeStatus updateWithCastInst(Attributor &A, CastInst *CI) {\n    auto AssumedBefore = getAssumed();\n    if (!CI->isIntegerCast())\n      return indicatePessimisticFixpoint();\n    assert(CI->getNumOperands() == 1 && \"Expected cast to be unary!\");\n    uint32_t ResultBitWidth = CI->getDestTy()->getIntegerBitWidth();\n    Value *Src = CI->getOperand(0);\n    auto &SrcAA = A.getAAFor<AAPotentialValues>(*this, IRPosition::value(*Src),\n                                                DepClassTy::REQUIRED);\n    if (!SrcAA.isValidState())\n      return indicatePessimisticFixpoint();\n    const DenseSet<APInt> &SrcAAPVS = SrcAA.getAssumedSet();\n    if (SrcAA.undefIsContained())\n      unionAssumedWithUndef();\n    else {\n      for (const APInt &S : SrcAAPVS) {\n        APInt T = calculateCastInst(CI, S, ResultBitWidth);\n        unionAssumed(T);\n      }\n    }\n    return AssumedBefore == getAssumed() ? ChangeStatus::UNCHANGED\n                                         : ChangeStatus::CHANGED;\n  }\n\n  ChangeStatus updateWithBinaryOperator(Attributor &A, BinaryOperator *BinOp) {\n    auto AssumedBefore = getAssumed();\n    Value *LHS = BinOp->getOperand(0);\n    Value *RHS = BinOp->getOperand(1);\n    if (!LHS->getType()->isIntegerTy() || !RHS->getType()->isIntegerTy())\n      return indicatePessimisticFixpoint();\n\n    auto &LHSAA = A.getAAFor<AAPotentialValues>(*this, IRPosition::value(*LHS),\n                                                DepClassTy::REQUIRED);\n    if (!LHSAA.isValidState())\n      return indicatePessimisticFixpoint();\n\n    auto &RHSAA = A.getAAFor<AAPotentialValues>(*this, IRPosition::value(*RHS),\n                                                DepClassTy::REQUIRED);\n    if (!RHSAA.isValidState())\n      return indicatePessimisticFixpoint();\n\n    const DenseSet<APInt> &LHSAAPVS = LHSAA.getAssumedSet();\n    const DenseSet<APInt> &RHSAAPVS = RHSAA.getAssumedSet();\n    const APInt Zero = APInt(LHS->getType()->getIntegerBitWidth(), 0);\n\n    // TODO: make use of undef flag to limit potential values aggressively.\n    if (LHSAA.undefIsContained() && RHSAA.undefIsContained()) {\n      if (!calculateBinaryOperatorAndTakeUnion(BinOp, Zero, Zero))\n        return indicatePessimisticFixpoint();\n    } else if (LHSAA.undefIsContained()) {\n      for (const APInt &R : RHSAAPVS) {\n        if (!calculateBinaryOperatorAndTakeUnion(BinOp, Zero, R))\n          return indicatePessimisticFixpoint();\n      }\n    } else if (RHSAA.undefIsContained()) {\n      for (const APInt &L : LHSAAPVS) {\n        if (!calculateBinaryOperatorAndTakeUnion(BinOp, L, Zero))\n          return indicatePessimisticFixpoint();\n      }\n    } else {\n      for (const APInt &L : LHSAAPVS) {\n        for (const APInt &R : RHSAAPVS) {\n          if (!calculateBinaryOperatorAndTakeUnion(BinOp, L, R))\n            return indicatePessimisticFixpoint();\n        }\n      }\n    }\n    return AssumedBefore == getAssumed() ? ChangeStatus::UNCHANGED\n                                         : ChangeStatus::CHANGED;\n  }\n\n  ChangeStatus updateWithPHINode(Attributor &A, PHINode *PHI) {\n    auto AssumedBefore = getAssumed();\n    for (unsigned u = 0, e = PHI->getNumIncomingValues(); u < e; u++) {\n      Value *IncomingValue = PHI->getIncomingValue(u);\n      auto &PotentialValuesAA = A.getAAFor<AAPotentialValues>(\n          *this, IRPosition::value(*IncomingValue), DepClassTy::REQUIRED);\n      if (!PotentialValuesAA.isValidState())\n        return indicatePessimisticFixpoint();\n      if (PotentialValuesAA.undefIsContained())\n        unionAssumedWithUndef();\n      else\n        unionAssumed(PotentialValuesAA.getAssumed());\n    }\n    return AssumedBefore == getAssumed() ? ChangeStatus::UNCHANGED\n                                         : ChangeStatus::CHANGED;\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    Value &V = getAssociatedValue();\n    Instruction *I = dyn_cast<Instruction>(&V);\n\n    if (auto *ICI = dyn_cast<ICmpInst>(I))\n      return updateWithICmpInst(A, ICI);\n\n    if (auto *SI = dyn_cast<SelectInst>(I))\n      return updateWithSelectInst(A, SI);\n\n    if (auto *CI = dyn_cast<CastInst>(I))\n      return updateWithCastInst(A, CI);\n\n    if (auto *BinOp = dyn_cast<BinaryOperator>(I))\n      return updateWithBinaryOperator(A, BinOp);\n\n    if (auto *PHI = dyn_cast<PHINode>(I))\n      return updateWithPHINode(A, PHI);\n\n    return indicatePessimisticFixpoint();\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    STATS_DECLTRACK_FLOATING_ATTR(potential_values)\n  }\n};\n\nstruct AAPotentialValuesFunction : AAPotentialValuesImpl {\n  AAPotentialValuesFunction(const IRPosition &IRP, Attributor &A)\n      : AAPotentialValuesImpl(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    llvm_unreachable(\"AAPotentialValues(Function|CallSite)::updateImpl will \"\n                     \"not be called\");\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    STATS_DECLTRACK_FN_ATTR(potential_values)\n  }\n};\n\nstruct AAPotentialValuesCallSite : AAPotentialValuesFunction {\n  AAPotentialValuesCallSite(const IRPosition &IRP, Attributor &A)\n      : AAPotentialValuesFunction(IRP, A) {}\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    STATS_DECLTRACK_CS_ATTR(potential_values)\n  }\n};\n\nstruct AAPotentialValuesCallSiteReturned\n    : AACallSiteReturnedFromReturned<AAPotentialValues, AAPotentialValuesImpl> {\n  AAPotentialValuesCallSiteReturned(const IRPosition &IRP, Attributor &A)\n      : AACallSiteReturnedFromReturned<AAPotentialValues,\n                                       AAPotentialValuesImpl>(IRP, A) {}\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    STATS_DECLTRACK_CSRET_ATTR(potential_values)\n  }\n};\n\nstruct AAPotentialValuesCallSiteArgument : AAPotentialValuesFloating {\n  AAPotentialValuesCallSiteArgument(const IRPosition &IRP, Attributor &A)\n      : AAPotentialValuesFloating(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(..).\n  void initialize(Attributor &A) override {\n    Value &V = getAssociatedValue();\n\n    if (auto *C = dyn_cast<ConstantInt>(&V)) {\n      unionAssumed(C->getValue());\n      indicateOptimisticFixpoint();\n      return;\n    }\n\n    if (isa<UndefValue>(&V)) {\n      unionAssumedWithUndef();\n      indicateOptimisticFixpoint();\n      return;\n    }\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    Value &V = getAssociatedValue();\n    auto AssumedBefore = getAssumed();\n    auto &AA = A.getAAFor<AAPotentialValues>(*this, IRPosition::value(V),\n                                             DepClassTy::REQUIRED);\n    const auto &S = AA.getAssumed();\n    unionAssumed(S);\n    return AssumedBefore == getAssumed() ? ChangeStatus::UNCHANGED\n                                         : ChangeStatus::CHANGED;\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override {\n    STATS_DECLTRACK_CSARG_ATTR(potential_values)\n  }\n};\n\n/// ------------------------ NoUndef Attribute ---------------------------------\nstruct AANoUndefImpl : AANoUndef {\n  AANoUndefImpl(const IRPosition &IRP, Attributor &A) : AANoUndef(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    if (getIRPosition().hasAttr({Attribute::NoUndef})) {\n      indicateOptimisticFixpoint();\n      return;\n    }\n    Value &V = getAssociatedValue();\n    if (isa<UndefValue>(V))\n      indicatePessimisticFixpoint();\n    else if (isa<FreezeInst>(V))\n      indicateOptimisticFixpoint();\n    else if (getPositionKind() != IRPosition::IRP_RETURNED &&\n             isGuaranteedNotToBeUndefOrPoison(&V))\n      indicateOptimisticFixpoint();\n    else\n      AANoUndef::initialize(A);\n  }\n\n  /// See followUsesInMBEC\n  bool followUseInMBEC(Attributor &A, const Use *U, const Instruction *I,\n                       AANoUndef::StateType &State) {\n    const Value *UseV = U->get();\n    const DominatorTree *DT = nullptr;\n    AssumptionCache *AC = nullptr;\n    InformationCache &InfoCache = A.getInfoCache();\n    if (Function *F = getAnchorScope()) {\n      DT = InfoCache.getAnalysisResultForFunction<DominatorTreeAnalysis>(*F);\n      AC = InfoCache.getAnalysisResultForFunction<AssumptionAnalysis>(*F);\n    }\n    State.setKnown(isGuaranteedNotToBeUndefOrPoison(UseV, AC, I, DT));\n    bool TrackUse = false;\n    // Track use for instructions which must produce undef or poison bits when\n    // at least one operand contains such bits.\n    if (isa<CastInst>(*I) || isa<GetElementPtrInst>(*I))\n      TrackUse = true;\n    return TrackUse;\n  }\n\n  /// See AbstractAttribute::getAsStr().\n  const std::string getAsStr() const override {\n    return getAssumed() ? \"noundef\" : \"may-undef-or-poison\";\n  }\n\n  ChangeStatus manifest(Attributor &A) override {\n    // We don't manifest noundef attribute for dead positions because the\n    // associated values with dead positions would be replaced with undef\n    // values.\n    if (A.isAssumedDead(getIRPosition(), nullptr, nullptr))\n      return ChangeStatus::UNCHANGED;\n    // A position whose simplified value does not have any value is\n    // considered to be dead. We don't manifest noundef in such positions for\n    // the same reason above.\n    auto &ValueSimplifyAA =\n        A.getAAFor<AAValueSimplify>(*this, getIRPosition(), DepClassTy::NONE);\n    if (!ValueSimplifyAA.getAssumedSimplifiedValue(A).hasValue())\n      return ChangeStatus::UNCHANGED;\n    return AANoUndef::manifest(A);\n  }\n};\n\nstruct AANoUndefFloating : public AANoUndefImpl {\n  AANoUndefFloating(const IRPosition &IRP, Attributor &A)\n      : AANoUndefImpl(IRP, A) {}\n\n  /// See AbstractAttribute::initialize(...).\n  void initialize(Attributor &A) override {\n    AANoUndefImpl::initialize(A);\n    if (!getState().isAtFixpoint())\n      if (Instruction *CtxI = getCtxI())\n        followUsesInMBEC(*this, A, getState(), *CtxI);\n  }\n\n  /// See AbstractAttribute::updateImpl(...).\n  ChangeStatus updateImpl(Attributor &A) override {\n    auto VisitValueCB = [&](Value &V, const Instruction *CtxI,\n                            AANoUndef::StateType &T, bool Stripped) -> bool {\n      const auto &AA = A.getAAFor<AANoUndef>(*this, IRPosition::value(V),\n                                             DepClassTy::REQUIRED);\n      if (!Stripped && this == &AA) {\n        T.indicatePessimisticFixpoint();\n      } else {\n        const AANoUndef::StateType &S =\n            static_cast<const AANoUndef::StateType &>(AA.getState());\n        T ^= S;\n      }\n      return T.isValidState();\n    };\n\n    StateType T;\n    if (!genericValueTraversal<AANoUndef, StateType>(\n            A, getIRPosition(), *this, T, VisitValueCB, getCtxI()))\n      return indicatePessimisticFixpoint();\n\n    return clampStateAndIndicateChange(getState(), T);\n  }\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_FNRET_ATTR(noundef) }\n};\n\nstruct AANoUndefReturned final\n    : AAReturnedFromReturnedValues<AANoUndef, AANoUndefImpl> {\n  AANoUndefReturned(const IRPosition &IRP, Attributor &A)\n      : AAReturnedFromReturnedValues<AANoUndef, AANoUndefImpl>(IRP, A) {}\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_FNRET_ATTR(noundef) }\n};\n\nstruct AANoUndefArgument final\n    : AAArgumentFromCallSiteArguments<AANoUndef, AANoUndefImpl> {\n  AANoUndefArgument(const IRPosition &IRP, Attributor &A)\n      : AAArgumentFromCallSiteArguments<AANoUndef, AANoUndefImpl>(IRP, A) {}\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_ARG_ATTR(noundef) }\n};\n\nstruct AANoUndefCallSiteArgument final : AANoUndefFloating {\n  AANoUndefCallSiteArgument(const IRPosition &IRP, Attributor &A)\n      : AANoUndefFloating(IRP, A) {}\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_CSARG_ATTR(noundef) }\n};\n\nstruct AANoUndefCallSiteReturned final\n    : AACallSiteReturnedFromReturned<AANoUndef, AANoUndefImpl> {\n  AANoUndefCallSiteReturned(const IRPosition &IRP, Attributor &A)\n      : AACallSiteReturnedFromReturned<AANoUndef, AANoUndefImpl>(IRP, A) {}\n\n  /// See AbstractAttribute::trackStatistics()\n  void trackStatistics() const override { STATS_DECLTRACK_CSRET_ATTR(noundef) }\n};\n} // namespace\n\nconst char AAReturnedValues::ID = 0;\nconst char AANoUnwind::ID = 0;\nconst char AANoSync::ID = 0;\nconst char AANoFree::ID = 0;\nconst char AANonNull::ID = 0;\nconst char AANoRecurse::ID = 0;\nconst char AAWillReturn::ID = 0;\nconst char AAUndefinedBehavior::ID = 0;\nconst char AANoAlias::ID = 0;\nconst char AAReachability::ID = 0;\nconst char AANoReturn::ID = 0;\nconst char AAIsDead::ID = 0;\nconst char AADereferenceable::ID = 0;\nconst char AAAlign::ID = 0;\nconst char AANoCapture::ID = 0;\nconst char AAValueSimplify::ID = 0;\nconst char AAHeapToStack::ID = 0;\nconst char AAPrivatizablePtr::ID = 0;\nconst char AAMemoryBehavior::ID = 0;\nconst char AAMemoryLocation::ID = 0;\nconst char AAValueConstantRange::ID = 0;\nconst char AAPotentialValues::ID = 0;\nconst char AANoUndef::ID = 0;\n\n// Macro magic to create the static generator function for attributes that\n// follow the naming scheme.\n\n#define SWITCH_PK_INV(CLASS, PK, POS_NAME)                                     \\\n  case IRPosition::PK:                                                         \\\n    llvm_unreachable(\"Cannot create \" #CLASS \" for a \" POS_NAME \" position!\");\n\n#define SWITCH_PK_CREATE(CLASS, IRP, PK, SUFFIX)                               \\\n  case IRPosition::PK:                                                         \\\n    AA = new (A.Allocator) CLASS##SUFFIX(IRP, A);                              \\\n    ++NumAAs;                                                                  \\\n    break;\n\n#define CREATE_FUNCTION_ABSTRACT_ATTRIBUTE_FOR_POSITION(CLASS)                 \\\n  CLASS &CLASS::createForPosition(const IRPosition &IRP, Attributor &A) {      \\\n    CLASS *AA = nullptr;                                                       \\\n    switch (IRP.getPositionKind()) {                                           \\\n      SWITCH_PK_INV(CLASS, IRP_INVALID, \"invalid\")                             \\\n      SWITCH_PK_INV(CLASS, IRP_FLOAT, \"floating\")                              \\\n      SWITCH_PK_INV(CLASS, IRP_ARGUMENT, \"argument\")                           \\\n      SWITCH_PK_INV(CLASS, IRP_RETURNED, \"returned\")                           \\\n      SWITCH_PK_INV(CLASS, IRP_CALL_SITE_RETURNED, \"call site returned\")       \\\n      SWITCH_PK_INV(CLASS, IRP_CALL_SITE_ARGUMENT, \"call site argument\")       \\\n      SWITCH_PK_CREATE(CLASS, IRP, IRP_FUNCTION, Function)                     \\\n      SWITCH_PK_CREATE(CLASS, IRP, IRP_CALL_SITE, CallSite)                    \\\n    }                                                                          \\\n    return *AA;                                                                \\\n  }\n\n#define CREATE_VALUE_ABSTRACT_ATTRIBUTE_FOR_POSITION(CLASS)                    \\\n  CLASS &CLASS::createForPosition(const IRPosition &IRP, Attributor &A) {      \\\n    CLASS *AA = nullptr;                                                       \\\n    switch (IRP.getPositionKind()) {                                           \\\n      SWITCH_PK_INV(CLASS, IRP_INVALID, \"invalid\")                             \\\n      SWITCH_PK_INV(CLASS, IRP_FUNCTION, \"function\")                           \\\n      SWITCH_PK_INV(CLASS, IRP_CALL_SITE, \"call site\")                         \\\n      SWITCH_PK_CREATE(CLASS, IRP, IRP_FLOAT, Floating)                        \\\n      SWITCH_PK_CREATE(CLASS, IRP, IRP_ARGUMENT, Argument)                     \\\n      SWITCH_PK_CREATE(CLASS, IRP, IRP_RETURNED, Returned)                     \\\n      SWITCH_PK_CREATE(CLASS, IRP, IRP_CALL_SITE_RETURNED, CallSiteReturned)   \\\n      SWITCH_PK_CREATE(CLASS, IRP, IRP_CALL_SITE_ARGUMENT, CallSiteArgument)   \\\n    }                                                                          \\\n    return *AA;                                                                \\\n  }\n\n#define CREATE_ALL_ABSTRACT_ATTRIBUTE_FOR_POSITION(CLASS)                      \\\n  CLASS &CLASS::createForPosition(const IRPosition &IRP, Attributor &A) {      \\\n    CLASS *AA = nullptr;                                                       \\\n    switch (IRP.getPositionKind()) {                                           \\\n      SWITCH_PK_INV(CLASS, IRP_INVALID, \"invalid\")                             \\\n      SWITCH_PK_CREATE(CLASS, IRP, IRP_FUNCTION, Function)                     \\\n      SWITCH_PK_CREATE(CLASS, IRP, IRP_CALL_SITE, CallSite)                    \\\n      SWITCH_PK_CREATE(CLASS, IRP, IRP_FLOAT, Floating)                        \\\n      SWITCH_PK_CREATE(CLASS, IRP, IRP_ARGUMENT, Argument)                     \\\n      SWITCH_PK_CREATE(CLASS, IRP, IRP_RETURNED, Returned)                     \\\n      SWITCH_PK_CREATE(CLASS, IRP, IRP_CALL_SITE_RETURNED, CallSiteReturned)   \\\n      SWITCH_PK_CREATE(CLASS, IRP, IRP_CALL_SITE_ARGUMENT, CallSiteArgument)   \\\n    }                                                                          \\\n    return *AA;                                                                \\\n  }\n\n#define CREATE_FUNCTION_ONLY_ABSTRACT_ATTRIBUTE_FOR_POSITION(CLASS)            \\\n  CLASS &CLASS::createForPosition(const IRPosition &IRP, Attributor &A) {      \\\n    CLASS *AA = nullptr;                                                       \\\n    switch (IRP.getPositionKind()) {                                           \\\n      SWITCH_PK_INV(CLASS, IRP_INVALID, \"invalid\")                             \\\n      SWITCH_PK_INV(CLASS, IRP_ARGUMENT, \"argument\")                           \\\n      SWITCH_PK_INV(CLASS, IRP_FLOAT, \"floating\")                              \\\n      SWITCH_PK_INV(CLASS, IRP_RETURNED, \"returned\")                           \\\n      SWITCH_PK_INV(CLASS, IRP_CALL_SITE_RETURNED, \"call site returned\")       \\\n      SWITCH_PK_INV(CLASS, IRP_CALL_SITE_ARGUMENT, \"call site argument\")       \\\n      SWITCH_PK_INV(CLASS, IRP_CALL_SITE, \"call site\")                         \\\n      SWITCH_PK_CREATE(CLASS, IRP, IRP_FUNCTION, Function)                     \\\n    }                                                                          \\\n    return *AA;                                                                \\\n  }\n\n#define CREATE_NON_RET_ABSTRACT_ATTRIBUTE_FOR_POSITION(CLASS)                  \\\n  CLASS &CLASS::createForPosition(const IRPosition &IRP, Attributor &A) {      \\\n    CLASS *AA = nullptr;                                                       \\\n    switch (IRP.getPositionKind()) {                                           \\\n      SWITCH_PK_INV(CLASS, IRP_INVALID, \"invalid\")                             \\\n      SWITCH_PK_INV(CLASS, IRP_RETURNED, \"returned\")                           \\\n      SWITCH_PK_CREATE(CLASS, IRP, IRP_FUNCTION, Function)                     \\\n      SWITCH_PK_CREATE(CLASS, IRP, IRP_CALL_SITE, CallSite)                    \\\n      SWITCH_PK_CREATE(CLASS, IRP, IRP_FLOAT, Floating)                        \\\n      SWITCH_PK_CREATE(CLASS, IRP, IRP_ARGUMENT, Argument)                     \\\n      SWITCH_PK_CREATE(CLASS, IRP, IRP_CALL_SITE_RETURNED, CallSiteReturned)   \\\n      SWITCH_PK_CREATE(CLASS, IRP, IRP_CALL_SITE_ARGUMENT, CallSiteArgument)   \\\n    }                                                                          \\\n    return *AA;                                                                \\\n  }\n\nCREATE_FUNCTION_ABSTRACT_ATTRIBUTE_FOR_POSITION(AANoUnwind)\nCREATE_FUNCTION_ABSTRACT_ATTRIBUTE_FOR_POSITION(AANoSync)\nCREATE_FUNCTION_ABSTRACT_ATTRIBUTE_FOR_POSITION(AANoRecurse)\nCREATE_FUNCTION_ABSTRACT_ATTRIBUTE_FOR_POSITION(AAWillReturn)\nCREATE_FUNCTION_ABSTRACT_ATTRIBUTE_FOR_POSITION(AANoReturn)\nCREATE_FUNCTION_ABSTRACT_ATTRIBUTE_FOR_POSITION(AAReturnedValues)\nCREATE_FUNCTION_ABSTRACT_ATTRIBUTE_FOR_POSITION(AAMemoryLocation)\n\nCREATE_VALUE_ABSTRACT_ATTRIBUTE_FOR_POSITION(AANonNull)\nCREATE_VALUE_ABSTRACT_ATTRIBUTE_FOR_POSITION(AANoAlias)\nCREATE_VALUE_ABSTRACT_ATTRIBUTE_FOR_POSITION(AAPrivatizablePtr)\nCREATE_VALUE_ABSTRACT_ATTRIBUTE_FOR_POSITION(AADereferenceable)\nCREATE_VALUE_ABSTRACT_ATTRIBUTE_FOR_POSITION(AAAlign)\nCREATE_VALUE_ABSTRACT_ATTRIBUTE_FOR_POSITION(AANoCapture)\nCREATE_VALUE_ABSTRACT_ATTRIBUTE_FOR_POSITION(AAValueConstantRange)\nCREATE_VALUE_ABSTRACT_ATTRIBUTE_FOR_POSITION(AAPotentialValues)\nCREATE_VALUE_ABSTRACT_ATTRIBUTE_FOR_POSITION(AANoUndef)\n\nCREATE_ALL_ABSTRACT_ATTRIBUTE_FOR_POSITION(AAValueSimplify)\nCREATE_ALL_ABSTRACT_ATTRIBUTE_FOR_POSITION(AAIsDead)\nCREATE_ALL_ABSTRACT_ATTRIBUTE_FOR_POSITION(AANoFree)\n\nCREATE_FUNCTION_ONLY_ABSTRACT_ATTRIBUTE_FOR_POSITION(AAHeapToStack)\nCREATE_FUNCTION_ONLY_ABSTRACT_ATTRIBUTE_FOR_POSITION(AAReachability)\nCREATE_FUNCTION_ONLY_ABSTRACT_ATTRIBUTE_FOR_POSITION(AAUndefinedBehavior)\n\nCREATE_NON_RET_ABSTRACT_ATTRIBUTE_FOR_POSITION(AAMemoryBehavior)\n\n#undef CREATE_FUNCTION_ONLY_ABSTRACT_ATTRIBUTE_FOR_POSITION\n#undef CREATE_FUNCTION_ABSTRACT_ATTRIBUTE_FOR_POSITION\n#undef CREATE_NON_RET_ABSTRACT_ATTRIBUTE_FOR_POSITION\n#undef CREATE_VALUE_ABSTRACT_ATTRIBUTE_FOR_POSITION\n#undef CREATE_ALL_ABSTRACT_ATTRIBUTE_FOR_POSITION\n#undef SWITCH_PK_CREATE\n#undef SWITCH_PK_INV\n"}}, "reports": [{"events": [{"location": {"col": 10, "file": 62, "line": 6664}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp", "reportHash": "532b5f40c1dbb929c1bb66eb7ae6a816", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
