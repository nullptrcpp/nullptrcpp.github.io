<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"27": {"id": 27, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h", "content": "//===- llvm/CodeGen/GlobalISel/LegalizerInfo.h ------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// Interface for Targets to specify which operations they can successfully\n/// select and how the others should be expanded most efficiently.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_GLOBALISEL_LEGALIZERINFO_H\n#define LLVM_CODEGEN_GLOBALISEL_LEGALIZERINFO_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallBitVector.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/CodeGen/MachineFunction.h\"\n#include \"llvm/CodeGen/TargetOpcodes.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Support/LowLevelTypeImpl.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cassert>\n#include <cstdint>\n#include <tuple>\n#include <unordered_map>\n#include <utility>\n\nnamespace llvm {\n\nextern cl::opt<bool> DisableGISelLegalityCheck;\n\nclass LegalizerHelper;\nclass MachineInstr;\nclass MachineRegisterInfo;\nclass MCInstrInfo;\nclass GISelChangeObserver;\n\nnamespace LegalizeActions {\nenum LegalizeAction : std::uint8_t {\n  /// The operation is expected to be selectable directly by the target, and\n  /// no transformation is necessary.\n  Legal,\n\n  /// The operation should be synthesized from multiple instructions acting on\n  /// a narrower scalar base-type. For example a 64-bit add might be\n  /// implemented in terms of 32-bit add-with-carry.\n  NarrowScalar,\n\n  /// The operation should be implemented in terms of a wider scalar\n  /// base-type. For example a <2 x s8> add could be implemented as a <2\n  /// x s32> add (ignoring the high bits).\n  WidenScalar,\n\n  /// The (vector) operation should be implemented by splitting it into\n  /// sub-vectors where the operation is legal. For example a <8 x s64> add\n  /// might be implemented as 4 separate <2 x s64> adds.\n  FewerElements,\n\n  /// The (vector) operation should be implemented by widening the input\n  /// vector and ignoring the lanes added by doing so. For example <2 x i8> is\n  /// rarely legal, but you might perform an <8 x i8> and then only look at\n  /// the first two results.\n  MoreElements,\n\n  /// Perform the operation on a different, but equivalently sized type.\n  Bitcast,\n\n  /// The operation itself must be expressed in terms of simpler actions on\n  /// this target. E.g. a SREM replaced by an SDIV and subtraction.\n  Lower,\n\n  /// The operation should be implemented as a call to some kind of runtime\n  /// support library. For example this usually happens on machines that don't\n  /// support floating-point operations natively.\n  Libcall,\n\n  /// The target wants to do something special with this combination of\n  /// operand and type. A callback will be issued when it is needed.\n  Custom,\n\n  /// This operation is completely unsupported on the target. A programming\n  /// error has occurred.\n  Unsupported,\n\n  /// Sentinel value for when no action was found in the specified table.\n  NotFound,\n\n  /// Fall back onto the old rules.\n  /// TODO: Remove this once we've migrated\n  UseLegacyRules,\n};\n} // end namespace LegalizeActions\nraw_ostream &operator<<(raw_ostream &OS, LegalizeActions::LegalizeAction Action);\n\nusing LegalizeActions::LegalizeAction;\n\n/// Legalization is decided based on an instruction's opcode, which type slot\n/// we're considering, and what the existing type is. These aspects are gathered\n/// together for convenience in the InstrAspect class.\nstruct InstrAspect {\n  unsigned Opcode;\n  unsigned Idx = 0;\n  LLT Type;\n\n  InstrAspect(unsigned Opcode, LLT Type) : Opcode(Opcode), Type(Type) {}\n  InstrAspect(unsigned Opcode, unsigned Idx, LLT Type)\n      : Opcode(Opcode), Idx(Idx), Type(Type) {}\n\n  bool operator==(const InstrAspect &RHS) const {\n    return Opcode == RHS.Opcode && Idx == RHS.Idx && Type == RHS.Type;\n  }\n};\n\n/// The LegalityQuery object bundles together all the information that's needed\n/// to decide whether a given operation is legal or not.\n/// For efficiency, it doesn't make a copy of Types so care must be taken not\n/// to free it before using the query.\nstruct LegalityQuery {\n  unsigned Opcode;\n  ArrayRef<LLT> Types;\n\n  struct MemDesc {\n    uint64_t SizeInBits;\n    uint64_t AlignInBits;\n    AtomicOrdering Ordering;\n  };\n\n  /// Operations which require memory can use this to place requirements on the\n  /// memory type for each MMO.\n  ArrayRef<MemDesc> MMODescrs;\n\n  constexpr LegalityQuery(unsigned Opcode, const ArrayRef<LLT> Types,\n                          const ArrayRef<MemDesc> MMODescrs)\n      : Opcode(Opcode), Types(Types), MMODescrs(MMODescrs) {}\n  constexpr LegalityQuery(unsigned Opcode, const ArrayRef<LLT> Types)\n      : LegalityQuery(Opcode, Types, {}) {}\n\n  raw_ostream &print(raw_ostream &OS) const;\n};\n\n/// The result of a query. It either indicates a final answer of Legal or\n/// Unsupported or describes an action that must be taken to make an operation\n/// more legal.\nstruct LegalizeActionStep {\n  /// The action to take or the final answer.\n  LegalizeAction Action;\n  /// If describing an action, the type index to change. Otherwise zero.\n  unsigned TypeIdx;\n  /// If describing an action, the new type for TypeIdx. Otherwise LLT{}.\n  LLT NewType;\n\n  LegalizeActionStep(LegalizeAction Action, unsigned TypeIdx,\n                     const LLT NewType)\n      : Action(Action), TypeIdx(TypeIdx), NewType(NewType) {}\n\n  bool operator==(const LegalizeActionStep &RHS) const {\n    return std::tie(Action, TypeIdx, NewType) ==\n        std::tie(RHS.Action, RHS.TypeIdx, RHS.NewType);\n  }\n};\n\nusing LegalityPredicate = std::function<bool (const LegalityQuery &)>;\nusing LegalizeMutation =\n    std::function<std::pair<unsigned, LLT>(const LegalityQuery &)>;\n\nnamespace LegalityPredicates {\nstruct TypePairAndMemDesc {\n  LLT Type0;\n  LLT Type1;\n  uint64_t MemSize;\n  uint64_t Align;\n\n  bool operator==(const TypePairAndMemDesc &Other) const {\n    return Type0 == Other.Type0 && Type1 == Other.Type1 &&\n           Align == Other.Align &&\n           MemSize == Other.MemSize;\n  }\n\n  /// \\returns true if this memory access is legal with for the access described\n  /// by \\p Other (The alignment is sufficient for the size and result type).\n  bool isCompatible(const TypePairAndMemDesc &Other) const {\n    return Type0 == Other.Type0 && Type1 == Other.Type1 &&\n           Align >= Other.Align &&\n           MemSize == Other.MemSize;\n  }\n};\n\n/// True iff P0 and P1 are true.\ntemplate<typename Predicate>\nPredicate all(Predicate P0, Predicate P1) {\n  return [=](const LegalityQuery &Query) {\n    return P0(Query) && P1(Query);\n  };\n}\n/// True iff all given predicates are true.\ntemplate<typename Predicate, typename... Args>\nPredicate all(Predicate P0, Predicate P1, Args... args) {\n  return all(all(P0, P1), args...);\n}\n\n/// True iff P0 or P1 are true.\ntemplate<typename Predicate>\nPredicate any(Predicate P0, Predicate P1) {\n  return [=](const LegalityQuery &Query) {\n    return P0(Query) || P1(Query);\n  };\n}\n/// True iff any given predicates are true.\ntemplate<typename Predicate, typename... Args>\nPredicate any(Predicate P0, Predicate P1, Args... args) {\n  return any(any(P0, P1), args...);\n}\n\n/// True iff the given type index is the specified type.\nLegalityPredicate typeIs(unsigned TypeIdx, LLT TypesInit);\n/// True iff the given type index is one of the specified types.\nLegalityPredicate typeInSet(unsigned TypeIdx,\n                            std::initializer_list<LLT> TypesInit);\n\n/// True iff the given type index is not the specified type.\ninline LegalityPredicate typeIsNot(unsigned TypeIdx, LLT Type) {\n  return [=](const LegalityQuery &Query) {\n           return Query.Types[TypeIdx] != Type;\n         };\n}\n\n/// True iff the given types for the given pair of type indexes is one of the\n/// specified type pairs.\nLegalityPredicate\ntypePairInSet(unsigned TypeIdx0, unsigned TypeIdx1,\n              std::initializer_list<std::pair<LLT, LLT>> TypesInit);\n/// True iff the given types for the given pair of type indexes is one of the\n/// specified type pairs.\nLegalityPredicate typePairAndMemDescInSet(\n    unsigned TypeIdx0, unsigned TypeIdx1, unsigned MMOIdx,\n    std::initializer_list<TypePairAndMemDesc> TypesAndMemDescInit);\n/// True iff the specified type index is a scalar.\nLegalityPredicate isScalar(unsigned TypeIdx);\n/// True iff the specified type index is a vector.\nLegalityPredicate isVector(unsigned TypeIdx);\n/// True iff the specified type index is a pointer (with any address space).\nLegalityPredicate isPointer(unsigned TypeIdx);\n/// True iff the specified type index is a pointer with the specified address\n/// space.\nLegalityPredicate isPointer(unsigned TypeIdx, unsigned AddrSpace);\n\n/// True if the type index is a vector with element type \\p EltTy\nLegalityPredicate elementTypeIs(unsigned TypeIdx, LLT EltTy);\n\n/// True iff the specified type index is a scalar that's narrower than the given\n/// size.\nLegalityPredicate scalarNarrowerThan(unsigned TypeIdx, unsigned Size);\n\n/// True iff the specified type index is a scalar that's wider than the given\n/// size.\nLegalityPredicate scalarWiderThan(unsigned TypeIdx, unsigned Size);\n\n/// True iff the specified type index is a scalar or vector with an element type\n/// that's narrower than the given size.\nLegalityPredicate scalarOrEltNarrowerThan(unsigned TypeIdx, unsigned Size);\n\n/// True iff the specified type index is a scalar or a vector with an element\n/// type that's wider than the given size.\nLegalityPredicate scalarOrEltWiderThan(unsigned TypeIdx, unsigned Size);\n\n/// True iff the specified type index is a scalar whose size is not a power of\n/// 2.\nLegalityPredicate sizeNotPow2(unsigned TypeIdx);\n\n/// True iff the specified type index is a scalar or vector whose element size\n/// is not a power of 2.\nLegalityPredicate scalarOrEltSizeNotPow2(unsigned TypeIdx);\n\n/// True if the total bitwidth of the specified type index is \\p Size bits.\nLegalityPredicate sizeIs(unsigned TypeIdx, unsigned Size);\n\n/// True iff the specified type indices are both the same bit size.\nLegalityPredicate sameSize(unsigned TypeIdx0, unsigned TypeIdx1);\n\n/// True iff the first type index has a larger total bit size than second type\n/// index.\nLegalityPredicate largerThan(unsigned TypeIdx0, unsigned TypeIdx1);\n\n/// True iff the first type index has a smaller total bit size than second type\n/// index.\nLegalityPredicate smallerThan(unsigned TypeIdx0, unsigned TypeIdx1);\n\n/// True iff the specified MMO index has a size that is not a power of 2\nLegalityPredicate memSizeInBytesNotPow2(unsigned MMOIdx);\n/// True iff the specified type index is a vector whose element count is not a\n/// power of 2.\nLegalityPredicate numElementsNotPow2(unsigned TypeIdx);\n/// True iff the specified MMO index has at an atomic ordering of at Ordering or\n/// stronger.\nLegalityPredicate atomicOrderingAtLeastOrStrongerThan(unsigned MMOIdx,\n                                                      AtomicOrdering Ordering);\n} // end namespace LegalityPredicates\n\nnamespace LegalizeMutations {\n/// Select this specific type for the given type index.\nLegalizeMutation changeTo(unsigned TypeIdx, LLT Ty);\n\n/// Keep the same type as the given type index.\nLegalizeMutation changeTo(unsigned TypeIdx, unsigned FromTypeIdx);\n\n/// Keep the same scalar or element type as the given type index.\nLegalizeMutation changeElementTo(unsigned TypeIdx, unsigned FromTypeIdx);\n\n/// Keep the same scalar or element type as the given type.\nLegalizeMutation changeElementTo(unsigned TypeIdx, LLT Ty);\n\n/// Change the scalar size or element size to have the same scalar size as type\n/// index \\p FromIndex. Unlike changeElementTo, this discards pointer types and\n/// only changes the size.\nLegalizeMutation changeElementSizeTo(unsigned TypeIdx, unsigned FromTypeIdx);\n\n/// Widen the scalar type or vector element type for the given type index to the\n/// next power of 2.\nLegalizeMutation widenScalarOrEltToNextPow2(unsigned TypeIdx, unsigned Min = 0);\n\n/// Add more elements to the type for the given type index to the next power of\n/// 2.\nLegalizeMutation moreElementsToNextPow2(unsigned TypeIdx, unsigned Min = 0);\n/// Break up the vector type for the given type index into the element type.\nLegalizeMutation scalarize(unsigned TypeIdx);\n} // end namespace LegalizeMutations\n\n/// A single rule in a legalizer info ruleset.\n/// The specified action is chosen when the predicate is true. Where appropriate\n/// for the action (e.g. for WidenScalar) the new type is selected using the\n/// given mutator.\nclass LegalizeRule {\n  LegalityPredicate Predicate;\n  LegalizeAction Action;\n  LegalizeMutation Mutation;\n\npublic:\n  LegalizeRule(LegalityPredicate Predicate, LegalizeAction Action,\n               LegalizeMutation Mutation = nullptr)\n      : Predicate(Predicate), Action(Action), Mutation(Mutation) {}\n\n  /// Test whether the LegalityQuery matches.\n  bool match(const LegalityQuery &Query) const {\n    return Predicate(Query);\n  }\n\n  LegalizeAction getAction() const { return Action; }\n\n  /// Determine the change to make.\n  std::pair<unsigned, LLT> determineMutation(const LegalityQuery &Query) const {\n    if (Mutation)\n      return Mutation(Query);\n    return std::make_pair(0, LLT{});\n  }\n};\n\nclass LegalizeRuleSet {\n  /// When non-zero, the opcode we are an alias of\n  unsigned AliasOf;\n  /// If true, there is another opcode that aliases this one\n  bool IsAliasedByAnother;\n  SmallVector<LegalizeRule, 2> Rules;\n\n#ifndef NDEBUG\n  /// If bit I is set, this rule set contains a rule that may handle (predicate\n  /// or perform an action upon (or both)) the type index I. The uncertainty\n  /// comes from free-form rules executing user-provided lambda functions. We\n  /// conservatively assume such rules do the right thing and cover all type\n  /// indices. The bitset is intentionally 1 bit wider than it absolutely needs\n  /// to be to distinguish such cases from the cases where all type indices are\n  /// individually handled.\n  SmallBitVector TypeIdxsCovered{MCOI::OPERAND_LAST_GENERIC -\n                                 MCOI::OPERAND_FIRST_GENERIC + 2};\n  SmallBitVector ImmIdxsCovered{MCOI::OPERAND_LAST_GENERIC_IMM -\n                                MCOI::OPERAND_FIRST_GENERIC_IMM + 2};\n#endif\n\n  unsigned typeIdx(unsigned TypeIdx) {\n    assert(TypeIdx <=\n               (MCOI::OPERAND_LAST_GENERIC - MCOI::OPERAND_FIRST_GENERIC) &&\n           \"Type Index is out of bounds\");\n#ifndef NDEBUG\n    TypeIdxsCovered.set(TypeIdx);\n#endif\n    return TypeIdx;\n  }\n\n  unsigned immIdx(unsigned ImmIdx) {\n    assert(ImmIdx <= (MCOI::OPERAND_LAST_GENERIC_IMM -\n                      MCOI::OPERAND_FIRST_GENERIC_IMM) &&\n           \"Imm Index is out of bounds\");\n#ifndef NDEBUG\n    ImmIdxsCovered.set(ImmIdx);\n#endif\n    return ImmIdx;\n  }\n\n  void markAllIdxsAsCovered() {\n#ifndef NDEBUG\n    TypeIdxsCovered.set();\n    ImmIdxsCovered.set();\n#endif\n  }\n\n  void add(const LegalizeRule &Rule) {\n    assert(AliasOf == 0 &&\n           \"RuleSet is aliased, change the representative opcode instead\");\n    Rules.push_back(Rule);\n  }\n\n  static bool always(const LegalityQuery &) { return true; }\n\n  /// Use the given action when the predicate is true.\n  /// Action should not be an action that requires mutation.\n  LegalizeRuleSet &actionIf(LegalizeAction Action,\n                            LegalityPredicate Predicate) {\n    add({Predicate, Action});\n    return *this;\n  }\n  /// Use the given action when the predicate is true.\n  /// Action should be an action that requires mutation.\n  LegalizeRuleSet &actionIf(LegalizeAction Action, LegalityPredicate Predicate,\n                            LegalizeMutation Mutation) {\n    add({Predicate, Action, Mutation});\n    return *this;\n  }\n  /// Use the given action when type index 0 is any type in the given list.\n  /// Action should not be an action that requires mutation.\n  LegalizeRuleSet &actionFor(LegalizeAction Action,\n                             std::initializer_list<LLT> Types) {\n    using namespace LegalityPredicates;\n    return actionIf(Action, typeInSet(typeIdx(0), Types));\n  }\n  /// Use the given action when type index 0 is any type in the given list.\n  /// Action should be an action that requires mutation.\n  LegalizeRuleSet &actionFor(LegalizeAction Action,\n                             std::initializer_list<LLT> Types,\n                             LegalizeMutation Mutation) {\n    using namespace LegalityPredicates;\n    return actionIf(Action, typeInSet(typeIdx(0), Types), Mutation);\n  }\n  /// Use the given action when type indexes 0 and 1 is any type pair in the\n  /// given list.\n  /// Action should not be an action that requires mutation.\n  LegalizeRuleSet &actionFor(LegalizeAction Action,\n                             std::initializer_list<std::pair<LLT, LLT>> Types) {\n    using namespace LegalityPredicates;\n    return actionIf(Action, typePairInSet(typeIdx(0), typeIdx(1), Types));\n  }\n  /// Use the given action when type indexes 0 and 1 is any type pair in the\n  /// given list.\n  /// Action should be an action that requires mutation.\n  LegalizeRuleSet &actionFor(LegalizeAction Action,\n                             std::initializer_list<std::pair<LLT, LLT>> Types,\n                             LegalizeMutation Mutation) {\n    using namespace LegalityPredicates;\n    return actionIf(Action, typePairInSet(typeIdx(0), typeIdx(1), Types),\n                    Mutation);\n  }\n  /// Use the given action when type index 0 is any type in the given list and\n  /// imm index 0 is anything. Action should not be an action that requires\n  /// mutation.\n  LegalizeRuleSet &actionForTypeWithAnyImm(LegalizeAction Action,\n                                           std::initializer_list<LLT> Types) {\n    using namespace LegalityPredicates;\n    immIdx(0); // Inform verifier imm idx 0 is handled.\n    return actionIf(Action, typeInSet(typeIdx(0), Types));\n  }\n\n  LegalizeRuleSet &actionForTypeWithAnyImm(\n    LegalizeAction Action, std::initializer_list<std::pair<LLT, LLT>> Types) {\n    using namespace LegalityPredicates;\n    immIdx(0); // Inform verifier imm idx 0 is handled.\n    return actionIf(Action, typePairInSet(typeIdx(0), typeIdx(1), Types));\n  }\n\n  /// Use the given action when type indexes 0 and 1 are both in the given list.\n  /// That is, the type pair is in the cartesian product of the list.\n  /// Action should not be an action that requires mutation.\n  LegalizeRuleSet &actionForCartesianProduct(LegalizeAction Action,\n                                             std::initializer_list<LLT> Types) {\n    using namespace LegalityPredicates;\n    return actionIf(Action, all(typeInSet(typeIdx(0), Types),\n                                typeInSet(typeIdx(1), Types)));\n  }\n  /// Use the given action when type indexes 0 and 1 are both in their\n  /// respective lists.\n  /// That is, the type pair is in the cartesian product of the lists\n  /// Action should not be an action that requires mutation.\n  LegalizeRuleSet &\n  actionForCartesianProduct(LegalizeAction Action,\n                            std::initializer_list<LLT> Types0,\n                            std::initializer_list<LLT> Types1) {\n    using namespace LegalityPredicates;\n    return actionIf(Action, all(typeInSet(typeIdx(0), Types0),\n                                typeInSet(typeIdx(1), Types1)));\n  }\n  /// Use the given action when type indexes 0, 1, and 2 are all in their\n  /// respective lists.\n  /// That is, the type triple is in the cartesian product of the lists\n  /// Action should not be an action that requires mutation.\n  LegalizeRuleSet &actionForCartesianProduct(\n      LegalizeAction Action, std::initializer_list<LLT> Types0,\n      std::initializer_list<LLT> Types1, std::initializer_list<LLT> Types2) {\n    using namespace LegalityPredicates;\n    return actionIf(Action, all(typeInSet(typeIdx(0), Types0),\n                                all(typeInSet(typeIdx(1), Types1),\n                                    typeInSet(typeIdx(2), Types2))));\n  }\n\npublic:\n  LegalizeRuleSet() : AliasOf(0), IsAliasedByAnother(false), Rules() {}\n\n  bool isAliasedByAnother() { return IsAliasedByAnother; }\n  void setIsAliasedByAnother() { IsAliasedByAnother = true; }\n  void aliasTo(unsigned Opcode) {\n    assert((AliasOf == 0 || AliasOf == Opcode) &&\n           \"Opcode is already aliased to another opcode\");\n    assert(Rules.empty() && \"Aliasing will discard rules\");\n    AliasOf = Opcode;\n  }\n  unsigned getAlias() const { return AliasOf; }\n\n  /// The instruction is legal if predicate is true.\n  LegalizeRuleSet &legalIf(LegalityPredicate Predicate) {\n    // We have no choice but conservatively assume that the free-form\n    // user-provided Predicate properly handles all type indices:\n    markAllIdxsAsCovered();\n    return actionIf(LegalizeAction::Legal, Predicate);\n  }\n  /// The instruction is legal when type index 0 is any type in the given list.\n  LegalizeRuleSet &legalFor(std::initializer_list<LLT> Types) {\n    return actionFor(LegalizeAction::Legal, Types);\n  }\n  /// The instruction is legal when type indexes 0 and 1 is any type pair in the\n  /// given list.\n  LegalizeRuleSet &legalFor(std::initializer_list<std::pair<LLT, LLT>> Types) {\n    return actionFor(LegalizeAction::Legal, Types);\n  }\n  /// The instruction is legal when type index 0 is any type in the given list\n  /// and imm index 0 is anything.\n  LegalizeRuleSet &legalForTypeWithAnyImm(std::initializer_list<LLT> Types) {\n    markAllIdxsAsCovered();\n    return actionForTypeWithAnyImm(LegalizeAction::Legal, Types);\n  }\n\n  LegalizeRuleSet &legalForTypeWithAnyImm(\n    std::initializer_list<std::pair<LLT, LLT>> Types) {\n    markAllIdxsAsCovered();\n    return actionForTypeWithAnyImm(LegalizeAction::Legal, Types);\n  }\n\n  /// The instruction is legal when type indexes 0 and 1 along with the memory\n  /// size and minimum alignment is any type and size tuple in the given list.\n  LegalizeRuleSet &legalForTypesWithMemDesc(\n      std::initializer_list<LegalityPredicates::TypePairAndMemDesc>\n          TypesAndMemDesc) {\n    return actionIf(LegalizeAction::Legal,\n                    LegalityPredicates::typePairAndMemDescInSet(\n                        typeIdx(0), typeIdx(1), /*MMOIdx*/ 0, TypesAndMemDesc));\n  }\n  /// The instruction is legal when type indexes 0 and 1 are both in the given\n  /// list. That is, the type pair is in the cartesian product of the list.\n  LegalizeRuleSet &legalForCartesianProduct(std::initializer_list<LLT> Types) {\n    return actionForCartesianProduct(LegalizeAction::Legal, Types);\n  }\n  /// The instruction is legal when type indexes 0 and 1 are both their\n  /// respective lists.\n  LegalizeRuleSet &legalForCartesianProduct(std::initializer_list<LLT> Types0,\n                                            std::initializer_list<LLT> Types1) {\n    return actionForCartesianProduct(LegalizeAction::Legal, Types0, Types1);\n  }\n  /// The instruction is legal when type indexes 0, 1, and 2 are both their\n  /// respective lists.\n  LegalizeRuleSet &legalForCartesianProduct(std::initializer_list<LLT> Types0,\n                                            std::initializer_list<LLT> Types1,\n                                            std::initializer_list<LLT> Types2) {\n    return actionForCartesianProduct(LegalizeAction::Legal, Types0, Types1,\n                                     Types2);\n  }\n\n  LegalizeRuleSet &alwaysLegal() {\n    using namespace LegalizeMutations;\n    markAllIdxsAsCovered();\n    return actionIf(LegalizeAction::Legal, always);\n  }\n\n  /// The specified type index is coerced if predicate is true.\n  LegalizeRuleSet &bitcastIf(LegalityPredicate Predicate,\n                             LegalizeMutation Mutation) {\n    // We have no choice but conservatively assume that lowering with a\n    // free-form user provided Predicate properly handles all type indices:\n    markAllIdxsAsCovered();\n    return actionIf(LegalizeAction::Bitcast, Predicate, Mutation);\n  }\n\n  /// The instruction is lowered.\n  LegalizeRuleSet &lower() {\n    using namespace LegalizeMutations;\n    // We have no choice but conservatively assume that predicate-less lowering\n    // properly handles all type indices by design:\n    markAllIdxsAsCovered();\n    return actionIf(LegalizeAction::Lower, always);\n  }\n  /// The instruction is lowered if predicate is true. Keep type index 0 as the\n  /// same type.\n  LegalizeRuleSet &lowerIf(LegalityPredicate Predicate) {\n    using namespace LegalizeMutations;\n    // We have no choice but conservatively assume that lowering with a\n    // free-form user provided Predicate properly handles all type indices:\n    markAllIdxsAsCovered();\n    return actionIf(LegalizeAction::Lower, Predicate);\n  }\n  /// The instruction is lowered if predicate is true.\n  LegalizeRuleSet &lowerIf(LegalityPredicate Predicate,\n                           LegalizeMutation Mutation) {\n    // We have no choice but conservatively assume that lowering with a\n    // free-form user provided Predicate properly handles all type indices:\n    markAllIdxsAsCovered();\n    return actionIf(LegalizeAction::Lower, Predicate, Mutation);\n  }\n  /// The instruction is lowered when type index 0 is any type in the given\n  /// list. Keep type index 0 as the same type.\n  LegalizeRuleSet &lowerFor(std::initializer_list<LLT> Types) {\n    return actionFor(LegalizeAction::Lower, Types);\n  }\n  /// The instruction is lowered when type index 0 is any type in the given\n  /// list.\n  LegalizeRuleSet &lowerFor(std::initializer_list<LLT> Types,\n                            LegalizeMutation Mutation) {\n    return actionFor(LegalizeAction::Lower, Types, Mutation);\n  }\n  /// The instruction is lowered when type indexes 0 and 1 is any type pair in\n  /// the given list. Keep type index 0 as the same type.\n  LegalizeRuleSet &lowerFor(std::initializer_list<std::pair<LLT, LLT>> Types) {\n    return actionFor(LegalizeAction::Lower, Types);\n  }\n  /// The instruction is lowered when type indexes 0 and 1 is any type pair in\n  /// the given list.\n  LegalizeRuleSet &lowerFor(std::initializer_list<std::pair<LLT, LLT>> Types,\n                            LegalizeMutation Mutation) {\n    return actionFor(LegalizeAction::Lower, Types, Mutation);\n  }\n  /// The instruction is lowered when type indexes 0 and 1 are both in their\n  /// respective lists.\n  LegalizeRuleSet &lowerForCartesianProduct(std::initializer_list<LLT> Types0,\n                                            std::initializer_list<LLT> Types1) {\n    using namespace LegalityPredicates;\n    return actionForCartesianProduct(LegalizeAction::Lower, Types0, Types1);\n  }\n  /// The instruction is lowered when when type indexes 0, 1, and 2 are all in\n  /// their respective lists.\n  LegalizeRuleSet &lowerForCartesianProduct(std::initializer_list<LLT> Types0,\n                                            std::initializer_list<LLT> Types1,\n                                            std::initializer_list<LLT> Types2) {\n    using namespace LegalityPredicates;\n    return actionForCartesianProduct(LegalizeAction::Lower, Types0, Types1,\n                                     Types2);\n  }\n\n  /// The instruction is emitted as a library call.\n  LegalizeRuleSet &libcall() {\n    using namespace LegalizeMutations;\n    // We have no choice but conservatively assume that predicate-less lowering\n    // properly handles all type indices by design:\n    markAllIdxsAsCovered();\n    return actionIf(LegalizeAction::Libcall, always);\n  }\n\n  /// Like legalIf, but for the Libcall action.\n  LegalizeRuleSet &libcallIf(LegalityPredicate Predicate) {\n    // We have no choice but conservatively assume that a libcall with a\n    // free-form user provided Predicate properly handles all type indices:\n    markAllIdxsAsCovered();\n    return actionIf(LegalizeAction::Libcall, Predicate);\n  }\n  LegalizeRuleSet &libcallFor(std::initializer_list<LLT> Types) {\n    return actionFor(LegalizeAction::Libcall, Types);\n  }\n  LegalizeRuleSet &\n  libcallFor(std::initializer_list<std::pair<LLT, LLT>> Types) {\n    return actionFor(LegalizeAction::Libcall, Types);\n  }\n  LegalizeRuleSet &\n  libcallForCartesianProduct(std::initializer_list<LLT> Types) {\n    return actionForCartesianProduct(LegalizeAction::Libcall, Types);\n  }\n  LegalizeRuleSet &\n  libcallForCartesianProduct(std::initializer_list<LLT> Types0,\n                             std::initializer_list<LLT> Types1) {\n    return actionForCartesianProduct(LegalizeAction::Libcall, Types0, Types1);\n  }\n\n  /// Widen the scalar to the one selected by the mutation if the predicate is\n  /// true.\n  LegalizeRuleSet &widenScalarIf(LegalityPredicate Predicate,\n                                 LegalizeMutation Mutation) {\n    // We have no choice but conservatively assume that an action with a\n    // free-form user provided Predicate properly handles all type indices:\n    markAllIdxsAsCovered();\n    return actionIf(LegalizeAction::WidenScalar, Predicate, Mutation);\n  }\n  /// Narrow the scalar to the one selected by the mutation if the predicate is\n  /// true.\n  LegalizeRuleSet &narrowScalarIf(LegalityPredicate Predicate,\n                                  LegalizeMutation Mutation) {\n    // We have no choice but conservatively assume that an action with a\n    // free-form user provided Predicate properly handles all type indices:\n    markAllIdxsAsCovered();\n    return actionIf(LegalizeAction::NarrowScalar, Predicate, Mutation);\n  }\n  /// Narrow the scalar, specified in mutation, when type indexes 0 and 1 is any\n  /// type pair in the given list.\n  LegalizeRuleSet &\n  narrowScalarFor(std::initializer_list<std::pair<LLT, LLT>> Types,\n                  LegalizeMutation Mutation) {\n    return actionFor(LegalizeAction::NarrowScalar, Types, Mutation);\n  }\n\n  /// Add more elements to reach the type selected by the mutation if the\n  /// predicate is true.\n  LegalizeRuleSet &moreElementsIf(LegalityPredicate Predicate,\n                                  LegalizeMutation Mutation) {\n    // We have no choice but conservatively assume that an action with a\n    // free-form user provided Predicate properly handles all type indices:\n    markAllIdxsAsCovered();\n    return actionIf(LegalizeAction::MoreElements, Predicate, Mutation);\n  }\n  /// Remove elements to reach the type selected by the mutation if the\n  /// predicate is true.\n  LegalizeRuleSet &fewerElementsIf(LegalityPredicate Predicate,\n                                   LegalizeMutation Mutation) {\n    // We have no choice but conservatively assume that an action with a\n    // free-form user provided Predicate properly handles all type indices:\n    markAllIdxsAsCovered();\n    return actionIf(LegalizeAction::FewerElements, Predicate, Mutation);\n  }\n\n  /// The instruction is unsupported.\n  LegalizeRuleSet &unsupported() {\n    markAllIdxsAsCovered();\n    return actionIf(LegalizeAction::Unsupported, always);\n  }\n  LegalizeRuleSet &unsupportedIf(LegalityPredicate Predicate) {\n    return actionIf(LegalizeAction::Unsupported, Predicate);\n  }\n\n  LegalizeRuleSet &unsupportedFor(std::initializer_list<LLT> Types) {\n    return actionFor(LegalizeAction::Unsupported, Types);\n  }\n\n  LegalizeRuleSet &unsupportedIfMemSizeNotPow2() {\n    return actionIf(LegalizeAction::Unsupported,\n                    LegalityPredicates::memSizeInBytesNotPow2(0));\n  }\n  LegalizeRuleSet &lowerIfMemSizeNotPow2() {\n    return actionIf(LegalizeAction::Lower,\n                    LegalityPredicates::memSizeInBytesNotPow2(0));\n  }\n\n  LegalizeRuleSet &customIf(LegalityPredicate Predicate) {\n    // We have no choice but conservatively assume that a custom action with a\n    // free-form user provided Predicate properly handles all type indices:\n    markAllIdxsAsCovered();\n    return actionIf(LegalizeAction::Custom, Predicate);\n  }\n  LegalizeRuleSet &customFor(std::initializer_list<LLT> Types) {\n    return actionFor(LegalizeAction::Custom, Types);\n  }\n\n  /// The instruction is custom when type indexes 0 and 1 is any type pair in the\n  /// given list.\n  LegalizeRuleSet &customFor(std::initializer_list<std::pair<LLT, LLT>> Types) {\n    return actionFor(LegalizeAction::Custom, Types);\n  }\n\n  LegalizeRuleSet &customForCartesianProduct(std::initializer_list<LLT> Types) {\n    return actionForCartesianProduct(LegalizeAction::Custom, Types);\n  }\n  LegalizeRuleSet &\n  customForCartesianProduct(std::initializer_list<LLT> Types0,\n                            std::initializer_list<LLT> Types1) {\n    return actionForCartesianProduct(LegalizeAction::Custom, Types0, Types1);\n  }\n\n  /// Unconditionally custom lower.\n  LegalizeRuleSet &custom() {\n    return customIf(always);\n  }\n\n  /// Widen the scalar to the next power of two that is at least MinSize.\n  /// No effect if the type is not a scalar or is a power of two.\n  LegalizeRuleSet &widenScalarToNextPow2(unsigned TypeIdx,\n                                         unsigned MinSize = 0) {\n    using namespace LegalityPredicates;\n    return actionIf(\n        LegalizeAction::WidenScalar, sizeNotPow2(typeIdx(TypeIdx)),\n        LegalizeMutations::widenScalarOrEltToNextPow2(TypeIdx, MinSize));\n  }\n\n  /// Widen the scalar or vector element type to the next power of two that is\n  /// at least MinSize.  No effect if the scalar size is a power of two.\n  LegalizeRuleSet &widenScalarOrEltToNextPow2(unsigned TypeIdx,\n                                              unsigned MinSize = 0) {\n    using namespace LegalityPredicates;\n    return actionIf(\n        LegalizeAction::WidenScalar, scalarOrEltSizeNotPow2(typeIdx(TypeIdx)),\n        LegalizeMutations::widenScalarOrEltToNextPow2(TypeIdx, MinSize));\n  }\n\n  LegalizeRuleSet &narrowScalar(unsigned TypeIdx, LegalizeMutation Mutation) {\n    using namespace LegalityPredicates;\n    return actionIf(LegalizeAction::NarrowScalar, isScalar(typeIdx(TypeIdx)),\n                    Mutation);\n  }\n\n  LegalizeRuleSet &scalarize(unsigned TypeIdx) {\n    using namespace LegalityPredicates;\n    return actionIf(LegalizeAction::FewerElements, isVector(typeIdx(TypeIdx)),\n                    LegalizeMutations::scalarize(TypeIdx));\n  }\n\n  LegalizeRuleSet &scalarizeIf(LegalityPredicate Predicate, unsigned TypeIdx) {\n    using namespace LegalityPredicates;\n    return actionIf(LegalizeAction::FewerElements,\n                    all(Predicate, isVector(typeIdx(TypeIdx))),\n                    LegalizeMutations::scalarize(TypeIdx));\n  }\n\n  /// Ensure the scalar or element is at least as wide as Ty.\n  LegalizeRuleSet &minScalarOrElt(unsigned TypeIdx, const LLT Ty) {\n    using namespace LegalityPredicates;\n    using namespace LegalizeMutations;\n    return actionIf(LegalizeAction::WidenScalar,\n                    scalarOrEltNarrowerThan(TypeIdx, Ty.getScalarSizeInBits()),\n                    changeElementTo(typeIdx(TypeIdx), Ty));\n  }\n\n  /// Ensure the scalar or element is at least as wide as Ty.\n  LegalizeRuleSet &minScalarOrEltIf(LegalityPredicate Predicate,\n                                    unsigned TypeIdx, const LLT Ty) {\n    using namespace LegalityPredicates;\n    using namespace LegalizeMutations;\n    return actionIf(LegalizeAction::WidenScalar,\n                    all(Predicate, scalarOrEltNarrowerThan(\n                                       TypeIdx, Ty.getScalarSizeInBits())),\n                    changeElementTo(typeIdx(TypeIdx), Ty));\n  }\n\n  /// Ensure the scalar is at least as wide as Ty.\n  LegalizeRuleSet &minScalar(unsigned TypeIdx, const LLT Ty) {\n    using namespace LegalityPredicates;\n    using namespace LegalizeMutations;\n    return actionIf(LegalizeAction::WidenScalar,\n                    scalarNarrowerThan(TypeIdx, Ty.getSizeInBits()),\n                    changeTo(typeIdx(TypeIdx), Ty));\n  }\n\n  /// Ensure the scalar is at most as wide as Ty.\n  LegalizeRuleSet &maxScalarOrElt(unsigned TypeIdx, const LLT Ty) {\n    using namespace LegalityPredicates;\n    using namespace LegalizeMutations;\n    return actionIf(LegalizeAction::NarrowScalar,\n                    scalarOrEltWiderThan(TypeIdx, Ty.getScalarSizeInBits()),\n                    changeElementTo(typeIdx(TypeIdx), Ty));\n  }\n\n  /// Ensure the scalar is at most as wide as Ty.\n  LegalizeRuleSet &maxScalar(unsigned TypeIdx, const LLT Ty) {\n    using namespace LegalityPredicates;\n    using namespace LegalizeMutations;\n    return actionIf(LegalizeAction::NarrowScalar,\n                    scalarWiderThan(TypeIdx, Ty.getSizeInBits()),\n                    changeTo(typeIdx(TypeIdx), Ty));\n  }\n\n  /// Conditionally limit the maximum size of the scalar.\n  /// For example, when the maximum size of one type depends on the size of\n  /// another such as extracting N bits from an M bit container.\n  LegalizeRuleSet &maxScalarIf(LegalityPredicate Predicate, unsigned TypeIdx,\n                               const LLT Ty) {\n    using namespace LegalityPredicates;\n    using namespace LegalizeMutations;\n    return actionIf(\n        LegalizeAction::NarrowScalar,\n        [=](const LegalityQuery &Query) {\n          const LLT QueryTy = Query.Types[TypeIdx];\n          return QueryTy.isScalar() &&\n                 QueryTy.getSizeInBits() > Ty.getSizeInBits() &&\n                 Predicate(Query);\n        },\n        changeElementTo(typeIdx(TypeIdx), Ty));\n  }\n\n  /// Limit the range of scalar sizes to MinTy and MaxTy.\n  LegalizeRuleSet &clampScalar(unsigned TypeIdx, const LLT MinTy,\n                               const LLT MaxTy) {\n    assert(MinTy.isScalar() && MaxTy.isScalar() && \"Expected scalar types\");\n    return minScalar(TypeIdx, MinTy).maxScalar(TypeIdx, MaxTy);\n  }\n\n  /// Limit the range of scalar sizes to MinTy and MaxTy.\n  LegalizeRuleSet &clampScalarOrElt(unsigned TypeIdx, const LLT MinTy,\n                                    const LLT MaxTy) {\n    return minScalarOrElt(TypeIdx, MinTy).maxScalarOrElt(TypeIdx, MaxTy);\n  }\n\n  /// Widen the scalar to match the size of another.\n  LegalizeRuleSet &minScalarSameAs(unsigned TypeIdx, unsigned LargeTypeIdx) {\n    typeIdx(TypeIdx);\n    return widenScalarIf(\n        [=](const LegalityQuery &Query) {\n          return Query.Types[LargeTypeIdx].getScalarSizeInBits() >\n                 Query.Types[TypeIdx].getSizeInBits();\n        },\n        LegalizeMutations::changeElementSizeTo(TypeIdx, LargeTypeIdx));\n  }\n\n  /// Narrow the scalar to match the size of another.\n  LegalizeRuleSet &maxScalarSameAs(unsigned TypeIdx, unsigned NarrowTypeIdx) {\n    typeIdx(TypeIdx);\n    return narrowScalarIf(\n        [=](const LegalityQuery &Query) {\n          return Query.Types[NarrowTypeIdx].getScalarSizeInBits() <\n                 Query.Types[TypeIdx].getSizeInBits();\n        },\n        LegalizeMutations::changeElementSizeTo(TypeIdx, NarrowTypeIdx));\n  }\n\n  /// Change the type \\p TypeIdx to have the same scalar size as type \\p\n  /// SameSizeIdx.\n  LegalizeRuleSet &scalarSameSizeAs(unsigned TypeIdx, unsigned SameSizeIdx) {\n    return minScalarSameAs(TypeIdx, SameSizeIdx)\n          .maxScalarSameAs(TypeIdx, SameSizeIdx);\n  }\n\n  /// Conditionally widen the scalar or elt to match the size of another.\n  LegalizeRuleSet &minScalarEltSameAsIf(LegalityPredicate Predicate,\n                                   unsigned TypeIdx, unsigned LargeTypeIdx) {\n    typeIdx(TypeIdx);\n    return widenScalarIf(\n        [=](const LegalityQuery &Query) {\n          return Query.Types[LargeTypeIdx].getScalarSizeInBits() >\n                     Query.Types[TypeIdx].getScalarSizeInBits() &&\n                 Predicate(Query);\n        },\n        [=](const LegalityQuery &Query) {\n          LLT T = Query.Types[LargeTypeIdx];\n          return std::make_pair(TypeIdx, T);\n        });\n  }\n\n  /// Add more elements to the vector to reach the next power of two.\n  /// No effect if the type is not a vector or the element count is a power of\n  /// two.\n  LegalizeRuleSet &moreElementsToNextPow2(unsigned TypeIdx) {\n    using namespace LegalityPredicates;\n    return actionIf(LegalizeAction::MoreElements,\n                    numElementsNotPow2(typeIdx(TypeIdx)),\n                    LegalizeMutations::moreElementsToNextPow2(TypeIdx));\n  }\n\n  /// Limit the number of elements in EltTy vectors to at least MinElements.\n  LegalizeRuleSet &clampMinNumElements(unsigned TypeIdx, const LLT EltTy,\n                                       unsigned MinElements) {\n    // Mark the type index as covered:\n    typeIdx(TypeIdx);\n    return actionIf(\n        LegalizeAction::MoreElements,\n        [=](const LegalityQuery &Query) {\n          LLT VecTy = Query.Types[TypeIdx];\n          return VecTy.isVector() && VecTy.getElementType() == EltTy &&\n                 VecTy.getNumElements() < MinElements;\n        },\n        [=](const LegalityQuery &Query) {\n          LLT VecTy = Query.Types[TypeIdx];\n          return std::make_pair(\n              TypeIdx, LLT::vector(MinElements, VecTy.getElementType()));\n        });\n  }\n  /// Limit the number of elements in EltTy vectors to at most MaxElements.\n  LegalizeRuleSet &clampMaxNumElements(unsigned TypeIdx, const LLT EltTy,\n                                       unsigned MaxElements) {\n    // Mark the type index as covered:\n    typeIdx(TypeIdx);\n    return actionIf(\n        LegalizeAction::FewerElements,\n        [=](const LegalityQuery &Query) {\n          LLT VecTy = Query.Types[TypeIdx];\n          return VecTy.isVector() && VecTy.getElementType() == EltTy &&\n                 VecTy.getNumElements() > MaxElements;\n        },\n        [=](const LegalityQuery &Query) {\n          LLT VecTy = Query.Types[TypeIdx];\n          LLT NewTy = LLT::scalarOrVector(MaxElements, VecTy.getElementType());\n          return std::make_pair(TypeIdx, NewTy);\n        });\n  }\n  /// Limit the number of elements for the given vectors to at least MinTy's\n  /// number of elements and at most MaxTy's number of elements.\n  ///\n  /// No effect if the type is not a vector or does not have the same element\n  /// type as the constraints.\n  /// The element type of MinTy and MaxTy must match.\n  LegalizeRuleSet &clampNumElements(unsigned TypeIdx, const LLT MinTy,\n                                    const LLT MaxTy) {\n    assert(MinTy.getElementType() == MaxTy.getElementType() &&\n           \"Expected element types to agree\");\n\n    const LLT EltTy = MinTy.getElementType();\n    return clampMinNumElements(TypeIdx, EltTy, MinTy.getNumElements())\n        .clampMaxNumElements(TypeIdx, EltTy, MaxTy.getNumElements());\n  }\n\n  /// Fallback on the previous implementation. This should only be used while\n  /// porting a rule.\n  LegalizeRuleSet &fallback() {\n    add({always, LegalizeAction::UseLegacyRules});\n    return *this;\n  }\n\n  /// Check if there is no type index which is obviously not handled by the\n  /// LegalizeRuleSet in any way at all.\n  /// \\pre Type indices of the opcode form a dense [0, \\p NumTypeIdxs) set.\n  bool verifyTypeIdxsCoverage(unsigned NumTypeIdxs) const;\n  /// Check if there is no imm index which is obviously not handled by the\n  /// LegalizeRuleSet in any way at all.\n  /// \\pre Type indices of the opcode form a dense [0, \\p NumTypeIdxs) set.\n  bool verifyImmIdxsCoverage(unsigned NumImmIdxs) const;\n\n  /// Apply the ruleset to the given LegalityQuery.\n  LegalizeActionStep apply(const LegalityQuery &Query) const;\n};\n\nclass LegalizerInfo {\npublic:\n  LegalizerInfo();\n  virtual ~LegalizerInfo() = default;\n\n  unsigned getOpcodeIdxForOpcode(unsigned Opcode) const;\n  unsigned getActionDefinitionsIdx(unsigned Opcode) const;\n\n  /// Compute any ancillary tables needed to quickly decide how an operation\n  /// should be handled. This must be called after all \"set*Action\"methods but\n  /// before any query is made or incorrect results may be returned.\n  void computeTables();\n\n  /// Perform simple self-diagnostic and assert if there is anything obviously\n  /// wrong with the actions set up.\n  void verify(const MCInstrInfo &MII) const;\n\n  static bool needsLegalizingToDifferentSize(const LegalizeAction Action) {\n    using namespace LegalizeActions;\n    switch (Action) {\n    case NarrowScalar:\n    case WidenScalar:\n    case FewerElements:\n    case MoreElements:\n    case Unsupported:\n      return true;\n    default:\n      return false;\n    }\n  }\n\n  using SizeAndAction = std::pair<uint16_t, LegalizeAction>;\n  using SizeAndActionsVec = std::vector<SizeAndAction>;\n  using SizeChangeStrategy =\n      std::function<SizeAndActionsVec(const SizeAndActionsVec &v)>;\n\n  /// More friendly way to set an action for common types that have an LLT\n  /// representation.\n  /// The LegalizeAction must be one for which NeedsLegalizingToDifferentSize\n  /// returns false.\n  void setAction(const InstrAspect &Aspect, LegalizeAction Action) {\n    assert(!needsLegalizingToDifferentSize(Action));\n    TablesInitialized = false;\n    const unsigned OpcodeIdx = Aspect.Opcode - FirstOp;\n    if (SpecifiedActions[OpcodeIdx].size() <= Aspect.Idx)\n      SpecifiedActions[OpcodeIdx].resize(Aspect.Idx + 1);\n    SpecifiedActions[OpcodeIdx][Aspect.Idx][Aspect.Type] = Action;\n  }\n\n  /// The setAction calls record the non-size-changing legalization actions\n  /// to take on specificly-sized types. The SizeChangeStrategy defines what\n  /// to do when the size of the type needs to be changed to reach a legally\n  /// sized type (i.e., one that was defined through a setAction call).\n  /// e.g.\n  /// setAction ({G_ADD, 0, LLT::scalar(32)}, Legal);\n  /// setLegalizeScalarToDifferentSizeStrategy(\n  ///   G_ADD, 0, widenToLargerTypesAndNarrowToLargest);\n  /// will end up defining getAction({G_ADD, 0, T}) to return the following\n  /// actions for different scalar types T:\n  ///  LLT::scalar(1)..LLT::scalar(31): {WidenScalar, 0, LLT::scalar(32)}\n  ///  LLT::scalar(32):                 {Legal, 0, LLT::scalar(32)}\n  ///  LLT::scalar(33)..:               {NarrowScalar, 0, LLT::scalar(32)}\n  ///\n  /// If no SizeChangeAction gets defined, through this function,\n  /// the default is unsupportedForDifferentSizes.\n  void setLegalizeScalarToDifferentSizeStrategy(const unsigned Opcode,\n                                                const unsigned TypeIdx,\n                                                SizeChangeStrategy S) {\n    const unsigned OpcodeIdx = Opcode - FirstOp;\n    if (ScalarSizeChangeStrategies[OpcodeIdx].size() <= TypeIdx)\n      ScalarSizeChangeStrategies[OpcodeIdx].resize(TypeIdx + 1);\n    ScalarSizeChangeStrategies[OpcodeIdx][TypeIdx] = S;\n  }\n\n  /// See also setLegalizeScalarToDifferentSizeStrategy.\n  /// This function allows to set the SizeChangeStrategy for vector elements.\n  void setLegalizeVectorElementToDifferentSizeStrategy(const unsigned Opcode,\n                                                       const unsigned TypeIdx,\n                                                       SizeChangeStrategy S) {\n    const unsigned OpcodeIdx = Opcode - FirstOp;\n    if (VectorElementSizeChangeStrategies[OpcodeIdx].size() <= TypeIdx)\n      VectorElementSizeChangeStrategies[OpcodeIdx].resize(TypeIdx + 1);\n    VectorElementSizeChangeStrategies[OpcodeIdx][TypeIdx] = S;\n  }\n\n  /// A SizeChangeStrategy for the common case where legalization for a\n  /// particular operation consists of only supporting a specific set of type\n  /// sizes. E.g.\n  ///   setAction ({G_DIV, 0, LLT::scalar(32)}, Legal);\n  ///   setAction ({G_DIV, 0, LLT::scalar(64)}, Legal);\n  ///   setLegalizeScalarToDifferentSizeStrategy(\n  ///     G_DIV, 0, unsupportedForDifferentSizes);\n  /// will result in getAction({G_DIV, 0, T}) to return Legal for s32 and s64,\n  /// and Unsupported for all other scalar types T.\n  static SizeAndActionsVec\n  unsupportedForDifferentSizes(const SizeAndActionsVec &v) {\n    using namespace LegalizeActions;\n    return increaseToLargerTypesAndDecreaseToLargest(v, Unsupported,\n                                                     Unsupported);\n  }\n\n  /// A SizeChangeStrategy for the common case where legalization for a\n  /// particular operation consists of widening the type to a large legal type,\n  /// unless there is no such type and then instead it should be narrowed to the\n  /// largest legal type.\n  static SizeAndActionsVec\n  widenToLargerTypesAndNarrowToLargest(const SizeAndActionsVec &v) {\n    using namespace LegalizeActions;\n    assert(v.size() > 0 &&\n           \"At least one size that can be legalized towards is needed\"\n           \" for this SizeChangeStrategy\");\n    return increaseToLargerTypesAndDecreaseToLargest(v, WidenScalar,\n                                                     NarrowScalar);\n  }\n\n  static SizeAndActionsVec\n  widenToLargerTypesUnsupportedOtherwise(const SizeAndActionsVec &v) {\n    using namespace LegalizeActions;\n    return increaseToLargerTypesAndDecreaseToLargest(v, WidenScalar,\n                                                     Unsupported);\n  }\n\n  static SizeAndActionsVec\n  narrowToSmallerAndUnsupportedIfTooSmall(const SizeAndActionsVec &v) {\n    using namespace LegalizeActions;\n    return decreaseToSmallerTypesAndIncreaseToSmallest(v, NarrowScalar,\n                                                       Unsupported);\n  }\n\n  static SizeAndActionsVec\n  narrowToSmallerAndWidenToSmallest(const SizeAndActionsVec &v) {\n    using namespace LegalizeActions;\n    assert(v.size() > 0 &&\n           \"At least one size that can be legalized towards is needed\"\n           \" for this SizeChangeStrategy\");\n    return decreaseToSmallerTypesAndIncreaseToSmallest(v, NarrowScalar,\n                                                       WidenScalar);\n  }\n\n  /// A SizeChangeStrategy for the common case where legalization for a\n  /// particular vector operation consists of having more elements in the\n  /// vector, to a type that is legal. Unless there is no such type and then\n  /// instead it should be legalized towards the widest vector that's still\n  /// legal. E.g.\n  ///   setAction({G_ADD, LLT::vector(8, 8)}, Legal);\n  ///   setAction({G_ADD, LLT::vector(16, 8)}, Legal);\n  ///   setAction({G_ADD, LLT::vector(2, 32)}, Legal);\n  ///   setAction({G_ADD, LLT::vector(4, 32)}, Legal);\n  ///   setLegalizeVectorElementToDifferentSizeStrategy(\n  ///     G_ADD, 0, moreToWiderTypesAndLessToWidest);\n  /// will result in the following getAction results:\n  ///   * getAction({G_ADD, LLT::vector(8,8)}) returns\n  ///       (Legal, vector(8,8)).\n  ///   * getAction({G_ADD, LLT::vector(9,8)}) returns\n  ///       (MoreElements, vector(16,8)).\n  ///   * getAction({G_ADD, LLT::vector(8,32)}) returns\n  ///       (FewerElements, vector(4,32)).\n  static SizeAndActionsVec\n  moreToWiderTypesAndLessToWidest(const SizeAndActionsVec &v) {\n    using namespace LegalizeActions;\n    return increaseToLargerTypesAndDecreaseToLargest(v, MoreElements,\n                                                     FewerElements);\n  }\n\n  /// Helper function to implement many typical SizeChangeStrategy functions.\n  static SizeAndActionsVec\n  increaseToLargerTypesAndDecreaseToLargest(const SizeAndActionsVec &v,\n                                            LegalizeAction IncreaseAction,\n                                            LegalizeAction DecreaseAction);\n  /// Helper function to implement many typical SizeChangeStrategy functions.\n  static SizeAndActionsVec\n  decreaseToSmallerTypesAndIncreaseToSmallest(const SizeAndActionsVec &v,\n                                              LegalizeAction DecreaseAction,\n                                              LegalizeAction IncreaseAction);\n\n  /// Get the action definitions for the given opcode. Use this to run a\n  /// LegalityQuery through the definitions.\n  const LegalizeRuleSet &getActionDefinitions(unsigned Opcode) const;\n\n  /// Get the action definition builder for the given opcode. Use this to define\n  /// the action definitions.\n  ///\n  /// It is an error to request an opcode that has already been requested by the\n  /// multiple-opcode variant.\n  LegalizeRuleSet &getActionDefinitionsBuilder(unsigned Opcode);\n\n  /// Get the action definition builder for the given set of opcodes. Use this\n  /// to define the action definitions for multiple opcodes at once. The first\n  /// opcode given will be considered the representative opcode and will hold\n  /// the definitions whereas the other opcodes will be configured to refer to\n  /// the representative opcode. This lowers memory requirements and very\n  /// slightly improves performance.\n  ///\n  /// It would be very easy to introduce unexpected side-effects as a result of\n  /// this aliasing if it were permitted to request different but intersecting\n  /// sets of opcodes but that is difficult to keep track of. It is therefore an\n  /// error to request the same opcode twice using this API, to request an\n  /// opcode that already has definitions, or to use the single-opcode API on an\n  /// opcode that has already been requested by this API.\n  LegalizeRuleSet &\n  getActionDefinitionsBuilder(std::initializer_list<unsigned> Opcodes);\n  void aliasActionDefinitions(unsigned OpcodeTo, unsigned OpcodeFrom);\n\n  /// Determine what action should be taken to legalize the described\n  /// instruction. Requires computeTables to have been called.\n  ///\n  /// \\returns a description of the next legalization step to perform.\n  LegalizeActionStep getAction(const LegalityQuery &Query) const;\n\n  /// Determine what action should be taken to legalize the given generic\n  /// instruction.\n  ///\n  /// \\returns a description of the next legalization step to perform.\n  LegalizeActionStep getAction(const MachineInstr &MI,\n                               const MachineRegisterInfo &MRI) const;\n\n  bool isLegal(const LegalityQuery &Query) const {\n    return getAction(Query).Action == LegalizeAction::Legal;\n  }\n\n  bool isLegalOrCustom(const LegalityQuery &Query) const {\n    auto Action = getAction(Query).Action;\n    return Action == LegalizeAction::Legal || Action == LegalizeAction::Custom;\n  }\n\n  bool isLegal(const MachineInstr &MI, const MachineRegisterInfo &MRI) const;\n  bool isLegalOrCustom(const MachineInstr &MI,\n                       const MachineRegisterInfo &MRI) const;\n\n  /// Called for instructions with the Custom LegalizationAction.\n  virtual bool legalizeCustom(LegalizerHelper &Helper,\n                              MachineInstr &MI) const {\n    llvm_unreachable(\"must implement this if custom action is used\");\n  }\n\n  /// \\returns true if MI is either legal or has been legalized and false if not\n  /// legal.\n  /// Return true if MI is either legal or has been legalized and false\n  /// if not legal.\n  virtual bool legalizeIntrinsic(LegalizerHelper &Helper,\n                                 MachineInstr &MI) const {\n    return true;\n  }\n\n  /// Return the opcode (SEXT/ZEXT/ANYEXT) that should be performed while\n  /// widening a constant of type SmallTy which targets can override.\n  /// For eg, the DAG does (SmallTy.isByteSized() ? G_SEXT : G_ZEXT) which\n  /// will be the default.\n  virtual unsigned getExtOpcodeForWideningConstant(LLT SmallTy) const;\n\nprivate:\n  /// Determine what action should be taken to legalize the given generic\n  /// instruction opcode, type-index and type. Requires computeTables to have\n  /// been called.\n  ///\n  /// \\returns a pair consisting of the kind of legalization that should be\n  /// performed and the destination type.\n  std::pair<LegalizeAction, LLT>\n  getAspectAction(const InstrAspect &Aspect) const;\n\n  /// The SizeAndActionsVec is a representation mapping between all natural\n  /// numbers and an Action. The natural number represents the bit size of\n  /// the InstrAspect. For example, for a target with native support for 32-bit\n  /// and 64-bit additions, you'd express that as:\n  /// setScalarAction(G_ADD, 0,\n  ///           {{1, WidenScalar},  // bit sizes [ 1, 31[\n  ///            {32, Legal},       // bit sizes [32, 33[\n  ///            {33, WidenScalar}, // bit sizes [33, 64[\n  ///            {64, Legal},       // bit sizes [64, 65[\n  ///            {65, NarrowScalar} // bit sizes [65, +inf[\n  ///           });\n  /// It may be that only 64-bit pointers are supported on your target:\n  /// setPointerAction(G_PTR_ADD, 0, LLT:pointer(1),\n  ///           {{1, Unsupported},  // bit sizes [ 1, 63[\n  ///            {64, Legal},       // bit sizes [64, 65[\n  ///            {65, Unsupported}, // bit sizes [65, +inf[\n  ///           });\n  void setScalarAction(const unsigned Opcode, const unsigned TypeIndex,\n                       const SizeAndActionsVec &SizeAndActions) {\n    const unsigned OpcodeIdx = Opcode - FirstOp;\n    SmallVector<SizeAndActionsVec, 1> &Actions = ScalarActions[OpcodeIdx];\n    setActions(TypeIndex, Actions, SizeAndActions);\n  }\n  void setPointerAction(const unsigned Opcode, const unsigned TypeIndex,\n                        const unsigned AddressSpace,\n                        const SizeAndActionsVec &SizeAndActions) {\n    const unsigned OpcodeIdx = Opcode - FirstOp;\n    if (AddrSpace2PointerActions[OpcodeIdx].find(AddressSpace) ==\n        AddrSpace2PointerActions[OpcodeIdx].end())\n      AddrSpace2PointerActions[OpcodeIdx][AddressSpace] = {{}};\n    SmallVector<SizeAndActionsVec, 1> &Actions =\n        AddrSpace2PointerActions[OpcodeIdx].find(AddressSpace)->second;\n    setActions(TypeIndex, Actions, SizeAndActions);\n  }\n\n  /// If an operation on a given vector type (say <M x iN>) isn't explicitly\n  /// specified, we proceed in 2 stages. First we legalize the underlying scalar\n  /// (so that there's at least one legal vector with that scalar), then we\n  /// adjust the number of elements in the vector so that it is legal. The\n  /// desired action in the first step is controlled by this function.\n  void setScalarInVectorAction(const unsigned Opcode, const unsigned TypeIndex,\n                               const SizeAndActionsVec &SizeAndActions) {\n    unsigned OpcodeIdx = Opcode - FirstOp;\n    SmallVector<SizeAndActionsVec, 1> &Actions =\n        ScalarInVectorActions[OpcodeIdx];\n    setActions(TypeIndex, Actions, SizeAndActions);\n  }\n\n  /// See also setScalarInVectorAction.\n  /// This function let's you specify the number of elements in a vector that\n  /// are legal for a legal element size.\n  void setVectorNumElementAction(const unsigned Opcode,\n                                 const unsigned TypeIndex,\n                                 const unsigned ElementSize,\n                                 const SizeAndActionsVec &SizeAndActions) {\n    const unsigned OpcodeIdx = Opcode - FirstOp;\n    if (NumElements2Actions[OpcodeIdx].find(ElementSize) ==\n        NumElements2Actions[OpcodeIdx].end())\n      NumElements2Actions[OpcodeIdx][ElementSize] = {{}};\n    SmallVector<SizeAndActionsVec, 1> &Actions =\n        NumElements2Actions[OpcodeIdx].find(ElementSize)->second;\n    setActions(TypeIndex, Actions, SizeAndActions);\n  }\n\n  /// A partial SizeAndActionsVec potentially doesn't cover all bit sizes,\n  /// i.e. it's OK if it doesn't start from size 1.\n  static void checkPartialSizeAndActionsVector(const SizeAndActionsVec& v) {\n    using namespace LegalizeActions;\n#ifndef NDEBUG\n    // The sizes should be in increasing order\n    int prev_size = -1;\n    for(auto SizeAndAction: v) {\n      assert(SizeAndAction.first > prev_size);\n      prev_size = SizeAndAction.first;\n    }\n    // - for every Widen action, there should be a larger bitsize that\n    //   can be legalized towards (e.g. Legal, Lower, Libcall or Custom\n    //   action).\n    // - for every Narrow action, there should be a smaller bitsize that\n    //   can be legalized towards.\n    int SmallestNarrowIdx = -1;\n    int LargestWidenIdx = -1;\n    int SmallestLegalizableToSameSizeIdx = -1;\n    int LargestLegalizableToSameSizeIdx = -1;\n    for(size_t i=0; i<v.size(); ++i) {\n      switch (v[i].second) {\n        case FewerElements:\n        case NarrowScalar:\n          if (SmallestNarrowIdx == -1)\n            SmallestNarrowIdx = i;\n          break;\n        case WidenScalar:\n        case MoreElements:\n          LargestWidenIdx = i;\n          break;\n        case Unsupported:\n          break;\n        default:\n          if (SmallestLegalizableToSameSizeIdx == -1)\n            SmallestLegalizableToSameSizeIdx = i;\n          LargestLegalizableToSameSizeIdx = i;\n      }\n    }\n    if (SmallestNarrowIdx != -1) {\n      assert(SmallestLegalizableToSameSizeIdx != -1);\n      assert(SmallestNarrowIdx > SmallestLegalizableToSameSizeIdx);\n    }\n    if (LargestWidenIdx != -1)\n      assert(LargestWidenIdx < LargestLegalizableToSameSizeIdx);\n#endif\n  }\n\n  /// A full SizeAndActionsVec must cover all bit sizes, i.e. must start with\n  /// from size 1.\n  static void checkFullSizeAndActionsVector(const SizeAndActionsVec& v) {\n#ifndef NDEBUG\n    // Data structure invariant: The first bit size must be size 1.\n    assert(v.size() >= 1);\n    assert(v[0].first == 1);\n    checkPartialSizeAndActionsVector(v);\n#endif\n  }\n\n  /// Sets actions for all bit sizes on a particular generic opcode, type\n  /// index and scalar or pointer type.\n  void setActions(unsigned TypeIndex,\n                  SmallVector<SizeAndActionsVec, 1> &Actions,\n                  const SizeAndActionsVec &SizeAndActions) {\n    checkFullSizeAndActionsVector(SizeAndActions);\n    if (Actions.size() <= TypeIndex)\n      Actions.resize(TypeIndex + 1);\n    Actions[TypeIndex] = SizeAndActions;\n  }\n\n  static SizeAndAction findAction(const SizeAndActionsVec &Vec,\n                                  const uint32_t Size);\n\n  /// Returns the next action needed to get the scalar or pointer type closer\n  /// to being legal\n  /// E.g. findLegalAction({G_REM, 13}) should return\n  /// (WidenScalar, 32). After that, findLegalAction({G_REM, 32}) will\n  /// probably be called, which should return (Lower, 32).\n  /// This is assuming the setScalarAction on G_REM was something like:\n  /// setScalarAction(G_REM, 0,\n  ///           {{1, WidenScalar},  // bit sizes [ 1, 31[\n  ///            {32, Lower},       // bit sizes [32, 33[\n  ///            {33, NarrowScalar} // bit sizes [65, +inf[\n  ///           });\n  std::pair<LegalizeAction, LLT>\n  findScalarLegalAction(const InstrAspect &Aspect) const;\n\n  /// Returns the next action needed towards legalizing the vector type.\n  std::pair<LegalizeAction, LLT>\n  findVectorLegalAction(const InstrAspect &Aspect) const;\n\n  static const int FirstOp = TargetOpcode::PRE_ISEL_GENERIC_OPCODE_START;\n  static const int LastOp = TargetOpcode::PRE_ISEL_GENERIC_OPCODE_END;\n\n  // Data structures used temporarily during construction of legality data:\n  using TypeMap = DenseMap<LLT, LegalizeAction>;\n  SmallVector<TypeMap, 1> SpecifiedActions[LastOp - FirstOp + 1];\n  SmallVector<SizeChangeStrategy, 1>\n      ScalarSizeChangeStrategies[LastOp - FirstOp + 1];\n  SmallVector<SizeChangeStrategy, 1>\n      VectorElementSizeChangeStrategies[LastOp - FirstOp + 1];\n  bool TablesInitialized;\n\n  // Data structures used by getAction:\n  SmallVector<SizeAndActionsVec, 1> ScalarActions[LastOp - FirstOp + 1];\n  SmallVector<SizeAndActionsVec, 1> ScalarInVectorActions[LastOp - FirstOp + 1];\n  std::unordered_map<uint16_t, SmallVector<SizeAndActionsVec, 1>>\n      AddrSpace2PointerActions[LastOp - FirstOp + 1];\n  std::unordered_map<uint16_t, SmallVector<SizeAndActionsVec, 1>>\n      NumElements2Actions[LastOp - FirstOp + 1];\n\n  LegalizeRuleSet RulesForOpcode[LastOp - FirstOp + 1];\n};\n\n#ifndef NDEBUG\n/// Checks that MIR is fully legal, returns an illegal instruction if it's not,\n/// nullptr otherwise\nconst MachineInstr *machineFunctionIsIllegal(const MachineFunction &MF);\n#endif\n\n} // end namespace llvm.\n\n#endif // LLVM_CODEGEN_GLOBALISEL_LEGALIZERINFO_H\n"}, "28": {"id": 28, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegisterBank.h", "content": "//==-- llvm/CodeGen/GlobalISel/RegisterBank.h - Register Bank ----*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file This file declares the API of register banks.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_GLOBALISEL_REGISTERBANK_H\n#define LLVM_CODEGEN_GLOBALISEL_REGISTERBANK_H\n\n#include \"llvm/ADT/BitVector.h\"\n\nnamespace llvm {\n// Forward declarations.\nclass RegisterBankInfo;\nclass raw_ostream;\nclass TargetRegisterClass;\nclass TargetRegisterInfo;\n\n/// This class implements the register bank concept.\n/// Two instances of RegisterBank must have different ID.\n/// This property is enforced by the RegisterBankInfo class.\nclass RegisterBank {\nprivate:\n  unsigned ID;\n  const char *Name;\n  unsigned Size;\n  BitVector ContainedRegClasses;\n\n  /// Sentinel value used to recognize register bank not properly\n  /// initialized yet.\n  static const unsigned InvalidID;\n\n  /// Only the RegisterBankInfo can initialize RegisterBank properly.\n  friend RegisterBankInfo;\n\npublic:\n  RegisterBank(unsigned ID, const char *Name, unsigned Size,\n               const uint32_t *CoveredClasses, unsigned NumRegClasses);\n\n  /// Get the identifier of this register bank.\n  unsigned getID() const { return ID; }\n\n  /// Get a user friendly name of this register bank.\n  /// Should be used only for debugging purposes.\n  const char *getName() const { return Name; }\n\n  /// Get the maximal size in bits that fits in this register bank.\n  unsigned getSize() const { return Size; }\n\n  /// Check whether this instance is ready to be used.\n  bool isValid() const;\n\n  /// Check if this register bank is valid. In other words,\n  /// if it has been properly constructed.\n  ///\n  /// \\note This method does not check anything when assertions are disabled.\n  ///\n  /// \\return True is the check was successful.\n  bool verify(const TargetRegisterInfo &TRI) const;\n\n  /// Check whether this register bank covers \\p RC.\n  /// In other words, check if this register bank fully covers\n  /// the registers that \\p RC contains.\n  /// \\pre isValid()\n  bool covers(const TargetRegisterClass &RC) const;\n\n  /// Check whether \\p OtherRB is the same as this.\n  bool operator==(const RegisterBank &OtherRB) const;\n  bool operator!=(const RegisterBank &OtherRB) const {\n    return !this->operator==(OtherRB);\n  }\n\n  /// Dump the register mask on dbgs() stream.\n  /// The dump is verbose.\n  void dump(const TargetRegisterInfo *TRI = nullptr) const;\n\n  /// Print the register mask on OS.\n  /// If IsForDebug is false, then only the name of the register bank\n  /// is printed. Otherwise, all the fields are printing.\n  /// TRI is then used to print the name of the register classes that\n  /// this register bank covers.\n  void print(raw_ostream &OS, bool IsForDebug = false,\n             const TargetRegisterInfo *TRI = nullptr) const;\n};\n\ninline raw_ostream &operator<<(raw_ostream &OS, const RegisterBank &RegBank) {\n  RegBank.print(OS);\n  return OS;\n}\n} // End namespace llvm.\n\n#endif\n"}, "30": {"id": 30, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundle.h", "content": "//===- llvm/CodeGen/MachineInstrBundle.h - MI bundle utilities --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file provide utility functions to manipulate machine instruction\n// bundles.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_MACHINEINSTRBUNDLE_H\n#define LLVM_CODEGEN_MACHINEINSTRBUNDLE_H\n\n#include \"llvm/CodeGen/MachineBasicBlock.h\"\n\nnamespace llvm {\n\n/// finalizeBundle - Finalize a machine instruction bundle which includes\n/// a sequence of instructions starting from FirstMI to LastMI (exclusive).\n/// This routine adds a BUNDLE instruction to represent the bundle, it adds\n/// IsInternalRead markers to MachineOperands which are defined inside the\n/// bundle, and it copies externally visible defs and uses to the BUNDLE\n/// instruction.\nvoid finalizeBundle(MachineBasicBlock &MBB,\n                    MachineBasicBlock::instr_iterator FirstMI,\n                    MachineBasicBlock::instr_iterator LastMI);\n\n/// finalizeBundle - Same functionality as the previous finalizeBundle except\n/// the last instruction in the bundle is not provided as an input. This is\n/// used in cases where bundles are pre-determined by marking instructions\n/// with 'InsideBundle' marker. It returns the MBB instruction iterator that\n/// points to the end of the bundle.\nMachineBasicBlock::instr_iterator finalizeBundle(MachineBasicBlock &MBB,\n                    MachineBasicBlock::instr_iterator FirstMI);\n\n/// finalizeBundles - Finalize instruction bundles in the specified\n/// MachineFunction. Return true if any bundles are finalized.\nbool finalizeBundles(MachineFunction &MF);\n\n/// Returns an iterator to the first instruction in the bundle containing \\p I.\ninline MachineBasicBlock::instr_iterator getBundleStart(\n    MachineBasicBlock::instr_iterator I) {\n  while (I->isBundledWithPred())\n    --I;\n  return I;\n}\n\n/// Returns an iterator to the first instruction in the bundle containing \\p I.\ninline MachineBasicBlock::const_instr_iterator getBundleStart(\n    MachineBasicBlock::const_instr_iterator I) {\n  while (I->isBundledWithPred())\n    --I;\n  return I;\n}\n\n/// Returns an iterator pointing beyond the bundle containing \\p I.\ninline MachineBasicBlock::instr_iterator getBundleEnd(\n    MachineBasicBlock::instr_iterator I) {\n  while (I->isBundledWithSucc())\n    ++I;\n  ++I;\n  return I;\n}\n\n/// Returns an iterator pointing beyond the bundle containing \\p I.\ninline MachineBasicBlock::const_instr_iterator getBundleEnd(\n    MachineBasicBlock::const_instr_iterator I) {\n  while (I->isBundledWithSucc())\n    ++I;\n  ++I;\n  return I;\n}\n\n//===----------------------------------------------------------------------===//\n// MachineBundleOperand iterator\n//\n\n/// MIBundleOperandIteratorBase - Iterator that visits all operands in a bundle\n/// of MachineInstrs. This class is not intended to be used directly, use one\n/// of the sub-classes instead.\n///\n/// Intended use:\n///\n///   for (MIBundleOperands MIO(MI); MIO.isValid(); ++MIO) {\n///     if (!MIO->isReg())\n///       continue;\n///     ...\n///   }\n///\ntemplate <typename ValueT>\nclass MIBundleOperandIteratorBase\n    : public iterator_facade_base<MIBundleOperandIteratorBase<ValueT>,\n                                  std::forward_iterator_tag, ValueT> {\n  MachineBasicBlock::instr_iterator InstrI, InstrE;\n  MachineInstr::mop_iterator OpI, OpE;\n\n  // If the operands on InstrI are exhausted, advance InstrI to the next\n  // bundled instruction with operands.\n  void advance() {\n    while (OpI == OpE) {\n      // Don't advance off the basic block, or into a new bundle.\n      if (++InstrI == InstrE || !InstrI->isInsideBundle()) {\n        InstrI = InstrE;\n        break;\n      }\n      OpI = InstrI->operands_begin();\n      OpE = InstrI->operands_end();\n    }\n  }\n\nprotected:\n  /// MIBundleOperandIteratorBase - Create an iterator that visits all operands\n  /// on MI, or all operands on every instruction in the bundle containing MI.\n  ///\n  /// @param MI The instruction to examine.\n  ///\n  explicit MIBundleOperandIteratorBase(MachineInstr &MI) {\n    InstrI = getBundleStart(MI.getIterator());\n    InstrE = MI.getParent()->instr_end();\n    OpI = InstrI->operands_begin();\n    OpE = InstrI->operands_end();\n    advance();\n  }\n\n  /// Constructor for an iterator past the last iteration: both instruction\n  /// iterators point to the end of the BB and OpI == OpE.\n  explicit MIBundleOperandIteratorBase(MachineBasicBlock::instr_iterator InstrE,\n                                       MachineInstr::mop_iterator OpE)\n      : InstrI(InstrE), InstrE(InstrE), OpI(OpE), OpE(OpE) {}\n\npublic:\n  /// isValid - Returns true until all the operands have been visited.\n  bool isValid() const { return OpI != OpE; }\n\n  /// Preincrement.  Move to the next operand.\n  void operator++() {\n    assert(isValid() && \"Cannot advance MIOperands beyond the last operand\");\n    ++OpI;\n    advance();\n  }\n\n  ValueT &operator*() const { return *OpI; }\n  ValueT *operator->() const { return &*OpI; }\n\n  bool operator==(const MIBundleOperandIteratorBase &Arg) const {\n    // Iterators are equal, if InstrI matches and either OpIs match or OpI ==\n    // OpE match for both. The second condition allows us to construct an 'end'\n    // iterator, without finding the last instruction in a bundle up-front.\n    return InstrI == Arg.InstrI &&\n           (OpI == Arg.OpI || (OpI == OpE && Arg.OpI == Arg.OpE));\n  }\n  /// getOperandNo - Returns the number of the current operand relative to its\n  /// instruction.\n  ///\n  unsigned getOperandNo() const {\n    return OpI - InstrI->operands_begin();\n  }\n};\n\n/// MIBundleOperands - Iterate over all operands in a bundle of machine\n/// instructions.\n///\nclass MIBundleOperands : public MIBundleOperandIteratorBase<MachineOperand> {\n  /// Constructor for an iterator past the last iteration.\n  MIBundleOperands(MachineBasicBlock::instr_iterator InstrE,\n                   MachineInstr::mop_iterator OpE)\n      : MIBundleOperandIteratorBase(InstrE, OpE) {}\n\npublic:\n  MIBundleOperands(MachineInstr &MI) : MIBundleOperandIteratorBase(MI) {}\n\n  /// Returns an iterator past the last iteration.\n  static MIBundleOperands end(const MachineBasicBlock &MBB) {\n    return {const_cast<MachineBasicBlock &>(MBB).instr_end(),\n            const_cast<MachineBasicBlock &>(MBB).instr_begin()->operands_end()};\n  }\n};\n\n/// ConstMIBundleOperands - Iterate over all operands in a const bundle of\n/// machine instructions.\n///\nclass ConstMIBundleOperands\n    : public MIBundleOperandIteratorBase<const MachineOperand> {\n\n  /// Constructor for an iterator past the last iteration.\n  ConstMIBundleOperands(MachineBasicBlock::instr_iterator InstrE,\n                        MachineInstr::mop_iterator OpE)\n      : MIBundleOperandIteratorBase(InstrE, OpE) {}\n\npublic:\n  ConstMIBundleOperands(const MachineInstr &MI)\n      : MIBundleOperandIteratorBase(const_cast<MachineInstr &>(MI)) {}\n\n  /// Returns an iterator past the last iteration.\n  static ConstMIBundleOperands end(const MachineBasicBlock &MBB) {\n    return {const_cast<MachineBasicBlock &>(MBB).instr_end(),\n            const_cast<MachineBasicBlock &>(MBB).instr_begin()->operands_end()};\n  }\n};\n\ninline iterator_range<ConstMIBundleOperands>\nconst_mi_bundle_ops(const MachineInstr &MI) {\n  return make_range(ConstMIBundleOperands(MI),\n                    ConstMIBundleOperands::end(*MI.getParent()));\n}\n\ninline iterator_range<MIBundleOperands> mi_bundle_ops(MachineInstr &MI) {\n  return make_range(MIBundleOperands(MI),\n                    MIBundleOperands::end(*MI.getParent()));\n}\n\n/// VirtRegInfo - Information about a virtual register used by a set of\n/// operands.\n///\nstruct VirtRegInfo {\n  /// Reads - One of the operands read the virtual register.  This does not\n  /// include undef or internal use operands, see MO::readsReg().\n  bool Reads;\n\n  /// Writes - One of the operands writes the virtual register.\n  bool Writes;\n\n  /// Tied - Uses and defs must use the same register. This can be because of\n  /// a two-address constraint, or there may be a partial redefinition of a\n  /// sub-register.\n  bool Tied;\n};\n\n/// AnalyzeVirtRegInBundle - Analyze how the current instruction or bundle uses\n/// a virtual register.  This function should not be called after operator++(),\n/// it expects a fresh iterator.\n///\n/// @param Reg The virtual register to analyze.\n/// @param Ops When set, this vector will receive an (MI, OpNum) entry for\n///            each operand referring to Reg.\n/// @returns A filled-in RegInfo struct.\nVirtRegInfo AnalyzeVirtRegInBundle(\n    MachineInstr &MI, Register Reg,\n    SmallVectorImpl<std::pair<MachineInstr *, unsigned>> *Ops = nullptr);\n\n/// Information about how a physical register Reg is used by a set of\n/// operands.\nstruct PhysRegInfo {\n  /// There is a regmask operand indicating Reg is clobbered.\n  /// \\see MachineOperand::CreateRegMask().\n  bool Clobbered;\n\n  /// Reg or one of its aliases is defined. The definition may only cover\n  /// parts of the register.\n  bool Defined;\n  /// Reg or a super-register is defined. The definition covers the full\n  /// register.\n  bool FullyDefined;\n\n  /// Reg or one of its aliases is read. The register may only be read\n  /// partially.\n  bool Read;\n  /// Reg or a super-register is read. The full register is read.\n  bool FullyRead;\n\n  /// Either:\n  /// - Reg is FullyDefined and all defs of reg or an overlapping\n  ///   register are dead, or\n  /// - Reg is completely dead because \"defined\" by a clobber.\n  bool DeadDef;\n\n  /// Reg is Defined and all defs of reg or an overlapping register are\n  /// dead.\n  bool PartialDeadDef;\n\n  /// There is a use operand of reg or a super-register with kill flag set.\n  bool Killed;\n};\n\n/// AnalyzePhysRegInBundle - Analyze how the current instruction or bundle uses\n/// a physical register.  This function should not be called after operator++(),\n/// it expects a fresh iterator.\n///\n/// @param Reg The physical register to analyze.\n/// @returns A filled-in PhysRegInfo struct.\nPhysRegInfo AnalyzePhysRegInBundle(const MachineInstr &MI, Register Reg,\n                                   const TargetRegisterInfo *TRI);\n\n} // End llvm namespace\n\n#endif\n"}, "33": {"id": 33, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h", "content": "//===---- MachineOutliner.h - Outliner data structures ------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Contains all data structures shared between the outliner implemented in\n/// MachineOutliner.cpp and target implementations of the outliner.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_MACHINEOUTLINER_H\n#define LLVM_CODEGEN_MACHINEOUTLINER_H\n\n#include \"llvm/CodeGen/LivePhysRegs.h\"\n#include \"llvm/CodeGen/LiveRegUnits.h\"\n#include \"llvm/CodeGen/MachineFunction.h\"\n#include \"llvm/CodeGen/MachineRegisterInfo.h\"\n#include \"llvm/CodeGen/TargetRegisterInfo.h\"\n\nnamespace llvm {\nnamespace outliner {\n\n/// Represents how an instruction should be mapped by the outliner.\n/// \\p Legal instructions are those which are safe to outline.\n/// \\p LegalTerminator instructions are safe to outline, but only as the\n/// last instruction in a sequence.\n/// \\p Illegal instructions are those which cannot be outlined.\n/// \\p Invisible instructions are instructions which can be outlined, but\n/// shouldn't actually impact the outlining result.\nenum InstrType { Legal, LegalTerminator, Illegal, Invisible };\n\n/// An individual sequence of instructions to be replaced with a call to\n/// an outlined function.\nstruct Candidate {\nprivate:\n  /// The start index of this \\p Candidate in the instruction list.\n  unsigned StartIdx = 0;\n\n  /// The number of instructions in this \\p Candidate.\n  unsigned Len = 0;\n\n  // The first instruction in this \\p Candidate.\n  MachineBasicBlock::iterator FirstInst;\n\n  // The last instruction in this \\p Candidate.\n  MachineBasicBlock::iterator LastInst;\n\n  // The basic block that contains this Candidate.\n  MachineBasicBlock *MBB = nullptr;\n\n  /// Cost of calling an outlined function from this point as defined by the\n  /// target.\n  unsigned CallOverhead = 0;\n\npublic:\n  /// The index of this \\p Candidate's \\p OutlinedFunction in the list of\n  /// \\p OutlinedFunctions.\n  unsigned FunctionIdx = 0;\n\n  /// Identifier denoting the instructions to emit to call an outlined function\n  /// from this point. Defined by the target.\n  unsigned CallConstructionID = 0;\n\n  /// Contains physical register liveness information for the MBB containing\n  /// this \\p Candidate.\n  ///\n  /// This is optionally used by the target to calculate more fine-grained\n  /// cost model information.\n  LiveRegUnits LRU;\n\n  /// Contains the accumulated register liveness information for the\n  /// instructions in this \\p Candidate.\n  ///\n  /// This is optionally used by the target to determine which registers have\n  /// been used across the sequence.\n  LiveRegUnits UsedInSequence;\n\n  /// Target-specific flags for this Candidate's MBB.\n  unsigned Flags = 0x0;\n\n  /// True if initLRU has been called on this Candidate.\n  bool LRUWasSet = false;\n\n  /// Return the number of instructions in this Candidate.\n  unsigned getLength() const { return Len; }\n\n  /// Return the start index of this candidate.\n  unsigned getStartIdx() const { return StartIdx; }\n\n  /// Return the end index of this candidate.\n  unsigned getEndIdx() const { return StartIdx + Len - 1; }\n\n  /// Set the CallConstructionID and CallOverhead of this candidate to CID and\n  /// CO respectively.\n  void setCallInfo(unsigned CID, unsigned CO) {\n    CallConstructionID = CID;\n    CallOverhead = CO;\n  }\n\n  /// Returns the call overhead of this candidate if it is in the list.\n  unsigned getCallOverhead() const { return CallOverhead; }\n\n  MachineBasicBlock::iterator &front() { return FirstInst; }\n  MachineBasicBlock::iterator &back() { return LastInst; }\n  MachineFunction *getMF() const { return MBB->getParent(); }\n  MachineBasicBlock *getMBB() const { return MBB; }\n\n  /// The number of instructions that would be saved by outlining every\n  /// candidate of this type.\n  ///\n  /// This is a fixed value which is not updated during the candidate pruning\n  /// process. It is only used for deciding which candidate to keep if two\n  /// candidates overlap. The true benefit is stored in the OutlinedFunction\n  /// for some given candidate.\n  unsigned Benefit = 0;\n\n  Candidate(unsigned StartIdx, unsigned Len,\n            MachineBasicBlock::iterator &FirstInst,\n            MachineBasicBlock::iterator &LastInst, MachineBasicBlock *MBB,\n            unsigned FunctionIdx, unsigned Flags)\n      : StartIdx(StartIdx), Len(Len), FirstInst(FirstInst), LastInst(LastInst),\n        MBB(MBB), FunctionIdx(FunctionIdx), Flags(Flags) {}\n  Candidate() {}\n\n  /// Used to ensure that \\p Candidates are outlined in an order that\n  /// preserves the start and end indices of other \\p Candidates.\n  bool operator<(const Candidate &RHS) const {\n    return getStartIdx() > RHS.getStartIdx();\n  }\n\n  /// Compute the registers that are live across this Candidate.\n  /// Used by targets that need this information for cost model calculation.\n  /// If a target does not need this information, then this should not be\n  /// called.\n  void initLRU(const TargetRegisterInfo &TRI) {\n    assert(MBB->getParent()->getRegInfo().tracksLiveness() &&\n           \"Candidate's Machine Function must track liveness\");\n    // Only initialize once.\n    if (LRUWasSet)\n      return;\n    LRUWasSet = true;\n    LRU.init(TRI);\n    LRU.addLiveOuts(*MBB);\n\n    // Compute liveness from the end of the block up to the beginning of the\n    // outlining candidate.\n    std::for_each(MBB->rbegin(), (MachineBasicBlock::reverse_iterator)front(),\n                  [this](MachineInstr &MI) { LRU.stepBackward(MI); });\n\n    // Walk over the sequence itself and figure out which registers were used\n    // in the sequence.\n    UsedInSequence.init(TRI);\n    std::for_each(front(), std::next(back()),\n                  [this](MachineInstr &MI) { UsedInSequence.accumulate(MI); });\n  }\n};\n\n/// The information necessary to create an outlined function for some\n/// class of candidate.\nstruct OutlinedFunction {\n\npublic:\n  std::vector<Candidate> Candidates;\n\n  /// The actual outlined function created.\n  /// This is initialized after we go through and create the actual function.\n  MachineFunction *MF = nullptr;\n\n  /// Represents the size of a sequence in bytes. (Some instructions vary\n  /// widely in size, so just counting the instructions isn't very useful.)\n  unsigned SequenceSize = 0;\n\n  /// Target-defined overhead of constructing a frame for this function.\n  unsigned FrameOverhead = 0;\n\n  /// Target-defined identifier for constructing a frame for this function.\n  unsigned FrameConstructionID = 0;\n\n  /// Return the number of candidates for this \\p OutlinedFunction.\n  unsigned getOccurrenceCount() const { return Candidates.size(); }\n\n  /// Return the number of bytes it would take to outline this\n  /// function.\n  unsigned getOutliningCost() const {\n    unsigned CallOverhead = 0;\n    for (const Candidate &C : Candidates)\n      CallOverhead += C.getCallOverhead();\n    return CallOverhead + SequenceSize + FrameOverhead;\n  }\n\n  /// Return the size in bytes of the unoutlined sequences.\n  unsigned getNotOutlinedCost() const {\n    return getOccurrenceCount() * SequenceSize;\n  }\n\n  /// Return the number of instructions that would be saved by outlining\n  /// this function.\n  unsigned getBenefit() const {\n    unsigned NotOutlinedCost = getNotOutlinedCost();\n    unsigned OutlinedCost = getOutliningCost();\n    return (NotOutlinedCost < OutlinedCost) ? 0\n                                            : NotOutlinedCost - OutlinedCost;\n  }\n\n  /// Return the number of instructions in this sequence.\n  unsigned getNumInstrs() const { return Candidates[0].getLength(); }\n\n  OutlinedFunction(std::vector<Candidate> &Candidates, unsigned SequenceSize,\n                   unsigned FrameOverhead, unsigned FrameConstructionID)\n      : Candidates(Candidates), SequenceSize(SequenceSize),\n        FrameOverhead(FrameOverhead), FrameConstructionID(FrameConstructionID) {\n    const unsigned B = getBenefit();\n    for (Candidate &C : Candidates)\n      C.Benefit = B;\n  }\n\n  OutlinedFunction() {}\n};\n} // namespace outliner\n} // namespace llvm\n\n#endif\n"}, "34": {"id": 34, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h", "content": "//===- llvm/CodeGen/MachineRegisterInfo.h -----------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the MachineRegisterInfo class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_MACHINEREGISTERINFO_H\n#define LLVM_CODEGEN_MACHINEREGISTERINFO_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/BitVector.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/IndexedMap.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringSet.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/CodeGen/GlobalISel/RegisterBank.h\"\n#include \"llvm/CodeGen/LowLevelType.h\"\n#include \"llvm/CodeGen/MachineBasicBlock.h\"\n#include \"llvm/CodeGen/MachineFunction.h\"\n#include \"llvm/CodeGen/MachineInstrBundle.h\"\n#include \"llvm/CodeGen/MachineOperand.h\"\n#include \"llvm/CodeGen/TargetRegisterInfo.h\"\n#include \"llvm/CodeGen/TargetSubtargetInfo.h\"\n#include \"llvm/MC/LaneBitmask.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <memory>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass PSetIterator;\n\n/// Convenient type to represent either a register class or a register bank.\nusing RegClassOrRegBank =\n    PointerUnion<const TargetRegisterClass *, const RegisterBank *>;\n\n/// MachineRegisterInfo - Keep track of information for virtual and physical\n/// registers, including vreg register classes, use/def chains for registers,\n/// etc.\nclass MachineRegisterInfo {\npublic:\n  class Delegate {\n    virtual void anchor();\n\n  public:\n    virtual ~Delegate() = default;\n\n    virtual void MRI_NoteNewVirtualRegister(Register Reg) = 0;\n  };\n\nprivate:\n  MachineFunction *MF;\n  Delegate *TheDelegate = nullptr;\n\n  /// True if subregister liveness is tracked.\n  const bool TracksSubRegLiveness;\n\n  /// VRegInfo - Information we keep for each virtual register.\n  ///\n  /// Each element in this list contains the register class of the vreg and the\n  /// start of the use/def list for the register.\n  IndexedMap<std::pair<RegClassOrRegBank, MachineOperand *>,\n             VirtReg2IndexFunctor>\n      VRegInfo;\n\n  /// Map for recovering vreg name from vreg number.\n  /// This map is used by the MIR Printer.\n  IndexedMap<std::string, VirtReg2IndexFunctor> VReg2Name;\n\n  /// StringSet that is used to unique vreg names.\n  StringSet<> VRegNames;\n\n  /// The flag is true upon \\p UpdatedCSRs initialization\n  /// and false otherwise.\n  bool IsUpdatedCSRsInitialized;\n\n  /// Contains the updated callee saved register list.\n  /// As opposed to the static list defined in register info,\n  /// all registers that were disabled are removed from the list.\n  SmallVector<MCPhysReg, 16> UpdatedCSRs;\n\n  /// RegAllocHints - This vector records register allocation hints for\n  /// virtual registers. For each virtual register, it keeps a pair of hint\n  /// type and hints vector making up the allocation hints. Only the first\n  /// hint may be target specific, and in that case this is reflected by the\n  /// first member of the pair being non-zero. If the hinted register is\n  /// virtual, it means the allocator should prefer the physical register\n  /// allocated to it if any.\n  IndexedMap<std::pair<Register, SmallVector<Register, 4>>,\n             VirtReg2IndexFunctor> RegAllocHints;\n\n  /// PhysRegUseDefLists - This is an array of the head of the use/def list for\n  /// physical registers.\n  std::unique_ptr<MachineOperand *[]> PhysRegUseDefLists;\n\n  /// getRegUseDefListHead - Return the head pointer for the register use/def\n  /// list for the specified virtual or physical register.\n  MachineOperand *&getRegUseDefListHead(Register RegNo) {\n    if (RegNo.isVirtual())\n      return VRegInfo[RegNo.id()].second;\n    return PhysRegUseDefLists[RegNo.id()];\n  }\n\n  MachineOperand *getRegUseDefListHead(Register RegNo) const {\n    if (RegNo.isVirtual())\n      return VRegInfo[RegNo.id()].second;\n    return PhysRegUseDefLists[RegNo.id()];\n  }\n\n  /// Get the next element in the use-def chain.\n  static MachineOperand *getNextOperandForReg(const MachineOperand *MO) {\n    assert(MO && MO->isReg() && \"This is not a register operand!\");\n    return MO->Contents.Reg.Next;\n  }\n\n  /// UsedPhysRegMask - Additional used physregs including aliases.\n  /// This bit vector represents all the registers clobbered by function calls.\n  BitVector UsedPhysRegMask;\n\n  /// ReservedRegs - This is a bit vector of reserved registers.  The target\n  /// may change its mind about which registers should be reserved.  This\n  /// vector is the frozen set of reserved registers when register allocation\n  /// started.\n  BitVector ReservedRegs;\n\n  using VRegToTypeMap = IndexedMap<LLT, VirtReg2IndexFunctor>;\n  /// Map generic virtual registers to their low-level type.\n  VRegToTypeMap VRegToType;\n\n  /// Keep track of the physical registers that are live in to the function.\n  /// Live in values are typically arguments in registers.  LiveIn values are\n  /// allowed to have virtual registers associated with them, stored in the\n  /// second element.\n  std::vector<std::pair<MCRegister, Register>> LiveIns;\n\npublic:\n  explicit MachineRegisterInfo(MachineFunction *MF);\n  MachineRegisterInfo(const MachineRegisterInfo &) = delete;\n  MachineRegisterInfo &operator=(const MachineRegisterInfo &) = delete;\n\n  const TargetRegisterInfo *getTargetRegisterInfo() const {\n    return MF->getSubtarget().getRegisterInfo();\n  }\n\n  void resetDelegate(Delegate *delegate) {\n    // Ensure another delegate does not take over unless the current\n    // delegate first unattaches itself. If we ever need to multicast\n    // notifications, we will need to change to using a list.\n    assert(TheDelegate == delegate &&\n           \"Only the current delegate can perform reset!\");\n    TheDelegate = nullptr;\n  }\n\n  void setDelegate(Delegate *delegate) {\n    assert(delegate && !TheDelegate &&\n           \"Attempted to set delegate to null, or to change it without \"\n           \"first resetting it!\");\n\n    TheDelegate = delegate;\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Function State\n  //===--------------------------------------------------------------------===//\n\n  // isSSA - Returns true when the machine function is in SSA form. Early\n  // passes require the machine function to be in SSA form where every virtual\n  // register has a single defining instruction.\n  //\n  // The TwoAddressInstructionPass and PHIElimination passes take the machine\n  // function out of SSA form when they introduce multiple defs per virtual\n  // register.\n  bool isSSA() const {\n    return MF->getProperties().hasProperty(\n        MachineFunctionProperties::Property::IsSSA);\n  }\n\n  // leaveSSA - Indicates that the machine function is no longer in SSA form.\n  void leaveSSA() {\n    MF->getProperties().reset(MachineFunctionProperties::Property::IsSSA);\n  }\n\n  /// tracksLiveness - Returns true when tracking register liveness accurately.\n  /// (see MachineFUnctionProperties::Property description for details)\n  bool tracksLiveness() const {\n    return MF->getProperties().hasProperty(\n        MachineFunctionProperties::Property::TracksLiveness);\n  }\n\n  /// invalidateLiveness - Indicates that register liveness is no longer being\n  /// tracked accurately.\n  ///\n  /// This should be called by late passes that invalidate the liveness\n  /// information.\n  void invalidateLiveness() {\n    MF->getProperties().reset(\n        MachineFunctionProperties::Property::TracksLiveness);\n  }\n\n  /// Returns true if liveness for register class @p RC should be tracked at\n  /// the subregister level.\n  bool shouldTrackSubRegLiveness(const TargetRegisterClass &RC) const {\n    return subRegLivenessEnabled() && RC.HasDisjunctSubRegs;\n  }\n  bool shouldTrackSubRegLiveness(Register VReg) const {\n    assert(VReg.isVirtual() && \"Must pass a VReg\");\n    return shouldTrackSubRegLiveness(*getRegClass(VReg));\n  }\n  bool subRegLivenessEnabled() const {\n    return TracksSubRegLiveness;\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Register Info\n  //===--------------------------------------------------------------------===//\n\n  /// Returns true if the updated CSR list was initialized and false otherwise.\n  bool isUpdatedCSRsInitialized() const { return IsUpdatedCSRsInitialized; }\n\n  /// Disables the register from the list of CSRs.\n  /// I.e. the register will not appear as part of the CSR mask.\n  /// \\see UpdatedCalleeSavedRegs.\n  void disableCalleeSavedRegister(MCRegister Reg);\n\n  /// Returns list of callee saved registers.\n  /// The function returns the updated CSR list (after taking into account\n  /// registers that are disabled from the CSR list).\n  const MCPhysReg *getCalleeSavedRegs() const;\n\n  /// Sets the updated Callee Saved Registers list.\n  /// Notice that it will override ant previously disabled/saved CSRs.\n  void setCalleeSavedRegs(ArrayRef<MCPhysReg> CSRs);\n\n  // Strictly for use by MachineInstr.cpp.\n  void addRegOperandToUseList(MachineOperand *MO);\n\n  // Strictly for use by MachineInstr.cpp.\n  void removeRegOperandFromUseList(MachineOperand *MO);\n\n  // Strictly for use by MachineInstr.cpp.\n  void moveOperands(MachineOperand *Dst, MachineOperand *Src, unsigned NumOps);\n\n  /// Verify the sanity of the use list for Reg.\n  void verifyUseList(Register Reg) const;\n\n  /// Verify the use list of all registers.\n  void verifyUseLists() const;\n\n  /// reg_begin/reg_end - Provide iteration support to walk over all definitions\n  /// and uses of a register within the MachineFunction that corresponds to this\n  /// MachineRegisterInfo object.\n  template<bool Uses, bool Defs, bool SkipDebug,\n           bool ByOperand, bool ByInstr, bool ByBundle>\n  class defusechain_iterator;\n  template<bool Uses, bool Defs, bool SkipDebug,\n           bool ByOperand, bool ByInstr, bool ByBundle>\n  class defusechain_instr_iterator;\n\n  // Make it a friend so it can access getNextOperandForReg().\n  template<bool, bool, bool, bool, bool, bool>\n    friend class defusechain_iterator;\n  template<bool, bool, bool, bool, bool, bool>\n    friend class defusechain_instr_iterator;\n\n  /// reg_iterator/reg_begin/reg_end - Walk all defs and uses of the specified\n  /// register.\n  using reg_iterator =\n      defusechain_iterator<true, true, false, true, false, false>;\n  reg_iterator reg_begin(Register RegNo) const {\n    return reg_iterator(getRegUseDefListHead(RegNo));\n  }\n  static reg_iterator reg_end() { return reg_iterator(nullptr); }\n\n  inline iterator_range<reg_iterator> reg_operands(Register Reg) const {\n    return make_range(reg_begin(Reg), reg_end());\n  }\n\n  /// reg_instr_iterator/reg_instr_begin/reg_instr_end - Walk all defs and uses\n  /// of the specified register, stepping by MachineInstr.\n  using reg_instr_iterator =\n      defusechain_instr_iterator<true, true, false, false, true, false>;\n  reg_instr_iterator reg_instr_begin(Register RegNo) const {\n    return reg_instr_iterator(getRegUseDefListHead(RegNo));\n  }\n  static reg_instr_iterator reg_instr_end() {\n    return reg_instr_iterator(nullptr);\n  }\n\n  inline iterator_range<reg_instr_iterator>\n  reg_instructions(Register Reg) const {\n    return make_range(reg_instr_begin(Reg), reg_instr_end());\n  }\n\n  /// reg_bundle_iterator/reg_bundle_begin/reg_bundle_end - Walk all defs and uses\n  /// of the specified register, stepping by bundle.\n  using reg_bundle_iterator =\n      defusechain_instr_iterator<true, true, false, false, false, true>;\n  reg_bundle_iterator reg_bundle_begin(Register RegNo) const {\n    return reg_bundle_iterator(getRegUseDefListHead(RegNo));\n  }\n  static reg_bundle_iterator reg_bundle_end() {\n    return reg_bundle_iterator(nullptr);\n  }\n\n  inline iterator_range<reg_bundle_iterator> reg_bundles(Register Reg) const {\n    return make_range(reg_bundle_begin(Reg), reg_bundle_end());\n  }\n\n  /// reg_empty - Return true if there are no instructions using or defining the\n  /// specified register (it may be live-in).\n  bool reg_empty(Register RegNo) const { return reg_begin(RegNo) == reg_end(); }\n\n  /// reg_nodbg_iterator/reg_nodbg_begin/reg_nodbg_end - Walk all defs and uses\n  /// of the specified register, skipping those marked as Debug.\n  using reg_nodbg_iterator =\n      defusechain_iterator<true, true, true, true, false, false>;\n  reg_nodbg_iterator reg_nodbg_begin(Register RegNo) const {\n    return reg_nodbg_iterator(getRegUseDefListHead(RegNo));\n  }\n  static reg_nodbg_iterator reg_nodbg_end() {\n    return reg_nodbg_iterator(nullptr);\n  }\n\n  inline iterator_range<reg_nodbg_iterator>\n  reg_nodbg_operands(Register Reg) const {\n    return make_range(reg_nodbg_begin(Reg), reg_nodbg_end());\n  }\n\n  /// reg_instr_nodbg_iterator/reg_instr_nodbg_begin/reg_instr_nodbg_end - Walk\n  /// all defs and uses of the specified register, stepping by MachineInstr,\n  /// skipping those marked as Debug.\n  using reg_instr_nodbg_iterator =\n      defusechain_instr_iterator<true, true, true, false, true, false>;\n  reg_instr_nodbg_iterator reg_instr_nodbg_begin(Register RegNo) const {\n    return reg_instr_nodbg_iterator(getRegUseDefListHead(RegNo));\n  }\n  static reg_instr_nodbg_iterator reg_instr_nodbg_end() {\n    return reg_instr_nodbg_iterator(nullptr);\n  }\n\n  inline iterator_range<reg_instr_nodbg_iterator>\n  reg_nodbg_instructions(Register Reg) const {\n    return make_range(reg_instr_nodbg_begin(Reg), reg_instr_nodbg_end());\n  }\n\n  /// reg_bundle_nodbg_iterator/reg_bundle_nodbg_begin/reg_bundle_nodbg_end - Walk\n  /// all defs and uses of the specified register, stepping by bundle,\n  /// skipping those marked as Debug.\n  using reg_bundle_nodbg_iterator =\n      defusechain_instr_iterator<true, true, true, false, false, true>;\n  reg_bundle_nodbg_iterator reg_bundle_nodbg_begin(Register RegNo) const {\n    return reg_bundle_nodbg_iterator(getRegUseDefListHead(RegNo));\n  }\n  static reg_bundle_nodbg_iterator reg_bundle_nodbg_end() {\n    return reg_bundle_nodbg_iterator(nullptr);\n  }\n\n  inline iterator_range<reg_bundle_nodbg_iterator>\n  reg_nodbg_bundles(Register Reg) const {\n    return make_range(reg_bundle_nodbg_begin(Reg), reg_bundle_nodbg_end());\n  }\n\n  /// reg_nodbg_empty - Return true if the only instructions using or defining\n  /// Reg are Debug instructions.\n  bool reg_nodbg_empty(Register RegNo) const {\n    return reg_nodbg_begin(RegNo) == reg_nodbg_end();\n  }\n\n  /// def_iterator/def_begin/def_end - Walk all defs of the specified register.\n  using def_iterator =\n      defusechain_iterator<false, true, false, true, false, false>;\n  def_iterator def_begin(Register RegNo) const {\n    return def_iterator(getRegUseDefListHead(RegNo));\n  }\n  static def_iterator def_end() { return def_iterator(nullptr); }\n\n  inline iterator_range<def_iterator> def_operands(Register Reg) const {\n    return make_range(def_begin(Reg), def_end());\n  }\n\n  /// def_instr_iterator/def_instr_begin/def_instr_end - Walk all defs of the\n  /// specified register, stepping by MachineInst.\n  using def_instr_iterator =\n      defusechain_instr_iterator<false, true, false, false, true, false>;\n  def_instr_iterator def_instr_begin(Register RegNo) const {\n    return def_instr_iterator(getRegUseDefListHead(RegNo));\n  }\n  static def_instr_iterator def_instr_end() {\n    return def_instr_iterator(nullptr);\n  }\n\n  inline iterator_range<def_instr_iterator>\n  def_instructions(Register Reg) const {\n    return make_range(def_instr_begin(Reg), def_instr_end());\n  }\n\n  /// def_bundle_iterator/def_bundle_begin/def_bundle_end - Walk all defs of the\n  /// specified register, stepping by bundle.\n  using def_bundle_iterator =\n      defusechain_instr_iterator<false, true, false, false, false, true>;\n  def_bundle_iterator def_bundle_begin(Register RegNo) const {\n    return def_bundle_iterator(getRegUseDefListHead(RegNo));\n  }\n  static def_bundle_iterator def_bundle_end() {\n    return def_bundle_iterator(nullptr);\n  }\n\n  inline iterator_range<def_bundle_iterator> def_bundles(Register Reg) const {\n    return make_range(def_bundle_begin(Reg), def_bundle_end());\n  }\n\n  /// def_empty - Return true if there are no instructions defining the\n  /// specified register (it may be live-in).\n  bool def_empty(Register RegNo) const { return def_begin(RegNo) == def_end(); }\n\n  StringRef getVRegName(Register Reg) const {\n    return VReg2Name.inBounds(Reg) ? StringRef(VReg2Name[Reg]) : \"\";\n  }\n\n  void insertVRegByName(StringRef Name, Register Reg) {\n    assert((Name.empty() || VRegNames.find(Name) == VRegNames.end()) &&\n           \"Named VRegs Must be Unique.\");\n    if (!Name.empty()) {\n      VRegNames.insert(Name);\n      VReg2Name.grow(Reg);\n      VReg2Name[Reg] = Name.str();\n    }\n  }\n\n  /// Return true if there is exactly one operand defining the specified\n  /// register.\n  bool hasOneDef(Register RegNo) const {\n    return hasSingleElement(def_operands(RegNo));\n  }\n\n  /// Returns the defining operand if there is exactly one operand defining the\n  /// specified register, otherwise nullptr.\n  MachineOperand *getOneDef(Register Reg) const {\n    def_iterator DI = def_begin(Reg);\n    if (DI == def_end()) // No defs.\n      return nullptr;\n\n    def_iterator OneDef = DI;\n    if (++DI == def_end())\n      return &*OneDef;\n    return nullptr; // Multiple defs.\n  }\n\n  /// use_iterator/use_begin/use_end - Walk all uses of the specified register.\n  using use_iterator =\n      defusechain_iterator<true, false, false, true, false, false>;\n  use_iterator use_begin(Register RegNo) const {\n    return use_iterator(getRegUseDefListHead(RegNo));\n  }\n  static use_iterator use_end() { return use_iterator(nullptr); }\n\n  inline iterator_range<use_iterator> use_operands(Register Reg) const {\n    return make_range(use_begin(Reg), use_end());\n  }\n\n  /// use_instr_iterator/use_instr_begin/use_instr_end - Walk all uses of the\n  /// specified register, stepping by MachineInstr.\n  using use_instr_iterator =\n      defusechain_instr_iterator<true, false, false, false, true, false>;\n  use_instr_iterator use_instr_begin(Register RegNo) const {\n    return use_instr_iterator(getRegUseDefListHead(RegNo));\n  }\n  static use_instr_iterator use_instr_end() {\n    return use_instr_iterator(nullptr);\n  }\n\n  inline iterator_range<use_instr_iterator>\n  use_instructions(Register Reg) const {\n    return make_range(use_instr_begin(Reg), use_instr_end());\n  }\n\n  /// use_bundle_iterator/use_bundle_begin/use_bundle_end - Walk all uses of the\n  /// specified register, stepping by bundle.\n  using use_bundle_iterator =\n      defusechain_instr_iterator<true, false, false, false, false, true>;\n  use_bundle_iterator use_bundle_begin(Register RegNo) const {\n    return use_bundle_iterator(getRegUseDefListHead(RegNo));\n  }\n  static use_bundle_iterator use_bundle_end() {\n    return use_bundle_iterator(nullptr);\n  }\n\n  inline iterator_range<use_bundle_iterator> use_bundles(Register Reg) const {\n    return make_range(use_bundle_begin(Reg), use_bundle_end());\n  }\n\n  /// use_empty - Return true if there are no instructions using the specified\n  /// register.\n  bool use_empty(Register RegNo) const { return use_begin(RegNo) == use_end(); }\n\n  /// hasOneUse - Return true if there is exactly one instruction using the\n  /// specified register.\n  bool hasOneUse(Register RegNo) const {\n    return hasSingleElement(use_operands(RegNo));\n  }\n\n  /// use_nodbg_iterator/use_nodbg_begin/use_nodbg_end - Walk all uses of the\n  /// specified register, skipping those marked as Debug.\n  using use_nodbg_iterator =\n      defusechain_iterator<true, false, true, true, false, false>;\n  use_nodbg_iterator use_nodbg_begin(Register RegNo) const {\n    return use_nodbg_iterator(getRegUseDefListHead(RegNo));\n  }\n  static use_nodbg_iterator use_nodbg_end() {\n    return use_nodbg_iterator(nullptr);\n  }\n\n  inline iterator_range<use_nodbg_iterator>\n  use_nodbg_operands(Register Reg) const {\n    return make_range(use_nodbg_begin(Reg), use_nodbg_end());\n  }\n\n  /// use_instr_nodbg_iterator/use_instr_nodbg_begin/use_instr_nodbg_end - Walk\n  /// all uses of the specified register, stepping by MachineInstr, skipping\n  /// those marked as Debug.\n  using use_instr_nodbg_iterator =\n      defusechain_instr_iterator<true, false, true, false, true, false>;\n  use_instr_nodbg_iterator use_instr_nodbg_begin(Register RegNo) const {\n    return use_instr_nodbg_iterator(getRegUseDefListHead(RegNo));\n  }\n  static use_instr_nodbg_iterator use_instr_nodbg_end() {\n    return use_instr_nodbg_iterator(nullptr);\n  }\n\n  inline iterator_range<use_instr_nodbg_iterator>\n  use_nodbg_instructions(Register Reg) const {\n    return make_range(use_instr_nodbg_begin(Reg), use_instr_nodbg_end());\n  }\n\n  /// use_bundle_nodbg_iterator/use_bundle_nodbg_begin/use_bundle_nodbg_end - Walk\n  /// all uses of the specified register, stepping by bundle, skipping\n  /// those marked as Debug.\n  using use_bundle_nodbg_iterator =\n      defusechain_instr_iterator<true, false, true, false, false, true>;\n  use_bundle_nodbg_iterator use_bundle_nodbg_begin(Register RegNo) const {\n    return use_bundle_nodbg_iterator(getRegUseDefListHead(RegNo));\n  }\n  static use_bundle_nodbg_iterator use_bundle_nodbg_end() {\n    return use_bundle_nodbg_iterator(nullptr);\n  }\n\n  inline iterator_range<use_bundle_nodbg_iterator>\n  use_nodbg_bundles(Register Reg) const {\n    return make_range(use_bundle_nodbg_begin(Reg), use_bundle_nodbg_end());\n  }\n\n  /// use_nodbg_empty - Return true if there are no non-Debug instructions\n  /// using the specified register.\n  bool use_nodbg_empty(Register RegNo) const {\n    return use_nodbg_begin(RegNo) == use_nodbg_end();\n  }\n\n  /// hasOneNonDBGUse - Return true if there is exactly one non-Debug\n  /// use of the specified register.\n  bool hasOneNonDBGUse(Register RegNo) const;\n\n  /// hasOneNonDBGUse - Return true if there is exactly one non-Debug\n  /// instruction using the specified register. Said instruction may have\n  /// multiple uses.\n  bool hasOneNonDBGUser(Register RegNo) const;\n\n  /// replaceRegWith - Replace all instances of FromReg with ToReg in the\n  /// machine function.  This is like llvm-level X->replaceAllUsesWith(Y),\n  /// except that it also changes any definitions of the register as well.\n  ///\n  /// Note that it is usually necessary to first constrain ToReg's register\n  /// class and register bank to match the FromReg constraints using one of the\n  /// methods:\n  ///\n  ///   constrainRegClass(ToReg, getRegClass(FromReg))\n  ///   constrainRegAttrs(ToReg, FromReg)\n  ///   RegisterBankInfo::constrainGenericRegister(ToReg,\n  ///       *MRI.getRegClass(FromReg), MRI)\n  ///\n  /// These functions will return a falsy result if the virtual registers have\n  /// incompatible constraints.\n  ///\n  /// Note that if ToReg is a physical register the function will replace and\n  /// apply sub registers to ToReg in order to obtain a final/proper physical\n  /// register.\n  void replaceRegWith(Register FromReg, Register ToReg);\n\n  /// getVRegDef - Return the machine instr that defines the specified virtual\n  /// register or null if none is found.  This assumes that the code is in SSA\n  /// form, so there should only be one definition.\n  MachineInstr *getVRegDef(Register Reg) const;\n\n  /// getUniqueVRegDef - Return the unique machine instr that defines the\n  /// specified virtual register or null if none is found.  If there are\n  /// multiple definitions or no definition, return null.\n  MachineInstr *getUniqueVRegDef(Register Reg) const;\n\n  /// clearKillFlags - Iterate over all the uses of the given register and\n  /// clear the kill flag from the MachineOperand. This function is used by\n  /// optimization passes which extend register lifetimes and need only\n  /// preserve conservative kill flag information.\n  void clearKillFlags(Register Reg) const;\n\n  void dumpUses(Register RegNo) const;\n\n  /// Returns true if PhysReg is unallocatable and constant throughout the\n  /// function. Writing to a constant register has no effect.\n  bool isConstantPhysReg(MCRegister PhysReg) const;\n\n  /// Get an iterator over the pressure sets affected by the given physical or\n  /// virtual register. If RegUnit is physical, it must be a register unit (from\n  /// MCRegUnitIterator).\n  PSetIterator getPressureSets(Register RegUnit) const;\n\n  //===--------------------------------------------------------------------===//\n  // Virtual Register Info\n  //===--------------------------------------------------------------------===//\n\n  /// Return the register class of the specified virtual register.\n  /// This shouldn't be used directly unless \\p Reg has a register class.\n  /// \\see getRegClassOrNull when this might happen.\n  const TargetRegisterClass *getRegClass(Register Reg) const {\n    assert(VRegInfo[Reg.id()].first.is<const TargetRegisterClass *>() &&\n           \"Register class not set, wrong accessor\");\n    return VRegInfo[Reg.id()].first.get<const TargetRegisterClass *>();\n  }\n\n  /// Return the register class of \\p Reg, or null if Reg has not been assigned\n  /// a register class yet.\n  ///\n  /// \\note A null register class can only happen when these two\n  /// conditions are met:\n  /// 1. Generic virtual registers are created.\n  /// 2. The machine function has not completely been through the\n  ///    instruction selection process.\n  /// None of this condition is possible without GlobalISel for now.\n  /// In other words, if GlobalISel is not used or if the query happens after\n  /// the select pass, using getRegClass is safe.\n  const TargetRegisterClass *getRegClassOrNull(Register Reg) const {\n    const RegClassOrRegBank &Val = VRegInfo[Reg].first;\n    return Val.dyn_cast<const TargetRegisterClass *>();\n  }\n\n  /// Return the register bank of \\p Reg, or null if Reg has not been assigned\n  /// a register bank or has been assigned a register class.\n  /// \\note It is possible to get the register bank from the register class via\n  /// RegisterBankInfo::getRegBankFromRegClass.\n  const RegisterBank *getRegBankOrNull(Register Reg) const {\n    const RegClassOrRegBank &Val = VRegInfo[Reg].first;\n    return Val.dyn_cast<const RegisterBank *>();\n  }\n\n  /// Return the register bank or register class of \\p Reg.\n  /// \\note Before the register bank gets assigned (i.e., before the\n  /// RegBankSelect pass) \\p Reg may not have either.\n  const RegClassOrRegBank &getRegClassOrRegBank(Register Reg) const {\n    return VRegInfo[Reg].first;\n  }\n\n  /// setRegClass - Set the register class of the specified virtual register.\n  void setRegClass(Register Reg, const TargetRegisterClass *RC);\n\n  /// Set the register bank to \\p RegBank for \\p Reg.\n  void setRegBank(Register Reg, const RegisterBank &RegBank);\n\n  void setRegClassOrRegBank(Register Reg,\n                            const RegClassOrRegBank &RCOrRB){\n    VRegInfo[Reg].first = RCOrRB;\n  }\n\n  /// constrainRegClass - Constrain the register class of the specified virtual\n  /// register to be a common subclass of RC and the current register class,\n  /// but only if the new class has at least MinNumRegs registers.  Return the\n  /// new register class, or NULL if no such class exists.\n  /// This should only be used when the constraint is known to be trivial, like\n  /// GR32 -> GR32_NOSP. Beware of increasing register pressure.\n  ///\n  /// \\note Assumes that the register has a register class assigned.\n  /// Use RegisterBankInfo::constrainGenericRegister in GlobalISel's\n  /// InstructionSelect pass and constrainRegAttrs in every other pass,\n  /// including non-select passes of GlobalISel, instead.\n  const TargetRegisterClass *constrainRegClass(Register Reg,\n                                               const TargetRegisterClass *RC,\n                                               unsigned MinNumRegs = 0);\n\n  /// Constrain the register class or the register bank of the virtual register\n  /// \\p Reg (and low-level type) to be a common subclass or a common bank of\n  /// both registers provided respectively (and a common low-level type). Do\n  /// nothing if any of the attributes (classes, banks, or low-level types) of\n  /// the registers are deemed incompatible, or if the resulting register will\n  /// have a class smaller than before and of size less than \\p MinNumRegs.\n  /// Return true if such register attributes exist, false otherwise.\n  ///\n  /// \\note Use this method instead of constrainRegClass and\n  /// RegisterBankInfo::constrainGenericRegister everywhere but SelectionDAG\n  /// ISel / FastISel and GlobalISel's InstructionSelect pass respectively.\n  bool constrainRegAttrs(Register Reg, Register ConstrainingReg,\n                         unsigned MinNumRegs = 0);\n\n  /// recomputeRegClass - Try to find a legal super-class of Reg's register\n  /// class that still satisfies the constraints from the instructions using\n  /// Reg.  Returns true if Reg was upgraded.\n  ///\n  /// This method can be used after constraints have been removed from a\n  /// virtual register, for example after removing instructions or splitting\n  /// the live range.\n  bool recomputeRegClass(Register Reg);\n\n  /// createVirtualRegister - Create and return a new virtual register in the\n  /// function with the specified register class.\n  Register createVirtualRegister(const TargetRegisterClass *RegClass,\n                                 StringRef Name = \"\");\n\n  /// Create and return a new virtual register in the function with the same\n  /// attributes as the given register.\n  Register cloneVirtualRegister(Register VReg, StringRef Name = \"\");\n\n  /// Get the low-level type of \\p Reg or LLT{} if Reg is not a generic\n  /// (target independent) virtual register.\n  LLT getType(Register Reg) const {\n    if (Register::isVirtualRegister(Reg) && VRegToType.inBounds(Reg))\n      return VRegToType[Reg];\n    return LLT{};\n  }\n\n  /// Set the low-level type of \\p VReg to \\p Ty.\n  void setType(Register VReg, LLT Ty);\n\n  /// Create and return a new generic virtual register with low-level\n  /// type \\p Ty.\n  Register createGenericVirtualRegister(LLT Ty, StringRef Name = \"\");\n\n  /// Remove all types associated to virtual registers (after instruction\n  /// selection and constraining of all generic virtual registers).\n  void clearVirtRegTypes();\n\n  /// Creates a new virtual register that has no register class, register bank\n  /// or size assigned yet. This is only allowed to be used\n  /// temporarily while constructing machine instructions. Most operations are\n  /// undefined on an incomplete register until one of setRegClass(),\n  /// setRegBank() or setSize() has been called on it.\n  Register createIncompleteVirtualRegister(StringRef Name = \"\");\n\n  /// getNumVirtRegs - Return the number of virtual registers created.\n  unsigned getNumVirtRegs() const { return VRegInfo.size(); }\n\n  /// clearVirtRegs - Remove all virtual registers (after physreg assignment).\n  void clearVirtRegs();\n\n  /// setRegAllocationHint - Specify a register allocation hint for the\n  /// specified virtual register. This is typically used by target, and in case\n  /// of an earlier hint it will be overwritten.\n  void setRegAllocationHint(Register VReg, unsigned Type, Register PrefReg) {\n    assert(VReg.isVirtual());\n    RegAllocHints[VReg].first  = Type;\n    RegAllocHints[VReg].second.clear();\n    RegAllocHints[VReg].second.push_back(PrefReg);\n  }\n\n  /// addRegAllocationHint - Add a register allocation hint to the hints\n  /// vector for VReg.\n  void addRegAllocationHint(Register VReg, Register PrefReg) {\n    assert(Register::isVirtualRegister(VReg));\n    RegAllocHints[VReg].second.push_back(PrefReg);\n  }\n\n  /// Specify the preferred (target independent) register allocation hint for\n  /// the specified virtual register.\n  void setSimpleHint(Register VReg, Register PrefReg) {\n    setRegAllocationHint(VReg, /*Type=*/0, PrefReg);\n  }\n\n  void clearSimpleHint(Register VReg) {\n    assert (!RegAllocHints[VReg].first &&\n            \"Expected to clear a non-target hint!\");\n    RegAllocHints[VReg].second.clear();\n  }\n\n  /// getRegAllocationHint - Return the register allocation hint for the\n  /// specified virtual register. If there are many hints, this returns the\n  /// one with the greatest weight.\n  std::pair<Register, Register>\n  getRegAllocationHint(Register VReg) const {\n    assert(VReg.isVirtual());\n    Register BestHint = (RegAllocHints[VReg.id()].second.size() ?\n                         RegAllocHints[VReg.id()].second[0] : Register());\n    return std::pair<Register, Register>(RegAllocHints[VReg.id()].first,\n                                         BestHint);\n  }\n\n  /// getSimpleHint - same as getRegAllocationHint except it will only return\n  /// a target independent hint.\n  Register getSimpleHint(Register VReg) const {\n    assert(VReg.isVirtual());\n    std::pair<Register, Register> Hint = getRegAllocationHint(VReg);\n    return Hint.first ? Register() : Hint.second;\n  }\n\n  /// getRegAllocationHints - Return a reference to the vector of all\n  /// register allocation hints for VReg.\n  const std::pair<Register, SmallVector<Register, 4>>\n  &getRegAllocationHints(Register VReg) const {\n    assert(VReg.isVirtual());\n    return RegAllocHints[VReg];\n  }\n\n  /// markUsesInDebugValueAsUndef - Mark every DBG_VALUE referencing the\n  /// specified register as undefined which causes the DBG_VALUE to be\n  /// deleted during LiveDebugVariables analysis.\n  void markUsesInDebugValueAsUndef(Register Reg) const;\n\n  /// updateDbgUsersToReg - Update a collection of DBG_VALUE instructions\n  /// to refer to the designated register.\n  void updateDbgUsersToReg(Register Reg,\n                           ArrayRef<MachineInstr*> Users) const {\n    for (MachineInstr *MI : Users) {\n      assert(MI->isDebugInstr());\n      assert(MI->getOperand(0).isReg());\n      MI->getOperand(0).setReg(Reg);\n    }\n  }\n\n  /// Return true if the specified register is modified in this function.\n  /// This checks that no defining machine operands exist for the register or\n  /// any of its aliases. Definitions found on functions marked noreturn are\n  /// ignored, to consider them pass 'true' for optional parameter\n  /// SkipNoReturnDef. The register is also considered modified when it is set\n  /// in the UsedPhysRegMask.\n  bool isPhysRegModified(MCRegister PhysReg, bool SkipNoReturnDef = false) const;\n\n  /// Return true if the specified register is modified or read in this\n  /// function. This checks that no machine operands exist for the register or\n  /// any of its aliases. The register is also considered used when it is set\n  /// in the UsedPhysRegMask.\n  bool isPhysRegUsed(MCRegister PhysReg) const;\n\n  /// addPhysRegsUsedFromRegMask - Mark any registers not in RegMask as used.\n  /// This corresponds to the bit mask attached to register mask operands.\n  void addPhysRegsUsedFromRegMask(const uint32_t *RegMask) {\n    UsedPhysRegMask.setBitsNotInMask(RegMask);\n  }\n\n  const BitVector &getUsedPhysRegsMask() const { return UsedPhysRegMask; }\n\n  //===--------------------------------------------------------------------===//\n  // Reserved Register Info\n  //===--------------------------------------------------------------------===//\n  //\n  // The set of reserved registers must be invariant during register\n  // allocation.  For example, the target cannot suddenly decide it needs a\n  // frame pointer when the register allocator has already used the frame\n  // pointer register for something else.\n  //\n  // These methods can be used by target hooks like hasFP() to avoid changing\n  // the reserved register set during register allocation.\n\n  /// freezeReservedRegs - Called by the register allocator to freeze the set\n  /// of reserved registers before allocation begins.\n  void freezeReservedRegs(const MachineFunction&);\n\n  /// reservedRegsFrozen - Returns true after freezeReservedRegs() was called\n  /// to ensure the set of reserved registers stays constant.\n  bool reservedRegsFrozen() const {\n    return !ReservedRegs.empty();\n  }\n\n  /// canReserveReg - Returns true if PhysReg can be used as a reserved\n  /// register.  Any register can be reserved before freezeReservedRegs() is\n  /// called.\n  bool canReserveReg(MCRegister PhysReg) const {\n    return !reservedRegsFrozen() || ReservedRegs.test(PhysReg);\n  }\n\n  /// getReservedRegs - Returns a reference to the frozen set of reserved\n  /// registers. This method should always be preferred to calling\n  /// TRI::getReservedRegs() when possible.\n  const BitVector &getReservedRegs() const {\n    assert(reservedRegsFrozen() &&\n           \"Reserved registers haven't been frozen yet. \"\n           \"Use TRI::getReservedRegs().\");\n    return ReservedRegs;\n  }\n\n  /// isReserved - Returns true when PhysReg is a reserved register.\n  ///\n  /// Reserved registers may belong to an allocatable register class, but the\n  /// target has explicitly requested that they are not used.\n  bool isReserved(MCRegister PhysReg) const {\n    return getReservedRegs().test(PhysReg.id());\n  }\n\n  /// Returns true when the given register unit is considered reserved.\n  ///\n  /// Register units are considered reserved when for at least one of their\n  /// root registers, the root register and all super registers are reserved.\n  /// This currently iterates the register hierarchy and may be slower than\n  /// expected.\n  bool isReservedRegUnit(unsigned Unit) const;\n\n  /// isAllocatable - Returns true when PhysReg belongs to an allocatable\n  /// register class and it hasn't been reserved.\n  ///\n  /// Allocatable registers may show up in the allocation order of some virtual\n  /// register, so a register allocator needs to track its liveness and\n  /// availability.\n  bool isAllocatable(MCRegister PhysReg) const {\n    return getTargetRegisterInfo()->isInAllocatableClass(PhysReg) &&\n      !isReserved(PhysReg);\n  }\n\n  //===--------------------------------------------------------------------===//\n  // LiveIn Management\n  //===--------------------------------------------------------------------===//\n\n  /// addLiveIn - Add the specified register as a live-in.  Note that it\n  /// is an error to add the same register to the same set more than once.\n  void addLiveIn(MCRegister Reg, Register vreg = Register()) {\n    LiveIns.push_back(std::make_pair(Reg, vreg));\n  }\n\n  // Iteration support for the live-ins set.  It's kept in sorted order\n  // by register number.\n  using livein_iterator =\n      std::vector<std::pair<MCRegister,Register>>::const_iterator;\n  livein_iterator livein_begin() const { return LiveIns.begin(); }\n  livein_iterator livein_end()   const { return LiveIns.end(); }\n  bool            livein_empty() const { return LiveIns.empty(); }\n\n  ArrayRef<std::pair<MCRegister, Register>> liveins() const {\n    return LiveIns;\n  }\n\n  bool isLiveIn(Register Reg) const;\n\n  /// getLiveInPhysReg - If VReg is a live-in virtual register, return the\n  /// corresponding live-in physical register.\n  MCRegister getLiveInPhysReg(Register VReg) const;\n\n  /// getLiveInVirtReg - If PReg is a live-in physical register, return the\n  /// corresponding live-in physical register.\n  Register getLiveInVirtReg(MCRegister PReg) const;\n\n  /// EmitLiveInCopies - Emit copies to initialize livein virtual registers\n  /// into the given entry block.\n  void EmitLiveInCopies(MachineBasicBlock *EntryMBB,\n                        const TargetRegisterInfo &TRI,\n                        const TargetInstrInfo &TII);\n\n  /// Returns a mask covering all bits that can appear in lane masks of\n  /// subregisters of the virtual register @p Reg.\n  LaneBitmask getMaxLaneMaskForVReg(Register Reg) const;\n\n  /// defusechain_iterator - This class provides iterator support for machine\n  /// operands in the function that use or define a specific register.  If\n  /// ReturnUses is true it returns uses of registers, if ReturnDefs is true it\n  /// returns defs.  If neither are true then you are silly and it always\n  /// returns end().  If SkipDebug is true it skips uses marked Debug\n  /// when incrementing.\n  template <bool ReturnUses, bool ReturnDefs, bool SkipDebug, bool ByOperand,\n            bool ByInstr, bool ByBundle>\n  class defusechain_iterator : public std::iterator<std::forward_iterator_tag,\n                                                    MachineOperand, ptrdiff_t> {\n    friend class MachineRegisterInfo;\n\n    MachineOperand *Op = nullptr;\n\n    explicit defusechain_iterator(MachineOperand *op) : Op(op) {\n      // If the first node isn't one we're interested in, advance to one that\n      // we are interested in.\n      if (op) {\n        if ((!ReturnUses && op->isUse()) ||\n            (!ReturnDefs && op->isDef()) ||\n            (SkipDebug && op->isDebug()))\n          advance();\n      }\n    }\n\n    void advance() {\n      assert(Op && \"Cannot increment end iterator!\");\n      Op = getNextOperandForReg(Op);\n\n      // All defs come before the uses, so stop def_iterator early.\n      if (!ReturnUses) {\n        if (Op) {\n          if (Op->isUse())\n            Op = nullptr;\n          else\n            assert(!Op->isDebug() && \"Can't have debug defs\");\n        }\n      } else {\n        // If this is an operand we don't care about, skip it.\n        while (Op && ((!ReturnDefs && Op->isDef()) ||\n                      (SkipDebug && Op->isDebug())))\n          Op = getNextOperandForReg(Op);\n      }\n    }\n\n  public:\n    using reference = std::iterator<std::forward_iterator_tag, MachineOperand,\n                                    ptrdiff_t>::reference;\n    using pointer = std::iterator<std::forward_iterator_tag, MachineOperand,\n                                  ptrdiff_t>::pointer;\n\n    defusechain_iterator() = default;\n\n    bool operator==(const defusechain_iterator &x) const {\n      return Op == x.Op;\n    }\n    bool operator!=(const defusechain_iterator &x) const {\n      return !operator==(x);\n    }\n\n    /// atEnd - return true if this iterator is equal to reg_end() on the value.\n    bool atEnd() const { return Op == nullptr; }\n\n    // Iterator traversal: forward iteration only\n    defusechain_iterator &operator++() {          // Preincrement\n      assert(Op && \"Cannot increment end iterator!\");\n      if (ByOperand)\n        advance();\n      else if (ByInstr) {\n        MachineInstr *P = Op->getParent();\n        do {\n          advance();\n        } while (Op && Op->getParent() == P);\n      } else if (ByBundle) {\n        MachineBasicBlock::instr_iterator P =\n            getBundleStart(Op->getParent()->getIterator());\n        do {\n          advance();\n        } while (Op && getBundleStart(Op->getParent()->getIterator()) == P);\n      }\n\n      return *this;\n    }\n    defusechain_iterator operator++(int) {        // Postincrement\n      defusechain_iterator tmp = *this; ++*this; return tmp;\n    }\n\n    /// getOperandNo - Return the operand # of this MachineOperand in its\n    /// MachineInstr.\n    unsigned getOperandNo() const {\n      assert(Op && \"Cannot dereference end iterator!\");\n      return Op - &Op->getParent()->getOperand(0);\n    }\n\n    // Retrieve a reference to the current operand.\n    MachineOperand &operator*() const {\n      assert(Op && \"Cannot dereference end iterator!\");\n      return *Op;\n    }\n\n    MachineOperand *operator->() const {\n      assert(Op && \"Cannot dereference end iterator!\");\n      return Op;\n    }\n  };\n\n  /// defusechain_iterator - This class provides iterator support for machine\n  /// operands in the function that use or define a specific register.  If\n  /// ReturnUses is true it returns uses of registers, if ReturnDefs is true it\n  /// returns defs.  If neither are true then you are silly and it always\n  /// returns end().  If SkipDebug is true it skips uses marked Debug\n  /// when incrementing.\n  template<bool ReturnUses, bool ReturnDefs, bool SkipDebug,\n           bool ByOperand, bool ByInstr, bool ByBundle>\n  class defusechain_instr_iterator\n    : public std::iterator<std::forward_iterator_tag, MachineInstr, ptrdiff_t> {\n    friend class MachineRegisterInfo;\n\n    MachineOperand *Op = nullptr;\n\n    explicit defusechain_instr_iterator(MachineOperand *op) : Op(op) {\n      // If the first node isn't one we're interested in, advance to one that\n      // we are interested in.\n      if (op) {\n        if ((!ReturnUses && op->isUse()) ||\n            (!ReturnDefs && op->isDef()) ||\n            (SkipDebug && op->isDebug()))\n          advance();\n      }\n    }\n\n    void advance() {\n      assert(Op && \"Cannot increment end iterator!\");\n      Op = getNextOperandForReg(Op);\n\n      // All defs come before the uses, so stop def_iterator early.\n      if (!ReturnUses) {\n        if (Op) {\n          if (Op->isUse())\n            Op = nullptr;\n          else\n            assert(!Op->isDebug() && \"Can't have debug defs\");\n        }\n      } else {\n        // If this is an operand we don't care about, skip it.\n        while (Op && ((!ReturnDefs && Op->isDef()) ||\n                      (SkipDebug && Op->isDebug())))\n          Op = getNextOperandForReg(Op);\n      }\n    }\n\n  public:\n    using reference = std::iterator<std::forward_iterator_tag,\n                                    MachineInstr, ptrdiff_t>::reference;\n    using pointer = std::iterator<std::forward_iterator_tag,\n                                  MachineInstr, ptrdiff_t>::pointer;\n\n    defusechain_instr_iterator() = default;\n\n    bool operator==(const defusechain_instr_iterator &x) const {\n      return Op == x.Op;\n    }\n    bool operator!=(const defusechain_instr_iterator &x) const {\n      return !operator==(x);\n    }\n\n    /// atEnd - return true if this iterator is equal to reg_end() on the value.\n    bool atEnd() const { return Op == nullptr; }\n\n    // Iterator traversal: forward iteration only\n    defusechain_instr_iterator &operator++() {          // Preincrement\n      assert(Op && \"Cannot increment end iterator!\");\n      if (ByOperand)\n        advance();\n      else if (ByInstr) {\n        MachineInstr *P = Op->getParent();\n        do {\n          advance();\n        } while (Op && Op->getParent() == P);\n      } else if (ByBundle) {\n        MachineBasicBlock::instr_iterator P =\n            getBundleStart(Op->getParent()->getIterator());\n        do {\n          advance();\n        } while (Op && getBundleStart(Op->getParent()->getIterator()) == P);\n      }\n\n      return *this;\n    }\n    defusechain_instr_iterator operator++(int) {        // Postincrement\n      defusechain_instr_iterator tmp = *this; ++*this; return tmp;\n    }\n\n    // Retrieve a reference to the current operand.\n    MachineInstr &operator*() const {\n      assert(Op && \"Cannot dereference end iterator!\");\n      if (ByBundle)\n        return *getBundleStart(Op->getParent()->getIterator());\n      return *Op->getParent();\n    }\n\n    MachineInstr *operator->() const { return &operator*(); }\n  };\n};\n\n/// Iterate over the pressure sets affected by the given physical or virtual\n/// register. If Reg is physical, it must be a register unit (from\n/// MCRegUnitIterator).\nclass PSetIterator {\n  const int *PSet = nullptr;\n  unsigned Weight = 0;\n\npublic:\n  PSetIterator() = default;\n\n  PSetIterator(Register RegUnit, const MachineRegisterInfo *MRI) {\n    const TargetRegisterInfo *TRI = MRI->getTargetRegisterInfo();\n    if (RegUnit.isVirtual()) {\n      const TargetRegisterClass *RC = MRI->getRegClass(RegUnit);\n      PSet = TRI->getRegClassPressureSets(RC);\n      Weight = TRI->getRegClassWeight(RC).RegWeight;\n    } else {\n      PSet = TRI->getRegUnitPressureSets(RegUnit);\n      Weight = TRI->getRegUnitWeight(RegUnit);\n    }\n    if (*PSet == -1)\n      PSet = nullptr;\n  }\n\n  bool isValid() const { return PSet; }\n\n  unsigned getWeight() const { return Weight; }\n\n  unsigned operator*() const { return *PSet; }\n\n  void operator++() {\n    assert(isValid() && \"Invalid PSetIterator.\");\n    ++PSet;\n    if (*PSet == -1)\n      PSet = nullptr;\n  }\n};\n\ninline PSetIterator\nMachineRegisterInfo::getPressureSets(Register RegUnit) const {\n  return PSetIterator(RegUnit, this);\n}\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_MACHINEREGISTERINFO_H\n"}, "36": {"id": 36, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h", "content": "//===- llvm/CodeGen/SelectionDAGNodes.h - SelectionDAG Nodes ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the SDNode class and derived classes, which are used to\n// represent the nodes and operations present in a SelectionDAG.  These nodes\n// and operations are machine code level operations, with some similarities to\n// the GCC RTL representation.\n//\n// Clients should include the SelectionDAG.h file instead of this file directly.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_SELECTIONDAGNODES_H\n#define LLVM_CODEGEN_SELECTIONDAGNODES_H\n\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/BitVector.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/GraphTraits.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/ilist_node.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/CodeGen/ISDOpcodes.h\"\n#include \"llvm/CodeGen/MachineMemOperand.h\"\n#include \"llvm/CodeGen/Register.h\"\n#include \"llvm/CodeGen/ValueTypes.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/DebugLoc.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/Metadata.h\"\n#include \"llvm/IR/Operator.h\"\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/AtomicOrdering.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/MachineValueType.h\"\n#include \"llvm/Support/TypeSize.h\"\n#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cstddef>\n#include <cstdint>\n#include <cstring>\n#include <iterator>\n#include <string>\n#include <tuple>\n\nnamespace llvm {\n\nclass APInt;\nclass Constant;\ntemplate <typename T> struct DenseMapInfo;\nclass GlobalValue;\nclass MachineBasicBlock;\nclass MachineConstantPoolValue;\nclass MCSymbol;\nclass raw_ostream;\nclass SDNode;\nclass SelectionDAG;\nclass Type;\nclass Value;\n\nvoid checkForCycles(const SDNode *N, const SelectionDAG *DAG = nullptr,\n                    bool force = false);\n\n/// This represents a list of ValueType's that has been intern'd by\n/// a SelectionDAG.  Instances of this simple value class are returned by\n/// SelectionDAG::getVTList(...).\n///\nstruct SDVTList {\n  const EVT *VTs;\n  unsigned int NumVTs;\n};\n\nnamespace ISD {\n\n  /// Node predicates\n\n/// If N is a BUILD_VECTOR or SPLAT_VECTOR node whose elements are all the\n/// same constant or undefined, return true and return the constant value in\n/// \\p SplatValue.\nbool isConstantSplatVector(const SDNode *N, APInt &SplatValue);\n\n/// Return true if the specified node is a BUILD_VECTOR or SPLAT_VECTOR where\n/// all of the elements are ~0 or undef. If \\p BuildVectorOnly is set to\n/// true, it only checks BUILD_VECTOR.\nbool isConstantSplatVectorAllOnes(const SDNode *N,\n                                  bool BuildVectorOnly = false);\n\n/// Return true if the specified node is a BUILD_VECTOR or SPLAT_VECTOR where\n/// all of the elements are 0 or undef. If \\p BuildVectorOnly is set to true, it\n/// only checks BUILD_VECTOR.\nbool isConstantSplatVectorAllZeros(const SDNode *N,\n                                   bool BuildVectorOnly = false);\n\n/// Return true if the specified node is a BUILD_VECTOR where all of the\n/// elements are ~0 or undef.\nbool isBuildVectorAllOnes(const SDNode *N);\n\n/// Return true if the specified node is a BUILD_VECTOR where all of the\n/// elements are 0 or undef.\nbool isBuildVectorAllZeros(const SDNode *N);\n\n/// Return true if the specified node is a BUILD_VECTOR node of all\n/// ConstantSDNode or undef.\nbool isBuildVectorOfConstantSDNodes(const SDNode *N);\n\n/// Return true if the specified node is a BUILD_VECTOR node of all\n/// ConstantFPSDNode or undef.\nbool isBuildVectorOfConstantFPSDNodes(const SDNode *N);\n\n/// Return true if the node has at least one operand and all operands of the\n/// specified node are ISD::UNDEF.\nbool allOperandsUndef(const SDNode *N);\n\n} // end namespace ISD\n\n//===----------------------------------------------------------------------===//\n/// Unlike LLVM values, Selection DAG nodes may return multiple\n/// values as the result of a computation.  Many nodes return multiple values,\n/// from loads (which define a token and a return value) to ADDC (which returns\n/// a result and a carry value), to calls (which may return an arbitrary number\n/// of values).\n///\n/// As such, each use of a SelectionDAG computation must indicate the node that\n/// computes it as well as which return value to use from that node.  This pair\n/// of information is represented with the SDValue value type.\n///\nclass SDValue {\n  friend struct DenseMapInfo<SDValue>;\n\n  SDNode *Node = nullptr; // The node defining the value we are using.\n  unsigned ResNo = 0;     // Which return value of the node we are using.\n\npublic:\n  SDValue() = default;\n  SDValue(SDNode *node, unsigned resno);\n\n  /// get the index which selects a specific result in the SDNode\n  unsigned getResNo() const { return ResNo; }\n\n  /// get the SDNode which holds the desired result\n  SDNode *getNode() const { return Node; }\n\n  /// set the SDNode\n  void setNode(SDNode *N) { Node = N; }\n\n  inline SDNode *operator->() const { return Node; }\n\n  bool operator==(const SDValue &O) const {\n    return Node == O.Node && ResNo == O.ResNo;\n  }\n  bool operator!=(const SDValue &O) const {\n    return !operator==(O);\n  }\n  bool operator<(const SDValue &O) const {\n    return std::tie(Node, ResNo) < std::tie(O.Node, O.ResNo);\n  }\n  explicit operator bool() const {\n    return Node != nullptr;\n  }\n\n  SDValue getValue(unsigned R) const {\n    return SDValue(Node, R);\n  }\n\n  /// Return true if this node is an operand of N.\n  bool isOperandOf(const SDNode *N) const;\n\n  /// Return the ValueType of the referenced return value.\n  inline EVT getValueType() const;\n\n  /// Return the simple ValueType of the referenced return value.\n  MVT getSimpleValueType() const {\n    return getValueType().getSimpleVT();\n  }\n\n  /// Returns the size of the value in bits.\n  ///\n  /// If the value type is a scalable vector type, the scalable property will\n  /// be set and the runtime size will be a positive integer multiple of the\n  /// base size.\n  TypeSize getValueSizeInBits() const {\n    return getValueType().getSizeInBits();\n  }\n\n  uint64_t getScalarValueSizeInBits() const {\n    return getValueType().getScalarType().getFixedSizeInBits();\n  }\n\n  // Forwarding methods - These forward to the corresponding methods in SDNode.\n  inline unsigned getOpcode() const;\n  inline unsigned getNumOperands() const;\n  inline const SDValue &getOperand(unsigned i) const;\n  inline uint64_t getConstantOperandVal(unsigned i) const;\n  inline const APInt &getConstantOperandAPInt(unsigned i) const;\n  inline bool isTargetMemoryOpcode() const;\n  inline bool isTargetOpcode() const;\n  inline bool isMachineOpcode() const;\n  inline bool isUndef() const;\n  inline unsigned getMachineOpcode() const;\n  inline const DebugLoc &getDebugLoc() const;\n  inline void dump() const;\n  inline void dump(const SelectionDAG *G) const;\n  inline void dumpr() const;\n  inline void dumpr(const SelectionDAG *G) const;\n\n  /// Return true if this operand (which must be a chain) reaches the\n  /// specified operand without crossing any side-effecting instructions.\n  /// In practice, this looks through token factors and non-volatile loads.\n  /// In order to remain efficient, this only\n  /// looks a couple of nodes in, it does not do an exhaustive search.\n  bool reachesChainWithoutSideEffects(SDValue Dest,\n                                      unsigned Depth = 2) const;\n\n  /// Return true if there are no nodes using value ResNo of Node.\n  inline bool use_empty() const;\n\n  /// Return true if there is exactly one node using value ResNo of Node.\n  inline bool hasOneUse() const;\n};\n\ntemplate<> struct DenseMapInfo<SDValue> {\n  static inline SDValue getEmptyKey() {\n    SDValue V;\n    V.ResNo = -1U;\n    return V;\n  }\n\n  static inline SDValue getTombstoneKey() {\n    SDValue V;\n    V.ResNo = -2U;\n    return V;\n  }\n\n  static unsigned getHashValue(const SDValue &Val) {\n    return ((unsigned)((uintptr_t)Val.getNode() >> 4) ^\n            (unsigned)((uintptr_t)Val.getNode() >> 9)) + Val.getResNo();\n  }\n\n  static bool isEqual(const SDValue &LHS, const SDValue &RHS) {\n    return LHS == RHS;\n  }\n};\n\n/// Allow casting operators to work directly on\n/// SDValues as if they were SDNode*'s.\ntemplate<> struct simplify_type<SDValue> {\n  using SimpleType = SDNode *;\n\n  static SimpleType getSimplifiedValue(SDValue &Val) {\n    return Val.getNode();\n  }\n};\ntemplate<> struct simplify_type<const SDValue> {\n  using SimpleType = /*const*/ SDNode *;\n\n  static SimpleType getSimplifiedValue(const SDValue &Val) {\n    return Val.getNode();\n  }\n};\n\n/// Represents a use of a SDNode. This class holds an SDValue,\n/// which records the SDNode being used and the result number, a\n/// pointer to the SDNode using the value, and Next and Prev pointers,\n/// which link together all the uses of an SDNode.\n///\nclass SDUse {\n  /// Val - The value being used.\n  SDValue Val;\n  /// User - The user of this value.\n  SDNode *User = nullptr;\n  /// Prev, Next - Pointers to the uses list of the SDNode referred by\n  /// this operand.\n  SDUse **Prev = nullptr;\n  SDUse *Next = nullptr;\n\npublic:\n  SDUse() = default;\n  SDUse(const SDUse &U) = delete;\n  SDUse &operator=(const SDUse &) = delete;\n\n  /// Normally SDUse will just implicitly convert to an SDValue that it holds.\n  operator const SDValue&() const { return Val; }\n\n  /// If implicit conversion to SDValue doesn't work, the get() method returns\n  /// the SDValue.\n  const SDValue &get() const { return Val; }\n\n  /// This returns the SDNode that contains this Use.\n  SDNode *getUser() { return User; }\n\n  /// Get the next SDUse in the use list.\n  SDUse *getNext() const { return Next; }\n\n  /// Convenience function for get().getNode().\n  SDNode *getNode() const { return Val.getNode(); }\n  /// Convenience function for get().getResNo().\n  unsigned getResNo() const { return Val.getResNo(); }\n  /// Convenience function for get().getValueType().\n  EVT getValueType() const { return Val.getValueType(); }\n\n  /// Convenience function for get().operator==\n  bool operator==(const SDValue &V) const {\n    return Val == V;\n  }\n\n  /// Convenience function for get().operator!=\n  bool operator!=(const SDValue &V) const {\n    return Val != V;\n  }\n\n  /// Convenience function for get().operator<\n  bool operator<(const SDValue &V) const {\n    return Val < V;\n  }\n\nprivate:\n  friend class SelectionDAG;\n  friend class SDNode;\n  // TODO: unfriend HandleSDNode once we fix its operand handling.\n  friend class HandleSDNode;\n\n  void setUser(SDNode *p) { User = p; }\n\n  /// Remove this use from its existing use list, assign it the\n  /// given value, and add it to the new value's node's use list.\n  inline void set(const SDValue &V);\n  /// Like set, but only supports initializing a newly-allocated\n  /// SDUse with a non-null value.\n  inline void setInitial(const SDValue &V);\n  /// Like set, but only sets the Node portion of the value,\n  /// leaving the ResNo portion unmodified.\n  inline void setNode(SDNode *N);\n\n  void addToList(SDUse **List) {\n    Next = *List;\n    if (Next) Next->Prev = &Next;\n    Prev = List;\n    *List = this;\n  }\n\n  void removeFromList() {\n    *Prev = Next;\n    if (Next) Next->Prev = Prev;\n  }\n};\n\n/// simplify_type specializations - Allow casting operators to work directly on\n/// SDValues as if they were SDNode*'s.\ntemplate<> struct simplify_type<SDUse> {\n  using SimpleType = SDNode *;\n\n  static SimpleType getSimplifiedValue(SDUse &Val) {\n    return Val.getNode();\n  }\n};\n\n/// These are IR-level optimization flags that may be propagated to SDNodes.\n/// TODO: This data structure should be shared by the IR optimizer and the\n/// the backend.\nstruct SDNodeFlags {\nprivate:\n  bool NoUnsignedWrap : 1;\n  bool NoSignedWrap : 1;\n  bool Exact : 1;\n  bool NoNaNs : 1;\n  bool NoInfs : 1;\n  bool NoSignedZeros : 1;\n  bool AllowReciprocal : 1;\n  bool AllowContract : 1;\n  bool ApproximateFuncs : 1;\n  bool AllowReassociation : 1;\n\n  // We assume instructions do not raise floating-point exceptions by default,\n  // and only those marked explicitly may do so.  We could choose to represent\n  // this via a positive \"FPExcept\" flags like on the MI level, but having a\n  // negative \"NoFPExcept\" flag here (that defaults to true) makes the flag\n  // intersection logic more straightforward.\n  bool NoFPExcept : 1;\n\npublic:\n  /// Default constructor turns off all optimization flags.\n  SDNodeFlags()\n      : NoUnsignedWrap(false), NoSignedWrap(false), Exact(false), NoNaNs(false),\n        NoInfs(false), NoSignedZeros(false), AllowReciprocal(false),\n        AllowContract(false), ApproximateFuncs(false),\n        AllowReassociation(false), NoFPExcept(false) {}\n\n  /// Propagate the fast-math-flags from an IR FPMathOperator.\n  void copyFMF(const FPMathOperator &FPMO) {\n    setNoNaNs(FPMO.hasNoNaNs());\n    setNoInfs(FPMO.hasNoInfs());\n    setNoSignedZeros(FPMO.hasNoSignedZeros());\n    setAllowReciprocal(FPMO.hasAllowReciprocal());\n    setAllowContract(FPMO.hasAllowContract());\n    setApproximateFuncs(FPMO.hasApproxFunc());\n    setAllowReassociation(FPMO.hasAllowReassoc());\n  }\n\n  // These are mutators for each flag.\n  void setNoUnsignedWrap(bool b) { NoUnsignedWrap = b; }\n  void setNoSignedWrap(bool b) { NoSignedWrap = b; }\n  void setExact(bool b) { Exact = b; }\n  void setNoNaNs(bool b) { NoNaNs = b; }\n  void setNoInfs(bool b) { NoInfs = b; }\n  void setNoSignedZeros(bool b) { NoSignedZeros = b; }\n  void setAllowReciprocal(bool b) { AllowReciprocal = b; }\n  void setAllowContract(bool b) { AllowContract = b; }\n  void setApproximateFuncs(bool b) { ApproximateFuncs = b; }\n  void setAllowReassociation(bool b) { AllowReassociation = b; }\n  void setNoFPExcept(bool b) { NoFPExcept = b; }\n\n  // These are accessors for each flag.\n  bool hasNoUnsignedWrap() const { return NoUnsignedWrap; }\n  bool hasNoSignedWrap() const { return NoSignedWrap; }\n  bool hasExact() const { return Exact; }\n  bool hasNoNaNs() const { return NoNaNs; }\n  bool hasNoInfs() const { return NoInfs; }\n  bool hasNoSignedZeros() const { return NoSignedZeros; }\n  bool hasAllowReciprocal() const { return AllowReciprocal; }\n  bool hasAllowContract() const { return AllowContract; }\n  bool hasApproximateFuncs() const { return ApproximateFuncs; }\n  bool hasAllowReassociation() const { return AllowReassociation; }\n  bool hasNoFPExcept() const { return NoFPExcept; }\n\n  /// Clear any flags in this flag set that aren't also set in Flags. All\n  /// flags will be cleared if Flags are undefined.\n  void intersectWith(const SDNodeFlags Flags) {\n    NoUnsignedWrap &= Flags.NoUnsignedWrap;\n    NoSignedWrap &= Flags.NoSignedWrap;\n    Exact &= Flags.Exact;\n    NoNaNs &= Flags.NoNaNs;\n    NoInfs &= Flags.NoInfs;\n    NoSignedZeros &= Flags.NoSignedZeros;\n    AllowReciprocal &= Flags.AllowReciprocal;\n    AllowContract &= Flags.AllowContract;\n    ApproximateFuncs &= Flags.ApproximateFuncs;\n    AllowReassociation &= Flags.AllowReassociation;\n    NoFPExcept &= Flags.NoFPExcept;\n  }\n};\n\n/// Represents one node in the SelectionDAG.\n///\nclass SDNode : public FoldingSetNode, public ilist_node<SDNode> {\nprivate:\n  /// The operation that this node performs.\n  int16_t NodeType;\n\nprotected:\n  // We define a set of mini-helper classes to help us interpret the bits in our\n  // SubclassData.  These are designed to fit within a uint16_t so they pack\n  // with NodeType.\n\n#if defined(_AIX) && (!defined(__GNUC__) || defined(__ibmxl__))\n// Except for GCC; by default, AIX compilers store bit-fields in 4-byte words\n// and give the `pack` pragma push semantics.\n#define BEGIN_TWO_BYTE_PACK() _Pragma(\"pack(2)\")\n#define END_TWO_BYTE_PACK() _Pragma(\"pack(pop)\")\n#else\n#define BEGIN_TWO_BYTE_PACK()\n#define END_TWO_BYTE_PACK()\n#endif\n\nBEGIN_TWO_BYTE_PACK()\n  class SDNodeBitfields {\n    friend class SDNode;\n    friend class MemIntrinsicSDNode;\n    friend class MemSDNode;\n    friend class SelectionDAG;\n\n    uint16_t HasDebugValue : 1;\n    uint16_t IsMemIntrinsic : 1;\n    uint16_t IsDivergent : 1;\n  };\n  enum { NumSDNodeBits = 3 };\n\n  class ConstantSDNodeBitfields {\n    friend class ConstantSDNode;\n\n    uint16_t : NumSDNodeBits;\n\n    uint16_t IsOpaque : 1;\n  };\n\n  class MemSDNodeBitfields {\n    friend class MemSDNode;\n    friend class MemIntrinsicSDNode;\n    friend class AtomicSDNode;\n\n    uint16_t : NumSDNodeBits;\n\n    uint16_t IsVolatile : 1;\n    uint16_t IsNonTemporal : 1;\n    uint16_t IsDereferenceable : 1;\n    uint16_t IsInvariant : 1;\n  };\n  enum { NumMemSDNodeBits = NumSDNodeBits + 4 };\n\n  class LSBaseSDNodeBitfields {\n    friend class LSBaseSDNode;\n    friend class MaskedLoadStoreSDNode;\n    friend class MaskedGatherScatterSDNode;\n\n    uint16_t : NumMemSDNodeBits;\n\n    // This storage is shared between disparate class hierarchies to hold an\n    // enumeration specific to the class hierarchy in use.\n    //   LSBaseSDNode => enum ISD::MemIndexedMode\n    //   MaskedLoadStoreBaseSDNode => enum ISD::MemIndexedMode\n    //   MaskedGatherScatterSDNode => enum ISD::MemIndexType\n    uint16_t AddressingMode : 3;\n  };\n  enum { NumLSBaseSDNodeBits = NumMemSDNodeBits + 3 };\n\n  class LoadSDNodeBitfields {\n    friend class LoadSDNode;\n    friend class MaskedLoadSDNode;\n    friend class MaskedGatherSDNode;\n\n    uint16_t : NumLSBaseSDNodeBits;\n\n    uint16_t ExtTy : 2; // enum ISD::LoadExtType\n    uint16_t IsExpanding : 1;\n  };\n\n  class StoreSDNodeBitfields {\n    friend class StoreSDNode;\n    friend class MaskedStoreSDNode;\n    friend class MaskedScatterSDNode;\n\n    uint16_t : NumLSBaseSDNodeBits;\n\n    uint16_t IsTruncating : 1;\n    uint16_t IsCompressing : 1;\n  };\n\n  union {\n    char RawSDNodeBits[sizeof(uint16_t)];\n    SDNodeBitfields SDNodeBits;\n    ConstantSDNodeBitfields ConstantSDNodeBits;\n    MemSDNodeBitfields MemSDNodeBits;\n    LSBaseSDNodeBitfields LSBaseSDNodeBits;\n    LoadSDNodeBitfields LoadSDNodeBits;\n    StoreSDNodeBitfields StoreSDNodeBits;\n  };\nEND_TWO_BYTE_PACK()\n#undef BEGIN_TWO_BYTE_PACK\n#undef END_TWO_BYTE_PACK\n\n  // RawSDNodeBits must cover the entirety of the union.  This means that all of\n  // the union's members must have size <= RawSDNodeBits.  We write the RHS as\n  // \"2\" instead of sizeof(RawSDNodeBits) because MSVC can't handle the latter.\n  static_assert(sizeof(SDNodeBitfields) <= 2, \"field too wide\");\n  static_assert(sizeof(ConstantSDNodeBitfields) <= 2, \"field too wide\");\n  static_assert(sizeof(MemSDNodeBitfields) <= 2, \"field too wide\");\n  static_assert(sizeof(LSBaseSDNodeBitfields) <= 2, \"field too wide\");\n  static_assert(sizeof(LoadSDNodeBitfields) <= 2, \"field too wide\");\n  static_assert(sizeof(StoreSDNodeBitfields) <= 2, \"field too wide\");\n\nprivate:\n  friend class SelectionDAG;\n  // TODO: unfriend HandleSDNode once we fix its operand handling.\n  friend class HandleSDNode;\n\n  /// Unique id per SDNode in the DAG.\n  int NodeId = -1;\n\n  /// The values that are used by this operation.\n  SDUse *OperandList = nullptr;\n\n  /// The types of the values this node defines.  SDNode's may\n  /// define multiple values simultaneously.\n  const EVT *ValueList;\n\n  /// List of uses for this SDNode.\n  SDUse *UseList = nullptr;\n\n  /// The number of entries in the Operand/Value list.\n  unsigned short NumOperands = 0;\n  unsigned short NumValues;\n\n  // The ordering of the SDNodes. It roughly corresponds to the ordering of the\n  // original LLVM instructions.\n  // This is used for turning off scheduling, because we'll forgo\n  // the normal scheduling algorithms and output the instructions according to\n  // this ordering.\n  unsigned IROrder;\n\n  /// Source line information.\n  DebugLoc debugLoc;\n\n  /// Return a pointer to the specified value type.\n  static const EVT *getValueTypeList(EVT VT);\n\n  SDNodeFlags Flags;\n\npublic:\n  /// Unique and persistent id per SDNode in the DAG.\n  /// Used for debug printing.\n  uint16_t PersistentId;\n\n  //===--------------------------------------------------------------------===//\n  //  Accessors\n  //\n\n  /// Return the SelectionDAG opcode value for this node. For\n  /// pre-isel nodes (those for which isMachineOpcode returns false), these\n  /// are the opcode values in the ISD and <target>ISD namespaces. For\n  /// post-isel opcodes, see getMachineOpcode.\n  unsigned getOpcode()  const { return (unsigned short)NodeType; }\n\n  /// Test if this node has a target-specific opcode (in the\n  /// \\<target\\>ISD namespace).\n  bool isTargetOpcode() const { return NodeType >= ISD::BUILTIN_OP_END; }\n\n  /// Test if this node has a target-specific opcode that may raise\n  /// FP exceptions (in the \\<target\\>ISD namespace and greater than\n  /// FIRST_TARGET_STRICTFP_OPCODE).  Note that all target memory\n  /// opcode are currently automatically considered to possibly raise\n  /// FP exceptions as well.\n  bool isTargetStrictFPOpcode() const {\n    return NodeType >= ISD::FIRST_TARGET_STRICTFP_OPCODE;\n  }\n\n  /// Test if this node has a target-specific\n  /// memory-referencing opcode (in the \\<target\\>ISD namespace and\n  /// greater than FIRST_TARGET_MEMORY_OPCODE).\n  bool isTargetMemoryOpcode() const {\n    return NodeType >= ISD::FIRST_TARGET_MEMORY_OPCODE;\n  }\n\n  /// Return true if the type of the node type undefined.\n  bool isUndef() const { return NodeType == ISD::UNDEF; }\n\n  /// Test if this node is a memory intrinsic (with valid pointer information).\n  /// INTRINSIC_W_CHAIN and INTRINSIC_VOID nodes are sometimes created for\n  /// non-memory intrinsics (with chains) that are not really instances of\n  /// MemSDNode. For such nodes, we need some extra state to determine the\n  /// proper classof relationship.\n  bool isMemIntrinsic() const {\n    return (NodeType == ISD::INTRINSIC_W_CHAIN ||\n            NodeType == ISD::INTRINSIC_VOID) &&\n           SDNodeBits.IsMemIntrinsic;\n  }\n\n  /// Test if this node is a strict floating point pseudo-op.\n  bool isStrictFPOpcode() {\n    switch (NodeType) {\n      default:\n        return false;\n      case ISD::STRICT_FP16_TO_FP:\n      case ISD::STRICT_FP_TO_FP16:\n#define DAG_INSTRUCTION(NAME, NARG, ROUND_MODE, INTRINSIC, DAGN)               \\\n      case ISD::STRICT_##DAGN:\n#include \"llvm/IR/ConstrainedOps.def\"\n        return true;\n    }\n  }\n\n  /// Test if this node has a post-isel opcode, directly\n  /// corresponding to a MachineInstr opcode.\n  bool isMachineOpcode() const { return NodeType < 0; }\n\n  /// This may only be called if isMachineOpcode returns\n  /// true. It returns the MachineInstr opcode value that the node's opcode\n  /// corresponds to.\n  unsigned getMachineOpcode() const {\n    assert(isMachineOpcode() && \"Not a MachineInstr opcode!\");\n    return ~NodeType;\n  }\n\n  bool getHasDebugValue() const { return SDNodeBits.HasDebugValue; }\n  void setHasDebugValue(bool b) { SDNodeBits.HasDebugValue = b; }\n\n  bool isDivergent() const { return SDNodeBits.IsDivergent; }\n\n  /// Return true if there are no uses of this node.\n  bool use_empty() const { return UseList == nullptr; }\n\n  /// Return true if there is exactly one use of this node.\n  bool hasOneUse() const { return hasSingleElement(uses()); }\n\n  /// Return the number of uses of this node. This method takes\n  /// time proportional to the number of uses.\n  size_t use_size() const { return std::distance(use_begin(), use_end()); }\n\n  /// Return the unique node id.\n  int getNodeId() const { return NodeId; }\n\n  /// Set unique node id.\n  void setNodeId(int Id) { NodeId = Id; }\n\n  /// Return the node ordering.\n  unsigned getIROrder() const { return IROrder; }\n\n  /// Set the node ordering.\n  void setIROrder(unsigned Order) { IROrder = Order; }\n\n  /// Return the source location info.\n  const DebugLoc &getDebugLoc() const { return debugLoc; }\n\n  /// Set source location info.  Try to avoid this, putting\n  /// it in the constructor is preferable.\n  void setDebugLoc(DebugLoc dl) { debugLoc = std::move(dl); }\n\n  /// This class provides iterator support for SDUse\n  /// operands that use a specific SDNode.\n  class use_iterator\n    : public std::iterator<std::forward_iterator_tag, SDUse, ptrdiff_t> {\n    friend class SDNode;\n\n    SDUse *Op = nullptr;\n\n    explicit use_iterator(SDUse *op) : Op(op) {}\n\n  public:\n    using reference = std::iterator<std::forward_iterator_tag,\n                                    SDUse, ptrdiff_t>::reference;\n    using pointer = std::iterator<std::forward_iterator_tag,\n                                  SDUse, ptrdiff_t>::pointer;\n\n    use_iterator() = default;\n    use_iterator(const use_iterator &I) : Op(I.Op) {}\n\n    bool operator==(const use_iterator &x) const {\n      return Op == x.Op;\n    }\n    bool operator!=(const use_iterator &x) const {\n      return !operator==(x);\n    }\n\n    /// Return true if this iterator is at the end of uses list.\n    bool atEnd() const { return Op == nullptr; }\n\n    // Iterator traversal: forward iteration only.\n    use_iterator &operator++() {          // Preincrement\n      assert(Op && \"Cannot increment end iterator!\");\n      Op = Op->getNext();\n      return *this;\n    }\n\n    use_iterator operator++(int) {        // Postincrement\n      use_iterator tmp = *this; ++*this; return tmp;\n    }\n\n    /// Retrieve a pointer to the current user node.\n    SDNode *operator*() const {\n      assert(Op && \"Cannot dereference end iterator!\");\n      return Op->getUser();\n    }\n\n    SDNode *operator->() const { return operator*(); }\n\n    SDUse &getUse() const { return *Op; }\n\n    /// Retrieve the operand # of this use in its user.\n    unsigned getOperandNo() const {\n      assert(Op && \"Cannot dereference end iterator!\");\n      return (unsigned)(Op - Op->getUser()->OperandList);\n    }\n  };\n\n  /// Provide iteration support to walk over all uses of an SDNode.\n  use_iterator use_begin() const {\n    return use_iterator(UseList);\n  }\n\n  static use_iterator use_end() { return use_iterator(nullptr); }\n\n  inline iterator_range<use_iterator> uses() {\n    return make_range(use_begin(), use_end());\n  }\n  inline iterator_range<use_iterator> uses() const {\n    return make_range(use_begin(), use_end());\n  }\n\n  /// Return true if there are exactly NUSES uses of the indicated value.\n  /// This method ignores uses of other values defined by this operation.\n  bool hasNUsesOfValue(unsigned NUses, unsigned Value) const;\n\n  /// Return true if there are any use of the indicated value.\n  /// This method ignores uses of other values defined by this operation.\n  bool hasAnyUseOfValue(unsigned Value) const;\n\n  /// Return true if this node is the only use of N.\n  bool isOnlyUserOf(const SDNode *N) const;\n\n  /// Return true if this node is an operand of N.\n  bool isOperandOf(const SDNode *N) const;\n\n  /// Return true if this node is a predecessor of N.\n  /// NOTE: Implemented on top of hasPredecessor and every bit as\n  /// expensive. Use carefully.\n  bool isPredecessorOf(const SDNode *N) const {\n    return N->hasPredecessor(this);\n  }\n\n  /// Return true if N is a predecessor of this node.\n  /// N is either an operand of this node, or can be reached by recursively\n  /// traversing up the operands.\n  /// NOTE: This is an expensive method. Use it carefully.\n  bool hasPredecessor(const SDNode *N) const;\n\n  /// Returns true if N is a predecessor of any node in Worklist. This\n  /// helper keeps Visited and Worklist sets externally to allow unions\n  /// searches to be performed in parallel, caching of results across\n  /// queries and incremental addition to Worklist. Stops early if N is\n  /// found but will resume. Remember to clear Visited and Worklists\n  /// if DAG changes. MaxSteps gives a maximum number of nodes to visit before\n  /// giving up. The TopologicalPrune flag signals that positive NodeIds are\n  /// topologically ordered (Operands have strictly smaller node id) and search\n  /// can be pruned leveraging this.\n  static bool hasPredecessorHelper(const SDNode *N,\n                                   SmallPtrSetImpl<const SDNode *> &Visited,\n                                   SmallVectorImpl<const SDNode *> &Worklist,\n                                   unsigned int MaxSteps = 0,\n                                   bool TopologicalPrune = false) {\n    SmallVector<const SDNode *, 8> DeferredNodes;\n    if (Visited.count(N))\n      return true;\n\n    // Node Id's are assigned in three places: As a topological\n    // ordering (> 0), during legalization (results in values set to\n    // 0), new nodes (set to -1). If N has a topolgical id then we\n    // know that all nodes with ids smaller than it cannot be\n    // successors and we need not check them. Filter out all node\n    // that can't be matches. We add them to the worklist before exit\n    // in case of multiple calls. Note that during selection the topological id\n    // may be violated if a node's predecessor is selected before it. We mark\n    // this at selection negating the id of unselected successors and\n    // restricting topological pruning to positive ids.\n\n    int NId = N->getNodeId();\n    // If we Invalidated the Id, reconstruct original NId.\n    if (NId < -1)\n      NId = -(NId + 1);\n\n    bool Found = false;\n    while (!Worklist.empty()) {\n      const SDNode *M = Worklist.pop_back_val();\n      int MId = M->getNodeId();\n      if (TopologicalPrune && M->getOpcode() != ISD::TokenFactor && (NId > 0) &&\n          (MId > 0) && (MId < NId)) {\n        DeferredNodes.push_back(M);\n        continue;\n      }\n      for (const SDValue &OpV : M->op_values()) {\n        SDNode *Op = OpV.getNode();\n        if (Visited.insert(Op).second)\n          Worklist.push_back(Op);\n        if (Op == N)\n          Found = true;\n      }\n      if (Found)\n        break;\n      if (MaxSteps != 0 && Visited.size() >= MaxSteps)\n        break;\n    }\n    // Push deferred nodes back on worklist.\n    Worklist.append(DeferredNodes.begin(), DeferredNodes.end());\n    // If we bailed early, conservatively return found.\n    if (MaxSteps != 0 && Visited.size() >= MaxSteps)\n      return true;\n    return Found;\n  }\n\n  /// Return true if all the users of N are contained in Nodes.\n  /// NOTE: Requires at least one match, but doesn't require them all.\n  static bool areOnlyUsersOf(ArrayRef<const SDNode *> Nodes, const SDNode *N);\n\n  /// Return the number of values used by this operation.\n  unsigned getNumOperands() const { return NumOperands; }\n\n  /// Return the maximum number of operands that a SDNode can hold.\n  static constexpr size_t getMaxNumOperands() {\n    return std::numeric_limits<decltype(SDNode::NumOperands)>::max();\n  }\n\n  /// Helper method returns the integer value of a ConstantSDNode operand.\n  inline uint64_t getConstantOperandVal(unsigned Num) const;\n\n  /// Helper method returns the APInt of a ConstantSDNode operand.\n  inline const APInt &getConstantOperandAPInt(unsigned Num) const;\n\n  const SDValue &getOperand(unsigned Num) const {\n    assert(Num < NumOperands && \"Invalid child # of SDNode!\");\n    return OperandList[Num];\n  }\n\n  using op_iterator = SDUse *;\n\n  op_iterator op_begin() const { return OperandList; }\n  op_iterator op_end() const { return OperandList+NumOperands; }\n  ArrayRef<SDUse> ops() const { return makeArrayRef(op_begin(), op_end()); }\n\n  /// Iterator for directly iterating over the operand SDValue's.\n  struct value_op_iterator\n      : iterator_adaptor_base<value_op_iterator, op_iterator,\n                              std::random_access_iterator_tag, SDValue,\n                              ptrdiff_t, value_op_iterator *,\n                              value_op_iterator *> {\n    explicit value_op_iterator(SDUse *U = nullptr)\n      : iterator_adaptor_base(U) {}\n\n    const SDValue &operator*() const { return I->get(); }\n  };\n\n  iterator_range<value_op_iterator> op_values() const {\n    return make_range(value_op_iterator(op_begin()),\n                      value_op_iterator(op_end()));\n  }\n\n  SDVTList getVTList() const {\n    SDVTList X = { ValueList, NumValues };\n    return X;\n  }\n\n  /// If this node has a glue operand, return the node\n  /// to which the glue operand points. Otherwise return NULL.\n  SDNode *getGluedNode() const {\n    if (getNumOperands() != 0 &&\n        getOperand(getNumOperands()-1).getValueType() == MVT::Glue)\n      return getOperand(getNumOperands()-1).getNode();\n    return nullptr;\n  }\n\n  /// If this node has a glue value with a user, return\n  /// the user (there is at most one). Otherwise return NULL.\n  SDNode *getGluedUser() const {\n    for (use_iterator UI = use_begin(), UE = use_end(); UI != UE; ++UI)\n      if (UI.getUse().get().getValueType() == MVT::Glue)\n        return *UI;\n    return nullptr;\n  }\n\n  SDNodeFlags getFlags() const { return Flags; }\n  void setFlags(SDNodeFlags NewFlags) { Flags = NewFlags; }\n\n  /// Clear any flags in this node that aren't also set in Flags.\n  /// If Flags is not in a defined state then this has no effect.\n  void intersectFlagsWith(const SDNodeFlags Flags);\n\n  /// Return the number of values defined/returned by this operator.\n  unsigned getNumValues() const { return NumValues; }\n\n  /// Return the type of a specified result.\n  EVT getValueType(unsigned ResNo) const {\n    assert(ResNo < NumValues && \"Illegal result number!\");\n    return ValueList[ResNo];\n  }\n\n  /// Return the type of a specified result as a simple type.\n  MVT getSimpleValueType(unsigned ResNo) const {\n    return getValueType(ResNo).getSimpleVT();\n  }\n\n  /// Returns MVT::getSizeInBits(getValueType(ResNo)).\n  ///\n  /// If the value type is a scalable vector type, the scalable property will\n  /// be set and the runtime size will be a positive integer multiple of the\n  /// base size.\n  TypeSize getValueSizeInBits(unsigned ResNo) const {\n    return getValueType(ResNo).getSizeInBits();\n  }\n\n  using value_iterator = const EVT *;\n\n  value_iterator value_begin() const { return ValueList; }\n  value_iterator value_end() const { return ValueList+NumValues; }\n  iterator_range<value_iterator> values() const {\n    return llvm::make_range(value_begin(), value_end());\n  }\n\n  /// Return the opcode of this operation for printing.\n  std::string getOperationName(const SelectionDAG *G = nullptr) const;\n  static const char* getIndexedModeName(ISD::MemIndexedMode AM);\n  void print_types(raw_ostream &OS, const SelectionDAG *G) const;\n  void print_details(raw_ostream &OS, const SelectionDAG *G) const;\n  void print(raw_ostream &OS, const SelectionDAG *G = nullptr) const;\n  void printr(raw_ostream &OS, const SelectionDAG *G = nullptr) const;\n\n  /// Print a SelectionDAG node and all children down to\n  /// the leaves.  The given SelectionDAG allows target-specific nodes\n  /// to be printed in human-readable form.  Unlike printr, this will\n  /// print the whole DAG, including children that appear multiple\n  /// times.\n  ///\n  void printrFull(raw_ostream &O, const SelectionDAG *G = nullptr) const;\n\n  /// Print a SelectionDAG node and children up to\n  /// depth \"depth.\"  The given SelectionDAG allows target-specific\n  /// nodes to be printed in human-readable form.  Unlike printr, this\n  /// will print children that appear multiple times wherever they are\n  /// used.\n  ///\n  void printrWithDepth(raw_ostream &O, const SelectionDAG *G = nullptr,\n                       unsigned depth = 100) const;\n\n  /// Dump this node, for debugging.\n  void dump() const;\n\n  /// Dump (recursively) this node and its use-def subgraph.\n  void dumpr() const;\n\n  /// Dump this node, for debugging.\n  /// The given SelectionDAG allows target-specific nodes to be printed\n  /// in human-readable form.\n  void dump(const SelectionDAG *G) const;\n\n  /// Dump (recursively) this node and its use-def subgraph.\n  /// The given SelectionDAG allows target-specific nodes to be printed\n  /// in human-readable form.\n  void dumpr(const SelectionDAG *G) const;\n\n  /// printrFull to dbgs().  The given SelectionDAG allows\n  /// target-specific nodes to be printed in human-readable form.\n  /// Unlike dumpr, this will print the whole DAG, including children\n  /// that appear multiple times.\n  void dumprFull(const SelectionDAG *G = nullptr) const;\n\n  /// printrWithDepth to dbgs().  The given\n  /// SelectionDAG allows target-specific nodes to be printed in\n  /// human-readable form.  Unlike dumpr, this will print children\n  /// that appear multiple times wherever they are used.\n  ///\n  void dumprWithDepth(const SelectionDAG *G = nullptr,\n                      unsigned depth = 100) const;\n\n  /// Gather unique data for the node.\n  void Profile(FoldingSetNodeID &ID) const;\n\n  /// This method should only be used by the SDUse class.\n  void addUse(SDUse &U) { U.addToList(&UseList); }\n\nprotected:\n  static SDVTList getSDVTList(EVT VT) {\n    SDVTList Ret = { getValueTypeList(VT), 1 };\n    return Ret;\n  }\n\n  /// Create an SDNode.\n  ///\n  /// SDNodes are created without any operands, and never own the operand\n  /// storage. To add operands, see SelectionDAG::createOperands.\n  SDNode(unsigned Opc, unsigned Order, DebugLoc dl, SDVTList VTs)\n      : NodeType(Opc), ValueList(VTs.VTs), NumValues(VTs.NumVTs),\n        IROrder(Order), debugLoc(std::move(dl)) {\n    memset(&RawSDNodeBits, 0, sizeof(RawSDNodeBits));\n    assert(debugLoc.hasTrivialDestructor() && \"Expected trivial destructor\");\n    assert(NumValues == VTs.NumVTs &&\n           \"NumValues wasn't wide enough for its operands!\");\n  }\n\n  /// Release the operands and set this node to have zero operands.\n  void DropOperands();\n};\n\n/// Wrapper class for IR location info (IR ordering and DebugLoc) to be passed\n/// into SDNode creation functions.\n/// When an SDNode is created from the DAGBuilder, the DebugLoc is extracted\n/// from the original Instruction, and IROrder is the ordinal position of\n/// the instruction.\n/// When an SDNode is created after the DAG is being built, both DebugLoc and\n/// the IROrder are propagated from the original SDNode.\n/// So SDLoc class provides two constructors besides the default one, one to\n/// be used by the DAGBuilder, the other to be used by others.\nclass SDLoc {\nprivate:\n  DebugLoc DL;\n  int IROrder = 0;\n\npublic:\n  SDLoc() = default;\n  SDLoc(const SDNode *N) : DL(N->getDebugLoc()), IROrder(N->getIROrder()) {}\n  SDLoc(const SDValue V) : SDLoc(V.getNode()) {}\n  SDLoc(const Instruction *I, int Order) : IROrder(Order) {\n    assert(Order >= 0 && \"bad IROrder\");\n    if (I)\n      DL = I->getDebugLoc();\n  }\n\n  unsigned getIROrder() const { return IROrder; }\n  const DebugLoc &getDebugLoc() const { return DL; }\n};\n\n// Define inline functions from the SDValue class.\n\ninline SDValue::SDValue(SDNode *node, unsigned resno)\n    : Node(node), ResNo(resno) {\n  // Explicitly check for !ResNo to avoid use-after-free, because there are\n  // callers that use SDValue(N, 0) with a deleted N to indicate successful\n  // combines.\n  assert((!Node || !ResNo || ResNo < Node->getNumValues()) &&\n         \"Invalid result number for the given node!\");\n  assert(ResNo < -2U && \"Cannot use result numbers reserved for DenseMaps.\");\n}\n\ninline unsigned SDValue::getOpcode() const {\n  return Node->getOpcode();\n}\n\ninline EVT SDValue::getValueType() const {\n  return Node->getValueType(ResNo);\n}\n\ninline unsigned SDValue::getNumOperands() const {\n  return Node->getNumOperands();\n}\n\ninline const SDValue &SDValue::getOperand(unsigned i) const {\n  return Node->getOperand(i);\n}\n\ninline uint64_t SDValue::getConstantOperandVal(unsigned i) const {\n  return Node->getConstantOperandVal(i);\n}\n\ninline const APInt &SDValue::getConstantOperandAPInt(unsigned i) const {\n  return Node->getConstantOperandAPInt(i);\n}\n\ninline bool SDValue::isTargetOpcode() const {\n  return Node->isTargetOpcode();\n}\n\ninline bool SDValue::isTargetMemoryOpcode() const {\n  return Node->isTargetMemoryOpcode();\n}\n\ninline bool SDValue::isMachineOpcode() const {\n  return Node->isMachineOpcode();\n}\n\ninline unsigned SDValue::getMachineOpcode() const {\n  return Node->getMachineOpcode();\n}\n\ninline bool SDValue::isUndef() const {\n  return Node->isUndef();\n}\n\ninline bool SDValue::use_empty() const {\n  return !Node->hasAnyUseOfValue(ResNo);\n}\n\ninline bool SDValue::hasOneUse() const {\n  return Node->hasNUsesOfValue(1, ResNo);\n}\n\ninline const DebugLoc &SDValue::getDebugLoc() const {\n  return Node->getDebugLoc();\n}\n\ninline void SDValue::dump() const {\n  return Node->dump();\n}\n\ninline void SDValue::dump(const SelectionDAG *G) const {\n  return Node->dump(G);\n}\n\ninline void SDValue::dumpr() const {\n  return Node->dumpr();\n}\n\ninline void SDValue::dumpr(const SelectionDAG *G) const {\n  return Node->dumpr(G);\n}\n\n// Define inline functions from the SDUse class.\n\ninline void SDUse::set(const SDValue &V) {\n  if (Val.getNode()) removeFromList();\n  Val = V;\n  if (V.getNode()) V.getNode()->addUse(*this);\n}\n\ninline void SDUse::setInitial(const SDValue &V) {\n  Val = V;\n  V.getNode()->addUse(*this);\n}\n\ninline void SDUse::setNode(SDNode *N) {\n  if (Val.getNode()) removeFromList();\n  Val.setNode(N);\n  if (N) N->addUse(*this);\n}\n\n/// This class is used to form a handle around another node that\n/// is persistent and is updated across invocations of replaceAllUsesWith on its\n/// operand.  This node should be directly created by end-users and not added to\n/// the AllNodes list.\nclass HandleSDNode : public SDNode {\n  SDUse Op;\n\npublic:\n  explicit HandleSDNode(SDValue X)\n    : SDNode(ISD::HANDLENODE, 0, DebugLoc(), getSDVTList(MVT::Other)) {\n    // HandleSDNodes are never inserted into the DAG, so they won't be\n    // auto-numbered. Use ID 65535 as a sentinel.\n    PersistentId = 0xffff;\n\n    // Manually set up the operand list. This node type is special in that it's\n    // always stack allocated and SelectionDAG does not manage its operands.\n    // TODO: This should either (a) not be in the SDNode hierarchy, or (b) not\n    // be so special.\n    Op.setUser(this);\n    Op.setInitial(X);\n    NumOperands = 1;\n    OperandList = &Op;\n  }\n  ~HandleSDNode();\n\n  const SDValue &getValue() const { return Op; }\n};\n\nclass AddrSpaceCastSDNode : public SDNode {\nprivate:\n  unsigned SrcAddrSpace;\n  unsigned DestAddrSpace;\n\npublic:\n  AddrSpaceCastSDNode(unsigned Order, const DebugLoc &dl, EVT VT,\n                      unsigned SrcAS, unsigned DestAS);\n\n  unsigned getSrcAddressSpace() const { return SrcAddrSpace; }\n  unsigned getDestAddressSpace() const { return DestAddrSpace; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::ADDRSPACECAST;\n  }\n};\n\n/// This is an abstract virtual class for memory operations.\nclass MemSDNode : public SDNode {\nprivate:\n  // VT of in-memory value.\n  EVT MemoryVT;\n\nprotected:\n  /// Memory reference information.\n  MachineMemOperand *MMO;\n\npublic:\n  MemSDNode(unsigned Opc, unsigned Order, const DebugLoc &dl, SDVTList VTs,\n            EVT memvt, MachineMemOperand *MMO);\n\n  bool readMem() const { return MMO->isLoad(); }\n  bool writeMem() const { return MMO->isStore(); }\n\n  /// Returns alignment and volatility of the memory access\n  Align getOriginalAlign() const { return MMO->getBaseAlign(); }\n  Align getAlign() const { return MMO->getAlign(); }\n  LLVM_ATTRIBUTE_DEPRECATED(unsigned getOriginalAlignment() const,\n                            \"Use getOriginalAlign() instead\") {\n    return MMO->getBaseAlign().value();\n  }\n  // FIXME: Remove once transition to getAlign is over.\n  unsigned getAlignment() const { return MMO->getAlign().value(); }\n\n  /// Return the SubclassData value, without HasDebugValue. This contains an\n  /// encoding of the volatile flag, as well as bits used by subclasses. This\n  /// function should only be used to compute a FoldingSetNodeID value.\n  /// The HasDebugValue bit is masked out because CSE map needs to match\n  /// nodes with debug info with nodes without debug info. Same is about\n  /// isDivergent bit.\n  unsigned getRawSubclassData() const {\n    uint16_t Data;\n    union {\n      char RawSDNodeBits[sizeof(uint16_t)];\n      SDNodeBitfields SDNodeBits;\n    };\n    memcpy(&RawSDNodeBits, &this->RawSDNodeBits, sizeof(this->RawSDNodeBits));\n    SDNodeBits.HasDebugValue = 0;\n    SDNodeBits.IsDivergent = false;\n    memcpy(&Data, &RawSDNodeBits, sizeof(RawSDNodeBits));\n    return Data;\n  }\n\n  bool isVolatile() const { return MemSDNodeBits.IsVolatile; }\n  bool isNonTemporal() const { return MemSDNodeBits.IsNonTemporal; }\n  bool isDereferenceable() const { return MemSDNodeBits.IsDereferenceable; }\n  bool isInvariant() const { return MemSDNodeBits.IsInvariant; }\n\n  // Returns the offset from the location of the access.\n  int64_t getSrcValueOffset() const { return MMO->getOffset(); }\n\n  /// Returns the AA info that describes the dereference.\n  AAMDNodes getAAInfo() const { return MMO->getAAInfo(); }\n\n  /// Returns the Ranges that describes the dereference.\n  const MDNode *getRanges() const { return MMO->getRanges(); }\n\n  /// Returns the synchronization scope ID for this memory operation.\n  SyncScope::ID getSyncScopeID() const { return MMO->getSyncScopeID(); }\n\n  /// Return the atomic ordering requirements for this memory operation. For\n  /// cmpxchg atomic operations, return the atomic ordering requirements when\n  /// store occurs.\n  AtomicOrdering getOrdering() const { return MMO->getOrdering(); }\n\n  /// Return true if the memory operation ordering is Unordered or higher.\n  bool isAtomic() const { return MMO->isAtomic(); }\n\n  /// Returns true if the memory operation doesn't imply any ordering\n  /// constraints on surrounding memory operations beyond the normal memory\n  /// aliasing rules.\n  bool isUnordered() const { return MMO->isUnordered(); }\n\n  /// Returns true if the memory operation is neither atomic or volatile.\n  bool isSimple() const { return !isAtomic() && !isVolatile(); }\n\n  /// Return the type of the in-memory value.\n  EVT getMemoryVT() const { return MemoryVT; }\n\n  /// Return a MachineMemOperand object describing the memory\n  /// reference performed by operation.\n  MachineMemOperand *getMemOperand() const { return MMO; }\n\n  const MachinePointerInfo &getPointerInfo() const {\n    return MMO->getPointerInfo();\n  }\n\n  /// Return the address space for the associated pointer\n  unsigned getAddressSpace() const {\n    return getPointerInfo().getAddrSpace();\n  }\n\n  /// Update this MemSDNode's MachineMemOperand information\n  /// to reflect the alignment of NewMMO, if it has a greater alignment.\n  /// This must only be used when the new alignment applies to all users of\n  /// this MachineMemOperand.\n  void refineAlignment(const MachineMemOperand *NewMMO) {\n    MMO->refineAlignment(NewMMO);\n  }\n\n  const SDValue &getChain() const { return getOperand(0); }\n\n  const SDValue &getBasePtr() const {\n    switch (getOpcode()) {\n    case ISD::STORE:\n    case ISD::MSTORE:\n      return getOperand(2);\n    case ISD::MGATHER:\n    case ISD::MSCATTER:\n      return getOperand(3);\n    default:\n      return getOperand(1);\n    }\n  }\n\n  // Methods to support isa and dyn_cast\n  static bool classof(const SDNode *N) {\n    // For some targets, we lower some target intrinsics to a MemIntrinsicNode\n    // with either an intrinsic or a target opcode.\n    return N->getOpcode() == ISD::LOAD                ||\n           N->getOpcode() == ISD::STORE               ||\n           N->getOpcode() == ISD::PREFETCH            ||\n           N->getOpcode() == ISD::ATOMIC_CMP_SWAP     ||\n           N->getOpcode() == ISD::ATOMIC_CMP_SWAP_WITH_SUCCESS ||\n           N->getOpcode() == ISD::ATOMIC_SWAP         ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_ADD     ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_SUB     ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_AND     ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_CLR     ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_OR      ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_XOR     ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_NAND    ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_MIN     ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_MAX     ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_UMIN    ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_UMAX    ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_FADD    ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_FSUB    ||\n           N->getOpcode() == ISD::ATOMIC_LOAD         ||\n           N->getOpcode() == ISD::ATOMIC_STORE        ||\n           N->getOpcode() == ISD::MLOAD               ||\n           N->getOpcode() == ISD::MSTORE              ||\n           N->getOpcode() == ISD::MGATHER             ||\n           N->getOpcode() == ISD::MSCATTER            ||\n           N->isMemIntrinsic()                        ||\n           N->isTargetMemoryOpcode();\n  }\n};\n\n/// This is an SDNode representing atomic operations.\nclass AtomicSDNode : public MemSDNode {\npublic:\n  AtomicSDNode(unsigned Opc, unsigned Order, const DebugLoc &dl, SDVTList VTL,\n               EVT MemVT, MachineMemOperand *MMO)\n    : MemSDNode(Opc, Order, dl, VTL, MemVT, MMO) {\n    assert(((Opc != ISD::ATOMIC_LOAD && Opc != ISD::ATOMIC_STORE) ||\n            MMO->isAtomic()) && \"then why are we using an AtomicSDNode?\");\n  }\n\n  const SDValue &getBasePtr() const { return getOperand(1); }\n  const SDValue &getVal() const { return getOperand(2); }\n\n  /// Returns true if this SDNode represents cmpxchg atomic operation, false\n  /// otherwise.\n  bool isCompareAndSwap() const {\n    unsigned Op = getOpcode();\n    return Op == ISD::ATOMIC_CMP_SWAP ||\n           Op == ISD::ATOMIC_CMP_SWAP_WITH_SUCCESS;\n  }\n\n  /// For cmpxchg atomic operations, return the atomic ordering requirements\n  /// when store does not occur.\n  AtomicOrdering getFailureOrdering() const {\n    assert(isCompareAndSwap() && \"Must be cmpxchg operation\");\n    return MMO->getFailureOrdering();\n  }\n\n  // Methods to support isa and dyn_cast\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::ATOMIC_CMP_SWAP     ||\n           N->getOpcode() == ISD::ATOMIC_CMP_SWAP_WITH_SUCCESS ||\n           N->getOpcode() == ISD::ATOMIC_SWAP         ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_ADD     ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_SUB     ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_AND     ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_CLR     ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_OR      ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_XOR     ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_NAND    ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_MIN     ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_MAX     ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_UMIN    ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_UMAX    ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_FADD    ||\n           N->getOpcode() == ISD::ATOMIC_LOAD_FSUB    ||\n           N->getOpcode() == ISD::ATOMIC_LOAD         ||\n           N->getOpcode() == ISD::ATOMIC_STORE;\n  }\n};\n\n/// This SDNode is used for target intrinsics that touch\n/// memory and need an associated MachineMemOperand. Its opcode may be\n/// INTRINSIC_VOID, INTRINSIC_W_CHAIN, PREFETCH, or a target-specific opcode\n/// with a value not less than FIRST_TARGET_MEMORY_OPCODE.\nclass MemIntrinsicSDNode : public MemSDNode {\npublic:\n  MemIntrinsicSDNode(unsigned Opc, unsigned Order, const DebugLoc &dl,\n                     SDVTList VTs, EVT MemoryVT, MachineMemOperand *MMO)\n      : MemSDNode(Opc, Order, dl, VTs, MemoryVT, MMO) {\n    SDNodeBits.IsMemIntrinsic = true;\n  }\n\n  // Methods to support isa and dyn_cast\n  static bool classof(const SDNode *N) {\n    // We lower some target intrinsics to their target opcode\n    // early a node with a target opcode can be of this class\n    return N->isMemIntrinsic()             ||\n           N->getOpcode() == ISD::PREFETCH ||\n           N->isTargetMemoryOpcode();\n  }\n};\n\n/// This SDNode is used to implement the code generator\n/// support for the llvm IR shufflevector instruction.  It combines elements\n/// from two input vectors into a new input vector, with the selection and\n/// ordering of elements determined by an array of integers, referred to as\n/// the shuffle mask.  For input vectors of width N, mask indices of 0..N-1\n/// refer to elements from the LHS input, and indices from N to 2N-1 the RHS.\n/// An index of -1 is treated as undef, such that the code generator may put\n/// any value in the corresponding element of the result.\nclass ShuffleVectorSDNode : public SDNode {\n  // The memory for Mask is owned by the SelectionDAG's OperandAllocator, and\n  // is freed when the SelectionDAG object is destroyed.\n  const int *Mask;\n\nprotected:\n  friend class SelectionDAG;\n\n  ShuffleVectorSDNode(EVT VT, unsigned Order, const DebugLoc &dl, const int *M)\n      : SDNode(ISD::VECTOR_SHUFFLE, Order, dl, getSDVTList(VT)), Mask(M) {}\n\npublic:\n  ArrayRef<int> getMask() const {\n    EVT VT = getValueType(0);\n    return makeArrayRef(Mask, VT.getVectorNumElements());\n  }\n\n  int getMaskElt(unsigned Idx) const {\n    assert(Idx < getValueType(0).getVectorNumElements() && \"Idx out of range!\");\n    return Mask[Idx];\n  }\n\n  bool isSplat() const { return isSplatMask(Mask, getValueType(0)); }\n\n  int getSplatIndex() const {\n    assert(isSplat() && \"Cannot get splat index for non-splat!\");\n    EVT VT = getValueType(0);\n    for (unsigned i = 0, e = VT.getVectorNumElements(); i != e; ++i)\n      if (Mask[i] >= 0)\n        return Mask[i];\n\n    // We can choose any index value here and be correct because all elements\n    // are undefined. Return 0 for better potential for callers to simplify.\n    return 0;\n  }\n\n  static bool isSplatMask(const int *Mask, EVT VT);\n\n  /// Change values in a shuffle permute mask assuming\n  /// the two vector operands have swapped position.\n  static void commuteMask(MutableArrayRef<int> Mask) {\n    unsigned NumElems = Mask.size();\n    for (unsigned i = 0; i != NumElems; ++i) {\n      int idx = Mask[i];\n      if (idx < 0)\n        continue;\n      else if (idx < (int)NumElems)\n        Mask[i] = idx + NumElems;\n      else\n        Mask[i] = idx - NumElems;\n    }\n  }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::VECTOR_SHUFFLE;\n  }\n};\n\nclass ConstantSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  const ConstantInt *Value;\n\n  ConstantSDNode(bool isTarget, bool isOpaque, const ConstantInt *val, EVT VT)\n      : SDNode(isTarget ? ISD::TargetConstant : ISD::Constant, 0, DebugLoc(),\n               getSDVTList(VT)),\n        Value(val) {\n    ConstantSDNodeBits.IsOpaque = isOpaque;\n  }\n\npublic:\n  const ConstantInt *getConstantIntValue() const { return Value; }\n  const APInt &getAPIntValue() const { return Value->getValue(); }\n  uint64_t getZExtValue() const { return Value->getZExtValue(); }\n  int64_t getSExtValue() const { return Value->getSExtValue(); }\n  uint64_t getLimitedValue(uint64_t Limit = UINT64_MAX) {\n    return Value->getLimitedValue(Limit);\n  }\n  MaybeAlign getMaybeAlignValue() const { return Value->getMaybeAlignValue(); }\n  Align getAlignValue() const { return Value->getAlignValue(); }\n\n  bool isOne() const { return Value->isOne(); }\n  bool isNullValue() const { return Value->isZero(); }\n  bool isAllOnesValue() const { return Value->isMinusOne(); }\n\n  bool isOpaque() const { return ConstantSDNodeBits.IsOpaque; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::Constant ||\n           N->getOpcode() == ISD::TargetConstant;\n  }\n};\n\nuint64_t SDNode::getConstantOperandVal(unsigned Num) const {\n  return cast<ConstantSDNode>(getOperand(Num))->getZExtValue();\n}\n\nconst APInt &SDNode::getConstantOperandAPInt(unsigned Num) const {\n  return cast<ConstantSDNode>(getOperand(Num))->getAPIntValue();\n}\n\nclass ConstantFPSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  const ConstantFP *Value;\n\n  ConstantFPSDNode(bool isTarget, const ConstantFP *val, EVT VT)\n      : SDNode(isTarget ? ISD::TargetConstantFP : ISD::ConstantFP, 0,\n               DebugLoc(), getSDVTList(VT)),\n        Value(val) {}\n\npublic:\n  const APFloat& getValueAPF() const { return Value->getValueAPF(); }\n  const ConstantFP *getConstantFPValue() const { return Value; }\n\n  /// Return true if the value is positive or negative zero.\n  bool isZero() const { return Value->isZero(); }\n\n  /// Return true if the value is a NaN.\n  bool isNaN() const { return Value->isNaN(); }\n\n  /// Return true if the value is an infinity\n  bool isInfinity() const { return Value->isInfinity(); }\n\n  /// Return true if the value is negative.\n  bool isNegative() const { return Value->isNegative(); }\n\n  /// We don't rely on operator== working on double values, as\n  /// it returns true for things that are clearly not equal, like -0.0 and 0.0.\n  /// As such, this method can be used to do an exact bit-for-bit comparison of\n  /// two floating point values.\n\n  /// We leave the version with the double argument here because it's just so\n  /// convenient to write \"2.0\" and the like.  Without this function we'd\n  /// have to duplicate its logic everywhere it's called.\n  bool isExactlyValue(double V) const {\n    return Value->getValueAPF().isExactlyValue(V);\n  }\n  bool isExactlyValue(const APFloat& V) const;\n\n  static bool isValueValidForType(EVT VT, const APFloat& Val);\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::ConstantFP ||\n           N->getOpcode() == ISD::TargetConstantFP;\n  }\n};\n\n/// Returns true if \\p V is a constant integer zero.\nbool isNullConstant(SDValue V);\n\n/// Returns true if \\p V is an FP constant with a value of positive zero.\nbool isNullFPConstant(SDValue V);\n\n/// Returns true if \\p V is an integer constant with all bits set.\nbool isAllOnesConstant(SDValue V);\n\n/// Returns true if \\p V is a constant integer one.\nbool isOneConstant(SDValue V);\n\n/// Return the non-bitcasted source operand of \\p V if it exists.\n/// If \\p V is not a bitcasted value, it is returned as-is.\nSDValue peekThroughBitcasts(SDValue V);\n\n/// Return the non-bitcasted and one-use source operand of \\p V if it exists.\n/// If \\p V is not a bitcasted one-use value, it is returned as-is.\nSDValue peekThroughOneUseBitcasts(SDValue V);\n\n/// Return the non-extracted vector source operand of \\p V if it exists.\n/// If \\p V is not an extracted subvector, it is returned as-is.\nSDValue peekThroughExtractSubvectors(SDValue V);\n\n/// Returns true if \\p V is a bitwise not operation. Assumes that an all ones\n/// constant is canonicalized to be operand 1.\nbool isBitwiseNot(SDValue V, bool AllowUndefs = false);\n\n/// Returns the SDNode if it is a constant splat BuildVector or constant int.\nConstantSDNode *isConstOrConstSplat(SDValue N, bool AllowUndefs = false,\n                                    bool AllowTruncation = false);\n\n/// Returns the SDNode if it is a demanded constant splat BuildVector or\n/// constant int.\nConstantSDNode *isConstOrConstSplat(SDValue N, const APInt &DemandedElts,\n                                    bool AllowUndefs = false,\n                                    bool AllowTruncation = false);\n\n/// Returns the SDNode if it is a constant splat BuildVector or constant float.\nConstantFPSDNode *isConstOrConstSplatFP(SDValue N, bool AllowUndefs = false);\n\n/// Returns the SDNode if it is a demanded constant splat BuildVector or\n/// constant float.\nConstantFPSDNode *isConstOrConstSplatFP(SDValue N, const APInt &DemandedElts,\n                                        bool AllowUndefs = false);\n\n/// Return true if the value is a constant 0 integer or a splatted vector of\n/// a constant 0 integer (with no undefs by default).\n/// Build vector implicit truncation is not an issue for null values.\nbool isNullOrNullSplat(SDValue V, bool AllowUndefs = false);\n\n/// Return true if the value is a constant 1 integer or a splatted vector of a\n/// constant 1 integer (with no undefs).\n/// Does not permit build vector implicit truncation.\nbool isOneOrOneSplat(SDValue V, bool AllowUndefs = false);\n\n/// Return true if the value is a constant -1 integer or a splatted vector of a\n/// constant -1 integer (with no undefs).\n/// Does not permit build vector implicit truncation.\nbool isAllOnesOrAllOnesSplat(SDValue V, bool AllowUndefs = false);\n\nclass GlobalAddressSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  const GlobalValue *TheGlobal;\n  int64_t Offset;\n  unsigned TargetFlags;\n\n  GlobalAddressSDNode(unsigned Opc, unsigned Order, const DebugLoc &DL,\n                      const GlobalValue *GA, EVT VT, int64_t o,\n                      unsigned TF);\n\npublic:\n  const GlobalValue *getGlobal() const { return TheGlobal; }\n  int64_t getOffset() const { return Offset; }\n  unsigned getTargetFlags() const { return TargetFlags; }\n  // Return the address space this GlobalAddress belongs to.\n  unsigned getAddressSpace() const;\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::GlobalAddress ||\n           N->getOpcode() == ISD::TargetGlobalAddress ||\n           N->getOpcode() == ISD::GlobalTLSAddress ||\n           N->getOpcode() == ISD::TargetGlobalTLSAddress;\n  }\n};\n\nclass FrameIndexSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  int FI;\n\n  FrameIndexSDNode(int fi, EVT VT, bool isTarg)\n    : SDNode(isTarg ? ISD::TargetFrameIndex : ISD::FrameIndex,\n      0, DebugLoc(), getSDVTList(VT)), FI(fi) {\n  }\n\npublic:\n  int getIndex() const { return FI; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::FrameIndex ||\n           N->getOpcode() == ISD::TargetFrameIndex;\n  }\n};\n\n/// This SDNode is used for LIFETIME_START/LIFETIME_END values, which indicate\n/// the offet and size that are started/ended in the underlying FrameIndex.\nclass LifetimeSDNode : public SDNode {\n  friend class SelectionDAG;\n  int64_t Size;\n  int64_t Offset; // -1 if offset is unknown.\n\n  LifetimeSDNode(unsigned Opcode, unsigned Order, const DebugLoc &dl,\n                 SDVTList VTs, int64_t Size, int64_t Offset)\n      : SDNode(Opcode, Order, dl, VTs), Size(Size), Offset(Offset) {}\npublic:\n  int64_t getFrameIndex() const {\n    return cast<FrameIndexSDNode>(getOperand(1))->getIndex();\n  }\n\n  bool hasOffset() const { return Offset >= 0; }\n  int64_t getOffset() const {\n    assert(hasOffset() && \"offset is unknown\");\n    return Offset;\n  }\n  int64_t getSize() const {\n    assert(hasOffset() && \"offset is unknown\");\n    return Size;\n  }\n\n  // Methods to support isa and dyn_cast\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::LIFETIME_START ||\n           N->getOpcode() == ISD::LIFETIME_END;\n  }\n};\n\n/// This SDNode is used for PSEUDO_PROBE values, which are the function guid and\n/// the index of the basic block being probed. A pseudo probe serves as a place\n/// holder and will be removed at the end of compilation. It does not have any\n/// operand because we do not want the instruction selection to deal with any.\nclass PseudoProbeSDNode : public SDNode {\n  friend class SelectionDAG;\n  uint64_t Guid;\n  uint64_t Index;\n  uint32_t Attributes;\n\n  PseudoProbeSDNode(unsigned Opcode, unsigned Order, const DebugLoc &Dl,\n                    SDVTList VTs, uint64_t Guid, uint64_t Index, uint32_t Attr)\n      : SDNode(Opcode, Order, Dl, VTs), Guid(Guid), Index(Index),\n        Attributes(Attr) {}\n\npublic:\n  uint64_t getGuid() const { return Guid; }\n  uint64_t getIndex() const { return Index; }\n  uint32_t getAttributes() const { return Attributes; }\n\n  // Methods to support isa and dyn_cast\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::PSEUDO_PROBE;\n  }\n};\n\nclass JumpTableSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  int JTI;\n  unsigned TargetFlags;\n\n  JumpTableSDNode(int jti, EVT VT, bool isTarg, unsigned TF)\n    : SDNode(isTarg ? ISD::TargetJumpTable : ISD::JumpTable,\n      0, DebugLoc(), getSDVTList(VT)), JTI(jti), TargetFlags(TF) {\n  }\n\npublic:\n  int getIndex() const { return JTI; }\n  unsigned getTargetFlags() const { return TargetFlags; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::JumpTable ||\n           N->getOpcode() == ISD::TargetJumpTable;\n  }\n};\n\nclass ConstantPoolSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  union {\n    const Constant *ConstVal;\n    MachineConstantPoolValue *MachineCPVal;\n  } Val;\n  int Offset;  // It's a MachineConstantPoolValue if top bit is set.\n  Align Alignment; // Minimum alignment requirement of CP.\n  unsigned TargetFlags;\n\n  ConstantPoolSDNode(bool isTarget, const Constant *c, EVT VT, int o,\n                     Align Alignment, unsigned TF)\n      : SDNode(isTarget ? ISD::TargetConstantPool : ISD::ConstantPool, 0,\n               DebugLoc(), getSDVTList(VT)),\n        Offset(o), Alignment(Alignment), TargetFlags(TF) {\n    assert(Offset >= 0 && \"Offset is too large\");\n    Val.ConstVal = c;\n  }\n\n  ConstantPoolSDNode(bool isTarget, MachineConstantPoolValue *v, EVT VT, int o,\n                     Align Alignment, unsigned TF)\n      : SDNode(isTarget ? ISD::TargetConstantPool : ISD::ConstantPool, 0,\n               DebugLoc(), getSDVTList(VT)),\n        Offset(o), Alignment(Alignment), TargetFlags(TF) {\n    assert(Offset >= 0 && \"Offset is too large\");\n    Val.MachineCPVal = v;\n    Offset |= 1 << (sizeof(unsigned)*CHAR_BIT-1);\n  }\n\npublic:\n  bool isMachineConstantPoolEntry() const {\n    return Offset < 0;\n  }\n\n  const Constant *getConstVal() const {\n    assert(!isMachineConstantPoolEntry() && \"Wrong constantpool type\");\n    return Val.ConstVal;\n  }\n\n  MachineConstantPoolValue *getMachineCPVal() const {\n    assert(isMachineConstantPoolEntry() && \"Wrong constantpool type\");\n    return Val.MachineCPVal;\n  }\n\n  int getOffset() const {\n    return Offset & ~(1 << (sizeof(unsigned)*CHAR_BIT-1));\n  }\n\n  // Return the alignment of this constant pool object, which is either 0 (for\n  // default alignment) or the desired value.\n  Align getAlign() const { return Alignment; }\n  unsigned getTargetFlags() const { return TargetFlags; }\n\n  Type *getType() const;\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::ConstantPool ||\n           N->getOpcode() == ISD::TargetConstantPool;\n  }\n};\n\n/// Completely target-dependent object reference.\nclass TargetIndexSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  unsigned TargetFlags;\n  int Index;\n  int64_t Offset;\n\npublic:\n  TargetIndexSDNode(int Idx, EVT VT, int64_t Ofs, unsigned TF)\n      : SDNode(ISD::TargetIndex, 0, DebugLoc(), getSDVTList(VT)),\n        TargetFlags(TF), Index(Idx), Offset(Ofs) {}\n\n  unsigned getTargetFlags() const { return TargetFlags; }\n  int getIndex() const { return Index; }\n  int64_t getOffset() const { return Offset; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::TargetIndex;\n  }\n};\n\nclass BasicBlockSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  MachineBasicBlock *MBB;\n\n  /// Debug info is meaningful and potentially useful here, but we create\n  /// blocks out of order when they're jumped to, which makes it a bit\n  /// harder.  Let's see if we need it first.\n  explicit BasicBlockSDNode(MachineBasicBlock *mbb)\n    : SDNode(ISD::BasicBlock, 0, DebugLoc(), getSDVTList(MVT::Other)), MBB(mbb)\n  {}\n\npublic:\n  MachineBasicBlock *getBasicBlock() const { return MBB; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::BasicBlock;\n  }\n};\n\n/// A \"pseudo-class\" with methods for operating on BUILD_VECTORs.\nclass BuildVectorSDNode : public SDNode {\npublic:\n  // These are constructed as SDNodes and then cast to BuildVectorSDNodes.\n  explicit BuildVectorSDNode() = delete;\n\n  /// Check if this is a constant splat, and if so, find the\n  /// smallest element size that splats the vector.  If MinSplatBits is\n  /// nonzero, the element size must be at least that large.  Note that the\n  /// splat element may be the entire vector (i.e., a one element vector).\n  /// Returns the splat element value in SplatValue.  Any undefined bits in\n  /// that value are zero, and the corresponding bits in the SplatUndef mask\n  /// are set.  The SplatBitSize value is set to the splat element size in\n  /// bits.  HasAnyUndefs is set to true if any bits in the vector are\n  /// undefined.  isBigEndian describes the endianness of the target.\n  bool isConstantSplat(APInt &SplatValue, APInt &SplatUndef,\n                       unsigned &SplatBitSize, bool &HasAnyUndefs,\n                       unsigned MinSplatBits = 0,\n                       bool isBigEndian = false) const;\n\n  /// Returns the demanded splatted value or a null value if this is not a\n  /// splat.\n  ///\n  /// The DemandedElts mask indicates the elements that must be in the splat.\n  /// If passed a non-null UndefElements bitvector, it will resize it to match\n  /// the vector width and set the bits where elements are undef.\n  SDValue getSplatValue(const APInt &DemandedElts,\n                        BitVector *UndefElements = nullptr) const;\n\n  /// Returns the splatted value or a null value if this is not a splat.\n  ///\n  /// If passed a non-null UndefElements bitvector, it will resize it to match\n  /// the vector width and set the bits where elements are undef.\n  SDValue getSplatValue(BitVector *UndefElements = nullptr) const;\n\n  /// Find the shortest repeating sequence of values in the build vector.\n  ///\n  /// e.g. { u, X, u, X, u, u, X, u } -> { X }\n  ///      { X, Y, u, Y, u, u, X, u } -> { X, Y }\n  ///\n  /// Currently this must be a power-of-2 build vector.\n  /// The DemandedElts mask indicates the elements that must be present,\n  /// undemanded elements in Sequence may be null (SDValue()). If passed a\n  /// non-null UndefElements bitvector, it will resize it to match the original\n  /// vector width and set the bits where elements are undef. If result is\n  /// false, Sequence will be empty.\n  bool getRepeatedSequence(const APInt &DemandedElts,\n                           SmallVectorImpl<SDValue> &Sequence,\n                           BitVector *UndefElements = nullptr) const;\n\n  /// Find the shortest repeating sequence of values in the build vector.\n  ///\n  /// e.g. { u, X, u, X, u, u, X, u } -> { X }\n  ///      { X, Y, u, Y, u, u, X, u } -> { X, Y }\n  ///\n  /// Currently this must be a power-of-2 build vector.\n  /// If passed a non-null UndefElements bitvector, it will resize it to match\n  /// the original vector width and set the bits where elements are undef.\n  /// If result is false, Sequence will be empty.\n  bool getRepeatedSequence(SmallVectorImpl<SDValue> &Sequence,\n                           BitVector *UndefElements = nullptr) const;\n\n  /// Returns the demanded splatted constant or null if this is not a constant\n  /// splat.\n  ///\n  /// The DemandedElts mask indicates the elements that must be in the splat.\n  /// If passed a non-null UndefElements bitvector, it will resize it to match\n  /// the vector width and set the bits where elements are undef.\n  ConstantSDNode *\n  getConstantSplatNode(const APInt &DemandedElts,\n                       BitVector *UndefElements = nullptr) const;\n\n  /// Returns the splatted constant or null if this is not a constant\n  /// splat.\n  ///\n  /// If passed a non-null UndefElements bitvector, it will resize it to match\n  /// the vector width and set the bits where elements are undef.\n  ConstantSDNode *\n  getConstantSplatNode(BitVector *UndefElements = nullptr) const;\n\n  /// Returns the demanded splatted constant FP or null if this is not a\n  /// constant FP splat.\n  ///\n  /// The DemandedElts mask indicates the elements that must be in the splat.\n  /// If passed a non-null UndefElements bitvector, it will resize it to match\n  /// the vector width and set the bits where elements are undef.\n  ConstantFPSDNode *\n  getConstantFPSplatNode(const APInt &DemandedElts,\n                         BitVector *UndefElements = nullptr) const;\n\n  /// Returns the splatted constant FP or null if this is not a constant\n  /// FP splat.\n  ///\n  /// If passed a non-null UndefElements bitvector, it will resize it to match\n  /// the vector width and set the bits where elements are undef.\n  ConstantFPSDNode *\n  getConstantFPSplatNode(BitVector *UndefElements = nullptr) const;\n\n  /// If this is a constant FP splat and the splatted constant FP is an\n  /// exact power or 2, return the log base 2 integer value.  Otherwise,\n  /// return -1.\n  ///\n  /// The BitWidth specifies the necessary bit precision.\n  int32_t getConstantFPSplatPow2ToLog2Int(BitVector *UndefElements,\n                                          uint32_t BitWidth) const;\n\n  bool isConstant() const;\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::BUILD_VECTOR;\n  }\n};\n\n/// An SDNode that holds an arbitrary LLVM IR Value. This is\n/// used when the SelectionDAG needs to make a simple reference to something\n/// in the LLVM IR representation.\n///\nclass SrcValueSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  const Value *V;\n\n  /// Create a SrcValue for a general value.\n  explicit SrcValueSDNode(const Value *v)\n    : SDNode(ISD::SRCVALUE, 0, DebugLoc(), getSDVTList(MVT::Other)), V(v) {}\n\npublic:\n  /// Return the contained Value.\n  const Value *getValue() const { return V; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::SRCVALUE;\n  }\n};\n\nclass MDNodeSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  const MDNode *MD;\n\n  explicit MDNodeSDNode(const MDNode *md)\n  : SDNode(ISD::MDNODE_SDNODE, 0, DebugLoc(), getSDVTList(MVT::Other)), MD(md)\n  {}\n\npublic:\n  const MDNode *getMD() const { return MD; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::MDNODE_SDNODE;\n  }\n};\n\nclass RegisterSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  Register Reg;\n\n  RegisterSDNode(Register reg, EVT VT)\n    : SDNode(ISD::Register, 0, DebugLoc(), getSDVTList(VT)), Reg(reg) {}\n\npublic:\n  Register getReg() const { return Reg; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::Register;\n  }\n};\n\nclass RegisterMaskSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  // The memory for RegMask is not owned by the node.\n  const uint32_t *RegMask;\n\n  RegisterMaskSDNode(const uint32_t *mask)\n    : SDNode(ISD::RegisterMask, 0, DebugLoc(), getSDVTList(MVT::Untyped)),\n      RegMask(mask) {}\n\npublic:\n  const uint32_t *getRegMask() const { return RegMask; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::RegisterMask;\n  }\n};\n\nclass BlockAddressSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  const BlockAddress *BA;\n  int64_t Offset;\n  unsigned TargetFlags;\n\n  BlockAddressSDNode(unsigned NodeTy, EVT VT, const BlockAddress *ba,\n                     int64_t o, unsigned Flags)\n    : SDNode(NodeTy, 0, DebugLoc(), getSDVTList(VT)),\n             BA(ba), Offset(o), TargetFlags(Flags) {}\n\npublic:\n  const BlockAddress *getBlockAddress() const { return BA; }\n  int64_t getOffset() const { return Offset; }\n  unsigned getTargetFlags() const { return TargetFlags; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::BlockAddress ||\n           N->getOpcode() == ISD::TargetBlockAddress;\n  }\n};\n\nclass LabelSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  MCSymbol *Label;\n\n  LabelSDNode(unsigned Opcode, unsigned Order, const DebugLoc &dl, MCSymbol *L)\n      : SDNode(Opcode, Order, dl, getSDVTList(MVT::Other)), Label(L) {\n    assert(LabelSDNode::classof(this) && \"not a label opcode\");\n  }\n\npublic:\n  MCSymbol *getLabel() const { return Label; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::EH_LABEL ||\n           N->getOpcode() == ISD::ANNOTATION_LABEL;\n  }\n};\n\nclass ExternalSymbolSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  const char *Symbol;\n  unsigned TargetFlags;\n\n  ExternalSymbolSDNode(bool isTarget, const char *Sym, unsigned TF, EVT VT)\n      : SDNode(isTarget ? ISD::TargetExternalSymbol : ISD::ExternalSymbol, 0,\n               DebugLoc(), getSDVTList(VT)),\n        Symbol(Sym), TargetFlags(TF) {}\n\npublic:\n  const char *getSymbol() const { return Symbol; }\n  unsigned getTargetFlags() const { return TargetFlags; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::ExternalSymbol ||\n           N->getOpcode() == ISD::TargetExternalSymbol;\n  }\n};\n\nclass MCSymbolSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  MCSymbol *Symbol;\n\n  MCSymbolSDNode(MCSymbol *Symbol, EVT VT)\n      : SDNode(ISD::MCSymbol, 0, DebugLoc(), getSDVTList(VT)), Symbol(Symbol) {}\n\npublic:\n  MCSymbol *getMCSymbol() const { return Symbol; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::MCSymbol;\n  }\n};\n\nclass CondCodeSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  ISD::CondCode Condition;\n\n  explicit CondCodeSDNode(ISD::CondCode Cond)\n    : SDNode(ISD::CONDCODE, 0, DebugLoc(), getSDVTList(MVT::Other)),\n      Condition(Cond) {}\n\npublic:\n  ISD::CondCode get() const { return Condition; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::CONDCODE;\n  }\n};\n\n/// This class is used to represent EVT's, which are used\n/// to parameterize some operations.\nclass VTSDNode : public SDNode {\n  friend class SelectionDAG;\n\n  EVT ValueType;\n\n  explicit VTSDNode(EVT VT)\n    : SDNode(ISD::VALUETYPE, 0, DebugLoc(), getSDVTList(MVT::Other)),\n      ValueType(VT) {}\n\npublic:\n  EVT getVT() const { return ValueType; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::VALUETYPE;\n  }\n};\n\n/// Base class for LoadSDNode and StoreSDNode\nclass LSBaseSDNode : public MemSDNode {\npublic:\n  LSBaseSDNode(ISD::NodeType NodeTy, unsigned Order, const DebugLoc &dl,\n               SDVTList VTs, ISD::MemIndexedMode AM, EVT MemVT,\n               MachineMemOperand *MMO)\n      : MemSDNode(NodeTy, Order, dl, VTs, MemVT, MMO) {\n    LSBaseSDNodeBits.AddressingMode = AM;\n    assert(getAddressingMode() == AM && \"Value truncated\");\n  }\n\n  const SDValue &getOffset() const {\n    return getOperand(getOpcode() == ISD::LOAD ? 2 : 3);\n  }\n\n  /// Return the addressing mode for this load or store:\n  /// unindexed, pre-inc, pre-dec, post-inc, or post-dec.\n  ISD::MemIndexedMode getAddressingMode() const {\n    return static_cast<ISD::MemIndexedMode>(LSBaseSDNodeBits.AddressingMode);\n  }\n\n  /// Return true if this is a pre/post inc/dec load/store.\n  bool isIndexed() const { return getAddressingMode() != ISD::UNINDEXED; }\n\n  /// Return true if this is NOT a pre/post inc/dec load/store.\n  bool isUnindexed() const { return getAddressingMode() == ISD::UNINDEXED; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::LOAD ||\n           N->getOpcode() == ISD::STORE;\n  }\n};\n\n/// This class is used to represent ISD::LOAD nodes.\nclass LoadSDNode : public LSBaseSDNode {\n  friend class SelectionDAG;\n\n  LoadSDNode(unsigned Order, const DebugLoc &dl, SDVTList VTs,\n             ISD::MemIndexedMode AM, ISD::LoadExtType ETy, EVT MemVT,\n             MachineMemOperand *MMO)\n      : LSBaseSDNode(ISD::LOAD, Order, dl, VTs, AM, MemVT, MMO) {\n    LoadSDNodeBits.ExtTy = ETy;\n    assert(readMem() && \"Load MachineMemOperand is not a load!\");\n    assert(!writeMem() && \"Load MachineMemOperand is a store!\");\n  }\n\npublic:\n  /// Return whether this is a plain node,\n  /// or one of the varieties of value-extending loads.\n  ISD::LoadExtType getExtensionType() const {\n    return static_cast<ISD::LoadExtType>(LoadSDNodeBits.ExtTy);\n  }\n\n  const SDValue &getBasePtr() const { return getOperand(1); }\n  const SDValue &getOffset() const { return getOperand(2); }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::LOAD;\n  }\n};\n\n/// This class is used to represent ISD::STORE nodes.\nclass StoreSDNode : public LSBaseSDNode {\n  friend class SelectionDAG;\n\n  StoreSDNode(unsigned Order, const DebugLoc &dl, SDVTList VTs,\n              ISD::MemIndexedMode AM, bool isTrunc, EVT MemVT,\n              MachineMemOperand *MMO)\n      : LSBaseSDNode(ISD::STORE, Order, dl, VTs, AM, MemVT, MMO) {\n    StoreSDNodeBits.IsTruncating = isTrunc;\n    assert(!readMem() && \"Store MachineMemOperand is a load!\");\n    assert(writeMem() && \"Store MachineMemOperand is not a store!\");\n  }\n\npublic:\n  /// Return true if the op does a truncation before store.\n  /// For integers this is the same as doing a TRUNCATE and storing the result.\n  /// For floats, it is the same as doing an FP_ROUND and storing the result.\n  bool isTruncatingStore() const { return StoreSDNodeBits.IsTruncating; }\n  void setTruncatingStore(bool Truncating) {\n    StoreSDNodeBits.IsTruncating = Truncating;\n  }\n\n  const SDValue &getValue() const { return getOperand(1); }\n  const SDValue &getBasePtr() const { return getOperand(2); }\n  const SDValue &getOffset() const { return getOperand(3); }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::STORE;\n  }\n};\n\n/// This base class is used to represent MLOAD and MSTORE nodes\nclass MaskedLoadStoreSDNode : public MemSDNode {\npublic:\n  friend class SelectionDAG;\n\n  MaskedLoadStoreSDNode(ISD::NodeType NodeTy, unsigned Order,\n                        const DebugLoc &dl, SDVTList VTs,\n                        ISD::MemIndexedMode AM, EVT MemVT,\n                        MachineMemOperand *MMO)\n      : MemSDNode(NodeTy, Order, dl, VTs, MemVT, MMO) {\n    LSBaseSDNodeBits.AddressingMode = AM;\n    assert(getAddressingMode() == AM && \"Value truncated\");\n  }\n\n  // MaskedLoadSDNode (Chain, ptr, offset, mask, passthru)\n  // MaskedStoreSDNode (Chain, data, ptr, offset, mask)\n  // Mask is a vector of i1 elements\n  const SDValue &getOffset() const {\n    return getOperand(getOpcode() == ISD::MLOAD ? 2 : 3);\n  }\n  const SDValue &getMask() const {\n    return getOperand(getOpcode() == ISD::MLOAD ? 3 : 4);\n  }\n\n  /// Return the addressing mode for this load or store:\n  /// unindexed, pre-inc, pre-dec, post-inc, or post-dec.\n  ISD::MemIndexedMode getAddressingMode() const {\n    return static_cast<ISD::MemIndexedMode>(LSBaseSDNodeBits.AddressingMode);\n  }\n\n  /// Return true if this is a pre/post inc/dec load/store.\n  bool isIndexed() const { return getAddressingMode() != ISD::UNINDEXED; }\n\n  /// Return true if this is NOT a pre/post inc/dec load/store.\n  bool isUnindexed() const { return getAddressingMode() == ISD::UNINDEXED; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::MLOAD ||\n           N->getOpcode() == ISD::MSTORE;\n  }\n};\n\n/// This class is used to represent an MLOAD node\nclass MaskedLoadSDNode : public MaskedLoadStoreSDNode {\npublic:\n  friend class SelectionDAG;\n\n  MaskedLoadSDNode(unsigned Order, const DebugLoc &dl, SDVTList VTs,\n                   ISD::MemIndexedMode AM, ISD::LoadExtType ETy,\n                   bool IsExpanding, EVT MemVT, MachineMemOperand *MMO)\n      : MaskedLoadStoreSDNode(ISD::MLOAD, Order, dl, VTs, AM, MemVT, MMO) {\n    LoadSDNodeBits.ExtTy = ETy;\n    LoadSDNodeBits.IsExpanding = IsExpanding;\n  }\n\n  ISD::LoadExtType getExtensionType() const {\n    return static_cast<ISD::LoadExtType>(LoadSDNodeBits.ExtTy);\n  }\n\n  const SDValue &getBasePtr() const { return getOperand(1); }\n  const SDValue &getOffset() const { return getOperand(2); }\n  const SDValue &getMask() const { return getOperand(3); }\n  const SDValue &getPassThru() const { return getOperand(4); }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::MLOAD;\n  }\n\n  bool isExpandingLoad() const { return LoadSDNodeBits.IsExpanding; }\n};\n\n/// This class is used to represent an MSTORE node\nclass MaskedStoreSDNode : public MaskedLoadStoreSDNode {\npublic:\n  friend class SelectionDAG;\n\n  MaskedStoreSDNode(unsigned Order, const DebugLoc &dl, SDVTList VTs,\n                    ISD::MemIndexedMode AM, bool isTrunc, bool isCompressing,\n                    EVT MemVT, MachineMemOperand *MMO)\n      : MaskedLoadStoreSDNode(ISD::MSTORE, Order, dl, VTs, AM, MemVT, MMO) {\n    StoreSDNodeBits.IsTruncating = isTrunc;\n    StoreSDNodeBits.IsCompressing = isCompressing;\n  }\n\n  /// Return true if the op does a truncation before store.\n  /// For integers this is the same as doing a TRUNCATE and storing the result.\n  /// For floats, it is the same as doing an FP_ROUND and storing the result.\n  bool isTruncatingStore() const { return StoreSDNodeBits.IsTruncating; }\n\n  /// Returns true if the op does a compression to the vector before storing.\n  /// The node contiguously stores the active elements (integers or floats)\n  /// in src (those with their respective bit set in writemask k) to unaligned\n  /// memory at base_addr.\n  bool isCompressingStore() const { return StoreSDNodeBits.IsCompressing; }\n\n  const SDValue &getValue() const { return getOperand(1); }\n  const SDValue &getBasePtr() const { return getOperand(2); }\n  const SDValue &getOffset() const { return getOperand(3); }\n  const SDValue &getMask() const { return getOperand(4); }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::MSTORE;\n  }\n};\n\n/// This is a base class used to represent\n/// MGATHER and MSCATTER nodes\n///\nclass MaskedGatherScatterSDNode : public MemSDNode {\npublic:\n  friend class SelectionDAG;\n\n  MaskedGatherScatterSDNode(ISD::NodeType NodeTy, unsigned Order,\n                            const DebugLoc &dl, SDVTList VTs, EVT MemVT,\n                            MachineMemOperand *MMO, ISD::MemIndexType IndexType)\n      : MemSDNode(NodeTy, Order, dl, VTs, MemVT, MMO) {\n    LSBaseSDNodeBits.AddressingMode = IndexType;\n    assert(getIndexType() == IndexType && \"Value truncated\");\n  }\n\n  /// How is Index applied to BasePtr when computing addresses.\n  ISD::MemIndexType getIndexType() const {\n    return static_cast<ISD::MemIndexType>(LSBaseSDNodeBits.AddressingMode);\n  }\n  void setIndexType(ISD::MemIndexType IndexType) {\n    LSBaseSDNodeBits.AddressingMode = IndexType;\n  }\n  bool isIndexScaled() const {\n    return (getIndexType() == ISD::SIGNED_SCALED) ||\n           (getIndexType() == ISD::UNSIGNED_SCALED);\n  }\n  bool isIndexSigned() const {\n    return (getIndexType() == ISD::SIGNED_SCALED) ||\n           (getIndexType() == ISD::SIGNED_UNSCALED);\n  }\n\n  // In the both nodes address is Op1, mask is Op2:\n  // MaskedGatherSDNode  (Chain, passthru, mask, base, index, scale)\n  // MaskedScatterSDNode (Chain, value, mask, base, index, scale)\n  // Mask is a vector of i1 elements\n  const SDValue &getBasePtr() const { return getOperand(3); }\n  const SDValue &getIndex()   const { return getOperand(4); }\n  const SDValue &getMask()    const { return getOperand(2); }\n  const SDValue &getScale()   const { return getOperand(5); }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::MGATHER ||\n           N->getOpcode() == ISD::MSCATTER;\n  }\n};\n\n/// This class is used to represent an MGATHER node\n///\nclass MaskedGatherSDNode : public MaskedGatherScatterSDNode {\npublic:\n  friend class SelectionDAG;\n\n  MaskedGatherSDNode(unsigned Order, const DebugLoc &dl, SDVTList VTs,\n                     EVT MemVT, MachineMemOperand *MMO,\n                     ISD::MemIndexType IndexType, ISD::LoadExtType ETy)\n      : MaskedGatherScatterSDNode(ISD::MGATHER, Order, dl, VTs, MemVT, MMO,\n                                  IndexType) {\n    LoadSDNodeBits.ExtTy = ETy;\n  }\n\n  const SDValue &getPassThru() const { return getOperand(1); }\n\n  ISD::LoadExtType getExtensionType() const {\n    return ISD::LoadExtType(LoadSDNodeBits.ExtTy);\n  }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::MGATHER;\n  }\n};\n\n/// This class is used to represent an MSCATTER node\n///\nclass MaskedScatterSDNode : public MaskedGatherScatterSDNode {\npublic:\n  friend class SelectionDAG;\n\n  MaskedScatterSDNode(unsigned Order, const DebugLoc &dl, SDVTList VTs,\n                      EVT MemVT, MachineMemOperand *MMO,\n                      ISD::MemIndexType IndexType, bool IsTrunc)\n      : MaskedGatherScatterSDNode(ISD::MSCATTER, Order, dl, VTs, MemVT, MMO,\n                                  IndexType) {\n    StoreSDNodeBits.IsTruncating = IsTrunc;\n  }\n\n  /// Return true if the op does a truncation before store.\n  /// For integers this is the same as doing a TRUNCATE and storing the result.\n  /// For floats, it is the same as doing an FP_ROUND and storing the result.\n  bool isTruncatingStore() const { return StoreSDNodeBits.IsTruncating; }\n\n  const SDValue &getValue() const { return getOperand(1); }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::MSCATTER;\n  }\n};\n\n/// An SDNode that represents everything that will be needed\n/// to construct a MachineInstr. These nodes are created during the\n/// instruction selection proper phase.\n///\n/// Note that the only supported way to set the `memoperands` is by calling the\n/// `SelectionDAG::setNodeMemRefs` function as the memory management happens\n/// inside the DAG rather than in the node.\nclass MachineSDNode : public SDNode {\nprivate:\n  friend class SelectionDAG;\n\n  MachineSDNode(unsigned Opc, unsigned Order, const DebugLoc &DL, SDVTList VTs)\n      : SDNode(Opc, Order, DL, VTs) {}\n\n  // We use a pointer union between a single `MachineMemOperand` pointer and\n  // a pointer to an array of `MachineMemOperand` pointers. This is null when\n  // the number of these is zero, the single pointer variant used when the\n  // number is one, and the array is used for larger numbers.\n  //\n  // The array is allocated via the `SelectionDAG`'s allocator and so will\n  // always live until the DAG is cleaned up and doesn't require ownership here.\n  //\n  // We can't use something simpler like `TinyPtrVector` here because `SDNode`\n  // subclasses aren't managed in a conforming C++ manner. See the comments on\n  // `SelectionDAG::MorphNodeTo` which details what all goes on, but the\n  // constraint here is that these don't manage memory with their constructor or\n  // destructor and can be initialized to a good state even if they start off\n  // uninitialized.\n  PointerUnion<MachineMemOperand *, MachineMemOperand **> MemRefs = {};\n\n  // Note that this could be folded into the above `MemRefs` member if doing so\n  // is advantageous at some point. We don't need to store this in most cases.\n  // However, at the moment this doesn't appear to make the allocation any\n  // smaller and makes the code somewhat simpler to read.\n  int NumMemRefs = 0;\n\npublic:\n  using mmo_iterator = ArrayRef<MachineMemOperand *>::const_iterator;\n\n  ArrayRef<MachineMemOperand *> memoperands() const {\n    // Special case the common cases.\n    if (NumMemRefs == 0)\n      return {};\n    if (NumMemRefs == 1)\n      return makeArrayRef(MemRefs.getAddrOfPtr1(), 1);\n\n    // Otherwise we have an actual array.\n    return makeArrayRef(MemRefs.get<MachineMemOperand **>(), NumMemRefs);\n  }\n  mmo_iterator memoperands_begin() const { return memoperands().begin(); }\n  mmo_iterator memoperands_end() const { return memoperands().end(); }\n  bool memoperands_empty() const { return memoperands().empty(); }\n\n  /// Clear out the memory reference descriptor list.\n  void clearMemRefs() {\n    MemRefs = nullptr;\n    NumMemRefs = 0;\n  }\n\n  static bool classof(const SDNode *N) {\n    return N->isMachineOpcode();\n  }\n};\n\n/// An SDNode that records if a register contains a value that is guaranteed to\n/// be aligned accordingly.\nclass AssertAlignSDNode : public SDNode {\n  Align Alignment;\n\npublic:\n  AssertAlignSDNode(unsigned Order, const DebugLoc &DL, EVT VT, Align A)\n      : SDNode(ISD::AssertAlign, Order, DL, getSDVTList(VT)), Alignment(A) {}\n\n  Align getAlign() const { return Alignment; }\n\n  static bool classof(const SDNode *N) {\n    return N->getOpcode() == ISD::AssertAlign;\n  }\n};\n\nclass SDNodeIterator : public std::iterator<std::forward_iterator_tag,\n                                            SDNode, ptrdiff_t> {\n  const SDNode *Node;\n  unsigned Operand;\n\n  SDNodeIterator(const SDNode *N, unsigned Op) : Node(N), Operand(Op) {}\n\npublic:\n  bool operator==(const SDNodeIterator& x) const {\n    return Operand == x.Operand;\n  }\n  bool operator!=(const SDNodeIterator& x) const { return !operator==(x); }\n\n  pointer operator*() const {\n    return Node->getOperand(Operand).getNode();\n  }\n  pointer operator->() const { return operator*(); }\n\n  SDNodeIterator& operator++() {                // Preincrement\n    ++Operand;\n    return *this;\n  }\n  SDNodeIterator operator++(int) { // Postincrement\n    SDNodeIterator tmp = *this; ++*this; return tmp;\n  }\n  size_t operator-(SDNodeIterator Other) const {\n    assert(Node == Other.Node &&\n           \"Cannot compare iterators of two different nodes!\");\n    return Operand - Other.Operand;\n  }\n\n  static SDNodeIterator begin(const SDNode *N) { return SDNodeIterator(N, 0); }\n  static SDNodeIterator end  (const SDNode *N) {\n    return SDNodeIterator(N, N->getNumOperands());\n  }\n\n  unsigned getOperand() const { return Operand; }\n  const SDNode *getNode() const { return Node; }\n};\n\ntemplate <> struct GraphTraits<SDNode*> {\n  using NodeRef = SDNode *;\n  using ChildIteratorType = SDNodeIterator;\n\n  static NodeRef getEntryNode(SDNode *N) { return N; }\n\n  static ChildIteratorType child_begin(NodeRef N) {\n    return SDNodeIterator::begin(N);\n  }\n\n  static ChildIteratorType child_end(NodeRef N) {\n    return SDNodeIterator::end(N);\n  }\n};\n\n/// A representation of the largest SDNode, for use in sizeof().\n///\n/// This needs to be a union because the largest node differs on 32 bit systems\n/// with 4 and 8 byte pointer alignment, respectively.\nusing LargestSDNode = AlignedCharArrayUnion<AtomicSDNode, TargetIndexSDNode,\n                                            BlockAddressSDNode,\n                                            GlobalAddressSDNode,\n                                            PseudoProbeSDNode>;\n\n/// The SDNode class with the greatest alignment requirement.\nusing MostAlignedSDNode = GlobalAddressSDNode;\n\nnamespace ISD {\n\n  /// Returns true if the specified node is a non-extending and unindexed load.\n  inline bool isNormalLoad(const SDNode *N) {\n    const LoadSDNode *Ld = dyn_cast<LoadSDNode>(N);\n    return Ld && Ld->getExtensionType() == ISD::NON_EXTLOAD &&\n      Ld->getAddressingMode() == ISD::UNINDEXED;\n  }\n\n  /// Returns true if the specified node is a non-extending load.\n  inline bool isNON_EXTLoad(const SDNode *N) {\n    return isa<LoadSDNode>(N) &&\n      cast<LoadSDNode>(N)->getExtensionType() == ISD::NON_EXTLOAD;\n  }\n\n  /// Returns true if the specified node is a EXTLOAD.\n  inline bool isEXTLoad(const SDNode *N) {\n    return isa<LoadSDNode>(N) &&\n      cast<LoadSDNode>(N)->getExtensionType() == ISD::EXTLOAD;\n  }\n\n  /// Returns true if the specified node is a SEXTLOAD.\n  inline bool isSEXTLoad(const SDNode *N) {\n    return isa<LoadSDNode>(N) &&\n      cast<LoadSDNode>(N)->getExtensionType() == ISD::SEXTLOAD;\n  }\n\n  /// Returns true if the specified node is a ZEXTLOAD.\n  inline bool isZEXTLoad(const SDNode *N) {\n    return isa<LoadSDNode>(N) &&\n      cast<LoadSDNode>(N)->getExtensionType() == ISD::ZEXTLOAD;\n  }\n\n  /// Returns true if the specified node is an unindexed load.\n  inline bool isUNINDEXEDLoad(const SDNode *N) {\n    return isa<LoadSDNode>(N) &&\n      cast<LoadSDNode>(N)->getAddressingMode() == ISD::UNINDEXED;\n  }\n\n  /// Returns true if the specified node is a non-truncating\n  /// and unindexed store.\n  inline bool isNormalStore(const SDNode *N) {\n    const StoreSDNode *St = dyn_cast<StoreSDNode>(N);\n    return St && !St->isTruncatingStore() &&\n      St->getAddressingMode() == ISD::UNINDEXED;\n  }\n\n  /// Returns true if the specified node is a non-truncating store.\n  inline bool isNON_TRUNCStore(const SDNode *N) {\n    return isa<StoreSDNode>(N) && !cast<StoreSDNode>(N)->isTruncatingStore();\n  }\n\n  /// Returns true if the specified node is a truncating store.\n  inline bool isTRUNCStore(const SDNode *N) {\n    return isa<StoreSDNode>(N) && cast<StoreSDNode>(N)->isTruncatingStore();\n  }\n\n  /// Returns true if the specified node is an unindexed store.\n  inline bool isUNINDEXEDStore(const SDNode *N) {\n    return isa<StoreSDNode>(N) &&\n      cast<StoreSDNode>(N)->getAddressingMode() == ISD::UNINDEXED;\n  }\n\n  /// Attempt to match a unary predicate against a scalar/splat constant or\n  /// every element of a constant BUILD_VECTOR.\n  /// If AllowUndef is true, then UNDEF elements will pass nullptr to Match.\n  bool matchUnaryPredicate(SDValue Op,\n                           std::function<bool(ConstantSDNode *)> Match,\n                           bool AllowUndefs = false);\n\n  /// Attempt to match a binary predicate against a pair of scalar/splat\n  /// constants or every element of a pair of constant BUILD_VECTORs.\n  /// If AllowUndef is true, then UNDEF elements will pass nullptr to Match.\n  /// If AllowTypeMismatch is true then RetType + ArgTypes don't need to match.\n  bool matchBinaryPredicate(\n      SDValue LHS, SDValue RHS,\n      std::function<bool(ConstantSDNode *, ConstantSDNode *)> Match,\n      bool AllowUndefs = false, bool AllowTypeMismatch = false);\n\n  /// Returns true if the specified value is the overflow result from one\n  /// of the overflow intrinsic nodes.\n  inline bool isOverflowIntrOpRes(SDValue Op) {\n    unsigned Opc = Op.getOpcode();\n    return (Op.getResNo() == 1 &&\n            (Opc == ISD::SADDO || Opc == ISD::UADDO || Opc == ISD::SSUBO ||\n             Opc == ISD::USUBO || Opc == ISD::SMULO || Opc == ISD::UMULO));\n  }\n\n} // end namespace ISD\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_SELECTIONDAGNODES_H\n"}, "37": {"id": 37, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h", "content": "//===- llvm/CodeGen/TargetInstrInfo.h - Instruction Info --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file describes the target machine instruction set to the code generator.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_TARGETINSTRINFO_H\n#define LLVM_CODEGEN_TARGETINSTRINFO_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/CodeGen/MIRFormatter.h\"\n#include \"llvm/CodeGen/MachineBasicBlock.h\"\n#include \"llvm/CodeGen/MachineCombinerPattern.h\"\n#include \"llvm/CodeGen/MachineFunction.h\"\n#include \"llvm/CodeGen/MachineInstr.h\"\n#include \"llvm/CodeGen/MachineInstrBuilder.h\"\n#include \"llvm/CodeGen/MachineOperand.h\"\n#include \"llvm/CodeGen/MachineOutliner.h\"\n#include \"llvm/CodeGen/RegisterClassInfo.h\"\n#include \"llvm/CodeGen/VirtRegMap.h\"\n#include \"llvm/MC/MCInstrInfo.h\"\n#include \"llvm/Support/BranchProbability.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass AAResults;\nclass DFAPacketizer;\nclass InstrItineraryData;\nclass LiveIntervals;\nclass LiveVariables;\nclass MachineLoop;\nclass MachineMemOperand;\nclass MachineRegisterInfo;\nclass MCAsmInfo;\nclass MCInst;\nstruct MCSchedModel;\nclass Module;\nclass ScheduleDAG;\nclass ScheduleDAGMI;\nclass ScheduleHazardRecognizer;\nclass SDNode;\nclass SelectionDAG;\nclass RegScavenger;\nclass TargetRegisterClass;\nclass TargetRegisterInfo;\nclass TargetSchedModel;\nclass TargetSubtargetInfo;\n\ntemplate <class T> class SmallVectorImpl;\n\nusing ParamLoadedValue = std::pair<MachineOperand, DIExpression*>;\n\nstruct DestSourcePair {\n  const MachineOperand *Destination;\n  const MachineOperand *Source;\n\n  DestSourcePair(const MachineOperand &Dest, const MachineOperand &Src)\n      : Destination(&Dest), Source(&Src) {}\n};\n\n/// Used to describe a register and immediate addition.\nstruct RegImmPair {\n  Register Reg;\n  int64_t Imm;\n\n  RegImmPair(Register Reg, int64_t Imm) : Reg(Reg), Imm(Imm) {}\n};\n\n/// Used to describe addressing mode similar to ExtAddrMode in CodeGenPrepare.\n/// It holds the register values, the scale value and the displacement.\nstruct ExtAddrMode {\n  Register BaseReg;\n  Register ScaledReg;\n  int64_t Scale;\n  int64_t Displacement;\n};\n\n//---------------------------------------------------------------------------\n///\n/// TargetInstrInfo - Interface to description of machine instruction set\n///\nclass TargetInstrInfo : public MCInstrInfo {\npublic:\n  TargetInstrInfo(unsigned CFSetupOpcode = ~0u, unsigned CFDestroyOpcode = ~0u,\n                  unsigned CatchRetOpcode = ~0u, unsigned ReturnOpcode = ~0u)\n      : CallFrameSetupOpcode(CFSetupOpcode),\n        CallFrameDestroyOpcode(CFDestroyOpcode), CatchRetOpcode(CatchRetOpcode),\n        ReturnOpcode(ReturnOpcode) {}\n  TargetInstrInfo(const TargetInstrInfo &) = delete;\n  TargetInstrInfo &operator=(const TargetInstrInfo &) = delete;\n  virtual ~TargetInstrInfo();\n\n  static bool isGenericOpcode(unsigned Opc) {\n    return Opc <= TargetOpcode::GENERIC_OP_END;\n  }\n\n  /// Given a machine instruction descriptor, returns the register\n  /// class constraint for OpNum, or NULL.\n  virtual\n  const TargetRegisterClass *getRegClass(const MCInstrDesc &MCID, unsigned OpNum,\n                                         const TargetRegisterInfo *TRI,\n                                         const MachineFunction &MF) const;\n\n  /// Return true if the instruction is trivially rematerializable, meaning it\n  /// has no side effects and requires no operands that aren't always available.\n  /// This means the only allowed uses are constants and unallocatable physical\n  /// registers so that the instructions result is independent of the place\n  /// in the function.\n  bool isTriviallyReMaterializable(const MachineInstr &MI,\n                                   AAResults *AA = nullptr) const {\n    return MI.getOpcode() == TargetOpcode::IMPLICIT_DEF ||\n           (MI.getDesc().isRematerializable() &&\n            (isReallyTriviallyReMaterializable(MI, AA) ||\n             isReallyTriviallyReMaterializableGeneric(MI, AA)));\n  }\n\nprotected:\n  /// For instructions with opcodes for which the M_REMATERIALIZABLE flag is\n  /// set, this hook lets the target specify whether the instruction is actually\n  /// trivially rematerializable, taking into consideration its operands. This\n  /// predicate must return false if the instruction has any side effects other\n  /// than producing a value, or if it requres any address registers that are\n  /// not always available.\n  /// Requirements must be check as stated in isTriviallyReMaterializable() .\n  virtual bool isReallyTriviallyReMaterializable(const MachineInstr &MI,\n                                                 AAResults *AA) const {\n    return false;\n  }\n\n  /// This method commutes the operands of the given machine instruction MI.\n  /// The operands to be commuted are specified by their indices OpIdx1 and\n  /// OpIdx2.\n  ///\n  /// If a target has any instructions that are commutable but require\n  /// converting to different instructions or making non-trivial changes\n  /// to commute them, this method can be overloaded to do that.\n  /// The default implementation simply swaps the commutable operands.\n  ///\n  /// If NewMI is false, MI is modified in place and returned; otherwise, a\n  /// new machine instruction is created and returned.\n  ///\n  /// Do not call this method for a non-commutable instruction.\n  /// Even though the instruction is commutable, the method may still\n  /// fail to commute the operands, null pointer is returned in such cases.\n  virtual MachineInstr *commuteInstructionImpl(MachineInstr &MI, bool NewMI,\n                                               unsigned OpIdx1,\n                                               unsigned OpIdx2) const;\n\n  /// Assigns the (CommutableOpIdx1, CommutableOpIdx2) pair of commutable\n  /// operand indices to (ResultIdx1, ResultIdx2).\n  /// One or both input values of the pair: (ResultIdx1, ResultIdx2) may be\n  /// predefined to some indices or be undefined (designated by the special\n  /// value 'CommuteAnyOperandIndex').\n  /// The predefined result indices cannot be re-defined.\n  /// The function returns true iff after the result pair redefinition\n  /// the fixed result pair is equal to or equivalent to the source pair of\n  /// indices: (CommutableOpIdx1, CommutableOpIdx2). It is assumed here that\n  /// the pairs (x,y) and (y,x) are equivalent.\n  static bool fixCommutedOpIndices(unsigned &ResultIdx1, unsigned &ResultIdx2,\n                                   unsigned CommutableOpIdx1,\n                                   unsigned CommutableOpIdx2);\n\nprivate:\n  /// For instructions with opcodes for which the M_REMATERIALIZABLE flag is\n  /// set and the target hook isReallyTriviallyReMaterializable returns false,\n  /// this function does target-independent tests to determine if the\n  /// instruction is really trivially rematerializable.\n  bool isReallyTriviallyReMaterializableGeneric(const MachineInstr &MI,\n                                                AAResults *AA) const;\n\npublic:\n  /// These methods return the opcode of the frame setup/destroy instructions\n  /// if they exist (-1 otherwise).  Some targets use pseudo instructions in\n  /// order to abstract away the difference between operating with a frame\n  /// pointer and operating without, through the use of these two instructions.\n  ///\n  unsigned getCallFrameSetupOpcode() const { return CallFrameSetupOpcode; }\n  unsigned getCallFrameDestroyOpcode() const { return CallFrameDestroyOpcode; }\n\n  /// Returns true if the argument is a frame pseudo instruction.\n  bool isFrameInstr(const MachineInstr &I) const {\n    return I.getOpcode() == getCallFrameSetupOpcode() ||\n           I.getOpcode() == getCallFrameDestroyOpcode();\n  }\n\n  /// Returns true if the argument is a frame setup pseudo instruction.\n  bool isFrameSetup(const MachineInstr &I) const {\n    return I.getOpcode() == getCallFrameSetupOpcode();\n  }\n\n  /// Returns size of the frame associated with the given frame instruction.\n  /// For frame setup instruction this is frame that is set up space set up\n  /// after the instruction. For frame destroy instruction this is the frame\n  /// freed by the caller.\n  /// Note, in some cases a call frame (or a part of it) may be prepared prior\n  /// to the frame setup instruction. It occurs in the calls that involve\n  /// inalloca arguments. This function reports only the size of the frame part\n  /// that is set up between the frame setup and destroy pseudo instructions.\n  int64_t getFrameSize(const MachineInstr &I) const {\n    assert(isFrameInstr(I) && \"Not a frame instruction\");\n    assert(I.getOperand(0).getImm() >= 0);\n    return I.getOperand(0).getImm();\n  }\n\n  /// Returns the total frame size, which is made up of the space set up inside\n  /// the pair of frame start-stop instructions and the space that is set up\n  /// prior to the pair.\n  int64_t getFrameTotalSize(const MachineInstr &I) const {\n    if (isFrameSetup(I)) {\n      assert(I.getOperand(1).getImm() >= 0 &&\n             \"Frame size must not be negative\");\n      return getFrameSize(I) + I.getOperand(1).getImm();\n    }\n    return getFrameSize(I);\n  }\n\n  unsigned getCatchReturnOpcode() const { return CatchRetOpcode; }\n  unsigned getReturnOpcode() const { return ReturnOpcode; }\n\n  /// Returns the actual stack pointer adjustment made by an instruction\n  /// as part of a call sequence. By default, only call frame setup/destroy\n  /// instructions adjust the stack, but targets may want to override this\n  /// to enable more fine-grained adjustment, or adjust by a different value.\n  virtual int getSPAdjust(const MachineInstr &MI) const;\n\n  /// Return true if the instruction is a \"coalescable\" extension instruction.\n  /// That is, it's like a copy where it's legal for the source to overlap the\n  /// destination. e.g. X86::MOVSX64rr32. If this returns true, then it's\n  /// expected the pre-extension value is available as a subreg of the result\n  /// register. This also returns the sub-register index in SubIdx.\n  virtual bool isCoalescableExtInstr(const MachineInstr &MI, Register &SrcReg,\n                                     Register &DstReg, unsigned &SubIdx) const {\n    return false;\n  }\n\n  /// If the specified machine instruction is a direct\n  /// load from a stack slot, return the virtual or physical register number of\n  /// the destination along with the FrameIndex of the loaded stack slot.  If\n  /// not, return 0.  This predicate must return 0 if the instruction has\n  /// any side effects other than loading from the stack slot.\n  virtual unsigned isLoadFromStackSlot(const MachineInstr &MI,\n                                       int &FrameIndex) const {\n    return 0;\n  }\n\n  /// Optional extension of isLoadFromStackSlot that returns the number of\n  /// bytes loaded from the stack. This must be implemented if a backend\n  /// supports partial stack slot spills/loads to further disambiguate\n  /// what the load does.\n  virtual unsigned isLoadFromStackSlot(const MachineInstr &MI,\n                                       int &FrameIndex,\n                                       unsigned &MemBytes) const {\n    MemBytes = 0;\n    return isLoadFromStackSlot(MI, FrameIndex);\n  }\n\n  /// Check for post-frame ptr elimination stack locations as well.\n  /// This uses a heuristic so it isn't reliable for correctness.\n  virtual unsigned isLoadFromStackSlotPostFE(const MachineInstr &MI,\n                                             int &FrameIndex) const {\n    return 0;\n  }\n\n  /// If the specified machine instruction has a load from a stack slot,\n  /// return true along with the FrameIndices of the loaded stack slot and the\n  /// machine mem operands containing the reference.\n  /// If not, return false.  Unlike isLoadFromStackSlot, this returns true for\n  /// any instructions that loads from the stack.  This is just a hint, as some\n  /// cases may be missed.\n  virtual bool hasLoadFromStackSlot(\n      const MachineInstr &MI,\n      SmallVectorImpl<const MachineMemOperand *> &Accesses) const;\n\n  /// If the specified machine instruction is a direct\n  /// store to a stack slot, return the virtual or physical register number of\n  /// the source reg along with the FrameIndex of the loaded stack slot.  If\n  /// not, return 0.  This predicate must return 0 if the instruction has\n  /// any side effects other than storing to the stack slot.\n  virtual unsigned isStoreToStackSlot(const MachineInstr &MI,\n                                      int &FrameIndex) const {\n    return 0;\n  }\n\n  /// Optional extension of isStoreToStackSlot that returns the number of\n  /// bytes stored to the stack. This must be implemented if a backend\n  /// supports partial stack slot spills/loads to further disambiguate\n  /// what the store does.\n  virtual unsigned isStoreToStackSlot(const MachineInstr &MI,\n                                      int &FrameIndex,\n                                      unsigned &MemBytes) const {\n    MemBytes = 0;\n    return isStoreToStackSlot(MI, FrameIndex);\n  }\n\n  /// Check for post-frame ptr elimination stack locations as well.\n  /// This uses a heuristic, so it isn't reliable for correctness.\n  virtual unsigned isStoreToStackSlotPostFE(const MachineInstr &MI,\n                                            int &FrameIndex) const {\n    return 0;\n  }\n\n  /// If the specified machine instruction has a store to a stack slot,\n  /// return true along with the FrameIndices of the loaded stack slot and the\n  /// machine mem operands containing the reference.\n  /// If not, return false.  Unlike isStoreToStackSlot,\n  /// this returns true for any instructions that stores to the\n  /// stack.  This is just a hint, as some cases may be missed.\n  virtual bool hasStoreToStackSlot(\n      const MachineInstr &MI,\n      SmallVectorImpl<const MachineMemOperand *> &Accesses) const;\n\n  /// Return true if the specified machine instruction\n  /// is a copy of one stack slot to another and has no other effect.\n  /// Provide the identity of the two frame indices.\n  virtual bool isStackSlotCopy(const MachineInstr &MI, int &DestFrameIndex,\n                               int &SrcFrameIndex) const {\n    return false;\n  }\n\n  /// Compute the size in bytes and offset within a stack slot of a spilled\n  /// register or subregister.\n  ///\n  /// \\param [out] Size in bytes of the spilled value.\n  /// \\param [out] Offset in bytes within the stack slot.\n  /// \\returns true if both Size and Offset are successfully computed.\n  ///\n  /// Not all subregisters have computable spill slots. For example,\n  /// subregisters registers may not be byte-sized, and a pair of discontiguous\n  /// subregisters has no single offset.\n  ///\n  /// Targets with nontrivial bigendian implementations may need to override\n  /// this, particularly to support spilled vector registers.\n  virtual bool getStackSlotRange(const TargetRegisterClass *RC, unsigned SubIdx,\n                                 unsigned &Size, unsigned &Offset,\n                                 const MachineFunction &MF) const;\n\n  /// Return true if the given instruction is terminator that is unspillable,\n  /// according to isUnspillableTerminatorImpl.\n  bool isUnspillableTerminator(const MachineInstr *MI) const {\n    return MI->isTerminator() && isUnspillableTerminatorImpl(MI);\n  }\n\n  /// Returns the size in bytes of the specified MachineInstr, or ~0U\n  /// when this function is not implemented by a target.\n  virtual unsigned getInstSizeInBytes(const MachineInstr &MI) const {\n    return ~0U;\n  }\n\n  /// Return true if the instruction is as cheap as a move instruction.\n  ///\n  /// Targets for different archs need to override this, and different\n  /// micro-architectures can also be finely tuned inside.\n  virtual bool isAsCheapAsAMove(const MachineInstr &MI) const {\n    return MI.isAsCheapAsAMove();\n  }\n\n  /// Return true if the instruction should be sunk by MachineSink.\n  ///\n  /// MachineSink determines on its own whether the instruction is safe to sink;\n  /// this gives the target a hook to override the default behavior with regards\n  /// to which instructions should be sunk.\n  virtual bool shouldSink(const MachineInstr &MI) const { return true; }\n\n  /// Re-issue the specified 'original' instruction at the\n  /// specific location targeting a new destination register.\n  /// The register in Orig->getOperand(0).getReg() will be substituted by\n  /// DestReg:SubIdx. Any existing subreg index is preserved or composed with\n  /// SubIdx.\n  virtual void reMaterialize(MachineBasicBlock &MBB,\n                             MachineBasicBlock::iterator MI, Register DestReg,\n                             unsigned SubIdx, const MachineInstr &Orig,\n                             const TargetRegisterInfo &TRI) const;\n\n  /// Clones instruction or the whole instruction bundle \\p Orig and\n  /// insert into \\p MBB before \\p InsertBefore. The target may update operands\n  /// that are required to be unique.\n  ///\n  /// \\p Orig must not return true for MachineInstr::isNotDuplicable().\n  virtual MachineInstr &duplicate(MachineBasicBlock &MBB,\n                                  MachineBasicBlock::iterator InsertBefore,\n                                  const MachineInstr &Orig) const;\n\n  /// This method must be implemented by targets that\n  /// set the M_CONVERTIBLE_TO_3_ADDR flag.  When this flag is set, the target\n  /// may be able to convert a two-address instruction into one or more true\n  /// three-address instructions on demand.  This allows the X86 target (for\n  /// example) to convert ADD and SHL instructions into LEA instructions if they\n  /// would require register copies due to two-addressness.\n  ///\n  /// This method returns a null pointer if the transformation cannot be\n  /// performed, otherwise it returns the last new instruction.\n  ///\n  virtual MachineInstr *convertToThreeAddress(MachineFunction::iterator &MFI,\n                                              MachineInstr &MI,\n                                              LiveVariables *LV) const {\n    return nullptr;\n  }\n\n  // This constant can be used as an input value of operand index passed to\n  // the method findCommutedOpIndices() to tell the method that the\n  // corresponding operand index is not pre-defined and that the method\n  // can pick any commutable operand.\n  static const unsigned CommuteAnyOperandIndex = ~0U;\n\n  /// This method commutes the operands of the given machine instruction MI.\n  ///\n  /// The operands to be commuted are specified by their indices OpIdx1 and\n  /// OpIdx2. OpIdx1 and OpIdx2 arguments may be set to a special value\n  /// 'CommuteAnyOperandIndex', which means that the method is free to choose\n  /// any arbitrarily chosen commutable operand. If both arguments are set to\n  /// 'CommuteAnyOperandIndex' then the method looks for 2 different commutable\n  /// operands; then commutes them if such operands could be found.\n  ///\n  /// If NewMI is false, MI is modified in place and returned; otherwise, a\n  /// new machine instruction is created and returned.\n  ///\n  /// Do not call this method for a non-commutable instruction or\n  /// for non-commuable operands.\n  /// Even though the instruction is commutable, the method may still\n  /// fail to commute the operands, null pointer is returned in such cases.\n  MachineInstr *\n  commuteInstruction(MachineInstr &MI, bool NewMI = false,\n                     unsigned OpIdx1 = CommuteAnyOperandIndex,\n                     unsigned OpIdx2 = CommuteAnyOperandIndex) const;\n\n  /// Returns true iff the routine could find two commutable operands in the\n  /// given machine instruction.\n  /// The 'SrcOpIdx1' and 'SrcOpIdx2' are INPUT and OUTPUT arguments.\n  /// If any of the INPUT values is set to the special value\n  /// 'CommuteAnyOperandIndex' then the method arbitrarily picks a commutable\n  /// operand, then returns its index in the corresponding argument.\n  /// If both of INPUT values are set to 'CommuteAnyOperandIndex' then method\n  /// looks for 2 commutable operands.\n  /// If INPUT values refer to some operands of MI, then the method simply\n  /// returns true if the corresponding operands are commutable and returns\n  /// false otherwise.\n  ///\n  /// For example, calling this method this way:\n  ///     unsigned Op1 = 1, Op2 = CommuteAnyOperandIndex;\n  ///     findCommutedOpIndices(MI, Op1, Op2);\n  /// can be interpreted as a query asking to find an operand that would be\n  /// commutable with the operand#1.\n  virtual bool findCommutedOpIndices(const MachineInstr &MI,\n                                     unsigned &SrcOpIdx1,\n                                     unsigned &SrcOpIdx2) const;\n\n  /// A pair composed of a register and a sub-register index.\n  /// Used to give some type checking when modeling Reg:SubReg.\n  struct RegSubRegPair {\n    Register Reg;\n    unsigned SubReg;\n\n    RegSubRegPair(Register Reg = Register(), unsigned SubReg = 0)\n        : Reg(Reg), SubReg(SubReg) {}\n\n    bool operator==(const RegSubRegPair& P) const {\n      return Reg == P.Reg && SubReg == P.SubReg;\n    }\n    bool operator!=(const RegSubRegPair& P) const {\n      return !(*this == P);\n    }\n  };\n\n  /// A pair composed of a pair of a register and a sub-register index,\n  /// and another sub-register index.\n  /// Used to give some type checking when modeling Reg:SubReg1, SubReg2.\n  struct RegSubRegPairAndIdx : RegSubRegPair {\n    unsigned SubIdx;\n\n    RegSubRegPairAndIdx(Register Reg = Register(), unsigned SubReg = 0,\n                        unsigned SubIdx = 0)\n        : RegSubRegPair(Reg, SubReg), SubIdx(SubIdx) {}\n  };\n\n  /// Build the equivalent inputs of a REG_SEQUENCE for the given \\p MI\n  /// and \\p DefIdx.\n  /// \\p [out] InputRegs of the equivalent REG_SEQUENCE. Each element of\n  /// the list is modeled as <Reg:SubReg, SubIdx>. Operands with the undef\n  /// flag are not added to this list.\n  /// E.g., REG_SEQUENCE %1:sub1, sub0, %2, sub1 would produce\n  /// two elements:\n  /// - %1:sub1, sub0\n  /// - %2<:0>, sub1\n  ///\n  /// \\returns true if it is possible to build such an input sequence\n  /// with the pair \\p MI, \\p DefIdx. False otherwise.\n  ///\n  /// \\pre MI.isRegSequence() or MI.isRegSequenceLike().\n  ///\n  /// \\note The generic implementation does not provide any support for\n  /// MI.isRegSequenceLike(). In other words, one has to override\n  /// getRegSequenceLikeInputs for target specific instructions.\n  bool\n  getRegSequenceInputs(const MachineInstr &MI, unsigned DefIdx,\n                       SmallVectorImpl<RegSubRegPairAndIdx> &InputRegs) const;\n\n  /// Build the equivalent inputs of a EXTRACT_SUBREG for the given \\p MI\n  /// and \\p DefIdx.\n  /// \\p [out] InputReg of the equivalent EXTRACT_SUBREG.\n  /// E.g., EXTRACT_SUBREG %1:sub1, sub0, sub1 would produce:\n  /// - %1:sub1, sub0\n  ///\n  /// \\returns true if it is possible to build such an input sequence\n  /// with the pair \\p MI, \\p DefIdx and the operand has no undef flag set.\n  /// False otherwise.\n  ///\n  /// \\pre MI.isExtractSubreg() or MI.isExtractSubregLike().\n  ///\n  /// \\note The generic implementation does not provide any support for\n  /// MI.isExtractSubregLike(). In other words, one has to override\n  /// getExtractSubregLikeInputs for target specific instructions.\n  bool getExtractSubregInputs(const MachineInstr &MI, unsigned DefIdx,\n                              RegSubRegPairAndIdx &InputReg) const;\n\n  /// Build the equivalent inputs of a INSERT_SUBREG for the given \\p MI\n  /// and \\p DefIdx.\n  /// \\p [out] BaseReg and \\p [out] InsertedReg contain\n  /// the equivalent inputs of INSERT_SUBREG.\n  /// E.g., INSERT_SUBREG %0:sub0, %1:sub1, sub3 would produce:\n  /// - BaseReg: %0:sub0\n  /// - InsertedReg: %1:sub1, sub3\n  ///\n  /// \\returns true if it is possible to build such an input sequence\n  /// with the pair \\p MI, \\p DefIdx and the operand has no undef flag set.\n  /// False otherwise.\n  ///\n  /// \\pre MI.isInsertSubreg() or MI.isInsertSubregLike().\n  ///\n  /// \\note The generic implementation does not provide any support for\n  /// MI.isInsertSubregLike(). In other words, one has to override\n  /// getInsertSubregLikeInputs for target specific instructions.\n  bool getInsertSubregInputs(const MachineInstr &MI, unsigned DefIdx,\n                             RegSubRegPair &BaseReg,\n                             RegSubRegPairAndIdx &InsertedReg) const;\n\n  /// Return true if two machine instructions would produce identical values.\n  /// By default, this is only true when the two instructions\n  /// are deemed identical except for defs. If this function is called when the\n  /// IR is still in SSA form, the caller can pass the MachineRegisterInfo for\n  /// aggressive checks.\n  virtual bool produceSameValue(const MachineInstr &MI0,\n                                const MachineInstr &MI1,\n                                const MachineRegisterInfo *MRI = nullptr) const;\n\n  /// \\returns true if a branch from an instruction with opcode \\p BranchOpc\n  ///  bytes is capable of jumping to a position \\p BrOffset bytes away.\n  virtual bool isBranchOffsetInRange(unsigned BranchOpc,\n                                     int64_t BrOffset) const {\n    llvm_unreachable(\"target did not implement\");\n  }\n\n  /// \\returns The block that branch instruction \\p MI jumps to.\n  virtual MachineBasicBlock *getBranchDestBlock(const MachineInstr &MI) const {\n    llvm_unreachable(\"target did not implement\");\n  }\n\n  /// Insert an unconditional indirect branch at the end of \\p MBB to \\p\n  /// NewDestBB.  \\p BrOffset indicates the offset of \\p NewDestBB relative to\n  /// the offset of the position to insert the new branch.\n  ///\n  /// \\returns The number of bytes added to the block.\n  virtual unsigned insertIndirectBranch(MachineBasicBlock &MBB,\n                                        MachineBasicBlock &NewDestBB,\n                                        const DebugLoc &DL,\n                                        int64_t BrOffset = 0,\n                                        RegScavenger *RS = nullptr) const {\n    llvm_unreachable(\"target did not implement\");\n  }\n\n  /// Analyze the branching code at the end of MBB, returning\n  /// true if it cannot be understood (e.g. it's a switch dispatch or isn't\n  /// implemented for a target).  Upon success, this returns false and returns\n  /// with the following information in various cases:\n  ///\n  /// 1. If this block ends with no branches (it just falls through to its succ)\n  ///    just return false, leaving TBB/FBB null.\n  /// 2. If this block ends with only an unconditional branch, it sets TBB to be\n  ///    the destination block.\n  /// 3. If this block ends with a conditional branch and it falls through to a\n  ///    successor block, it sets TBB to be the branch destination block and a\n  ///    list of operands that evaluate the condition. These operands can be\n  ///    passed to other TargetInstrInfo methods to create new branches.\n  /// 4. If this block ends with a conditional branch followed by an\n  ///    unconditional branch, it returns the 'true' destination in TBB, the\n  ///    'false' destination in FBB, and a list of operands that evaluate the\n  ///    condition.  These operands can be passed to other TargetInstrInfo\n  ///    methods to create new branches.\n  ///\n  /// Note that removeBranch and insertBranch must be implemented to support\n  /// cases where this method returns success.\n  ///\n  /// If AllowModify is true, then this routine is allowed to modify the basic\n  /// block (e.g. delete instructions after the unconditional branch).\n  ///\n  /// The CFG information in MBB.Predecessors and MBB.Successors must be valid\n  /// before calling this function.\n  virtual bool analyzeBranch(MachineBasicBlock &MBB, MachineBasicBlock *&TBB,\n                             MachineBasicBlock *&FBB,\n                             SmallVectorImpl<MachineOperand> &Cond,\n                             bool AllowModify = false) const {\n    return true;\n  }\n\n  /// Represents a predicate at the MachineFunction level.  The control flow a\n  /// MachineBranchPredicate represents is:\n  ///\n  ///  Reg = LHS `Predicate` RHS         == ConditionDef\n  ///  if Reg then goto TrueDest else goto FalseDest\n  ///\n  struct MachineBranchPredicate {\n    enum ComparePredicate {\n      PRED_EQ,     // True if two values are equal\n      PRED_NE,     // True if two values are not equal\n      PRED_INVALID // Sentinel value\n    };\n\n    ComparePredicate Predicate = PRED_INVALID;\n    MachineOperand LHS = MachineOperand::CreateImm(0);\n    MachineOperand RHS = MachineOperand::CreateImm(0);\n    MachineBasicBlock *TrueDest = nullptr;\n    MachineBasicBlock *FalseDest = nullptr;\n    MachineInstr *ConditionDef = nullptr;\n\n    /// SingleUseCondition is true if ConditionDef is dead except for the\n    /// branch(es) at the end of the basic block.\n    ///\n    bool SingleUseCondition = false;\n\n    explicit MachineBranchPredicate() = default;\n  };\n\n  /// Analyze the branching code at the end of MBB and parse it into the\n  /// MachineBranchPredicate structure if possible.  Returns false on success\n  /// and true on failure.\n  ///\n  /// If AllowModify is true, then this routine is allowed to modify the basic\n  /// block (e.g. delete instructions after the unconditional branch).\n  ///\n  virtual bool analyzeBranchPredicate(MachineBasicBlock &MBB,\n                                      MachineBranchPredicate &MBP,\n                                      bool AllowModify = false) const {\n    return true;\n  }\n\n  /// Remove the branching code at the end of the specific MBB.\n  /// This is only invoked in cases where analyzeBranch returns success. It\n  /// returns the number of instructions that were removed.\n  /// If \\p BytesRemoved is non-null, report the change in code size from the\n  /// removed instructions.\n  virtual unsigned removeBranch(MachineBasicBlock &MBB,\n                                int *BytesRemoved = nullptr) const {\n    llvm_unreachable(\"Target didn't implement TargetInstrInfo::removeBranch!\");\n  }\n\n  /// Insert branch code into the end of the specified MachineBasicBlock. The\n  /// operands to this method are the same as those returned by analyzeBranch.\n  /// This is only invoked in cases where analyzeBranch returns success. It\n  /// returns the number of instructions inserted. If \\p BytesAdded is non-null,\n  /// report the change in code size from the added instructions.\n  ///\n  /// It is also invoked by tail merging to add unconditional branches in\n  /// cases where analyzeBranch doesn't apply because there was no original\n  /// branch to analyze.  At least this much must be implemented, else tail\n  /// merging needs to be disabled.\n  ///\n  /// The CFG information in MBB.Predecessors and MBB.Successors must be valid\n  /// before calling this function.\n  virtual unsigned insertBranch(MachineBasicBlock &MBB, MachineBasicBlock *TBB,\n                                MachineBasicBlock *FBB,\n                                ArrayRef<MachineOperand> Cond,\n                                const DebugLoc &DL,\n                                int *BytesAdded = nullptr) const {\n    llvm_unreachable(\"Target didn't implement TargetInstrInfo::insertBranch!\");\n  }\n\n  unsigned insertUnconditionalBranch(MachineBasicBlock &MBB,\n                                     MachineBasicBlock *DestBB,\n                                     const DebugLoc &DL,\n                                     int *BytesAdded = nullptr) const {\n    return insertBranch(MBB, DestBB, nullptr, ArrayRef<MachineOperand>(), DL,\n                        BytesAdded);\n  }\n\n  /// Object returned by analyzeLoopForPipelining. Allows software pipelining\n  /// implementations to query attributes of the loop being pipelined and to\n  /// apply target-specific updates to the loop once pipelining is complete.\n  class PipelinerLoopInfo {\n  public:\n    virtual ~PipelinerLoopInfo();\n    /// Return true if the given instruction should not be pipelined and should\n    /// be ignored. An example could be a loop comparison, or induction variable\n    /// update with no users being pipelined.\n    virtual bool shouldIgnoreForPipelining(const MachineInstr *MI) const = 0;\n\n    /// Create a condition to determine if the trip count of the loop is greater\n    /// than TC.\n    ///\n    /// If the trip count is statically known to be greater than TC, return\n    /// true. If the trip count is statically known to be not greater than TC,\n    /// return false. Otherwise return nullopt and fill out Cond with the test\n    /// condition.\n    virtual Optional<bool>\n    createTripCountGreaterCondition(int TC, MachineBasicBlock &MBB,\n                                    SmallVectorImpl<MachineOperand> &Cond) = 0;\n\n    /// Modify the loop such that the trip count is\n    /// OriginalTC + TripCountAdjust.\n    virtual void adjustTripCount(int TripCountAdjust) = 0;\n\n    /// Called when the loop's preheader has been modified to NewPreheader.\n    virtual void setPreheader(MachineBasicBlock *NewPreheader) = 0;\n\n    /// Called when the loop is being removed. Any instructions in the preheader\n    /// should be removed.\n    ///\n    /// Once this function is called, no other functions on this object are\n    /// valid; the loop has been removed.\n    virtual void disposed() = 0;\n  };\n\n  /// Analyze loop L, which must be a single-basic-block loop, and if the\n  /// conditions can be understood enough produce a PipelinerLoopInfo object.\n  virtual std::unique_ptr<PipelinerLoopInfo>\n  analyzeLoopForPipelining(MachineBasicBlock *LoopBB) const {\n    return nullptr;\n  }\n\n  /// Analyze the loop code, return true if it cannot be understood. Upon\n  /// success, this function returns false and returns information about the\n  /// induction variable and compare instruction used at the end.\n  virtual bool analyzeLoop(MachineLoop &L, MachineInstr *&IndVarInst,\n                           MachineInstr *&CmpInst) const {\n    return true;\n  }\n\n  /// Generate code to reduce the loop iteration by one and check if the loop\n  /// is finished.  Return the value/register of the new loop count.  We need\n  /// this function when peeling off one or more iterations of a loop. This\n  /// function assumes the nth iteration is peeled first.\n  virtual unsigned reduceLoopCount(MachineBasicBlock &MBB,\n                                   MachineBasicBlock &PreHeader,\n                                   MachineInstr *IndVar, MachineInstr &Cmp,\n                                   SmallVectorImpl<MachineOperand> &Cond,\n                                   SmallVectorImpl<MachineInstr *> &PrevInsts,\n                                   unsigned Iter, unsigned MaxIter) const {\n    llvm_unreachable(\"Target didn't implement ReduceLoopCount\");\n  }\n\n  /// Delete the instruction OldInst and everything after it, replacing it with\n  /// an unconditional branch to NewDest. This is used by the tail merging pass.\n  virtual void ReplaceTailWithBranchTo(MachineBasicBlock::iterator Tail,\n                                       MachineBasicBlock *NewDest) const;\n\n  /// Return true if it's legal to split the given basic\n  /// block at the specified instruction (i.e. instruction would be the start\n  /// of a new basic block).\n  virtual bool isLegalToSplitMBBAt(MachineBasicBlock &MBB,\n                                   MachineBasicBlock::iterator MBBI) const {\n    return true;\n  }\n\n  /// Return true if it's profitable to predicate\n  /// instructions with accumulated instruction latency of \"NumCycles\"\n  /// of the specified basic block, where the probability of the instructions\n  /// being executed is given by Probability, and Confidence is a measure\n  /// of our confidence that it will be properly predicted.\n  virtual bool isProfitableToIfCvt(MachineBasicBlock &MBB, unsigned NumCycles,\n                                   unsigned ExtraPredCycles,\n                                   BranchProbability Probability) const {\n    return false;\n  }\n\n  /// Second variant of isProfitableToIfCvt. This one\n  /// checks for the case where two basic blocks from true and false path\n  /// of a if-then-else (diamond) are predicated on mutually exclusive\n  /// predicates, where the probability of the true path being taken is given\n  /// by Probability, and Confidence is a measure of our confidence that it\n  /// will be properly predicted.\n  virtual bool isProfitableToIfCvt(MachineBasicBlock &TMBB, unsigned NumTCycles,\n                                   unsigned ExtraTCycles,\n                                   MachineBasicBlock &FMBB, unsigned NumFCycles,\n                                   unsigned ExtraFCycles,\n                                   BranchProbability Probability) const {\n    return false;\n  }\n\n  /// Return true if it's profitable for if-converter to duplicate instructions\n  /// of specified accumulated instruction latencies in the specified MBB to\n  /// enable if-conversion.\n  /// The probability of the instructions being executed is given by\n  /// Probability, and Confidence is a measure of our confidence that it\n  /// will be properly predicted.\n  virtual bool isProfitableToDupForIfCvt(MachineBasicBlock &MBB,\n                                         unsigned NumCycles,\n                                         BranchProbability Probability) const {\n    return false;\n  }\n\n  /// Return the increase in code size needed to predicate a contiguous run of\n  /// NumInsts instructions.\n  virtual unsigned extraSizeToPredicateInstructions(const MachineFunction &MF,\n                                                    unsigned NumInsts) const {\n    return 0;\n  }\n\n  /// Return an estimate for the code size reduction (in bytes) which will be\n  /// caused by removing the given branch instruction during if-conversion.\n  virtual unsigned predictBranchSizeForIfCvt(MachineInstr &MI) const {\n    return getInstSizeInBytes(MI);\n  }\n\n  /// Return true if it's profitable to unpredicate\n  /// one side of a 'diamond', i.e. two sides of if-else predicated on mutually\n  /// exclusive predicates.\n  /// e.g.\n  ///   subeq  r0, r1, #1\n  ///   addne  r0, r1, #1\n  /// =>\n  ///   sub    r0, r1, #1\n  ///   addne  r0, r1, #1\n  ///\n  /// This may be profitable is conditional instructions are always executed.\n  virtual bool isProfitableToUnpredicate(MachineBasicBlock &TMBB,\n                                         MachineBasicBlock &FMBB) const {\n    return false;\n  }\n\n  /// Return true if it is possible to insert a select\n  /// instruction that chooses between TrueReg and FalseReg based on the\n  /// condition code in Cond.\n  ///\n  /// When successful, also return the latency in cycles from TrueReg,\n  /// FalseReg, and Cond to the destination register. In most cases, a select\n  /// instruction will be 1 cycle, so CondCycles = TrueCycles = FalseCycles = 1\n  ///\n  /// Some x86 implementations have 2-cycle cmov instructions.\n  ///\n  /// @param MBB         Block where select instruction would be inserted.\n  /// @param Cond        Condition returned by analyzeBranch.\n  /// @param DstReg      Virtual dest register that the result should write to.\n  /// @param TrueReg     Virtual register to select when Cond is true.\n  /// @param FalseReg    Virtual register to select when Cond is false.\n  /// @param CondCycles  Latency from Cond+Branch to select output.\n  /// @param TrueCycles  Latency from TrueReg to select output.\n  /// @param FalseCycles Latency from FalseReg to select output.\n  virtual bool canInsertSelect(const MachineBasicBlock &MBB,\n                               ArrayRef<MachineOperand> Cond, Register DstReg,\n                               Register TrueReg, Register FalseReg,\n                               int &CondCycles, int &TrueCycles,\n                               int &FalseCycles) const {\n    return false;\n  }\n\n  /// Insert a select instruction into MBB before I that will copy TrueReg to\n  /// DstReg when Cond is true, and FalseReg to DstReg when Cond is false.\n  ///\n  /// This function can only be called after canInsertSelect() returned true.\n  /// The condition in Cond comes from analyzeBranch, and it can be assumed\n  /// that the same flags or registers required by Cond are available at the\n  /// insertion point.\n  ///\n  /// @param MBB      Block where select instruction should be inserted.\n  /// @param I        Insertion point.\n  /// @param DL       Source location for debugging.\n  /// @param DstReg   Virtual register to be defined by select instruction.\n  /// @param Cond     Condition as computed by analyzeBranch.\n  /// @param TrueReg  Virtual register to copy when Cond is true.\n  /// @param FalseReg Virtual register to copy when Cons is false.\n  virtual void insertSelect(MachineBasicBlock &MBB,\n                            MachineBasicBlock::iterator I, const DebugLoc &DL,\n                            Register DstReg, ArrayRef<MachineOperand> Cond,\n                            Register TrueReg, Register FalseReg) const {\n    llvm_unreachable(\"Target didn't implement TargetInstrInfo::insertSelect!\");\n  }\n\n  /// Analyze the given select instruction, returning true if\n  /// it cannot be understood. It is assumed that MI->isSelect() is true.\n  ///\n  /// When successful, return the controlling condition and the operands that\n  /// determine the true and false result values.\n  ///\n  ///   Result = SELECT Cond, TrueOp, FalseOp\n  ///\n  /// Some targets can optimize select instructions, for example by predicating\n  /// the instruction defining one of the operands. Such targets should set\n  /// Optimizable.\n  ///\n  /// @param         MI Select instruction to analyze.\n  /// @param Cond    Condition controlling the select.\n  /// @param TrueOp  Operand number of the value selected when Cond is true.\n  /// @param FalseOp Operand number of the value selected when Cond is false.\n  /// @param Optimizable Returned as true if MI is optimizable.\n  /// @returns False on success.\n  virtual bool analyzeSelect(const MachineInstr &MI,\n                             SmallVectorImpl<MachineOperand> &Cond,\n                             unsigned &TrueOp, unsigned &FalseOp,\n                             bool &Optimizable) const {\n    assert(MI.getDesc().isSelect() && \"MI must be a select instruction\");\n    return true;\n  }\n\n  /// Given a select instruction that was understood by\n  /// analyzeSelect and returned Optimizable = true, attempt to optimize MI by\n  /// merging it with one of its operands. Returns NULL on failure.\n  ///\n  /// When successful, returns the new select instruction. The client is\n  /// responsible for deleting MI.\n  ///\n  /// If both sides of the select can be optimized, PreferFalse is used to pick\n  /// a side.\n  ///\n  /// @param MI          Optimizable select instruction.\n  /// @param NewMIs     Set that record all MIs in the basic block up to \\p\n  /// MI. Has to be updated with any newly created MI or deleted ones.\n  /// @param PreferFalse Try to optimize FalseOp instead of TrueOp.\n  /// @returns Optimized instruction or NULL.\n  virtual MachineInstr *optimizeSelect(MachineInstr &MI,\n                                       SmallPtrSetImpl<MachineInstr *> &NewMIs,\n                                       bool PreferFalse = false) const {\n    // This function must be implemented if Optimizable is ever set.\n    llvm_unreachable(\"Target must implement TargetInstrInfo::optimizeSelect!\");\n  }\n\n  /// Emit instructions to copy a pair of physical registers.\n  ///\n  /// This function should support copies within any legal register class as\n  /// well as any cross-class copies created during instruction selection.\n  ///\n  /// The source and destination registers may overlap, which may require a\n  /// careful implementation when multiple copy instructions are required for\n  /// large registers. See for example the ARM target.\n  virtual void copyPhysReg(MachineBasicBlock &MBB,\n                           MachineBasicBlock::iterator MI, const DebugLoc &DL,\n                           MCRegister DestReg, MCRegister SrcReg,\n                           bool KillSrc) const {\n    llvm_unreachable(\"Target didn't implement TargetInstrInfo::copyPhysReg!\");\n  }\n\n  /// Allow targets to tell MachineVerifier whether a specific register\n  /// MachineOperand can be used as part of PC-relative addressing.\n  /// PC-relative addressing modes in many CISC architectures contain\n  /// (non-PC) registers as offsets or scaling values, which inherently\n  /// tags the corresponding MachineOperand with OPERAND_PCREL.\n  ///\n  /// @param MO The MachineOperand in question. MO.isReg() should always\n  /// be true.\n  /// @return Whether this operand is allowed to be used PC-relatively.\n  virtual bool isPCRelRegisterOperandLegal(const MachineOperand &MO) const {\n    return false;\n  }\n\nprotected:\n  /// Target-dependent implementation for IsCopyInstr.\n  /// If the specific machine instruction is a instruction that moves/copies\n  /// value from one register to another register return destination and source\n  /// registers as machine operands.\n  virtual Optional<DestSourcePair>\n  isCopyInstrImpl(const MachineInstr &MI) const {\n    return None;\n  }\n\n  /// Return true if the given terminator MI is not expected to spill. This\n  /// sets the live interval as not spillable and adjusts phi node lowering to\n  /// not introduce copies after the terminator. Use with care, these are\n  /// currently used for hardware loop intrinsics in very controlled situations,\n  /// created prior to registry allocation in loops that only have single phi\n  /// users for the terminators value. They may run out of registers if not used\n  /// carefully.\n  virtual bool isUnspillableTerminatorImpl(const MachineInstr *MI) const {\n    return false;\n  }\n\npublic:\n  /// If the specific machine instruction is a instruction that moves/copies\n  /// value from one register to another register return destination and source\n  /// registers as machine operands.\n  /// For COPY-instruction the method naturally returns destination and source\n  /// registers as machine operands, for all other instructions the method calls\n  /// target-dependent implementation.\n  Optional<DestSourcePair> isCopyInstr(const MachineInstr &MI) const {\n    if (MI.isCopy()) {\n      return DestSourcePair{MI.getOperand(0), MI.getOperand(1)};\n    }\n    return isCopyInstrImpl(MI);\n  }\n\n  /// If the specific machine instruction is an instruction that adds an\n  /// immediate value and a physical register, and stores the result in\n  /// the given physical register \\c Reg, return a pair of the source\n  /// register and the offset which has been added.\n  virtual Optional<RegImmPair> isAddImmediate(const MachineInstr &MI,\n                                              Register Reg) const {\n    return None;\n  }\n\n  /// Returns true if MI is an instruction that defines Reg to have a constant\n  /// value and the value is recorded in ImmVal. The ImmVal is a result that\n  /// should be interpreted as modulo size of Reg.\n  virtual bool getConstValDefinedInReg(const MachineInstr &MI,\n                                       const Register Reg,\n                                       int64_t &ImmVal) const {\n    return false;\n  }\n\n  /// Store the specified register of the given register class to the specified\n  /// stack frame index. The store instruction is to be added to the given\n  /// machine basic block before the specified machine instruction. If isKill\n  /// is true, the register operand is the last use and must be marked kill.\n  virtual void storeRegToStackSlot(MachineBasicBlock &MBB,\n                                   MachineBasicBlock::iterator MI,\n                                   Register SrcReg, bool isKill, int FrameIndex,\n                                   const TargetRegisterClass *RC,\n                                   const TargetRegisterInfo *TRI) const {\n    llvm_unreachable(\"Target didn't implement \"\n                     \"TargetInstrInfo::storeRegToStackSlot!\");\n  }\n\n  /// Load the specified register of the given register class from the specified\n  /// stack frame index. The load instruction is to be added to the given\n  /// machine basic block before the specified machine instruction.\n  virtual void loadRegFromStackSlot(MachineBasicBlock &MBB,\n                                    MachineBasicBlock::iterator MI,\n                                    Register DestReg, int FrameIndex,\n                                    const TargetRegisterClass *RC,\n                                    const TargetRegisterInfo *TRI) const {\n    llvm_unreachable(\"Target didn't implement \"\n                     \"TargetInstrInfo::loadRegFromStackSlot!\");\n  }\n\n  /// This function is called for all pseudo instructions\n  /// that remain after register allocation. Many pseudo instructions are\n  /// created to help register allocation. This is the place to convert them\n  /// into real instructions. The target can edit MI in place, or it can insert\n  /// new instructions and erase MI. The function should return true if\n  /// anything was changed.\n  virtual bool expandPostRAPseudo(MachineInstr &MI) const { return false; }\n\n  /// Check whether the target can fold a load that feeds a subreg operand\n  /// (or a subreg operand that feeds a store).\n  /// For example, X86 may want to return true if it can fold\n  /// movl (%esp), %eax\n  /// subb, %al, ...\n  /// Into:\n  /// subb (%esp), ...\n  ///\n  /// Ideally, we'd like the target implementation of foldMemoryOperand() to\n  /// reject subregs - but since this behavior used to be enforced in the\n  /// target-independent code, moving this responsibility to the targets\n  /// has the potential of causing nasty silent breakage in out-of-tree targets.\n  virtual bool isSubregFoldable() const { return false; }\n\n  /// Attempt to fold a load or store of the specified stack\n  /// slot into the specified machine instruction for the specified operand(s).\n  /// If this is possible, a new instruction is returned with the specified\n  /// operand folded, otherwise NULL is returned.\n  /// The new instruction is inserted before MI, and the client is responsible\n  /// for removing the old instruction.\n  /// If VRM is passed, the assigned physregs can be inspected by target to\n  /// decide on using an opcode (note that those assignments can still change).\n  MachineInstr *foldMemoryOperand(MachineInstr &MI, ArrayRef<unsigned> Ops,\n                                  int FI,\n                                  LiveIntervals *LIS = nullptr,\n                                  VirtRegMap *VRM = nullptr) const;\n\n  /// Same as the previous version except it allows folding of any load and\n  /// store from / to any address, not just from a specific stack slot.\n  MachineInstr *foldMemoryOperand(MachineInstr &MI, ArrayRef<unsigned> Ops,\n                                  MachineInstr &LoadMI,\n                                  LiveIntervals *LIS = nullptr) const;\n\n  /// Return true when there is potentially a faster code sequence\n  /// for an instruction chain ending in \\p Root. All potential patterns are\n  /// returned in the \\p Pattern vector. Pattern should be sorted in priority\n  /// order since the pattern evaluator stops checking as soon as it finds a\n  /// faster sequence.\n  /// \\param Root - Instruction that could be combined with one of its operands\n  /// \\param Patterns - Vector of possible combination patterns\n  virtual bool\n  getMachineCombinerPatterns(MachineInstr &Root,\n                             SmallVectorImpl<MachineCombinerPattern> &Patterns,\n                             bool DoRegPressureReduce) const;\n\n  /// Return true if target supports reassociation of instructions in machine\n  /// combiner pass to reduce register pressure for a given BB.\n  virtual bool\n  shouldReduceRegisterPressure(MachineBasicBlock *MBB,\n                               RegisterClassInfo *RegClassInfo) const {\n    return false;\n  }\n\n  /// Fix up the placeholder we may add in genAlternativeCodeSequence().\n  virtual void\n  finalizeInsInstrs(MachineInstr &Root, MachineCombinerPattern &P,\n                    SmallVectorImpl<MachineInstr *> &InsInstrs) const {}\n\n  /// Return true when a code sequence can improve throughput. It\n  /// should be called only for instructions in loops.\n  /// \\param Pattern - combiner pattern\n  virtual bool isThroughputPattern(MachineCombinerPattern Pattern) const;\n\n  /// Return true if the input \\P Inst is part of a chain of dependent ops\n  /// that are suitable for reassociation, otherwise return false.\n  /// If the instruction's operands must be commuted to have a previous\n  /// instruction of the same type define the first source operand, \\P Commuted\n  /// will be set to true.\n  bool isReassociationCandidate(const MachineInstr &Inst, bool &Commuted) const;\n\n  /// Return true when \\P Inst is both associative and commutative.\n  virtual bool isAssociativeAndCommutative(const MachineInstr &Inst) const {\n    return false;\n  }\n\n  /// Return true when \\P Inst has reassociable operands in the same \\P MBB.\n  virtual bool hasReassociableOperands(const MachineInstr &Inst,\n                                       const MachineBasicBlock *MBB) const;\n\n  /// Return true when \\P Inst has reassociable sibling.\n  bool hasReassociableSibling(const MachineInstr &Inst, bool &Commuted) const;\n\n  /// When getMachineCombinerPatterns() finds patterns, this function generates\n  /// the instructions that could replace the original code sequence. The client\n  /// has to decide whether the actual replacement is beneficial or not.\n  /// \\param Root - Instruction that could be combined with one of its operands\n  /// \\param Pattern - Combination pattern for Root\n  /// \\param InsInstrs - Vector of new instructions that implement P\n  /// \\param DelInstrs - Old instructions, including Root, that could be\n  /// replaced by InsInstr\n  /// \\param InstIdxForVirtReg - map of virtual register to instruction in\n  /// InsInstr that defines it\n  virtual void genAlternativeCodeSequence(\n      MachineInstr &Root, MachineCombinerPattern Pattern,\n      SmallVectorImpl<MachineInstr *> &InsInstrs,\n      SmallVectorImpl<MachineInstr *> &DelInstrs,\n      DenseMap<unsigned, unsigned> &InstIdxForVirtReg) const;\n\n  /// Attempt to reassociate \\P Root and \\P Prev according to \\P Pattern to\n  /// reduce critical path length.\n  void reassociateOps(MachineInstr &Root, MachineInstr &Prev,\n                      MachineCombinerPattern Pattern,\n                      SmallVectorImpl<MachineInstr *> &InsInstrs,\n                      SmallVectorImpl<MachineInstr *> &DelInstrs,\n                      DenseMap<unsigned, unsigned> &InstrIdxForVirtReg) const;\n\n  /// The limit on resource length extension we accept in MachineCombiner Pass.\n  virtual int getExtendResourceLenLimit() const { return 0; }\n\n  /// This is an architecture-specific helper function of reassociateOps.\n  /// Set special operand attributes for new instructions after reassociation.\n  virtual void setSpecialOperandAttr(MachineInstr &OldMI1, MachineInstr &OldMI2,\n                                     MachineInstr &NewMI1,\n                                     MachineInstr &NewMI2) const {}\n\n  virtual void setSpecialOperandAttr(MachineInstr &MI, uint16_t Flags) const {}\n\n  /// Return true when a target supports MachineCombiner.\n  virtual bool useMachineCombiner() const { return false; }\n\n  /// Return true if the given SDNode can be copied during scheduling\n  /// even if it has glue.\n  virtual bool canCopyGluedNodeDuringSchedule(SDNode *N) const { return false; }\n\nprotected:\n  /// Target-dependent implementation for foldMemoryOperand.\n  /// Target-independent code in foldMemoryOperand will\n  /// take care of adding a MachineMemOperand to the newly created instruction.\n  /// The instruction and any auxiliary instructions necessary will be inserted\n  /// at InsertPt.\n  virtual MachineInstr *\n  foldMemoryOperandImpl(MachineFunction &MF, MachineInstr &MI,\n                        ArrayRef<unsigned> Ops,\n                        MachineBasicBlock::iterator InsertPt, int FrameIndex,\n                        LiveIntervals *LIS = nullptr,\n                        VirtRegMap *VRM = nullptr) const {\n    return nullptr;\n  }\n\n  /// Target-dependent implementation for foldMemoryOperand.\n  /// Target-independent code in foldMemoryOperand will\n  /// take care of adding a MachineMemOperand to the newly created instruction.\n  /// The instruction and any auxiliary instructions necessary will be inserted\n  /// at InsertPt.\n  virtual MachineInstr *foldMemoryOperandImpl(\n      MachineFunction &MF, MachineInstr &MI, ArrayRef<unsigned> Ops,\n      MachineBasicBlock::iterator InsertPt, MachineInstr &LoadMI,\n      LiveIntervals *LIS = nullptr) const {\n    return nullptr;\n  }\n\n  /// Target-dependent implementation of getRegSequenceInputs.\n  ///\n  /// \\returns true if it is possible to build the equivalent\n  /// REG_SEQUENCE inputs with the pair \\p MI, \\p DefIdx. False otherwise.\n  ///\n  /// \\pre MI.isRegSequenceLike().\n  ///\n  /// \\see TargetInstrInfo::getRegSequenceInputs.\n  virtual bool getRegSequenceLikeInputs(\n      const MachineInstr &MI, unsigned DefIdx,\n      SmallVectorImpl<RegSubRegPairAndIdx> &InputRegs) const {\n    return false;\n  }\n\n  /// Target-dependent implementation of getExtractSubregInputs.\n  ///\n  /// \\returns true if it is possible to build the equivalent\n  /// EXTRACT_SUBREG inputs with the pair \\p MI, \\p DefIdx. False otherwise.\n  ///\n  /// \\pre MI.isExtractSubregLike().\n  ///\n  /// \\see TargetInstrInfo::getExtractSubregInputs.\n  virtual bool getExtractSubregLikeInputs(const MachineInstr &MI,\n                                          unsigned DefIdx,\n                                          RegSubRegPairAndIdx &InputReg) const {\n    return false;\n  }\n\n  /// Target-dependent implementation of getInsertSubregInputs.\n  ///\n  /// \\returns true if it is possible to build the equivalent\n  /// INSERT_SUBREG inputs with the pair \\p MI, \\p DefIdx. False otherwise.\n  ///\n  /// \\pre MI.isInsertSubregLike().\n  ///\n  /// \\see TargetInstrInfo::getInsertSubregInputs.\n  virtual bool\n  getInsertSubregLikeInputs(const MachineInstr &MI, unsigned DefIdx,\n                            RegSubRegPair &BaseReg,\n                            RegSubRegPairAndIdx &InsertedReg) const {\n    return false;\n  }\n\npublic:\n  /// getAddressSpaceForPseudoSourceKind - Given the kind of memory\n  /// (e.g. stack) the target returns the corresponding address space.\n  virtual unsigned\n  getAddressSpaceForPseudoSourceKind(unsigned Kind) const {\n    return 0;\n  }\n\n  /// unfoldMemoryOperand - Separate a single instruction which folded a load or\n  /// a store or a load and a store into two or more instruction. If this is\n  /// possible, returns true as well as the new instructions by reference.\n  virtual bool\n  unfoldMemoryOperand(MachineFunction &MF, MachineInstr &MI, unsigned Reg,\n                      bool UnfoldLoad, bool UnfoldStore,\n                      SmallVectorImpl<MachineInstr *> &NewMIs) const {\n    return false;\n  }\n\n  virtual bool unfoldMemoryOperand(SelectionDAG &DAG, SDNode *N,\n                                   SmallVectorImpl<SDNode *> &NewNodes) const {\n    return false;\n  }\n\n  /// Returns the opcode of the would be new\n  /// instruction after load / store are unfolded from an instruction of the\n  /// specified opcode. It returns zero if the specified unfolding is not\n  /// possible. If LoadRegIndex is non-null, it is filled in with the operand\n  /// index of the operand which will hold the register holding the loaded\n  /// value.\n  virtual unsigned\n  getOpcodeAfterMemoryUnfold(unsigned Opc, bool UnfoldLoad, bool UnfoldStore,\n                             unsigned *LoadRegIndex = nullptr) const {\n    return 0;\n  }\n\n  /// This is used by the pre-regalloc scheduler to determine if two loads are\n  /// loading from the same base address. It should only return true if the base\n  /// pointers are the same and the only differences between the two addresses\n  /// are the offset. It also returns the offsets by reference.\n  virtual bool areLoadsFromSameBasePtr(SDNode *Load1, SDNode *Load2,\n                                       int64_t &Offset1,\n                                       int64_t &Offset2) const {\n    return false;\n  }\n\n  /// This is a used by the pre-regalloc scheduler to determine (in conjunction\n  /// with areLoadsFromSameBasePtr) if two loads should be scheduled together.\n  /// On some targets if two loads are loading from\n  /// addresses in the same cache line, it's better if they are scheduled\n  /// together. This function takes two integers that represent the load offsets\n  /// from the common base address. It returns true if it decides it's desirable\n  /// to schedule the two loads together. \"NumLoads\" is the number of loads that\n  /// have already been scheduled after Load1.\n  virtual bool shouldScheduleLoadsNear(SDNode *Load1, SDNode *Load2,\n                                       int64_t Offset1, int64_t Offset2,\n                                       unsigned NumLoads) const {\n    return false;\n  }\n\n  /// Get the base operand and byte offset of an instruction that reads/writes\n  /// memory. This is a convenience function for callers that are only prepared\n  /// to handle a single base operand.\n  bool getMemOperandWithOffset(const MachineInstr &MI,\n                               const MachineOperand *&BaseOp, int64_t &Offset,\n                               bool &OffsetIsScalable,\n                               const TargetRegisterInfo *TRI) const;\n\n  /// Get zero or more base operands and the byte offset of an instruction that\n  /// reads/writes memory. Note that there may be zero base operands if the\n  /// instruction accesses a constant address.\n  /// It returns false if MI does not read/write memory.\n  /// It returns false if base operands and offset could not be determined.\n  /// It is not guaranteed to always recognize base operands and offsets in all\n  /// cases.\n  virtual bool getMemOperandsWithOffsetWidth(\n      const MachineInstr &MI, SmallVectorImpl<const MachineOperand *> &BaseOps,\n      int64_t &Offset, bool &OffsetIsScalable, unsigned &Width,\n      const TargetRegisterInfo *TRI) const {\n    return false;\n  }\n\n  /// Return true if the instruction contains a base register and offset. If\n  /// true, the function also sets the operand position in the instruction\n  /// for the base register and offset.\n  virtual bool getBaseAndOffsetPosition(const MachineInstr &MI,\n                                        unsigned &BasePos,\n                                        unsigned &OffsetPos) const {\n    return false;\n  }\n\n  /// Target dependent implementation to get the values constituting the address\n  /// MachineInstr that is accessing memory. These values are returned as a\n  /// struct ExtAddrMode which contains all relevant information to make up the\n  /// address.\n  virtual Optional<ExtAddrMode>\n  getAddrModeFromMemoryOp(const MachineInstr &MemI,\n                          const TargetRegisterInfo *TRI) const {\n    return None;\n  }\n\n  /// Returns true if MI's Def is NullValueReg, and the MI\n  /// does not change the Zero value. i.e. cases such as rax = shr rax, X where\n  /// NullValueReg = rax. Note that if the NullValueReg is non-zero, this\n  /// function can return true even if becomes zero. Specifically cases such as\n  /// NullValueReg = shl NullValueReg, 63.\n  virtual bool preservesZeroValueInReg(const MachineInstr *MI,\n                                       const Register NullValueReg,\n                                       const TargetRegisterInfo *TRI) const {\n    return false;\n  }\n\n  /// If the instruction is an increment of a constant value, return the amount.\n  virtual bool getIncrementValue(const MachineInstr &MI, int &Value) const {\n    return false;\n  }\n\n  /// Returns true if the two given memory operations should be scheduled\n  /// adjacent. Note that you have to add:\n  ///   DAG->addMutation(createLoadClusterDAGMutation(DAG->TII, DAG->TRI));\n  /// or\n  ///   DAG->addMutation(createStoreClusterDAGMutation(DAG->TII, DAG->TRI));\n  /// to TargetPassConfig::createMachineScheduler() to have an effect.\n  ///\n  /// \\p BaseOps1 and \\p BaseOps2 are memory operands of two memory operations.\n  /// \\p NumLoads is the number of loads that will be in the cluster if this\n  /// hook returns true.\n  /// \\p NumBytes is the number of bytes that will be loaded from all the\n  /// clustered loads if this hook returns true.\n  virtual bool shouldClusterMemOps(ArrayRef<const MachineOperand *> BaseOps1,\n                                   ArrayRef<const MachineOperand *> BaseOps2,\n                                   unsigned NumLoads, unsigned NumBytes) const {\n    llvm_unreachable(\"target did not implement shouldClusterMemOps()\");\n  }\n\n  /// Reverses the branch condition of the specified condition list,\n  /// returning false on success and true if it cannot be reversed.\n  virtual bool\n  reverseBranchCondition(SmallVectorImpl<MachineOperand> &Cond) const {\n    return true;\n  }\n\n  /// Insert a noop into the instruction stream at the specified point.\n  virtual void insertNoop(MachineBasicBlock &MBB,\n                          MachineBasicBlock::iterator MI) const;\n\n  /// Insert noops into the instruction stream at the specified point.\n  virtual void insertNoops(MachineBasicBlock &MBB,\n                           MachineBasicBlock::iterator MI,\n                           unsigned Quantity) const;\n\n  /// Return the noop instruction to use for a noop.\n  virtual MCInst getNop() const;\n\n  /// Return true for post-incremented instructions.\n  virtual bool isPostIncrement(const MachineInstr &MI) const { return false; }\n\n  /// Returns true if the instruction is already predicated.\n  virtual bool isPredicated(const MachineInstr &MI) const { return false; }\n\n  // Returns a MIRPrinter comment for this machine operand.\n  virtual std::string\n  createMIROperandComment(const MachineInstr &MI, const MachineOperand &Op,\n                          unsigned OpIdx, const TargetRegisterInfo *TRI) const;\n\n  /// Returns true if the instruction is a\n  /// terminator instruction that has not been predicated.\n  bool isUnpredicatedTerminator(const MachineInstr &MI) const;\n\n  /// Returns true if MI is an unconditional tail call.\n  virtual bool isUnconditionalTailCall(const MachineInstr &MI) const {\n    return false;\n  }\n\n  /// Returns true if the tail call can be made conditional on BranchCond.\n  virtual bool canMakeTailCallConditional(SmallVectorImpl<MachineOperand> &Cond,\n                                          const MachineInstr &TailCall) const {\n    return false;\n  }\n\n  /// Replace the conditional branch in MBB with a conditional tail call.\n  virtual void replaceBranchWithTailCall(MachineBasicBlock &MBB,\n                                         SmallVectorImpl<MachineOperand> &Cond,\n                                         const MachineInstr &TailCall) const {\n    llvm_unreachable(\"Target didn't implement replaceBranchWithTailCall!\");\n  }\n\n  /// Convert the instruction into a predicated instruction.\n  /// It returns true if the operation was successful.\n  virtual bool PredicateInstruction(MachineInstr &MI,\n                                    ArrayRef<MachineOperand> Pred) const;\n\n  /// Returns true if the first specified predicate\n  /// subsumes the second, e.g. GE subsumes GT.\n  virtual bool SubsumesPredicate(ArrayRef<MachineOperand> Pred1,\n                                 ArrayRef<MachineOperand> Pred2) const {\n    return false;\n  }\n\n  /// If the specified instruction defines any predicate\n  /// or condition code register(s) used for predication, returns true as well\n  /// as the definition predicate(s) by reference.\n  /// SkipDead should be set to false at any point that dead\n  /// predicate instructions should be considered as being defined.\n  /// A dead predicate instruction is one that is guaranteed to be removed\n  /// after a call to PredicateInstruction.\n  virtual bool ClobbersPredicate(MachineInstr &MI,\n                                 std::vector<MachineOperand> &Pred,\n                                 bool SkipDead) const {\n    return false;\n  }\n\n  /// Return true if the specified instruction can be predicated.\n  /// By default, this returns true for every instruction with a\n  /// PredicateOperand.\n  virtual bool isPredicable(const MachineInstr &MI) const {\n    return MI.getDesc().isPredicable();\n  }\n\n  /// Return true if it's safe to move a machine\n  /// instruction that defines the specified register class.\n  virtual bool isSafeToMoveRegClassDefs(const TargetRegisterClass *RC) const {\n    return true;\n  }\n\n  /// Test if the given instruction should be considered a scheduling boundary.\n  /// This primarily includes labels and terminators.\n  virtual bool isSchedulingBoundary(const MachineInstr &MI,\n                                    const MachineBasicBlock *MBB,\n                                    const MachineFunction &MF) const;\n\n  /// Measure the specified inline asm to determine an approximation of its\n  /// length.\n  virtual unsigned getInlineAsmLength(\n    const char *Str, const MCAsmInfo &MAI,\n    const TargetSubtargetInfo *STI = nullptr) const;\n\n  /// Allocate and return a hazard recognizer to use for this target when\n  /// scheduling the machine instructions before register allocation.\n  virtual ScheduleHazardRecognizer *\n  CreateTargetHazardRecognizer(const TargetSubtargetInfo *STI,\n                               const ScheduleDAG *DAG) const;\n\n  /// Allocate and return a hazard recognizer to use for this target when\n  /// scheduling the machine instructions before register allocation.\n  virtual ScheduleHazardRecognizer *\n  CreateTargetMIHazardRecognizer(const InstrItineraryData *,\n                                 const ScheduleDAGMI *DAG) const;\n\n  /// Allocate and return a hazard recognizer to use for this target when\n  /// scheduling the machine instructions after register allocation.\n  virtual ScheduleHazardRecognizer *\n  CreateTargetPostRAHazardRecognizer(const InstrItineraryData *,\n                                     const ScheduleDAG *DAG) const;\n\n  /// Allocate and return a hazard recognizer to use for by non-scheduling\n  /// passes.\n  virtual ScheduleHazardRecognizer *\n  CreateTargetPostRAHazardRecognizer(const MachineFunction &MF) const {\n    return nullptr;\n  }\n\n  /// Provide a global flag for disabling the PreRA hazard recognizer that\n  /// targets may choose to honor.\n  bool usePreRAHazardRecognizer() const;\n\n  /// For a comparison instruction, return the source registers\n  /// in SrcReg and SrcReg2 if having two register operands, and the value it\n  /// compares against in CmpValue. Return true if the comparison instruction\n  /// can be analyzed.\n  virtual bool analyzeCompare(const MachineInstr &MI, Register &SrcReg,\n                              Register &SrcReg2, int &Mask, int &Value) const {\n    return false;\n  }\n\n  /// See if the comparison instruction can be converted\n  /// into something more efficient. E.g., on ARM most instructions can set the\n  /// flags register, obviating the need for a separate CMP.\n  virtual bool optimizeCompareInstr(MachineInstr &CmpInstr, Register SrcReg,\n                                    Register SrcReg2, int Mask, int Value,\n                                    const MachineRegisterInfo *MRI) const {\n    return false;\n  }\n  virtual bool optimizeCondBranch(MachineInstr &MI) const { return false; }\n\n  /// Try to remove the load by folding it to a register operand at the use.\n  /// We fold the load instructions if and only if the\n  /// def and use are in the same BB. We only look at one load and see\n  /// whether it can be folded into MI. FoldAsLoadDefReg is the virtual register\n  /// defined by the load we are trying to fold. DefMI returns the machine\n  /// instruction that defines FoldAsLoadDefReg, and the function returns\n  /// the machine instruction generated due to folding.\n  virtual MachineInstr *optimizeLoadInstr(MachineInstr &MI,\n                                          const MachineRegisterInfo *MRI,\n                                          Register &FoldAsLoadDefReg,\n                                          MachineInstr *&DefMI) const {\n    return nullptr;\n  }\n\n  /// 'Reg' is known to be defined by a move immediate instruction,\n  /// try to fold the immediate into the use instruction.\n  /// If MRI->hasOneNonDBGUse(Reg) is true, and this function returns true,\n  /// then the caller may assume that DefMI has been erased from its parent\n  /// block. The caller may assume that it will not be erased by this\n  /// function otherwise.\n  virtual bool FoldImmediate(MachineInstr &UseMI, MachineInstr &DefMI,\n                             Register Reg, MachineRegisterInfo *MRI) const {\n    return false;\n  }\n\n  /// Return the number of u-operations the given machine\n  /// instruction will be decoded to on the target cpu. The itinerary's\n  /// IssueWidth is the number of microops that can be dispatched each\n  /// cycle. An instruction with zero microops takes no dispatch resources.\n  virtual unsigned getNumMicroOps(const InstrItineraryData *ItinData,\n                                  const MachineInstr &MI) const;\n\n  /// Return true for pseudo instructions that don't consume any\n  /// machine resources in their current form. These are common cases that the\n  /// scheduler should consider free, rather than conservatively handling them\n  /// as instructions with no itinerary.\n  bool isZeroCost(unsigned Opcode) const {\n    return Opcode <= TargetOpcode::COPY;\n  }\n\n  virtual int getOperandLatency(const InstrItineraryData *ItinData,\n                                SDNode *DefNode, unsigned DefIdx,\n                                SDNode *UseNode, unsigned UseIdx) const;\n\n  /// Compute and return the use operand latency of a given pair of def and use.\n  /// In most cases, the static scheduling itinerary was enough to determine the\n  /// operand latency. But it may not be possible for instructions with variable\n  /// number of defs / uses.\n  ///\n  /// This is a raw interface to the itinerary that may be directly overridden\n  /// by a target. Use computeOperandLatency to get the best estimate of\n  /// latency.\n  virtual int getOperandLatency(const InstrItineraryData *ItinData,\n                                const MachineInstr &DefMI, unsigned DefIdx,\n                                const MachineInstr &UseMI,\n                                unsigned UseIdx) const;\n\n  /// Compute the instruction latency of a given instruction.\n  /// If the instruction has higher cost when predicated, it's returned via\n  /// PredCost.\n  virtual unsigned getInstrLatency(const InstrItineraryData *ItinData,\n                                   const MachineInstr &MI,\n                                   unsigned *PredCost = nullptr) const;\n\n  virtual unsigned getPredicationCost(const MachineInstr &MI) const;\n\n  virtual int getInstrLatency(const InstrItineraryData *ItinData,\n                              SDNode *Node) const;\n\n  /// Return the default expected latency for a def based on its opcode.\n  unsigned defaultDefLatency(const MCSchedModel &SchedModel,\n                             const MachineInstr &DefMI) const;\n\n  int computeDefOperandLatency(const InstrItineraryData *ItinData,\n                               const MachineInstr &DefMI) const;\n\n  /// Return true if this opcode has high latency to its result.\n  virtual bool isHighLatencyDef(int opc) const { return false; }\n\n  /// Compute operand latency between a def of 'Reg'\n  /// and a use in the current loop. Return true if the target considered\n  /// it 'high'. This is used by optimization passes such as machine LICM to\n  /// determine whether it makes sense to hoist an instruction out even in a\n  /// high register pressure situation.\n  virtual bool hasHighOperandLatency(const TargetSchedModel &SchedModel,\n                                     const MachineRegisterInfo *MRI,\n                                     const MachineInstr &DefMI, unsigned DefIdx,\n                                     const MachineInstr &UseMI,\n                                     unsigned UseIdx) const {\n    return false;\n  }\n\n  /// Compute operand latency of a def of 'Reg'. Return true\n  /// if the target considered it 'low'.\n  virtual bool hasLowDefLatency(const TargetSchedModel &SchedModel,\n                                const MachineInstr &DefMI,\n                                unsigned DefIdx) const;\n\n  /// Perform target-specific instruction verification.\n  virtual bool verifyInstruction(const MachineInstr &MI,\n                                 StringRef &ErrInfo) const {\n    return true;\n  }\n\n  /// Return the current execution domain and bit mask of\n  /// possible domains for instruction.\n  ///\n  /// Some micro-architectures have multiple execution domains, and multiple\n  /// opcodes that perform the same operation in different domains.  For\n  /// example, the x86 architecture provides the por, orps, and orpd\n  /// instructions that all do the same thing.  There is a latency penalty if a\n  /// register is written in one domain and read in another.\n  ///\n  /// This function returns a pair (domain, mask) containing the execution\n  /// domain of MI, and a bit mask of possible domains.  The setExecutionDomain\n  /// function can be used to change the opcode to one of the domains in the\n  /// bit mask.  Instructions whose execution domain can't be changed should\n  /// return a 0 mask.\n  ///\n  /// The execution domain numbers don't have any special meaning except domain\n  /// 0 is used for instructions that are not associated with any interesting\n  /// execution domain.\n  ///\n  virtual std::pair<uint16_t, uint16_t>\n  getExecutionDomain(const MachineInstr &MI) const {\n    return std::make_pair(0, 0);\n  }\n\n  /// Change the opcode of MI to execute in Domain.\n  ///\n  /// The bit (1 << Domain) must be set in the mask returned from\n  /// getExecutionDomain(MI).\n  virtual void setExecutionDomain(MachineInstr &MI, unsigned Domain) const {}\n\n  /// Returns the preferred minimum clearance\n  /// before an instruction with an unwanted partial register update.\n  ///\n  /// Some instructions only write part of a register, and implicitly need to\n  /// read the other parts of the register.  This may cause unwanted stalls\n  /// preventing otherwise unrelated instructions from executing in parallel in\n  /// an out-of-order CPU.\n  ///\n  /// For example, the x86 instruction cvtsi2ss writes its result to bits\n  /// [31:0] of the destination xmm register. Bits [127:32] are unaffected, so\n  /// the instruction needs to wait for the old value of the register to become\n  /// available:\n  ///\n  ///   addps %xmm1, %xmm0\n  ///   movaps %xmm0, (%rax)\n  ///   cvtsi2ss %rbx, %xmm0\n  ///\n  /// In the code above, the cvtsi2ss instruction needs to wait for the addps\n  /// instruction before it can issue, even though the high bits of %xmm0\n  /// probably aren't needed.\n  ///\n  /// This hook returns the preferred clearance before MI, measured in\n  /// instructions.  Other defs of MI's operand OpNum are avoided in the last N\n  /// instructions before MI.  It should only return a positive value for\n  /// unwanted dependencies.  If the old bits of the defined register have\n  /// useful values, or if MI is determined to otherwise read the dependency,\n  /// the hook should return 0.\n  ///\n  /// The unwanted dependency may be handled by:\n  ///\n  /// 1. Allocating the same register for an MI def and use.  That makes the\n  ///    unwanted dependency identical to a required dependency.\n  ///\n  /// 2. Allocating a register for the def that has no defs in the previous N\n  ///    instructions.\n  ///\n  /// 3. Calling breakPartialRegDependency() with the same arguments.  This\n  ///    allows the target to insert a dependency breaking instruction.\n  ///\n  virtual unsigned\n  getPartialRegUpdateClearance(const MachineInstr &MI, unsigned OpNum,\n                               const TargetRegisterInfo *TRI) const {\n    // The default implementation returns 0 for no partial register dependency.\n    return 0;\n  }\n\n  /// Return the minimum clearance before an instruction that reads an\n  /// unused register.\n  ///\n  /// For example, AVX instructions may copy part of a register operand into\n  /// the unused high bits of the destination register.\n  ///\n  /// vcvtsi2sdq %rax, undef %xmm0, %xmm14\n  ///\n  /// In the code above, vcvtsi2sdq copies %xmm0[127:64] into %xmm14 creating a\n  /// false dependence on any previous write to %xmm0.\n  ///\n  /// This hook works similarly to getPartialRegUpdateClearance, except that it\n  /// does not take an operand index. Instead sets \\p OpNum to the index of the\n  /// unused register.\n  virtual unsigned getUndefRegClearance(const MachineInstr &MI, unsigned OpNum,\n                                        const TargetRegisterInfo *TRI) const {\n    // The default implementation returns 0 for no undef register dependency.\n    return 0;\n  }\n\n  /// Insert a dependency-breaking instruction\n  /// before MI to eliminate an unwanted dependency on OpNum.\n  ///\n  /// If it wasn't possible to avoid a def in the last N instructions before MI\n  /// (see getPartialRegUpdateClearance), this hook will be called to break the\n  /// unwanted dependency.\n  ///\n  /// On x86, an xorps instruction can be used as a dependency breaker:\n  ///\n  ///   addps %xmm1, %xmm0\n  ///   movaps %xmm0, (%rax)\n  ///   xorps %xmm0, %xmm0\n  ///   cvtsi2ss %rbx, %xmm0\n  ///\n  /// An <imp-kill> operand should be added to MI if an instruction was\n  /// inserted.  This ties the instructions together in the post-ra scheduler.\n  ///\n  virtual void breakPartialRegDependency(MachineInstr &MI, unsigned OpNum,\n                                         const TargetRegisterInfo *TRI) const {}\n\n  /// Create machine specific model for scheduling.\n  virtual DFAPacketizer *\n  CreateTargetScheduleState(const TargetSubtargetInfo &) const {\n    return nullptr;\n  }\n\n  /// Sometimes, it is possible for the target\n  /// to tell, even without aliasing information, that two MIs access different\n  /// memory addresses. This function returns true if two MIs access different\n  /// memory addresses and false otherwise.\n  ///\n  /// Assumes any physical registers used to compute addresses have the same\n  /// value for both instructions. (This is the most useful assumption for\n  /// post-RA scheduling.)\n  ///\n  /// See also MachineInstr::mayAlias, which is implemented on top of this\n  /// function.\n  virtual bool\n  areMemAccessesTriviallyDisjoint(const MachineInstr &MIa,\n                                  const MachineInstr &MIb) const {\n    assert(MIa.mayLoadOrStore() &&\n           \"MIa must load from or modify a memory location\");\n    assert(MIb.mayLoadOrStore() &&\n           \"MIb must load from or modify a memory location\");\n    return false;\n  }\n\n  /// Return the value to use for the MachineCSE's LookAheadLimit,\n  /// which is a heuristic used for CSE'ing phys reg defs.\n  virtual unsigned getMachineCSELookAheadLimit() const {\n    // The default lookahead is small to prevent unprofitable quadratic\n    // behavior.\n    return 5;\n  }\n\n  /// Return the maximal number of alias checks on memory operands. For\n  /// instructions with more than one memory operands, the alias check on a\n  /// single MachineInstr pair has quadratic overhead and results in\n  /// unacceptable performance in the worst case. The limit here is to clamp\n  /// that maximal checks performed. Usually, that's the product of memory\n  /// operand numbers from that pair of MachineInstr to be checked. For\n  /// instance, with two MachineInstrs with 4 and 5 memory operands\n  /// correspondingly, a total of 20 checks are required. With this limit set to\n  /// 16, their alias check is skipped. We choose to limit the product instead\n  /// of the individual instruction as targets may have special MachineInstrs\n  /// with a considerably high number of memory operands, such as `ldm` in ARM.\n  /// Setting this limit per MachineInstr would result in either too high\n  /// overhead or too rigid restriction.\n  virtual unsigned getMemOperandAACheckLimit() const { return 16; }\n\n  /// Return an array that contains the ids of the target indices (used for the\n  /// TargetIndex machine operand) and their names.\n  ///\n  /// MIR Serialization is able to serialize only the target indices that are\n  /// defined by this method.\n  virtual ArrayRef<std::pair<int, const char *>>\n  getSerializableTargetIndices() const {\n    return None;\n  }\n\n  /// Decompose the machine operand's target flags into two values - the direct\n  /// target flag value and any of bit flags that are applied.\n  virtual std::pair<unsigned, unsigned>\n  decomposeMachineOperandsTargetFlags(unsigned /*TF*/) const {\n    return std::make_pair(0u, 0u);\n  }\n\n  /// Return an array that contains the direct target flag values and their\n  /// names.\n  ///\n  /// MIR Serialization is able to serialize only the target flags that are\n  /// defined by this method.\n  virtual ArrayRef<std::pair<unsigned, const char *>>\n  getSerializableDirectMachineOperandTargetFlags() const {\n    return None;\n  }\n\n  /// Return an array that contains the bitmask target flag values and their\n  /// names.\n  ///\n  /// MIR Serialization is able to serialize only the target flags that are\n  /// defined by this method.\n  virtual ArrayRef<std::pair<unsigned, const char *>>\n  getSerializableBitmaskMachineOperandTargetFlags() const {\n    return None;\n  }\n\n  /// Return an array that contains the MMO target flag values and their\n  /// names.\n  ///\n  /// MIR Serialization is able to serialize only the MMO target flags that are\n  /// defined by this method.\n  virtual ArrayRef<std::pair<MachineMemOperand::Flags, const char *>>\n  getSerializableMachineMemOperandTargetFlags() const {\n    return None;\n  }\n\n  /// Determines whether \\p Inst is a tail call instruction. Override this\n  /// method on targets that do not properly set MCID::Return and MCID::Call on\n  /// tail call instructions.\"\n  virtual bool isTailCall(const MachineInstr &Inst) const {\n    return Inst.isReturn() && Inst.isCall();\n  }\n\n  /// True if the instruction is bound to the top of its basic block and no\n  /// other instructions shall be inserted before it. This can be implemented\n  /// to prevent register allocator to insert spills before such instructions.\n  virtual bool isBasicBlockPrologue(const MachineInstr &MI) const {\n    return false;\n  }\n\n  /// During PHI eleimination lets target to make necessary checks and\n  /// insert the copy to the PHI destination register in a target specific\n  /// manner.\n  virtual MachineInstr *createPHIDestinationCopy(\n      MachineBasicBlock &MBB, MachineBasicBlock::iterator InsPt,\n      const DebugLoc &DL, Register Src, Register Dst) const {\n    return BuildMI(MBB, InsPt, DL, get(TargetOpcode::COPY), Dst)\n        .addReg(Src);\n  }\n\n  /// During PHI eleimination lets target to make necessary checks and\n  /// insert the copy to the PHI destination register in a target specific\n  /// manner.\n  virtual MachineInstr *createPHISourceCopy(MachineBasicBlock &MBB,\n                                            MachineBasicBlock::iterator InsPt,\n                                            const DebugLoc &DL, Register Src,\n                                            unsigned SrcSubReg,\n                                            Register Dst) const {\n    return BuildMI(MBB, InsPt, DL, get(TargetOpcode::COPY), Dst)\n        .addReg(Src, 0, SrcSubReg);\n  }\n\n  /// Returns a \\p outliner::OutlinedFunction struct containing target-specific\n  /// information for a set of outlining candidates.\n  virtual outliner::OutlinedFunction getOutliningCandidateInfo(\n      std::vector<outliner::Candidate> &RepeatedSequenceLocs) const {\n    llvm_unreachable(\n        \"Target didn't implement TargetInstrInfo::getOutliningCandidateInfo!\");\n  }\n\n  /// Returns how or if \\p MI should be outlined.\n  virtual outliner::InstrType\n  getOutliningType(MachineBasicBlock::iterator &MIT, unsigned Flags) const {\n    llvm_unreachable(\n        \"Target didn't implement TargetInstrInfo::getOutliningType!\");\n  }\n\n  /// Optional target hook that returns true if \\p MBB is safe to outline from,\n  /// and returns any target-specific information in \\p Flags.\n  virtual bool isMBBSafeToOutlineFrom(MachineBasicBlock &MBB,\n                                      unsigned &Flags) const {\n    return true;\n  }\n\n  /// Insert a custom frame for outlined functions.\n  virtual void buildOutlinedFrame(MachineBasicBlock &MBB, MachineFunction &MF,\n                                  const outliner::OutlinedFunction &OF) const {\n    llvm_unreachable(\n        \"Target didn't implement TargetInstrInfo::buildOutlinedFrame!\");\n  }\n\n  /// Insert a call to an outlined function into the program.\n  /// Returns an iterator to the spot where we inserted the call. This must be\n  /// implemented by the target.\n  virtual MachineBasicBlock::iterator\n  insertOutlinedCall(Module &M, MachineBasicBlock &MBB,\n                     MachineBasicBlock::iterator &It, MachineFunction &MF,\n                     const outliner::Candidate &C) const {\n    llvm_unreachable(\n        \"Target didn't implement TargetInstrInfo::insertOutlinedCall!\");\n  }\n\n  /// Return true if the function can safely be outlined from.\n  /// A function \\p MF is considered safe for outlining if an outlined function\n  /// produced from instructions in F will produce a program which produces the\n  /// same output for any set of given inputs.\n  virtual bool isFunctionSafeToOutlineFrom(MachineFunction &MF,\n                                           bool OutlineFromLinkOnceODRs) const {\n    llvm_unreachable(\"Target didn't implement \"\n                     \"TargetInstrInfo::isFunctionSafeToOutlineFrom!\");\n  }\n\n  /// Return true if the function should be outlined from by default.\n  virtual bool shouldOutlineFromFunctionByDefault(MachineFunction &MF) const {\n    return false;\n  }\n\n  /// Produce the expression describing the \\p MI loading a value into\n  /// the physical register \\p Reg. This hook should only be used with\n  /// \\p MIs belonging to VReg-less functions.\n  virtual Optional<ParamLoadedValue> describeLoadedValue(const MachineInstr &MI,\n                                                         Register Reg) const;\n\n  /// Given the generic extension instruction \\p ExtMI, returns true if this\n  /// extension is a likely candidate for being folded into an another\n  /// instruction.\n  virtual bool isExtendLikelyToBeFolded(MachineInstr &ExtMI,\n                                        MachineRegisterInfo &MRI) const {\n    return false;\n  }\n\n  /// Return MIR formatter to format/parse MIR operands.  Target can override\n  /// this virtual function and return target specific MIR formatter.\n  virtual const MIRFormatter *getMIRFormatter() const {\n    if (!Formatter.get())\n      Formatter = std::make_unique<MIRFormatter>();\n    return Formatter.get();\n  }\n\n  /// Returns the target-specific default value for tail duplication.\n  /// This value will be used if the tail-dup-placement-threshold argument is\n  /// not provided.\n  virtual unsigned getTailDuplicateSize(CodeGenOpt::Level OptLevel) const {\n    return OptLevel >= CodeGenOpt::Aggressive ? 4 : 2;\n  }\n\nprivate:\n  mutable std::unique_ptr<MIRFormatter> Formatter;\n  unsigned CallFrameSetupOpcode, CallFrameDestroyOpcode;\n  unsigned CatchRetOpcode;\n  unsigned ReturnOpcode;\n};\n\n/// Provide DenseMapInfo for TargetInstrInfo::RegSubRegPair.\ntemplate <> struct DenseMapInfo<TargetInstrInfo::RegSubRegPair> {\n  using RegInfo = DenseMapInfo<unsigned>;\n\n  static inline TargetInstrInfo::RegSubRegPair getEmptyKey() {\n    return TargetInstrInfo::RegSubRegPair(RegInfo::getEmptyKey(),\n                                          RegInfo::getEmptyKey());\n  }\n\n  static inline TargetInstrInfo::RegSubRegPair getTombstoneKey() {\n    return TargetInstrInfo::RegSubRegPair(RegInfo::getTombstoneKey(),\n                                          RegInfo::getTombstoneKey());\n  }\n\n  /// Reuse getHashValue implementation from\n  /// std::pair<unsigned, unsigned>.\n  static unsigned getHashValue(const TargetInstrInfo::RegSubRegPair &Val) {\n    std::pair<unsigned, unsigned> PairVal = std::make_pair(Val.Reg, Val.SubReg);\n    return DenseMapInfo<std::pair<unsigned, unsigned>>::getHashValue(PairVal);\n  }\n\n  static bool isEqual(const TargetInstrInfo::RegSubRegPair &LHS,\n                      const TargetInstrInfo::RegSubRegPair &RHS) {\n    return RegInfo::isEqual(LHS.Reg, RHS.Reg) &&\n           RegInfo::isEqual(LHS.SubReg, RHS.SubReg);\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_TARGETINSTRINFO_H\n"}, "38": {"id": 38, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/TileShapeInfo.h", "content": "//===- llvm/CodeGen/TileShapeInfo.h - ---------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file Shape utility for AMX.\n/// AMX hardware requires to config the shape of tile data register before use.\n/// The 2D shape includes row and column. In AMX intrinsics interface the shape\n/// is passed as 1st and 2nd parameter and they are lowered as the 1st and 2nd\n/// machine operand of AMX pseudo instructions. ShapeT class is to facilitate\n/// tile config and register allocator. The row and column are machine operand\n/// of AMX pseudo instructions.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_TILESHAPEINFO_H\n#define LLVM_CODEGEN_TILESHAPEINFO_H\n\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/CodeGen/MachineInstr.h\"\n#include \"llvm/CodeGen/MachineOperand.h\"\n#include \"llvm/CodeGen/MachineRegisterInfo.h\"\n#include \"llvm/CodeGen/Register.h\"\n#include <utility>\n\nnamespace llvm {\n\nclass ShapeT {\npublic:\n  ShapeT(MachineOperand *Row, MachineOperand *Col,\n         const MachineRegisterInfo *MRI = nullptr)\n      : Row(Row), Col(Col) {\n    if (MRI)\n      deduceImm(MRI);\n  }\n  ShapeT()\n      : Row(nullptr), Col(nullptr), RowImm(InvalidImmShape),\n        ColImm(InvalidImmShape) {}\n  bool operator==(const ShapeT &Shape) {\n    MachineOperand *R = Shape.Row;\n    MachineOperand *C = Shape.Col;\n    if (!R || !C)\n      return false;\n    if (!Row || !Col)\n      return false;\n    if (Row->getReg() == R->getReg() && Col->getReg() == C->getReg())\n      return true;\n    if ((RowImm != InvalidImmShape) && (ColImm != InvalidImmShape))\n      return RowImm == Shape.getRowImm() && ColImm == Shape.getColImm();\n    return false;\n  }\n\n  bool operator!=(const ShapeT &Shape) { return !(*this == Shape); }\n\n  MachineOperand *getRow() const { return Row; }\n\n  MachineOperand *getCol() const { return Col; }\n\n  int64_t getRowImm() const { return RowImm; }\n\n  int64_t getColImm() const { return ColImm; }\n\n  bool isValid() { return (Row != nullptr) && (Col != nullptr); }\n\n  void deduceImm(const MachineRegisterInfo *MRI) {\n    // All def must be the same value, otherwise it is invalid MIs.\n    // Find the immediate.\n    // TODO copy propagation.\n    auto GetImm = [&](Register Reg) {\n      int64_t Imm = InvalidImmShape;\n      for (const MachineOperand &DefMO : MRI->def_operands(Reg)) {\n        const auto *MI = DefMO.getParent();\n        if (MI->isMoveImmediate()) {\n          Imm = MI->getOperand(1).getImm();\n          break;\n        }\n      }\n      return Imm;\n    };\n    RowImm = GetImm(Row->getReg());\n    ColImm = GetImm(Col->getReg());\n  }\n\nprivate:\n  static constexpr int64_t InvalidImmShape = -1;\n  MachineOperand *Row;\n  MachineOperand *Col;\n  int64_t RowImm;\n  int64_t ColImm;\n};\n\n} // namespace llvm\n\n#endif\n"}, "39": {"id": 39, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h", "content": "//===- CodeGen/ValueTypes.h - Low-Level Target independ. types --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the set of low-level target independent types which various\n// values in the code generator are.  This allows the target specific behavior\n// of instructions to be described to target independent passes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_VALUETYPES_H\n#define LLVM_CODEGEN_VALUETYPES_H\n\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/MachineValueType.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/TypeSize.h\"\n#include \"llvm/Support/WithColor.h\"\n#include <cassert>\n#include <cstdint>\n#include <string>\n\nnamespace llvm {\n\n  class LLVMContext;\n  class Type;\n\n  /// Extended Value Type. Capable of holding value types which are not native\n  /// for any processor (such as the i12345 type), as well as the types an MVT\n  /// can represent.\n  struct EVT {\n  private:\n    MVT V = MVT::INVALID_SIMPLE_VALUE_TYPE;\n    Type *LLVMTy = nullptr;\n\n  public:\n    constexpr EVT() = default;\n    constexpr EVT(MVT::SimpleValueType SVT) : V(SVT) {}\n    constexpr EVT(MVT S) : V(S) {}\n\n    bool operator==(EVT VT) const {\n      return !(*this != VT);\n    }\n    bool operator!=(EVT VT) const {\n      if (V.SimpleTy != VT.V.SimpleTy)\n        return true;\n      if (V.SimpleTy == MVT::INVALID_SIMPLE_VALUE_TYPE)\n        return LLVMTy != VT.LLVMTy;\n      return false;\n    }\n\n    /// Returns the EVT that represents a floating-point type with the given\n    /// number of bits. There are two floating-point types with 128 bits - this\n    /// returns f128 rather than ppcf128.\n    static EVT getFloatingPointVT(unsigned BitWidth) {\n      return MVT::getFloatingPointVT(BitWidth);\n    }\n\n    /// Returns the EVT that represents an integer with the given number of\n    /// bits.\n    static EVT getIntegerVT(LLVMContext &Context, unsigned BitWidth) {\n      MVT M = MVT::getIntegerVT(BitWidth);\n      if (M.SimpleTy != MVT::INVALID_SIMPLE_VALUE_TYPE)\n        return M;\n      return getExtendedIntegerVT(Context, BitWidth);\n    }\n\n    /// Returns the EVT that represents a vector NumElements in length, where\n    /// each element is of type VT.\n    static EVT getVectorVT(LLVMContext &Context, EVT VT, unsigned NumElements,\n                           bool IsScalable = false) {\n      MVT M = MVT::getVectorVT(VT.V, NumElements, IsScalable);\n      if (M.SimpleTy != MVT::INVALID_SIMPLE_VALUE_TYPE)\n        return M;\n      return getExtendedVectorVT(Context, VT, NumElements, IsScalable);\n    }\n\n    /// Returns the EVT that represents a vector EC.Min elements in length,\n    /// where each element is of type VT.\n    static EVT getVectorVT(LLVMContext &Context, EVT VT, ElementCount EC) {\n      MVT M = MVT::getVectorVT(VT.V, EC);\n      if (M.SimpleTy != MVT::INVALID_SIMPLE_VALUE_TYPE)\n        return M;\n      return getExtendedVectorVT(Context, VT, EC);\n    }\n\n    /// Return a vector with the same number of elements as this vector, but\n    /// with the element type converted to an integer type with the same\n    /// bitwidth.\n    EVT changeVectorElementTypeToInteger() const {\n      if (isSimple())\n        return getSimpleVT().changeVectorElementTypeToInteger();\n      return changeExtendedVectorElementTypeToInteger();\n    }\n\n    /// Return a VT for a vector type whose attributes match ourselves\n    /// with the exception of the element type that is chosen by the caller.\n    EVT changeVectorElementType(EVT EltVT) const {\n      if (isSimple()) {\n        assert(EltVT.isSimple() &&\n               \"Can't change simple vector VT to have extended element VT\");\n        return getSimpleVT().changeVectorElementType(EltVT.getSimpleVT());\n      }\n      return changeExtendedVectorElementType(EltVT);\n    }\n\n    /// Return the type converted to an equivalently sized integer or vector\n    /// with integer element type. Similar to changeVectorElementTypeToInteger,\n    /// but also handles scalars.\n    EVT changeTypeToInteger() {\n      if (isVector())\n        return changeVectorElementTypeToInteger();\n\n      if (isSimple())\n        return getSimpleVT().changeTypeToInteger();\n      return changeExtendedTypeToInteger();\n    }\n\n    /// Test if the given EVT is simple (as opposed to being extended).\n    bool isSimple() const {\n      return V.SimpleTy != MVT::INVALID_SIMPLE_VALUE_TYPE;\n    }\n\n    /// Test if the given EVT is extended (as opposed to being simple).\n    bool isExtended() const {\n      return !isSimple();\n    }\n\n    /// Return true if this is a FP or a vector FP type.\n    bool isFloatingPoint() const {\n      return isSimple() ? V.isFloatingPoint() : isExtendedFloatingPoint();\n    }\n\n    /// Return true if this is an integer or a vector integer type.\n    bool isInteger() const {\n      return isSimple() ? V.isInteger() : isExtendedInteger();\n    }\n\n    /// Return true if this is an integer, but not a vector.\n    bool isScalarInteger() const {\n      return isSimple() ? V.isScalarInteger() : isExtendedScalarInteger();\n    }\n\n    /// Return true if this is a vector value type.\n    bool isVector() const {\n      return isSimple() ? V.isVector() : isExtendedVector();\n    }\n\n    /// Return true if this is a vector type where the runtime\n    /// length is machine dependent\n    bool isScalableVector() const {\n      return isSimple() ? V.isScalableVector() : isExtendedScalableVector();\n    }\n\n    bool isFixedLengthVector() const {\n      return isSimple() ? V.isFixedLengthVector()\n                        : isExtendedFixedLengthVector();\n    }\n\n    /// Return true if this is a 16-bit vector type.\n    bool is16BitVector() const {\n      return isSimple() ? V.is16BitVector() : isExtended16BitVector();\n    }\n\n    /// Return true if this is a 32-bit vector type.\n    bool is32BitVector() const {\n      return isSimple() ? V.is32BitVector() : isExtended32BitVector();\n    }\n\n    /// Return true if this is a 64-bit vector type.\n    bool is64BitVector() const {\n      return isSimple() ? V.is64BitVector() : isExtended64BitVector();\n    }\n\n    /// Return true if this is a 128-bit vector type.\n    bool is128BitVector() const {\n      return isSimple() ? V.is128BitVector() : isExtended128BitVector();\n    }\n\n    /// Return true if this is a 256-bit vector type.\n    bool is256BitVector() const {\n      return isSimple() ? V.is256BitVector() : isExtended256BitVector();\n    }\n\n    /// Return true if this is a 512-bit vector type.\n    bool is512BitVector() const {\n      return isSimple() ? V.is512BitVector() : isExtended512BitVector();\n    }\n\n    /// Return true if this is a 1024-bit vector type.\n    bool is1024BitVector() const {\n      return isSimple() ? V.is1024BitVector() : isExtended1024BitVector();\n    }\n\n    /// Return true if this is a 2048-bit vector type.\n    bool is2048BitVector() const {\n      return isSimple() ? V.is2048BitVector() : isExtended2048BitVector();\n    }\n\n    /// Return true if this is an overloaded type for TableGen.\n    bool isOverloaded() const {\n      return (V==MVT::iAny || V==MVT::fAny || V==MVT::vAny || V==MVT::iPTRAny);\n    }\n\n    /// Return true if the bit size is a multiple of 8.\n    bool isByteSized() const { return getSizeInBits().isKnownMultipleOf(8); }\n\n    /// Return true if the size is a power-of-two number of bytes.\n    bool isRound() const {\n      if (isScalableVector())\n        return false;\n      unsigned BitSize = getSizeInBits();\n      return BitSize >= 8 && !(BitSize & (BitSize - 1));\n    }\n\n    /// Return true if this has the same number of bits as VT.\n    bool bitsEq(EVT VT) const {\n      if (EVT::operator==(VT)) return true;\n      return getSizeInBits() == VT.getSizeInBits();\n    }\n\n    /// Return true if we know at compile time this has more bits than VT.\n    bool knownBitsGT(EVT VT) const {\n      return TypeSize::isKnownGT(getSizeInBits(), VT.getSizeInBits());\n    }\n\n    /// Return true if we know at compile time this has more than or the same\n    /// bits as VT.\n    bool knownBitsGE(EVT VT) const {\n      return TypeSize::isKnownGE(getSizeInBits(), VT.getSizeInBits());\n    }\n\n    /// Return true if we know at compile time this has fewer bits than VT.\n    bool knownBitsLT(EVT VT) const {\n      return TypeSize::isKnownLT(getSizeInBits(), VT.getSizeInBits());\n    }\n\n    /// Return true if we know at compile time this has fewer than or the same\n    /// bits as VT.\n    bool knownBitsLE(EVT VT) const {\n      return TypeSize::isKnownLE(getSizeInBits(), VT.getSizeInBits());\n    }\n\n    /// Return true if this has more bits than VT.\n    bool bitsGT(EVT VT) const {\n      if (EVT::operator==(VT)) return false;\n      assert(isScalableVector() == VT.isScalableVector() &&\n             \"Comparison between scalable and fixed types\");\n      return knownBitsGT(VT);\n    }\n\n    /// Return true if this has no less bits than VT.\n    bool bitsGE(EVT VT) const {\n      if (EVT::operator==(VT)) return true;\n      assert(isScalableVector() == VT.isScalableVector() &&\n             \"Comparison between scalable and fixed types\");\n      return knownBitsGE(VT);\n    }\n\n    /// Return true if this has less bits than VT.\n    bool bitsLT(EVT VT) const {\n      if (EVT::operator==(VT)) return false;\n      assert(isScalableVector() == VT.isScalableVector() &&\n             \"Comparison between scalable and fixed types\");\n      return knownBitsLT(VT);\n    }\n\n    /// Return true if this has no more bits than VT.\n    bool bitsLE(EVT VT) const {\n      if (EVT::operator==(VT)) return true;\n      assert(isScalableVector() == VT.isScalableVector() &&\n             \"Comparison between scalable and fixed types\");\n      return knownBitsLE(VT);\n    }\n\n    /// Return the SimpleValueType held in the specified simple EVT.\n    MVT getSimpleVT() const {\n      assert(isSimple() && \"Expected a SimpleValueType!\");\n      return V;\n    }\n\n    /// If this is a vector type, return the element type, otherwise return\n    /// this.\n    EVT getScalarType() const {\n      return isVector() ? getVectorElementType() : *this;\n    }\n\n    /// Given a vector type, return the type of each element.\n    EVT getVectorElementType() const {\n      assert(isVector() && \"Invalid vector type!\");\n      if (isSimple())\n        return V.getVectorElementType();\n      return getExtendedVectorElementType();\n    }\n\n    /// Given a vector type, return the number of elements it contains.\n    unsigned getVectorNumElements() const {\n#ifdef STRICT_FIXED_SIZE_VECTORS\n      assert(isFixedLengthVector() && \"Invalid vector type!\");\n#else\n      assert(isVector() && \"Invalid vector type!\");\n      if (isScalableVector())\n        WithColor::warning()\n            << \"Possible incorrect use of EVT::getVectorNumElements() for \"\n               \"scalable vector. Scalable flag may be dropped, use \"\n               \"EVT::getVectorElementCount() instead\\n\";\n#endif\n      if (isSimple())\n        return V.getVectorNumElements();\n      return getExtendedVectorNumElements();\n    }\n\n    // Given a (possibly scalable) vector type, return the ElementCount\n    ElementCount getVectorElementCount() const {\n      assert((isVector()) && \"Invalid vector type!\");\n      if (isSimple())\n        return V.getVectorElementCount();\n\n      return getExtendedVectorElementCount();\n    }\n\n    /// Given a vector type, return the minimum number of elements it contains.\n    unsigned getVectorMinNumElements() const {\n      return getVectorElementCount().getKnownMinValue();\n    }\n\n    /// Return the size of the specified value type in bits.\n    ///\n    /// If the value type is a scalable vector type, the scalable property will\n    /// be set and the runtime size will be a positive integer multiple of the\n    /// base size.\n    TypeSize getSizeInBits() const {\n      if (isSimple())\n        return V.getSizeInBits();\n      return getExtendedSizeInBits();\n    }\n\n    /// Return the size of the specified fixed width value type in bits. The\n    /// function will assert if the type is scalable.\n    uint64_t getFixedSizeInBits() const {\n      return getSizeInBits().getFixedSize();\n    }\n\n    uint64_t getScalarSizeInBits() const {\n      return getScalarType().getSizeInBits().getFixedSize();\n    }\n\n    /// Return the number of bytes overwritten by a store of the specified value\n    /// type.\n    ///\n    /// If the value type is a scalable vector type, the scalable property will\n    /// be set and the runtime size will be a positive integer multiple of the\n    /// base size.\n    TypeSize getStoreSize() const {\n      TypeSize BaseSize = getSizeInBits();\n      return {(BaseSize.getKnownMinSize() + 7) / 8, BaseSize.isScalable()};\n    }\n\n    /// Return the number of bits overwritten by a store of the specified value\n    /// type.\n    ///\n    /// If the value type is a scalable vector type, the scalable property will\n    /// be set and the runtime size will be a positive integer multiple of the\n    /// base size.\n    TypeSize getStoreSizeInBits() const {\n      return getStoreSize() * 8;\n    }\n\n    /// Rounds the bit-width of the given integer EVT up to the nearest power of\n    /// two (and at least to eight), and returns the integer EVT with that\n    /// number of bits.\n    EVT getRoundIntegerType(LLVMContext &Context) const {\n      assert(isInteger() && !isVector() && \"Invalid integer type!\");\n      unsigned BitWidth = getSizeInBits();\n      if (BitWidth <= 8)\n        return EVT(MVT::i8);\n      return getIntegerVT(Context, 1 << Log2_32_Ceil(BitWidth));\n    }\n\n    /// Finds the smallest simple value type that is greater than or equal to\n    /// half the width of this EVT. If no simple value type can be found, an\n    /// extended integer value type of half the size (rounded up) is returned.\n    EVT getHalfSizedIntegerVT(LLVMContext &Context) const {\n      assert(isInteger() && !isVector() && \"Invalid integer type!\");\n      unsigned EVTSize = getSizeInBits();\n      for (unsigned IntVT = MVT::FIRST_INTEGER_VALUETYPE;\n          IntVT <= MVT::LAST_INTEGER_VALUETYPE; ++IntVT) {\n        EVT HalfVT = EVT((MVT::SimpleValueType)IntVT);\n        if (HalfVT.getSizeInBits() * 2 >= EVTSize)\n          return HalfVT;\n      }\n      return getIntegerVT(Context, (EVTSize + 1) / 2);\n    }\n\n    /// Return a VT for an integer vector type with the size of the\n    /// elements doubled. The typed returned may be an extended type.\n    EVT widenIntegerVectorElementType(LLVMContext &Context) const {\n      EVT EltVT = getVectorElementType();\n      EltVT = EVT::getIntegerVT(Context, 2 * EltVT.getSizeInBits());\n      return EVT::getVectorVT(Context, EltVT, getVectorElementCount());\n    }\n\n    // Return a VT for a vector type with the same element type but\n    // half the number of elements. The type returned may be an\n    // extended type.\n    EVT getHalfNumVectorElementsVT(LLVMContext &Context) const {\n      EVT EltVT = getVectorElementType();\n      auto EltCnt = getVectorElementCount();\n      assert(EltCnt.isKnownEven() && \"Splitting vector, but not in half!\");\n      return EVT::getVectorVT(Context, EltVT, EltCnt.divideCoefficientBy(2));\n    }\n\n    // Return a VT for a vector type with the same element type but\n    // double the number of elements. The type returned may be an\n    // extended type.\n    EVT getDoubleNumVectorElementsVT(LLVMContext &Context) const {\n      EVT EltVT = getVectorElementType();\n      auto EltCnt = getVectorElementCount();\n      return EVT::getVectorVT(Context, EltVT, EltCnt * 2);\n    }\n\n    /// Returns true if the given vector is a power of 2.\n    bool isPow2VectorType() const {\n      unsigned NElts = getVectorMinNumElements();\n      return !(NElts & (NElts - 1));\n    }\n\n    /// Widens the length of the given vector EVT up to the nearest power of 2\n    /// and returns that type.\n    EVT getPow2VectorType(LLVMContext &Context) const {\n      if (!isPow2VectorType()) {\n        ElementCount NElts = getVectorElementCount();\n        unsigned NewMinCount = 1 << Log2_32_Ceil(NElts.getKnownMinValue());\n        NElts = ElementCount::get(NewMinCount, NElts.isScalable());\n        return EVT::getVectorVT(Context, getVectorElementType(), NElts);\n      }\n      else {\n        return *this;\n      }\n    }\n\n    /// This function returns value type as a string, e.g. \"i32\".\n    std::string getEVTString() const;\n\n    /// This method returns an LLVM type corresponding to the specified EVT.\n    /// For integer types, this returns an unsigned type. Note that this will\n    /// abort for types that cannot be represented.\n    Type *getTypeForEVT(LLVMContext &Context) const;\n\n    /// Return the value type corresponding to the specified type.\n    /// This returns all pointers as iPTR.  If HandleUnknown is true, unknown\n    /// types are returned as Other, otherwise they are invalid.\n    static EVT getEVT(Type *Ty, bool HandleUnknown = false);\n\n    intptr_t getRawBits() const {\n      if (isSimple())\n        return V.SimpleTy;\n      else\n        return (intptr_t)(LLVMTy);\n    }\n\n    /// A meaningless but well-behaved order, useful for constructing\n    /// containers.\n    struct compareRawBits {\n      bool operator()(EVT L, EVT R) const {\n        if (L.V.SimpleTy == R.V.SimpleTy)\n          return L.LLVMTy < R.LLVMTy;\n        else\n          return L.V.SimpleTy < R.V.SimpleTy;\n      }\n    };\n\n  private:\n    // Methods for handling the Extended-type case in functions above.\n    // These are all out-of-line to prevent users of this header file\n    // from having a dependency on Type.h.\n    EVT changeExtendedTypeToInteger() const;\n    EVT changeExtendedVectorElementType(EVT EltVT) const;\n    EVT changeExtendedVectorElementTypeToInteger() const;\n    static EVT getExtendedIntegerVT(LLVMContext &C, unsigned BitWidth);\n    static EVT getExtendedVectorVT(LLVMContext &C, EVT VT, unsigned NumElements,\n                                   bool IsScalable);\n    static EVT getExtendedVectorVT(LLVMContext &Context, EVT VT,\n                                   ElementCount EC);\n    bool isExtendedFloatingPoint() const LLVM_READONLY;\n    bool isExtendedInteger() const LLVM_READONLY;\n    bool isExtendedScalarInteger() const LLVM_READONLY;\n    bool isExtendedVector() const LLVM_READONLY;\n    bool isExtended16BitVector() const LLVM_READONLY;\n    bool isExtended32BitVector() const LLVM_READONLY;\n    bool isExtended64BitVector() const LLVM_READONLY;\n    bool isExtended128BitVector() const LLVM_READONLY;\n    bool isExtended256BitVector() const LLVM_READONLY;\n    bool isExtended512BitVector() const LLVM_READONLY;\n    bool isExtended1024BitVector() const LLVM_READONLY;\n    bool isExtended2048BitVector() const LLVM_READONLY;\n    bool isExtendedFixedLengthVector() const LLVM_READONLY;\n    bool isExtendedScalableVector() const LLVM_READONLY;\n    EVT getExtendedVectorElementType() const;\n    unsigned getExtendedVectorNumElements() const LLVM_READONLY;\n    ElementCount getExtendedVectorElementCount() const LLVM_READONLY;\n    TypeSize getExtendedSizeInBits() const LLVM_READONLY;\n  };\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_VALUETYPES_H\n"}, "56": {"id": 56, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCContext.h", "content": "//===- MCContext.h - Machine Code Context -----------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_MCCONTEXT_H\n#define LLVM_MC_MCCONTEXT_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/BinaryFormat/ELF.h\"\n#include \"llvm/BinaryFormat/XCOFF.h\"\n#include \"llvm/MC/MCAsmMacro.h\"\n#include \"llvm/MC/MCDwarf.h\"\n#include \"llvm/MC/MCPseudoProbe.h\"\n#include \"llvm/MC/MCSubtargetInfo.h\"\n#include \"llvm/MC/MCTargetOptions.h\"\n#include \"llvm/MC/SectionKind.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/MD5.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <functional>\n#include <map>\n#include <memory>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\n  class CodeViewContext;\n  class MCAsmInfo;\n  class MCLabel;\n  class MCObjectFileInfo;\n  class MCRegisterInfo;\n  class MCSection;\n  class MCSectionCOFF;\n  class MCSectionELF;\n  class MCSectionMachO;\n  class MCSectionWasm;\n  class MCSectionXCOFF;\n  class MCStreamer;\n  class MCSymbol;\n  class MCSymbolELF;\n  class MCSymbolWasm;\n  class MCSymbolXCOFF;\n  class MDNode;\n  class SMDiagnostic;\n  class SMLoc;\n  class SourceMgr;\n\n  /// Context object for machine code objects.  This class owns all of the\n  /// sections that it creates.\n  ///\n  class MCContext {\n  public:\n    using SymbolTable = StringMap<MCSymbol *, BumpPtrAllocator &>;\n    using DiagHandlerTy =\n        std::function<void(const SMDiagnostic &, bool, const SourceMgr &,\n                           std::vector<const MDNode *> &)>;\n\n  private:\n    /// The SourceMgr for this object, if any.\n    const SourceMgr *SrcMgr;\n\n    /// The SourceMgr for inline assembly, if any.\n    std::unique_ptr<SourceMgr> InlineSrcMgr;\n    std::vector<const MDNode *> LocInfos;\n\n    DiagHandlerTy DiagHandler;\n\n    /// The MCAsmInfo for this target.\n    const MCAsmInfo *MAI;\n\n    /// The MCRegisterInfo for this target.\n    const MCRegisterInfo *MRI;\n\n    /// The MCObjectFileInfo for this target.\n    const MCObjectFileInfo *MOFI;\n\n    std::unique_ptr<CodeViewContext> CVContext;\n\n    /// Allocator object used for creating machine code objects.\n    ///\n    /// We use a bump pointer allocator to avoid the need to track all allocated\n    /// objects.\n    BumpPtrAllocator Allocator;\n\n    SpecificBumpPtrAllocator<MCSectionCOFF> COFFAllocator;\n    SpecificBumpPtrAllocator<MCSectionELF> ELFAllocator;\n    SpecificBumpPtrAllocator<MCSectionMachO> MachOAllocator;\n    SpecificBumpPtrAllocator<MCSectionWasm> WasmAllocator;\n    SpecificBumpPtrAllocator<MCSectionXCOFF> XCOFFAllocator;\n    SpecificBumpPtrAllocator<MCInst> MCInstAllocator;\n\n    /// Bindings of names to symbols.\n    SymbolTable Symbols;\n\n    /// A mapping from a local label number and an instance count to a symbol.\n    /// For example, in the assembly\n    ///     1:\n    ///     2:\n    ///     1:\n    /// We have three labels represented by the pairs (1, 0), (2, 0) and (1, 1)\n    DenseMap<std::pair<unsigned, unsigned>, MCSymbol *> LocalSymbols;\n\n    /// Keeps tracks of names that were used both for used declared and\n    /// artificial symbols. The value is \"true\" if the name has been used for a\n    /// non-section symbol (there can be at most one of those, plus an unlimited\n    /// number of section symbols with the same name).\n    StringMap<bool, BumpPtrAllocator &> UsedNames;\n\n    /// Keeps track of labels that are used in inline assembly.\n    SymbolTable InlineAsmUsedLabelNames;\n\n    /// The next ID to dole out to an unnamed assembler temporary symbol with\n    /// a given prefix.\n    StringMap<unsigned> NextID;\n\n    /// Instances of directional local labels.\n    DenseMap<unsigned, MCLabel *> Instances;\n    /// NextInstance() creates the next instance of the directional local label\n    /// for the LocalLabelVal and adds it to the map if needed.\n    unsigned NextInstance(unsigned LocalLabelVal);\n    /// GetInstance() gets the current instance of the directional local label\n    /// for the LocalLabelVal and adds it to the map if needed.\n    unsigned GetInstance(unsigned LocalLabelVal);\n\n    /// The file name of the log file from the environment variable\n    /// AS_SECURE_LOG_FILE.  Which must be set before the .secure_log_unique\n    /// directive is used or it is an error.\n    char *SecureLogFile;\n    /// The stream that gets written to for the .secure_log_unique directive.\n    std::unique_ptr<raw_fd_ostream> SecureLog;\n    /// Boolean toggled when .secure_log_unique / .secure_log_reset is seen to\n    /// catch errors if .secure_log_unique appears twice without\n    /// .secure_log_reset appearing between them.\n    bool SecureLogUsed = false;\n\n    /// The compilation directory to use for DW_AT_comp_dir.\n    SmallString<128> CompilationDir;\n\n    /// Prefix replacement map for source file information.\n    std::map<const std::string, const std::string> DebugPrefixMap;\n\n    /// The main file name if passed in explicitly.\n    std::string MainFileName;\n\n    /// The dwarf file and directory tables from the dwarf .file directive.\n    /// We now emit a line table for each compile unit. To reduce the prologue\n    /// size of each line table, the files and directories used by each compile\n    /// unit are separated.\n    std::map<unsigned, MCDwarfLineTable> MCDwarfLineTablesCUMap;\n\n    /// The current dwarf line information from the last dwarf .loc directive.\n    MCDwarfLoc CurrentDwarfLoc;\n    bool DwarfLocSeen = false;\n\n    /// Generate dwarf debugging info for assembly source files.\n    bool GenDwarfForAssembly = false;\n\n    /// The current dwarf file number when generate dwarf debugging info for\n    /// assembly source files.\n    unsigned GenDwarfFileNumber = 0;\n\n    /// Sections for generating the .debug_ranges and .debug_aranges sections.\n    SetVector<MCSection *> SectionsForRanges;\n\n    /// The information gathered from labels that will have dwarf label\n    /// entries when generating dwarf assembly source files.\n    std::vector<MCGenDwarfLabelEntry> MCGenDwarfLabelEntries;\n\n    /// The string to embed in the debug information for the compile unit, if\n    /// non-empty.\n    StringRef DwarfDebugFlags;\n\n    /// The string to embed in as the dwarf AT_producer for the compile unit, if\n    /// non-empty.\n    StringRef DwarfDebugProducer;\n\n    /// The maximum version of dwarf that we should emit.\n    uint16_t DwarfVersion = 4;\n\n    /// The format of dwarf that we emit.\n    dwarf::DwarfFormat DwarfFormat = dwarf::DWARF32;\n\n    /// Honor temporary labels, this is useful for debugging semantic\n    /// differences between temporary and non-temporary labels (primarily on\n    /// Darwin).\n    bool AllowTemporaryLabels = true;\n    bool UseNamesOnTempLabels = false;\n\n    /// The Compile Unit ID that we are currently processing.\n    unsigned DwarfCompileUnitID = 0;\n\n    /// A collection of MCPseudoProbe in the current module\n    MCPseudoProbeTable PseudoProbeTable;\n\n    // Sections are differentiated by the quadruple (section_name, group_name,\n    // unique_id, link_to_symbol_name). Sections sharing the same quadruple are\n    // combined into one section.\n    struct ELFSectionKey {\n      std::string SectionName;\n      StringRef GroupName;\n      StringRef LinkedToName;\n      unsigned UniqueID;\n\n      ELFSectionKey(StringRef SectionName, StringRef GroupName,\n                    StringRef LinkedToName, unsigned UniqueID)\n          : SectionName(SectionName), GroupName(GroupName),\n            LinkedToName(LinkedToName), UniqueID(UniqueID) {}\n\n      bool operator<(const ELFSectionKey &Other) const {\n        if (SectionName != Other.SectionName)\n          return SectionName < Other.SectionName;\n        if (GroupName != Other.GroupName)\n          return GroupName < Other.GroupName;\n        if (int O = LinkedToName.compare(Other.LinkedToName))\n          return O < 0;\n        return UniqueID < Other.UniqueID;\n      }\n    };\n\n    struct COFFSectionKey {\n      std::string SectionName;\n      StringRef GroupName;\n      int SelectionKey;\n      unsigned UniqueID;\n\n      COFFSectionKey(StringRef SectionName, StringRef GroupName,\n                     int SelectionKey, unsigned UniqueID)\n          : SectionName(SectionName), GroupName(GroupName),\n            SelectionKey(SelectionKey), UniqueID(UniqueID) {}\n\n      bool operator<(const COFFSectionKey &Other) const {\n        if (SectionName != Other.SectionName)\n          return SectionName < Other.SectionName;\n        if (GroupName != Other.GroupName)\n          return GroupName < Other.GroupName;\n        if (SelectionKey != Other.SelectionKey)\n          return SelectionKey < Other.SelectionKey;\n        return UniqueID < Other.UniqueID;\n      }\n    };\n\n    struct WasmSectionKey {\n      std::string SectionName;\n      StringRef GroupName;\n      unsigned UniqueID;\n\n      WasmSectionKey(StringRef SectionName, StringRef GroupName,\n                     unsigned UniqueID)\n          : SectionName(SectionName), GroupName(GroupName), UniqueID(UniqueID) {\n      }\n\n      bool operator<(const WasmSectionKey &Other) const {\n        if (SectionName != Other.SectionName)\n          return SectionName < Other.SectionName;\n        if (GroupName != Other.GroupName)\n          return GroupName < Other.GroupName;\n        return UniqueID < Other.UniqueID;\n      }\n    };\n\n    struct XCOFFSectionKey {\n      // Section name.\n      std::string SectionName;\n      // Section property.\n      // For csect section, it is storage mapping class.\n      // For debug section, it is section type flags.\n      union {\n        XCOFF::StorageMappingClass MappingClass;\n        XCOFF::DwarfSectionSubtypeFlags DwarfSubtypeFlags;\n      };\n      bool IsCsect;\n\n      XCOFFSectionKey(StringRef SectionName,\n                      XCOFF::StorageMappingClass MappingClass)\n          : SectionName(SectionName), MappingClass(MappingClass),\n            IsCsect(true) {}\n\n      XCOFFSectionKey(StringRef SectionName,\n                      XCOFF::DwarfSectionSubtypeFlags DwarfSubtypeFlags)\n          : SectionName(SectionName), DwarfSubtypeFlags(DwarfSubtypeFlags),\n            IsCsect(false) {}\n\n      bool operator<(const XCOFFSectionKey &Other) const {\n        if (IsCsect && Other.IsCsect)\n          return std::tie(SectionName, MappingClass) <\n                 std::tie(Other.SectionName, Other.MappingClass);\n        if (IsCsect != Other.IsCsect)\n          return IsCsect;\n        return std::tie(SectionName, DwarfSubtypeFlags) <\n               std::tie(Other.SectionName, Other.DwarfSubtypeFlags);\n      }\n    };\n\n    StringMap<MCSectionMachO *> MachOUniquingMap;\n    std::map<ELFSectionKey, MCSectionELF *> ELFUniquingMap;\n    std::map<COFFSectionKey, MCSectionCOFF *> COFFUniquingMap;\n    std::map<WasmSectionKey, MCSectionWasm *> WasmUniquingMap;\n    std::map<XCOFFSectionKey, MCSectionXCOFF *> XCOFFUniquingMap;\n    StringMap<bool> RelSecNames;\n\n    SpecificBumpPtrAllocator<MCSubtargetInfo> MCSubtargetAllocator;\n\n    /// Do automatic reset in destructor\n    bool AutoReset;\n\n    MCTargetOptions const *TargetOptions;\n\n    bool HadError = false;\n\n    void reportCommon(SMLoc Loc,\n                      std::function<void(SMDiagnostic &, const SourceMgr *)>);\n\n    MCSymbol *createSymbolImpl(const StringMapEntry<bool> *Name,\n                               bool CanBeUnnamed);\n    MCSymbol *createSymbol(StringRef Name, bool AlwaysAddSuffix,\n                           bool IsTemporary);\n\n    MCSymbol *getOrCreateDirectionalLocalSymbol(unsigned LocalLabelVal,\n                                                unsigned Instance);\n\n    MCSectionELF *createELFSectionImpl(StringRef Section, unsigned Type,\n                                       unsigned Flags, SectionKind K,\n                                       unsigned EntrySize,\n                                       const MCSymbolELF *Group, bool IsComdat,\n                                       unsigned UniqueID,\n                                       const MCSymbolELF *LinkedToSym);\n\n    MCSymbolXCOFF *createXCOFFSymbolImpl(const StringMapEntry<bool> *Name,\n                                         bool IsTemporary);\n\n    /// Map of currently defined macros.\n    StringMap<MCAsmMacro> MacroMap;\n\n    struct ELFEntrySizeKey {\n      std::string SectionName;\n      unsigned Flags;\n      unsigned EntrySize;\n\n      ELFEntrySizeKey(StringRef SectionName, unsigned Flags, unsigned EntrySize)\n          : SectionName(SectionName), Flags(Flags), EntrySize(EntrySize) {}\n\n      bool operator<(const ELFEntrySizeKey &Other) const {\n        if (SectionName != Other.SectionName)\n          return SectionName < Other.SectionName;\n        if ((Flags & ELF::SHF_STRINGS) != (Other.Flags & ELF::SHF_STRINGS))\n          return Other.Flags & ELF::SHF_STRINGS;\n        return EntrySize < Other.EntrySize;\n      }\n    };\n\n    // Symbols must be assigned to a section with a compatible entry\n    // size. This map is used to assign unique IDs to sections to\n    // distinguish between sections with identical names but incompatible entry\n    // sizes. This can occur when a symbol is explicitly assigned to a\n    // section, e.g. via __attribute__((section(\"myname\"))).\n    std::map<ELFEntrySizeKey, unsigned> ELFEntrySizeMap;\n\n    // This set is used to record the generic mergeable section names seen.\n    // These are sections that are created as mergeable e.g. .debug_str. We need\n    // to avoid assigning non-mergeable symbols to these sections. It is used\n    // to prevent non-mergeable symbols being explicitly assigned  to mergeable\n    // sections (e.g. via _attribute_((section(\"myname\")))).\n    DenseSet<StringRef> ELFSeenGenericMergeableSections;\n\n  public:\n    explicit MCContext(const MCAsmInfo *MAI, const MCRegisterInfo *MRI,\n                       const MCObjectFileInfo *MOFI,\n                       const SourceMgr *Mgr = nullptr,\n                       MCTargetOptions const *TargetOpts = nullptr,\n                       bool DoAutoReset = true);\n    MCContext(const MCContext &) = delete;\n    MCContext &operator=(const MCContext &) = delete;\n    ~MCContext();\n\n    const SourceMgr *getSourceManager() const { return SrcMgr; }\n\n    void initInlineSourceManager();\n    SourceMgr *getInlineSourceManager() {\n      return InlineSrcMgr.get();\n    }\n    std::vector<const MDNode *> &getLocInfos() { return LocInfos; }\n    void setDiagnosticHandler(DiagHandlerTy DiagHandler) {\n      this->DiagHandler = DiagHandler;\n    }\n\n    const MCAsmInfo *getAsmInfo() const { return MAI; }\n\n    const MCRegisterInfo *getRegisterInfo() const { return MRI; }\n\n    const MCObjectFileInfo *getObjectFileInfo() const { return MOFI; }\n\n    CodeViewContext &getCVContext();\n\n    void setAllowTemporaryLabels(bool Value) { AllowTemporaryLabels = Value; }\n    void setUseNamesOnTempLabels(bool Value) { UseNamesOnTempLabels = Value; }\n\n    /// \\name Module Lifetime Management\n    /// @{\n\n    /// reset - return object to right after construction state to prepare\n    /// to process a new module\n    void reset();\n\n    /// @}\n\n    /// \\name McInst Management\n\n    /// Create and return a new MC instruction.\n    MCInst *createMCInst();\n\n    /// \\name Symbol Management\n    /// @{\n\n    /// Create and return a new linker temporary symbol with a unique but\n    /// unspecified name.\n    MCSymbol *createLinkerPrivateTempSymbol();\n\n    /// Create a temporary symbol with a unique name. The name will be omitted\n    /// in the symbol table if UseNamesOnTempLabels is false (default except\n    /// MCAsmStreamer). The overload without Name uses an unspecified name.\n    MCSymbol *createTempSymbol();\n    MCSymbol *createTempSymbol(const Twine &Name, bool AlwaysAddSuffix = true);\n\n    /// Create a temporary symbol with a unique name whose name cannot be\n    /// omitted in the symbol table. This is rarely used.\n    MCSymbol *createNamedTempSymbol();\n    MCSymbol *createNamedTempSymbol(const Twine &Name);\n\n    /// Create the definition of a directional local symbol for numbered label\n    /// (used for \"1:\" definitions).\n    MCSymbol *createDirectionalLocalSymbol(unsigned LocalLabelVal);\n\n    /// Create and return a directional local symbol for numbered label (used\n    /// for \"1b\" or 1f\" references).\n    MCSymbol *getDirectionalLocalSymbol(unsigned LocalLabelVal, bool Before);\n\n    /// Lookup the symbol inside with the specified \\p Name.  If it exists,\n    /// return it.  If not, create a forward reference and return it.\n    ///\n    /// \\param Name - The symbol name, which must be unique across all symbols.\n    MCSymbol *getOrCreateSymbol(const Twine &Name);\n\n    /// Gets a symbol that will be defined to the final stack offset of a local\n    /// variable after codegen.\n    ///\n    /// \\param Idx - The index of a local variable passed to \\@llvm.localescape.\n    MCSymbol *getOrCreateFrameAllocSymbol(StringRef FuncName, unsigned Idx);\n\n    MCSymbol *getOrCreateParentFrameOffsetSymbol(StringRef FuncName);\n\n    MCSymbol *getOrCreateLSDASymbol(StringRef FuncName);\n\n    /// Get the symbol for \\p Name, or null.\n    MCSymbol *lookupSymbol(const Twine &Name) const;\n\n    /// Set value for a symbol.\n    void setSymbolValue(MCStreamer &Streamer, StringRef Sym, uint64_t Val);\n\n    /// getSymbols - Get a reference for the symbol table for clients that\n    /// want to, for example, iterate over all symbols. 'const' because we\n    /// still want any modifications to the table itself to use the MCContext\n    /// APIs.\n    const SymbolTable &getSymbols() const { return Symbols; }\n\n    /// isInlineAsmLabel - Return true if the name is a label referenced in\n    /// inline assembly.\n    MCSymbol *getInlineAsmLabel(StringRef Name) const {\n      return InlineAsmUsedLabelNames.lookup(Name);\n    }\n\n    /// registerInlineAsmLabel - Records that the name is a label referenced in\n    /// inline assembly.\n    void registerInlineAsmLabel(MCSymbol *Sym);\n\n    /// @}\n\n    /// \\name Section Management\n    /// @{\n\n    enum : unsigned {\n      /// Pass this value as the UniqueID during section creation to get the\n      /// generic section with the given name and characteristics. The usual\n      /// sections such as .text use this ID.\n      GenericSectionID = ~0U\n    };\n\n    /// Return the MCSection for the specified mach-o section.  This requires\n    /// the operands to be valid.\n    MCSectionMachO *getMachOSection(StringRef Segment, StringRef Section,\n                                    unsigned TypeAndAttributes,\n                                    unsigned Reserved2, SectionKind K,\n                                    const char *BeginSymName = nullptr);\n\n    MCSectionMachO *getMachOSection(StringRef Segment, StringRef Section,\n                                    unsigned TypeAndAttributes, SectionKind K,\n                                    const char *BeginSymName = nullptr) {\n      return getMachOSection(Segment, Section, TypeAndAttributes, 0, K,\n                             BeginSymName);\n    }\n\n    MCSectionELF *getELFSection(const Twine &Section, unsigned Type,\n                                unsigned Flags) {\n      return getELFSection(Section, Type, Flags, 0, \"\", false);\n    }\n\n    MCSectionELF *getELFSection(const Twine &Section, unsigned Type,\n                                unsigned Flags, unsigned EntrySize) {\n      return getELFSection(Section, Type, Flags, EntrySize, \"\", false,\n                           MCSection::NonUniqueID, nullptr);\n    }\n\n    MCSectionELF *getELFSection(const Twine &Section, unsigned Type,\n                                unsigned Flags, unsigned EntrySize,\n                                const Twine &Group, bool IsComdat) {\n      return getELFSection(Section, Type, Flags, EntrySize, Group, IsComdat,\n                           MCSection::NonUniqueID, nullptr);\n    }\n\n    MCSectionELF *getELFSection(const Twine &Section, unsigned Type,\n                                unsigned Flags, unsigned EntrySize,\n                                const Twine &Group, bool IsComdat,\n                                unsigned UniqueID,\n                                const MCSymbolELF *LinkedToSym);\n\n    MCSectionELF *getELFSection(const Twine &Section, unsigned Type,\n                                unsigned Flags, unsigned EntrySize,\n                                const MCSymbolELF *Group, bool IsComdat,\n                                unsigned UniqueID,\n                                const MCSymbolELF *LinkedToSym);\n\n    /// Get a section with the provided group identifier. This section is\n    /// named by concatenating \\p Prefix with '.' then \\p Suffix. The \\p Type\n    /// describes the type of the section and \\p Flags are used to further\n    /// configure this named section.\n    MCSectionELF *getELFNamedSection(const Twine &Prefix, const Twine &Suffix,\n                                     unsigned Type, unsigned Flags,\n                                     unsigned EntrySize = 0);\n\n    MCSectionELF *createELFRelSection(const Twine &Name, unsigned Type,\n                                      unsigned Flags, unsigned EntrySize,\n                                      const MCSymbolELF *Group,\n                                      const MCSectionELF *RelInfoSection);\n\n    void renameELFSection(MCSectionELF *Section, StringRef Name);\n\n    MCSectionELF *createELFGroupSection(const MCSymbolELF *Group,\n                                        bool IsComdat);\n\n    void recordELFMergeableSectionInfo(StringRef SectionName, unsigned Flags,\n                                       unsigned UniqueID, unsigned EntrySize);\n\n    bool isELFImplicitMergeableSectionNamePrefix(StringRef Name);\n\n    bool isELFGenericMergeableSection(StringRef Name);\n\n    Optional<unsigned> getELFUniqueIDForEntsize(StringRef SectionName,\n                                                unsigned Flags,\n                                                unsigned EntrySize);\n\n    MCSectionCOFF *getCOFFSection(StringRef Section, unsigned Characteristics,\n                                  SectionKind Kind, StringRef COMDATSymName,\n                                  int Selection,\n                                  unsigned UniqueID = GenericSectionID,\n                                  const char *BeginSymName = nullptr);\n\n    MCSectionCOFF *getCOFFSection(StringRef Section, unsigned Characteristics,\n                                  SectionKind Kind,\n                                  const char *BeginSymName = nullptr);\n\n    /// Gets or creates a section equivalent to Sec that is associated with the\n    /// section containing KeySym. For example, to create a debug info section\n    /// associated with an inline function, pass the normal debug info section\n    /// as Sec and the function symbol as KeySym.\n    MCSectionCOFF *\n    getAssociativeCOFFSection(MCSectionCOFF *Sec, const MCSymbol *KeySym,\n                              unsigned UniqueID = GenericSectionID);\n\n    MCSectionWasm *getWasmSection(const Twine &Section, SectionKind K) {\n      return getWasmSection(Section, K, nullptr);\n    }\n\n    MCSectionWasm *getWasmSection(const Twine &Section, SectionKind K,\n                                  const char *BeginSymName) {\n      return getWasmSection(Section, K, \"\", ~0, BeginSymName);\n    }\n\n    MCSectionWasm *getWasmSection(const Twine &Section, SectionKind K,\n                                  const Twine &Group, unsigned UniqueID) {\n      return getWasmSection(Section, K, Group, UniqueID, nullptr);\n    }\n\n    MCSectionWasm *getWasmSection(const Twine &Section, SectionKind K,\n                                  const Twine &Group, unsigned UniqueID,\n                                  const char *BeginSymName);\n\n    MCSectionWasm *getWasmSection(const Twine &Section, SectionKind K,\n                                  const MCSymbolWasm *Group, unsigned UniqueID,\n                                  const char *BeginSymName);\n\n    MCSectionXCOFF *getXCOFFSection(\n        StringRef Section, SectionKind K,\n        Optional<XCOFF::CsectProperties> CsectProp = None,\n        bool MultiSymbolsAllowed = false, const char *BeginSymName = nullptr,\n        Optional<XCOFF::DwarfSectionSubtypeFlags> DwarfSubtypeFlags = None);\n\n    // Create and save a copy of STI and return a reference to the copy.\n    MCSubtargetInfo &getSubtargetCopy(const MCSubtargetInfo &STI);\n\n    /// @}\n\n    /// \\name Dwarf Management\n    /// @{\n\n    /// Get the compilation directory for DW_AT_comp_dir\n    /// The compilation directory should be set with \\c setCompilationDir before\n    /// calling this function. If it is unset, an empty string will be returned.\n    StringRef getCompilationDir() const { return CompilationDir; }\n\n    /// Set the compilation directory for DW_AT_comp_dir\n    void setCompilationDir(StringRef S) { CompilationDir = S.str(); }\n\n    /// Add an entry to the debug prefix map.\n    void addDebugPrefixMapEntry(const std::string &From, const std::string &To);\n\n    // Remaps all debug directory paths in-place as per the debug prefix map.\n    void RemapDebugPaths();\n\n    /// Get the main file name for use in error messages and debug\n    /// info. This can be set to ensure we've got the correct file name\n    /// after preprocessing or for -save-temps.\n    const std::string &getMainFileName() const { return MainFileName; }\n\n    /// Set the main file name and override the default.\n    void setMainFileName(StringRef S) { MainFileName = std::string(S); }\n\n    /// Creates an entry in the dwarf file and directory tables.\n    Expected<unsigned> getDwarfFile(StringRef Directory, StringRef FileName,\n                                    unsigned FileNumber,\n                                    Optional<MD5::MD5Result> Checksum,\n                                    Optional<StringRef> Source, unsigned CUID);\n\n    bool isValidDwarfFileNumber(unsigned FileNumber, unsigned CUID = 0);\n\n    const std::map<unsigned, MCDwarfLineTable> &getMCDwarfLineTables() const {\n      return MCDwarfLineTablesCUMap;\n    }\n\n    MCDwarfLineTable &getMCDwarfLineTable(unsigned CUID) {\n      return MCDwarfLineTablesCUMap[CUID];\n    }\n\n    const MCDwarfLineTable &getMCDwarfLineTable(unsigned CUID) const {\n      auto I = MCDwarfLineTablesCUMap.find(CUID);\n      assert(I != MCDwarfLineTablesCUMap.end());\n      return I->second;\n    }\n\n    const SmallVectorImpl<MCDwarfFile> &getMCDwarfFiles(unsigned CUID = 0) {\n      return getMCDwarfLineTable(CUID).getMCDwarfFiles();\n    }\n\n    const SmallVectorImpl<std::string> &getMCDwarfDirs(unsigned CUID = 0) {\n      return getMCDwarfLineTable(CUID).getMCDwarfDirs();\n    }\n\n    unsigned getDwarfCompileUnitID() { return DwarfCompileUnitID; }\n\n    void setDwarfCompileUnitID(unsigned CUIndex) {\n      DwarfCompileUnitID = CUIndex;\n    }\n\n    /// Specifies the \"root\" file and directory of the compilation unit.\n    /// These are \"file 0\" and \"directory 0\" in DWARF v5.\n    void setMCLineTableRootFile(unsigned CUID, StringRef CompilationDir,\n                                StringRef Filename,\n                                Optional<MD5::MD5Result> Checksum,\n                                Optional<StringRef> Source) {\n      getMCDwarfLineTable(CUID).setRootFile(CompilationDir, Filename, Checksum,\n                                            Source);\n    }\n\n    /// Reports whether MD5 checksum usage is consistent (all-or-none).\n    bool isDwarfMD5UsageConsistent(unsigned CUID) const {\n      return getMCDwarfLineTable(CUID).isMD5UsageConsistent();\n    }\n\n    /// Saves the information from the currently parsed dwarf .loc directive\n    /// and sets DwarfLocSeen.  When the next instruction is assembled an entry\n    /// in the line number table with this information and the address of the\n    /// instruction will be created.\n    void setCurrentDwarfLoc(unsigned FileNum, unsigned Line, unsigned Column,\n                            unsigned Flags, unsigned Isa,\n                            unsigned Discriminator) {\n      CurrentDwarfLoc.setFileNum(FileNum);\n      CurrentDwarfLoc.setLine(Line);\n      CurrentDwarfLoc.setColumn(Column);\n      CurrentDwarfLoc.setFlags(Flags);\n      CurrentDwarfLoc.setIsa(Isa);\n      CurrentDwarfLoc.setDiscriminator(Discriminator);\n      DwarfLocSeen = true;\n    }\n\n    void clearDwarfLocSeen() { DwarfLocSeen = false; }\n\n    bool getDwarfLocSeen() { return DwarfLocSeen; }\n    const MCDwarfLoc &getCurrentDwarfLoc() { return CurrentDwarfLoc; }\n\n    bool getGenDwarfForAssembly() { return GenDwarfForAssembly; }\n    void setGenDwarfForAssembly(bool Value) { GenDwarfForAssembly = Value; }\n    unsigned getGenDwarfFileNumber() { return GenDwarfFileNumber; }\n\n    void setGenDwarfFileNumber(unsigned FileNumber) {\n      GenDwarfFileNumber = FileNumber;\n    }\n\n    /// Specifies information about the \"root file\" for assembler clients\n    /// (e.g., llvm-mc). Assumes compilation dir etc. have been set up.\n    void setGenDwarfRootFile(StringRef FileName, StringRef Buffer);\n\n    const SetVector<MCSection *> &getGenDwarfSectionSyms() {\n      return SectionsForRanges;\n    }\n\n    bool addGenDwarfSection(MCSection *Sec) {\n      return SectionsForRanges.insert(Sec);\n    }\n\n    void finalizeDwarfSections(MCStreamer &MCOS);\n\n    const std::vector<MCGenDwarfLabelEntry> &getMCGenDwarfLabelEntries() const {\n      return MCGenDwarfLabelEntries;\n    }\n\n    void addMCGenDwarfLabelEntry(const MCGenDwarfLabelEntry &E) {\n      MCGenDwarfLabelEntries.push_back(E);\n    }\n\n    void setDwarfDebugFlags(StringRef S) { DwarfDebugFlags = S; }\n    StringRef getDwarfDebugFlags() { return DwarfDebugFlags; }\n\n    void setDwarfDebugProducer(StringRef S) { DwarfDebugProducer = S; }\n    StringRef getDwarfDebugProducer() { return DwarfDebugProducer; }\n\n    void setDwarfFormat(dwarf::DwarfFormat f) { DwarfFormat = f; }\n    dwarf::DwarfFormat getDwarfFormat() const { return DwarfFormat; }\n\n    void setDwarfVersion(uint16_t v) { DwarfVersion = v; }\n    uint16_t getDwarfVersion() const { return DwarfVersion; }\n\n    /// @}\n\n    char *getSecureLogFile() { return SecureLogFile; }\n    raw_fd_ostream *getSecureLog() { return SecureLog.get(); }\n\n    void setSecureLog(std::unique_ptr<raw_fd_ostream> Value) {\n      SecureLog = std::move(Value);\n    }\n\n    bool getSecureLogUsed() { return SecureLogUsed; }\n    void setSecureLogUsed(bool Value) { SecureLogUsed = Value; }\n\n    void *allocate(unsigned Size, unsigned Align = 8) {\n      return Allocator.Allocate(Size, Align);\n    }\n\n    void deallocate(void *Ptr) {}\n\n    bool hadError() { return HadError; }\n    void diagnose(const SMDiagnostic &SMD);\n    void reportError(SMLoc L, const Twine &Msg);\n    void reportWarning(SMLoc L, const Twine &Msg);\n    // Unrecoverable error has occurred. Display the best diagnostic we can\n    // and bail via exit(1). For now, most MC backend errors are unrecoverable.\n    // FIXME: We should really do something about that.\n    LLVM_ATTRIBUTE_NORETURN void reportFatalError(SMLoc L, const Twine &Msg);\n\n    const MCAsmMacro *lookupMacro(StringRef Name) {\n      StringMap<MCAsmMacro>::iterator I = MacroMap.find(Name);\n      return (I == MacroMap.end()) ? nullptr : &I->getValue();\n    }\n\n    void defineMacro(StringRef Name, MCAsmMacro Macro) {\n      MacroMap.insert(std::make_pair(Name, std::move(Macro)));\n    }\n\n    void undefineMacro(StringRef Name) { MacroMap.erase(Name); }\n\n    MCPseudoProbeTable &getMCPseudoProbeTable() { return PseudoProbeTable; }\n  };\n\n} // end namespace llvm\n\n// operator new and delete aren't allowed inside namespaces.\n// The throw specifications are mandated by the standard.\n/// Placement new for using the MCContext's allocator.\n///\n/// This placement form of operator new uses the MCContext's allocator for\n/// obtaining memory. It is a non-throwing new, which means that it returns\n/// null on error. (If that is what the allocator does. The current does, so if\n/// this ever changes, this operator will have to be changed, too.)\n/// Usage looks like this (assuming there's an MCContext 'Context' in scope):\n/// \\code\n/// // Default alignment (8)\n/// IntegerLiteral *Ex = new (Context) IntegerLiteral(arguments);\n/// // Specific alignment\n/// IntegerLiteral *Ex2 = new (Context, 4) IntegerLiteral(arguments);\n/// \\endcode\n/// Please note that you cannot use delete on the pointer; it must be\n/// deallocated using an explicit destructor call followed by\n/// \\c Context.Deallocate(Ptr).\n///\n/// \\param Bytes The number of bytes to allocate. Calculated by the compiler.\n/// \\param C The MCContext that provides the allocator.\n/// \\param Alignment The alignment of the allocated memory (if the underlying\n///                  allocator supports it).\n/// \\return The allocated memory. Could be NULL.\ninline void *operator new(size_t Bytes, llvm::MCContext &C,\n                          size_t Alignment = 8) noexcept {\n  return C.allocate(Bytes, Alignment);\n}\n/// Placement delete companion to the new above.\n///\n/// This operator is just a companion to the new above. There is no way of\n/// invoking it directly; see the new operator for more details. This operator\n/// is called implicitly by the compiler if a placement new expression using\n/// the MCContext throws in the object constructor.\ninline void operator delete(void *Ptr, llvm::MCContext &C, size_t) noexcept {\n  C.deallocate(Ptr);\n}\n\n/// This placement form of operator new[] uses the MCContext's allocator for\n/// obtaining memory. It is a non-throwing new[], which means that it returns\n/// null on error.\n/// Usage looks like this (assuming there's an MCContext 'Context' in scope):\n/// \\code\n/// // Default alignment (8)\n/// char *data = new (Context) char[10];\n/// // Specific alignment\n/// char *data = new (Context, 4) char[10];\n/// \\endcode\n/// Please note that you cannot use delete on the pointer; it must be\n/// deallocated using an explicit destructor call followed by\n/// \\c Context.Deallocate(Ptr).\n///\n/// \\param Bytes The number of bytes to allocate. Calculated by the compiler.\n/// \\param C The MCContext that provides the allocator.\n/// \\param Alignment The alignment of the allocated memory (if the underlying\n///                  allocator supports it).\n/// \\return The allocated memory. Could be NULL.\ninline void *operator new[](size_t Bytes, llvm::MCContext &C,\n                            size_t Alignment = 8) noexcept {\n  return C.allocate(Bytes, Alignment);\n}\n\n/// Placement delete[] companion to the new[] above.\n///\n/// This operator is just a companion to the new[] above. There is no way of\n/// invoking it directly; see the new[] operator for more details. This operator\n/// is called implicitly by the compiler if a placement new[] expression using\n/// the MCContext throws in the object constructor.\ninline void operator delete[](void *Ptr, llvm::MCContext &C) noexcept {\n  C.deallocate(Ptr);\n}\n\n#endif // LLVM_MC_MCCONTEXT_H\n"}, "75": {"id": 75, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TargetRegistry.h", "content": "//===- Support/TargetRegistry.h - Target Registration -----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file exposes the TargetRegistry interface, which tools can use to access\n// the appropriate target specific classes (TargetMachine, AsmPrinter, etc.)\n// which have been registered.\n//\n// Target specific class implementations should register themselves using the\n// appropriate TargetRegistry interfaces.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_TARGETREGISTRY_H\n#define LLVM_SUPPORT_TARGETREGISTRY_H\n\n#include \"llvm-c/DisassemblerTypes.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/CodeGen.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/FormattedStream.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <memory>\n#include <string>\n\nnamespace llvm {\n\nclass AsmPrinter;\nclass MCAsmBackend;\nclass MCAsmInfo;\nclass MCAsmParser;\nclass MCCodeEmitter;\nclass MCContext;\nclass MCDisassembler;\nclass MCInstPrinter;\nclass MCInstrAnalysis;\nclass MCInstrInfo;\nclass MCObjectWriter;\nclass MCRegisterInfo;\nclass MCRelocationInfo;\nclass MCStreamer;\nclass MCSubtargetInfo;\nclass MCSymbolizer;\nclass MCTargetAsmParser;\nclass MCTargetOptions;\nclass MCTargetStreamer;\nclass raw_ostream;\nclass raw_pwrite_stream;\nclass TargetMachine;\nclass TargetOptions;\n\nMCStreamer *createNullStreamer(MCContext &Ctx);\n// Takes ownership of \\p TAB and \\p CE.\n\n/// Create a machine code streamer which will print out assembly for the native\n/// target, suitable for compiling with a native assembler.\n///\n/// \\param InstPrint - If given, the instruction printer to use. If not given\n/// the MCInst representation will be printed.  This method takes ownership of\n/// InstPrint.\n///\n/// \\param CE - If given, a code emitter to use to show the instruction\n/// encoding inline with the assembly. This method takes ownership of \\p CE.\n///\n/// \\param TAB - If given, a target asm backend to use to show the fixup\n/// information in conjunction with encoding information. This method takes\n/// ownership of \\p TAB.\n///\n/// \\param ShowInst - Whether to show the MCInst representation inline with\n/// the assembly.\nMCStreamer *\ncreateAsmStreamer(MCContext &Ctx, std::unique_ptr<formatted_raw_ostream> OS,\n                  bool isVerboseAsm, bool useDwarfDirectory,\n                  MCInstPrinter *InstPrint, std::unique_ptr<MCCodeEmitter> &&CE,\n                  std::unique_ptr<MCAsmBackend> &&TAB, bool ShowInst);\n\nMCStreamer *createELFStreamer(MCContext &Ctx,\n                              std::unique_ptr<MCAsmBackend> &&TAB,\n                              std::unique_ptr<MCObjectWriter> &&OW,\n                              std::unique_ptr<MCCodeEmitter> &&CE,\n                              bool RelaxAll);\nMCStreamer *createMachOStreamer(MCContext &Ctx,\n                                std::unique_ptr<MCAsmBackend> &&TAB,\n                                std::unique_ptr<MCObjectWriter> &&OW,\n                                std::unique_ptr<MCCodeEmitter> &&CE,\n                                bool RelaxAll, bool DWARFMustBeAtTheEnd,\n                                bool LabelSections = false);\nMCStreamer *createWasmStreamer(MCContext &Ctx,\n                               std::unique_ptr<MCAsmBackend> &&TAB,\n                               std::unique_ptr<MCObjectWriter> &&OW,\n                               std::unique_ptr<MCCodeEmitter> &&CE,\n                               bool RelaxAll);\nMCStreamer *createXCOFFStreamer(MCContext &Ctx,\n                                std::unique_ptr<MCAsmBackend> &&TAB,\n                                std::unique_ptr<MCObjectWriter> &&OW,\n                                std::unique_ptr<MCCodeEmitter> &&CE,\n                                bool RelaxAll);\n\nMCRelocationInfo *createMCRelocationInfo(const Triple &TT, MCContext &Ctx);\n\nMCSymbolizer *createMCSymbolizer(const Triple &TT, LLVMOpInfoCallback GetOpInfo,\n                                 LLVMSymbolLookupCallback SymbolLookUp,\n                                 void *DisInfo, MCContext *Ctx,\n                                 std::unique_ptr<MCRelocationInfo> &&RelInfo);\n\n/// Target - Wrapper for Target specific information.\n///\n/// For registration purposes, this is a POD type so that targets can be\n/// registered without the use of static constructors.\n///\n/// Targets should implement a single global instance of this class (which\n/// will be zero initialized), and pass that instance to the TargetRegistry as\n/// part of their initialization.\nclass Target {\npublic:\n  friend struct TargetRegistry;\n\n  using ArchMatchFnTy = bool (*)(Triple::ArchType Arch);\n\n  using MCAsmInfoCtorFnTy = MCAsmInfo *(*)(const MCRegisterInfo &MRI,\n                                           const Triple &TT,\n                                           const MCTargetOptions &Options);\n  using MCInstrInfoCtorFnTy = MCInstrInfo *(*)();\n  using MCInstrAnalysisCtorFnTy = MCInstrAnalysis *(*)(const MCInstrInfo *Info);\n  using MCRegInfoCtorFnTy = MCRegisterInfo *(*)(const Triple &TT);\n  using MCSubtargetInfoCtorFnTy = MCSubtargetInfo *(*)(const Triple &TT,\n                                                       StringRef CPU,\n                                                       StringRef Features);\n  using TargetMachineCtorTy = TargetMachine\n      *(*)(const Target &T, const Triple &TT, StringRef CPU, StringRef Features,\n           const TargetOptions &Options, Optional<Reloc::Model> RM,\n           Optional<CodeModel::Model> CM, CodeGenOpt::Level OL, bool JIT);\n  // If it weren't for layering issues (this header is in llvm/Support, but\n  // depends on MC?) this should take the Streamer by value rather than rvalue\n  // reference.\n  using AsmPrinterCtorTy = AsmPrinter *(*)(\n      TargetMachine &TM, std::unique_ptr<MCStreamer> &&Streamer);\n  using MCAsmBackendCtorTy = MCAsmBackend *(*)(const Target &T,\n                                               const MCSubtargetInfo &STI,\n                                               const MCRegisterInfo &MRI,\n                                               const MCTargetOptions &Options);\n  using MCAsmParserCtorTy = MCTargetAsmParser *(*)(\n      const MCSubtargetInfo &STI, MCAsmParser &P, const MCInstrInfo &MII,\n      const MCTargetOptions &Options);\n  using MCDisassemblerCtorTy = MCDisassembler *(*)(const Target &T,\n                                                   const MCSubtargetInfo &STI,\n                                                   MCContext &Ctx);\n  using MCInstPrinterCtorTy = MCInstPrinter *(*)(const Triple &T,\n                                                 unsigned SyntaxVariant,\n                                                 const MCAsmInfo &MAI,\n                                                 const MCInstrInfo &MII,\n                                                 const MCRegisterInfo &MRI);\n  using MCCodeEmitterCtorTy = MCCodeEmitter *(*)(const MCInstrInfo &II,\n                                                 const MCRegisterInfo &MRI,\n                                                 MCContext &Ctx);\n  using ELFStreamerCtorTy =\n      MCStreamer *(*)(const Triple &T, MCContext &Ctx,\n                      std::unique_ptr<MCAsmBackend> &&TAB,\n                      std::unique_ptr<MCObjectWriter> &&OW,\n                      std::unique_ptr<MCCodeEmitter> &&Emitter, bool RelaxAll);\n  using MachOStreamerCtorTy =\n      MCStreamer *(*)(MCContext &Ctx, std::unique_ptr<MCAsmBackend> &&TAB,\n                      std::unique_ptr<MCObjectWriter> &&OW,\n                      std::unique_ptr<MCCodeEmitter> &&Emitter, bool RelaxAll,\n                      bool DWARFMustBeAtTheEnd);\n  using COFFStreamerCtorTy =\n      MCStreamer *(*)(MCContext &Ctx, std::unique_ptr<MCAsmBackend> &&TAB,\n                      std::unique_ptr<MCObjectWriter> &&OW,\n                      std::unique_ptr<MCCodeEmitter> &&Emitter, bool RelaxAll,\n                      bool IncrementalLinkerCompatible);\n  using WasmStreamerCtorTy =\n      MCStreamer *(*)(const Triple &T, MCContext &Ctx,\n                      std::unique_ptr<MCAsmBackend> &&TAB,\n                      std::unique_ptr<MCObjectWriter> &&OW,\n                      std::unique_ptr<MCCodeEmitter> &&Emitter, bool RelaxAll);\n  using NullTargetStreamerCtorTy = MCTargetStreamer *(*)(MCStreamer &S);\n  using AsmTargetStreamerCtorTy = MCTargetStreamer *(*)(\n      MCStreamer &S, formatted_raw_ostream &OS, MCInstPrinter *InstPrint,\n      bool IsVerboseAsm);\n  using ObjectTargetStreamerCtorTy = MCTargetStreamer *(*)(\n      MCStreamer &S, const MCSubtargetInfo &STI);\n  using MCRelocationInfoCtorTy = MCRelocationInfo *(*)(const Triple &TT,\n                                                       MCContext &Ctx);\n  using MCSymbolizerCtorTy = MCSymbolizer *(*)(\n      const Triple &TT, LLVMOpInfoCallback GetOpInfo,\n      LLVMSymbolLookupCallback SymbolLookUp, void *DisInfo, MCContext *Ctx,\n      std::unique_ptr<MCRelocationInfo> &&RelInfo);\n\nprivate:\n  /// Next - The next registered target in the linked list, maintained by the\n  /// TargetRegistry.\n  Target *Next;\n\n  /// The target function for checking if an architecture is supported.\n  ArchMatchFnTy ArchMatchFn;\n\n  /// Name - The target name.\n  const char *Name;\n\n  /// ShortDesc - A short description of the target.\n  const char *ShortDesc;\n\n  /// BackendName - The name of the backend implementation. This must match the\n  /// name of the 'def X : Target ...' in TableGen.\n  const char *BackendName;\n\n  /// HasJIT - Whether this target supports the JIT.\n  bool HasJIT;\n\n  /// MCAsmInfoCtorFn - Constructor function for this target's MCAsmInfo, if\n  /// registered.\n  MCAsmInfoCtorFnTy MCAsmInfoCtorFn;\n\n  /// MCInstrInfoCtorFn - Constructor function for this target's MCInstrInfo,\n  /// if registered.\n  MCInstrInfoCtorFnTy MCInstrInfoCtorFn;\n\n  /// MCInstrAnalysisCtorFn - Constructor function for this target's\n  /// MCInstrAnalysis, if registered.\n  MCInstrAnalysisCtorFnTy MCInstrAnalysisCtorFn;\n\n  /// MCRegInfoCtorFn - Constructor function for this target's MCRegisterInfo,\n  /// if registered.\n  MCRegInfoCtorFnTy MCRegInfoCtorFn;\n\n  /// MCSubtargetInfoCtorFn - Constructor function for this target's\n  /// MCSubtargetInfo, if registered.\n  MCSubtargetInfoCtorFnTy MCSubtargetInfoCtorFn;\n\n  /// TargetMachineCtorFn - Construction function for this target's\n  /// TargetMachine, if registered.\n  TargetMachineCtorTy TargetMachineCtorFn;\n\n  /// MCAsmBackendCtorFn - Construction function for this target's\n  /// MCAsmBackend, if registered.\n  MCAsmBackendCtorTy MCAsmBackendCtorFn;\n\n  /// MCAsmParserCtorFn - Construction function for this target's\n  /// MCTargetAsmParser, if registered.\n  MCAsmParserCtorTy MCAsmParserCtorFn;\n\n  /// AsmPrinterCtorFn - Construction function for this target's AsmPrinter,\n  /// if registered.\n  AsmPrinterCtorTy AsmPrinterCtorFn;\n\n  /// MCDisassemblerCtorFn - Construction function for this target's\n  /// MCDisassembler, if registered.\n  MCDisassemblerCtorTy MCDisassemblerCtorFn;\n\n  /// MCInstPrinterCtorFn - Construction function for this target's\n  /// MCInstPrinter, if registered.\n  MCInstPrinterCtorTy MCInstPrinterCtorFn;\n\n  /// MCCodeEmitterCtorFn - Construction function for this target's\n  /// CodeEmitter, if registered.\n  MCCodeEmitterCtorTy MCCodeEmitterCtorFn;\n\n  // Construction functions for the various object formats, if registered.\n  COFFStreamerCtorTy COFFStreamerCtorFn = nullptr;\n  MachOStreamerCtorTy MachOStreamerCtorFn = nullptr;\n  ELFStreamerCtorTy ELFStreamerCtorFn = nullptr;\n  WasmStreamerCtorTy WasmStreamerCtorFn = nullptr;\n\n  /// Construction function for this target's null TargetStreamer, if\n  /// registered (default = nullptr).\n  NullTargetStreamerCtorTy NullTargetStreamerCtorFn = nullptr;\n\n  /// Construction function for this target's asm TargetStreamer, if\n  /// registered (default = nullptr).\n  AsmTargetStreamerCtorTy AsmTargetStreamerCtorFn = nullptr;\n\n  /// Construction function for this target's obj TargetStreamer, if\n  /// registered (default = nullptr).\n  ObjectTargetStreamerCtorTy ObjectTargetStreamerCtorFn = nullptr;\n\n  /// MCRelocationInfoCtorFn - Construction function for this target's\n  /// MCRelocationInfo, if registered (default = llvm::createMCRelocationInfo)\n  MCRelocationInfoCtorTy MCRelocationInfoCtorFn = nullptr;\n\n  /// MCSymbolizerCtorFn - Construction function for this target's\n  /// MCSymbolizer, if registered (default = llvm::createMCSymbolizer)\n  MCSymbolizerCtorTy MCSymbolizerCtorFn = nullptr;\n\npublic:\n  Target() = default;\n\n  /// @name Target Information\n  /// @{\n\n  // getNext - Return the next registered target.\n  const Target *getNext() const { return Next; }\n\n  /// getName - Get the target name.\n  const char *getName() const { return Name; }\n\n  /// getShortDescription - Get a short description of the target.\n  const char *getShortDescription() const { return ShortDesc; }\n\n  /// getBackendName - Get the backend name.\n  const char *getBackendName() const { return BackendName; }\n\n  /// @}\n  /// @name Feature Predicates\n  /// @{\n\n  /// hasJIT - Check if this targets supports the just-in-time compilation.\n  bool hasJIT() const { return HasJIT; }\n\n  /// hasTargetMachine - Check if this target supports code generation.\n  bool hasTargetMachine() const { return TargetMachineCtorFn != nullptr; }\n\n  /// hasMCAsmBackend - Check if this target supports .o generation.\n  bool hasMCAsmBackend() const { return MCAsmBackendCtorFn != nullptr; }\n\n  /// hasMCAsmParser - Check if this target supports assembly parsing.\n  bool hasMCAsmParser() const { return MCAsmParserCtorFn != nullptr; }\n\n  /// @}\n  /// @name Feature Constructors\n  /// @{\n\n  /// createMCAsmInfo - Create a MCAsmInfo implementation for the specified\n  /// target triple.\n  ///\n  /// \\param TheTriple This argument is used to determine the target machine\n  /// feature set; it should always be provided. Generally this should be\n  /// either the target triple from the module, or the target triple of the\n  /// host if that does not exist.\n  MCAsmInfo *createMCAsmInfo(const MCRegisterInfo &MRI, StringRef TheTriple,\n                             const MCTargetOptions &Options) const {\n    if (!MCAsmInfoCtorFn)\n      return nullptr;\n    return MCAsmInfoCtorFn(MRI, Triple(TheTriple), Options);\n  }\n\n  /// createMCInstrInfo - Create a MCInstrInfo implementation.\n  ///\n  MCInstrInfo *createMCInstrInfo() const {\n    if (!MCInstrInfoCtorFn)\n      return nullptr;\n    return MCInstrInfoCtorFn();\n  }\n\n  /// createMCInstrAnalysis - Create a MCInstrAnalysis implementation.\n  ///\n  MCInstrAnalysis *createMCInstrAnalysis(const MCInstrInfo *Info) const {\n    if (!MCInstrAnalysisCtorFn)\n      return nullptr;\n    return MCInstrAnalysisCtorFn(Info);\n  }\n\n  /// createMCRegInfo - Create a MCRegisterInfo implementation.\n  ///\n  MCRegisterInfo *createMCRegInfo(StringRef TT) const {\n    if (!MCRegInfoCtorFn)\n      return nullptr;\n    return MCRegInfoCtorFn(Triple(TT));\n  }\n\n  /// createMCSubtargetInfo - Create a MCSubtargetInfo implementation.\n  ///\n  /// \\param TheTriple This argument is used to determine the target machine\n  /// feature set; it should always be provided. Generally this should be\n  /// either the target triple from the module, or the target triple of the\n  /// host if that does not exist.\n  /// \\param CPU This specifies the name of the target CPU.\n  /// \\param Features This specifies the string representation of the\n  /// additional target features.\n  MCSubtargetInfo *createMCSubtargetInfo(StringRef TheTriple, StringRef CPU,\n                                         StringRef Features) const {\n    if (!MCSubtargetInfoCtorFn)\n      return nullptr;\n    return MCSubtargetInfoCtorFn(Triple(TheTriple), CPU, Features);\n  }\n\n  /// createTargetMachine - Create a target specific machine implementation\n  /// for the specified \\p Triple.\n  ///\n  /// \\param TT This argument is used to determine the target machine\n  /// feature set; it should always be provided. Generally this should be\n  /// either the target triple from the module, or the target triple of the\n  /// host if that does not exist.\n  TargetMachine *createTargetMachine(StringRef TT, StringRef CPU,\n                                     StringRef Features,\n                                     const TargetOptions &Options,\n                                     Optional<Reloc::Model> RM,\n                                     Optional<CodeModel::Model> CM = None,\n                                     CodeGenOpt::Level OL = CodeGenOpt::Default,\n                                     bool JIT = false) const {\n    if (!TargetMachineCtorFn)\n      return nullptr;\n    return TargetMachineCtorFn(*this, Triple(TT), CPU, Features, Options, RM,\n                               CM, OL, JIT);\n  }\n\n  /// createMCAsmBackend - Create a target specific assembly parser.\n  MCAsmBackend *createMCAsmBackend(const MCSubtargetInfo &STI,\n                                   const MCRegisterInfo &MRI,\n                                   const MCTargetOptions &Options) const {\n    if (!MCAsmBackendCtorFn)\n      return nullptr;\n    return MCAsmBackendCtorFn(*this, STI, MRI, Options);\n  }\n\n  /// createMCAsmParser - Create a target specific assembly parser.\n  ///\n  /// \\param Parser The target independent parser implementation to use for\n  /// parsing and lexing.\n  MCTargetAsmParser *createMCAsmParser(const MCSubtargetInfo &STI,\n                                       MCAsmParser &Parser,\n                                       const MCInstrInfo &MII,\n                                       const MCTargetOptions &Options) const {\n    if (!MCAsmParserCtorFn)\n      return nullptr;\n    return MCAsmParserCtorFn(STI, Parser, MII, Options);\n  }\n\n  /// createAsmPrinter - Create a target specific assembly printer pass.  This\n  /// takes ownership of the MCStreamer object.\n  AsmPrinter *createAsmPrinter(TargetMachine &TM,\n                               std::unique_ptr<MCStreamer> &&Streamer) const {\n    if (!AsmPrinterCtorFn)\n      return nullptr;\n    return AsmPrinterCtorFn(TM, std::move(Streamer));\n  }\n\n  MCDisassembler *createMCDisassembler(const MCSubtargetInfo &STI,\n                                       MCContext &Ctx) const {\n    if (!MCDisassemblerCtorFn)\n      return nullptr;\n    return MCDisassemblerCtorFn(*this, STI, Ctx);\n  }\n\n  MCInstPrinter *createMCInstPrinter(const Triple &T, unsigned SyntaxVariant,\n                                     const MCAsmInfo &MAI,\n                                     const MCInstrInfo &MII,\n                                     const MCRegisterInfo &MRI) const {\n    if (!MCInstPrinterCtorFn)\n      return nullptr;\n    return MCInstPrinterCtorFn(T, SyntaxVariant, MAI, MII, MRI);\n  }\n\n  /// createMCCodeEmitter - Create a target specific code emitter.\n  MCCodeEmitter *createMCCodeEmitter(const MCInstrInfo &II,\n                                     const MCRegisterInfo &MRI,\n                                     MCContext &Ctx) const {\n    if (!MCCodeEmitterCtorFn)\n      return nullptr;\n    return MCCodeEmitterCtorFn(II, MRI, Ctx);\n  }\n\n  /// Create a target specific MCStreamer.\n  ///\n  /// \\param T The target triple.\n  /// \\param Ctx The target context.\n  /// \\param TAB The target assembler backend object. Takes ownership.\n  /// \\param OW The stream object.\n  /// \\param Emitter The target independent assembler object.Takes ownership.\n  /// \\param RelaxAll Relax all fixups?\n  MCStreamer *createMCObjectStreamer(const Triple &T, MCContext &Ctx,\n                                     std::unique_ptr<MCAsmBackend> &&TAB,\n                                     std::unique_ptr<MCObjectWriter> &&OW,\n                                     std::unique_ptr<MCCodeEmitter> &&Emitter,\n                                     const MCSubtargetInfo &STI, bool RelaxAll,\n                                     bool IncrementalLinkerCompatible,\n                                     bool DWARFMustBeAtTheEnd) const {\n    MCStreamer *S = nullptr;\n    switch (T.getObjectFormat()) {\n    case Triple::UnknownObjectFormat:\n      llvm_unreachable(\"Unknown object format\");\n    case Triple::COFF:\n      assert(T.isOSWindows() && \"only Windows COFF is supported\");\n      S = COFFStreamerCtorFn(Ctx, std::move(TAB), std::move(OW),\n                             std::move(Emitter), RelaxAll,\n                             IncrementalLinkerCompatible);\n      break;\n    case Triple::MachO:\n      if (MachOStreamerCtorFn)\n        S = MachOStreamerCtorFn(Ctx, std::move(TAB), std::move(OW),\n                                std::move(Emitter), RelaxAll,\n                                DWARFMustBeAtTheEnd);\n      else\n        S = createMachOStreamer(Ctx, std::move(TAB), std::move(OW),\n                                std::move(Emitter), RelaxAll,\n                                DWARFMustBeAtTheEnd);\n      break;\n    case Triple::ELF:\n      if (ELFStreamerCtorFn)\n        S = ELFStreamerCtorFn(T, Ctx, std::move(TAB), std::move(OW),\n                              std::move(Emitter), RelaxAll);\n      else\n        S = createELFStreamer(Ctx, std::move(TAB), std::move(OW),\n                              std::move(Emitter), RelaxAll);\n      break;\n    case Triple::Wasm:\n      if (WasmStreamerCtorFn)\n        S = WasmStreamerCtorFn(T, Ctx, std::move(TAB), std::move(OW),\n                               std::move(Emitter), RelaxAll);\n      else\n        S = createWasmStreamer(Ctx, std::move(TAB), std::move(OW),\n                               std::move(Emitter), RelaxAll);\n      break;\n    case Triple::GOFF:\n      report_fatal_error(\"GOFF MCObjectStreamer not implemented yet\");\n    case Triple::XCOFF:\n      S = createXCOFFStreamer(Ctx, std::move(TAB), std::move(OW),\n                              std::move(Emitter), RelaxAll);\n      break;\n    }\n    if (ObjectTargetStreamerCtorFn)\n      ObjectTargetStreamerCtorFn(*S, STI);\n    return S;\n  }\n\n  MCStreamer *createAsmStreamer(MCContext &Ctx,\n                                std::unique_ptr<formatted_raw_ostream> OS,\n                                bool IsVerboseAsm, bool UseDwarfDirectory,\n                                MCInstPrinter *InstPrint,\n                                std::unique_ptr<MCCodeEmitter> &&CE,\n                                std::unique_ptr<MCAsmBackend> &&TAB,\n                                bool ShowInst) const {\n    formatted_raw_ostream &OSRef = *OS;\n    MCStreamer *S = llvm::createAsmStreamer(\n        Ctx, std::move(OS), IsVerboseAsm, UseDwarfDirectory, InstPrint,\n        std::move(CE), std::move(TAB), ShowInst);\n    createAsmTargetStreamer(*S, OSRef, InstPrint, IsVerboseAsm);\n    return S;\n  }\n\n  MCTargetStreamer *createAsmTargetStreamer(MCStreamer &S,\n                                            formatted_raw_ostream &OS,\n                                            MCInstPrinter *InstPrint,\n                                            bool IsVerboseAsm) const {\n    if (AsmTargetStreamerCtorFn)\n      return AsmTargetStreamerCtorFn(S, OS, InstPrint, IsVerboseAsm);\n    return nullptr;\n  }\n\n  MCStreamer *createNullStreamer(MCContext &Ctx) const {\n    MCStreamer *S = llvm::createNullStreamer(Ctx);\n    createNullTargetStreamer(*S);\n    return S;\n  }\n\n  MCTargetStreamer *createNullTargetStreamer(MCStreamer &S) const {\n    if (NullTargetStreamerCtorFn)\n      return NullTargetStreamerCtorFn(S);\n    return nullptr;\n  }\n\n  /// createMCRelocationInfo - Create a target specific MCRelocationInfo.\n  ///\n  /// \\param TT The target triple.\n  /// \\param Ctx The target context.\n  MCRelocationInfo *createMCRelocationInfo(StringRef TT, MCContext &Ctx) const {\n    MCRelocationInfoCtorTy Fn = MCRelocationInfoCtorFn\n                                    ? MCRelocationInfoCtorFn\n                                    : llvm::createMCRelocationInfo;\n    return Fn(Triple(TT), Ctx);\n  }\n\n  /// createMCSymbolizer - Create a target specific MCSymbolizer.\n  ///\n  /// \\param TT The target triple.\n  /// \\param GetOpInfo The function to get the symbolic information for\n  /// operands.\n  /// \\param SymbolLookUp The function to lookup a symbol name.\n  /// \\param DisInfo The pointer to the block of symbolic information for above\n  /// call\n  /// back.\n  /// \\param Ctx The target context.\n  /// \\param RelInfo The relocation information for this target. Takes\n  /// ownership.\n  MCSymbolizer *\n  createMCSymbolizer(StringRef TT, LLVMOpInfoCallback GetOpInfo,\n                     LLVMSymbolLookupCallback SymbolLookUp, void *DisInfo,\n                     MCContext *Ctx,\n                     std::unique_ptr<MCRelocationInfo> &&RelInfo) const {\n    MCSymbolizerCtorTy Fn =\n        MCSymbolizerCtorFn ? MCSymbolizerCtorFn : llvm::createMCSymbolizer;\n    return Fn(Triple(TT), GetOpInfo, SymbolLookUp, DisInfo, Ctx,\n              std::move(RelInfo));\n  }\n\n  /// @}\n};\n\n/// TargetRegistry - Generic interface to target specific features.\nstruct TargetRegistry {\n  // FIXME: Make this a namespace, probably just move all the Register*\n  // functions into Target (currently they all just set members on the Target\n  // anyway, and Target friends this class so those functions can...\n  // function).\n  TargetRegistry() = delete;\n\n  class iterator\n      : public std::iterator<std::forward_iterator_tag, Target, ptrdiff_t> {\n    friend struct TargetRegistry;\n\n    const Target *Current = nullptr;\n\n    explicit iterator(Target *T) : Current(T) {}\n\n  public:\n    iterator() = default;\n\n    bool operator==(const iterator &x) const { return Current == x.Current; }\n    bool operator!=(const iterator &x) const { return !operator==(x); }\n\n    // Iterator traversal: forward iteration only\n    iterator &operator++() { // Preincrement\n      assert(Current && \"Cannot increment end iterator!\");\n      Current = Current->getNext();\n      return *this;\n    }\n    iterator operator++(int) { // Postincrement\n      iterator tmp = *this;\n      ++*this;\n      return tmp;\n    }\n\n    const Target &operator*() const {\n      assert(Current && \"Cannot dereference end iterator!\");\n      return *Current;\n    }\n\n    const Target *operator->() const { return &operator*(); }\n  };\n\n  /// printRegisteredTargetsForVersion - Print the registered targets\n  /// appropriately for inclusion in a tool's version output.\n  static void printRegisteredTargetsForVersion(raw_ostream &OS);\n\n  /// @name Registry Access\n  /// @{\n\n  static iterator_range<iterator> targets();\n\n  /// lookupTarget - Lookup a target based on a target triple.\n  ///\n  /// \\param Triple - The triple to use for finding a target.\n  /// \\param Error - On failure, an error string describing why no target was\n  /// found.\n  static const Target *lookupTarget(const std::string &Triple,\n                                    std::string &Error);\n\n  /// lookupTarget - Lookup a target based on an architecture name\n  /// and a target triple.  If the architecture name is non-empty,\n  /// then the lookup is done by architecture.  Otherwise, the target\n  /// triple is used.\n  ///\n  /// \\param ArchName - The architecture to use for finding a target.\n  /// \\param TheTriple - The triple to use for finding a target.  The\n  /// triple is updated with canonical architecture name if a lookup\n  /// by architecture is done.\n  /// \\param Error - On failure, an error string describing why no target was\n  /// found.\n  static const Target *lookupTarget(const std::string &ArchName,\n                                    Triple &TheTriple, std::string &Error);\n\n  /// @}\n  /// @name Target Registration\n  /// @{\n\n  /// RegisterTarget - Register the given target. Attempts to register a\n  /// target which has already been registered will be ignored.\n  ///\n  /// Clients are responsible for ensuring that registration doesn't occur\n  /// while another thread is attempting to access the registry. Typically\n  /// this is done by initializing all targets at program startup.\n  ///\n  /// @param T - The target being registered.\n  /// @param Name - The target name. This should be a static string.\n  /// @param ShortDesc - A short target description. This should be a static\n  /// string.\n  /// @param BackendName - The name of the backend. This should be a static\n  /// string that is the same for all targets that share a backend\n  /// implementation and must match the name used in the 'def X : Target ...' in\n  /// TableGen.\n  /// @param ArchMatchFn - The arch match checking function for this target.\n  /// @param HasJIT - Whether the target supports JIT code\n  /// generation.\n  static void RegisterTarget(Target &T, const char *Name, const char *ShortDesc,\n                             const char *BackendName,\n                             Target::ArchMatchFnTy ArchMatchFn,\n                             bool HasJIT = false);\n\n  /// RegisterMCAsmInfo - Register a MCAsmInfo implementation for the\n  /// given target.\n  ///\n  /// Clients are responsible for ensuring that registration doesn't occur\n  /// while another thread is attempting to access the registry. Typically\n  /// this is done by initializing all targets at program startup.\n  ///\n  /// @param T - The target being registered.\n  /// @param Fn - A function to construct a MCAsmInfo for the target.\n  static void RegisterMCAsmInfo(Target &T, Target::MCAsmInfoCtorFnTy Fn) {\n    T.MCAsmInfoCtorFn = Fn;\n  }\n\n  /// RegisterMCInstrInfo - Register a MCInstrInfo implementation for the\n  /// given target.\n  ///\n  /// Clients are responsible for ensuring that registration doesn't occur\n  /// while another thread is attempting to access the registry. Typically\n  /// this is done by initializing all targets at program startup.\n  ///\n  /// @param T - The target being registered.\n  /// @param Fn - A function to construct a MCInstrInfo for the target.\n  static void RegisterMCInstrInfo(Target &T, Target::MCInstrInfoCtorFnTy Fn) {\n    T.MCInstrInfoCtorFn = Fn;\n  }\n\n  /// RegisterMCInstrAnalysis - Register a MCInstrAnalysis implementation for\n  /// the given target.\n  static void RegisterMCInstrAnalysis(Target &T,\n                                      Target::MCInstrAnalysisCtorFnTy Fn) {\n    T.MCInstrAnalysisCtorFn = Fn;\n  }\n\n  /// RegisterMCRegInfo - Register a MCRegisterInfo implementation for the\n  /// given target.\n  ///\n  /// Clients are responsible for ensuring that registration doesn't occur\n  /// while another thread is attempting to access the registry. Typically\n  /// this is done by initializing all targets at program startup.\n  ///\n  /// @param T - The target being registered.\n  /// @param Fn - A function to construct a MCRegisterInfo for the target.\n  static void RegisterMCRegInfo(Target &T, Target::MCRegInfoCtorFnTy Fn) {\n    T.MCRegInfoCtorFn = Fn;\n  }\n\n  /// RegisterMCSubtargetInfo - Register a MCSubtargetInfo implementation for\n  /// the given target.\n  ///\n  /// Clients are responsible for ensuring that registration doesn't occur\n  /// while another thread is attempting to access the registry. Typically\n  /// this is done by initializing all targets at program startup.\n  ///\n  /// @param T - The target being registered.\n  /// @param Fn - A function to construct a MCSubtargetInfo for the target.\n  static void RegisterMCSubtargetInfo(Target &T,\n                                      Target::MCSubtargetInfoCtorFnTy Fn) {\n    T.MCSubtargetInfoCtorFn = Fn;\n  }\n\n  /// RegisterTargetMachine - Register a TargetMachine implementation for the\n  /// given target.\n  ///\n  /// Clients are responsible for ensuring that registration doesn't occur\n  /// while another thread is attempting to access the registry. Typically\n  /// this is done by initializing all targets at program startup.\n  ///\n  /// @param T - The target being registered.\n  /// @param Fn - A function to construct a TargetMachine for the target.\n  static void RegisterTargetMachine(Target &T, Target::TargetMachineCtorTy Fn) {\n    T.TargetMachineCtorFn = Fn;\n  }\n\n  /// RegisterMCAsmBackend - Register a MCAsmBackend implementation for the\n  /// given target.\n  ///\n  /// Clients are responsible for ensuring that registration doesn't occur\n  /// while another thread is attempting to access the registry. Typically\n  /// this is done by initializing all targets at program startup.\n  ///\n  /// @param T - The target being registered.\n  /// @param Fn - A function to construct an AsmBackend for the target.\n  static void RegisterMCAsmBackend(Target &T, Target::MCAsmBackendCtorTy Fn) {\n    T.MCAsmBackendCtorFn = Fn;\n  }\n\n  /// RegisterMCAsmParser - Register a MCTargetAsmParser implementation for\n  /// the given target.\n  ///\n  /// Clients are responsible for ensuring that registration doesn't occur\n  /// while another thread is attempting to access the registry. Typically\n  /// this is done by initializing all targets at program startup.\n  ///\n  /// @param T - The target being registered.\n  /// @param Fn - A function to construct an MCTargetAsmParser for the target.\n  static void RegisterMCAsmParser(Target &T, Target::MCAsmParserCtorTy Fn) {\n    T.MCAsmParserCtorFn = Fn;\n  }\n\n  /// RegisterAsmPrinter - Register an AsmPrinter implementation for the given\n  /// target.\n  ///\n  /// Clients are responsible for ensuring that registration doesn't occur\n  /// while another thread is attempting to access the registry. Typically\n  /// this is done by initializing all targets at program startup.\n  ///\n  /// @param T - The target being registered.\n  /// @param Fn - A function to construct an AsmPrinter for the target.\n  static void RegisterAsmPrinter(Target &T, Target::AsmPrinterCtorTy Fn) {\n    T.AsmPrinterCtorFn = Fn;\n  }\n\n  /// RegisterMCDisassembler - Register a MCDisassembler implementation for\n  /// the given target.\n  ///\n  /// Clients are responsible for ensuring that registration doesn't occur\n  /// while another thread is attempting to access the registry. Typically\n  /// this is done by initializing all targets at program startup.\n  ///\n  /// @param T - The target being registered.\n  /// @param Fn - A function to construct an MCDisassembler for the target.\n  static void RegisterMCDisassembler(Target &T,\n                                     Target::MCDisassemblerCtorTy Fn) {\n    T.MCDisassemblerCtorFn = Fn;\n  }\n\n  /// RegisterMCInstPrinter - Register a MCInstPrinter implementation for the\n  /// given target.\n  ///\n  /// Clients are responsible for ensuring that registration doesn't occur\n  /// while another thread is attempting to access the registry. Typically\n  /// this is done by initializing all targets at program startup.\n  ///\n  /// @param T - The target being registered.\n  /// @param Fn - A function to construct an MCInstPrinter for the target.\n  static void RegisterMCInstPrinter(Target &T, Target::MCInstPrinterCtorTy Fn) {\n    T.MCInstPrinterCtorFn = Fn;\n  }\n\n  /// RegisterMCCodeEmitter - Register a MCCodeEmitter implementation for the\n  /// given target.\n  ///\n  /// Clients are responsible for ensuring that registration doesn't occur\n  /// while another thread is attempting to access the registry. Typically\n  /// this is done by initializing all targets at program startup.\n  ///\n  /// @param T - The target being registered.\n  /// @param Fn - A function to construct an MCCodeEmitter for the target.\n  static void RegisterMCCodeEmitter(Target &T, Target::MCCodeEmitterCtorTy Fn) {\n    T.MCCodeEmitterCtorFn = Fn;\n  }\n\n  static void RegisterCOFFStreamer(Target &T, Target::COFFStreamerCtorTy Fn) {\n    T.COFFStreamerCtorFn = Fn;\n  }\n\n  static void RegisterMachOStreamer(Target &T, Target::MachOStreamerCtorTy Fn) {\n    T.MachOStreamerCtorFn = Fn;\n  }\n\n  static void RegisterELFStreamer(Target &T, Target::ELFStreamerCtorTy Fn) {\n    T.ELFStreamerCtorFn = Fn;\n  }\n\n  static void RegisterWasmStreamer(Target &T, Target::WasmStreamerCtorTy Fn) {\n    T.WasmStreamerCtorFn = Fn;\n  }\n\n  static void RegisterNullTargetStreamer(Target &T,\n                                         Target::NullTargetStreamerCtorTy Fn) {\n    T.NullTargetStreamerCtorFn = Fn;\n  }\n\n  static void RegisterAsmTargetStreamer(Target &T,\n                                        Target::AsmTargetStreamerCtorTy Fn) {\n    T.AsmTargetStreamerCtorFn = Fn;\n  }\n\n  static void\n  RegisterObjectTargetStreamer(Target &T,\n                               Target::ObjectTargetStreamerCtorTy Fn) {\n    T.ObjectTargetStreamerCtorFn = Fn;\n  }\n\n  /// RegisterMCRelocationInfo - Register an MCRelocationInfo\n  /// implementation for the given target.\n  ///\n  /// Clients are responsible for ensuring that registration doesn't occur\n  /// while another thread is attempting to access the registry. Typically\n  /// this is done by initializing all targets at program startup.\n  ///\n  /// @param T - The target being registered.\n  /// @param Fn - A function to construct an MCRelocationInfo for the target.\n  static void RegisterMCRelocationInfo(Target &T,\n                                       Target::MCRelocationInfoCtorTy Fn) {\n    T.MCRelocationInfoCtorFn = Fn;\n  }\n\n  /// RegisterMCSymbolizer - Register an MCSymbolizer\n  /// implementation for the given target.\n  ///\n  /// Clients are responsible for ensuring that registration doesn't occur\n  /// while another thread is attempting to access the registry. Typically\n  /// this is done by initializing all targets at program startup.\n  ///\n  /// @param T - The target being registered.\n  /// @param Fn - A function to construct an MCSymbolizer for the target.\n  static void RegisterMCSymbolizer(Target &T, Target::MCSymbolizerCtorTy Fn) {\n    T.MCSymbolizerCtorFn = Fn;\n  }\n\n  /// @}\n};\n\n//===--------------------------------------------------------------------===//\n\n/// RegisterTarget - Helper template for registering a target, for use in the\n/// target's initialization function. Usage:\n///\n///\n/// Target &getTheFooTarget() { // The global target instance.\n///   static Target TheFooTarget;\n///   return TheFooTarget;\n/// }\n/// extern \"C\" void LLVMInitializeFooTargetInfo() {\n///   RegisterTarget<Triple::foo> X(getTheFooTarget(), \"foo\", \"Foo\n///   description\", \"Foo\" /* Backend Name */);\n/// }\ntemplate <Triple::ArchType TargetArchType = Triple::UnknownArch,\n          bool HasJIT = false>\nstruct RegisterTarget {\n  RegisterTarget(Target &T, const char *Name, const char *Desc,\n                 const char *BackendName) {\n    TargetRegistry::RegisterTarget(T, Name, Desc, BackendName, &getArchMatch,\n                                   HasJIT);\n  }\n\n  static bool getArchMatch(Triple::ArchType Arch) {\n    return Arch == TargetArchType;\n  }\n};\n\n/// RegisterMCAsmInfo - Helper template for registering a target assembly info\n/// implementation.  This invokes the static \"Create\" method on the class to\n/// actually do the construction.  Usage:\n///\n/// extern \"C\" void LLVMInitializeFooTarget() {\n///   extern Target TheFooTarget;\n///   RegisterMCAsmInfo<FooMCAsmInfo> X(TheFooTarget);\n/// }\ntemplate <class MCAsmInfoImpl> struct RegisterMCAsmInfo {\n  RegisterMCAsmInfo(Target &T) {\n    TargetRegistry::RegisterMCAsmInfo(T, &Allocator);\n  }\n\nprivate:\n  static MCAsmInfo *Allocator(const MCRegisterInfo & /*MRI*/, const Triple &TT,\n                              const MCTargetOptions &Options) {\n    return new MCAsmInfoImpl(TT, Options);\n  }\n};\n\n/// RegisterMCAsmInfoFn - Helper template for registering a target assembly info\n/// implementation.  This invokes the specified function to do the\n/// construction.  Usage:\n///\n/// extern \"C\" void LLVMInitializeFooTarget() {\n///   extern Target TheFooTarget;\n///   RegisterMCAsmInfoFn X(TheFooTarget, TheFunction);\n/// }\nstruct RegisterMCAsmInfoFn {\n  RegisterMCAsmInfoFn(Target &T, Target::MCAsmInfoCtorFnTy Fn) {\n    TargetRegistry::RegisterMCAsmInfo(T, Fn);\n  }\n};\n\n/// RegisterMCInstrInfo - Helper template for registering a target instruction\n/// info implementation.  This invokes the static \"Create\" method on the class\n/// to actually do the construction.  Usage:\n///\n/// extern \"C\" void LLVMInitializeFooTarget() {\n///   extern Target TheFooTarget;\n///   RegisterMCInstrInfo<FooMCInstrInfo> X(TheFooTarget);\n/// }\ntemplate <class MCInstrInfoImpl> struct RegisterMCInstrInfo {\n  RegisterMCInstrInfo(Target &T) {\n    TargetRegistry::RegisterMCInstrInfo(T, &Allocator);\n  }\n\nprivate:\n  static MCInstrInfo *Allocator() { return new MCInstrInfoImpl(); }\n};\n\n/// RegisterMCInstrInfoFn - Helper template for registering a target\n/// instruction info implementation.  This invokes the specified function to\n/// do the construction.  Usage:\n///\n/// extern \"C\" void LLVMInitializeFooTarget() {\n///   extern Target TheFooTarget;\n///   RegisterMCInstrInfoFn X(TheFooTarget, TheFunction);\n/// }\nstruct RegisterMCInstrInfoFn {\n  RegisterMCInstrInfoFn(Target &T, Target::MCInstrInfoCtorFnTy Fn) {\n    TargetRegistry::RegisterMCInstrInfo(T, Fn);\n  }\n};\n\n/// RegisterMCInstrAnalysis - Helper template for registering a target\n/// instruction analyzer implementation.  This invokes the static \"Create\"\n/// method on the class to actually do the construction.  Usage:\n///\n/// extern \"C\" void LLVMInitializeFooTarget() {\n///   extern Target TheFooTarget;\n///   RegisterMCInstrAnalysis<FooMCInstrAnalysis> X(TheFooTarget);\n/// }\ntemplate <class MCInstrAnalysisImpl> struct RegisterMCInstrAnalysis {\n  RegisterMCInstrAnalysis(Target &T) {\n    TargetRegistry::RegisterMCInstrAnalysis(T, &Allocator);\n  }\n\nprivate:\n  static MCInstrAnalysis *Allocator(const MCInstrInfo *Info) {\n    return new MCInstrAnalysisImpl(Info);\n  }\n};\n\n/// RegisterMCInstrAnalysisFn - Helper template for registering a target\n/// instruction analyzer implementation.  This invokes the specified function\n/// to do the construction.  Usage:\n///\n/// extern \"C\" void LLVMInitializeFooTarget() {\n///   extern Target TheFooTarget;\n///   RegisterMCInstrAnalysisFn X(TheFooTarget, TheFunction);\n/// }\nstruct RegisterMCInstrAnalysisFn {\n  RegisterMCInstrAnalysisFn(Target &T, Target::MCInstrAnalysisCtorFnTy Fn) {\n    TargetRegistry::RegisterMCInstrAnalysis(T, Fn);\n  }\n};\n\n/// RegisterMCRegInfo - Helper template for registering a target register info\n/// implementation.  This invokes the static \"Create\" method on the class to\n/// actually do the construction.  Usage:\n///\n/// extern \"C\" void LLVMInitializeFooTarget() {\n///   extern Target TheFooTarget;\n///   RegisterMCRegInfo<FooMCRegInfo> X(TheFooTarget);\n/// }\ntemplate <class MCRegisterInfoImpl> struct RegisterMCRegInfo {\n  RegisterMCRegInfo(Target &T) {\n    TargetRegistry::RegisterMCRegInfo(T, &Allocator);\n  }\n\nprivate:\n  static MCRegisterInfo *Allocator(const Triple & /*TT*/) {\n    return new MCRegisterInfoImpl();\n  }\n};\n\n/// RegisterMCRegInfoFn - Helper template for registering a target register\n/// info implementation.  This invokes the specified function to do the\n/// construction.  Usage:\n///\n/// extern \"C\" void LLVMInitializeFooTarget() {\n///   extern Target TheFooTarget;\n///   RegisterMCRegInfoFn X(TheFooTarget, TheFunction);\n/// }\nstruct RegisterMCRegInfoFn {\n  RegisterMCRegInfoFn(Target &T, Target::MCRegInfoCtorFnTy Fn) {\n    TargetRegistry::RegisterMCRegInfo(T, Fn);\n  }\n};\n\n/// RegisterMCSubtargetInfo - Helper template for registering a target\n/// subtarget info implementation.  This invokes the static \"Create\" method\n/// on the class to actually do the construction.  Usage:\n///\n/// extern \"C\" void LLVMInitializeFooTarget() {\n///   extern Target TheFooTarget;\n///   RegisterMCSubtargetInfo<FooMCSubtargetInfo> X(TheFooTarget);\n/// }\ntemplate <class MCSubtargetInfoImpl> struct RegisterMCSubtargetInfo {\n  RegisterMCSubtargetInfo(Target &T) {\n    TargetRegistry::RegisterMCSubtargetInfo(T, &Allocator);\n  }\n\nprivate:\n  static MCSubtargetInfo *Allocator(const Triple & /*TT*/, StringRef /*CPU*/,\n                                    StringRef /*FS*/) {\n    return new MCSubtargetInfoImpl();\n  }\n};\n\n/// RegisterMCSubtargetInfoFn - Helper template for registering a target\n/// subtarget info implementation.  This invokes the specified function to\n/// do the construction.  Usage:\n///\n/// extern \"C\" void LLVMInitializeFooTarget() {\n///   extern Target TheFooTarget;\n///   RegisterMCSubtargetInfoFn X(TheFooTarget, TheFunction);\n/// }\nstruct RegisterMCSubtargetInfoFn {\n  RegisterMCSubtargetInfoFn(Target &T, Target::MCSubtargetInfoCtorFnTy Fn) {\n    TargetRegistry::RegisterMCSubtargetInfo(T, Fn);\n  }\n};\n\n/// RegisterTargetMachine - Helper template for registering a target machine\n/// implementation, for use in the target machine initialization\n/// function. Usage:\n///\n/// extern \"C\" void LLVMInitializeFooTarget() {\n///   extern Target TheFooTarget;\n///   RegisterTargetMachine<FooTargetMachine> X(TheFooTarget);\n/// }\ntemplate <class TargetMachineImpl> struct RegisterTargetMachine {\n  RegisterTargetMachine(Target &T) {\n    TargetRegistry::RegisterTargetMachine(T, &Allocator);\n  }\n\nprivate:\n  static TargetMachine *\n  Allocator(const Target &T, const Triple &TT, StringRef CPU, StringRef FS,\n            const TargetOptions &Options, Optional<Reloc::Model> RM,\n            Optional<CodeModel::Model> CM, CodeGenOpt::Level OL, bool JIT) {\n    return new TargetMachineImpl(T, TT, CPU, FS, Options, RM, CM, OL, JIT);\n  }\n};\n\n/// RegisterMCAsmBackend - Helper template for registering a target specific\n/// assembler backend. Usage:\n///\n/// extern \"C\" void LLVMInitializeFooMCAsmBackend() {\n///   extern Target TheFooTarget;\n///   RegisterMCAsmBackend<FooAsmLexer> X(TheFooTarget);\n/// }\ntemplate <class MCAsmBackendImpl> struct RegisterMCAsmBackend {\n  RegisterMCAsmBackend(Target &T) {\n    TargetRegistry::RegisterMCAsmBackend(T, &Allocator);\n  }\n\nprivate:\n  static MCAsmBackend *Allocator(const Target &T, const MCSubtargetInfo &STI,\n                                 const MCRegisterInfo &MRI,\n                                 const MCTargetOptions &Options) {\n    return new MCAsmBackendImpl(T, STI, MRI);\n  }\n};\n\n/// RegisterMCAsmParser - Helper template for registering a target specific\n/// assembly parser, for use in the target machine initialization\n/// function. Usage:\n///\n/// extern \"C\" void LLVMInitializeFooMCAsmParser() {\n///   extern Target TheFooTarget;\n///   RegisterMCAsmParser<FooAsmParser> X(TheFooTarget);\n/// }\ntemplate <class MCAsmParserImpl> struct RegisterMCAsmParser {\n  RegisterMCAsmParser(Target &T) {\n    TargetRegistry::RegisterMCAsmParser(T, &Allocator);\n  }\n\nprivate:\n  static MCTargetAsmParser *Allocator(const MCSubtargetInfo &STI,\n                                      MCAsmParser &P, const MCInstrInfo &MII,\n                                      const MCTargetOptions &Options) {\n    return new MCAsmParserImpl(STI, P, MII, Options);\n  }\n};\n\n/// RegisterAsmPrinter - Helper template for registering a target specific\n/// assembly printer, for use in the target machine initialization\n/// function. Usage:\n///\n/// extern \"C\" void LLVMInitializeFooAsmPrinter() {\n///   extern Target TheFooTarget;\n///   RegisterAsmPrinter<FooAsmPrinter> X(TheFooTarget);\n/// }\ntemplate <class AsmPrinterImpl> struct RegisterAsmPrinter {\n  RegisterAsmPrinter(Target &T) {\n    TargetRegistry::RegisterAsmPrinter(T, &Allocator);\n  }\n\nprivate:\n  static AsmPrinter *Allocator(TargetMachine &TM,\n                               std::unique_ptr<MCStreamer> &&Streamer) {\n    return new AsmPrinterImpl(TM, std::move(Streamer));\n  }\n};\n\n/// RegisterMCCodeEmitter - Helper template for registering a target specific\n/// machine code emitter, for use in the target initialization\n/// function. Usage:\n///\n/// extern \"C\" void LLVMInitializeFooMCCodeEmitter() {\n///   extern Target TheFooTarget;\n///   RegisterMCCodeEmitter<FooCodeEmitter> X(TheFooTarget);\n/// }\ntemplate <class MCCodeEmitterImpl> struct RegisterMCCodeEmitter {\n  RegisterMCCodeEmitter(Target &T) {\n    TargetRegistry::RegisterMCCodeEmitter(T, &Allocator);\n  }\n\nprivate:\n  static MCCodeEmitter *Allocator(const MCInstrInfo & /*II*/,\n                                  const MCRegisterInfo & /*MRI*/,\n                                  MCContext & /*Ctx*/) {\n    return new MCCodeEmitterImpl();\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_TARGETREGISTRY_H\n"}}, "reports": [{"events": [{"location": {"col": 8, "file": 27, "line": 115}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h", "reportHash": "a28a4a41a277fa7fd91c2f1b9dc185d2", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 27, "line": 162}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h", "reportHash": "5eb893d9893ddfb17b3814236db4bc13", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 27, "line": 179}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h", "reportHash": "91b6f126325ef7f6d632208ebbb32137", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 28, "line": 74}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegisterBank.h", "reportHash": "ee80ec8dfbd54b03bcf6694862a5a231", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 28, "line": 75}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegisterBank.h", "reportHash": "de7112f2c03348cf83e56c41d15d70df", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 30, "line": 148}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundle.h", "reportHash": "c4be40cd4267bea607d5698a1e4dd8e3", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 33, "line": 131}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h", "reportHash": "9caf41ef6ece70fbf942cf0cb813ed47", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 34, "line": 1018}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h", "reportHash": "ee0b79d255d27f01706661b94be7ea43", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 34, "line": 1021}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h", "reportHash": "95dc3e9f7095572526c72372e657da76", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 34, "line": 1124}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h", "reportHash": "7b7704cd1b1ace4e83685604d5f4ef84", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 34, "line": 1127}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h", "reportHash": "5df5e800c3a8a6f67e5d3371d4d0f08a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 159}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h", "reportHash": "65d5ddd005b600d51d0022190fa1996f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 162}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h", "reportHash": "0c68a1dbaa7400d1847186df7c7d7fbc", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 165}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h", "reportHash": "c67976c3a1615bd392100b7eb0dbc71e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 313}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h", "reportHash": "b3f9e2ed80a4d009e2ea61dc5507bf26", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 318}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h", "reportHash": "fd0837318c08089c0fdef148ccfaaa47", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 323}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h", "reportHash": "0ad627a4c8fd96fe48b48e0630d255cc", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 36, "line": 736}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h", "reportHash": "26a8176286e45715b970046d3c3abfdf", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 36, "line": 739}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h", "reportHash": "740ba8ba4d49a517c3af7129ee892ea0", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 2598}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h", "reportHash": "3598206e4e75eec3e23bbcb205b0b4a4", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 2601}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h", "reportHash": "da47b856a10bea926615cb3027efb3df", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 37, "line": 471}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h", "reportHash": "47966fbe3b83b7300a30991066d937d2", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 37, "line": 474}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h", "reportHash": "8f263e3c149bcaa00306ccd170fbd18d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 38, "line": 42}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/TileShapeInfo.h", "reportHash": "5a250a5bfc078869779e1a7320bb9d0d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 38, "line": 56}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/TileShapeInfo.h", "reportHash": "13363d91420c648bcbf6e9f8fa2d92aa", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 39, "line": 45}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h", "reportHash": "c7a2cc1cfe7601bd9314760e9f68093c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 39, "line": 48}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h", "reportHash": "cc298492c5e00a23b6233bd2e26d2425", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 56, "line": 229}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCContext.h", "reportHash": "dd4ac438053fa1b88ca84494bb96c8a5", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 56, "line": 251}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCContext.h", "reportHash": "71b7427766a68c1d866b4c683ff133e9", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 56, "line": 272}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCContext.h", "reportHash": "68148630b7fa666a2d07ac4cc3e44607", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 56, "line": 303}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCContext.h", "reportHash": "34c7f88910ef1397cb3e148f33726b7f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 56, "line": 362}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCContext.h", "reportHash": "f6338b4bee0ec52577f074e03415cd38", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 75, "line": 617}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TargetRegistry.h", "reportHash": "4d7b2c00f5db59ec7912bcbf377e1c0d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 75, "line": 618}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TargetRegistry.h", "reportHash": "2a25aa339792d021a68a22b5f24fe04d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
