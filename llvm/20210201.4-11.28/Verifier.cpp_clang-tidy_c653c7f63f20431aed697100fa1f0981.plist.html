<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/llvm/lib/IR/Verifier.cpp", "content": "//===-- Verifier.cpp - Implement the Module Verifier -----------------------==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the function verifier interface, that can be used for some\n// sanity checking of input to the system.\n//\n// Note that this does not provide full `Java style' security and verifications,\n// instead it just tries to ensure that code is well-formed.\n//\n//  * Both of a binary operator's parameters are of the same type\n//  * Verify that the indices of mem access instructions match other operands\n//  * Verify that arithmetic and other things are only performed on first-class\n//    types.  Verify that shifts & logicals only happen on integrals f.e.\n//  * All of the constants in a switch statement are of the correct type\n//  * The code is in valid SSA form\n//  * It should be illegal to put a label into any other type (like a structure)\n//    or to return one. [except constant arrays!]\n//  * Only phi nodes can be self referential: 'add i32 %0, %0 ; <int>:0' is bad\n//  * PHI nodes must have an entry for each predecessor, with no extras.\n//  * PHI nodes must be the first thing in a basic block, all grouped together\n//  * PHI nodes must have at least one entry\n//  * All basic blocks should only end with terminator insts, not contain them\n//  * The entry node to a function must not have predecessors\n//  * All Instructions must be embedded into a basic block\n//  * Functions cannot take a void-typed parameter\n//  * Verify that a function's argument list agrees with it's declared type.\n//  * It is illegal to specify a name for a void value.\n//  * It is illegal to have a internal global value with no initializer\n//  * It is illegal to have a ret instruction that returns a value that does not\n//    agree with the function return value type.\n//  * Function call argument types match the function prototype\n//  * A landing pad is defined by a landingpad instruction, and can be jumped to\n//    only by the unwind edge of an invoke instruction.\n//  * A landingpad instruction must be the first non-PHI instruction in the\n//    block.\n//  * Landingpad instructions must be in a function with a personality function.\n//  * All other things that are tested by asserts spread about the code...\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/IR/Verifier.h\"\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/MapVector.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/ADT/ilist.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/IR/Argument.h\"\n#include \"llvm/IR/Attributes.h\"\n#include \"llvm/IR/BasicBlock.h\"\n#include \"llvm/IR/CFG.h\"\n#include \"llvm/IR/CallingConv.h\"\n#include \"llvm/IR/Comdat.h\"\n#include \"llvm/IR/Constant.h\"\n#include \"llvm/IR/ConstantRange.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/DataLayout.h\"\n#include \"llvm/IR/DebugInfo.h\"\n#include \"llvm/IR/DebugInfoMetadata.h\"\n#include \"llvm/IR/DebugLoc.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/Dominators.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/GlobalAlias.h\"\n#include \"llvm/IR/GlobalValue.h\"\n#include \"llvm/IR/GlobalVariable.h\"\n#include \"llvm/IR/InlineAsm.h\"\n#include \"llvm/IR/InstVisitor.h\"\n#include \"llvm/IR/InstrTypes.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/IntrinsicInst.h\"\n#include \"llvm/IR/Intrinsics.h\"\n#include \"llvm/IR/IntrinsicsWebAssembly.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/Metadata.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/ModuleSlotTracker.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/IR/Statepoint.h\"\n#include \"llvm/IR/Type.h\"\n#include \"llvm/IR/Use.h\"\n#include \"llvm/IR/User.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/InitializePasses.h\"\n#include \"llvm/Pass.h\"\n#include \"llvm/Support/AtomicOrdering.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <memory>\n#include <string>\n#include <utility>\n\nusing namespace llvm;\n\nstatic cl::opt<bool> VerifyNoAliasScopeDomination(\n    \"verify-noalias-scope-decl-dom\", cl::Hidden, cl::init(true),\n    cl::desc(\"Ensure that llvm.experimental.noalias.scope.decl for identical \"\n             \"scopes are not dominating\"));\n\nnamespace llvm {\n\nstruct VerifierSupport {\n  raw_ostream *OS;\n  const Module &M;\n  ModuleSlotTracker MST;\n  Triple TT;\n  const DataLayout &DL;\n  LLVMContext &Context;\n\n  /// Track the brokenness of the module while recursively visiting.\n  bool Broken = false;\n  /// Broken debug info can be \"recovered\" from by stripping the debug info.\n  bool BrokenDebugInfo = false;\n  /// Whether to treat broken debug info as an error.\n  bool TreatBrokenDebugInfoAsError = true;\n\n  explicit VerifierSupport(raw_ostream *OS, const Module &M)\n      : OS(OS), M(M), MST(&M), TT(M.getTargetTriple()), DL(M.getDataLayout()),\n        Context(M.getContext()) {}\n\nprivate:\n  void Write(const Module *M) {\n    *OS << \"; ModuleID = '\" << M->getModuleIdentifier() << \"'\\n\";\n  }\n\n  void Write(const Value *V) {\n    if (V)\n      Write(*V);\n  }\n\n  void Write(const Value &V) {\n    if (isa<Instruction>(V)) {\n      V.print(*OS, MST);\n      *OS << '\\n';\n    } else {\n      V.printAsOperand(*OS, true, MST);\n      *OS << '\\n';\n    }\n  }\n\n  void Write(const Metadata *MD) {\n    if (!MD)\n      return;\n    MD->print(*OS, MST, &M);\n    *OS << '\\n';\n  }\n\n  template <class T> void Write(const MDTupleTypedArrayWrapper<T> &MD) {\n    Write(MD.get());\n  }\n\n  void Write(const NamedMDNode *NMD) {\n    if (!NMD)\n      return;\n    NMD->print(*OS, MST);\n    *OS << '\\n';\n  }\n\n  void Write(Type *T) {\n    if (!T)\n      return;\n    *OS << ' ' << *T;\n  }\n\n  void Write(const Comdat *C) {\n    if (!C)\n      return;\n    *OS << *C;\n  }\n\n  void Write(const APInt *AI) {\n    if (!AI)\n      return;\n    *OS << *AI << '\\n';\n  }\n\n  void Write(const unsigned i) { *OS << i << '\\n'; }\n\n  template <typename T> void Write(ArrayRef<T> Vs) {\n    for (const T &V : Vs)\n      Write(V);\n  }\n\n  template <typename T1, typename... Ts>\n  void WriteTs(const T1 &V1, const Ts &... Vs) {\n    Write(V1);\n    WriteTs(Vs...);\n  }\n\n  template <typename... Ts> void WriteTs() {}\n\npublic:\n  /// A check failed, so printout out the condition and the message.\n  ///\n  /// This provides a nice place to put a breakpoint if you want to see why\n  /// something is not correct.\n  void CheckFailed(const Twine &Message) {\n    if (OS)\n      *OS << Message << '\\n';\n    Broken = true;\n  }\n\n  /// A check failed (with values to print).\n  ///\n  /// This calls the Message-only version so that the above is easier to set a\n  /// breakpoint on.\n  template <typename T1, typename... Ts>\n  void CheckFailed(const Twine &Message, const T1 &V1, const Ts &... Vs) {\n    CheckFailed(Message);\n    if (OS)\n      WriteTs(V1, Vs...);\n  }\n\n  /// A debug info check failed.\n  void DebugInfoCheckFailed(const Twine &Message) {\n    if (OS)\n      *OS << Message << '\\n';\n    Broken |= TreatBrokenDebugInfoAsError;\n    BrokenDebugInfo = true;\n  }\n\n  /// A debug info check failed (with values to print).\n  template <typename T1, typename... Ts>\n  void DebugInfoCheckFailed(const Twine &Message, const T1 &V1,\n                            const Ts &... Vs) {\n    DebugInfoCheckFailed(Message);\n    if (OS)\n      WriteTs(V1, Vs...);\n  }\n};\n\n} // namespace llvm\n\nnamespace {\n\nclass Verifier : public InstVisitor<Verifier>, VerifierSupport {\n  friend class InstVisitor<Verifier>;\n\n  DominatorTree DT;\n\n  /// When verifying a basic block, keep track of all of the\n  /// instructions we have seen so far.\n  ///\n  /// This allows us to do efficient dominance checks for the case when an\n  /// instruction has an operand that is an instruction in the same block.\n  SmallPtrSet<Instruction *, 16> InstsInThisBlock;\n\n  /// Keep track of the metadata nodes that have been checked already.\n  SmallPtrSet<const Metadata *, 32> MDNodes;\n\n  /// Keep track which DISubprogram is attached to which function.\n  DenseMap<const DISubprogram *, const Function *> DISubprogramAttachments;\n\n  /// Track all DICompileUnits visited.\n  SmallPtrSet<const Metadata *, 2> CUVisited;\n\n  /// The result type for a landingpad.\n  Type *LandingPadResultTy;\n\n  /// Whether we've seen a call to @llvm.localescape in this function\n  /// already.\n  bool SawFrameEscape;\n\n  /// Whether the current function has a DISubprogram attached to it.\n  bool HasDebugInfo = false;\n\n  /// The current source language.\n  dwarf::SourceLanguage CurrentSourceLang = dwarf::DW_LANG_lo_user;\n\n  /// Whether source was present on the first DIFile encountered in each CU.\n  DenseMap<const DICompileUnit *, bool> HasSourceDebugInfo;\n\n  /// Stores the count of how many objects were passed to llvm.localescape for a\n  /// given function and the largest index passed to llvm.localrecover.\n  DenseMap<Function *, std::pair<unsigned, unsigned>> FrameEscapeInfo;\n\n  // Maps catchswitches and cleanuppads that unwind to siblings to the\n  // terminators that indicate the unwind, used to detect cycles therein.\n  MapVector<Instruction *, Instruction *> SiblingFuncletInfo;\n\n  /// Cache of constants visited in search of ConstantExprs.\n  SmallPtrSet<const Constant *, 32> ConstantExprVisited;\n\n  /// Cache of declarations of the llvm.experimental.deoptimize.<ty> intrinsic.\n  SmallVector<const Function *, 4> DeoptimizeDeclarations;\n\n  // Verify that this GlobalValue is only used in this module.\n  // This map is used to avoid visiting uses twice. We can arrive at a user\n  // twice, if they have multiple operands. In particular for very large\n  // constant expressions, we can arrive at a particular user many times.\n  SmallPtrSet<const Value *, 32> GlobalValueVisited;\n\n  // Keeps track of duplicate function argument debug info.\n  SmallVector<const DILocalVariable *, 16> DebugFnArgs;\n\n  TBAAVerifier TBAAVerifyHelper;\n\n  SmallVector<IntrinsicInst *, 4> NoAliasScopeDecls;\n\n  void checkAtomicMemAccessSize(Type *Ty, const Instruction *I);\n\npublic:\n  explicit Verifier(raw_ostream *OS, bool ShouldTreatBrokenDebugInfoAsError,\n                    const Module &M)\n      : VerifierSupport(OS, M), LandingPadResultTy(nullptr),\n        SawFrameEscape(false), TBAAVerifyHelper(this) {\n    TreatBrokenDebugInfoAsError = ShouldTreatBrokenDebugInfoAsError;\n  }\n\n  bool hasBrokenDebugInfo() const { return BrokenDebugInfo; }\n\n  bool verify(const Function &F) {\n    assert(F.getParent() == &M &&\n           \"An instance of this class only works with a specific module!\");\n\n    // First ensure the function is well-enough formed to compute dominance\n    // information, and directly compute a dominance tree. We don't rely on the\n    // pass manager to provide this as it isolates us from a potentially\n    // out-of-date dominator tree and makes it significantly more complex to run\n    // this code outside of a pass manager.\n    // FIXME: It's really gross that we have to cast away constness here.\n    if (!F.empty())\n      DT.recalculate(const_cast<Function &>(F));\n\n    for (const BasicBlock &BB : F) {\n      if (!BB.empty() && BB.back().isTerminator())\n        continue;\n\n      if (OS) {\n        *OS << \"Basic Block in function '\" << F.getName()\n            << \"' does not have terminator!\\n\";\n        BB.printAsOperand(*OS, true, MST);\n        *OS << \"\\n\";\n      }\n      return false;\n    }\n\n    Broken = false;\n    // FIXME: We strip const here because the inst visitor strips const.\n    visit(const_cast<Function &>(F));\n    verifySiblingFuncletUnwinds();\n    InstsInThisBlock.clear();\n    DebugFnArgs.clear();\n    LandingPadResultTy = nullptr;\n    SawFrameEscape = false;\n    SiblingFuncletInfo.clear();\n    verifyNoAliasScopeDecl();\n    NoAliasScopeDecls.clear();\n\n    return !Broken;\n  }\n\n  /// Verify the module that this instance of \\c Verifier was initialized with.\n  bool verify() {\n    Broken = false;\n\n    // Collect all declarations of the llvm.experimental.deoptimize intrinsic.\n    for (const Function &F : M)\n      if (F.getIntrinsicID() == Intrinsic::experimental_deoptimize)\n        DeoptimizeDeclarations.push_back(&F);\n\n    // Now that we've visited every function, verify that we never asked to\n    // recover a frame index that wasn't escaped.\n    verifyFrameRecoverIndices();\n    for (const GlobalVariable &GV : M.globals())\n      visitGlobalVariable(GV);\n\n    for (const GlobalAlias &GA : M.aliases())\n      visitGlobalAlias(GA);\n\n    for (const NamedMDNode &NMD : M.named_metadata())\n      visitNamedMDNode(NMD);\n\n    for (const StringMapEntry<Comdat> &SMEC : M.getComdatSymbolTable())\n      visitComdat(SMEC.getValue());\n\n    visitModuleFlags(M);\n    visitModuleIdents(M);\n    visitModuleCommandLines(M);\n\n    verifyCompileUnits();\n\n    verifyDeoptimizeCallingConvs();\n    DISubprogramAttachments.clear();\n    return !Broken;\n  }\n\nprivate:\n  /// Whether a metadata node is allowed to be, or contain, a DILocation.\n  enum class AreDebugLocsAllowed { No, Yes };\n\n  // Verification methods...\n  void visitGlobalValue(const GlobalValue &GV);\n  void visitGlobalVariable(const GlobalVariable &GV);\n  void visitGlobalAlias(const GlobalAlias &GA);\n  void visitAliaseeSubExpr(const GlobalAlias &A, const Constant &C);\n  void visitAliaseeSubExpr(SmallPtrSetImpl<const GlobalAlias *> &Visited,\n                           const GlobalAlias &A, const Constant &C);\n  void visitNamedMDNode(const NamedMDNode &NMD);\n  void visitMDNode(const MDNode &MD, AreDebugLocsAllowed AllowLocs);\n  void visitMetadataAsValue(const MetadataAsValue &MD, Function *F);\n  void visitValueAsMetadata(const ValueAsMetadata &MD, Function *F);\n  void visitComdat(const Comdat &C);\n  void visitModuleIdents(const Module &M);\n  void visitModuleCommandLines(const Module &M);\n  void visitModuleFlags(const Module &M);\n  void visitModuleFlag(const MDNode *Op,\n                       DenseMap<const MDString *, const MDNode *> &SeenIDs,\n                       SmallVectorImpl<const MDNode *> &Requirements);\n  void visitModuleFlagCGProfileEntry(const MDOperand &MDO);\n  void visitFunction(const Function &F);\n  void visitBasicBlock(BasicBlock &BB);\n  void visitRangeMetadata(Instruction &I, MDNode *Range, Type *Ty);\n  void visitDereferenceableMetadata(Instruction &I, MDNode *MD);\n  void visitProfMetadata(Instruction &I, MDNode *MD);\n  void visitAnnotationMetadata(MDNode *Annotation);\n\n  template <class Ty> bool isValidMetadataArray(const MDTuple &N);\n#define HANDLE_SPECIALIZED_MDNODE_LEAF(CLASS) void visit##CLASS(const CLASS &N);\n#include \"llvm/IR/Metadata.def\"\n  void visitDIScope(const DIScope &N);\n  void visitDIVariable(const DIVariable &N);\n  void visitDILexicalBlockBase(const DILexicalBlockBase &N);\n  void visitDITemplateParameter(const DITemplateParameter &N);\n\n  void visitTemplateParams(const MDNode &N, const Metadata &RawParams);\n\n  // InstVisitor overrides...\n  using InstVisitor<Verifier>::visit;\n  void visit(Instruction &I);\n\n  void visitTruncInst(TruncInst &I);\n  void visitZExtInst(ZExtInst &I);\n  void visitSExtInst(SExtInst &I);\n  void visitFPTruncInst(FPTruncInst &I);\n  void visitFPExtInst(FPExtInst &I);\n  void visitFPToUIInst(FPToUIInst &I);\n  void visitFPToSIInst(FPToSIInst &I);\n  void visitUIToFPInst(UIToFPInst &I);\n  void visitSIToFPInst(SIToFPInst &I);\n  void visitIntToPtrInst(IntToPtrInst &I);\n  void visitPtrToIntInst(PtrToIntInst &I);\n  void visitBitCastInst(BitCastInst &I);\n  void visitAddrSpaceCastInst(AddrSpaceCastInst &I);\n  void visitPHINode(PHINode &PN);\n  void visitCallBase(CallBase &Call);\n  void visitUnaryOperator(UnaryOperator &U);\n  void visitBinaryOperator(BinaryOperator &B);\n  void visitICmpInst(ICmpInst &IC);\n  void visitFCmpInst(FCmpInst &FC);\n  void visitExtractElementInst(ExtractElementInst &EI);\n  void visitInsertElementInst(InsertElementInst &EI);\n  void visitShuffleVectorInst(ShuffleVectorInst &EI);\n  void visitVAArgInst(VAArgInst &VAA) { visitInstruction(VAA); }\n  void visitCallInst(CallInst &CI);\n  void visitInvokeInst(InvokeInst &II);\n  void visitGetElementPtrInst(GetElementPtrInst &GEP);\n  void visitLoadInst(LoadInst &LI);\n  void visitStoreInst(StoreInst &SI);\n  void verifyDominatesUse(Instruction &I, unsigned i);\n  void visitInstruction(Instruction &I);\n  void visitTerminator(Instruction &I);\n  void visitBranchInst(BranchInst &BI);\n  void visitReturnInst(ReturnInst &RI);\n  void visitSwitchInst(SwitchInst &SI);\n  void visitIndirectBrInst(IndirectBrInst &BI);\n  void visitCallBrInst(CallBrInst &CBI);\n  void visitSelectInst(SelectInst &SI);\n  void visitUserOp1(Instruction &I);\n  void visitUserOp2(Instruction &I) { visitUserOp1(I); }\n  void visitIntrinsicCall(Intrinsic::ID ID, CallBase &Call);\n  void visitConstrainedFPIntrinsic(ConstrainedFPIntrinsic &FPI);\n  void visitDbgIntrinsic(StringRef Kind, DbgVariableIntrinsic &DII);\n  void visitDbgLabelIntrinsic(StringRef Kind, DbgLabelInst &DLI);\n  void visitAtomicCmpXchgInst(AtomicCmpXchgInst &CXI);\n  void visitAtomicRMWInst(AtomicRMWInst &RMWI);\n  void visitFenceInst(FenceInst &FI);\n  void visitAllocaInst(AllocaInst &AI);\n  void visitExtractValueInst(ExtractValueInst &EVI);\n  void visitInsertValueInst(InsertValueInst &IVI);\n  void visitEHPadPredecessors(Instruction &I);\n  void visitLandingPadInst(LandingPadInst &LPI);\n  void visitResumeInst(ResumeInst &RI);\n  void visitCatchPadInst(CatchPadInst &CPI);\n  void visitCatchReturnInst(CatchReturnInst &CatchReturn);\n  void visitCleanupPadInst(CleanupPadInst &CPI);\n  void visitFuncletPadInst(FuncletPadInst &FPI);\n  void visitCatchSwitchInst(CatchSwitchInst &CatchSwitch);\n  void visitCleanupReturnInst(CleanupReturnInst &CRI);\n\n  void verifySwiftErrorCall(CallBase &Call, const Value *SwiftErrorVal);\n  void verifySwiftErrorValue(const Value *SwiftErrorVal);\n  void verifyMustTailCall(CallInst &CI);\n  bool verifyAttributeCount(AttributeList Attrs, unsigned Params);\n  void verifyAttributeTypes(AttributeSet Attrs, bool IsFunction,\n                            const Value *V);\n  void verifyParameterAttrs(AttributeSet Attrs, Type *Ty, const Value *V);\n  void verifyFunctionAttrs(FunctionType *FT, AttributeList Attrs,\n                           const Value *V, bool IsIntrinsic);\n  void verifyFunctionMetadata(ArrayRef<std::pair<unsigned, MDNode *>> MDs);\n\n  void visitConstantExprsRecursively(const Constant *EntryC);\n  void visitConstantExpr(const ConstantExpr *CE);\n  void verifyStatepoint(const CallBase &Call);\n  void verifyFrameRecoverIndices();\n  void verifySiblingFuncletUnwinds();\n\n  void verifyFragmentExpression(const DbgVariableIntrinsic &I);\n  template <typename ValueOrMetadata>\n  void verifyFragmentExpression(const DIVariable &V,\n                                DIExpression::FragmentInfo Fragment,\n                                ValueOrMetadata *Desc);\n  void verifyFnArgs(const DbgVariableIntrinsic &I);\n  void verifyNotEntryValue(const DbgVariableIntrinsic &I);\n\n  /// Module-level debug info verification...\n  void verifyCompileUnits();\n\n  /// Module-level verification that all @llvm.experimental.deoptimize\n  /// declarations share the same calling convention.\n  void verifyDeoptimizeCallingConvs();\n\n  /// Verify all-or-nothing property of DIFile source attribute within a CU.\n  void verifySourceDebugInfo(const DICompileUnit &U, const DIFile &F);\n\n  /// Verify the llvm.experimental.noalias.scope.decl declarations\n  void verifyNoAliasScopeDecl();\n};\n\n} // end anonymous namespace\n\n/// We know that cond should be true, if not print an error message.\n#define Assert(C, ...) \\\n  do { if (!(C)) { CheckFailed(__VA_ARGS__); return; } } while (false)\n\n/// We know that a debug info condition should be true, if not print\n/// an error message.\n#define AssertDI(C, ...) \\\n  do { if (!(C)) { DebugInfoCheckFailed(__VA_ARGS__); return; } } while (false)\n\nvoid Verifier::visit(Instruction &I) {\n  for (unsigned i = 0, e = I.getNumOperands(); i != e; ++i)\n    Assert(I.getOperand(i) != nullptr, \"Operand is null\", &I);\n  InstVisitor<Verifier>::visit(I);\n}\n\n// Helper to recursively iterate over indirect users. By\n// returning false, the callback can ask to stop recursing\n// further.\nstatic void forEachUser(const Value *User,\n                        SmallPtrSet<const Value *, 32> &Visited,\n                        llvm::function_ref<bool(const Value *)> Callback) {\n  if (!Visited.insert(User).second)\n    return;\n  for (const Value *TheNextUser : User->materialized_users())\n    if (Callback(TheNextUser))\n      forEachUser(TheNextUser, Visited, Callback);\n}\n\nvoid Verifier::visitGlobalValue(const GlobalValue &GV) {\n  Assert(!GV.isDeclaration() || GV.hasValidDeclarationLinkage(),\n         \"Global is external, but doesn't have external or weak linkage!\", &GV);\n\n  if (const GlobalObject *GO = dyn_cast<GlobalObject>(&GV))\n    Assert(GO->getAlignment() <= Value::MaximumAlignment,\n           \"huge alignment values are unsupported\", GO);\n  Assert(!GV.hasAppendingLinkage() || isa<GlobalVariable>(GV),\n         \"Only global variables can have appending linkage!\", &GV);\n\n  if (GV.hasAppendingLinkage()) {\n    const GlobalVariable *GVar = dyn_cast<GlobalVariable>(&GV);\n    Assert(GVar && GVar->getValueType()->isArrayTy(),\n           \"Only global arrays can have appending linkage!\", GVar);\n  }\n\n  if (GV.isDeclarationForLinker())\n    Assert(!GV.hasComdat(), \"Declaration may not be in a Comdat!\", &GV);\n\n  if (GV.hasDLLImportStorageClass()) {\n    Assert(!GV.isDSOLocal(),\n           \"GlobalValue with DLLImport Storage is dso_local!\", &GV);\n\n    Assert((GV.isDeclaration() &&\n            (GV.hasExternalLinkage() || GV.hasExternalWeakLinkage())) ||\n               GV.hasAvailableExternallyLinkage(),\n           \"Global is marked as dllimport, but not external\", &GV);\n  }\n\n  if (GV.isImplicitDSOLocal())\n    Assert(GV.isDSOLocal(),\n           \"GlobalValue with local linkage or non-default \"\n           \"visibility must be dso_local!\",\n           &GV);\n\n  forEachUser(&GV, GlobalValueVisited, [&](const Value *V) -> bool {\n    if (const Instruction *I = dyn_cast<Instruction>(V)) {\n      if (!I->getParent() || !I->getParent()->getParent())\n        CheckFailed(\"Global is referenced by parentless instruction!\", &GV, &M,\n                    I);\n      else if (I->getParent()->getParent()->getParent() != &M)\n        CheckFailed(\"Global is referenced in a different module!\", &GV, &M, I,\n                    I->getParent()->getParent(),\n                    I->getParent()->getParent()->getParent());\n      return false;\n    } else if (const Function *F = dyn_cast<Function>(V)) {\n      if (F->getParent() != &M)\n        CheckFailed(\"Global is used by function in a different module\", &GV, &M,\n                    F, F->getParent());\n      return false;\n    }\n    return true;\n  });\n}\n\nvoid Verifier::visitGlobalVariable(const GlobalVariable &GV) {\n  if (GV.hasInitializer()) {\n    Assert(GV.getInitializer()->getType() == GV.getValueType(),\n           \"Global variable initializer type does not match global \"\n           \"variable type!\",\n           &GV);\n    // If the global has common linkage, it must have a zero initializer and\n    // cannot be constant.\n    if (GV.hasCommonLinkage()) {\n      Assert(GV.getInitializer()->isNullValue(),\n             \"'common' global must have a zero initializer!\", &GV);\n      Assert(!GV.isConstant(), \"'common' global may not be marked constant!\",\n             &GV);\n      Assert(!GV.hasComdat(), \"'common' global may not be in a Comdat!\", &GV);\n    }\n  }\n\n  if (GV.hasName() && (GV.getName() == \"llvm.global_ctors\" ||\n                       GV.getName() == \"llvm.global_dtors\")) {\n    Assert(!GV.hasInitializer() || GV.hasAppendingLinkage(),\n           \"invalid linkage for intrinsic global variable\", &GV);\n    // Don't worry about emitting an error for it not being an array,\n    // visitGlobalValue will complain on appending non-array.\n    if (ArrayType *ATy = dyn_cast<ArrayType>(GV.getValueType())) {\n      StructType *STy = dyn_cast<StructType>(ATy->getElementType());\n      PointerType *FuncPtrTy =\n          FunctionType::get(Type::getVoidTy(Context), false)->\n          getPointerTo(DL.getProgramAddressSpace());\n      Assert(STy &&\n                 (STy->getNumElements() == 2 || STy->getNumElements() == 3) &&\n                 STy->getTypeAtIndex(0u)->isIntegerTy(32) &&\n                 STy->getTypeAtIndex(1) == FuncPtrTy,\n             \"wrong type for intrinsic global variable\", &GV);\n      Assert(STy->getNumElements() == 3,\n             \"the third field of the element type is mandatory, \"\n             \"specify i8* null to migrate from the obsoleted 2-field form\");\n      Type *ETy = STy->getTypeAtIndex(2);\n      Assert(ETy->isPointerTy() &&\n                 cast<PointerType>(ETy)->getElementType()->isIntegerTy(8),\n             \"wrong type for intrinsic global variable\", &GV);\n    }\n  }\n\n  if (GV.hasName() && (GV.getName() == \"llvm.used\" ||\n                       GV.getName() == \"llvm.compiler.used\")) {\n    Assert(!GV.hasInitializer() || GV.hasAppendingLinkage(),\n           \"invalid linkage for intrinsic global variable\", &GV);\n    Type *GVType = GV.getValueType();\n    if (ArrayType *ATy = dyn_cast<ArrayType>(GVType)) {\n      PointerType *PTy = dyn_cast<PointerType>(ATy->getElementType());\n      Assert(PTy, \"wrong type for intrinsic global variable\", &GV);\n      if (GV.hasInitializer()) {\n        const Constant *Init = GV.getInitializer();\n        const ConstantArray *InitArray = dyn_cast<ConstantArray>(Init);\n        Assert(InitArray, \"wrong initalizer for intrinsic global variable\",\n               Init);\n        for (Value *Op : InitArray->operands()) {\n          Value *V = Op->stripPointerCasts();\n          Assert(isa<GlobalVariable>(V) || isa<Function>(V) ||\n                     isa<GlobalAlias>(V),\n                 \"invalid llvm.used member\", V);\n          Assert(V->hasName(), \"members of llvm.used must be named\", V);\n        }\n      }\n    }\n  }\n\n  // Visit any debug info attachments.\n  SmallVector<MDNode *, 1> MDs;\n  GV.getMetadata(LLVMContext::MD_dbg, MDs);\n  for (auto *MD : MDs) {\n    if (auto *GVE = dyn_cast<DIGlobalVariableExpression>(MD))\n      visitDIGlobalVariableExpression(*GVE);\n    else\n      AssertDI(false, \"!dbg attachment of global variable must be a \"\n                      \"DIGlobalVariableExpression\");\n  }\n\n  // Scalable vectors cannot be global variables, since we don't know\n  // the runtime size. If the global is an array containing scalable vectors,\n  // that will be caught by the isValidElementType methods in StructType or\n  // ArrayType instead.\n  Assert(!isa<ScalableVectorType>(GV.getValueType()),\n         \"Globals cannot contain scalable vectors\", &GV);\n\n  if (auto *STy = dyn_cast<StructType>(GV.getValueType()))\n    Assert(!STy->containsScalableVectorType(),\n           \"Globals cannot contain scalable vectors\", &GV);\n\n  if (!GV.hasInitializer()) {\n    visitGlobalValue(GV);\n    return;\n  }\n\n  // Walk any aggregate initializers looking for bitcasts between address spaces\n  visitConstantExprsRecursively(GV.getInitializer());\n\n  visitGlobalValue(GV);\n}\n\nvoid Verifier::visitAliaseeSubExpr(const GlobalAlias &GA, const Constant &C) {\n  SmallPtrSet<const GlobalAlias*, 4> Visited;\n  Visited.insert(&GA);\n  visitAliaseeSubExpr(Visited, GA, C);\n}\n\nvoid Verifier::visitAliaseeSubExpr(SmallPtrSetImpl<const GlobalAlias*> &Visited,\n                                   const GlobalAlias &GA, const Constant &C) {\n  if (const auto *GV = dyn_cast<GlobalValue>(&C)) {\n    Assert(!GV->isDeclarationForLinker(), \"Alias must point to a definition\",\n           &GA);\n\n    if (const auto *GA2 = dyn_cast<GlobalAlias>(GV)) {\n      Assert(Visited.insert(GA2).second, \"Aliases cannot form a cycle\", &GA);\n\n      Assert(!GA2->isInterposable(), \"Alias cannot point to an interposable alias\",\n             &GA);\n    } else {\n      // Only continue verifying subexpressions of GlobalAliases.\n      // Do not recurse into global initializers.\n      return;\n    }\n  }\n\n  if (const auto *CE = dyn_cast<ConstantExpr>(&C))\n    visitConstantExprsRecursively(CE);\n\n  for (const Use &U : C.operands()) {\n    Value *V = &*U;\n    if (const auto *GA2 = dyn_cast<GlobalAlias>(V))\n      visitAliaseeSubExpr(Visited, GA, *GA2->getAliasee());\n    else if (const auto *C2 = dyn_cast<Constant>(V))\n      visitAliaseeSubExpr(Visited, GA, *C2);\n  }\n}\n\nvoid Verifier::visitGlobalAlias(const GlobalAlias &GA) {\n  Assert(GlobalAlias::isValidLinkage(GA.getLinkage()),\n         \"Alias should have private, internal, linkonce, weak, linkonce_odr, \"\n         \"weak_odr, or external linkage!\",\n         &GA);\n  const Constant *Aliasee = GA.getAliasee();\n  Assert(Aliasee, \"Aliasee cannot be NULL!\", &GA);\n  Assert(GA.getType() == Aliasee->getType(),\n         \"Alias and aliasee types should match!\", &GA);\n\n  Assert(isa<GlobalValue>(Aliasee) || isa<ConstantExpr>(Aliasee),\n         \"Aliasee should be either GlobalValue or ConstantExpr\", &GA);\n\n  visitAliaseeSubExpr(GA, *Aliasee);\n\n  visitGlobalValue(GA);\n}\n\nvoid Verifier::visitNamedMDNode(const NamedMDNode &NMD) {\n  // There used to be various other llvm.dbg.* nodes, but we don't support\n  // upgrading them and we want to reserve the namespace for future uses.\n  if (NMD.getName().startswith(\"llvm.dbg.\"))\n    AssertDI(NMD.getName() == \"llvm.dbg.cu\",\n             \"unrecognized named metadata node in the llvm.dbg namespace\",\n             &NMD);\n  for (const MDNode *MD : NMD.operands()) {\n    if (NMD.getName() == \"llvm.dbg.cu\")\n      AssertDI(MD && isa<DICompileUnit>(MD), \"invalid compile unit\", &NMD, MD);\n\n    if (!MD)\n      continue;\n\n    visitMDNode(*MD, AreDebugLocsAllowed::Yes);\n  }\n}\n\nvoid Verifier::visitMDNode(const MDNode &MD, AreDebugLocsAllowed AllowLocs) {\n  // Only visit each node once.  Metadata can be mutually recursive, so this\n  // avoids infinite recursion here, as well as being an optimization.\n  if (!MDNodes.insert(&MD).second)\n    return;\n\n  switch (MD.getMetadataID()) {\n  default:\n    llvm_unreachable(\"Invalid MDNode subclass\");\n  case Metadata::MDTupleKind:\n    break;\n#define HANDLE_SPECIALIZED_MDNODE_LEAF(CLASS)                                  \\\n  case Metadata::CLASS##Kind:                                                  \\\n    visit##CLASS(cast<CLASS>(MD));                                             \\\n    break;\n#include \"llvm/IR/Metadata.def\"\n  }\n\n  for (const Metadata *Op : MD.operands()) {\n    if (!Op)\n      continue;\n    Assert(!isa<LocalAsMetadata>(Op), \"Invalid operand for global metadata!\",\n           &MD, Op);\n    AssertDI(!isa<DILocation>(Op) || AllowLocs == AreDebugLocsAllowed::Yes,\n             \"DILocation not allowed within this metadata node\", &MD, Op);\n    if (auto *N = dyn_cast<MDNode>(Op)) {\n      visitMDNode(*N, AllowLocs);\n      continue;\n    }\n    if (auto *V = dyn_cast<ValueAsMetadata>(Op)) {\n      visitValueAsMetadata(*V, nullptr);\n      continue;\n    }\n  }\n\n  // Check these last, so we diagnose problems in operands first.\n  Assert(!MD.isTemporary(), \"Expected no forward declarations!\", &MD);\n  Assert(MD.isResolved(), \"All nodes should be resolved!\", &MD);\n}\n\nvoid Verifier::visitValueAsMetadata(const ValueAsMetadata &MD, Function *F) {\n  Assert(MD.getValue(), \"Expected valid value\", &MD);\n  Assert(!MD.getValue()->getType()->isMetadataTy(),\n         \"Unexpected metadata round-trip through values\", &MD, MD.getValue());\n\n  auto *L = dyn_cast<LocalAsMetadata>(&MD);\n  if (!L)\n    return;\n\n  Assert(F, \"function-local metadata used outside a function\", L);\n\n  // If this was an instruction, bb, or argument, verify that it is in the\n  // function that we expect.\n  Function *ActualF = nullptr;\n  if (Instruction *I = dyn_cast<Instruction>(L->getValue())) {\n    Assert(I->getParent(), \"function-local metadata not in basic block\", L, I);\n    ActualF = I->getParent()->getParent();\n  } else if (BasicBlock *BB = dyn_cast<BasicBlock>(L->getValue()))\n    ActualF = BB->getParent();\n  else if (Argument *A = dyn_cast<Argument>(L->getValue()))\n    ActualF = A->getParent();\n  assert(ActualF && \"Unimplemented function local metadata case!\");\n\n  Assert(ActualF == F, \"function-local metadata used in wrong function\", L);\n}\n\nvoid Verifier::visitMetadataAsValue(const MetadataAsValue &MDV, Function *F) {\n  Metadata *MD = MDV.getMetadata();\n  if (auto *N = dyn_cast<MDNode>(MD)) {\n    visitMDNode(*N, AreDebugLocsAllowed::No);\n    return;\n  }\n\n  // Only visit each node once.  Metadata can be mutually recursive, so this\n  // avoids infinite recursion here, as well as being an optimization.\n  if (!MDNodes.insert(MD).second)\n    return;\n\n  if (auto *V = dyn_cast<ValueAsMetadata>(MD))\n    visitValueAsMetadata(*V, F);\n}\n\nstatic bool isType(const Metadata *MD) { return !MD || isa<DIType>(MD); }\nstatic bool isScope(const Metadata *MD) { return !MD || isa<DIScope>(MD); }\nstatic bool isDINode(const Metadata *MD) { return !MD || isa<DINode>(MD); }\n\nvoid Verifier::visitDILocation(const DILocation &N) {\n  AssertDI(N.getRawScope() && isa<DILocalScope>(N.getRawScope()),\n           \"location requires a valid scope\", &N, N.getRawScope());\n  if (auto *IA = N.getRawInlinedAt())\n    AssertDI(isa<DILocation>(IA), \"inlined-at should be a location\", &N, IA);\n  if (auto *SP = dyn_cast<DISubprogram>(N.getRawScope()))\n    AssertDI(SP->isDefinition(), \"scope points into the type hierarchy\", &N);\n}\n\nvoid Verifier::visitGenericDINode(const GenericDINode &N) {\n  AssertDI(N.getTag(), \"invalid tag\", &N);\n}\n\nvoid Verifier::visitDIScope(const DIScope &N) {\n  if (auto *F = N.getRawFile())\n    AssertDI(isa<DIFile>(F), \"invalid file\", &N, F);\n}\n\nvoid Verifier::visitDISubrange(const DISubrange &N) {\n  AssertDI(N.getTag() == dwarf::DW_TAG_subrange_type, \"invalid tag\", &N);\n  bool HasAssumedSizedArraySupport = dwarf::isFortran(CurrentSourceLang);\n  AssertDI(HasAssumedSizedArraySupport || N.getRawCountNode() ||\n               N.getRawUpperBound(),\n           \"Subrange must contain count or upperBound\", &N);\n  AssertDI(!N.getRawCountNode() || !N.getRawUpperBound(),\n           \"Subrange can have any one of count or upperBound\", &N);\n  AssertDI(!N.getRawCountNode() || N.getCount(),\n           \"Count must either be a signed constant or a DIVariable\", &N);\n  auto Count = N.getCount();\n  AssertDI(!Count || !Count.is<ConstantInt *>() ||\n               Count.get<ConstantInt *>()->getSExtValue() >= -1,\n           \"invalid subrange count\", &N);\n  auto *LBound = N.getRawLowerBound();\n  AssertDI(!LBound || isa<ConstantAsMetadata>(LBound) ||\n               isa<DIVariable>(LBound) || isa<DIExpression>(LBound),\n           \"LowerBound must be signed constant or DIVariable or DIExpression\",\n           &N);\n  auto *UBound = N.getRawUpperBound();\n  AssertDI(!UBound || isa<ConstantAsMetadata>(UBound) ||\n               isa<DIVariable>(UBound) || isa<DIExpression>(UBound),\n           \"UpperBound must be signed constant or DIVariable or DIExpression\",\n           &N);\n  auto *Stride = N.getRawStride();\n  AssertDI(!Stride || isa<ConstantAsMetadata>(Stride) ||\n               isa<DIVariable>(Stride) || isa<DIExpression>(Stride),\n           \"Stride must be signed constant or DIVariable or DIExpression\", &N);\n}\n\nvoid Verifier::visitDIGenericSubrange(const DIGenericSubrange &N) {\n  AssertDI(N.getTag() == dwarf::DW_TAG_generic_subrange, \"invalid tag\", &N);\n  AssertDI(N.getRawCountNode() || N.getRawUpperBound(),\n           \"GenericSubrange must contain count or upperBound\", &N);\n  AssertDI(!N.getRawCountNode() || !N.getRawUpperBound(),\n           \"GenericSubrange can have any one of count or upperBound\", &N);\n  auto *CBound = N.getRawCountNode();\n  AssertDI(!CBound || isa<DIVariable>(CBound) || isa<DIExpression>(CBound),\n           \"Count must be signed constant or DIVariable or DIExpression\", &N);\n  auto *LBound = N.getRawLowerBound();\n  AssertDI(LBound, \"GenericSubrange must contain lowerBound\", &N);\n  AssertDI(isa<DIVariable>(LBound) || isa<DIExpression>(LBound),\n           \"LowerBound must be signed constant or DIVariable or DIExpression\",\n           &N);\n  auto *UBound = N.getRawUpperBound();\n  AssertDI(!UBound || isa<DIVariable>(UBound) || isa<DIExpression>(UBound),\n           \"UpperBound must be signed constant or DIVariable or DIExpression\",\n           &N);\n  auto *Stride = N.getRawStride();\n  AssertDI(Stride, \"GenericSubrange must contain stride\", &N);\n  AssertDI(isa<DIVariable>(Stride) || isa<DIExpression>(Stride),\n           \"Stride must be signed constant or DIVariable or DIExpression\", &N);\n}\n\nvoid Verifier::visitDIEnumerator(const DIEnumerator &N) {\n  AssertDI(N.getTag() == dwarf::DW_TAG_enumerator, \"invalid tag\", &N);\n}\n\nvoid Verifier::visitDIBasicType(const DIBasicType &N) {\n  AssertDI(N.getTag() == dwarf::DW_TAG_base_type ||\n               N.getTag() == dwarf::DW_TAG_unspecified_type ||\n               N.getTag() == dwarf::DW_TAG_string_type,\n           \"invalid tag\", &N);\n}\n\nvoid Verifier::visitDIStringType(const DIStringType &N) {\n  AssertDI(N.getTag() == dwarf::DW_TAG_string_type, \"invalid tag\", &N);\n  AssertDI(!(N.isBigEndian() && N.isLittleEndian()) ,\n            \"has conflicting flags\", &N);\n}\n\nvoid Verifier::visitDIDerivedType(const DIDerivedType &N) {\n  // Common scope checks.\n  visitDIScope(N);\n\n  AssertDI(N.getTag() == dwarf::DW_TAG_typedef ||\n               N.getTag() == dwarf::DW_TAG_pointer_type ||\n               N.getTag() == dwarf::DW_TAG_ptr_to_member_type ||\n               N.getTag() == dwarf::DW_TAG_reference_type ||\n               N.getTag() == dwarf::DW_TAG_rvalue_reference_type ||\n               N.getTag() == dwarf::DW_TAG_const_type ||\n               N.getTag() == dwarf::DW_TAG_volatile_type ||\n               N.getTag() == dwarf::DW_TAG_restrict_type ||\n               N.getTag() == dwarf::DW_TAG_atomic_type ||\n               N.getTag() == dwarf::DW_TAG_member ||\n               N.getTag() == dwarf::DW_TAG_inheritance ||\n               N.getTag() == dwarf::DW_TAG_friend,\n           \"invalid tag\", &N);\n  if (N.getTag() == dwarf::DW_TAG_ptr_to_member_type) {\n    AssertDI(isType(N.getRawExtraData()), \"invalid pointer to member type\", &N,\n             N.getRawExtraData());\n  }\n\n  AssertDI(isScope(N.getRawScope()), \"invalid scope\", &N, N.getRawScope());\n  AssertDI(isType(N.getRawBaseType()), \"invalid base type\", &N,\n           N.getRawBaseType());\n\n  if (N.getDWARFAddressSpace()) {\n    AssertDI(N.getTag() == dwarf::DW_TAG_pointer_type ||\n                 N.getTag() == dwarf::DW_TAG_reference_type ||\n                 N.getTag() == dwarf::DW_TAG_rvalue_reference_type,\n             \"DWARF address space only applies to pointer or reference types\",\n             &N);\n  }\n}\n\n/// Detect mutually exclusive flags.\nstatic bool hasConflictingReferenceFlags(unsigned Flags) {\n  return ((Flags & DINode::FlagLValueReference) &&\n          (Flags & DINode::FlagRValueReference)) ||\n         ((Flags & DINode::FlagTypePassByValue) &&\n          (Flags & DINode::FlagTypePassByReference));\n}\n\nvoid Verifier::visitTemplateParams(const MDNode &N, const Metadata &RawParams) {\n  auto *Params = dyn_cast<MDTuple>(&RawParams);\n  AssertDI(Params, \"invalid template params\", &N, &RawParams);\n  for (Metadata *Op : Params->operands()) {\n    AssertDI(Op && isa<DITemplateParameter>(Op), \"invalid template parameter\",\n             &N, Params, Op);\n  }\n}\n\nvoid Verifier::visitDICompositeType(const DICompositeType &N) {\n  // Common scope checks.\n  visitDIScope(N);\n\n  AssertDI(N.getTag() == dwarf::DW_TAG_array_type ||\n               N.getTag() == dwarf::DW_TAG_structure_type ||\n               N.getTag() == dwarf::DW_TAG_union_type ||\n               N.getTag() == dwarf::DW_TAG_enumeration_type ||\n               N.getTag() == dwarf::DW_TAG_class_type ||\n               N.getTag() == dwarf::DW_TAG_variant_part,\n           \"invalid tag\", &N);\n\n  AssertDI(isScope(N.getRawScope()), \"invalid scope\", &N, N.getRawScope());\n  AssertDI(isType(N.getRawBaseType()), \"invalid base type\", &N,\n           N.getRawBaseType());\n\n  AssertDI(!N.getRawElements() || isa<MDTuple>(N.getRawElements()),\n           \"invalid composite elements\", &N, N.getRawElements());\n  AssertDI(isType(N.getRawVTableHolder()), \"invalid vtable holder\", &N,\n           N.getRawVTableHolder());\n  AssertDI(!hasConflictingReferenceFlags(N.getFlags()),\n           \"invalid reference flags\", &N);\n  unsigned DIBlockByRefStruct = 1 << 4;\n  AssertDI((N.getFlags() & DIBlockByRefStruct) == 0,\n           \"DIBlockByRefStruct on DICompositeType is no longer supported\", &N);\n\n  if (N.isVector()) {\n    const DINodeArray Elements = N.getElements();\n    AssertDI(Elements.size() == 1 &&\n             Elements[0]->getTag() == dwarf::DW_TAG_subrange_type,\n             \"invalid vector, expected one element of type subrange\", &N);\n  }\n\n  if (auto *Params = N.getRawTemplateParams())\n    visitTemplateParams(N, *Params);\n\n  if (N.getTag() == dwarf::DW_TAG_class_type ||\n      N.getTag() == dwarf::DW_TAG_union_type) {\n    AssertDI(N.getFile() && !N.getFile()->getFilename().empty(),\n             \"class/union requires a filename\", &N, N.getFile());\n  }\n\n  if (auto *D = N.getRawDiscriminator()) {\n    AssertDI(isa<DIDerivedType>(D) && N.getTag() == dwarf::DW_TAG_variant_part,\n             \"discriminator can only appear on variant part\");\n  }\n\n  if (N.getRawDataLocation()) {\n    AssertDI(N.getTag() == dwarf::DW_TAG_array_type,\n             \"dataLocation can only appear in array type\");\n  }\n\n  if (N.getRawAssociated()) {\n    AssertDI(N.getTag() == dwarf::DW_TAG_array_type,\n             \"associated can only appear in array type\");\n  }\n\n  if (N.getRawAllocated()) {\n    AssertDI(N.getTag() == dwarf::DW_TAG_array_type,\n             \"allocated can only appear in array type\");\n  }\n\n  if (N.getRawRank()) {\n    AssertDI(N.getTag() == dwarf::DW_TAG_array_type,\n             \"rank can only appear in array type\");\n  }\n}\n\nvoid Verifier::visitDISubroutineType(const DISubroutineType &N) {\n  AssertDI(N.getTag() == dwarf::DW_TAG_subroutine_type, \"invalid tag\", &N);\n  if (auto *Types = N.getRawTypeArray()) {\n    AssertDI(isa<MDTuple>(Types), \"invalid composite elements\", &N, Types);\n    for (Metadata *Ty : N.getTypeArray()->operands()) {\n      AssertDI(isType(Ty), \"invalid subroutine type ref\", &N, Types, Ty);\n    }\n  }\n  AssertDI(!hasConflictingReferenceFlags(N.getFlags()),\n           \"invalid reference flags\", &N);\n}\n\nvoid Verifier::visitDIFile(const DIFile &N) {\n  AssertDI(N.getTag() == dwarf::DW_TAG_file_type, \"invalid tag\", &N);\n  Optional<DIFile::ChecksumInfo<StringRef>> Checksum = N.getChecksum();\n  if (Checksum) {\n    AssertDI(Checksum->Kind <= DIFile::ChecksumKind::CSK_Last,\n             \"invalid checksum kind\", &N);\n    size_t Size;\n    switch (Checksum->Kind) {\n    case DIFile::CSK_MD5:\n      Size = 32;\n      break;\n    case DIFile::CSK_SHA1:\n      Size = 40;\n      break;\n    case DIFile::CSK_SHA256:\n      Size = 64;\n      break;\n    }\n    AssertDI(Checksum->Value.size() == Size, \"invalid checksum length\", &N);\n    AssertDI(Checksum->Value.find_if_not(llvm::isHexDigit) == StringRef::npos,\n             \"invalid checksum\", &N);\n  }\n}\n\nvoid Verifier::visitDICompileUnit(const DICompileUnit &N) {\n  AssertDI(N.isDistinct(), \"compile units must be distinct\", &N);\n  AssertDI(N.getTag() == dwarf::DW_TAG_compile_unit, \"invalid tag\", &N);\n\n  // Don't bother verifying the compilation directory or producer string\n  // as those could be empty.\n  AssertDI(N.getRawFile() && isa<DIFile>(N.getRawFile()), \"invalid file\", &N,\n           N.getRawFile());\n  AssertDI(!N.getFile()->getFilename().empty(), \"invalid filename\", &N,\n           N.getFile());\n\n  CurrentSourceLang = (dwarf::SourceLanguage)N.getSourceLanguage();\n\n  verifySourceDebugInfo(N, *N.getFile());\n\n  AssertDI((N.getEmissionKind() <= DICompileUnit::LastEmissionKind),\n           \"invalid emission kind\", &N);\n\n  if (auto *Array = N.getRawEnumTypes()) {\n    AssertDI(isa<MDTuple>(Array), \"invalid enum list\", &N, Array);\n    for (Metadata *Op : N.getEnumTypes()->operands()) {\n      auto *Enum = dyn_cast_or_null<DICompositeType>(Op);\n      AssertDI(Enum && Enum->getTag() == dwarf::DW_TAG_enumeration_type,\n               \"invalid enum type\", &N, N.getEnumTypes(), Op);\n    }\n  }\n  if (auto *Array = N.getRawRetainedTypes()) {\n    AssertDI(isa<MDTuple>(Array), \"invalid retained type list\", &N, Array);\n    for (Metadata *Op : N.getRetainedTypes()->operands()) {\n      AssertDI(Op && (isa<DIType>(Op) ||\n                      (isa<DISubprogram>(Op) &&\n                       !cast<DISubprogram>(Op)->isDefinition())),\n               \"invalid retained type\", &N, Op);\n    }\n  }\n  if (auto *Array = N.getRawGlobalVariables()) {\n    AssertDI(isa<MDTuple>(Array), \"invalid global variable list\", &N, Array);\n    for (Metadata *Op : N.getGlobalVariables()->operands()) {\n      AssertDI(Op && (isa<DIGlobalVariableExpression>(Op)),\n               \"invalid global variable ref\", &N, Op);\n    }\n  }\n  if (auto *Array = N.getRawImportedEntities()) {\n    AssertDI(isa<MDTuple>(Array), \"invalid imported entity list\", &N, Array);\n    for (Metadata *Op : N.getImportedEntities()->operands()) {\n      AssertDI(Op && isa<DIImportedEntity>(Op), \"invalid imported entity ref\",\n               &N, Op);\n    }\n  }\n  if (auto *Array = N.getRawMacros()) {\n    AssertDI(isa<MDTuple>(Array), \"invalid macro list\", &N, Array);\n    for (Metadata *Op : N.getMacros()->operands()) {\n      AssertDI(Op && isa<DIMacroNode>(Op), \"invalid macro ref\", &N, Op);\n    }\n  }\n  CUVisited.insert(&N);\n}\n\nvoid Verifier::visitDISubprogram(const DISubprogram &N) {\n  AssertDI(N.getTag() == dwarf::DW_TAG_subprogram, \"invalid tag\", &N);\n  AssertDI(isScope(N.getRawScope()), \"invalid scope\", &N, N.getRawScope());\n  if (auto *F = N.getRawFile())\n    AssertDI(isa<DIFile>(F), \"invalid file\", &N, F);\n  else\n    AssertDI(N.getLine() == 0, \"line specified with no file\", &N, N.getLine());\n  if (auto *T = N.getRawType())\n    AssertDI(isa<DISubroutineType>(T), \"invalid subroutine type\", &N, T);\n  AssertDI(isType(N.getRawContainingType()), \"invalid containing type\", &N,\n           N.getRawContainingType());\n  if (auto *Params = N.getRawTemplateParams())\n    visitTemplateParams(N, *Params);\n  if (auto *S = N.getRawDeclaration())\n    AssertDI(isa<DISubprogram>(S) && !cast<DISubprogram>(S)->isDefinition(),\n             \"invalid subprogram declaration\", &N, S);\n  if (auto *RawNode = N.getRawRetainedNodes()) {\n    auto *Node = dyn_cast<MDTuple>(RawNode);\n    AssertDI(Node, \"invalid retained nodes list\", &N, RawNode);\n    for (Metadata *Op : Node->operands()) {\n      AssertDI(Op && (isa<DILocalVariable>(Op) || isa<DILabel>(Op)),\n               \"invalid retained nodes, expected DILocalVariable or DILabel\",\n               &N, Node, Op);\n    }\n  }\n  AssertDI(!hasConflictingReferenceFlags(N.getFlags()),\n           \"invalid reference flags\", &N);\n\n  auto *Unit = N.getRawUnit();\n  if (N.isDefinition()) {\n    // Subprogram definitions (not part of the type hierarchy).\n    AssertDI(N.isDistinct(), \"subprogram definitions must be distinct\", &N);\n    AssertDI(Unit, \"subprogram definitions must have a compile unit\", &N);\n    AssertDI(isa<DICompileUnit>(Unit), \"invalid unit type\", &N, Unit);\n    if (N.getFile())\n      verifySourceDebugInfo(*N.getUnit(), *N.getFile());\n  } else {\n    // Subprogram declarations (part of the type hierarchy).\n    AssertDI(!Unit, \"subprogram declarations must not have a compile unit\", &N);\n  }\n\n  if (auto *RawThrownTypes = N.getRawThrownTypes()) {\n    auto *ThrownTypes = dyn_cast<MDTuple>(RawThrownTypes);\n    AssertDI(ThrownTypes, \"invalid thrown types list\", &N, RawThrownTypes);\n    for (Metadata *Op : ThrownTypes->operands())\n      AssertDI(Op && isa<DIType>(Op), \"invalid thrown type\", &N, ThrownTypes,\n               Op);\n  }\n\n  if (N.areAllCallsDescribed())\n    AssertDI(N.isDefinition(),\n             \"DIFlagAllCallsDescribed must be attached to a definition\");\n}\n\nvoid Verifier::visitDILexicalBlockBase(const DILexicalBlockBase &N) {\n  AssertDI(N.getTag() == dwarf::DW_TAG_lexical_block, \"invalid tag\", &N);\n  AssertDI(N.getRawScope() && isa<DILocalScope>(N.getRawScope()),\n           \"invalid local scope\", &N, N.getRawScope());\n  if (auto *SP = dyn_cast<DISubprogram>(N.getRawScope()))\n    AssertDI(SP->isDefinition(), \"scope points into the type hierarchy\", &N);\n}\n\nvoid Verifier::visitDILexicalBlock(const DILexicalBlock &N) {\n  visitDILexicalBlockBase(N);\n\n  AssertDI(N.getLine() || !N.getColumn(),\n           \"cannot have column info without line info\", &N);\n}\n\nvoid Verifier::visitDILexicalBlockFile(const DILexicalBlockFile &N) {\n  visitDILexicalBlockBase(N);\n}\n\nvoid Verifier::visitDICommonBlock(const DICommonBlock &N) {\n  AssertDI(N.getTag() == dwarf::DW_TAG_common_block, \"invalid tag\", &N);\n  if (auto *S = N.getRawScope())\n    AssertDI(isa<DIScope>(S), \"invalid scope ref\", &N, S);\n  if (auto *S = N.getRawDecl())\n    AssertDI(isa<DIGlobalVariable>(S), \"invalid declaration\", &N, S);\n}\n\nvoid Verifier::visitDINamespace(const DINamespace &N) {\n  AssertDI(N.getTag() == dwarf::DW_TAG_namespace, \"invalid tag\", &N);\n  if (auto *S = N.getRawScope())\n    AssertDI(isa<DIScope>(S), \"invalid scope ref\", &N, S);\n}\n\nvoid Verifier::visitDIMacro(const DIMacro &N) {\n  AssertDI(N.getMacinfoType() == dwarf::DW_MACINFO_define ||\n               N.getMacinfoType() == dwarf::DW_MACINFO_undef,\n           \"invalid macinfo type\", &N);\n  AssertDI(!N.getName().empty(), \"anonymous macro\", &N);\n  if (!N.getValue().empty()) {\n    assert(N.getValue().data()[0] != ' ' && \"Macro value has a space prefix\");\n  }\n}\n\nvoid Verifier::visitDIMacroFile(const DIMacroFile &N) {\n  AssertDI(N.getMacinfoType() == dwarf::DW_MACINFO_start_file,\n           \"invalid macinfo type\", &N);\n  if (auto *F = N.getRawFile())\n    AssertDI(isa<DIFile>(F), \"invalid file\", &N, F);\n\n  if (auto *Array = N.getRawElements()) {\n    AssertDI(isa<MDTuple>(Array), \"invalid macro list\", &N, Array);\n    for (Metadata *Op : N.getElements()->operands()) {\n      AssertDI(Op && isa<DIMacroNode>(Op), \"invalid macro ref\", &N, Op);\n    }\n  }\n}\n\nvoid Verifier::visitDIModule(const DIModule &N) {\n  AssertDI(N.getTag() == dwarf::DW_TAG_module, \"invalid tag\", &N);\n  AssertDI(!N.getName().empty(), \"anonymous module\", &N);\n}\n\nvoid Verifier::visitDITemplateParameter(const DITemplateParameter &N) {\n  AssertDI(isType(N.getRawType()), \"invalid type ref\", &N, N.getRawType());\n}\n\nvoid Verifier::visitDITemplateTypeParameter(const DITemplateTypeParameter &N) {\n  visitDITemplateParameter(N);\n\n  AssertDI(N.getTag() == dwarf::DW_TAG_template_type_parameter, \"invalid tag\",\n           &N);\n}\n\nvoid Verifier::visitDITemplateValueParameter(\n    const DITemplateValueParameter &N) {\n  visitDITemplateParameter(N);\n\n  AssertDI(N.getTag() == dwarf::DW_TAG_template_value_parameter ||\n               N.getTag() == dwarf::DW_TAG_GNU_template_template_param ||\n               N.getTag() == dwarf::DW_TAG_GNU_template_parameter_pack,\n           \"invalid tag\", &N);\n}\n\nvoid Verifier::visitDIVariable(const DIVariable &N) {\n  if (auto *S = N.getRawScope())\n    AssertDI(isa<DIScope>(S), \"invalid scope\", &N, S);\n  if (auto *F = N.getRawFile())\n    AssertDI(isa<DIFile>(F), \"invalid file\", &N, F);\n}\n\nvoid Verifier::visitDIGlobalVariable(const DIGlobalVariable &N) {\n  // Checks common to all variables.\n  visitDIVariable(N);\n\n  AssertDI(N.getTag() == dwarf::DW_TAG_variable, \"invalid tag\", &N);\n  AssertDI(isType(N.getRawType()), \"invalid type ref\", &N, N.getRawType());\n  // Assert only if the global variable is not an extern\n  if (N.isDefinition())\n    AssertDI(N.getType(), \"missing global variable type\", &N);\n  if (auto *Member = N.getRawStaticDataMemberDeclaration()) {\n    AssertDI(isa<DIDerivedType>(Member),\n             \"invalid static data member declaration\", &N, Member);\n  }\n}\n\nvoid Verifier::visitDILocalVariable(const DILocalVariable &N) {\n  // Checks common to all variables.\n  visitDIVariable(N);\n\n  AssertDI(isType(N.getRawType()), \"invalid type ref\", &N, N.getRawType());\n  AssertDI(N.getTag() == dwarf::DW_TAG_variable, \"invalid tag\", &N);\n  AssertDI(N.getRawScope() && isa<DILocalScope>(N.getRawScope()),\n           \"local variable requires a valid scope\", &N, N.getRawScope());\n  if (auto Ty = N.getType())\n    AssertDI(!isa<DISubroutineType>(Ty), \"invalid type\", &N, N.getType());\n}\n\nvoid Verifier::visitDILabel(const DILabel &N) {\n  if (auto *S = N.getRawScope())\n    AssertDI(isa<DIScope>(S), \"invalid scope\", &N, S);\n  if (auto *F = N.getRawFile())\n    AssertDI(isa<DIFile>(F), \"invalid file\", &N, F);\n\n  AssertDI(N.getTag() == dwarf::DW_TAG_label, \"invalid tag\", &N);\n  AssertDI(N.getRawScope() && isa<DILocalScope>(N.getRawScope()),\n           \"label requires a valid scope\", &N, N.getRawScope());\n}\n\nvoid Verifier::visitDIExpression(const DIExpression &N) {\n  AssertDI(N.isValid(), \"invalid expression\", &N);\n}\n\nvoid Verifier::visitDIGlobalVariableExpression(\n    const DIGlobalVariableExpression &GVE) {\n  AssertDI(GVE.getVariable(), \"missing variable\");\n  if (auto *Var = GVE.getVariable())\n    visitDIGlobalVariable(*Var);\n  if (auto *Expr = GVE.getExpression()) {\n    visitDIExpression(*Expr);\n    if (auto Fragment = Expr->getFragmentInfo())\n      verifyFragmentExpression(*GVE.getVariable(), *Fragment, &GVE);\n  }\n}\n\nvoid Verifier::visitDIObjCProperty(const DIObjCProperty &N) {\n  AssertDI(N.getTag() == dwarf::DW_TAG_APPLE_property, \"invalid tag\", &N);\n  if (auto *T = N.getRawType())\n    AssertDI(isType(T), \"invalid type ref\", &N, T);\n  if (auto *F = N.getRawFile())\n    AssertDI(isa<DIFile>(F), \"invalid file\", &N, F);\n}\n\nvoid Verifier::visitDIImportedEntity(const DIImportedEntity &N) {\n  AssertDI(N.getTag() == dwarf::DW_TAG_imported_module ||\n               N.getTag() == dwarf::DW_TAG_imported_declaration,\n           \"invalid tag\", &N);\n  if (auto *S = N.getRawScope())\n    AssertDI(isa<DIScope>(S), \"invalid scope for imported entity\", &N, S);\n  AssertDI(isDINode(N.getRawEntity()), \"invalid imported entity\", &N,\n           N.getRawEntity());\n}\n\nvoid Verifier::visitComdat(const Comdat &C) {\n  // In COFF the Module is invalid if the GlobalValue has private linkage.\n  // Entities with private linkage don't have entries in the symbol table.\n  if (TT.isOSBinFormatCOFF())\n    if (const GlobalValue *GV = M.getNamedValue(C.getName()))\n      Assert(!GV->hasPrivateLinkage(),\n             \"comdat global value has private linkage\", GV);\n}\n\nvoid Verifier::visitModuleIdents(const Module &M) {\n  const NamedMDNode *Idents = M.getNamedMetadata(\"llvm.ident\");\n  if (!Idents)\n    return;\n\n  // llvm.ident takes a list of metadata entry. Each entry has only one string.\n  // Scan each llvm.ident entry and make sure that this requirement is met.\n  for (const MDNode *N : Idents->operands()) {\n    Assert(N->getNumOperands() == 1,\n           \"incorrect number of operands in llvm.ident metadata\", N);\n    Assert(dyn_cast_or_null<MDString>(N->getOperand(0)),\n           (\"invalid value for llvm.ident metadata entry operand\"\n            \"(the operand should be a string)\"),\n           N->getOperand(0));\n  }\n}\n\nvoid Verifier::visitModuleCommandLines(const Module &M) {\n  const NamedMDNode *CommandLines = M.getNamedMetadata(\"llvm.commandline\");\n  if (!CommandLines)\n    return;\n\n  // llvm.commandline takes a list of metadata entry. Each entry has only one\n  // string. Scan each llvm.commandline entry and make sure that this\n  // requirement is met.\n  for (const MDNode *N : CommandLines->operands()) {\n    Assert(N->getNumOperands() == 1,\n           \"incorrect number of operands in llvm.commandline metadata\", N);\n    Assert(dyn_cast_or_null<MDString>(N->getOperand(0)),\n           (\"invalid value for llvm.commandline metadata entry operand\"\n            \"(the operand should be a string)\"),\n           N->getOperand(0));\n  }\n}\n\nvoid Verifier::visitModuleFlags(const Module &M) {\n  const NamedMDNode *Flags = M.getModuleFlagsMetadata();\n  if (!Flags) return;\n\n  // Scan each flag, and track the flags and requirements.\n  DenseMap<const MDString*, const MDNode*> SeenIDs;\n  SmallVector<const MDNode*, 16> Requirements;\n  for (const MDNode *MDN : Flags->operands())\n    visitModuleFlag(MDN, SeenIDs, Requirements);\n\n  // Validate that the requirements in the module are valid.\n  for (const MDNode *Requirement : Requirements) {\n    const MDString *Flag = cast<MDString>(Requirement->getOperand(0));\n    const Metadata *ReqValue = Requirement->getOperand(1);\n\n    const MDNode *Op = SeenIDs.lookup(Flag);\n    if (!Op) {\n      CheckFailed(\"invalid requirement on flag, flag is not present in module\",\n                  Flag);\n      continue;\n    }\n\n    if (Op->getOperand(2) != ReqValue) {\n      CheckFailed((\"invalid requirement on flag, \"\n                   \"flag does not have the required value\"),\n                  Flag);\n      continue;\n    }\n  }\n}\n\nvoid\nVerifier::visitModuleFlag(const MDNode *Op,\n                          DenseMap<const MDString *, const MDNode *> &SeenIDs,\n                          SmallVectorImpl<const MDNode *> &Requirements) {\n  // Each module flag should have three arguments, the merge behavior (a\n  // constant int), the flag ID (an MDString), and the value.\n  Assert(Op->getNumOperands() == 3,\n         \"incorrect number of operands in module flag\", Op);\n  Module::ModFlagBehavior MFB;\n  if (!Module::isValidModFlagBehavior(Op->getOperand(0), MFB)) {\n    Assert(\n        mdconst::dyn_extract_or_null<ConstantInt>(Op->getOperand(0)),\n        \"invalid behavior operand in module flag (expected constant integer)\",\n        Op->getOperand(0));\n    Assert(false,\n           \"invalid behavior operand in module flag (unexpected constant)\",\n           Op->getOperand(0));\n  }\n  MDString *ID = dyn_cast_or_null<MDString>(Op->getOperand(1));\n  Assert(ID, \"invalid ID operand in module flag (expected metadata string)\",\n         Op->getOperand(1));\n\n  // Sanity check the values for behaviors with additional requirements.\n  switch (MFB) {\n  case Module::Error:\n  case Module::Warning:\n  case Module::Override:\n    // These behavior types accept any value.\n    break;\n\n  case Module::Max: {\n    Assert(mdconst::dyn_extract_or_null<ConstantInt>(Op->getOperand(2)),\n           \"invalid value for 'max' module flag (expected constant integer)\",\n           Op->getOperand(2));\n    break;\n  }\n\n  case Module::Require: {\n    // The value should itself be an MDNode with two operands, a flag ID (an\n    // MDString), and a value.\n    MDNode *Value = dyn_cast<MDNode>(Op->getOperand(2));\n    Assert(Value && Value->getNumOperands() == 2,\n           \"invalid value for 'require' module flag (expected metadata pair)\",\n           Op->getOperand(2));\n    Assert(isa<MDString>(Value->getOperand(0)),\n           (\"invalid value for 'require' module flag \"\n            \"(first value operand should be a string)\"),\n           Value->getOperand(0));\n\n    // Append it to the list of requirements, to check once all module flags are\n    // scanned.\n    Requirements.push_back(Value);\n    break;\n  }\n\n  case Module::Append:\n  case Module::AppendUnique: {\n    // These behavior types require the operand be an MDNode.\n    Assert(isa<MDNode>(Op->getOperand(2)),\n           \"invalid value for 'append'-type module flag \"\n           \"(expected a metadata node)\",\n           Op->getOperand(2));\n    break;\n  }\n  }\n\n  // Unless this is a \"requires\" flag, check the ID is unique.\n  if (MFB != Module::Require) {\n    bool Inserted = SeenIDs.insert(std::make_pair(ID, Op)).second;\n    Assert(Inserted,\n           \"module flag identifiers must be unique (or of 'require' type)\", ID);\n  }\n\n  if (ID->getString() == \"wchar_size\") {\n    ConstantInt *Value\n      = mdconst::dyn_extract_or_null<ConstantInt>(Op->getOperand(2));\n    Assert(Value, \"wchar_size metadata requires constant integer argument\");\n  }\n\n  if (ID->getString() == \"Linker Options\") {\n    // If the llvm.linker.options named metadata exists, we assume that the\n    // bitcode reader has upgraded the module flag. Otherwise the flag might\n    // have been created by a client directly.\n    Assert(M.getNamedMetadata(\"llvm.linker.options\"),\n           \"'Linker Options' named metadata no longer supported\");\n  }\n\n  if (ID->getString() == \"SemanticInterposition\") {\n    ConstantInt *Value =\n        mdconst::dyn_extract_or_null<ConstantInt>(Op->getOperand(2));\n    Assert(Value,\n           \"SemanticInterposition metadata requires constant integer argument\");\n  }\n\n  if (ID->getString() == \"CG Profile\") {\n    for (const MDOperand &MDO : cast<MDNode>(Op->getOperand(2))->operands())\n      visitModuleFlagCGProfileEntry(MDO);\n  }\n}\n\nvoid Verifier::visitModuleFlagCGProfileEntry(const MDOperand &MDO) {\n  auto CheckFunction = [&](const MDOperand &FuncMDO) {\n    if (!FuncMDO)\n      return;\n    auto F = dyn_cast<ValueAsMetadata>(FuncMDO);\n    Assert(F && isa<Function>(F->getValue()->stripPointerCasts()),\n           \"expected a Function or null\", FuncMDO);\n  };\n  auto Node = dyn_cast_or_null<MDNode>(MDO);\n  Assert(Node && Node->getNumOperands() == 3, \"expected a MDNode triple\", MDO);\n  CheckFunction(Node->getOperand(0));\n  CheckFunction(Node->getOperand(1));\n  auto Count = dyn_cast_or_null<ConstantAsMetadata>(Node->getOperand(2));\n  Assert(Count && Count->getType()->isIntegerTy(),\n         \"expected an integer constant\", Node->getOperand(2));\n}\n\n/// Return true if this attribute kind only applies to functions.\nstatic bool isFuncOnlyAttr(Attribute::AttrKind Kind) {\n  switch (Kind) {\n  case Attribute::NoMerge:\n  case Attribute::NoReturn:\n  case Attribute::NoSync:\n  case Attribute::WillReturn:\n  case Attribute::NoCallback:\n  case Attribute::NoCfCheck:\n  case Attribute::NoUnwind:\n  case Attribute::NoInline:\n  case Attribute::AlwaysInline:\n  case Attribute::OptimizeForSize:\n  case Attribute::StackProtect:\n  case Attribute::StackProtectReq:\n  case Attribute::StackProtectStrong:\n  case Attribute::SafeStack:\n  case Attribute::ShadowCallStack:\n  case Attribute::NoRedZone:\n  case Attribute::NoImplicitFloat:\n  case Attribute::Naked:\n  case Attribute::InlineHint:\n  case Attribute::StackAlignment:\n  case Attribute::UWTable:\n  case Attribute::NonLazyBind:\n  case Attribute::ReturnsTwice:\n  case Attribute::SanitizeAddress:\n  case Attribute::SanitizeHWAddress:\n  case Attribute::SanitizeMemTag:\n  case Attribute::SanitizeThread:\n  case Attribute::SanitizeMemory:\n  case Attribute::MinSize:\n  case Attribute::NoDuplicate:\n  case Attribute::Builtin:\n  case Attribute::NoBuiltin:\n  case Attribute::Cold:\n  case Attribute::Hot:\n  case Attribute::OptForFuzzing:\n  case Attribute::OptimizeNone:\n  case Attribute::JumpTable:\n  case Attribute::Convergent:\n  case Attribute::ArgMemOnly:\n  case Attribute::NoRecurse:\n  case Attribute::InaccessibleMemOnly:\n  case Attribute::InaccessibleMemOrArgMemOnly:\n  case Attribute::AllocSize:\n  case Attribute::SpeculativeLoadHardening:\n  case Attribute::Speculatable:\n  case Attribute::StrictFP:\n  case Attribute::NullPointerIsValid:\n  case Attribute::MustProgress:\n  case Attribute::NoProfile:\n    return true;\n  default:\n    break;\n  }\n  return false;\n}\n\n/// Return true if this is a function attribute that can also appear on\n/// arguments.\nstatic bool isFuncOrArgAttr(Attribute::AttrKind Kind) {\n  return Kind == Attribute::ReadOnly || Kind == Attribute::WriteOnly ||\n         Kind == Attribute::ReadNone || Kind == Attribute::NoFree ||\n         Kind == Attribute::Preallocated;\n}\n\nvoid Verifier::verifyAttributeTypes(AttributeSet Attrs, bool IsFunction,\n                                    const Value *V) {\n  for (Attribute A : Attrs) {\n    if (A.isStringAttribute())\n      continue;\n\n    if (A.isIntAttribute() !=\n        Attribute::doesAttrKindHaveArgument(A.getKindAsEnum())) {\n      CheckFailed(\"Attribute '\" + A.getAsString() + \"' should have an Argument\",\n                  V);\n      return;\n    }\n\n    if (isFuncOnlyAttr(A.getKindAsEnum())) {\n      if (!IsFunction) {\n        CheckFailed(\"Attribute '\" + A.getAsString() +\n                        \"' only applies to functions!\",\n                    V);\n        return;\n      }\n    } else if (IsFunction && !isFuncOrArgAttr(A.getKindAsEnum())) {\n      CheckFailed(\"Attribute '\" + A.getAsString() +\n                      \"' does not apply to functions!\",\n                  V);\n      return;\n    }\n  }\n}\n\n// VerifyParameterAttrs - Check the given attributes for an argument or return\n// value of the specified type.  The value V is printed in error messages.\nvoid Verifier::verifyParameterAttrs(AttributeSet Attrs, Type *Ty,\n                                    const Value *V) {\n  if (!Attrs.hasAttributes())\n    return;\n\n  verifyAttributeTypes(Attrs, /*IsFunction=*/false, V);\n\n  if (Attrs.hasAttribute(Attribute::ImmArg)) {\n    Assert(Attrs.getNumAttributes() == 1,\n           \"Attribute 'immarg' is incompatible with other attributes\", V);\n  }\n\n  // Check for mutually incompatible attributes.  Only inreg is compatible with\n  // sret.\n  unsigned AttrCount = 0;\n  AttrCount += Attrs.hasAttribute(Attribute::ByVal);\n  AttrCount += Attrs.hasAttribute(Attribute::InAlloca);\n  AttrCount += Attrs.hasAttribute(Attribute::Preallocated);\n  AttrCount += Attrs.hasAttribute(Attribute::StructRet) ||\n               Attrs.hasAttribute(Attribute::InReg);\n  AttrCount += Attrs.hasAttribute(Attribute::Nest);\n  AttrCount += Attrs.hasAttribute(Attribute::ByRef);\n  Assert(AttrCount <= 1,\n         \"Attributes 'byval', 'inalloca', 'preallocated', 'inreg', 'nest', \"\n         \"'byref', and 'sret' are incompatible!\",\n         V);\n\n  Assert(!(Attrs.hasAttribute(Attribute::InAlloca) &&\n           Attrs.hasAttribute(Attribute::ReadOnly)),\n         \"Attributes \"\n         \"'inalloca and readonly' are incompatible!\",\n         V);\n\n  Assert(!(Attrs.hasAttribute(Attribute::StructRet) &&\n           Attrs.hasAttribute(Attribute::Returned)),\n         \"Attributes \"\n         \"'sret and returned' are incompatible!\",\n         V);\n\n  Assert(!(Attrs.hasAttribute(Attribute::ZExt) &&\n           Attrs.hasAttribute(Attribute::SExt)),\n         \"Attributes \"\n         \"'zeroext and signext' are incompatible!\",\n         V);\n\n  Assert(!(Attrs.hasAttribute(Attribute::ReadNone) &&\n           Attrs.hasAttribute(Attribute::ReadOnly)),\n         \"Attributes \"\n         \"'readnone and readonly' are incompatible!\",\n         V);\n\n  Assert(!(Attrs.hasAttribute(Attribute::ReadNone) &&\n           Attrs.hasAttribute(Attribute::WriteOnly)),\n         \"Attributes \"\n         \"'readnone and writeonly' are incompatible!\",\n         V);\n\n  Assert(!(Attrs.hasAttribute(Attribute::ReadOnly) &&\n           Attrs.hasAttribute(Attribute::WriteOnly)),\n         \"Attributes \"\n         \"'readonly and writeonly' are incompatible!\",\n         V);\n\n  Assert(!(Attrs.hasAttribute(Attribute::NoInline) &&\n           Attrs.hasAttribute(Attribute::AlwaysInline)),\n         \"Attributes \"\n         \"'noinline and alwaysinline' are incompatible!\",\n         V);\n\n  AttrBuilder IncompatibleAttrs = AttributeFuncs::typeIncompatible(Ty);\n  Assert(!AttrBuilder(Attrs).overlaps(IncompatibleAttrs),\n         \"Wrong types for attribute: \" +\n             AttributeSet::get(Context, IncompatibleAttrs).getAsString(),\n         V);\n\n  if (PointerType *PTy = dyn_cast<PointerType>(Ty)) {\n    SmallPtrSet<Type*, 4> Visited;\n    if (!PTy->getElementType()->isSized(&Visited)) {\n      Assert(!Attrs.hasAttribute(Attribute::ByVal) &&\n             !Attrs.hasAttribute(Attribute::ByRef) &&\n             !Attrs.hasAttribute(Attribute::InAlloca) &&\n             !Attrs.hasAttribute(Attribute::Preallocated),\n             \"Attributes 'byval', 'byref', 'inalloca', and 'preallocated' do not \"\n             \"support unsized types!\",\n             V);\n    }\n    if (!isa<PointerType>(PTy->getElementType()))\n      Assert(!Attrs.hasAttribute(Attribute::SwiftError),\n             \"Attribute 'swifterror' only applies to parameters \"\n             \"with pointer to pointer type!\",\n             V);\n\n    if (Attrs.hasAttribute(Attribute::ByRef)) {\n      Assert(Attrs.getByRefType() == PTy->getElementType(),\n             \"Attribute 'byref' type does not match parameter!\", V);\n    }\n\n    if (Attrs.hasAttribute(Attribute::ByVal) && Attrs.getByValType()) {\n      Assert(Attrs.getByValType() == PTy->getElementType(),\n             \"Attribute 'byval' type does not match parameter!\", V);\n    }\n\n    if (Attrs.hasAttribute(Attribute::Preallocated)) {\n      Assert(Attrs.getPreallocatedType() == PTy->getElementType(),\n             \"Attribute 'preallocated' type does not match parameter!\", V);\n    }\n  } else {\n    Assert(!Attrs.hasAttribute(Attribute::ByVal),\n           \"Attribute 'byval' only applies to parameters with pointer type!\",\n           V);\n    Assert(!Attrs.hasAttribute(Attribute::ByRef),\n           \"Attribute 'byref' only applies to parameters with pointer type!\",\n           V);\n    Assert(!Attrs.hasAttribute(Attribute::SwiftError),\n           \"Attribute 'swifterror' only applies to parameters \"\n           \"with pointer type!\",\n           V);\n  }\n}\n\n// Check parameter attributes against a function type.\n// The value V is printed in error messages.\nvoid Verifier::verifyFunctionAttrs(FunctionType *FT, AttributeList Attrs,\n                                   const Value *V, bool IsIntrinsic) {\n  if (Attrs.isEmpty())\n    return;\n\n  bool SawNest = false;\n  bool SawReturned = false;\n  bool SawSRet = false;\n  bool SawSwiftSelf = false;\n  bool SawSwiftError = false;\n\n  // Verify return value attributes.\n  AttributeSet RetAttrs = Attrs.getRetAttributes();\n  Assert((!RetAttrs.hasAttribute(Attribute::ByVal) &&\n          !RetAttrs.hasAttribute(Attribute::Nest) &&\n          !RetAttrs.hasAttribute(Attribute::StructRet) &&\n          !RetAttrs.hasAttribute(Attribute::NoCapture) &&\n          !RetAttrs.hasAttribute(Attribute::NoFree) &&\n          !RetAttrs.hasAttribute(Attribute::Returned) &&\n          !RetAttrs.hasAttribute(Attribute::InAlloca) &&\n          !RetAttrs.hasAttribute(Attribute::Preallocated) &&\n          !RetAttrs.hasAttribute(Attribute::ByRef) &&\n          !RetAttrs.hasAttribute(Attribute::SwiftSelf) &&\n          !RetAttrs.hasAttribute(Attribute::SwiftError)),\n         \"Attributes 'byval', 'inalloca', 'preallocated', 'byref', \"\n         \"'nest', 'sret', 'nocapture', 'nofree', \"\n         \"'returned', 'swiftself', and 'swifterror' do not apply to return \"\n         \"values!\",\n         V);\n  Assert((!RetAttrs.hasAttribute(Attribute::ReadOnly) &&\n          !RetAttrs.hasAttribute(Attribute::WriteOnly) &&\n          !RetAttrs.hasAttribute(Attribute::ReadNone)),\n         \"Attribute '\" + RetAttrs.getAsString() +\n             \"' does not apply to function returns\",\n         V);\n  verifyParameterAttrs(RetAttrs, FT->getReturnType(), V);\n\n  // Verify parameter attributes.\n  for (unsigned i = 0, e = FT->getNumParams(); i != e; ++i) {\n    Type *Ty = FT->getParamType(i);\n    AttributeSet ArgAttrs = Attrs.getParamAttributes(i);\n\n    if (!IsIntrinsic) {\n      Assert(!ArgAttrs.hasAttribute(Attribute::ImmArg),\n             \"immarg attribute only applies to intrinsics\",V);\n    }\n\n    verifyParameterAttrs(ArgAttrs, Ty, V);\n\n    if (ArgAttrs.hasAttribute(Attribute::Nest)) {\n      Assert(!SawNest, \"More than one parameter has attribute nest!\", V);\n      SawNest = true;\n    }\n\n    if (ArgAttrs.hasAttribute(Attribute::Returned)) {\n      Assert(!SawReturned, \"More than one parameter has attribute returned!\",\n             V);\n      Assert(Ty->canLosslesslyBitCastTo(FT->getReturnType()),\n             \"Incompatible argument and return types for 'returned' attribute\",\n             V);\n      SawReturned = true;\n    }\n\n    if (ArgAttrs.hasAttribute(Attribute::StructRet)) {\n      Assert(!SawSRet, \"Cannot have multiple 'sret' parameters!\", V);\n      Assert(i == 0 || i == 1,\n             \"Attribute 'sret' is not on first or second parameter!\", V);\n      SawSRet = true;\n    }\n\n    if (ArgAttrs.hasAttribute(Attribute::SwiftSelf)) {\n      Assert(!SawSwiftSelf, \"Cannot have multiple 'swiftself' parameters!\", V);\n      SawSwiftSelf = true;\n    }\n\n    if (ArgAttrs.hasAttribute(Attribute::SwiftError)) {\n      Assert(!SawSwiftError, \"Cannot have multiple 'swifterror' parameters!\",\n             V);\n      SawSwiftError = true;\n    }\n\n    if (ArgAttrs.hasAttribute(Attribute::InAlloca)) {\n      Assert(i == FT->getNumParams() - 1,\n             \"inalloca isn't on the last parameter!\", V);\n    }\n  }\n\n  if (!Attrs.hasAttributes(AttributeList::FunctionIndex))\n    return;\n\n  verifyAttributeTypes(Attrs.getFnAttributes(), /*IsFunction=*/true, V);\n\n  Assert(!(Attrs.hasFnAttribute(Attribute::ReadNone) &&\n           Attrs.hasFnAttribute(Attribute::ReadOnly)),\n         \"Attributes 'readnone and readonly' are incompatible!\", V);\n\n  Assert(!(Attrs.hasFnAttribute(Attribute::ReadNone) &&\n           Attrs.hasFnAttribute(Attribute::WriteOnly)),\n         \"Attributes 'readnone and writeonly' are incompatible!\", V);\n\n  Assert(!(Attrs.hasFnAttribute(Attribute::ReadOnly) &&\n           Attrs.hasFnAttribute(Attribute::WriteOnly)),\n         \"Attributes 'readonly and writeonly' are incompatible!\", V);\n\n  Assert(!(Attrs.hasFnAttribute(Attribute::ReadNone) &&\n           Attrs.hasFnAttribute(Attribute::InaccessibleMemOrArgMemOnly)),\n         \"Attributes 'readnone and inaccessiblemem_or_argmemonly' are \"\n         \"incompatible!\",\n         V);\n\n  Assert(!(Attrs.hasFnAttribute(Attribute::ReadNone) &&\n           Attrs.hasFnAttribute(Attribute::InaccessibleMemOnly)),\n         \"Attributes 'readnone and inaccessiblememonly' are incompatible!\", V);\n\n  Assert(!(Attrs.hasFnAttribute(Attribute::NoInline) &&\n           Attrs.hasFnAttribute(Attribute::AlwaysInline)),\n         \"Attributes 'noinline and alwaysinline' are incompatible!\", V);\n\n  if (Attrs.hasFnAttribute(Attribute::OptimizeNone)) {\n    Assert(Attrs.hasFnAttribute(Attribute::NoInline),\n           \"Attribute 'optnone' requires 'noinline'!\", V);\n\n    Assert(!Attrs.hasFnAttribute(Attribute::OptimizeForSize),\n           \"Attributes 'optsize and optnone' are incompatible!\", V);\n\n    Assert(!Attrs.hasFnAttribute(Attribute::MinSize),\n           \"Attributes 'minsize and optnone' are incompatible!\", V);\n  }\n\n  if (Attrs.hasFnAttribute(Attribute::JumpTable)) {\n    const GlobalValue *GV = cast<GlobalValue>(V);\n    Assert(GV->hasGlobalUnnamedAddr(),\n           \"Attribute 'jumptable' requires 'unnamed_addr'\", V);\n  }\n\n  if (Attrs.hasFnAttribute(Attribute::AllocSize)) {\n    std::pair<unsigned, Optional<unsigned>> Args =\n        Attrs.getAllocSizeArgs(AttributeList::FunctionIndex);\n\n    auto CheckParam = [&](StringRef Name, unsigned ParamNo) {\n      if (ParamNo >= FT->getNumParams()) {\n        CheckFailed(\"'allocsize' \" + Name + \" argument is out of bounds\", V);\n        return false;\n      }\n\n      if (!FT->getParamType(ParamNo)->isIntegerTy()) {\n        CheckFailed(\"'allocsize' \" + Name +\n                        \" argument must refer to an integer parameter\",\n                    V);\n        return false;\n      }\n\n      return true;\n    };\n\n    if (!CheckParam(\"element size\", Args.first))\n      return;\n\n    if (Args.second && !CheckParam(\"number of elements\", *Args.second))\n      return;\n  }\n\n  if (Attrs.hasFnAttribute(\"frame-pointer\")) {\n    StringRef FP = Attrs.getAttribute(AttributeList::FunctionIndex,\n                                      \"frame-pointer\").getValueAsString();\n    if (FP != \"all\" && FP != \"non-leaf\" && FP != \"none\")\n      CheckFailed(\"invalid value for 'frame-pointer' attribute: \" + FP, V);\n  }\n\n  if (Attrs.hasFnAttribute(\"patchable-function-prefix\")) {\n    StringRef S = Attrs\n                      .getAttribute(AttributeList::FunctionIndex,\n                                    \"patchable-function-prefix\")\n                      .getValueAsString();\n    unsigned N;\n    if (S.getAsInteger(10, N))\n      CheckFailed(\n          \"\\\"patchable-function-prefix\\\" takes an unsigned integer: \" + S, V);\n  }\n  if (Attrs.hasFnAttribute(\"patchable-function-entry\")) {\n    StringRef S = Attrs\n                      .getAttribute(AttributeList::FunctionIndex,\n                                    \"patchable-function-entry\")\n                      .getValueAsString();\n    unsigned N;\n    if (S.getAsInteger(10, N))\n      CheckFailed(\n          \"\\\"patchable-function-entry\\\" takes an unsigned integer: \" + S, V);\n  }\n}\n\nvoid Verifier::verifyFunctionMetadata(\n    ArrayRef<std::pair<unsigned, MDNode *>> MDs) {\n  for (const auto &Pair : MDs) {\n    if (Pair.first == LLVMContext::MD_prof) {\n      MDNode *MD = Pair.second;\n      Assert(MD->getNumOperands() >= 2,\n             \"!prof annotations should have no less than 2 operands\", MD);\n\n      // Check first operand.\n      Assert(MD->getOperand(0) != nullptr, \"first operand should not be null\",\n             MD);\n      Assert(isa<MDString>(MD->getOperand(0)),\n             \"expected string with name of the !prof annotation\", MD);\n      MDString *MDS = cast<MDString>(MD->getOperand(0));\n      StringRef ProfName = MDS->getString();\n      Assert(ProfName.equals(\"function_entry_count\") ||\n                 ProfName.equals(\"synthetic_function_entry_count\"),\n             \"first operand should be 'function_entry_count'\"\n             \" or 'synthetic_function_entry_count'\",\n             MD);\n\n      // Check second operand.\n      Assert(MD->getOperand(1) != nullptr, \"second operand should not be null\",\n             MD);\n      Assert(isa<ConstantAsMetadata>(MD->getOperand(1)),\n             \"expected integer argument to function_entry_count\", MD);\n    }\n  }\n}\n\nvoid Verifier::visitConstantExprsRecursively(const Constant *EntryC) {\n  if (!ConstantExprVisited.insert(EntryC).second)\n    return;\n\n  SmallVector<const Constant *, 16> Stack;\n  Stack.push_back(EntryC);\n\n  while (!Stack.empty()) {\n    const Constant *C = Stack.pop_back_val();\n\n    // Check this constant expression.\n    if (const auto *CE = dyn_cast<ConstantExpr>(C))\n      visitConstantExpr(CE);\n\n    if (const auto *GV = dyn_cast<GlobalValue>(C)) {\n      // Global Values get visited separately, but we do need to make sure\n      // that the global value is in the correct module\n      Assert(GV->getParent() == &M, \"Referencing global in another module!\",\n             EntryC, &M, GV, GV->getParent());\n      continue;\n    }\n\n    // Visit all sub-expressions.\n    for (const Use &U : C->operands()) {\n      const auto *OpC = dyn_cast<Constant>(U);\n      if (!OpC)\n        continue;\n      if (!ConstantExprVisited.insert(OpC).second)\n        continue;\n      Stack.push_back(OpC);\n    }\n  }\n}\n\nvoid Verifier::visitConstantExpr(const ConstantExpr *CE) {\n  if (CE->getOpcode() == Instruction::BitCast)\n    Assert(CastInst::castIsValid(Instruction::BitCast, CE->getOperand(0),\n                                 CE->getType()),\n           \"Invalid bitcast\", CE);\n\n  if (CE->getOpcode() == Instruction::IntToPtr ||\n      CE->getOpcode() == Instruction::PtrToInt) {\n    auto *PtrTy = CE->getOpcode() == Instruction::IntToPtr\n                      ? CE->getType()\n                      : CE->getOperand(0)->getType();\n    StringRef Msg = CE->getOpcode() == Instruction::IntToPtr\n                        ? \"inttoptr not supported for non-integral pointers\"\n                        : \"ptrtoint not supported for non-integral pointers\";\n    Assert(\n        !DL.isNonIntegralPointerType(cast<PointerType>(PtrTy->getScalarType())),\n        Msg);\n  }\n}\n\nbool Verifier::verifyAttributeCount(AttributeList Attrs, unsigned Params) {\n  // There shouldn't be more attribute sets than there are parameters plus the\n  // function and return value.\n  return Attrs.getNumAttrSets() <= Params + 2;\n}\n\n/// Verify that statepoint intrinsic is well formed.\nvoid Verifier::verifyStatepoint(const CallBase &Call) {\n  assert(Call.getCalledFunction() &&\n         Call.getCalledFunction()->getIntrinsicID() ==\n             Intrinsic::experimental_gc_statepoint);\n\n  Assert(!Call.doesNotAccessMemory() && !Call.onlyReadsMemory() &&\n             !Call.onlyAccessesArgMemory(),\n         \"gc.statepoint must read and write all memory to preserve \"\n         \"reordering restrictions required by safepoint semantics\",\n         Call);\n\n  const int64_t NumPatchBytes =\n      cast<ConstantInt>(Call.getArgOperand(1))->getSExtValue();\n  assert(isInt<32>(NumPatchBytes) && \"NumPatchBytesV is an i32!\");\n  Assert(NumPatchBytes >= 0,\n         \"gc.statepoint number of patchable bytes must be \"\n         \"positive\",\n         Call);\n\n  const Value *Target = Call.getArgOperand(2);\n  auto *PT = dyn_cast<PointerType>(Target->getType());\n  Assert(PT && PT->getElementType()->isFunctionTy(),\n         \"gc.statepoint callee must be of function pointer type\", Call, Target);\n  FunctionType *TargetFuncType = cast<FunctionType>(PT->getElementType());\n\n  const int NumCallArgs = cast<ConstantInt>(Call.getArgOperand(3))->getZExtValue();\n  Assert(NumCallArgs >= 0,\n         \"gc.statepoint number of arguments to underlying call \"\n         \"must be positive\",\n         Call);\n  const int NumParams = (int)TargetFuncType->getNumParams();\n  if (TargetFuncType->isVarArg()) {\n    Assert(NumCallArgs >= NumParams,\n           \"gc.statepoint mismatch in number of vararg call args\", Call);\n\n    // TODO: Remove this limitation\n    Assert(TargetFuncType->getReturnType()->isVoidTy(),\n           \"gc.statepoint doesn't support wrapping non-void \"\n           \"vararg functions yet\",\n           Call);\n  } else\n    Assert(NumCallArgs == NumParams,\n           \"gc.statepoint mismatch in number of call args\", Call);\n\n  const uint64_t Flags\n    = cast<ConstantInt>(Call.getArgOperand(4))->getZExtValue();\n  Assert((Flags & ~(uint64_t)StatepointFlags::MaskAll) == 0,\n         \"unknown flag used in gc.statepoint flags argument\", Call);\n\n  // Verify that the types of the call parameter arguments match\n  // the type of the wrapped callee.\n  AttributeList Attrs = Call.getAttributes();\n  for (int i = 0; i < NumParams; i++) {\n    Type *ParamType = TargetFuncType->getParamType(i);\n    Type *ArgType = Call.getArgOperand(5 + i)->getType();\n    Assert(ArgType == ParamType,\n           \"gc.statepoint call argument does not match wrapped \"\n           \"function type\",\n           Call);\n\n    if (TargetFuncType->isVarArg()) {\n      AttributeSet ArgAttrs = Attrs.getParamAttributes(5 + i);\n      Assert(!ArgAttrs.hasAttribute(Attribute::StructRet),\n             \"Attribute 'sret' cannot be used for vararg call arguments!\",\n             Call);\n    }\n  }\n\n  const int EndCallArgsInx = 4 + NumCallArgs;\n\n  const Value *NumTransitionArgsV = Call.getArgOperand(EndCallArgsInx + 1);\n  Assert(isa<ConstantInt>(NumTransitionArgsV),\n         \"gc.statepoint number of transition arguments \"\n         \"must be constant integer\",\n         Call);\n  const int NumTransitionArgs =\n      cast<ConstantInt>(NumTransitionArgsV)->getZExtValue();\n  Assert(NumTransitionArgs == 0,\n         \"gc.statepoint w/inline transition bundle is deprecated\", Call);\n  const int EndTransitionArgsInx = EndCallArgsInx + 1 + NumTransitionArgs;\n\n  const Value *NumDeoptArgsV = Call.getArgOperand(EndTransitionArgsInx + 1);\n  Assert(isa<ConstantInt>(NumDeoptArgsV),\n         \"gc.statepoint number of deoptimization arguments \"\n         \"must be constant integer\",\n         Call);\n  const int NumDeoptArgs = cast<ConstantInt>(NumDeoptArgsV)->getZExtValue();\n  Assert(NumDeoptArgs == 0,\n         \"gc.statepoint w/inline deopt operands is deprecated\", Call);\n\n  const int ExpectedNumArgs = 7 + NumCallArgs;\n  Assert(ExpectedNumArgs == (int)Call.arg_size(),\n         \"gc.statepoint too many arguments\", Call);\n\n  // Check that the only uses of this gc.statepoint are gc.result or\n  // gc.relocate calls which are tied to this statepoint and thus part\n  // of the same statepoint sequence\n  for (const User *U : Call.users()) {\n    const CallInst *UserCall = dyn_cast<const CallInst>(U);\n    Assert(UserCall, \"illegal use of statepoint token\", Call, U);\n    if (!UserCall)\n      continue;\n    Assert(isa<GCRelocateInst>(UserCall) || isa<GCResultInst>(UserCall),\n           \"gc.result or gc.relocate are the only value uses \"\n           \"of a gc.statepoint\",\n           Call, U);\n    if (isa<GCResultInst>(UserCall)) {\n      Assert(UserCall->getArgOperand(0) == &Call,\n             \"gc.result connected to wrong gc.statepoint\", Call, UserCall);\n    } else if (isa<GCRelocateInst>(Call)) {\n      Assert(UserCall->getArgOperand(0) == &Call,\n             \"gc.relocate connected to wrong gc.statepoint\", Call, UserCall);\n    }\n  }\n\n  // Note: It is legal for a single derived pointer to be listed multiple\n  // times.  It's non-optimal, but it is legal.  It can also happen after\n  // insertion if we strip a bitcast away.\n  // Note: It is really tempting to check that each base is relocated and\n  // that a derived pointer is never reused as a base pointer.  This turns\n  // out to be problematic since optimizations run after safepoint insertion\n  // can recognize equality properties that the insertion logic doesn't know\n  // about.  See example statepoint.ll in the verifier subdirectory\n}\n\nvoid Verifier::verifyFrameRecoverIndices() {\n  for (auto &Counts : FrameEscapeInfo) {\n    Function *F = Counts.first;\n    unsigned EscapedObjectCount = Counts.second.first;\n    unsigned MaxRecoveredIndex = Counts.second.second;\n    Assert(MaxRecoveredIndex <= EscapedObjectCount,\n           \"all indices passed to llvm.localrecover must be less than the \"\n           \"number of arguments passed to llvm.localescape in the parent \"\n           \"function\",\n           F);\n  }\n}\n\nstatic Instruction *getSuccPad(Instruction *Terminator) {\n  BasicBlock *UnwindDest;\n  if (auto *II = dyn_cast<InvokeInst>(Terminator))\n    UnwindDest = II->getUnwindDest();\n  else if (auto *CSI = dyn_cast<CatchSwitchInst>(Terminator))\n    UnwindDest = CSI->getUnwindDest();\n  else\n    UnwindDest = cast<CleanupReturnInst>(Terminator)->getUnwindDest();\n  return UnwindDest->getFirstNonPHI();\n}\n\nvoid Verifier::verifySiblingFuncletUnwinds() {\n  SmallPtrSet<Instruction *, 8> Visited;\n  SmallPtrSet<Instruction *, 8> Active;\n  for (const auto &Pair : SiblingFuncletInfo) {\n    Instruction *PredPad = Pair.first;\n    if (Visited.count(PredPad))\n      continue;\n    Active.insert(PredPad);\n    Instruction *Terminator = Pair.second;\n    do {\n      Instruction *SuccPad = getSuccPad(Terminator);\n      if (Active.count(SuccPad)) {\n        // Found a cycle; report error\n        Instruction *CyclePad = SuccPad;\n        SmallVector<Instruction *, 8> CycleNodes;\n        do {\n          CycleNodes.push_back(CyclePad);\n          Instruction *CycleTerminator = SiblingFuncletInfo[CyclePad];\n          if (CycleTerminator != CyclePad)\n            CycleNodes.push_back(CycleTerminator);\n          CyclePad = getSuccPad(CycleTerminator);\n        } while (CyclePad != SuccPad);\n        Assert(false, \"EH pads can't handle each other's exceptions\",\n               ArrayRef<Instruction *>(CycleNodes));\n      }\n      // Don't re-walk a node we've already checked\n      if (!Visited.insert(SuccPad).second)\n        break;\n      // Walk to this successor if it has a map entry.\n      PredPad = SuccPad;\n      auto TermI = SiblingFuncletInfo.find(PredPad);\n      if (TermI == SiblingFuncletInfo.end())\n        break;\n      Terminator = TermI->second;\n      Active.insert(PredPad);\n    } while (true);\n    // Each node only has one successor, so we've walked all the active\n    // nodes' successors.\n    Active.clear();\n  }\n}\n\n// visitFunction - Verify that a function is ok.\n//\nvoid Verifier::visitFunction(const Function &F) {\n  visitGlobalValue(F);\n\n  // Check function arguments.\n  FunctionType *FT = F.getFunctionType();\n  unsigned NumArgs = F.arg_size();\n\n  Assert(&Context == &F.getContext(),\n         \"Function context does not match Module context!\", &F);\n\n  Assert(!F.hasCommonLinkage(), \"Functions may not have common linkage\", &F);\n  Assert(FT->getNumParams() == NumArgs,\n         \"# formal arguments must match # of arguments for function type!\", &F,\n         FT);\n  Assert(F.getReturnType()->isFirstClassType() ||\n             F.getReturnType()->isVoidTy() || F.getReturnType()->isStructTy(),\n         \"Functions cannot return aggregate values!\", &F);\n\n  Assert(!F.hasStructRetAttr() || F.getReturnType()->isVoidTy(),\n         \"Invalid struct return type!\", &F);\n\n  AttributeList Attrs = F.getAttributes();\n\n  Assert(verifyAttributeCount(Attrs, FT->getNumParams()),\n         \"Attribute after last parameter!\", &F);\n\n  bool isLLVMdotName = F.getName().size() >= 5 &&\n                       F.getName().substr(0, 5) == \"llvm.\";\n\n  // Check function attributes.\n  verifyFunctionAttrs(FT, Attrs, &F, isLLVMdotName);\n\n  // On function declarations/definitions, we do not support the builtin\n  // attribute. We do not check this in VerifyFunctionAttrs since that is\n  // checking for Attributes that can/can not ever be on functions.\n  Assert(!Attrs.hasFnAttribute(Attribute::Builtin),\n         \"Attribute 'builtin' can only be applied to a callsite.\", &F);\n\n  // Check that this function meets the restrictions on this calling convention.\n  // Sometimes varargs is used for perfectly forwarding thunks, so some of these\n  // restrictions can be lifted.\n  switch (F.getCallingConv()) {\n  default:\n  case CallingConv::C:\n    break;\n  case CallingConv::X86_INTR: {\n    Assert(F.arg_empty() || Attrs.hasParamAttribute(0, Attribute::ByVal),\n           \"Calling convention parameter requires byval\", &F);\n    break;\n  }\n  case CallingConv::AMDGPU_KERNEL:\n  case CallingConv::SPIR_KERNEL:\n    Assert(F.getReturnType()->isVoidTy(),\n           \"Calling convention requires void return type\", &F);\n    LLVM_FALLTHROUGH;\n  case CallingConv::AMDGPU_VS:\n  case CallingConv::AMDGPU_HS:\n  case CallingConv::AMDGPU_GS:\n  case CallingConv::AMDGPU_PS:\n  case CallingConv::AMDGPU_CS:\n    Assert(!F.hasStructRetAttr(),\n           \"Calling convention does not allow sret\", &F);\n    if (F.getCallingConv() != CallingConv::SPIR_KERNEL) {\n      const unsigned StackAS = DL.getAllocaAddrSpace();\n      unsigned i = 0;\n      for (const Argument &Arg : F.args()) {\n        Assert(!Attrs.hasParamAttribute(i, Attribute::ByVal),\n               \"Calling convention disallows byval\", &F);\n        Assert(!Attrs.hasParamAttribute(i, Attribute::Preallocated),\n               \"Calling convention disallows preallocated\", &F);\n        Assert(!Attrs.hasParamAttribute(i, Attribute::InAlloca),\n               \"Calling convention disallows inalloca\", &F);\n\n        if (Attrs.hasParamAttribute(i, Attribute::ByRef)) {\n          // FIXME: Should also disallow LDS and GDS, but we don't have the enum\n          // value here.\n          Assert(Arg.getType()->getPointerAddressSpace() != StackAS,\n                 \"Calling convention disallows stack byref\", &F);\n        }\n\n        ++i;\n      }\n    }\n\n    LLVM_FALLTHROUGH;\n  case CallingConv::Fast:\n  case CallingConv::Cold:\n  case CallingConv::Intel_OCL_BI:\n  case CallingConv::PTX_Kernel:\n  case CallingConv::PTX_Device:\n    Assert(!F.isVarArg(), \"Calling convention does not support varargs or \"\n                          \"perfect forwarding!\",\n           &F);\n    break;\n  }\n\n  // Check that the argument values match the function type for this function...\n  unsigned i = 0;\n  for (const Argument &Arg : F.args()) {\n    Assert(Arg.getType() == FT->getParamType(i),\n           \"Argument value does not match function argument type!\", &Arg,\n           FT->getParamType(i));\n    Assert(Arg.getType()->isFirstClassType(),\n           \"Function arguments must have first-class types!\", &Arg);\n    if (!isLLVMdotName) {\n      Assert(!Arg.getType()->isMetadataTy(),\n             \"Function takes metadata but isn't an intrinsic\", &Arg, &F);\n      Assert(!Arg.getType()->isTokenTy(),\n             \"Function takes token but isn't an intrinsic\", &Arg, &F);\n    }\n\n    // Check that swifterror argument is only used by loads and stores.\n    if (Attrs.hasParamAttribute(i, Attribute::SwiftError)) {\n      verifySwiftErrorValue(&Arg);\n    }\n    ++i;\n  }\n\n  if (!isLLVMdotName)\n    Assert(!F.getReturnType()->isTokenTy(),\n           \"Functions returns a token but isn't an intrinsic\", &F);\n\n  // Get the function metadata attachments.\n  SmallVector<std::pair<unsigned, MDNode *>, 4> MDs;\n  F.getAllMetadata(MDs);\n  assert(F.hasMetadata() != MDs.empty() && \"Bit out-of-sync\");\n  verifyFunctionMetadata(MDs);\n\n  // Check validity of the personality function\n  if (F.hasPersonalityFn()) {\n    auto *Per = dyn_cast<Function>(F.getPersonalityFn()->stripPointerCasts());\n    if (Per)\n      Assert(Per->getParent() == F.getParent(),\n             \"Referencing personality function in another module!\",\n             &F, F.getParent(), Per, Per->getParent());\n  }\n\n  if (F.isMaterializable()) {\n    // Function has a body somewhere we can't see.\n    Assert(MDs.empty(), \"unmaterialized function cannot have metadata\", &F,\n           MDs.empty() ? nullptr : MDs.front().second);\n  } else if (F.isDeclaration()) {\n    for (const auto &I : MDs) {\n      // This is used for call site debug information.\n      AssertDI(I.first != LLVMContext::MD_dbg ||\n                   !cast<DISubprogram>(I.second)->isDistinct(),\n               \"function declaration may only have a unique !dbg attachment\",\n               &F);\n      Assert(I.first != LLVMContext::MD_prof,\n             \"function declaration may not have a !prof attachment\", &F);\n\n      // Verify the metadata itself.\n      visitMDNode(*I.second, AreDebugLocsAllowed::Yes);\n    }\n    Assert(!F.hasPersonalityFn(),\n           \"Function declaration shouldn't have a personality routine\", &F);\n  } else {\n    // Verify that this function (which has a body) is not named \"llvm.*\".  It\n    // is not legal to define intrinsics.\n    Assert(!isLLVMdotName, \"llvm intrinsics cannot be defined!\", &F);\n\n    // Check the entry node\n    const BasicBlock *Entry = &F.getEntryBlock();\n    Assert(pred_empty(Entry),\n           \"Entry block to function must not have predecessors!\", Entry);\n\n    // The address of the entry block cannot be taken, unless it is dead.\n    if (Entry->hasAddressTaken()) {\n      Assert(!BlockAddress::lookup(Entry)->isConstantUsed(),\n             \"blockaddress may not be used with the entry block!\", Entry);\n    }\n\n    unsigned NumDebugAttachments = 0, NumProfAttachments = 0;\n    // Visit metadata attachments.\n    for (const auto &I : MDs) {\n      // Verify that the attachment is legal.\n      auto AllowLocs = AreDebugLocsAllowed::No;\n      switch (I.first) {\n      default:\n        break;\n      case LLVMContext::MD_dbg: {\n        ++NumDebugAttachments;\n        AssertDI(NumDebugAttachments == 1,\n                 \"function must have a single !dbg attachment\", &F, I.second);\n        AssertDI(isa<DISubprogram>(I.second),\n                 \"function !dbg attachment must be a subprogram\", &F, I.second);\n        AssertDI(cast<DISubprogram>(I.second)->isDistinct(),\n                 \"function definition may only have a distinct !dbg attachment\",\n                 &F);\n\n        auto *SP = cast<DISubprogram>(I.second);\n        const Function *&AttachedTo = DISubprogramAttachments[SP];\n        AssertDI(!AttachedTo || AttachedTo == &F,\n                 \"DISubprogram attached to more than one function\", SP, &F);\n        AttachedTo = &F;\n        AllowLocs = AreDebugLocsAllowed::Yes;\n        break;\n      }\n      case LLVMContext::MD_prof:\n        ++NumProfAttachments;\n        Assert(NumProfAttachments == 1,\n               \"function must have a single !prof attachment\", &F, I.second);\n        break;\n      }\n\n      // Verify the metadata itself.\n      visitMDNode(*I.second, AllowLocs);\n    }\n  }\n\n  // If this function is actually an intrinsic, verify that it is only used in\n  // direct call/invokes, never having its \"address taken\".\n  // Only do this if the module is materialized, otherwise we don't have all the\n  // uses.\n  if (F.getIntrinsicID() && F.getParent()->isMaterialized()) {\n    const User *U;\n    if (F.hasAddressTaken(&U))\n      Assert(false, \"Invalid user of intrinsic instruction!\", U);\n  }\n\n  auto *N = F.getSubprogram();\n  HasDebugInfo = (N != nullptr);\n  if (!HasDebugInfo)\n    return;\n\n  // Check that all !dbg attachments lead to back to N.\n  //\n  // FIXME: Check this incrementally while visiting !dbg attachments.\n  // FIXME: Only check when N is the canonical subprogram for F.\n  SmallPtrSet<const MDNode *, 32> Seen;\n  auto VisitDebugLoc = [&](const Instruction &I, const MDNode *Node) {\n    // Be careful about using DILocation here since we might be dealing with\n    // broken code (this is the Verifier after all).\n    const DILocation *DL = dyn_cast_or_null<DILocation>(Node);\n    if (!DL)\n      return;\n    if (!Seen.insert(DL).second)\n      return;\n\n    Metadata *Parent = DL->getRawScope();\n    AssertDI(Parent && isa<DILocalScope>(Parent),\n             \"DILocation's scope must be a DILocalScope\", N, &F, &I, DL,\n             Parent);\n\n    DILocalScope *Scope = DL->getInlinedAtScope();\n    Assert(Scope, \"Failed to find DILocalScope\", DL);\n\n    if (!Seen.insert(Scope).second)\n      return;\n\n    DISubprogram *SP = Scope->getSubprogram();\n\n    // Scope and SP could be the same MDNode and we don't want to skip\n    // validation in that case\n    if (SP && ((Scope != SP) && !Seen.insert(SP).second))\n      return;\n\n    AssertDI(SP->describes(&F),\n             \"!dbg attachment points at wrong subprogram for function\", N, &F,\n             &I, DL, Scope, SP);\n  };\n  for (auto &BB : F)\n    for (auto &I : BB) {\n      VisitDebugLoc(I, I.getDebugLoc().getAsMDNode());\n      // The llvm.loop annotations also contain two DILocations.\n      if (auto MD = I.getMetadata(LLVMContext::MD_loop))\n        for (unsigned i = 1; i < MD->getNumOperands(); ++i)\n          VisitDebugLoc(I, dyn_cast_or_null<MDNode>(MD->getOperand(i)));\n      if (BrokenDebugInfo)\n        return;\n    }\n}\n\n// verifyBasicBlock - Verify that a basic block is well formed...\n//\nvoid Verifier::visitBasicBlock(BasicBlock &BB) {\n  InstsInThisBlock.clear();\n\n  // Ensure that basic blocks have terminators!\n  Assert(BB.getTerminator(), \"Basic Block does not have terminator!\", &BB);\n\n  // Check constraints that this basic block imposes on all of the PHI nodes in\n  // it.\n  if (isa<PHINode>(BB.front())) {\n    SmallVector<BasicBlock *, 8> Preds(predecessors(&BB));\n    SmallVector<std::pair<BasicBlock*, Value*>, 8> Values;\n    llvm::sort(Preds);\n    for (const PHINode &PN : BB.phis()) {\n      Assert(PN.getNumIncomingValues() == Preds.size(),\n             \"PHINode should have one entry for each predecessor of its \"\n             \"parent basic block!\",\n             &PN);\n\n      // Get and sort all incoming values in the PHI node...\n      Values.clear();\n      Values.reserve(PN.getNumIncomingValues());\n      for (unsigned i = 0, e = PN.getNumIncomingValues(); i != e; ++i)\n        Values.push_back(\n            std::make_pair(PN.getIncomingBlock(i), PN.getIncomingValue(i)));\n      llvm::sort(Values);\n\n      for (unsigned i = 0, e = Values.size(); i != e; ++i) {\n        // Check to make sure that if there is more than one entry for a\n        // particular basic block in this PHI node, that the incoming values are\n        // all identical.\n        //\n        Assert(i == 0 || Values[i].first != Values[i - 1].first ||\n                   Values[i].second == Values[i - 1].second,\n               \"PHI node has multiple entries for the same basic block with \"\n               \"different incoming values!\",\n               &PN, Values[i].first, Values[i].second, Values[i - 1].second);\n\n        // Check to make sure that the predecessors and PHI node entries are\n        // matched up.\n        Assert(Values[i].first == Preds[i],\n               \"PHI node entries do not match predecessors!\", &PN,\n               Values[i].first, Preds[i]);\n      }\n    }\n  }\n\n  // Check that all instructions have their parent pointers set up correctly.\n  for (auto &I : BB)\n  {\n    Assert(I.getParent() == &BB, \"Instruction has bogus parent pointer!\");\n  }\n}\n\nvoid Verifier::visitTerminator(Instruction &I) {\n  // Ensure that terminators only exist at the end of the basic block.\n  Assert(&I == I.getParent()->getTerminator(),\n         \"Terminator found in the middle of a basic block!\", I.getParent());\n  visitInstruction(I);\n}\n\nvoid Verifier::visitBranchInst(BranchInst &BI) {\n  if (BI.isConditional()) {\n    Assert(BI.getCondition()->getType()->isIntegerTy(1),\n           \"Branch condition is not 'i1' type!\", &BI, BI.getCondition());\n  }\n  visitTerminator(BI);\n}\n\nvoid Verifier::visitReturnInst(ReturnInst &RI) {\n  Function *F = RI.getParent()->getParent();\n  unsigned N = RI.getNumOperands();\n  if (F->getReturnType()->isVoidTy())\n    Assert(N == 0,\n           \"Found return instr that returns non-void in Function of void \"\n           \"return type!\",\n           &RI, F->getReturnType());\n  else\n    Assert(N == 1 && F->getReturnType() == RI.getOperand(0)->getType(),\n           \"Function return type does not match operand \"\n           \"type of return inst!\",\n           &RI, F->getReturnType());\n\n  // Check to make sure that the return value has necessary properties for\n  // terminators...\n  visitTerminator(RI);\n}\n\nvoid Verifier::visitSwitchInst(SwitchInst &SI) {\n  // Check to make sure that all of the constants in the switch instruction\n  // have the same type as the switched-on value.\n  Type *SwitchTy = SI.getCondition()->getType();\n  SmallPtrSet<ConstantInt*, 32> Constants;\n  for (auto &Case : SI.cases()) {\n    Assert(Case.getCaseValue()->getType() == SwitchTy,\n           \"Switch constants must all be same type as switch value!\", &SI);\n    Assert(Constants.insert(Case.getCaseValue()).second,\n           \"Duplicate integer as switch case\", &SI, Case.getCaseValue());\n  }\n\n  visitTerminator(SI);\n}\n\nvoid Verifier::visitIndirectBrInst(IndirectBrInst &BI) {\n  Assert(BI.getAddress()->getType()->isPointerTy(),\n         \"Indirectbr operand must have pointer type!\", &BI);\n  for (unsigned i = 0, e = BI.getNumDestinations(); i != e; ++i)\n    Assert(BI.getDestination(i)->getType()->isLabelTy(),\n           \"Indirectbr destinations must all have pointer type!\", &BI);\n\n  visitTerminator(BI);\n}\n\nvoid Verifier::visitCallBrInst(CallBrInst &CBI) {\n  Assert(CBI.isInlineAsm(), \"Callbr is currently only used for asm-goto!\",\n         &CBI);\n  for (unsigned i = 0, e = CBI.getNumSuccessors(); i != e; ++i)\n    Assert(CBI.getSuccessor(i)->getType()->isLabelTy(),\n           \"Callbr successors must all have pointer type!\", &CBI);\n  for (unsigned i = 0, e = CBI.getNumOperands(); i != e; ++i) {\n    Assert(i >= CBI.getNumArgOperands() || !isa<BasicBlock>(CBI.getOperand(i)),\n           \"Using an unescaped label as a callbr argument!\", &CBI);\n    if (isa<BasicBlock>(CBI.getOperand(i)))\n      for (unsigned j = i + 1; j != e; ++j)\n        Assert(CBI.getOperand(i) != CBI.getOperand(j),\n               \"Duplicate callbr destination!\", &CBI);\n  }\n  {\n    SmallPtrSet<BasicBlock *, 4> ArgBBs;\n    for (Value *V : CBI.args())\n      if (auto *BA = dyn_cast<BlockAddress>(V))\n        ArgBBs.insert(BA->getBasicBlock());\n    for (BasicBlock *BB : CBI.getIndirectDests())\n      Assert(ArgBBs.count(BB), \"Indirect label missing from arglist.\", &CBI);\n  }\n\n  visitTerminator(CBI);\n}\n\nvoid Verifier::visitSelectInst(SelectInst &SI) {\n  Assert(!SelectInst::areInvalidOperands(SI.getOperand(0), SI.getOperand(1),\n                                         SI.getOperand(2)),\n         \"Invalid operands for select instruction!\", &SI);\n\n  Assert(SI.getTrueValue()->getType() == SI.getType(),\n         \"Select values must have same type as select instruction!\", &SI);\n  visitInstruction(SI);\n}\n\n/// visitUserOp1 - User defined operators shouldn't live beyond the lifetime of\n/// a pass, if any exist, it's an error.\n///\nvoid Verifier::visitUserOp1(Instruction &I) {\n  Assert(false, \"User-defined operators should not live outside of a pass!\", &I);\n}\n\nvoid Verifier::visitTruncInst(TruncInst &I) {\n  // Get the source and destination types\n  Type *SrcTy = I.getOperand(0)->getType();\n  Type *DestTy = I.getType();\n\n  // Get the size of the types in bits, we'll need this later\n  unsigned SrcBitSize = SrcTy->getScalarSizeInBits();\n  unsigned DestBitSize = DestTy->getScalarSizeInBits();\n\n  Assert(SrcTy->isIntOrIntVectorTy(), \"Trunc only operates on integer\", &I);\n  Assert(DestTy->isIntOrIntVectorTy(), \"Trunc only produces integer\", &I);\n  Assert(SrcTy->isVectorTy() == DestTy->isVectorTy(),\n         \"trunc source and destination must both be a vector or neither\", &I);\n  Assert(SrcBitSize > DestBitSize, \"DestTy too big for Trunc\", &I);\n\n  visitInstruction(I);\n}\n\nvoid Verifier::visitZExtInst(ZExtInst &I) {\n  // Get the source and destination types\n  Type *SrcTy = I.getOperand(0)->getType();\n  Type *DestTy = I.getType();\n\n  // Get the size of the types in bits, we'll need this later\n  Assert(SrcTy->isIntOrIntVectorTy(), \"ZExt only operates on integer\", &I);\n  Assert(DestTy->isIntOrIntVectorTy(), \"ZExt only produces an integer\", &I);\n  Assert(SrcTy->isVectorTy() == DestTy->isVectorTy(),\n         \"zext source and destination must both be a vector or neither\", &I);\n  unsigned SrcBitSize = SrcTy->getScalarSizeInBits();\n  unsigned DestBitSize = DestTy->getScalarSizeInBits();\n\n  Assert(SrcBitSize < DestBitSize, \"Type too small for ZExt\", &I);\n\n  visitInstruction(I);\n}\n\nvoid Verifier::visitSExtInst(SExtInst &I) {\n  // Get the source and destination types\n  Type *SrcTy = I.getOperand(0)->getType();\n  Type *DestTy = I.getType();\n\n  // Get the size of the types in bits, we'll need this later\n  unsigned SrcBitSize = SrcTy->getScalarSizeInBits();\n  unsigned DestBitSize = DestTy->getScalarSizeInBits();\n\n  Assert(SrcTy->isIntOrIntVectorTy(), \"SExt only operates on integer\", &I);\n  Assert(DestTy->isIntOrIntVectorTy(), \"SExt only produces an integer\", &I);\n  Assert(SrcTy->isVectorTy() == DestTy->isVectorTy(),\n         \"sext source and destination must both be a vector or neither\", &I);\n  Assert(SrcBitSize < DestBitSize, \"Type too small for SExt\", &I);\n\n  visitInstruction(I);\n}\n\nvoid Verifier::visitFPTruncInst(FPTruncInst &I) {\n  // Get the source and destination types\n  Type *SrcTy = I.getOperand(0)->getType();\n  Type *DestTy = I.getType();\n  // Get the size of the types in bits, we'll need this later\n  unsigned SrcBitSize = SrcTy->getScalarSizeInBits();\n  unsigned DestBitSize = DestTy->getScalarSizeInBits();\n\n  Assert(SrcTy->isFPOrFPVectorTy(), \"FPTrunc only operates on FP\", &I);\n  Assert(DestTy->isFPOrFPVectorTy(), \"FPTrunc only produces an FP\", &I);\n  Assert(SrcTy->isVectorTy() == DestTy->isVectorTy(),\n         \"fptrunc source and destination must both be a vector or neither\", &I);\n  Assert(SrcBitSize > DestBitSize, \"DestTy too big for FPTrunc\", &I);\n\n  visitInstruction(I);\n}\n\nvoid Verifier::visitFPExtInst(FPExtInst &I) {\n  // Get the source and destination types\n  Type *SrcTy = I.getOperand(0)->getType();\n  Type *DestTy = I.getType();\n\n  // Get the size of the types in bits, we'll need this later\n  unsigned SrcBitSize = SrcTy->getScalarSizeInBits();\n  unsigned DestBitSize = DestTy->getScalarSizeInBits();\n\n  Assert(SrcTy->isFPOrFPVectorTy(), \"FPExt only operates on FP\", &I);\n  Assert(DestTy->isFPOrFPVectorTy(), \"FPExt only produces an FP\", &I);\n  Assert(SrcTy->isVectorTy() == DestTy->isVectorTy(),\n         \"fpext source and destination must both be a vector or neither\", &I);\n  Assert(SrcBitSize < DestBitSize, \"DestTy too small for FPExt\", &I);\n\n  visitInstruction(I);\n}\n\nvoid Verifier::visitUIToFPInst(UIToFPInst &I) {\n  // Get the source and destination types\n  Type *SrcTy = I.getOperand(0)->getType();\n  Type *DestTy = I.getType();\n\n  bool SrcVec = SrcTy->isVectorTy();\n  bool DstVec = DestTy->isVectorTy();\n\n  Assert(SrcVec == DstVec,\n         \"UIToFP source and dest must both be vector or scalar\", &I);\n  Assert(SrcTy->isIntOrIntVectorTy(),\n         \"UIToFP source must be integer or integer vector\", &I);\n  Assert(DestTy->isFPOrFPVectorTy(), \"UIToFP result must be FP or FP vector\",\n         &I);\n\n  if (SrcVec && DstVec)\n    Assert(cast<VectorType>(SrcTy)->getElementCount() ==\n               cast<VectorType>(DestTy)->getElementCount(),\n           \"UIToFP source and dest vector length mismatch\", &I);\n\n  visitInstruction(I);\n}\n\nvoid Verifier::visitSIToFPInst(SIToFPInst &I) {\n  // Get the source and destination types\n  Type *SrcTy = I.getOperand(0)->getType();\n  Type *DestTy = I.getType();\n\n  bool SrcVec = SrcTy->isVectorTy();\n  bool DstVec = DestTy->isVectorTy();\n\n  Assert(SrcVec == DstVec,\n         \"SIToFP source and dest must both be vector or scalar\", &I);\n  Assert(SrcTy->isIntOrIntVectorTy(),\n         \"SIToFP source must be integer or integer vector\", &I);\n  Assert(DestTy->isFPOrFPVectorTy(), \"SIToFP result must be FP or FP vector\",\n         &I);\n\n  if (SrcVec && DstVec)\n    Assert(cast<VectorType>(SrcTy)->getElementCount() ==\n               cast<VectorType>(DestTy)->getElementCount(),\n           \"SIToFP source and dest vector length mismatch\", &I);\n\n  visitInstruction(I);\n}\n\nvoid Verifier::visitFPToUIInst(FPToUIInst &I) {\n  // Get the source and destination types\n  Type *SrcTy = I.getOperand(0)->getType();\n  Type *DestTy = I.getType();\n\n  bool SrcVec = SrcTy->isVectorTy();\n  bool DstVec = DestTy->isVectorTy();\n\n  Assert(SrcVec == DstVec,\n         \"FPToUI source and dest must both be vector or scalar\", &I);\n  Assert(SrcTy->isFPOrFPVectorTy(), \"FPToUI source must be FP or FP vector\",\n         &I);\n  Assert(DestTy->isIntOrIntVectorTy(),\n         \"FPToUI result must be integer or integer vector\", &I);\n\n  if (SrcVec && DstVec)\n    Assert(cast<VectorType>(SrcTy)->getElementCount() ==\n               cast<VectorType>(DestTy)->getElementCount(),\n           \"FPToUI source and dest vector length mismatch\", &I);\n\n  visitInstruction(I);\n}\n\nvoid Verifier::visitFPToSIInst(FPToSIInst &I) {\n  // Get the source and destination types\n  Type *SrcTy = I.getOperand(0)->getType();\n  Type *DestTy = I.getType();\n\n  bool SrcVec = SrcTy->isVectorTy();\n  bool DstVec = DestTy->isVectorTy();\n\n  Assert(SrcVec == DstVec,\n         \"FPToSI source and dest must both be vector or scalar\", &I);\n  Assert(SrcTy->isFPOrFPVectorTy(), \"FPToSI source must be FP or FP vector\",\n         &I);\n  Assert(DestTy->isIntOrIntVectorTy(),\n         \"FPToSI result must be integer or integer vector\", &I);\n\n  if (SrcVec && DstVec)\n    Assert(cast<VectorType>(SrcTy)->getElementCount() ==\n               cast<VectorType>(DestTy)->getElementCount(),\n           \"FPToSI source and dest vector length mismatch\", &I);\n\n  visitInstruction(I);\n}\n\nvoid Verifier::visitPtrToIntInst(PtrToIntInst &I) {\n  // Get the source and destination types\n  Type *SrcTy = I.getOperand(0)->getType();\n  Type *DestTy = I.getType();\n\n  Assert(SrcTy->isPtrOrPtrVectorTy(), \"PtrToInt source must be pointer\", &I);\n\n  if (auto *PTy = dyn_cast<PointerType>(SrcTy->getScalarType()))\n    Assert(!DL.isNonIntegralPointerType(PTy),\n           \"ptrtoint not supported for non-integral pointers\");\n\n  Assert(DestTy->isIntOrIntVectorTy(), \"PtrToInt result must be integral\", &I);\n  Assert(SrcTy->isVectorTy() == DestTy->isVectorTy(), \"PtrToInt type mismatch\",\n         &I);\n\n  if (SrcTy->isVectorTy()) {\n    auto *VSrc = cast<VectorType>(SrcTy);\n    auto *VDest = cast<VectorType>(DestTy);\n    Assert(VSrc->getElementCount() == VDest->getElementCount(),\n           \"PtrToInt Vector width mismatch\", &I);\n  }\n\n  visitInstruction(I);\n}\n\nvoid Verifier::visitIntToPtrInst(IntToPtrInst &I) {\n  // Get the source and destination types\n  Type *SrcTy = I.getOperand(0)->getType();\n  Type *DestTy = I.getType();\n\n  Assert(SrcTy->isIntOrIntVectorTy(),\n         \"IntToPtr source must be an integral\", &I);\n  Assert(DestTy->isPtrOrPtrVectorTy(), \"IntToPtr result must be a pointer\", &I);\n\n  if (auto *PTy = dyn_cast<PointerType>(DestTy->getScalarType()))\n    Assert(!DL.isNonIntegralPointerType(PTy),\n           \"inttoptr not supported for non-integral pointers\");\n\n  Assert(SrcTy->isVectorTy() == DestTy->isVectorTy(), \"IntToPtr type mismatch\",\n         &I);\n  if (SrcTy->isVectorTy()) {\n    auto *VSrc = cast<VectorType>(SrcTy);\n    auto *VDest = cast<VectorType>(DestTy);\n    Assert(VSrc->getElementCount() == VDest->getElementCount(),\n           \"IntToPtr Vector width mismatch\", &I);\n  }\n  visitInstruction(I);\n}\n\nvoid Verifier::visitBitCastInst(BitCastInst &I) {\n  Assert(\n      CastInst::castIsValid(Instruction::BitCast, I.getOperand(0), I.getType()),\n      \"Invalid bitcast\", &I);\n  visitInstruction(I);\n}\n\nvoid Verifier::visitAddrSpaceCastInst(AddrSpaceCastInst &I) {\n  Type *SrcTy = I.getOperand(0)->getType();\n  Type *DestTy = I.getType();\n\n  Assert(SrcTy->isPtrOrPtrVectorTy(), \"AddrSpaceCast source must be a pointer\",\n         &I);\n  Assert(DestTy->isPtrOrPtrVectorTy(), \"AddrSpaceCast result must be a pointer\",\n         &I);\n  Assert(SrcTy->getPointerAddressSpace() != DestTy->getPointerAddressSpace(),\n         \"AddrSpaceCast must be between different address spaces\", &I);\n  if (auto *SrcVTy = dyn_cast<VectorType>(SrcTy))\n    Assert(SrcVTy->getElementCount() ==\n               cast<VectorType>(DestTy)->getElementCount(),\n           \"AddrSpaceCast vector pointer number of elements mismatch\", &I);\n  visitInstruction(I);\n}\n\n/// visitPHINode - Ensure that a PHI node is well formed.\n///\nvoid Verifier::visitPHINode(PHINode &PN) {\n  // Ensure that the PHI nodes are all grouped together at the top of the block.\n  // This can be tested by checking whether the instruction before this is\n  // either nonexistent (because this is begin()) or is a PHI node.  If not,\n  // then there is some other instruction before a PHI.\n  Assert(&PN == &PN.getParent()->front() ||\n             isa<PHINode>(--BasicBlock::iterator(&PN)),\n         \"PHI nodes not grouped at top of basic block!\", &PN, PN.getParent());\n\n  // Check that a PHI doesn't yield a Token.\n  Assert(!PN.getType()->isTokenTy(), \"PHI nodes cannot have token type!\");\n\n  // Check that all of the values of the PHI node have the same type as the\n  // result, and that the incoming blocks are really basic blocks.\n  for (Value *IncValue : PN.incoming_values()) {\n    Assert(PN.getType() == IncValue->getType(),\n           \"PHI node operands are not the same type as the result!\", &PN);\n  }\n\n  // All other PHI node constraints are checked in the visitBasicBlock method.\n\n  visitInstruction(PN);\n}\n\nvoid Verifier::visitCallBase(CallBase &Call) {\n  Assert(Call.getCalledOperand()->getType()->isPointerTy(),\n         \"Called function must be a pointer!\", Call);\n  PointerType *FPTy = cast<PointerType>(Call.getCalledOperand()->getType());\n\n  Assert(FPTy->getElementType()->isFunctionTy(),\n         \"Called function is not pointer to function type!\", Call);\n\n  Assert(FPTy->getElementType() == Call.getFunctionType(),\n         \"Called function is not the same type as the call!\", Call);\n\n  FunctionType *FTy = Call.getFunctionType();\n\n  // Verify that the correct number of arguments are being passed\n  if (FTy->isVarArg())\n    Assert(Call.arg_size() >= FTy->getNumParams(),\n           \"Called function requires more parameters than were provided!\",\n           Call);\n  else\n    Assert(Call.arg_size() == FTy->getNumParams(),\n           \"Incorrect number of arguments passed to called function!\", Call);\n\n  // Verify that all arguments to the call match the function type.\n  for (unsigned i = 0, e = FTy->getNumParams(); i != e; ++i)\n    Assert(Call.getArgOperand(i)->getType() == FTy->getParamType(i),\n           \"Call parameter type does not match function signature!\",\n           Call.getArgOperand(i), FTy->getParamType(i), Call);\n\n  AttributeList Attrs = Call.getAttributes();\n\n  Assert(verifyAttributeCount(Attrs, Call.arg_size()),\n         \"Attribute after last parameter!\", Call);\n\n  bool IsIntrinsic = Call.getCalledFunction() &&\n                     Call.getCalledFunction()->getName().startswith(\"llvm.\");\n\n  Function *Callee =\n      dyn_cast<Function>(Call.getCalledOperand()->stripPointerCasts());\n\n  if (Attrs.hasFnAttribute(Attribute::Speculatable)) {\n    // Don't allow speculatable on call sites, unless the underlying function\n    // declaration is also speculatable.\n    Assert(Callee && Callee->isSpeculatable(),\n           \"speculatable attribute may not apply to call sites\", Call);\n  }\n\n  if (Attrs.hasFnAttribute(Attribute::Preallocated)) {\n    Assert(Call.getCalledFunction()->getIntrinsicID() ==\n               Intrinsic::call_preallocated_arg,\n           \"preallocated as a call site attribute can only be on \"\n           \"llvm.call.preallocated.arg\");\n  }\n\n  // Verify call attributes.\n  verifyFunctionAttrs(FTy, Attrs, &Call, IsIntrinsic);\n\n  // Conservatively check the inalloca argument.\n  // We have a bug if we can find that there is an underlying alloca without\n  // inalloca.\n  if (Call.hasInAllocaArgument()) {\n    Value *InAllocaArg = Call.getArgOperand(FTy->getNumParams() - 1);\n    if (auto AI = dyn_cast<AllocaInst>(InAllocaArg->stripInBoundsOffsets()))\n      Assert(AI->isUsedWithInAlloca(),\n             \"inalloca argument for call has mismatched alloca\", AI, Call);\n  }\n\n  // For each argument of the callsite, if it has the swifterror argument,\n  // make sure the underlying alloca/parameter it comes from has a swifterror as\n  // well.\n  for (unsigned i = 0, e = FTy->getNumParams(); i != e; ++i) {\n    if (Call.paramHasAttr(i, Attribute::SwiftError)) {\n      Value *SwiftErrorArg = Call.getArgOperand(i);\n      if (auto AI = dyn_cast<AllocaInst>(SwiftErrorArg->stripInBoundsOffsets())) {\n        Assert(AI->isSwiftError(),\n               \"swifterror argument for call has mismatched alloca\", AI, Call);\n        continue;\n      }\n      auto ArgI = dyn_cast<Argument>(SwiftErrorArg);\n      Assert(ArgI,\n             \"swifterror argument should come from an alloca or parameter\",\n             SwiftErrorArg, Call);\n      Assert(ArgI->hasSwiftErrorAttr(),\n             \"swifterror argument for call has mismatched parameter\", ArgI,\n             Call);\n    }\n\n    if (Attrs.hasParamAttribute(i, Attribute::ImmArg)) {\n      // Don't allow immarg on call sites, unless the underlying declaration\n      // also has the matching immarg.\n      Assert(Callee && Callee->hasParamAttribute(i, Attribute::ImmArg),\n             \"immarg may not apply only to call sites\",\n             Call.getArgOperand(i), Call);\n    }\n\n    if (Call.paramHasAttr(i, Attribute::ImmArg)) {\n      Value *ArgVal = Call.getArgOperand(i);\n      Assert(isa<ConstantInt>(ArgVal) || isa<ConstantFP>(ArgVal),\n             \"immarg operand has non-immediate parameter\", ArgVal, Call);\n    }\n\n    if (Call.paramHasAttr(i, Attribute::Preallocated)) {\n      Value *ArgVal = Call.getArgOperand(i);\n      bool hasOB =\n          Call.countOperandBundlesOfType(LLVMContext::OB_preallocated) != 0;\n      bool isMustTail = Call.isMustTailCall();\n      Assert(hasOB != isMustTail,\n             \"preallocated operand either requires a preallocated bundle or \"\n             \"the call to be musttail (but not both)\",\n             ArgVal, Call);\n    }\n  }\n\n  if (FTy->isVarArg()) {\n    // FIXME? is 'nest' even legal here?\n    bool SawNest = false;\n    bool SawReturned = false;\n\n    for (unsigned Idx = 0; Idx < FTy->getNumParams(); ++Idx) {\n      if (Attrs.hasParamAttribute(Idx, Attribute::Nest))\n        SawNest = true;\n      if (Attrs.hasParamAttribute(Idx, Attribute::Returned))\n        SawReturned = true;\n    }\n\n    // Check attributes on the varargs part.\n    for (unsigned Idx = FTy->getNumParams(); Idx < Call.arg_size(); ++Idx) {\n      Type *Ty = Call.getArgOperand(Idx)->getType();\n      AttributeSet ArgAttrs = Attrs.getParamAttributes(Idx);\n      verifyParameterAttrs(ArgAttrs, Ty, &Call);\n\n      if (ArgAttrs.hasAttribute(Attribute::Nest)) {\n        Assert(!SawNest, \"More than one parameter has attribute nest!\", Call);\n        SawNest = true;\n      }\n\n      if (ArgAttrs.hasAttribute(Attribute::Returned)) {\n        Assert(!SawReturned, \"More than one parameter has attribute returned!\",\n               Call);\n        Assert(Ty->canLosslesslyBitCastTo(FTy->getReturnType()),\n               \"Incompatible argument and return types for 'returned' \"\n               \"attribute\",\n               Call);\n        SawReturned = true;\n      }\n\n      // Statepoint intrinsic is vararg but the wrapped function may be not.\n      // Allow sret here and check the wrapped function in verifyStatepoint.\n      if (!Call.getCalledFunction() ||\n          Call.getCalledFunction()->getIntrinsicID() !=\n              Intrinsic::experimental_gc_statepoint)\n        Assert(!ArgAttrs.hasAttribute(Attribute::StructRet),\n               \"Attribute 'sret' cannot be used for vararg call arguments!\",\n               Call);\n\n      if (ArgAttrs.hasAttribute(Attribute::InAlloca))\n        Assert(Idx == Call.arg_size() - 1,\n               \"inalloca isn't on the last argument!\", Call);\n    }\n  }\n\n  // Verify that there's no metadata unless it's a direct call to an intrinsic.\n  if (!IsIntrinsic) {\n    for (Type *ParamTy : FTy->params()) {\n      Assert(!ParamTy->isMetadataTy(),\n             \"Function has metadata parameter but isn't an intrinsic\", Call);\n      Assert(!ParamTy->isTokenTy(),\n             \"Function has token parameter but isn't an intrinsic\", Call);\n    }\n  }\n\n  // Verify that indirect calls don't return tokens.\n  if (!Call.getCalledFunction())\n    Assert(!FTy->getReturnType()->isTokenTy(),\n           \"Return type cannot be token for indirect call!\");\n\n  if (Function *F = Call.getCalledFunction())\n    if (Intrinsic::ID ID = (Intrinsic::ID)F->getIntrinsicID())\n      visitIntrinsicCall(ID, Call);\n\n  // Verify that a callsite has at most one \"deopt\", at most one \"funclet\", at\n  // most one \"gc-transition\", at most one \"cfguardtarget\",\n  // and at most one \"preallocated\" operand bundle.\n  bool FoundDeoptBundle = false, FoundFuncletBundle = false,\n       FoundGCTransitionBundle = false, FoundCFGuardTargetBundle = false,\n       FoundPreallocatedBundle = false, FoundGCLiveBundle = false;;\n  for (unsigned i = 0, e = Call.getNumOperandBundles(); i < e; ++i) {\n    OperandBundleUse BU = Call.getOperandBundleAt(i);\n    uint32_t Tag = BU.getTagID();\n    if (Tag == LLVMContext::OB_deopt) {\n      Assert(!FoundDeoptBundle, \"Multiple deopt operand bundles\", Call);\n      FoundDeoptBundle = true;\n    } else if (Tag == LLVMContext::OB_gc_transition) {\n      Assert(!FoundGCTransitionBundle, \"Multiple gc-transition operand bundles\",\n             Call);\n      FoundGCTransitionBundle = true;\n    } else if (Tag == LLVMContext::OB_funclet) {\n      Assert(!FoundFuncletBundle, \"Multiple funclet operand bundles\", Call);\n      FoundFuncletBundle = true;\n      Assert(BU.Inputs.size() == 1,\n             \"Expected exactly one funclet bundle operand\", Call);\n      Assert(isa<FuncletPadInst>(BU.Inputs.front()),\n             \"Funclet bundle operands should correspond to a FuncletPadInst\",\n             Call);\n    } else if (Tag == LLVMContext::OB_cfguardtarget) {\n      Assert(!FoundCFGuardTargetBundle,\n             \"Multiple CFGuardTarget operand bundles\", Call);\n      FoundCFGuardTargetBundle = true;\n      Assert(BU.Inputs.size() == 1,\n             \"Expected exactly one cfguardtarget bundle operand\", Call);\n    } else if (Tag == LLVMContext::OB_preallocated) {\n      Assert(!FoundPreallocatedBundle, \"Multiple preallocated operand bundles\",\n             Call);\n      FoundPreallocatedBundle = true;\n      Assert(BU.Inputs.size() == 1,\n             \"Expected exactly one preallocated bundle operand\", Call);\n      auto Input = dyn_cast<IntrinsicInst>(BU.Inputs.front());\n      Assert(Input &&\n                 Input->getIntrinsicID() == Intrinsic::call_preallocated_setup,\n             \"\\\"preallocated\\\" argument must be a token from \"\n             \"llvm.call.preallocated.setup\",\n             Call);\n    } else if (Tag == LLVMContext::OB_gc_live) {\n      Assert(!FoundGCLiveBundle, \"Multiple gc-live operand bundles\",\n             Call);\n      FoundGCLiveBundle = true;\n    }\n  }\n\n  // Verify that each inlinable callsite of a debug-info-bearing function in a\n  // debug-info-bearing function has a debug location attached to it. Failure to\n  // do so causes assertion failures when the inliner sets up inline scope info.\n  if (Call.getFunction()->getSubprogram() && Call.getCalledFunction() &&\n      Call.getCalledFunction()->getSubprogram())\n    AssertDI(Call.getDebugLoc(),\n             \"inlinable function call in a function with \"\n             \"debug info must have a !dbg location\",\n             Call);\n\n  visitInstruction(Call);\n}\n\n/// Two types are \"congruent\" if they are identical, or if they are both pointer\n/// types with different pointee types and the same address space.\nstatic bool isTypeCongruent(Type *L, Type *R) {\n  if (L == R)\n    return true;\n  PointerType *PL = dyn_cast<PointerType>(L);\n  PointerType *PR = dyn_cast<PointerType>(R);\n  if (!PL || !PR)\n    return false;\n  return PL->getAddressSpace() == PR->getAddressSpace();\n}\n\nstatic AttrBuilder getParameterABIAttributes(int I, AttributeList Attrs) {\n  static const Attribute::AttrKind ABIAttrs[] = {\n      Attribute::StructRet,    Attribute::ByVal,     Attribute::InAlloca,\n      Attribute::InReg,        Attribute::SwiftSelf, Attribute::SwiftError,\n      Attribute::Preallocated, Attribute::ByRef};\n  AttrBuilder Copy;\n  for (auto AK : ABIAttrs) {\n    if (Attrs.hasParamAttribute(I, AK))\n      Copy.addAttribute(AK);\n  }\n\n  // `align` is ABI-affecting only in combination with `byval` or `byref`.\n  if (Attrs.hasParamAttribute(I, Attribute::Alignment) &&\n      (Attrs.hasParamAttribute(I, Attribute::ByVal) ||\n       Attrs.hasParamAttribute(I, Attribute::ByRef)))\n    Copy.addAlignmentAttr(Attrs.getParamAlignment(I));\n  return Copy;\n}\n\nvoid Verifier::verifyMustTailCall(CallInst &CI) {\n  Assert(!CI.isInlineAsm(), \"cannot use musttail call with inline asm\", &CI);\n\n  // - The caller and callee prototypes must match.  Pointer types of\n  //   parameters or return types may differ in pointee type, but not\n  //   address space.\n  Function *F = CI.getParent()->getParent();\n  FunctionType *CallerTy = F->getFunctionType();\n  FunctionType *CalleeTy = CI.getFunctionType();\n  if (!CI.getCalledFunction() || !CI.getCalledFunction()->isIntrinsic()) {\n    Assert(CallerTy->getNumParams() == CalleeTy->getNumParams(),\n           \"cannot guarantee tail call due to mismatched parameter counts\",\n           &CI);\n    for (int I = 0, E = CallerTy->getNumParams(); I != E; ++I) {\n      Assert(\n          isTypeCongruent(CallerTy->getParamType(I), CalleeTy->getParamType(I)),\n          \"cannot guarantee tail call due to mismatched parameter types\", &CI);\n    }\n  }\n  Assert(CallerTy->isVarArg() == CalleeTy->isVarArg(),\n         \"cannot guarantee tail call due to mismatched varargs\", &CI);\n  Assert(isTypeCongruent(CallerTy->getReturnType(), CalleeTy->getReturnType()),\n         \"cannot guarantee tail call due to mismatched return types\", &CI);\n\n  // - The calling conventions of the caller and callee must match.\n  Assert(F->getCallingConv() == CI.getCallingConv(),\n         \"cannot guarantee tail call due to mismatched calling conv\", &CI);\n\n  // - All ABI-impacting function attributes, such as sret, byval, inreg,\n  //   returned, preallocated, and inalloca, must match.\n  AttributeList CallerAttrs = F->getAttributes();\n  AttributeList CalleeAttrs = CI.getAttributes();\n  for (int I = 0, E = CallerTy->getNumParams(); I != E; ++I) {\n    AttrBuilder CallerABIAttrs = getParameterABIAttributes(I, CallerAttrs);\n    AttrBuilder CalleeABIAttrs = getParameterABIAttributes(I, CalleeAttrs);\n    Assert(CallerABIAttrs == CalleeABIAttrs,\n           \"cannot guarantee tail call due to mismatched ABI impacting \"\n           \"function attributes\",\n           &CI, CI.getOperand(I));\n  }\n\n  // - The call must immediately precede a :ref:`ret <i_ret>` instruction,\n  //   or a pointer bitcast followed by a ret instruction.\n  // - The ret instruction must return the (possibly bitcasted) value\n  //   produced by the call or void.\n  Value *RetVal = &CI;\n  Instruction *Next = CI.getNextNode();\n\n  // Handle the optional bitcast.\n  if (BitCastInst *BI = dyn_cast_or_null<BitCastInst>(Next)) {\n    Assert(BI->getOperand(0) == RetVal,\n           \"bitcast following musttail call must use the call\", BI);\n    RetVal = BI;\n    Next = BI->getNextNode();\n  }\n\n  // Check the return.\n  ReturnInst *Ret = dyn_cast_or_null<ReturnInst>(Next);\n  Assert(Ret, \"musttail call must precede a ret with an optional bitcast\",\n         &CI);\n  Assert(!Ret->getReturnValue() || Ret->getReturnValue() == RetVal,\n         \"musttail call result must be returned\", Ret);\n}\n\nvoid Verifier::visitCallInst(CallInst &CI) {\n  visitCallBase(CI);\n\n  if (CI.isMustTailCall())\n    verifyMustTailCall(CI);\n}\n\nvoid Verifier::visitInvokeInst(InvokeInst &II) {\n  visitCallBase(II);\n\n  // Verify that the first non-PHI instruction of the unwind destination is an\n  // exception handling instruction.\n  Assert(\n      II.getUnwindDest()->isEHPad(),\n      \"The unwind destination does not have an exception handling instruction!\",\n      &II);\n\n  visitTerminator(II);\n}\n\n/// visitUnaryOperator - Check the argument to the unary operator.\n///\nvoid Verifier::visitUnaryOperator(UnaryOperator &U) {\n  Assert(U.getType() == U.getOperand(0)->getType(),\n         \"Unary operators must have same type for\"\n         \"operands and result!\",\n         &U);\n\n  switch (U.getOpcode()) {\n  // Check that floating-point arithmetic operators are only used with\n  // floating-point operands.\n  case Instruction::FNeg:\n    Assert(U.getType()->isFPOrFPVectorTy(),\n           \"FNeg operator only works with float types!\", &U);\n    break;\n  default:\n    llvm_unreachable(\"Unknown UnaryOperator opcode!\");\n  }\n\n  visitInstruction(U);\n}\n\n/// visitBinaryOperator - Check that both arguments to the binary operator are\n/// of the same type!\n///\nvoid Verifier::visitBinaryOperator(BinaryOperator &B) {\n  Assert(B.getOperand(0)->getType() == B.getOperand(1)->getType(),\n         \"Both operands to a binary operator are not of the same type!\", &B);\n\n  switch (B.getOpcode()) {\n  // Check that integer arithmetic operators are only used with\n  // integral operands.\n  case Instruction::Add:\n  case Instruction::Sub:\n  case Instruction::Mul:\n  case Instruction::SDiv:\n  case Instruction::UDiv:\n  case Instruction::SRem:\n  case Instruction::URem:\n    Assert(B.getType()->isIntOrIntVectorTy(),\n           \"Integer arithmetic operators only work with integral types!\", &B);\n    Assert(B.getType() == B.getOperand(0)->getType(),\n           \"Integer arithmetic operators must have same type \"\n           \"for operands and result!\",\n           &B);\n    break;\n  // Check that floating-point arithmetic operators are only used with\n  // floating-point operands.\n  case Instruction::FAdd:\n  case Instruction::FSub:\n  case Instruction::FMul:\n  case Instruction::FDiv:\n  case Instruction::FRem:\n    Assert(B.getType()->isFPOrFPVectorTy(),\n           \"Floating-point arithmetic operators only work with \"\n           \"floating-point types!\",\n           &B);\n    Assert(B.getType() == B.getOperand(0)->getType(),\n           \"Floating-point arithmetic operators must have same type \"\n           \"for operands and result!\",\n           &B);\n    break;\n  // Check that logical operators are only used with integral operands.\n  case Instruction::And:\n  case Instruction::Or:\n  case Instruction::Xor:\n    Assert(B.getType()->isIntOrIntVectorTy(),\n           \"Logical operators only work with integral types!\", &B);\n    Assert(B.getType() == B.getOperand(0)->getType(),\n           \"Logical operators must have same type for operands and result!\",\n           &B);\n    break;\n  case Instruction::Shl:\n  case Instruction::LShr:\n  case Instruction::AShr:\n    Assert(B.getType()->isIntOrIntVectorTy(),\n           \"Shifts only work with integral types!\", &B);\n    Assert(B.getType() == B.getOperand(0)->getType(),\n           \"Shift return type must be same as operands!\", &B);\n    break;\n  default:\n    llvm_unreachable(\"Unknown BinaryOperator opcode!\");\n  }\n\n  visitInstruction(B);\n}\n\nvoid Verifier::visitICmpInst(ICmpInst &IC) {\n  // Check that the operands are the same type\n  Type *Op0Ty = IC.getOperand(0)->getType();\n  Type *Op1Ty = IC.getOperand(1)->getType();\n  Assert(Op0Ty == Op1Ty,\n         \"Both operands to ICmp instruction are not of the same type!\", &IC);\n  // Check that the operands are the right type\n  Assert(Op0Ty->isIntOrIntVectorTy() || Op0Ty->isPtrOrPtrVectorTy(),\n         \"Invalid operand types for ICmp instruction\", &IC);\n  // Check that the predicate is valid.\n  Assert(IC.isIntPredicate(),\n         \"Invalid predicate in ICmp instruction!\", &IC);\n\n  visitInstruction(IC);\n}\n\nvoid Verifier::visitFCmpInst(FCmpInst &FC) {\n  // Check that the operands are the same type\n  Type *Op0Ty = FC.getOperand(0)->getType();\n  Type *Op1Ty = FC.getOperand(1)->getType();\n  Assert(Op0Ty == Op1Ty,\n         \"Both operands to FCmp instruction are not of the same type!\", &FC);\n  // Check that the operands are the right type\n  Assert(Op0Ty->isFPOrFPVectorTy(),\n         \"Invalid operand types for FCmp instruction\", &FC);\n  // Check that the predicate is valid.\n  Assert(FC.isFPPredicate(),\n         \"Invalid predicate in FCmp instruction!\", &FC);\n\n  visitInstruction(FC);\n}\n\nvoid Verifier::visitExtractElementInst(ExtractElementInst &EI) {\n  Assert(\n      ExtractElementInst::isValidOperands(EI.getOperand(0), EI.getOperand(1)),\n      \"Invalid extractelement operands!\", &EI);\n  visitInstruction(EI);\n}\n\nvoid Verifier::visitInsertElementInst(InsertElementInst &IE) {\n  Assert(InsertElementInst::isValidOperands(IE.getOperand(0), IE.getOperand(1),\n                                            IE.getOperand(2)),\n         \"Invalid insertelement operands!\", &IE);\n  visitInstruction(IE);\n}\n\nvoid Verifier::visitShuffleVectorInst(ShuffleVectorInst &SV) {\n  Assert(ShuffleVectorInst::isValidOperands(SV.getOperand(0), SV.getOperand(1),\n                                            SV.getShuffleMask()),\n         \"Invalid shufflevector operands!\", &SV);\n  visitInstruction(SV);\n}\n\nvoid Verifier::visitGetElementPtrInst(GetElementPtrInst &GEP) {\n  Type *TargetTy = GEP.getPointerOperandType()->getScalarType();\n\n  Assert(isa<PointerType>(TargetTy),\n         \"GEP base pointer is not a vector or a vector of pointers\", &GEP);\n  Assert(GEP.getSourceElementType()->isSized(), \"GEP into unsized type!\", &GEP);\n\n  SmallVector<Value *, 16> Idxs(GEP.indices());\n  Assert(all_of(\n      Idxs, [](Value* V) { return V->getType()->isIntOrIntVectorTy(); }),\n      \"GEP indexes must be integers\", &GEP);\n  Type *ElTy =\n      GetElementPtrInst::getIndexedType(GEP.getSourceElementType(), Idxs);\n  Assert(ElTy, \"Invalid indices for GEP pointer type!\", &GEP);\n\n  Assert(GEP.getType()->isPtrOrPtrVectorTy() &&\n             GEP.getResultElementType() == ElTy,\n         \"GEP is not of right type for indices!\", &GEP, ElTy);\n\n  if (auto *GEPVTy = dyn_cast<VectorType>(GEP.getType())) {\n    // Additional checks for vector GEPs.\n    ElementCount GEPWidth = GEPVTy->getElementCount();\n    if (GEP.getPointerOperandType()->isVectorTy())\n      Assert(\n          GEPWidth ==\n              cast<VectorType>(GEP.getPointerOperandType())->getElementCount(),\n          \"Vector GEP result width doesn't match operand's\", &GEP);\n    for (Value *Idx : Idxs) {\n      Type *IndexTy = Idx->getType();\n      if (auto *IndexVTy = dyn_cast<VectorType>(IndexTy)) {\n        ElementCount IndexWidth = IndexVTy->getElementCount();\n        Assert(IndexWidth == GEPWidth, \"Invalid GEP index vector width\", &GEP);\n      }\n      Assert(IndexTy->isIntOrIntVectorTy(),\n             \"All GEP indices should be of integer type\");\n    }\n  }\n\n  if (auto *PTy = dyn_cast<PointerType>(GEP.getType())) {\n    Assert(GEP.getAddressSpace() == PTy->getAddressSpace(),\n           \"GEP address space doesn't match type\", &GEP);\n  }\n\n  visitInstruction(GEP);\n}\n\nstatic bool isContiguous(const ConstantRange &A, const ConstantRange &B) {\n  return A.getUpper() == B.getLower() || A.getLower() == B.getUpper();\n}\n\nvoid Verifier::visitRangeMetadata(Instruction &I, MDNode *Range, Type *Ty) {\n  assert(Range && Range == I.getMetadata(LLVMContext::MD_range) &&\n         \"precondition violation\");\n\n  unsigned NumOperands = Range->getNumOperands();\n  Assert(NumOperands % 2 == 0, \"Unfinished range!\", Range);\n  unsigned NumRanges = NumOperands / 2;\n  Assert(NumRanges >= 1, \"It should have at least one range!\", Range);\n\n  ConstantRange LastRange(1, true); // Dummy initial value\n  for (unsigned i = 0; i < NumRanges; ++i) {\n    ConstantInt *Low =\n        mdconst::dyn_extract<ConstantInt>(Range->getOperand(2 * i));\n    Assert(Low, \"The lower limit must be an integer!\", Low);\n    ConstantInt *High =\n        mdconst::dyn_extract<ConstantInt>(Range->getOperand(2 * i + 1));\n    Assert(High, \"The upper limit must be an integer!\", High);\n    Assert(High->getType() == Low->getType() && High->getType() == Ty,\n           \"Range types must match instruction type!\", &I);\n\n    APInt HighV = High->getValue();\n    APInt LowV = Low->getValue();\n    ConstantRange CurRange(LowV, HighV);\n    Assert(!CurRange.isEmptySet() && !CurRange.isFullSet(),\n           \"Range must not be empty!\", Range);\n    if (i != 0) {\n      Assert(CurRange.intersectWith(LastRange).isEmptySet(),\n             \"Intervals are overlapping\", Range);\n      Assert(LowV.sgt(LastRange.getLower()), \"Intervals are not in order\",\n             Range);\n      Assert(!isContiguous(CurRange, LastRange), \"Intervals are contiguous\",\n             Range);\n    }\n    LastRange = ConstantRange(LowV, HighV);\n  }\n  if (NumRanges > 2) {\n    APInt FirstLow =\n        mdconst::dyn_extract<ConstantInt>(Range->getOperand(0))->getValue();\n    APInt FirstHigh =\n        mdconst::dyn_extract<ConstantInt>(Range->getOperand(1))->getValue();\n    ConstantRange FirstRange(FirstLow, FirstHigh);\n    Assert(FirstRange.intersectWith(LastRange).isEmptySet(),\n           \"Intervals are overlapping\", Range);\n    Assert(!isContiguous(FirstRange, LastRange), \"Intervals are contiguous\",\n           Range);\n  }\n}\n\nvoid Verifier::checkAtomicMemAccessSize(Type *Ty, const Instruction *I) {\n  unsigned Size = DL.getTypeSizeInBits(Ty);\n  Assert(Size >= 8, \"atomic memory access' size must be byte-sized\", Ty, I);\n  Assert(!(Size & (Size - 1)),\n         \"atomic memory access' operand must have a power-of-two size\", Ty, I);\n}\n\nvoid Verifier::visitLoadInst(LoadInst &LI) {\n  PointerType *PTy = dyn_cast<PointerType>(LI.getOperand(0)->getType());\n  Assert(PTy, \"Load operand must be a pointer.\", &LI);\n  Type *ElTy = LI.getType();\n  Assert(LI.getAlignment() <= Value::MaximumAlignment,\n         \"huge alignment values are unsupported\", &LI);\n  Assert(ElTy->isSized(), \"loading unsized types is not allowed\", &LI);\n  if (LI.isAtomic()) {\n    Assert(LI.getOrdering() != AtomicOrdering::Release &&\n               LI.getOrdering() != AtomicOrdering::AcquireRelease,\n           \"Load cannot have Release ordering\", &LI);\n    Assert(LI.getAlignment() != 0,\n           \"Atomic load must specify explicit alignment\", &LI);\n    Assert(ElTy->isIntOrPtrTy() || ElTy->isFloatingPointTy(),\n           \"atomic load operand must have integer, pointer, or floating point \"\n           \"type!\",\n           ElTy, &LI);\n    checkAtomicMemAccessSize(ElTy, &LI);\n  } else {\n    Assert(LI.getSyncScopeID() == SyncScope::System,\n           \"Non-atomic load cannot have SynchronizationScope specified\", &LI);\n  }\n\n  visitInstruction(LI);\n}\n\nvoid Verifier::visitStoreInst(StoreInst &SI) {\n  PointerType *PTy = dyn_cast<PointerType>(SI.getOperand(1)->getType());\n  Assert(PTy, \"Store operand must be a pointer.\", &SI);\n  Type *ElTy = PTy->getElementType();\n  Assert(ElTy == SI.getOperand(0)->getType(),\n         \"Stored value type does not match pointer operand type!\", &SI, ElTy);\n  Assert(SI.getAlignment() <= Value::MaximumAlignment,\n         \"huge alignment values are unsupported\", &SI);\n  Assert(ElTy->isSized(), \"storing unsized types is not allowed\", &SI);\n  if (SI.isAtomic()) {\n    Assert(SI.getOrdering() != AtomicOrdering::Acquire &&\n               SI.getOrdering() != AtomicOrdering::AcquireRelease,\n           \"Store cannot have Acquire ordering\", &SI);\n    Assert(SI.getAlignment() != 0,\n           \"Atomic store must specify explicit alignment\", &SI);\n    Assert(ElTy->isIntOrPtrTy() || ElTy->isFloatingPointTy(),\n           \"atomic store operand must have integer, pointer, or floating point \"\n           \"type!\",\n           ElTy, &SI);\n    checkAtomicMemAccessSize(ElTy, &SI);\n  } else {\n    Assert(SI.getSyncScopeID() == SyncScope::System,\n           \"Non-atomic store cannot have SynchronizationScope specified\", &SI);\n  }\n  visitInstruction(SI);\n}\n\n/// Check that SwiftErrorVal is used as a swifterror argument in CS.\nvoid Verifier::verifySwiftErrorCall(CallBase &Call,\n                                    const Value *SwiftErrorVal) {\n  unsigned Idx = 0;\n  for (auto I = Call.arg_begin(), E = Call.arg_end(); I != E; ++I, ++Idx) {\n    if (*I == SwiftErrorVal) {\n      Assert(Call.paramHasAttr(Idx, Attribute::SwiftError),\n             \"swifterror value when used in a callsite should be marked \"\n             \"with swifterror attribute\",\n             SwiftErrorVal, Call);\n    }\n  }\n}\n\nvoid Verifier::verifySwiftErrorValue(const Value *SwiftErrorVal) {\n  // Check that swifterror value is only used by loads, stores, or as\n  // a swifterror argument.\n  for (const User *U : SwiftErrorVal->users()) {\n    Assert(isa<LoadInst>(U) || isa<StoreInst>(U) || isa<CallInst>(U) ||\n           isa<InvokeInst>(U),\n           \"swifterror value can only be loaded and stored from, or \"\n           \"as a swifterror argument!\",\n           SwiftErrorVal, U);\n    // If it is used by a store, check it is the second operand.\n    if (auto StoreI = dyn_cast<StoreInst>(U))\n      Assert(StoreI->getOperand(1) == SwiftErrorVal,\n             \"swifterror value should be the second operand when used \"\n             \"by stores\", SwiftErrorVal, U);\n    if (auto *Call = dyn_cast<CallBase>(U))\n      verifySwiftErrorCall(*const_cast<CallBase *>(Call), SwiftErrorVal);\n  }\n}\n\nvoid Verifier::visitAllocaInst(AllocaInst &AI) {\n  SmallPtrSet<Type*, 4> Visited;\n  PointerType *PTy = AI.getType();\n  // TODO: Relax this restriction?\n  Assert(PTy->getAddressSpace() == DL.getAllocaAddrSpace(),\n         \"Allocation instruction pointer not in the stack address space!\",\n         &AI);\n  Assert(AI.getAllocatedType()->isSized(&Visited),\n         \"Cannot allocate unsized type\", &AI);\n  Assert(AI.getArraySize()->getType()->isIntegerTy(),\n         \"Alloca array size must have integer type\", &AI);\n  Assert(AI.getAlignment() <= Value::MaximumAlignment,\n         \"huge alignment values are unsupported\", &AI);\n\n  if (AI.isSwiftError()) {\n    verifySwiftErrorValue(&AI);\n  }\n\n  visitInstruction(AI);\n}\n\nvoid Verifier::visitAtomicCmpXchgInst(AtomicCmpXchgInst &CXI) {\n\n  // FIXME: more conditions???\n  Assert(CXI.getSuccessOrdering() != AtomicOrdering::NotAtomic,\n         \"cmpxchg instructions must be atomic.\", &CXI);\n  Assert(CXI.getFailureOrdering() != AtomicOrdering::NotAtomic,\n         \"cmpxchg instructions must be atomic.\", &CXI);\n  Assert(CXI.getSuccessOrdering() != AtomicOrdering::Unordered,\n         \"cmpxchg instructions cannot be unordered.\", &CXI);\n  Assert(CXI.getFailureOrdering() != AtomicOrdering::Unordered,\n         \"cmpxchg instructions cannot be unordered.\", &CXI);\n  Assert(!isStrongerThan(CXI.getFailureOrdering(), CXI.getSuccessOrdering()),\n         \"cmpxchg instructions failure argument shall be no stronger than the \"\n         \"success argument\",\n         &CXI);\n  Assert(CXI.getFailureOrdering() != AtomicOrdering::Release &&\n             CXI.getFailureOrdering() != AtomicOrdering::AcquireRelease,\n         \"cmpxchg failure ordering cannot include release semantics\", &CXI);\n\n  PointerType *PTy = dyn_cast<PointerType>(CXI.getOperand(0)->getType());\n  Assert(PTy, \"First cmpxchg operand must be a pointer.\", &CXI);\n  Type *ElTy = PTy->getElementType();\n  Assert(ElTy->isIntOrPtrTy(),\n         \"cmpxchg operand must have integer or pointer type\", ElTy, &CXI);\n  checkAtomicMemAccessSize(ElTy, &CXI);\n  Assert(ElTy == CXI.getOperand(1)->getType(),\n         \"Expected value type does not match pointer operand type!\", &CXI,\n         ElTy);\n  Assert(ElTy == CXI.getOperand(2)->getType(),\n         \"Stored value type does not match pointer operand type!\", &CXI, ElTy);\n  visitInstruction(CXI);\n}\n\nvoid Verifier::visitAtomicRMWInst(AtomicRMWInst &RMWI) {\n  Assert(RMWI.getOrdering() != AtomicOrdering::NotAtomic,\n         \"atomicrmw instructions must be atomic.\", &RMWI);\n  Assert(RMWI.getOrdering() != AtomicOrdering::Unordered,\n         \"atomicrmw instructions cannot be unordered.\", &RMWI);\n  auto Op = RMWI.getOperation();\n  PointerType *PTy = dyn_cast<PointerType>(RMWI.getOperand(0)->getType());\n  Assert(PTy, \"First atomicrmw operand must be a pointer.\", &RMWI);\n  Type *ElTy = PTy->getElementType();\n  if (Op == AtomicRMWInst::Xchg) {\n    Assert(ElTy->isIntegerTy() || ElTy->isFloatingPointTy(), \"atomicrmw \" +\n           AtomicRMWInst::getOperationName(Op) +\n           \" operand must have integer or floating point type!\",\n           &RMWI, ElTy);\n  } else if (AtomicRMWInst::isFPOperation(Op)) {\n    Assert(ElTy->isFloatingPointTy(), \"atomicrmw \" +\n           AtomicRMWInst::getOperationName(Op) +\n           \" operand must have floating point type!\",\n           &RMWI, ElTy);\n  } else {\n    Assert(ElTy->isIntegerTy(), \"atomicrmw \" +\n           AtomicRMWInst::getOperationName(Op) +\n           \" operand must have integer type!\",\n           &RMWI, ElTy);\n  }\n  checkAtomicMemAccessSize(ElTy, &RMWI);\n  Assert(ElTy == RMWI.getOperand(1)->getType(),\n         \"Argument value type does not match pointer operand type!\", &RMWI,\n         ElTy);\n  Assert(AtomicRMWInst::FIRST_BINOP <= Op && Op <= AtomicRMWInst::LAST_BINOP,\n         \"Invalid binary operation!\", &RMWI);\n  visitInstruction(RMWI);\n}\n\nvoid Verifier::visitFenceInst(FenceInst &FI) {\n  const AtomicOrdering Ordering = FI.getOrdering();\n  Assert(Ordering == AtomicOrdering::Acquire ||\n             Ordering == AtomicOrdering::Release ||\n             Ordering == AtomicOrdering::AcquireRelease ||\n             Ordering == AtomicOrdering::SequentiallyConsistent,\n         \"fence instructions may only have acquire, release, acq_rel, or \"\n         \"seq_cst ordering.\",\n         &FI);\n  visitInstruction(FI);\n}\n\nvoid Verifier::visitExtractValueInst(ExtractValueInst &EVI) {\n  Assert(ExtractValueInst::getIndexedType(EVI.getAggregateOperand()->getType(),\n                                          EVI.getIndices()) == EVI.getType(),\n         \"Invalid ExtractValueInst operands!\", &EVI);\n\n  visitInstruction(EVI);\n}\n\nvoid Verifier::visitInsertValueInst(InsertValueInst &IVI) {\n  Assert(ExtractValueInst::getIndexedType(IVI.getAggregateOperand()->getType(),\n                                          IVI.getIndices()) ==\n             IVI.getOperand(1)->getType(),\n         \"Invalid InsertValueInst operands!\", &IVI);\n\n  visitInstruction(IVI);\n}\n\nstatic Value *getParentPad(Value *EHPad) {\n  if (auto *FPI = dyn_cast<FuncletPadInst>(EHPad))\n    return FPI->getParentPad();\n\n  return cast<CatchSwitchInst>(EHPad)->getParentPad();\n}\n\nvoid Verifier::visitEHPadPredecessors(Instruction &I) {\n  assert(I.isEHPad());\n\n  BasicBlock *BB = I.getParent();\n  Function *F = BB->getParent();\n\n  Assert(BB != &F->getEntryBlock(), \"EH pad cannot be in entry block.\", &I);\n\n  if (auto *LPI = dyn_cast<LandingPadInst>(&I)) {\n    // The landingpad instruction defines its parent as a landing pad block. The\n    // landing pad block may be branched to only by the unwind edge of an\n    // invoke.\n    for (BasicBlock *PredBB : predecessors(BB)) {\n      const auto *II = dyn_cast<InvokeInst>(PredBB->getTerminator());\n      Assert(II && II->getUnwindDest() == BB && II->getNormalDest() != BB,\n             \"Block containing LandingPadInst must be jumped to \"\n             \"only by the unwind edge of an invoke.\",\n             LPI);\n    }\n    return;\n  }\n  if (auto *CPI = dyn_cast<CatchPadInst>(&I)) {\n    if (!pred_empty(BB))\n      Assert(BB->getUniquePredecessor() == CPI->getCatchSwitch()->getParent(),\n             \"Block containg CatchPadInst must be jumped to \"\n             \"only by its catchswitch.\",\n             CPI);\n    Assert(BB != CPI->getCatchSwitch()->getUnwindDest(),\n           \"Catchswitch cannot unwind to one of its catchpads\",\n           CPI->getCatchSwitch(), CPI);\n    return;\n  }\n\n  // Verify that each pred has a legal terminator with a legal to/from EH\n  // pad relationship.\n  Instruction *ToPad = &I;\n  Value *ToPadParent = getParentPad(ToPad);\n  for (BasicBlock *PredBB : predecessors(BB)) {\n    Instruction *TI = PredBB->getTerminator();\n    Value *FromPad;\n    if (auto *II = dyn_cast<InvokeInst>(TI)) {\n      Assert(II->getUnwindDest() == BB && II->getNormalDest() != BB,\n             \"EH pad must be jumped to via an unwind edge\", ToPad, II);\n      if (auto Bundle = II->getOperandBundle(LLVMContext::OB_funclet))\n        FromPad = Bundle->Inputs[0];\n      else\n        FromPad = ConstantTokenNone::get(II->getContext());\n    } else if (auto *CRI = dyn_cast<CleanupReturnInst>(TI)) {\n      FromPad = CRI->getOperand(0);\n      Assert(FromPad != ToPadParent, \"A cleanupret must exit its cleanup\", CRI);\n    } else if (auto *CSI = dyn_cast<CatchSwitchInst>(TI)) {\n      FromPad = CSI;\n    } else {\n      Assert(false, \"EH pad must be jumped to via an unwind edge\", ToPad, TI);\n    }\n\n    // The edge may exit from zero or more nested pads.\n    SmallSet<Value *, 8> Seen;\n    for (;; FromPad = getParentPad(FromPad)) {\n      Assert(FromPad != ToPad,\n             \"EH pad cannot handle exceptions raised within it\", FromPad, TI);\n      if (FromPad == ToPadParent) {\n        // This is a legal unwind edge.\n        break;\n      }\n      Assert(!isa<ConstantTokenNone>(FromPad),\n             \"A single unwind edge may only enter one EH pad\", TI);\n      Assert(Seen.insert(FromPad).second,\n             \"EH pad jumps through a cycle of pads\", FromPad);\n    }\n  }\n}\n\nvoid Verifier::visitLandingPadInst(LandingPadInst &LPI) {\n  // The landingpad instruction is ill-formed if it doesn't have any clauses and\n  // isn't a cleanup.\n  Assert(LPI.getNumClauses() > 0 || LPI.isCleanup(),\n         \"LandingPadInst needs at least one clause or to be a cleanup.\", &LPI);\n\n  visitEHPadPredecessors(LPI);\n\n  if (!LandingPadResultTy)\n    LandingPadResultTy = LPI.getType();\n  else\n    Assert(LandingPadResultTy == LPI.getType(),\n           \"The landingpad instruction should have a consistent result type \"\n           \"inside a function.\",\n           &LPI);\n\n  Function *F = LPI.getParent()->getParent();\n  Assert(F->hasPersonalityFn(),\n         \"LandingPadInst needs to be in a function with a personality.\", &LPI);\n\n  // The landingpad instruction must be the first non-PHI instruction in the\n  // block.\n  Assert(LPI.getParent()->getLandingPadInst() == &LPI,\n         \"LandingPadInst not the first non-PHI instruction in the block.\",\n         &LPI);\n\n  for (unsigned i = 0, e = LPI.getNumClauses(); i < e; ++i) {\n    Constant *Clause = LPI.getClause(i);\n    if (LPI.isCatch(i)) {\n      Assert(isa<PointerType>(Clause->getType()),\n             \"Catch operand does not have pointer type!\", &LPI);\n    } else {\n      Assert(LPI.isFilter(i), \"Clause is neither catch nor filter!\", &LPI);\n      Assert(isa<ConstantArray>(Clause) || isa<ConstantAggregateZero>(Clause),\n             \"Filter operand is not an array of constants!\", &LPI);\n    }\n  }\n\n  visitInstruction(LPI);\n}\n\nvoid Verifier::visitResumeInst(ResumeInst &RI) {\n  Assert(RI.getFunction()->hasPersonalityFn(),\n         \"ResumeInst needs to be in a function with a personality.\", &RI);\n\n  if (!LandingPadResultTy)\n    LandingPadResultTy = RI.getValue()->getType();\n  else\n    Assert(LandingPadResultTy == RI.getValue()->getType(),\n           \"The resume instruction should have a consistent result type \"\n           \"inside a function.\",\n           &RI);\n\n  visitTerminator(RI);\n}\n\nvoid Verifier::visitCatchPadInst(CatchPadInst &CPI) {\n  BasicBlock *BB = CPI.getParent();\n\n  Function *F = BB->getParent();\n  Assert(F->hasPersonalityFn(),\n         \"CatchPadInst needs to be in a function with a personality.\", &CPI);\n\n  Assert(isa<CatchSwitchInst>(CPI.getParentPad()),\n         \"CatchPadInst needs to be directly nested in a CatchSwitchInst.\",\n         CPI.getParentPad());\n\n  // The catchpad instruction must be the first non-PHI instruction in the\n  // block.\n  Assert(BB->getFirstNonPHI() == &CPI,\n         \"CatchPadInst not the first non-PHI instruction in the block.\", &CPI);\n\n  visitEHPadPredecessors(CPI);\n  visitFuncletPadInst(CPI);\n}\n\nvoid Verifier::visitCatchReturnInst(CatchReturnInst &CatchReturn) {\n  Assert(isa<CatchPadInst>(CatchReturn.getOperand(0)),\n         \"CatchReturnInst needs to be provided a CatchPad\", &CatchReturn,\n         CatchReturn.getOperand(0));\n\n  visitTerminator(CatchReturn);\n}\n\nvoid Verifier::visitCleanupPadInst(CleanupPadInst &CPI) {\n  BasicBlock *BB = CPI.getParent();\n\n  Function *F = BB->getParent();\n  Assert(F->hasPersonalityFn(),\n         \"CleanupPadInst needs to be in a function with a personality.\", &CPI);\n\n  // The cleanuppad instruction must be the first non-PHI instruction in the\n  // block.\n  Assert(BB->getFirstNonPHI() == &CPI,\n         \"CleanupPadInst not the first non-PHI instruction in the block.\",\n         &CPI);\n\n  auto *ParentPad = CPI.getParentPad();\n  Assert(isa<ConstantTokenNone>(ParentPad) || isa<FuncletPadInst>(ParentPad),\n         \"CleanupPadInst has an invalid parent.\", &CPI);\n\n  visitEHPadPredecessors(CPI);\n  visitFuncletPadInst(CPI);\n}\n\nvoid Verifier::visitFuncletPadInst(FuncletPadInst &FPI) {\n  User *FirstUser = nullptr;\n  Value *FirstUnwindPad = nullptr;\n  SmallVector<FuncletPadInst *, 8> Worklist({&FPI});\n  SmallSet<FuncletPadInst *, 8> Seen;\n\n  while (!Worklist.empty()) {\n    FuncletPadInst *CurrentPad = Worklist.pop_back_val();\n    Assert(Seen.insert(CurrentPad).second,\n           \"FuncletPadInst must not be nested within itself\", CurrentPad);\n    Value *UnresolvedAncestorPad = nullptr;\n    for (User *U : CurrentPad->users()) {\n      BasicBlock *UnwindDest;\n      if (auto *CRI = dyn_cast<CleanupReturnInst>(U)) {\n        UnwindDest = CRI->getUnwindDest();\n      } else if (auto *CSI = dyn_cast<CatchSwitchInst>(U)) {\n        // We allow catchswitch unwind to caller to nest\n        // within an outer pad that unwinds somewhere else,\n        // because catchswitch doesn't have a nounwind variant.\n        // See e.g. SimplifyCFGOpt::SimplifyUnreachable.\n        if (CSI->unwindsToCaller())\n          continue;\n        UnwindDest = CSI->getUnwindDest();\n      } else if (auto *II = dyn_cast<InvokeInst>(U)) {\n        UnwindDest = II->getUnwindDest();\n      } else if (isa<CallInst>(U)) {\n        // Calls which don't unwind may be found inside funclet\n        // pads that unwind somewhere else.  We don't *require*\n        // such calls to be annotated nounwind.\n        continue;\n      } else if (auto *CPI = dyn_cast<CleanupPadInst>(U)) {\n        // The unwind dest for a cleanup can only be found by\n        // recursive search.  Add it to the worklist, and we'll\n        // search for its first use that determines where it unwinds.\n        Worklist.push_back(CPI);\n        continue;\n      } else {\n        Assert(isa<CatchReturnInst>(U), \"Bogus funclet pad use\", U);\n        continue;\n      }\n\n      Value *UnwindPad;\n      bool ExitsFPI;\n      if (UnwindDest) {\n        UnwindPad = UnwindDest->getFirstNonPHI();\n        if (!cast<Instruction>(UnwindPad)->isEHPad())\n          continue;\n        Value *UnwindParent = getParentPad(UnwindPad);\n        // Ignore unwind edges that don't exit CurrentPad.\n        if (UnwindParent == CurrentPad)\n          continue;\n        // Determine whether the original funclet pad is exited,\n        // and if we are scanning nested pads determine how many\n        // of them are exited so we can stop searching their\n        // children.\n        Value *ExitedPad = CurrentPad;\n        ExitsFPI = false;\n        do {\n          if (ExitedPad == &FPI) {\n            ExitsFPI = true;\n            // Now we can resolve any ancestors of CurrentPad up to\n            // FPI, but not including FPI since we need to make sure\n            // to check all direct users of FPI for consistency.\n            UnresolvedAncestorPad = &FPI;\n            break;\n          }\n          Value *ExitedParent = getParentPad(ExitedPad);\n          if (ExitedParent == UnwindParent) {\n            // ExitedPad is the ancestor-most pad which this unwind\n            // edge exits, so we can resolve up to it, meaning that\n            // ExitedParent is the first ancestor still unresolved.\n            UnresolvedAncestorPad = ExitedParent;\n            break;\n          }\n          ExitedPad = ExitedParent;\n        } while (!isa<ConstantTokenNone>(ExitedPad));\n      } else {\n        // Unwinding to caller exits all pads.\n        UnwindPad = ConstantTokenNone::get(FPI.getContext());\n        ExitsFPI = true;\n        UnresolvedAncestorPad = &FPI;\n      }\n\n      if (ExitsFPI) {\n        // This unwind edge exits FPI.  Make sure it agrees with other\n        // such edges.\n        if (FirstUser) {\n          Assert(UnwindPad == FirstUnwindPad, \"Unwind edges out of a funclet \"\n                                              \"pad must have the same unwind \"\n                                              \"dest\",\n                 &FPI, U, FirstUser);\n        } else {\n          FirstUser = U;\n          FirstUnwindPad = UnwindPad;\n          // Record cleanup sibling unwinds for verifySiblingFuncletUnwinds\n          if (isa<CleanupPadInst>(&FPI) && !isa<ConstantTokenNone>(UnwindPad) &&\n              getParentPad(UnwindPad) == getParentPad(&FPI))\n            SiblingFuncletInfo[&FPI] = cast<Instruction>(U);\n        }\n      }\n      // Make sure we visit all uses of FPI, but for nested pads stop as\n      // soon as we know where they unwind to.\n      if (CurrentPad != &FPI)\n        break;\n    }\n    if (UnresolvedAncestorPad) {\n      if (CurrentPad == UnresolvedAncestorPad) {\n        // When CurrentPad is FPI itself, we don't mark it as resolved even if\n        // we've found an unwind edge that exits it, because we need to verify\n        // all direct uses of FPI.\n        assert(CurrentPad == &FPI);\n        continue;\n      }\n      // Pop off the worklist any nested pads that we've found an unwind\n      // destination for.  The pads on the worklist are the uncles,\n      // great-uncles, etc. of CurrentPad.  We've found an unwind destination\n      // for all ancestors of CurrentPad up to but not including\n      // UnresolvedAncestorPad.\n      Value *ResolvedPad = CurrentPad;\n      while (!Worklist.empty()) {\n        Value *UnclePad = Worklist.back();\n        Value *AncestorPad = getParentPad(UnclePad);\n        // Walk ResolvedPad up the ancestor list until we either find the\n        // uncle's parent or the last resolved ancestor.\n        while (ResolvedPad != AncestorPad) {\n          Value *ResolvedParent = getParentPad(ResolvedPad);\n          if (ResolvedParent == UnresolvedAncestorPad) {\n            break;\n          }\n          ResolvedPad = ResolvedParent;\n        }\n        // If the resolved ancestor search didn't find the uncle's parent,\n        // then the uncle is not yet resolved.\n        if (ResolvedPad != AncestorPad)\n          break;\n        // This uncle is resolved, so pop it from the worklist.\n        Worklist.pop_back();\n      }\n    }\n  }\n\n  if (FirstUnwindPad) {\n    if (auto *CatchSwitch = dyn_cast<CatchSwitchInst>(FPI.getParentPad())) {\n      BasicBlock *SwitchUnwindDest = CatchSwitch->getUnwindDest();\n      Value *SwitchUnwindPad;\n      if (SwitchUnwindDest)\n        SwitchUnwindPad = SwitchUnwindDest->getFirstNonPHI();\n      else\n        SwitchUnwindPad = ConstantTokenNone::get(FPI.getContext());\n      Assert(SwitchUnwindPad == FirstUnwindPad,\n             \"Unwind edges out of a catch must have the same unwind dest as \"\n             \"the parent catchswitch\",\n             &FPI, FirstUser, CatchSwitch);\n    }\n  }\n\n  visitInstruction(FPI);\n}\n\nvoid Verifier::visitCatchSwitchInst(CatchSwitchInst &CatchSwitch) {\n  BasicBlock *BB = CatchSwitch.getParent();\n\n  Function *F = BB->getParent();\n  Assert(F->hasPersonalityFn(),\n         \"CatchSwitchInst needs to be in a function with a personality.\",\n         &CatchSwitch);\n\n  // The catchswitch instruction must be the first non-PHI instruction in the\n  // block.\n  Assert(BB->getFirstNonPHI() == &CatchSwitch,\n         \"CatchSwitchInst not the first non-PHI instruction in the block.\",\n         &CatchSwitch);\n\n  auto *ParentPad = CatchSwitch.getParentPad();\n  Assert(isa<ConstantTokenNone>(ParentPad) || isa<FuncletPadInst>(ParentPad),\n         \"CatchSwitchInst has an invalid parent.\", ParentPad);\n\n  if (BasicBlock *UnwindDest = CatchSwitch.getUnwindDest()) {\n    Instruction *I = UnwindDest->getFirstNonPHI();\n    Assert(I->isEHPad() && !isa<LandingPadInst>(I),\n           \"CatchSwitchInst must unwind to an EH block which is not a \"\n           \"landingpad.\",\n           &CatchSwitch);\n\n    // Record catchswitch sibling unwinds for verifySiblingFuncletUnwinds\n    if (getParentPad(I) == ParentPad)\n      SiblingFuncletInfo[&CatchSwitch] = &CatchSwitch;\n  }\n\n  Assert(CatchSwitch.getNumHandlers() != 0,\n         \"CatchSwitchInst cannot have empty handler list\", &CatchSwitch);\n\n  for (BasicBlock *Handler : CatchSwitch.handlers()) {\n    Assert(isa<CatchPadInst>(Handler->getFirstNonPHI()),\n           \"CatchSwitchInst handlers must be catchpads\", &CatchSwitch, Handler);\n  }\n\n  visitEHPadPredecessors(CatchSwitch);\n  visitTerminator(CatchSwitch);\n}\n\nvoid Verifier::visitCleanupReturnInst(CleanupReturnInst &CRI) {\n  Assert(isa<CleanupPadInst>(CRI.getOperand(0)),\n         \"CleanupReturnInst needs to be provided a CleanupPad\", &CRI,\n         CRI.getOperand(0));\n\n  if (BasicBlock *UnwindDest = CRI.getUnwindDest()) {\n    Instruction *I = UnwindDest->getFirstNonPHI();\n    Assert(I->isEHPad() && !isa<LandingPadInst>(I),\n           \"CleanupReturnInst must unwind to an EH block which is not a \"\n           \"landingpad.\",\n           &CRI);\n  }\n\n  visitTerminator(CRI);\n}\n\nvoid Verifier::verifyDominatesUse(Instruction &I, unsigned i) {\n  Instruction *Op = cast<Instruction>(I.getOperand(i));\n  // If the we have an invalid invoke, don't try to compute the dominance.\n  // We already reject it in the invoke specific checks and the dominance\n  // computation doesn't handle multiple edges.\n  if (InvokeInst *II = dyn_cast<InvokeInst>(Op)) {\n    if (II->getNormalDest() == II->getUnwindDest())\n      return;\n  }\n\n  // Quick check whether the def has already been encountered in the same block.\n  // PHI nodes are not checked to prevent accepting preceding PHIs, because PHI\n  // uses are defined to happen on the incoming edge, not at the instruction.\n  //\n  // FIXME: If this operand is a MetadataAsValue (wrapping a LocalAsMetadata)\n  // wrapping an SSA value, assert that we've already encountered it.  See\n  // related FIXME in Mapper::mapLocalAsMetadata in ValueMapper.cpp.\n  if (!isa<PHINode>(I) && InstsInThisBlock.count(Op))\n    return;\n\n  const Use &U = I.getOperandUse(i);\n  Assert(DT.dominates(Op, U),\n         \"Instruction does not dominate all uses!\", Op, &I);\n}\n\nvoid Verifier::visitDereferenceableMetadata(Instruction& I, MDNode* MD) {\n  Assert(I.getType()->isPointerTy(), \"dereferenceable, dereferenceable_or_null \"\n         \"apply only to pointer types\", &I);\n  Assert((isa<LoadInst>(I) || isa<IntToPtrInst>(I)),\n         \"dereferenceable, dereferenceable_or_null apply only to load\"\n         \" and inttoptr instructions, use attributes for calls or invokes\", &I);\n  Assert(MD->getNumOperands() == 1, \"dereferenceable, dereferenceable_or_null \"\n         \"take one operand!\", &I);\n  ConstantInt *CI = mdconst::dyn_extract<ConstantInt>(MD->getOperand(0));\n  Assert(CI && CI->getType()->isIntegerTy(64), \"dereferenceable, \"\n         \"dereferenceable_or_null metadata value must be an i64!\", &I);\n}\n\nvoid Verifier::visitProfMetadata(Instruction &I, MDNode *MD) {\n  Assert(MD->getNumOperands() >= 2,\n         \"!prof annotations should have no less than 2 operands\", MD);\n\n  // Check first operand.\n  Assert(MD->getOperand(0) != nullptr, \"first operand should not be null\", MD);\n  Assert(isa<MDString>(MD->getOperand(0)),\n         \"expected string with name of the !prof annotation\", MD);\n  MDString *MDS = cast<MDString>(MD->getOperand(0));\n  StringRef ProfName = MDS->getString();\n\n  // Check consistency of !prof branch_weights metadata.\n  if (ProfName.equals(\"branch_weights\")) {\n    if (isa<InvokeInst>(&I)) {\n      Assert(MD->getNumOperands() == 2 || MD->getNumOperands() == 3,\n             \"Wrong number of InvokeInst branch_weights operands\", MD);\n    } else {\n      unsigned ExpectedNumOperands = 0;\n      if (BranchInst *BI = dyn_cast<BranchInst>(&I))\n        ExpectedNumOperands = BI->getNumSuccessors();\n      else if (SwitchInst *SI = dyn_cast<SwitchInst>(&I))\n        ExpectedNumOperands = SI->getNumSuccessors();\n      else if (isa<CallInst>(&I))\n        ExpectedNumOperands = 1;\n      else if (IndirectBrInst *IBI = dyn_cast<IndirectBrInst>(&I))\n        ExpectedNumOperands = IBI->getNumDestinations();\n      else if (isa<SelectInst>(&I))\n        ExpectedNumOperands = 2;\n      else\n        CheckFailed(\"!prof branch_weights are not allowed for this instruction\",\n                    MD);\n\n      Assert(MD->getNumOperands() == 1 + ExpectedNumOperands,\n             \"Wrong number of operands\", MD);\n    }\n    for (unsigned i = 1; i < MD->getNumOperands(); ++i) {\n      auto &MDO = MD->getOperand(i);\n      Assert(MDO, \"second operand should not be null\", MD);\n      Assert(mdconst::dyn_extract<ConstantInt>(MDO),\n             \"!prof brunch_weights operand is not a const int\");\n    }\n  }\n}\n\nvoid Verifier::visitAnnotationMetadata(MDNode *Annotation) {\n  Assert(isa<MDTuple>(Annotation), \"annotation must be a tuple\");\n  Assert(Annotation->getNumOperands() >= 1,\n         \"annotation must have at least one operand\");\n  for (const MDOperand &Op : Annotation->operands())\n    Assert(isa<MDString>(Op.get()), \"operands must be strings\");\n}\n\n/// verifyInstruction - Verify that an instruction is well formed.\n///\nvoid Verifier::visitInstruction(Instruction &I) {\n  BasicBlock *BB = I.getParent();\n  Assert(BB, \"Instruction not embedded in basic block!\", &I);\n\n  if (!isa<PHINode>(I)) {   // Check that non-phi nodes are not self referential\n    for (User *U : I.users()) {\n      Assert(U != (User *)&I || !DT.isReachableFromEntry(BB),\n             \"Only PHI nodes may reference their own value!\", &I);\n    }\n  }\n\n  // Check that void typed values don't have names\n  Assert(!I.getType()->isVoidTy() || !I.hasName(),\n         \"Instruction has a name, but provides a void value!\", &I);\n\n  // Check that the return value of the instruction is either void or a legal\n  // value type.\n  Assert(I.getType()->isVoidTy() || I.getType()->isFirstClassType(),\n         \"Instruction returns a non-scalar type!\", &I);\n\n  // Check that the instruction doesn't produce metadata. Calls are already\n  // checked against the callee type.\n  Assert(!I.getType()->isMetadataTy() || isa<CallInst>(I) || isa<InvokeInst>(I),\n         \"Invalid use of metadata!\", &I);\n\n  // Check that all uses of the instruction, if they are instructions\n  // themselves, actually have parent basic blocks.  If the use is not an\n  // instruction, it is an error!\n  for (Use &U : I.uses()) {\n    if (Instruction *Used = dyn_cast<Instruction>(U.getUser()))\n      Assert(Used->getParent() != nullptr,\n             \"Instruction referencing\"\n             \" instruction not embedded in a basic block!\",\n             &I, Used);\n    else {\n      CheckFailed(\"Use of instruction is not an instruction!\", U);\n      return;\n    }\n  }\n\n  // Get a pointer to the call base of the instruction if it is some form of\n  // call.\n  const CallBase *CBI = dyn_cast<CallBase>(&I);\n\n  for (unsigned i = 0, e = I.getNumOperands(); i != e; ++i) {\n    Assert(I.getOperand(i) != nullptr, \"Instruction has null operand!\", &I);\n\n    // Check to make sure that only first-class-values are operands to\n    // instructions.\n    if (!I.getOperand(i)->getType()->isFirstClassType()) {\n      Assert(false, \"Instruction operands must be first-class values!\", &I);\n    }\n\n    if (Function *F = dyn_cast<Function>(I.getOperand(i))) {\n      // Check to make sure that the \"address of\" an intrinsic function is never\n      // taken.\n      Assert(!F->isIntrinsic() ||\n                 (CBI && &CBI->getCalledOperandUse() == &I.getOperandUse(i)),\n             \"Cannot take the address of an intrinsic!\", &I);\n      Assert(\n          !F->isIntrinsic() || isa<CallInst>(I) ||\n              F->getIntrinsicID() == Intrinsic::donothing ||\n              F->getIntrinsicID() == Intrinsic::coro_resume ||\n              F->getIntrinsicID() == Intrinsic::coro_destroy ||\n              F->getIntrinsicID() == Intrinsic::experimental_patchpoint_void ||\n              F->getIntrinsicID() == Intrinsic::experimental_patchpoint_i64 ||\n              F->getIntrinsicID() == Intrinsic::experimental_gc_statepoint ||\n              F->getIntrinsicID() == Intrinsic::wasm_rethrow,\n          \"Cannot invoke an intrinsic other than donothing, patchpoint, \"\n          \"statepoint, coro_resume or coro_destroy\",\n          &I);\n      Assert(F->getParent() == &M, \"Referencing function in another module!\",\n             &I, &M, F, F->getParent());\n    } else if (BasicBlock *OpBB = dyn_cast<BasicBlock>(I.getOperand(i))) {\n      Assert(OpBB->getParent() == BB->getParent(),\n             \"Referring to a basic block in another function!\", &I);\n    } else if (Argument *OpArg = dyn_cast<Argument>(I.getOperand(i))) {\n      Assert(OpArg->getParent() == BB->getParent(),\n             \"Referring to an argument in another function!\", &I);\n    } else if (GlobalValue *GV = dyn_cast<GlobalValue>(I.getOperand(i))) {\n      Assert(GV->getParent() == &M, \"Referencing global in another module!\", &I,\n             &M, GV, GV->getParent());\n    } else if (isa<Instruction>(I.getOperand(i))) {\n      verifyDominatesUse(I, i);\n    } else if (isa<InlineAsm>(I.getOperand(i))) {\n      Assert(CBI && &CBI->getCalledOperandUse() == &I.getOperandUse(i),\n             \"Cannot take the address of an inline asm!\", &I);\n    } else if (ConstantExpr *CE = dyn_cast<ConstantExpr>(I.getOperand(i))) {\n      if (CE->getType()->isPtrOrPtrVectorTy() ||\n          !DL.getNonIntegralAddressSpaces().empty()) {\n        // If we have a ConstantExpr pointer, we need to see if it came from an\n        // illegal bitcast.  If the datalayout string specifies non-integral\n        // address spaces then we also need to check for illegal ptrtoint and\n        // inttoptr expressions.\n        visitConstantExprsRecursively(CE);\n      }\n    }\n  }\n\n  if (MDNode *MD = I.getMetadata(LLVMContext::MD_fpmath)) {\n    Assert(I.getType()->isFPOrFPVectorTy(),\n           \"fpmath requires a floating point result!\", &I);\n    Assert(MD->getNumOperands() == 1, \"fpmath takes one operand!\", &I);\n    if (ConstantFP *CFP0 =\n            mdconst::dyn_extract_or_null<ConstantFP>(MD->getOperand(0))) {\n      const APFloat &Accuracy = CFP0->getValueAPF();\n      Assert(&Accuracy.getSemantics() == &APFloat::IEEEsingle(),\n             \"fpmath accuracy must have float type\", &I);\n      Assert(Accuracy.isFiniteNonZero() && !Accuracy.isNegative(),\n             \"fpmath accuracy not a positive number!\", &I);\n    } else {\n      Assert(false, \"invalid fpmath accuracy!\", &I);\n    }\n  }\n\n  if (MDNode *Range = I.getMetadata(LLVMContext::MD_range)) {\n    Assert(isa<LoadInst>(I) || isa<CallInst>(I) || isa<InvokeInst>(I),\n           \"Ranges are only for loads, calls and invokes!\", &I);\n    visitRangeMetadata(I, Range, I.getType());\n  }\n\n  if (I.getMetadata(LLVMContext::MD_nonnull)) {\n    Assert(I.getType()->isPointerTy(), \"nonnull applies only to pointer types\",\n           &I);\n    Assert(isa<LoadInst>(I),\n           \"nonnull applies only to load instructions, use attributes\"\n           \" for calls or invokes\",\n           &I);\n  }\n\n  if (MDNode *MD = I.getMetadata(LLVMContext::MD_dereferenceable))\n    visitDereferenceableMetadata(I, MD);\n\n  if (MDNode *MD = I.getMetadata(LLVMContext::MD_dereferenceable_or_null))\n    visitDereferenceableMetadata(I, MD);\n\n  if (MDNode *TBAA = I.getMetadata(LLVMContext::MD_tbaa))\n    TBAAVerifyHelper.visitTBAAMetadata(I, TBAA);\n\n  if (MDNode *AlignMD = I.getMetadata(LLVMContext::MD_align)) {\n    Assert(I.getType()->isPointerTy(), \"align applies only to pointer types\",\n           &I);\n    Assert(isa<LoadInst>(I), \"align applies only to load instructions, \"\n           \"use attributes for calls or invokes\", &I);\n    Assert(AlignMD->getNumOperands() == 1, \"align takes one operand!\", &I);\n    ConstantInt *CI = mdconst::dyn_extract<ConstantInt>(AlignMD->getOperand(0));\n    Assert(CI && CI->getType()->isIntegerTy(64),\n           \"align metadata value must be an i64!\", &I);\n    uint64_t Align = CI->getZExtValue();\n    Assert(isPowerOf2_64(Align),\n           \"align metadata value must be a power of 2!\", &I);\n    Assert(Align <= Value::MaximumAlignment,\n           \"alignment is larger that implementation defined limit\", &I);\n  }\n\n  if (MDNode *MD = I.getMetadata(LLVMContext::MD_prof))\n    visitProfMetadata(I, MD);\n\n  if (MDNode *Annotation = I.getMetadata(LLVMContext::MD_annotation))\n    visitAnnotationMetadata(Annotation);\n\n  if (MDNode *N = I.getDebugLoc().getAsMDNode()) {\n    AssertDI(isa<DILocation>(N), \"invalid !dbg metadata attachment\", &I, N);\n    visitMDNode(*N, AreDebugLocsAllowed::Yes);\n  }\n\n  if (auto *DII = dyn_cast<DbgVariableIntrinsic>(&I)) {\n    verifyFragmentExpression(*DII);\n    verifyNotEntryValue(*DII);\n  }\n\n  SmallVector<std::pair<unsigned, MDNode *>, 4> MDs;\n  I.getAllMetadata(MDs);\n  for (auto Attachment : MDs) {\n    unsigned Kind = Attachment.first;\n    auto AllowLocs =\n        (Kind == LLVMContext::MD_dbg || Kind == LLVMContext::MD_loop)\n            ? AreDebugLocsAllowed::Yes\n            : AreDebugLocsAllowed::No;\n    visitMDNode(*Attachment.second, AllowLocs);\n  }\n\n  InstsInThisBlock.insert(&I);\n}\n\n/// Allow intrinsics to be verified in different ways.\nvoid Verifier::visitIntrinsicCall(Intrinsic::ID ID, CallBase &Call) {\n  Function *IF = Call.getCalledFunction();\n  Assert(IF->isDeclaration(), \"Intrinsic functions should never be defined!\",\n         IF);\n\n  // Verify that the intrinsic prototype lines up with what the .td files\n  // describe.\n  FunctionType *IFTy = IF->getFunctionType();\n  bool IsVarArg = IFTy->isVarArg();\n\n  SmallVector<Intrinsic::IITDescriptor, 8> Table;\n  getIntrinsicInfoTableEntries(ID, Table);\n  ArrayRef<Intrinsic::IITDescriptor> TableRef = Table;\n\n  // Walk the descriptors to extract overloaded types.\n  SmallVector<Type *, 4> ArgTys;\n  Intrinsic::MatchIntrinsicTypesResult Res =\n      Intrinsic::matchIntrinsicSignature(IFTy, TableRef, ArgTys);\n  Assert(Res != Intrinsic::MatchIntrinsicTypes_NoMatchRet,\n         \"Intrinsic has incorrect return type!\", IF);\n  Assert(Res != Intrinsic::MatchIntrinsicTypes_NoMatchArg,\n         \"Intrinsic has incorrect argument type!\", IF);\n\n  // Verify if the intrinsic call matches the vararg property.\n  if (IsVarArg)\n    Assert(!Intrinsic::matchIntrinsicVarArg(IsVarArg, TableRef),\n           \"Intrinsic was not defined with variable arguments!\", IF);\n  else\n    Assert(!Intrinsic::matchIntrinsicVarArg(IsVarArg, TableRef),\n           \"Callsite was not defined with variable arguments!\", IF);\n\n  // All descriptors should be absorbed by now.\n  Assert(TableRef.empty(), \"Intrinsic has too few arguments!\", IF);\n\n  // Now that we have the intrinsic ID and the actual argument types (and we\n  // know they are legal for the intrinsic!) get the intrinsic name through the\n  // usual means.  This allows us to verify the mangling of argument types into\n  // the name.\n  const std::string ExpectedName = Intrinsic::getName(ID, ArgTys);\n  Assert(ExpectedName == IF->getName(),\n         \"Intrinsic name not mangled correctly for type arguments! \"\n         \"Should be: \" +\n             ExpectedName,\n         IF);\n\n  // If the intrinsic takes MDNode arguments, verify that they are either global\n  // or are local to *this* function.\n  for (Value *V : Call.args())\n    if (auto *MD = dyn_cast<MetadataAsValue>(V))\n      visitMetadataAsValue(*MD, Call.getCaller());\n\n  switch (ID) {\n  default:\n    break;\n  case Intrinsic::assume: {\n    for (auto &Elem : Call.bundle_op_infos()) {\n      Assert(Elem.Tag->getKey() == \"ignore\" ||\n                 Attribute::isExistingAttribute(Elem.Tag->getKey()),\n             \"tags must be valid attribute names\");\n      Attribute::AttrKind Kind =\n          Attribute::getAttrKindFromName(Elem.Tag->getKey());\n      unsigned ArgCount = Elem.End - Elem.Begin;\n      if (Kind == Attribute::Alignment) {\n        Assert(ArgCount <= 3 && ArgCount >= 2,\n               \"alignment assumptions should have 2 or 3 arguments\");\n        Assert(Call.getOperand(Elem.Begin)->getType()->isPointerTy(),\n               \"first argument should be a pointer\");\n        Assert(Call.getOperand(Elem.Begin + 1)->getType()->isIntegerTy(),\n               \"second argument should be an integer\");\n        if (ArgCount == 3)\n          Assert(Call.getOperand(Elem.Begin + 2)->getType()->isIntegerTy(),\n                 \"third argument should be an integer if present\");\n        return;\n      }\n      Assert(ArgCount <= 2, \"to many arguments\");\n      if (Kind == Attribute::None)\n        break;\n      if (Attribute::doesAttrKindHaveArgument(Kind)) {\n        Assert(ArgCount == 2, \"this attribute should have 2 arguments\");\n        Assert(isa<ConstantInt>(Call.getOperand(Elem.Begin + 1)),\n               \"the second argument should be a constant integral value\");\n      } else if (isFuncOnlyAttr(Kind)) {\n        Assert((ArgCount) == 0, \"this attribute has no argument\");\n      } else if (!isFuncOrArgAttr(Kind)) {\n        Assert((ArgCount) == 1, \"this attribute should have one argument\");\n      }\n    }\n    break;\n  }\n  case Intrinsic::coro_id: {\n    auto *InfoArg = Call.getArgOperand(3)->stripPointerCasts();\n    if (isa<ConstantPointerNull>(InfoArg))\n      break;\n    auto *GV = dyn_cast<GlobalVariable>(InfoArg);\n    Assert(GV && GV->isConstant() && GV->hasDefinitiveInitializer(),\n      \"info argument of llvm.coro.begin must refer to an initialized \"\n      \"constant\");\n    Constant *Init = GV->getInitializer();\n    Assert(isa<ConstantStruct>(Init) || isa<ConstantArray>(Init),\n      \"info argument of llvm.coro.begin must refer to either a struct or \"\n      \"an array\");\n    break;\n  }\n#define INSTRUCTION(NAME, NARGS, ROUND_MODE, INTRINSIC)                        \\\n  case Intrinsic::INTRINSIC:\n#include \"llvm/IR/ConstrainedOps.def\"\n    visitConstrainedFPIntrinsic(cast<ConstrainedFPIntrinsic>(Call));\n    break;\n  case Intrinsic::dbg_declare: // llvm.dbg.declare\n    Assert(isa<MetadataAsValue>(Call.getArgOperand(0)),\n           \"invalid llvm.dbg.declare intrinsic call 1\", Call);\n    visitDbgIntrinsic(\"declare\", cast<DbgVariableIntrinsic>(Call));\n    break;\n  case Intrinsic::dbg_addr: // llvm.dbg.addr\n    visitDbgIntrinsic(\"addr\", cast<DbgVariableIntrinsic>(Call));\n    break;\n  case Intrinsic::dbg_value: // llvm.dbg.value\n    visitDbgIntrinsic(\"value\", cast<DbgVariableIntrinsic>(Call));\n    break;\n  case Intrinsic::dbg_label: // llvm.dbg.label\n    visitDbgLabelIntrinsic(\"label\", cast<DbgLabelInst>(Call));\n    break;\n  case Intrinsic::memcpy:\n  case Intrinsic::memcpy_inline:\n  case Intrinsic::memmove:\n  case Intrinsic::memset: {\n    const auto *MI = cast<MemIntrinsic>(&Call);\n    auto IsValidAlignment = [&](unsigned Alignment) -> bool {\n      return Alignment == 0 || isPowerOf2_32(Alignment);\n    };\n    Assert(IsValidAlignment(MI->getDestAlignment()),\n           \"alignment of arg 0 of memory intrinsic must be 0 or a power of 2\",\n           Call);\n    if (const auto *MTI = dyn_cast<MemTransferInst>(MI)) {\n      Assert(IsValidAlignment(MTI->getSourceAlignment()),\n             \"alignment of arg 1 of memory intrinsic must be 0 or a power of 2\",\n             Call);\n    }\n\n    break;\n  }\n  case Intrinsic::memcpy_element_unordered_atomic:\n  case Intrinsic::memmove_element_unordered_atomic:\n  case Intrinsic::memset_element_unordered_atomic: {\n    const auto *AMI = cast<AtomicMemIntrinsic>(&Call);\n\n    ConstantInt *ElementSizeCI =\n        cast<ConstantInt>(AMI->getRawElementSizeInBytes());\n    const APInt &ElementSizeVal = ElementSizeCI->getValue();\n    Assert(ElementSizeVal.isPowerOf2(),\n           \"element size of the element-wise atomic memory intrinsic \"\n           \"must be a power of 2\",\n           Call);\n\n    auto IsValidAlignment = [&](uint64_t Alignment) {\n      return isPowerOf2_64(Alignment) && ElementSizeVal.ule(Alignment);\n    };\n    uint64_t DstAlignment = AMI->getDestAlignment();\n    Assert(IsValidAlignment(DstAlignment),\n           \"incorrect alignment of the destination argument\", Call);\n    if (const auto *AMT = dyn_cast<AtomicMemTransferInst>(AMI)) {\n      uint64_t SrcAlignment = AMT->getSourceAlignment();\n      Assert(IsValidAlignment(SrcAlignment),\n             \"incorrect alignment of the source argument\", Call);\n    }\n    break;\n  }\n  case Intrinsic::call_preallocated_setup: {\n    auto *NumArgs = dyn_cast<ConstantInt>(Call.getArgOperand(0));\n    Assert(NumArgs != nullptr,\n           \"llvm.call.preallocated.setup argument must be a constant\");\n    bool FoundCall = false;\n    for (User *U : Call.users()) {\n      auto *UseCall = dyn_cast<CallBase>(U);\n      Assert(UseCall != nullptr,\n             \"Uses of llvm.call.preallocated.setup must be calls\");\n      const Function *Fn = UseCall->getCalledFunction();\n      if (Fn && Fn->getIntrinsicID() == Intrinsic::call_preallocated_arg) {\n        auto *AllocArgIndex = dyn_cast<ConstantInt>(UseCall->getArgOperand(1));\n        Assert(AllocArgIndex != nullptr,\n               \"llvm.call.preallocated.alloc arg index must be a constant\");\n        auto AllocArgIndexInt = AllocArgIndex->getValue();\n        Assert(AllocArgIndexInt.sge(0) &&\n                   AllocArgIndexInt.slt(NumArgs->getValue()),\n               \"llvm.call.preallocated.alloc arg index must be between 0 and \"\n               \"corresponding \"\n               \"llvm.call.preallocated.setup's argument count\");\n      } else if (Fn && Fn->getIntrinsicID() ==\n                           Intrinsic::call_preallocated_teardown) {\n        // nothing to do\n      } else {\n        Assert(!FoundCall, \"Can have at most one call corresponding to a \"\n                           \"llvm.call.preallocated.setup\");\n        FoundCall = true;\n        size_t NumPreallocatedArgs = 0;\n        for (unsigned i = 0; i < UseCall->getNumArgOperands(); i++) {\n          if (UseCall->paramHasAttr(i, Attribute::Preallocated)) {\n            ++NumPreallocatedArgs;\n          }\n        }\n        Assert(NumPreallocatedArgs != 0,\n               \"cannot use preallocated intrinsics on a call without \"\n               \"preallocated arguments\");\n        Assert(NumArgs->equalsInt(NumPreallocatedArgs),\n               \"llvm.call.preallocated.setup arg size must be equal to number \"\n               \"of preallocated arguments \"\n               \"at call site\",\n               Call, *UseCall);\n        // getOperandBundle() cannot be called if more than one of the operand\n        // bundle exists. There is already a check elsewhere for this, so skip\n        // here if we see more than one.\n        if (UseCall->countOperandBundlesOfType(LLVMContext::OB_preallocated) >\n            1) {\n          return;\n        }\n        auto PreallocatedBundle =\n            UseCall->getOperandBundle(LLVMContext::OB_preallocated);\n        Assert(PreallocatedBundle,\n               \"Use of llvm.call.preallocated.setup outside intrinsics \"\n               \"must be in \\\"preallocated\\\" operand bundle\");\n        Assert(PreallocatedBundle->Inputs.front().get() == &Call,\n               \"preallocated bundle must have token from corresponding \"\n               \"llvm.call.preallocated.setup\");\n      }\n    }\n    break;\n  }\n  case Intrinsic::call_preallocated_arg: {\n    auto *Token = dyn_cast<CallBase>(Call.getArgOperand(0));\n    Assert(Token && Token->getCalledFunction()->getIntrinsicID() ==\n                        Intrinsic::call_preallocated_setup,\n           \"llvm.call.preallocated.arg token argument must be a \"\n           \"llvm.call.preallocated.setup\");\n    Assert(Call.hasFnAttr(Attribute::Preallocated),\n           \"llvm.call.preallocated.arg must be called with a \\\"preallocated\\\" \"\n           \"call site attribute\");\n    break;\n  }\n  case Intrinsic::call_preallocated_teardown: {\n    auto *Token = dyn_cast<CallBase>(Call.getArgOperand(0));\n    Assert(Token && Token->getCalledFunction()->getIntrinsicID() ==\n                        Intrinsic::call_preallocated_setup,\n           \"llvm.call.preallocated.teardown token argument must be a \"\n           \"llvm.call.preallocated.setup\");\n    break;\n  }\n  case Intrinsic::gcroot:\n  case Intrinsic::gcwrite:\n  case Intrinsic::gcread:\n    if (ID == Intrinsic::gcroot) {\n      AllocaInst *AI =\n          dyn_cast<AllocaInst>(Call.getArgOperand(0)->stripPointerCasts());\n      Assert(AI, \"llvm.gcroot parameter #1 must be an alloca.\", Call);\n      Assert(isa<Constant>(Call.getArgOperand(1)),\n             \"llvm.gcroot parameter #2 must be a constant.\", Call);\n      if (!AI->getAllocatedType()->isPointerTy()) {\n        Assert(!isa<ConstantPointerNull>(Call.getArgOperand(1)),\n               \"llvm.gcroot parameter #1 must either be a pointer alloca, \"\n               \"or argument #2 must be a non-null constant.\",\n               Call);\n      }\n    }\n\n    Assert(Call.getParent()->getParent()->hasGC(),\n           \"Enclosing function does not use GC.\", Call);\n    break;\n  case Intrinsic::init_trampoline:\n    Assert(isa<Function>(Call.getArgOperand(1)->stripPointerCasts()),\n           \"llvm.init_trampoline parameter #2 must resolve to a function.\",\n           Call);\n    break;\n  case Intrinsic::prefetch:\n    Assert(cast<ConstantInt>(Call.getArgOperand(1))->getZExtValue() < 2 &&\n           cast<ConstantInt>(Call.getArgOperand(2))->getZExtValue() < 4,\n           \"invalid arguments to llvm.prefetch\", Call);\n    break;\n  case Intrinsic::stackprotector:\n    Assert(isa<AllocaInst>(Call.getArgOperand(1)->stripPointerCasts()),\n           \"llvm.stackprotector parameter #2 must resolve to an alloca.\", Call);\n    break;\n  case Intrinsic::localescape: {\n    BasicBlock *BB = Call.getParent();\n    Assert(BB == &BB->getParent()->front(),\n           \"llvm.localescape used outside of entry block\", Call);\n    Assert(!SawFrameEscape,\n           \"multiple calls to llvm.localescape in one function\", Call);\n    for (Value *Arg : Call.args()) {\n      if (isa<ConstantPointerNull>(Arg))\n        continue; // Null values are allowed as placeholders.\n      auto *AI = dyn_cast<AllocaInst>(Arg->stripPointerCasts());\n      Assert(AI && AI->isStaticAlloca(),\n             \"llvm.localescape only accepts static allocas\", Call);\n    }\n    FrameEscapeInfo[BB->getParent()].first = Call.getNumArgOperands();\n    SawFrameEscape = true;\n    break;\n  }\n  case Intrinsic::localrecover: {\n    Value *FnArg = Call.getArgOperand(0)->stripPointerCasts();\n    Function *Fn = dyn_cast<Function>(FnArg);\n    Assert(Fn && !Fn->isDeclaration(),\n           \"llvm.localrecover first \"\n           \"argument must be function defined in this module\",\n           Call);\n    auto *IdxArg = cast<ConstantInt>(Call.getArgOperand(2));\n    auto &Entry = FrameEscapeInfo[Fn];\n    Entry.second = unsigned(\n        std::max(uint64_t(Entry.second), IdxArg->getLimitedValue(~0U) + 1));\n    break;\n  }\n\n  case Intrinsic::experimental_gc_statepoint:\n    if (auto *CI = dyn_cast<CallInst>(&Call))\n      Assert(!CI->isInlineAsm(),\n             \"gc.statepoint support for inline assembly unimplemented\", CI);\n    Assert(Call.getParent()->getParent()->hasGC(),\n           \"Enclosing function does not use GC.\", Call);\n\n    verifyStatepoint(Call);\n    break;\n  case Intrinsic::experimental_gc_result: {\n    Assert(Call.getParent()->getParent()->hasGC(),\n           \"Enclosing function does not use GC.\", Call);\n    // Are we tied to a statepoint properly?\n    const auto *StatepointCall = dyn_cast<CallBase>(Call.getArgOperand(0));\n    const Function *StatepointFn =\n        StatepointCall ? StatepointCall->getCalledFunction() : nullptr;\n    Assert(StatepointFn && StatepointFn->isDeclaration() &&\n               StatepointFn->getIntrinsicID() ==\n                   Intrinsic::experimental_gc_statepoint,\n           \"gc.result operand #1 must be from a statepoint\", Call,\n           Call.getArgOperand(0));\n\n    // Assert that result type matches wrapped callee.\n    const Value *Target = StatepointCall->getArgOperand(2);\n    auto *PT = cast<PointerType>(Target->getType());\n    auto *TargetFuncType = cast<FunctionType>(PT->getElementType());\n    Assert(Call.getType() == TargetFuncType->getReturnType(),\n           \"gc.result result type does not match wrapped callee\", Call);\n    break;\n  }\n  case Intrinsic::experimental_gc_relocate: {\n    Assert(Call.getNumArgOperands() == 3, \"wrong number of arguments\", Call);\n\n    Assert(isa<PointerType>(Call.getType()->getScalarType()),\n           \"gc.relocate must return a pointer or a vector of pointers\", Call);\n\n    // Check that this relocate is correctly tied to the statepoint\n\n    // This is case for relocate on the unwinding path of an invoke statepoint\n    if (LandingPadInst *LandingPad =\n            dyn_cast<LandingPadInst>(Call.getArgOperand(0))) {\n\n      const BasicBlock *InvokeBB =\n          LandingPad->getParent()->getUniquePredecessor();\n\n      // Landingpad relocates should have only one predecessor with invoke\n      // statepoint terminator\n      Assert(InvokeBB, \"safepoints should have unique landingpads\",\n             LandingPad->getParent());\n      Assert(InvokeBB->getTerminator(), \"safepoint block should be well formed\",\n             InvokeBB);\n      Assert(isa<GCStatepointInst>(InvokeBB->getTerminator()),\n             \"gc relocate should be linked to a statepoint\", InvokeBB);\n    } else {\n      // In all other cases relocate should be tied to the statepoint directly.\n      // This covers relocates on a normal return path of invoke statepoint and\n      // relocates of a call statepoint.\n      auto Token = Call.getArgOperand(0);\n      Assert(isa<GCStatepointInst>(Token),\n             \"gc relocate is incorrectly tied to the statepoint\", Call, Token);\n    }\n\n    // Verify rest of the relocate arguments.\n    const CallBase &StatepointCall =\n      *cast<GCRelocateInst>(Call).getStatepoint();\n\n    // Both the base and derived must be piped through the safepoint.\n    Value *Base = Call.getArgOperand(1);\n    Assert(isa<ConstantInt>(Base),\n           \"gc.relocate operand #2 must be integer offset\", Call);\n\n    Value *Derived = Call.getArgOperand(2);\n    Assert(isa<ConstantInt>(Derived),\n           \"gc.relocate operand #3 must be integer offset\", Call);\n\n    const uint64_t BaseIndex = cast<ConstantInt>(Base)->getZExtValue();\n    const uint64_t DerivedIndex = cast<ConstantInt>(Derived)->getZExtValue();\n\n    // Check the bounds\n    if (auto Opt = StatepointCall.getOperandBundle(LLVMContext::OB_gc_live)) {\n      Assert(BaseIndex < Opt->Inputs.size(),\n             \"gc.relocate: statepoint base index out of bounds\", Call);\n      Assert(DerivedIndex < Opt->Inputs.size(),\n             \"gc.relocate: statepoint derived index out of bounds\", Call);\n    }\n\n    // Relocated value must be either a pointer type or vector-of-pointer type,\n    // but gc_relocate does not need to return the same pointer type as the\n    // relocated pointer. It can be casted to the correct type later if it's\n    // desired. However, they must have the same address space and 'vectorness'\n    GCRelocateInst &Relocate = cast<GCRelocateInst>(Call);\n    Assert(Relocate.getDerivedPtr()->getType()->isPtrOrPtrVectorTy(),\n           \"gc.relocate: relocated value must be a gc pointer\", Call);\n\n    auto ResultType = Call.getType();\n    auto DerivedType = Relocate.getDerivedPtr()->getType();\n    Assert(ResultType->isVectorTy() == DerivedType->isVectorTy(),\n           \"gc.relocate: vector relocates to vector and pointer to pointer\",\n           Call);\n    Assert(\n        ResultType->getPointerAddressSpace() ==\n            DerivedType->getPointerAddressSpace(),\n        \"gc.relocate: relocating a pointer shouldn't change its address space\",\n        Call);\n    break;\n  }\n  case Intrinsic::eh_exceptioncode:\n  case Intrinsic::eh_exceptionpointer: {\n    Assert(isa<CatchPadInst>(Call.getArgOperand(0)),\n           \"eh.exceptionpointer argument must be a catchpad\", Call);\n    break;\n  }\n  case Intrinsic::get_active_lane_mask: {\n    Assert(Call.getType()->isVectorTy(), \"get_active_lane_mask: must return a \"\n           \"vector\", Call);\n    auto *ElemTy = Call.getType()->getScalarType();\n    Assert(ElemTy->isIntegerTy(1), \"get_active_lane_mask: element type is not \"\n           \"i1\", Call);\n    break;\n  }\n  case Intrinsic::masked_load: {\n    Assert(Call.getType()->isVectorTy(), \"masked_load: must return a vector\",\n           Call);\n\n    Value *Ptr = Call.getArgOperand(0);\n    ConstantInt *Alignment = cast<ConstantInt>(Call.getArgOperand(1));\n    Value *Mask = Call.getArgOperand(2);\n    Value *PassThru = Call.getArgOperand(3);\n    Assert(Mask->getType()->isVectorTy(), \"masked_load: mask must be vector\",\n           Call);\n    Assert(Alignment->getValue().isPowerOf2(),\n           \"masked_load: alignment must be a power of 2\", Call);\n\n    // DataTy is the overloaded type\n    Type *DataTy = cast<PointerType>(Ptr->getType())->getElementType();\n    Assert(DataTy == Call.getType(),\n           \"masked_load: return must match pointer type\", Call);\n    Assert(PassThru->getType() == DataTy,\n           \"masked_load: pass through and data type must match\", Call);\n    Assert(cast<VectorType>(Mask->getType())->getElementCount() ==\n               cast<VectorType>(DataTy)->getElementCount(),\n           \"masked_load: vector mask must be same length as data\", Call);\n    break;\n  }\n  case Intrinsic::masked_store: {\n    Value *Val = Call.getArgOperand(0);\n    Value *Ptr = Call.getArgOperand(1);\n    ConstantInt *Alignment = cast<ConstantInt>(Call.getArgOperand(2));\n    Value *Mask = Call.getArgOperand(3);\n    Assert(Mask->getType()->isVectorTy(), \"masked_store: mask must be vector\",\n           Call);\n    Assert(Alignment->getValue().isPowerOf2(),\n           \"masked_store: alignment must be a power of 2\", Call);\n\n    // DataTy is the overloaded type\n    Type *DataTy = cast<PointerType>(Ptr->getType())->getElementType();\n    Assert(DataTy == Val->getType(),\n           \"masked_store: storee must match pointer type\", Call);\n    Assert(cast<VectorType>(Mask->getType())->getElementCount() ==\n               cast<VectorType>(DataTy)->getElementCount(),\n           \"masked_store: vector mask must be same length as data\", Call);\n    break;\n  }\n\n  case Intrinsic::masked_gather: {\n    const APInt &Alignment =\n        cast<ConstantInt>(Call.getArgOperand(1))->getValue();\n    Assert(Alignment.isNullValue() || Alignment.isPowerOf2(),\n           \"masked_gather: alignment must be 0 or a power of 2\", Call);\n    break;\n  }\n  case Intrinsic::masked_scatter: {\n    const APInt &Alignment =\n        cast<ConstantInt>(Call.getArgOperand(2))->getValue();\n    Assert(Alignment.isNullValue() || Alignment.isPowerOf2(),\n           \"masked_scatter: alignment must be 0 or a power of 2\", Call);\n    break;\n  }\n\n  case Intrinsic::experimental_guard: {\n    Assert(isa<CallInst>(Call), \"experimental_guard cannot be invoked\", Call);\n    Assert(Call.countOperandBundlesOfType(LLVMContext::OB_deopt) == 1,\n           \"experimental_guard must have exactly one \"\n           \"\\\"deopt\\\" operand bundle\");\n    break;\n  }\n\n  case Intrinsic::experimental_deoptimize: {\n    Assert(isa<CallInst>(Call), \"experimental_deoptimize cannot be invoked\",\n           Call);\n    Assert(Call.countOperandBundlesOfType(LLVMContext::OB_deopt) == 1,\n           \"experimental_deoptimize must have exactly one \"\n           \"\\\"deopt\\\" operand bundle\");\n    Assert(Call.getType() == Call.getFunction()->getReturnType(),\n           \"experimental_deoptimize return type must match caller return type\");\n\n    if (isa<CallInst>(Call)) {\n      auto *RI = dyn_cast<ReturnInst>(Call.getNextNode());\n      Assert(RI,\n             \"calls to experimental_deoptimize must be followed by a return\");\n\n      if (!Call.getType()->isVoidTy() && RI)\n        Assert(RI->getReturnValue() == &Call,\n               \"calls to experimental_deoptimize must be followed by a return \"\n               \"of the value computed by experimental_deoptimize\");\n    }\n\n    break;\n  }\n  case Intrinsic::sadd_sat:\n  case Intrinsic::uadd_sat:\n  case Intrinsic::ssub_sat:\n  case Intrinsic::usub_sat:\n  case Intrinsic::sshl_sat:\n  case Intrinsic::ushl_sat: {\n    Value *Op1 = Call.getArgOperand(0);\n    Value *Op2 = Call.getArgOperand(1);\n    Assert(Op1->getType()->isIntOrIntVectorTy(),\n           \"first operand of [us][add|sub|shl]_sat must be an int type or \"\n           \"vector of ints\");\n    Assert(Op2->getType()->isIntOrIntVectorTy(),\n           \"second operand of [us][add|sub|shl]_sat must be an int type or \"\n           \"vector of ints\");\n    break;\n  }\n  case Intrinsic::smul_fix:\n  case Intrinsic::smul_fix_sat:\n  case Intrinsic::umul_fix:\n  case Intrinsic::umul_fix_sat:\n  case Intrinsic::sdiv_fix:\n  case Intrinsic::sdiv_fix_sat:\n  case Intrinsic::udiv_fix:\n  case Intrinsic::udiv_fix_sat: {\n    Value *Op1 = Call.getArgOperand(0);\n    Value *Op2 = Call.getArgOperand(1);\n    Assert(Op1->getType()->isIntOrIntVectorTy(),\n           \"first operand of [us][mul|div]_fix[_sat] must be an int type or \"\n           \"vector of ints\");\n    Assert(Op2->getType()->isIntOrIntVectorTy(),\n           \"second operand of [us][mul|div]_fix[_sat] must be an int type or \"\n           \"vector of ints\");\n\n    auto *Op3 = cast<ConstantInt>(Call.getArgOperand(2));\n    Assert(Op3->getType()->getBitWidth() <= 32,\n           \"third argument of [us][mul|div]_fix[_sat] must fit within 32 bits\");\n\n    if (ID == Intrinsic::smul_fix || ID == Intrinsic::smul_fix_sat ||\n        ID == Intrinsic::sdiv_fix || ID == Intrinsic::sdiv_fix_sat) {\n      Assert(\n          Op3->getZExtValue() < Op1->getType()->getScalarSizeInBits(),\n          \"the scale of s[mul|div]_fix[_sat] must be less than the width of \"\n          \"the operands\");\n    } else {\n      Assert(Op3->getZExtValue() <= Op1->getType()->getScalarSizeInBits(),\n             \"the scale of u[mul|div]_fix[_sat] must be less than or equal \"\n             \"to the width of the operands\");\n    }\n    break;\n  }\n  case Intrinsic::lround:\n  case Intrinsic::llround:\n  case Intrinsic::lrint:\n  case Intrinsic::llrint: {\n    Type *ValTy = Call.getArgOperand(0)->getType();\n    Type *ResultTy = Call.getType();\n    Assert(!ValTy->isVectorTy() && !ResultTy->isVectorTy(),\n           \"Intrinsic does not support vectors\", &Call);\n    break;\n  }\n  case Intrinsic::bswap: {\n    Type *Ty = Call.getType();\n    unsigned Size = Ty->getScalarSizeInBits();\n    Assert(Size % 16 == 0, \"bswap must be an even number of bytes\", &Call);\n    break;\n  }\n  case Intrinsic::invariant_start: {\n    ConstantInt *InvariantSize = dyn_cast<ConstantInt>(Call.getArgOperand(0));\n    Assert(InvariantSize &&\n               (!InvariantSize->isNegative() || InvariantSize->isMinusOne()),\n           \"invariant_start parameter must be -1, 0 or a positive number\",\n           &Call);\n    break;\n  }\n  case Intrinsic::matrix_multiply:\n  case Intrinsic::matrix_transpose:\n  case Intrinsic::matrix_column_major_load:\n  case Intrinsic::matrix_column_major_store: {\n    Function *IF = Call.getCalledFunction();\n    ConstantInt *Stride = nullptr;\n    ConstantInt *NumRows;\n    ConstantInt *NumColumns;\n    VectorType *ResultTy;\n    Type *Op0ElemTy = nullptr;\n    Type *Op1ElemTy = nullptr;\n    switch (ID) {\n    case Intrinsic::matrix_multiply:\n      NumRows = cast<ConstantInt>(Call.getArgOperand(2));\n      NumColumns = cast<ConstantInt>(Call.getArgOperand(4));\n      ResultTy = cast<VectorType>(Call.getType());\n      Op0ElemTy =\n          cast<VectorType>(Call.getArgOperand(0)->getType())->getElementType();\n      Op1ElemTy =\n          cast<VectorType>(Call.getArgOperand(1)->getType())->getElementType();\n      break;\n    case Intrinsic::matrix_transpose:\n      NumRows = cast<ConstantInt>(Call.getArgOperand(1));\n      NumColumns = cast<ConstantInt>(Call.getArgOperand(2));\n      ResultTy = cast<VectorType>(Call.getType());\n      Op0ElemTy =\n          cast<VectorType>(Call.getArgOperand(0)->getType())->getElementType();\n      break;\n    case Intrinsic::matrix_column_major_load:\n      Stride = dyn_cast<ConstantInt>(Call.getArgOperand(1));\n      NumRows = cast<ConstantInt>(Call.getArgOperand(3));\n      NumColumns = cast<ConstantInt>(Call.getArgOperand(4));\n      ResultTy = cast<VectorType>(Call.getType());\n      Op0ElemTy =\n          cast<PointerType>(Call.getArgOperand(0)->getType())->getElementType();\n      break;\n    case Intrinsic::matrix_column_major_store:\n      Stride = dyn_cast<ConstantInt>(Call.getArgOperand(2));\n      NumRows = cast<ConstantInt>(Call.getArgOperand(4));\n      NumColumns = cast<ConstantInt>(Call.getArgOperand(5));\n      ResultTy = cast<VectorType>(Call.getArgOperand(0)->getType());\n      Op0ElemTy =\n          cast<VectorType>(Call.getArgOperand(0)->getType())->getElementType();\n      Op1ElemTy =\n          cast<PointerType>(Call.getArgOperand(1)->getType())->getElementType();\n      break;\n    default:\n      llvm_unreachable(\"unexpected intrinsic\");\n    }\n\n    Assert(ResultTy->getElementType()->isIntegerTy() ||\n           ResultTy->getElementType()->isFloatingPointTy(),\n           \"Result type must be an integer or floating-point type!\", IF);\n\n    Assert(ResultTy->getElementType() == Op0ElemTy,\n           \"Vector element type mismatch of the result and first operand \"\n           \"vector!\", IF);\n\n    if (Op1ElemTy)\n      Assert(ResultTy->getElementType() == Op1ElemTy,\n             \"Vector element type mismatch of the result and second operand \"\n             \"vector!\", IF);\n\n    Assert(cast<FixedVectorType>(ResultTy)->getNumElements() ==\n               NumRows->getZExtValue() * NumColumns->getZExtValue(),\n           \"Result of a matrix operation does not fit in the returned vector!\");\n\n    if (Stride)\n      Assert(Stride->getZExtValue() >= NumRows->getZExtValue(),\n             \"Stride must be greater or equal than the number of rows!\", IF);\n\n    break;\n  }\n  case Intrinsic::experimental_vector_insert: {\n    VectorType *VecTy = cast<VectorType>(Call.getArgOperand(0)->getType());\n    VectorType *SubVecTy = cast<VectorType>(Call.getArgOperand(1)->getType());\n\n    Assert(VecTy->getElementType() == SubVecTy->getElementType(),\n           \"experimental_vector_insert parameters must have the same element \"\n           \"type.\",\n           &Call);\n    break;\n  }\n  case Intrinsic::experimental_vector_extract: {\n    VectorType *ResultTy = cast<VectorType>(Call.getType());\n    VectorType *VecTy = cast<VectorType>(Call.getArgOperand(0)->getType());\n\n    Assert(ResultTy->getElementType() == VecTy->getElementType(),\n           \"experimental_vector_extract result must have the same element \"\n           \"type as the input vector.\",\n           &Call);\n    break;\n  }\n  case Intrinsic::experimental_noalias_scope_decl: {\n    NoAliasScopeDecls.push_back(cast<IntrinsicInst>(&Call));\n    break;\n  }\n  };\n}\n\n/// Carefully grab the subprogram from a local scope.\n///\n/// This carefully grabs the subprogram from a local scope, avoiding the\n/// built-in assertions that would typically fire.\nstatic DISubprogram *getSubprogram(Metadata *LocalScope) {\n  if (!LocalScope)\n    return nullptr;\n\n  if (auto *SP = dyn_cast<DISubprogram>(LocalScope))\n    return SP;\n\n  if (auto *LB = dyn_cast<DILexicalBlockBase>(LocalScope))\n    return getSubprogram(LB->getRawScope());\n\n  // Just return null; broken scope chains are checked elsewhere.\n  assert(!isa<DILocalScope>(LocalScope) && \"Unknown type of local scope\");\n  return nullptr;\n}\n\nvoid Verifier::visitConstrainedFPIntrinsic(ConstrainedFPIntrinsic &FPI) {\n  unsigned NumOperands;\n  bool HasRoundingMD;\n  switch (FPI.getIntrinsicID()) {\n#define INSTRUCTION(NAME, NARG, ROUND_MODE, INTRINSIC)                         \\\n  case Intrinsic::INTRINSIC:                                                   \\\n    NumOperands = NARG;                                                        \\\n    HasRoundingMD = ROUND_MODE;                                                \\\n    break;\n#include \"llvm/IR/ConstrainedOps.def\"\n  default:\n    llvm_unreachable(\"Invalid constrained FP intrinsic!\");\n  }\n  NumOperands += (1 + HasRoundingMD);\n  // Compare intrinsics carry an extra predicate metadata operand.\n  if (isa<ConstrainedFPCmpIntrinsic>(FPI))\n    NumOperands += 1;\n  Assert((FPI.getNumArgOperands() == NumOperands),\n         \"invalid arguments for constrained FP intrinsic\", &FPI);\n\n  switch (FPI.getIntrinsicID()) {\n  case Intrinsic::experimental_constrained_lrint:\n  case Intrinsic::experimental_constrained_llrint: {\n    Type *ValTy = FPI.getArgOperand(0)->getType();\n    Type *ResultTy = FPI.getType();\n    Assert(!ValTy->isVectorTy() && !ResultTy->isVectorTy(),\n           \"Intrinsic does not support vectors\", &FPI);\n  }\n    break;\n\n  case Intrinsic::experimental_constrained_lround:\n  case Intrinsic::experimental_constrained_llround: {\n    Type *ValTy = FPI.getArgOperand(0)->getType();\n    Type *ResultTy = FPI.getType();\n    Assert(!ValTy->isVectorTy() && !ResultTy->isVectorTy(),\n           \"Intrinsic does not support vectors\", &FPI);\n    break;\n  }\n\n  case Intrinsic::experimental_constrained_fcmp:\n  case Intrinsic::experimental_constrained_fcmps: {\n    auto Pred = cast<ConstrainedFPCmpIntrinsic>(&FPI)->getPredicate();\n    Assert(CmpInst::isFPPredicate(Pred),\n           \"invalid predicate for constrained FP comparison intrinsic\", &FPI);\n    break;\n  }\n\n  case Intrinsic::experimental_constrained_fptosi:\n  case Intrinsic::experimental_constrained_fptoui: {\n    Value *Operand = FPI.getArgOperand(0);\n    uint64_t NumSrcElem = 0;\n    Assert(Operand->getType()->isFPOrFPVectorTy(),\n           \"Intrinsic first argument must be floating point\", &FPI);\n    if (auto *OperandT = dyn_cast<VectorType>(Operand->getType())) {\n      NumSrcElem = cast<FixedVectorType>(OperandT)->getNumElements();\n    }\n\n    Operand = &FPI;\n    Assert((NumSrcElem > 0) == Operand->getType()->isVectorTy(),\n           \"Intrinsic first argument and result disagree on vector use\", &FPI);\n    Assert(Operand->getType()->isIntOrIntVectorTy(),\n           \"Intrinsic result must be an integer\", &FPI);\n    if (auto *OperandT = dyn_cast<VectorType>(Operand->getType())) {\n      Assert(NumSrcElem == cast<FixedVectorType>(OperandT)->getNumElements(),\n             \"Intrinsic first argument and result vector lengths must be equal\",\n             &FPI);\n    }\n  }\n    break;\n\n  case Intrinsic::experimental_constrained_sitofp:\n  case Intrinsic::experimental_constrained_uitofp: {\n    Value *Operand = FPI.getArgOperand(0);\n    uint64_t NumSrcElem = 0;\n    Assert(Operand->getType()->isIntOrIntVectorTy(),\n           \"Intrinsic first argument must be integer\", &FPI);\n    if (auto *OperandT = dyn_cast<VectorType>(Operand->getType())) {\n      NumSrcElem = cast<FixedVectorType>(OperandT)->getNumElements();\n    }\n\n    Operand = &FPI;\n    Assert((NumSrcElem > 0) == Operand->getType()->isVectorTy(),\n           \"Intrinsic first argument and result disagree on vector use\", &FPI);\n    Assert(Operand->getType()->isFPOrFPVectorTy(),\n           \"Intrinsic result must be a floating point\", &FPI);\n    if (auto *OperandT = dyn_cast<VectorType>(Operand->getType())) {\n      Assert(NumSrcElem == cast<FixedVectorType>(OperandT)->getNumElements(),\n             \"Intrinsic first argument and result vector lengths must be equal\",\n             &FPI);\n    }\n  } break;\n\n  case Intrinsic::experimental_constrained_fptrunc:\n  case Intrinsic::experimental_constrained_fpext: {\n    Value *Operand = FPI.getArgOperand(0);\n    Type *OperandTy = Operand->getType();\n    Value *Result = &FPI;\n    Type *ResultTy = Result->getType();\n    Assert(OperandTy->isFPOrFPVectorTy(),\n           \"Intrinsic first argument must be FP or FP vector\", &FPI);\n    Assert(ResultTy->isFPOrFPVectorTy(),\n           \"Intrinsic result must be FP or FP vector\", &FPI);\n    Assert(OperandTy->isVectorTy() == ResultTy->isVectorTy(),\n           \"Intrinsic first argument and result disagree on vector use\", &FPI);\n    if (OperandTy->isVectorTy()) {\n      Assert(cast<FixedVectorType>(OperandTy)->getNumElements() ==\n                 cast<FixedVectorType>(ResultTy)->getNumElements(),\n             \"Intrinsic first argument and result vector lengths must be equal\",\n             &FPI);\n    }\n    if (FPI.getIntrinsicID() == Intrinsic::experimental_constrained_fptrunc) {\n      Assert(OperandTy->getScalarSizeInBits() > ResultTy->getScalarSizeInBits(),\n             \"Intrinsic first argument's type must be larger than result type\",\n             &FPI);\n    } else {\n      Assert(OperandTy->getScalarSizeInBits() < ResultTy->getScalarSizeInBits(),\n             \"Intrinsic first argument's type must be smaller than result type\",\n             &FPI);\n    }\n  }\n    break;\n\n  default:\n    break;\n  }\n\n  // If a non-metadata argument is passed in a metadata slot then the\n  // error will be caught earlier when the incorrect argument doesn't\n  // match the specification in the intrinsic call table. Thus, no\n  // argument type check is needed here.\n\n  Assert(FPI.getExceptionBehavior().hasValue(),\n         \"invalid exception behavior argument\", &FPI);\n  if (HasRoundingMD) {\n    Assert(FPI.getRoundingMode().hasValue(),\n           \"invalid rounding mode argument\", &FPI);\n  }\n}\n\nvoid Verifier::visitDbgIntrinsic(StringRef Kind, DbgVariableIntrinsic &DII) {\n  auto *MD = cast<MetadataAsValue>(DII.getArgOperand(0))->getMetadata();\n  AssertDI(isa<ValueAsMetadata>(MD) ||\n             (isa<MDNode>(MD) && !cast<MDNode>(MD)->getNumOperands()),\n         \"invalid llvm.dbg.\" + Kind + \" intrinsic address/value\", &DII, MD);\n  AssertDI(isa<DILocalVariable>(DII.getRawVariable()),\n         \"invalid llvm.dbg.\" + Kind + \" intrinsic variable\", &DII,\n         DII.getRawVariable());\n  AssertDI(isa<DIExpression>(DII.getRawExpression()),\n         \"invalid llvm.dbg.\" + Kind + \" intrinsic expression\", &DII,\n         DII.getRawExpression());\n\n  // Ignore broken !dbg attachments; they're checked elsewhere.\n  if (MDNode *N = DII.getDebugLoc().getAsMDNode())\n    if (!isa<DILocation>(N))\n      return;\n\n  BasicBlock *BB = DII.getParent();\n  Function *F = BB ? BB->getParent() : nullptr;\n\n  // The scopes for variables and !dbg attachments must agree.\n  DILocalVariable *Var = DII.getVariable();\n  DILocation *Loc = DII.getDebugLoc();\n  AssertDI(Loc, \"llvm.dbg.\" + Kind + \" intrinsic requires a !dbg attachment\",\n           &DII, BB, F);\n\n  DISubprogram *VarSP = getSubprogram(Var->getRawScope());\n  DISubprogram *LocSP = getSubprogram(Loc->getRawScope());\n  if (!VarSP || !LocSP)\n    return; // Broken scope chains are checked elsewhere.\n\n  AssertDI(VarSP == LocSP, \"mismatched subprogram between llvm.dbg.\" + Kind +\n                               \" variable and !dbg attachment\",\n           &DII, BB, F, Var, Var->getScope()->getSubprogram(), Loc,\n           Loc->getScope()->getSubprogram());\n\n  // This check is redundant with one in visitLocalVariable().\n  AssertDI(isType(Var->getRawType()), \"invalid type ref\", Var,\n           Var->getRawType());\n  verifyFnArgs(DII);\n}\n\nvoid Verifier::visitDbgLabelIntrinsic(StringRef Kind, DbgLabelInst &DLI) {\n  AssertDI(isa<DILabel>(DLI.getRawLabel()),\n         \"invalid llvm.dbg.\" + Kind + \" intrinsic variable\", &DLI,\n         DLI.getRawLabel());\n\n  // Ignore broken !dbg attachments; they're checked elsewhere.\n  if (MDNode *N = DLI.getDebugLoc().getAsMDNode())\n    if (!isa<DILocation>(N))\n      return;\n\n  BasicBlock *BB = DLI.getParent();\n  Function *F = BB ? BB->getParent() : nullptr;\n\n  // The scopes for variables and !dbg attachments must agree.\n  DILabel *Label = DLI.getLabel();\n  DILocation *Loc = DLI.getDebugLoc();\n  Assert(Loc, \"llvm.dbg.\" + Kind + \" intrinsic requires a !dbg attachment\",\n         &DLI, BB, F);\n\n  DISubprogram *LabelSP = getSubprogram(Label->getRawScope());\n  DISubprogram *LocSP = getSubprogram(Loc->getRawScope());\n  if (!LabelSP || !LocSP)\n    return;\n\n  AssertDI(LabelSP == LocSP, \"mismatched subprogram between llvm.dbg.\" + Kind +\n                             \" label and !dbg attachment\",\n           &DLI, BB, F, Label, Label->getScope()->getSubprogram(), Loc,\n           Loc->getScope()->getSubprogram());\n}\n\nvoid Verifier::verifyFragmentExpression(const DbgVariableIntrinsic &I) {\n  DILocalVariable *V = dyn_cast_or_null<DILocalVariable>(I.getRawVariable());\n  DIExpression *E = dyn_cast_or_null<DIExpression>(I.getRawExpression());\n\n  // We don't know whether this intrinsic verified correctly.\n  if (!V || !E || !E->isValid())\n    return;\n\n  // Nothing to do if this isn't a DW_OP_LLVM_fragment expression.\n  auto Fragment = E->getFragmentInfo();\n  if (!Fragment)\n    return;\n\n  // The frontend helps out GDB by emitting the members of local anonymous\n  // unions as artificial local variables with shared storage. When SROA splits\n  // the storage for artificial local variables that are smaller than the entire\n  // union, the overhang piece will be outside of the allotted space for the\n  // variable and this check fails.\n  // FIXME: Remove this check as soon as clang stops doing this; it hides bugs.\n  if (V->isArtificial())\n    return;\n\n  verifyFragmentExpression(*V, *Fragment, &I);\n}\n\ntemplate <typename ValueOrMetadata>\nvoid Verifier::verifyFragmentExpression(const DIVariable &V,\n                                        DIExpression::FragmentInfo Fragment,\n                                        ValueOrMetadata *Desc) {\n  // If there's no size, the type is broken, but that should be checked\n  // elsewhere.\n  auto VarSize = V.getSizeInBits();\n  if (!VarSize)\n    return;\n\n  unsigned FragSize = Fragment.SizeInBits;\n  unsigned FragOffset = Fragment.OffsetInBits;\n  AssertDI(FragSize + FragOffset <= *VarSize,\n         \"fragment is larger than or outside of variable\", Desc, &V);\n  AssertDI(FragSize != *VarSize, \"fragment covers entire variable\", Desc, &V);\n}\n\nvoid Verifier::verifyFnArgs(const DbgVariableIntrinsic &I) {\n  // This function does not take the scope of noninlined function arguments into\n  // account. Don't run it if current function is nodebug, because it may\n  // contain inlined debug intrinsics.\n  if (!HasDebugInfo)\n    return;\n\n  // For performance reasons only check non-inlined ones.\n  if (I.getDebugLoc()->getInlinedAt())\n    return;\n\n  DILocalVariable *Var = I.getVariable();\n  AssertDI(Var, \"dbg intrinsic without variable\");\n\n  unsigned ArgNo = Var->getArg();\n  if (!ArgNo)\n    return;\n\n  // Verify there are no duplicate function argument debug info entries.\n  // These will cause hard-to-debug assertions in the DWARF backend.\n  if (DebugFnArgs.size() < ArgNo)\n    DebugFnArgs.resize(ArgNo, nullptr);\n\n  auto *Prev = DebugFnArgs[ArgNo - 1];\n  DebugFnArgs[ArgNo - 1] = Var;\n  AssertDI(!Prev || (Prev == Var), \"conflicting debug info for argument\", &I,\n           Prev, Var);\n}\n\nvoid Verifier::verifyNotEntryValue(const DbgVariableIntrinsic &I) {\n  DIExpression *E = dyn_cast_or_null<DIExpression>(I.getRawExpression());\n\n  // We don't know whether this intrinsic verified correctly.\n  if (!E || !E->isValid())\n    return;\n\n  AssertDI(!E->isEntryValue(), \"Entry values are only allowed in MIR\", &I);\n}\n\nvoid Verifier::verifyCompileUnits() {\n  // When more than one Module is imported into the same context, such as during\n  // an LTO build before linking the modules, ODR type uniquing may cause types\n  // to point to a different CU. This check does not make sense in this case.\n  if (M.getContext().isODRUniquingDebugTypes())\n    return;\n  auto *CUs = M.getNamedMetadata(\"llvm.dbg.cu\");\n  SmallPtrSet<const Metadata *, 2> Listed;\n  if (CUs)\n    Listed.insert(CUs->op_begin(), CUs->op_end());\n  for (auto *CU : CUVisited)\n    AssertDI(Listed.count(CU), \"DICompileUnit not listed in llvm.dbg.cu\", CU);\n  CUVisited.clear();\n}\n\nvoid Verifier::verifyDeoptimizeCallingConvs() {\n  if (DeoptimizeDeclarations.empty())\n    return;\n\n  const Function *First = DeoptimizeDeclarations[0];\n  for (auto *F : makeArrayRef(DeoptimizeDeclarations).slice(1)) {\n    Assert(First->getCallingConv() == F->getCallingConv(),\n           \"All llvm.experimental.deoptimize declarations must have the same \"\n           \"calling convention\",\n           First, F);\n  }\n}\n\nvoid Verifier::verifySourceDebugInfo(const DICompileUnit &U, const DIFile &F) {\n  bool HasSource = F.getSource().hasValue();\n  if (!HasSourceDebugInfo.count(&U))\n    HasSourceDebugInfo[&U] = HasSource;\n  AssertDI(HasSource == HasSourceDebugInfo[&U],\n           \"inconsistent use of embedded source\");\n}\n\nvoid Verifier::verifyNoAliasScopeDecl() {\n  if (NoAliasScopeDecls.empty())\n    return;\n\n  // only a single scope must be declared at a time.\n  for (auto *II : NoAliasScopeDecls) {\n    assert(II->getIntrinsicID() == Intrinsic::experimental_noalias_scope_decl &&\n           \"Not a llvm.experimental.noalias.scope.decl ?\");\n    const auto *ScopeListMV = dyn_cast<MetadataAsValue>(\n        II->getOperand(Intrinsic::NoAliasScopeDeclScopeArg));\n    Assert(ScopeListMV != nullptr,\n           \"llvm.experimental.noalias.scope.decl must have a MetadataAsValue \"\n           \"argument\",\n           II);\n\n    const auto *ScopeListMD = dyn_cast<MDNode>(ScopeListMV->getMetadata());\n    Assert(ScopeListMD != nullptr, \"!id.scope.list must point to an MDNode\",\n           II);\n    Assert(ScopeListMD->getNumOperands() == 1,\n           \"!id.scope.list must point to a list with a single scope\", II);\n  }\n\n  // Only check the domination rule when requested. Once all passes have been\n  // adapted this option can go away.\n  if (!VerifyNoAliasScopeDomination)\n    return;\n\n  // Now sort the intrinsics based on the scope MDNode so that declarations of\n  // the same scopes are next to each other.\n  auto GetScope = [](IntrinsicInst *II) {\n    const auto *ScopeListMV = cast<MetadataAsValue>(\n        II->getOperand(Intrinsic::NoAliasScopeDeclScopeArg));\n    return &cast<MDNode>(ScopeListMV->getMetadata())->getOperand(0);\n  };\n\n  // We are sorting on MDNode pointers here. For valid input IR this is ok.\n  // TODO: Sort on Metadata ID to avoid non-deterministic error messages.\n  auto Compare = [GetScope](IntrinsicInst *Lhs, IntrinsicInst *Rhs) {\n    return GetScope(Lhs) < GetScope(Rhs);\n  };\n\n  llvm::sort(NoAliasScopeDecls, Compare);\n\n  // Go over the intrinsics and check that for the same scope, they are not\n  // dominating each other.\n  auto ItCurrent = NoAliasScopeDecls.begin();\n  while (ItCurrent != NoAliasScopeDecls.end()) {\n    auto CurScope = GetScope(*ItCurrent);\n    auto ItNext = ItCurrent;\n    do {\n      ++ItNext;\n    } while (ItNext != NoAliasScopeDecls.end() &&\n             GetScope(*ItNext) == CurScope);\n\n    // [ItCurrent, ItNext) represents the declarations for the same scope.\n    // Ensure they are not dominating each other.. but only if it is not too\n    // expensive.\n    if (ItNext - ItCurrent < 32)\n      for (auto *I : llvm::make_range(ItCurrent, ItNext))\n        for (auto *J : llvm::make_range(ItCurrent, ItNext))\n          if (I != J)\n            Assert(!DT.dominates(I, J),\n                   \"llvm.experimental.noalias.scope.decl dominates another one \"\n                   \"with the same scope\",\n                   I);\n    ItCurrent = ItNext;\n  }\n}\n\n//===----------------------------------------------------------------------===//\n//  Implement the public interfaces to this file...\n//===----------------------------------------------------------------------===//\n\nbool llvm::verifyFunction(const Function &f, raw_ostream *OS) {\n  Function &F = const_cast<Function &>(f);\n\n  // Don't use a raw_null_ostream.  Printing IR is expensive.\n  Verifier V(OS, /*ShouldTreatBrokenDebugInfoAsError=*/true, *f.getParent());\n\n  // Note that this function's return value is inverted from what you would\n  // expect of a function called \"verify\".\n  return !V.verify(F);\n}\n\nbool llvm::verifyModule(const Module &M, raw_ostream *OS,\n                        bool *BrokenDebugInfo) {\n  // Don't use a raw_null_ostream.  Printing IR is expensive.\n  Verifier V(OS, /*ShouldTreatBrokenDebugInfoAsError=*/!BrokenDebugInfo, M);\n\n  bool Broken = false;\n  for (const Function &F : M)\n    Broken |= !V.verify(F);\n\n  Broken |= !V.verify();\n  if (BrokenDebugInfo)\n    *BrokenDebugInfo = V.hasBrokenDebugInfo();\n  // Note that this function's return value is inverted from what you would\n  // expect of a function called \"verify\".\n  return Broken;\n}\n\nnamespace {\n\nstruct VerifierLegacyPass : public FunctionPass {\n  static char ID;\n\n  std::unique_ptr<Verifier> V;\n  bool FatalErrors = true;\n\n  VerifierLegacyPass() : FunctionPass(ID) {\n    initializeVerifierLegacyPassPass(*PassRegistry::getPassRegistry());\n  }\n  explicit VerifierLegacyPass(bool FatalErrors)\n      : FunctionPass(ID),\n        FatalErrors(FatalErrors) {\n    initializeVerifierLegacyPassPass(*PassRegistry::getPassRegistry());\n  }\n\n  bool doInitialization(Module &M) override {\n    V = std::make_unique<Verifier>(\n        &dbgs(), /*ShouldTreatBrokenDebugInfoAsError=*/false, M);\n    return false;\n  }\n\n  bool runOnFunction(Function &F) override {\n    if (!V->verify(F) && FatalErrors) {\n      errs() << \"in function \" << F.getName() << '\\n';\n      report_fatal_error(\"Broken function found, compilation aborted!\");\n    }\n    return false;\n  }\n\n  bool doFinalization(Module &M) override {\n    bool HasErrors = false;\n    for (Function &F : M)\n      if (F.isDeclaration())\n        HasErrors |= !V->verify(F);\n\n    HasErrors |= !V->verify();\n    if (FatalErrors && (HasErrors || V->hasBrokenDebugInfo()))\n      report_fatal_error(\"Broken module found, compilation aborted!\");\n    return false;\n  }\n\n  void getAnalysisUsage(AnalysisUsage &AU) const override {\n    AU.setPreservesAll();\n  }\n};\n\n} // end anonymous namespace\n\n/// Helper to issue failure from the TBAA verification\ntemplate <typename... Tys> void TBAAVerifier::CheckFailed(Tys &&... Args) {\n  if (Diagnostic)\n    return Diagnostic->CheckFailed(Args...);\n}\n\n#define AssertTBAA(C, ...)                                                     \\\n  do {                                                                         \\\n    if (!(C)) {                                                                \\\n      CheckFailed(__VA_ARGS__);                                                \\\n      return false;                                                            \\\n    }                                                                          \\\n  } while (false)\n\n/// Verify that \\p BaseNode can be used as the \"base type\" in the struct-path\n/// TBAA scheme.  This means \\p BaseNode is either a scalar node, or a\n/// struct-type node describing an aggregate data structure (like a struct).\nTBAAVerifier::TBAABaseNodeSummary\nTBAAVerifier::verifyTBAABaseNode(Instruction &I, const MDNode *BaseNode,\n                                 bool IsNewFormat) {\n  if (BaseNode->getNumOperands() < 2) {\n    CheckFailed(\"Base nodes must have at least two operands\", &I, BaseNode);\n    return {true, ~0u};\n  }\n\n  auto Itr = TBAABaseNodes.find(BaseNode);\n  if (Itr != TBAABaseNodes.end())\n    return Itr->second;\n\n  auto Result = verifyTBAABaseNodeImpl(I, BaseNode, IsNewFormat);\n  auto InsertResult = TBAABaseNodes.insert({BaseNode, Result});\n  (void)InsertResult;\n  assert(InsertResult.second && \"We just checked!\");\n  return Result;\n}\n\nTBAAVerifier::TBAABaseNodeSummary\nTBAAVerifier::verifyTBAABaseNodeImpl(Instruction &I, const MDNode *BaseNode,\n                                     bool IsNewFormat) {\n  const TBAAVerifier::TBAABaseNodeSummary InvalidNode = {true, ~0u};\n\n  if (BaseNode->getNumOperands() == 2) {\n    // Scalar nodes can only be accessed at offset 0.\n    return isValidScalarTBAANode(BaseNode)\n               ? TBAAVerifier::TBAABaseNodeSummary({false, 0})\n               : InvalidNode;\n  }\n\n  if (IsNewFormat) {\n    if (BaseNode->getNumOperands() % 3 != 0) {\n      CheckFailed(\"Access tag nodes must have the number of operands that is a \"\n                  \"multiple of 3!\", BaseNode);\n      return InvalidNode;\n    }\n  } else {\n    if (BaseNode->getNumOperands() % 2 != 1) {\n      CheckFailed(\"Struct tag nodes must have an odd number of operands!\",\n                  BaseNode);\n      return InvalidNode;\n    }\n  }\n\n  // Check the type size field.\n  if (IsNewFormat) {\n    auto *TypeSizeNode = mdconst::dyn_extract_or_null<ConstantInt>(\n        BaseNode->getOperand(1));\n    if (!TypeSizeNode) {\n      CheckFailed(\"Type size nodes must be constants!\", &I, BaseNode);\n      return InvalidNode;\n    }\n  }\n\n  // Check the type name field. In the new format it can be anything.\n  if (!IsNewFormat && !isa<MDString>(BaseNode->getOperand(0))) {\n    CheckFailed(\"Struct tag nodes have a string as their first operand\",\n                BaseNode);\n    return InvalidNode;\n  }\n\n  bool Failed = false;\n\n  Optional<APInt> PrevOffset;\n  unsigned BitWidth = ~0u;\n\n  // We've already checked that BaseNode is not a degenerate root node with one\n  // operand in \\c verifyTBAABaseNode, so this loop should run at least once.\n  unsigned FirstFieldOpNo = IsNewFormat ? 3 : 1;\n  unsigned NumOpsPerField = IsNewFormat ? 3 : 2;\n  for (unsigned Idx = FirstFieldOpNo; Idx < BaseNode->getNumOperands();\n           Idx += NumOpsPerField) {\n    const MDOperand &FieldTy = BaseNode->getOperand(Idx);\n    const MDOperand &FieldOffset = BaseNode->getOperand(Idx + 1);\n    if (!isa<MDNode>(FieldTy)) {\n      CheckFailed(\"Incorrect field entry in struct type node!\", &I, BaseNode);\n      Failed = true;\n      continue;\n    }\n\n    auto *OffsetEntryCI =\n        mdconst::dyn_extract_or_null<ConstantInt>(FieldOffset);\n    if (!OffsetEntryCI) {\n      CheckFailed(\"Offset entries must be constants!\", &I, BaseNode);\n      Failed = true;\n      continue;\n    }\n\n    if (BitWidth == ~0u)\n      BitWidth = OffsetEntryCI->getBitWidth();\n\n    if (OffsetEntryCI->getBitWidth() != BitWidth) {\n      CheckFailed(\n          \"Bitwidth between the offsets and struct type entries must match\", &I,\n          BaseNode);\n      Failed = true;\n      continue;\n    }\n\n    // NB! As far as I can tell, we generate a non-strictly increasing offset\n    // sequence only from structs that have zero size bit fields.  When\n    // recursing into a contained struct in \\c getFieldNodeFromTBAABaseNode we\n    // pick the field lexically the latest in struct type metadata node.  This\n    // mirrors the actual behavior of the alias analysis implementation.\n    bool IsAscending =\n        !PrevOffset || PrevOffset->ule(OffsetEntryCI->getValue());\n\n    if (!IsAscending) {\n      CheckFailed(\"Offsets must be increasing!\", &I, BaseNode);\n      Failed = true;\n    }\n\n    PrevOffset = OffsetEntryCI->getValue();\n\n    if (IsNewFormat) {\n      auto *MemberSizeNode = mdconst::dyn_extract_or_null<ConstantInt>(\n          BaseNode->getOperand(Idx + 2));\n      if (!MemberSizeNode) {\n        CheckFailed(\"Member size entries must be constants!\", &I, BaseNode);\n        Failed = true;\n        continue;\n      }\n    }\n  }\n\n  return Failed ? InvalidNode\n                : TBAAVerifier::TBAABaseNodeSummary(false, BitWidth);\n}\n\nstatic bool IsRootTBAANode(const MDNode *MD) {\n  return MD->getNumOperands() < 2;\n}\n\nstatic bool IsScalarTBAANodeImpl(const MDNode *MD,\n                                 SmallPtrSetImpl<const MDNode *> &Visited) {\n  if (MD->getNumOperands() != 2 && MD->getNumOperands() != 3)\n    return false;\n\n  if (!isa<MDString>(MD->getOperand(0)))\n    return false;\n\n  if (MD->getNumOperands() == 3) {\n    auto *Offset = mdconst::dyn_extract<ConstantInt>(MD->getOperand(2));\n    if (!(Offset && Offset->isZero() && isa<MDString>(MD->getOperand(0))))\n      return false;\n  }\n\n  auto *Parent = dyn_cast_or_null<MDNode>(MD->getOperand(1));\n  return Parent && Visited.insert(Parent).second &&\n         (IsRootTBAANode(Parent) || IsScalarTBAANodeImpl(Parent, Visited));\n}\n\nbool TBAAVerifier::isValidScalarTBAANode(const MDNode *MD) {\n  auto ResultIt = TBAAScalarNodes.find(MD);\n  if (ResultIt != TBAAScalarNodes.end())\n    return ResultIt->second;\n\n  SmallPtrSet<const MDNode *, 4> Visited;\n  bool Result = IsScalarTBAANodeImpl(MD, Visited);\n  auto InsertResult = TBAAScalarNodes.insert({MD, Result});\n  (void)InsertResult;\n  assert(InsertResult.second && \"Just checked!\");\n\n  return Result;\n}\n\n/// Returns the field node at the offset \\p Offset in \\p BaseNode.  Update \\p\n/// Offset in place to be the offset within the field node returned.\n///\n/// We assume we've okayed \\p BaseNode via \\c verifyTBAABaseNode.\nMDNode *TBAAVerifier::getFieldNodeFromTBAABaseNode(Instruction &I,\n                                                   const MDNode *BaseNode,\n                                                   APInt &Offset,\n                                                   bool IsNewFormat) {\n  assert(BaseNode->getNumOperands() >= 2 && \"Invalid base node!\");\n\n  // Scalar nodes have only one possible \"field\" -- their parent in the access\n  // hierarchy.  Offset must be zero at this point, but our caller is supposed\n  // to Assert that.\n  if (BaseNode->getNumOperands() == 2)\n    return cast<MDNode>(BaseNode->getOperand(1));\n\n  unsigned FirstFieldOpNo = IsNewFormat ? 3 : 1;\n  unsigned NumOpsPerField = IsNewFormat ? 3 : 2;\n  for (unsigned Idx = FirstFieldOpNo; Idx < BaseNode->getNumOperands();\n           Idx += NumOpsPerField) {\n    auto *OffsetEntryCI =\n        mdconst::extract<ConstantInt>(BaseNode->getOperand(Idx + 1));\n    if (OffsetEntryCI->getValue().ugt(Offset)) {\n      if (Idx == FirstFieldOpNo) {\n        CheckFailed(\"Could not find TBAA parent in struct type node\", &I,\n                    BaseNode, &Offset);\n        return nullptr;\n      }\n\n      unsigned PrevIdx = Idx - NumOpsPerField;\n      auto *PrevOffsetEntryCI =\n          mdconst::extract<ConstantInt>(BaseNode->getOperand(PrevIdx + 1));\n      Offset -= PrevOffsetEntryCI->getValue();\n      return cast<MDNode>(BaseNode->getOperand(PrevIdx));\n    }\n  }\n\n  unsigned LastIdx = BaseNode->getNumOperands() - NumOpsPerField;\n  auto *LastOffsetEntryCI = mdconst::extract<ConstantInt>(\n      BaseNode->getOperand(LastIdx + 1));\n  Offset -= LastOffsetEntryCI->getValue();\n  return cast<MDNode>(BaseNode->getOperand(LastIdx));\n}\n\nstatic bool isNewFormatTBAATypeNode(llvm::MDNode *Type) {\n  if (!Type || Type->getNumOperands() < 3)\n    return false;\n\n  // In the new format type nodes shall have a reference to the parent type as\n  // its first operand.\n  MDNode *Parent = dyn_cast_or_null<MDNode>(Type->getOperand(0));\n  if (!Parent)\n    return false;\n\n  return true;\n}\n\nbool TBAAVerifier::visitTBAAMetadata(Instruction &I, const MDNode *MD) {\n  AssertTBAA(isa<LoadInst>(I) || isa<StoreInst>(I) || isa<CallInst>(I) ||\n                 isa<VAArgInst>(I) || isa<AtomicRMWInst>(I) ||\n                 isa<AtomicCmpXchgInst>(I),\n             \"This instruction shall not have a TBAA access tag!\", &I);\n\n  bool IsStructPathTBAA =\n      isa<MDNode>(MD->getOperand(0)) && MD->getNumOperands() >= 3;\n\n  AssertTBAA(\n      IsStructPathTBAA,\n      \"Old-style TBAA is no longer allowed, use struct-path TBAA instead\", &I);\n\n  MDNode *BaseNode = dyn_cast_or_null<MDNode>(MD->getOperand(0));\n  MDNode *AccessType = dyn_cast_or_null<MDNode>(MD->getOperand(1));\n\n  bool IsNewFormat = isNewFormatTBAATypeNode(AccessType);\n\n  if (IsNewFormat) {\n    AssertTBAA(MD->getNumOperands() == 4 || MD->getNumOperands() == 5,\n               \"Access tag metadata must have either 4 or 5 operands\", &I, MD);\n  } else {\n    AssertTBAA(MD->getNumOperands() < 5,\n               \"Struct tag metadata must have either 3 or 4 operands\", &I, MD);\n  }\n\n  // Check the access size field.\n  if (IsNewFormat) {\n    auto *AccessSizeNode = mdconst::dyn_extract_or_null<ConstantInt>(\n        MD->getOperand(3));\n    AssertTBAA(AccessSizeNode, \"Access size field must be a constant\", &I, MD);\n  }\n\n  // Check the immutability flag.\n  unsigned ImmutabilityFlagOpNo = IsNewFormat ? 4 : 3;\n  if (MD->getNumOperands() == ImmutabilityFlagOpNo + 1) {\n    auto *IsImmutableCI = mdconst::dyn_extract_or_null<ConstantInt>(\n        MD->getOperand(ImmutabilityFlagOpNo));\n    AssertTBAA(IsImmutableCI,\n               \"Immutability tag on struct tag metadata must be a constant\",\n               &I, MD);\n    AssertTBAA(\n        IsImmutableCI->isZero() || IsImmutableCI->isOne(),\n        \"Immutability part of the struct tag metadata must be either 0 or 1\",\n        &I, MD);\n  }\n\n  AssertTBAA(BaseNode && AccessType,\n             \"Malformed struct tag metadata: base and access-type \"\n             \"should be non-null and point to Metadata nodes\",\n             &I, MD, BaseNode, AccessType);\n\n  if (!IsNewFormat) {\n    AssertTBAA(isValidScalarTBAANode(AccessType),\n               \"Access type node must be a valid scalar type\", &I, MD,\n               AccessType);\n  }\n\n  auto *OffsetCI = mdconst::dyn_extract_or_null<ConstantInt>(MD->getOperand(2));\n  AssertTBAA(OffsetCI, \"Offset must be constant integer\", &I, MD);\n\n  APInt Offset = OffsetCI->getValue();\n  bool SeenAccessTypeInPath = false;\n\n  SmallPtrSet<MDNode *, 4> StructPath;\n\n  for (/* empty */; BaseNode && !IsRootTBAANode(BaseNode);\n       BaseNode = getFieldNodeFromTBAABaseNode(I, BaseNode, Offset,\n                                               IsNewFormat)) {\n    if (!StructPath.insert(BaseNode).second) {\n      CheckFailed(\"Cycle detected in struct path\", &I, MD);\n      return false;\n    }\n\n    bool Invalid;\n    unsigned BaseNodeBitWidth;\n    std::tie(Invalid, BaseNodeBitWidth) = verifyTBAABaseNode(I, BaseNode,\n                                                             IsNewFormat);\n\n    // If the base node is invalid in itself, then we've already printed all the\n    // errors we wanted to print.\n    if (Invalid)\n      return false;\n\n    SeenAccessTypeInPath |= BaseNode == AccessType;\n\n    if (isValidScalarTBAANode(BaseNode) || BaseNode == AccessType)\n      AssertTBAA(Offset == 0, \"Offset not zero at the point of scalar access\",\n                 &I, MD, &Offset);\n\n    AssertTBAA(BaseNodeBitWidth == Offset.getBitWidth() ||\n                   (BaseNodeBitWidth == 0 && Offset == 0) ||\n                   (IsNewFormat && BaseNodeBitWidth == ~0u),\n               \"Access bit-width not the same as description bit-width\", &I, MD,\n               BaseNodeBitWidth, Offset.getBitWidth());\n\n    if (IsNewFormat && SeenAccessTypeInPath)\n      break;\n  }\n\n  AssertTBAA(SeenAccessTypeInPath, \"Did not see access type in access path!\",\n             &I, MD);\n  return true;\n}\n\nchar VerifierLegacyPass::ID = 0;\nINITIALIZE_PASS(VerifierLegacyPass, \"verify\", \"Module Verifier\", false, false)\n\nFunctionPass *llvm::createVerifierPass(bool FatalErrors) {\n  return new VerifierLegacyPass(FatalErrors);\n}\n\nAnalysisKey VerifierAnalysis::Key;\nVerifierAnalysis::Result VerifierAnalysis::run(Module &M,\n                                               ModuleAnalysisManager &) {\n  Result Res;\n  Res.IRBroken = llvm::verifyModule(M, &dbgs(), &Res.DebugInfoBroken);\n  return Res;\n}\n\nVerifierAnalysis::Result VerifierAnalysis::run(Function &F,\n                                               FunctionAnalysisManager &) {\n  return { llvm::verifyFunction(F, &dbgs()), false };\n}\n\nPreservedAnalyses VerifierPass::run(Module &M, ModuleAnalysisManager &AM) {\n  auto Res = AM.getResult<VerifierAnalysis>(M);\n  if (FatalErrors && (Res.IRBroken || Res.DebugInfoBroken))\n    report_fatal_error(\"Broken module found, compilation aborted!\");\n\n  return PreservedAnalyses::all();\n}\n\nPreservedAnalyses VerifierPass::run(Function &F, FunctionAnalysisManager &AM) {\n  auto res = AM.getResult<VerifierAnalysis>(F);\n  if (res.IRBroken && FatalErrors)\n    report_fatal_error(\"Broken function found, compilation aborted!\");\n\n  return PreservedAnalyses::all();\n}\n"}}, "reports": [{"events": [{"location": {"col": 16, "file": 3, "line": 3494}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 3, "line": 475}, "message": "differing parameters are named here: ('EI'), in definition: ('IE')"}, {"location": {"col": 8, "file": 3, "line": 475}, "message": "function '(anonymous namespace)::Verifier::visitInsertElementInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/IR/Verifier.cpp", "reportHash": "ac0a1799b4131f18d4f1de4a2ec279c3", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 3, "line": 3501}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 3, "line": 476}, "message": "differing parameters are named here: ('EI'), in definition: ('SV')"}, {"location": {"col": 8, "file": 3, "line": 476}, "message": "function '(anonymous namespace)::Verifier::visitShuffleVectorInst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/IR/Verifier.cpp", "reportHash": "78876318eb454cc7f5f0887815d0ac81", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
