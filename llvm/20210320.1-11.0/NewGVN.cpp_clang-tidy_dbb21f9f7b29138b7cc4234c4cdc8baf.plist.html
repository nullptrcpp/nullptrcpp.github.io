<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"57": {"id": 57, "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp", "content": "//===- NewGVN.cpp - Global Value Numbering Pass ---------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// This file implements the new LLVM's Global Value Numbering pass.\n/// GVN partitions values computed by a function into congruence classes.\n/// Values ending up in the same congruence class are guaranteed to be the same\n/// for every execution of the program. In that respect, congruency is a\n/// compile-time approximation of equivalence of values at runtime.\n/// The algorithm implemented here uses a sparse formulation and it's based\n/// on the ideas described in the paper:\n/// \"A Sparse Algorithm for Predicated Global Value Numbering\" from\n/// Karthik Gargi.\n///\n/// A brief overview of the algorithm: The algorithm is essentially the same as\n/// the standard RPO value numbering algorithm (a good reference is the paper\n/// \"SCC based value numbering\" by L. Taylor Simpson) with one major difference:\n/// The RPO algorithm proceeds, on every iteration, to process every reachable\n/// block and every instruction in that block.  This is because the standard RPO\n/// algorithm does not track what things have the same value number, it only\n/// tracks what the value number of a given operation is (the mapping is\n/// operation -> value number).  Thus, when a value number of an operation\n/// changes, it must reprocess everything to ensure all uses of a value number\n/// get updated properly.  In constrast, the sparse algorithm we use *also*\n/// tracks what operations have a given value number (IE it also tracks the\n/// reverse mapping from value number -> operations with that value number), so\n/// that it only needs to reprocess the instructions that are affected when\n/// something's value number changes.  The vast majority of complexity and code\n/// in this file is devoted to tracking what value numbers could change for what\n/// instructions when various things happen.  The rest of the algorithm is\n/// devoted to performing symbolic evaluation, forward propagation, and\n/// simplification of operations based on the value numbers deduced so far\n///\n/// In order to make the GVN mostly-complete, we use a technique derived from\n/// \"Detection of Redundant Expressions: A Complete and Polynomial-time\n/// Algorithm in SSA\" by R.R. Pai.  The source of incompleteness in most SSA\n/// based GVN algorithms is related to their inability to detect equivalence\n/// between phi of ops (IE phi(a+b, c+d)) and op of phis (phi(a,c) + phi(b, d)).\n/// We resolve this issue by generating the equivalent \"phi of ops\" form for\n/// each op of phis we see, in a way that only takes polynomial time to resolve.\n///\n/// We also do not perform elimination by using any published algorithm.  All\n/// published algorithms are O(Instructions). Instead, we use a technique that\n/// is O(number of operations with the same value number), enabling us to skip\n/// trying to eliminate things that have unique value numbers.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/Transforms/Scalar/NewGVN.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/BitVector.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/DepthFirstIterator.h\"\n#include \"llvm/ADT/GraphTraits.h\"\n#include \"llvm/ADT/Hashing.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PostOrderIterator.h\"\n#include \"llvm/ADT/SetOperations.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/SparseBitVector.h\"\n#include \"llvm/ADT/Statistic.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Analysis/AliasAnalysis.h\"\n#include \"llvm/Analysis/AssumptionCache.h\"\n#include \"llvm/Analysis/CFGPrinter.h\"\n#include \"llvm/Analysis/ConstantFolding.h\"\n#include \"llvm/Analysis/GlobalsModRef.h\"\n#include \"llvm/Analysis/InstructionSimplify.h\"\n#include \"llvm/Analysis/MemoryBuiltins.h\"\n#include \"llvm/Analysis/MemorySSA.h\"\n#include \"llvm/Analysis/TargetLibraryInfo.h\"\n#include \"llvm/IR/Argument.h\"\n#include \"llvm/IR/BasicBlock.h\"\n#include \"llvm/IR/Constant.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/Dominators.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/InstrTypes.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/IntrinsicInst.h\"\n#include \"llvm/IR/Intrinsics.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/PatternMatch.h\"\n#include \"llvm/IR/Type.h\"\n#include \"llvm/IR/Use.h\"\n#include \"llvm/IR/User.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/InitializePasses.h\"\n#include \"llvm/Pass.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/ArrayRecycler.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/DebugCounter.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include \"llvm/Transforms/Scalar.h\"\n#include \"llvm/Transforms/Scalar/GVNExpression.h\"\n#include \"llvm/Transforms/Utils/AssumeBundleBuilder.h\"\n#include \"llvm/Transforms/Utils/Local.h\"\n#include \"llvm/Transforms/Utils/PredicateInfo.h\"\n#include \"llvm/Transforms/Utils/VNCoercion.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <iterator>\n#include <map>\n#include <memory>\n#include <set>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <vector>\n\nusing namespace llvm;\nusing namespace llvm::GVNExpression;\nusing namespace llvm::VNCoercion;\nusing namespace llvm::PatternMatch;\n\n#define DEBUG_TYPE \"newgvn\"\n\nSTATISTIC(NumGVNInstrDeleted, \"Number of instructions deleted\");\nSTATISTIC(NumGVNBlocksDeleted, \"Number of blocks deleted\");\nSTATISTIC(NumGVNOpsSimplified, \"Number of Expressions simplified\");\nSTATISTIC(NumGVNPhisAllSame, \"Number of PHIs whos arguments are all the same\");\nSTATISTIC(NumGVNMaxIterations,\n          \"Maximum Number of iterations it took to converge GVN\");\nSTATISTIC(NumGVNLeaderChanges, \"Number of leader changes\");\nSTATISTIC(NumGVNSortedLeaderChanges, \"Number of sorted leader changes\");\nSTATISTIC(NumGVNAvoidedSortedLeaderChanges,\n          \"Number of avoided sorted leader changes\");\nSTATISTIC(NumGVNDeadStores, \"Number of redundant/dead stores eliminated\");\nSTATISTIC(NumGVNPHIOfOpsCreated, \"Number of PHI of ops created\");\nSTATISTIC(NumGVNPHIOfOpsEliminations,\n          \"Number of things eliminated using PHI of ops\");\nDEBUG_COUNTER(VNCounter, \"newgvn-vn\",\n              \"Controls which instructions are value numbered\");\nDEBUG_COUNTER(PHIOfOpsCounter, \"newgvn-phi\",\n              \"Controls which instructions we create phi of ops for\");\n// Currently store defining access refinement is too slow due to basicaa being\n// egregiously slow.  This flag lets us keep it working while we work on this\n// issue.\nstatic cl::opt<bool> EnableStoreRefinement(\"enable-store-refinement\",\n                                           cl::init(false), cl::Hidden);\n\n/// Currently, the generation \"phi of ops\" can result in correctness issues.\nstatic cl::opt<bool> EnablePhiOfOps(\"enable-phi-of-ops\", cl::init(true),\n                                    cl::Hidden);\n\n//===----------------------------------------------------------------------===//\n//                                GVN Pass\n//===----------------------------------------------------------------------===//\n\n// Anchor methods.\nnamespace llvm {\nnamespace GVNExpression {\n\nExpression::~Expression() = default;\nBasicExpression::~BasicExpression() = default;\nCallExpression::~CallExpression() = default;\nLoadExpression::~LoadExpression() = default;\nStoreExpression::~StoreExpression() = default;\nAggregateValueExpression::~AggregateValueExpression() = default;\nPHIExpression::~PHIExpression() = default;\n\n} // end namespace GVNExpression\n} // end namespace llvm\n\nnamespace {\n\n// Tarjan's SCC finding algorithm with Nuutila's improvements\n// SCCIterator is actually fairly complex for the simple thing we want.\n// It also wants to hand us SCC's that are unrelated to the phi node we ask\n// about, and have us process them there or risk redoing work.\n// Graph traits over a filter iterator also doesn't work that well here.\n// This SCC finder is specialized to walk use-def chains, and only follows\n// instructions,\n// not generic values (arguments, etc).\nstruct TarjanSCC {\n  TarjanSCC() : Components(1) {}\n\n  void Start(const Instruction *Start) {\n    if (Root.lookup(Start) == 0)\n      FindSCC(Start);\n  }\n\n  const SmallPtrSetImpl<const Value *> &getComponentFor(const Value *V) const {\n    unsigned ComponentID = ValueToComponent.lookup(V);\n\n    assert(ComponentID > 0 &&\n           \"Asking for a component for a value we never processed\");\n    return Components[ComponentID];\n  }\n\nprivate:\n  void FindSCC(const Instruction *I) {\n    Root[I] = ++DFSNum;\n    // Store the DFS Number we had before it possibly gets incremented.\n    unsigned int OurDFS = DFSNum;\n    for (auto &Op : I->operands()) {\n      if (auto *InstOp = dyn_cast<Instruction>(Op)) {\n        if (Root.lookup(Op) == 0)\n          FindSCC(InstOp);\n        if (!InComponent.count(Op))\n          Root[I] = std::min(Root.lookup(I), Root.lookup(Op));\n      }\n    }\n    // See if we really were the root of a component, by seeing if we still have\n    // our DFSNumber.  If we do, we are the root of the component, and we have\n    // completed a component. If we do not, we are not the root of a component,\n    // and belong on the component stack.\n    if (Root.lookup(I) == OurDFS) {\n      unsigned ComponentID = Components.size();\n      Components.resize(Components.size() + 1);\n      auto &Component = Components.back();\n      Component.insert(I);\n      LLVM_DEBUG(dbgs() << \"Component root is \" << *I << \"\\n\");\n      InComponent.insert(I);\n      ValueToComponent[I] = ComponentID;\n      // Pop a component off the stack and label it.\n      while (!Stack.empty() && Root.lookup(Stack.back()) >= OurDFS) {\n        auto *Member = Stack.back();\n        LLVM_DEBUG(dbgs() << \"Component member is \" << *Member << \"\\n\");\n        Component.insert(Member);\n        InComponent.insert(Member);\n        ValueToComponent[Member] = ComponentID;\n        Stack.pop_back();\n      }\n    } else {\n      // Part of a component, push to stack\n      Stack.push_back(I);\n    }\n  }\n\n  unsigned int DFSNum = 1;\n  SmallPtrSet<const Value *, 8> InComponent;\n  DenseMap<const Value *, unsigned int> Root;\n  SmallVector<const Value *, 8> Stack;\n\n  // Store the components as vector of ptr sets, because we need the topo order\n  // of SCC's, but not individual member order\n  SmallVector<SmallPtrSet<const Value *, 8>, 8> Components;\n\n  DenseMap<const Value *, unsigned> ValueToComponent;\n};\n\n// Congruence classes represent the set of expressions/instructions\n// that are all the same *during some scope in the function*.\n// That is, because of the way we perform equality propagation, and\n// because of memory value numbering, it is not correct to assume\n// you can willy-nilly replace any member with any other at any\n// point in the function.\n//\n// For any Value in the Member set, it is valid to replace any dominated member\n// with that Value.\n//\n// Every congruence class has a leader, and the leader is used to symbolize\n// instructions in a canonical way (IE every operand of an instruction that is a\n// member of the same congruence class will always be replaced with leader\n// during symbolization).  To simplify symbolization, we keep the leader as a\n// constant if class can be proved to be a constant value.  Otherwise, the\n// leader is the member of the value set with the smallest DFS number.  Each\n// congruence class also has a defining expression, though the expression may be\n// null.  If it exists, it can be used for forward propagation and reassociation\n// of values.\n\n// For memory, we also track a representative MemoryAccess, and a set of memory\n// members for MemoryPhis (which have no real instructions). Note that for\n// memory, it seems tempting to try to split the memory members into a\n// MemoryCongruenceClass or something.  Unfortunately, this does not work\n// easily.  The value numbering of a given memory expression depends on the\n// leader of the memory congruence class, and the leader of memory congruence\n// class depends on the value numbering of a given memory expression.  This\n// leads to wasted propagation, and in some cases, missed optimization.  For\n// example: If we had value numbered two stores together before, but now do not,\n// we move them to a new value congruence class.  This in turn will move at one\n// of the memorydefs to a new memory congruence class.  Which in turn, affects\n// the value numbering of the stores we just value numbered (because the memory\n// congruence class is part of the value number).  So while theoretically\n// possible to split them up, it turns out to be *incredibly* complicated to get\n// it to work right, because of the interdependency.  While structurally\n// slightly messier, it is algorithmically much simpler and faster to do what we\n// do here, and track them both at once in the same class.\n// Note: The default iterators for this class iterate over values\nclass CongruenceClass {\npublic:\n  using MemberType = Value;\n  using MemberSet = SmallPtrSet<MemberType *, 4>;\n  using MemoryMemberType = MemoryPhi;\n  using MemoryMemberSet = SmallPtrSet<const MemoryMemberType *, 2>;\n\n  explicit CongruenceClass(unsigned ID) : ID(ID) {}\n  CongruenceClass(unsigned ID, Value *Leader, const Expression *E)\n      : ID(ID), RepLeader(Leader), DefiningExpr(E) {}\n\n  unsigned getID() const { return ID; }\n\n  // True if this class has no members left.  This is mainly used for assertion\n  // purposes, and for skipping empty classes.\n  bool isDead() const {\n    // If it's both dead from a value perspective, and dead from a memory\n    // perspective, it's really dead.\n    return empty() && memory_empty();\n  }\n\n  // Leader functions\n  Value *getLeader() const { return RepLeader; }\n  void setLeader(Value *Leader) { RepLeader = Leader; }\n  const std::pair<Value *, unsigned int> &getNextLeader() const {\n    return NextLeader;\n  }\n  void resetNextLeader() { NextLeader = {nullptr, ~0}; }\n  void addPossibleNextLeader(std::pair<Value *, unsigned int> LeaderPair) {\n    if (LeaderPair.second < NextLeader.second)\n      NextLeader = LeaderPair;\n  }\n\n  Value *getStoredValue() const { return RepStoredValue; }\n  void setStoredValue(Value *Leader) { RepStoredValue = Leader; }\n  const MemoryAccess *getMemoryLeader() const { return RepMemoryAccess; }\n  void setMemoryLeader(const MemoryAccess *Leader) { RepMemoryAccess = Leader; }\n\n  // Forward propagation info\n  const Expression *getDefiningExpr() const { return DefiningExpr; }\n\n  // Value member set\n  bool empty() const { return Members.empty(); }\n  unsigned size() const { return Members.size(); }\n  MemberSet::const_iterator begin() const { return Members.begin(); }\n  MemberSet::const_iterator end() const { return Members.end(); }\n  void insert(MemberType *M) { Members.insert(M); }\n  void erase(MemberType *M) { Members.erase(M); }\n  void swap(MemberSet &Other) { Members.swap(Other); }\n\n  // Memory member set\n  bool memory_empty() const { return MemoryMembers.empty(); }\n  unsigned memory_size() const { return MemoryMembers.size(); }\n  MemoryMemberSet::const_iterator memory_begin() const {\n    return MemoryMembers.begin();\n  }\n  MemoryMemberSet::const_iterator memory_end() const {\n    return MemoryMembers.end();\n  }\n  iterator_range<MemoryMemberSet::const_iterator> memory() const {\n    return make_range(memory_begin(), memory_end());\n  }\n\n  void memory_insert(const MemoryMemberType *M) { MemoryMembers.insert(M); }\n  void memory_erase(const MemoryMemberType *M) { MemoryMembers.erase(M); }\n\n  // Store count\n  unsigned getStoreCount() const { return StoreCount; }\n  void incStoreCount() { ++StoreCount; }\n  void decStoreCount() {\n    assert(StoreCount != 0 && \"Store count went negative\");\n    --StoreCount;\n  }\n\n  // True if this class has no memory members.\n  bool definesNoMemory() const { return StoreCount == 0 && memory_empty(); }\n\n  // Return true if two congruence classes are equivalent to each other. This\n  // means that every field but the ID number and the dead field are equivalent.\n  bool isEquivalentTo(const CongruenceClass *Other) const {\n    if (!Other)\n      return false;\n    if (this == Other)\n      return true;\n\n    if (std::tie(StoreCount, RepLeader, RepStoredValue, RepMemoryAccess) !=\n        std::tie(Other->StoreCount, Other->RepLeader, Other->RepStoredValue,\n                 Other->RepMemoryAccess))\n      return false;\n    if (DefiningExpr != Other->DefiningExpr)\n      if (!DefiningExpr || !Other->DefiningExpr ||\n          *DefiningExpr != *Other->DefiningExpr)\n        return false;\n\n    if (Members.size() != Other->Members.size())\n      return false;\n\n    return llvm::set_is_subset(Members, Other->Members);\n  }\n\nprivate:\n  unsigned ID;\n\n  // Representative leader.\n  Value *RepLeader = nullptr;\n\n  // The most dominating leader after our current leader, because the member set\n  // is not sorted and is expensive to keep sorted all the time.\n  std::pair<Value *, unsigned int> NextLeader = {nullptr, ~0U};\n\n  // If this is represented by a store, the value of the store.\n  Value *RepStoredValue = nullptr;\n\n  // If this class contains MemoryDefs or MemoryPhis, this is the leading memory\n  // access.\n  const MemoryAccess *RepMemoryAccess = nullptr;\n\n  // Defining Expression.\n  const Expression *DefiningExpr = nullptr;\n\n  // Actual members of this class.\n  MemberSet Members;\n\n  // This is the set of MemoryPhis that exist in the class. MemoryDefs and\n  // MemoryUses have real instructions representing them, so we only need to\n  // track MemoryPhis here.\n  MemoryMemberSet MemoryMembers;\n\n  // Number of stores in this congruence class.\n  // This is used so we can detect store equivalence changes properly.\n  int StoreCount = 0;\n};\n\n} // end anonymous namespace\n\nnamespace llvm {\n\nstruct ExactEqualsExpression {\n  const Expression &E;\n\n  explicit ExactEqualsExpression(const Expression &E) : E(E) {}\n\n  hash_code getComputedHash() const { return E.getComputedHash(); }\n\n  bool operator==(const Expression &Other) const {\n    return E.exactlyEquals(Other);\n  }\n};\n\ntemplate <> struct DenseMapInfo<const Expression *> {\n  static const Expression *getEmptyKey() {\n    auto Val = static_cast<uintptr_t>(-1);\n    Val <<= PointerLikeTypeTraits<const Expression *>::NumLowBitsAvailable;\n    return reinterpret_cast<const Expression *>(Val);\n  }\n\n  static const Expression *getTombstoneKey() {\n    auto Val = static_cast<uintptr_t>(~1U);\n    Val <<= PointerLikeTypeTraits<const Expression *>::NumLowBitsAvailable;\n    return reinterpret_cast<const Expression *>(Val);\n  }\n\n  static unsigned getHashValue(const Expression *E) {\n    return E->getComputedHash();\n  }\n\n  static unsigned getHashValue(const ExactEqualsExpression &E) {\n    return E.getComputedHash();\n  }\n\n  static bool isEqual(const ExactEqualsExpression &LHS, const Expression *RHS) {\n    if (RHS == getTombstoneKey() || RHS == getEmptyKey())\n      return false;\n    return LHS == *RHS;\n  }\n\n  static bool isEqual(const Expression *LHS, const Expression *RHS) {\n    if (LHS == RHS)\n      return true;\n    if (LHS == getTombstoneKey() || RHS == getTombstoneKey() ||\n        LHS == getEmptyKey() || RHS == getEmptyKey())\n      return false;\n    // Compare hashes before equality.  This is *not* what the hashtable does,\n    // since it is computing it modulo the number of buckets, whereas we are\n    // using the full hash keyspace.  Since the hashes are precomputed, this\n    // check is *much* faster than equality.\n    if (LHS->getComputedHash() != RHS->getComputedHash())\n      return false;\n    return *LHS == *RHS;\n  }\n};\n\n} // end namespace llvm\n\nnamespace {\n\nclass NewGVN {\n  Function &F;\n  DominatorTree *DT = nullptr;\n  const TargetLibraryInfo *TLI = nullptr;\n  AliasAnalysis *AA = nullptr;\n  MemorySSA *MSSA = nullptr;\n  MemorySSAWalker *MSSAWalker = nullptr;\n  AssumptionCache *AC = nullptr;\n  const DataLayout &DL;\n  std::unique_ptr<PredicateInfo> PredInfo;\n\n  // These are the only two things the create* functions should have\n  // side-effects on due to allocating memory.\n  mutable BumpPtrAllocator ExpressionAllocator;\n  mutable ArrayRecycler<Value *> ArgRecycler;\n  mutable TarjanSCC SCCFinder;\n  const SimplifyQuery SQ;\n\n  // Number of function arguments, used by ranking\n  unsigned int NumFuncArgs = 0;\n\n  // RPOOrdering of basic blocks\n  DenseMap<const DomTreeNode *, unsigned> RPOOrdering;\n\n  // Congruence class info.\n\n  // This class is called INITIAL in the paper. It is the class everything\n  // startsout in, and represents any value. Being an optimistic analysis,\n  // anything in the TOP class has the value TOP, which is indeterminate and\n  // equivalent to everything.\n  CongruenceClass *TOPClass = nullptr;\n  std::vector<CongruenceClass *> CongruenceClasses;\n  unsigned NextCongruenceNum = 0;\n\n  // Value Mappings.\n  DenseMap<Value *, CongruenceClass *> ValueToClass;\n  DenseMap<Value *, const Expression *> ValueToExpression;\n\n  // Value PHI handling, used to make equivalence between phi(op, op) and\n  // op(phi, phi).\n  // These mappings just store various data that would normally be part of the\n  // IR.\n  SmallPtrSet<const Instruction *, 8> PHINodeUses;\n\n  DenseMap<const Value *, bool> OpSafeForPHIOfOps;\n\n  // Map a temporary instruction we created to a parent block.\n  DenseMap<const Value *, BasicBlock *> TempToBlock;\n\n  // Map between the already in-program instructions and the temporary phis we\n  // created that they are known equivalent to.\n  DenseMap<const Value *, PHINode *> RealToTemp;\n\n  // In order to know when we should re-process instructions that have\n  // phi-of-ops, we track the set of expressions that they needed as\n  // leaders. When we discover new leaders for those expressions, we process the\n  // associated phi-of-op instructions again in case they have changed.  The\n  // other way they may change is if they had leaders, and those leaders\n  // disappear.  However, at the point they have leaders, there are uses of the\n  // relevant operands in the created phi node, and so they will get reprocessed\n  // through the normal user marking we perform.\n  mutable DenseMap<const Value *, SmallPtrSet<Value *, 2>> AdditionalUsers;\n  DenseMap<const Expression *, SmallPtrSet<Instruction *, 2>>\n      ExpressionToPhiOfOps;\n\n  // Map from temporary operation to MemoryAccess.\n  DenseMap<const Instruction *, MemoryUseOrDef *> TempToMemory;\n\n  // Set of all temporary instructions we created.\n  // Note: This will include instructions that were just created during value\n  // numbering.  The way to test if something is using them is to check\n  // RealToTemp.\n  DenseSet<Instruction *> AllTempInstructions;\n\n  // This is the set of instructions to revisit on a reachability change.  At\n  // the end of the main iteration loop it will contain at least all the phi of\n  // ops instructions that will be changed to phis, as well as regular phis.\n  // During the iteration loop, it may contain other things, such as phi of ops\n  // instructions that used edge reachability to reach a result, and so need to\n  // be revisited when the edge changes, independent of whether the phi they\n  // depended on changes.\n  DenseMap<BasicBlock *, SparseBitVector<>> RevisitOnReachabilityChange;\n\n  // Mapping from predicate info we used to the instructions we used it with.\n  // In order to correctly ensure propagation, we must keep track of what\n  // comparisons we used, so that when the values of the comparisons change, we\n  // propagate the information to the places we used the comparison.\n  mutable DenseMap<const Value *, SmallPtrSet<Instruction *, 2>>\n      PredicateToUsers;\n\n  // the same reasoning as PredicateToUsers.  When we skip MemoryAccesses for\n  // stores, we no longer can rely solely on the def-use chains of MemorySSA.\n  mutable DenseMap<const MemoryAccess *, SmallPtrSet<MemoryAccess *, 2>>\n      MemoryToUsers;\n\n  // A table storing which memorydefs/phis represent a memory state provably\n  // equivalent to another memory state.\n  // We could use the congruence class machinery, but the MemoryAccess's are\n  // abstract memory states, so they can only ever be equivalent to each other,\n  // and not to constants, etc.\n  DenseMap<const MemoryAccess *, CongruenceClass *> MemoryAccessToClass;\n\n  // We could, if we wanted, build MemoryPhiExpressions and\n  // MemoryVariableExpressions, etc, and value number them the same way we value\n  // number phi expressions.  For the moment, this seems like overkill.  They\n  // can only exist in one of three states: they can be TOP (equal to\n  // everything), Equivalent to something else, or unique.  Because we do not\n  // create expressions for them, we need to simulate leader change not just\n  // when they change class, but when they change state.  Note: We can do the\n  // same thing for phis, and avoid having phi expressions if we wanted, We\n  // should eventually unify in one direction or the other, so this is a little\n  // bit of an experiment in which turns out easier to maintain.\n  enum MemoryPhiState { MPS_Invalid, MPS_TOP, MPS_Equivalent, MPS_Unique };\n  DenseMap<const MemoryPhi *, MemoryPhiState> MemoryPhiState;\n\n  enum InstCycleState { ICS_Unknown, ICS_CycleFree, ICS_Cycle };\n  mutable DenseMap<const Instruction *, InstCycleState> InstCycleState;\n\n  // Expression to class mapping.\n  using ExpressionClassMap = DenseMap<const Expression *, CongruenceClass *>;\n  ExpressionClassMap ExpressionToClass;\n\n  // We have a single expression that represents currently DeadExpressions.\n  // For dead expressions we can prove will stay dead, we mark them with\n  // DFS number zero.  However, it's possible in the case of phi nodes\n  // for us to assume/prove all arguments are dead during fixpointing.\n  // We use DeadExpression for that case.\n  DeadExpression *SingletonDeadExpression = nullptr;\n\n  // Which values have changed as a result of leader changes.\n  SmallPtrSet<Value *, 8> LeaderChanges;\n\n  // Reachability info.\n  using BlockEdge = BasicBlockEdge;\n  DenseSet<BlockEdge> ReachableEdges;\n  SmallPtrSet<const BasicBlock *, 8> ReachableBlocks;\n\n  // This is a bitvector because, on larger functions, we may have\n  // thousands of touched instructions at once (entire blocks,\n  // instructions with hundreds of uses, etc).  Even with optimization\n  // for when we mark whole blocks as touched, when this was a\n  // SmallPtrSet or DenseSet, for some functions, we spent >20% of all\n  // the time in GVN just managing this list.  The bitvector, on the\n  // other hand, efficiently supports test/set/clear of both\n  // individual and ranges, as well as \"find next element\" This\n  // enables us to use it as a worklist with essentially 0 cost.\n  BitVector TouchedInstructions;\n\n  DenseMap<const BasicBlock *, std::pair<unsigned, unsigned>> BlockInstRange;\n\n#ifndef NDEBUG\n  // Debugging for how many times each block and instruction got processed.\n  DenseMap<const Value *, unsigned> ProcessedCount;\n#endif\n\n  // DFS info.\n  // This contains a mapping from Instructions to DFS numbers.\n  // The numbering starts at 1. An instruction with DFS number zero\n  // means that the instruction is dead.\n  DenseMap<const Value *, unsigned> InstrDFS;\n\n  // This contains the mapping DFS numbers to instructions.\n  SmallVector<Value *, 32> DFSToInstr;\n\n  // Deletion info.\n  SmallPtrSet<Instruction *, 8> InstructionsToErase;\n\npublic:\n  NewGVN(Function &F, DominatorTree *DT, AssumptionCache *AC,\n         TargetLibraryInfo *TLI, AliasAnalysis *AA, MemorySSA *MSSA,\n         const DataLayout &DL)\n      : F(F), DT(DT), TLI(TLI), AA(AA), MSSA(MSSA), AC(AC), DL(DL),\n        PredInfo(std::make_unique<PredicateInfo>(F, *DT, *AC)),\n        SQ(DL, TLI, DT, AC, /*CtxI=*/nullptr, /*UseInstrInfo=*/false,\n           /*CanUseUndef=*/false) {}\n\n  bool runGVN();\n\nprivate:\n  // Expression handling.\n  const Expression *createExpression(Instruction *) const;\n  const Expression *createBinaryExpression(unsigned, Type *, Value *, Value *,\n                                           Instruction *) const;\n\n  // Our canonical form for phi arguments is a pair of incoming value, incoming\n  // basic block.\n  using ValPair = std::pair<Value *, BasicBlock *>;\n\n  PHIExpression *createPHIExpression(ArrayRef<ValPair>, const Instruction *,\n                                     BasicBlock *, bool &HasBackEdge,\n                                     bool &OriginalOpsConstant) const;\n  const DeadExpression *createDeadExpression() const;\n  const VariableExpression *createVariableExpression(Value *) const;\n  const ConstantExpression *createConstantExpression(Constant *) const;\n  const Expression *createVariableOrConstant(Value *V) const;\n  const UnknownExpression *createUnknownExpression(Instruction *) const;\n  const StoreExpression *createStoreExpression(StoreInst *,\n                                               const MemoryAccess *) const;\n  LoadExpression *createLoadExpression(Type *, Value *, LoadInst *,\n                                       const MemoryAccess *) const;\n  const CallExpression *createCallExpression(CallInst *,\n                                             const MemoryAccess *) const;\n  const AggregateValueExpression *\n  createAggregateValueExpression(Instruction *) const;\n  bool setBasicExpressionInfo(Instruction *, BasicExpression *) const;\n\n  // Congruence class handling.\n  CongruenceClass *createCongruenceClass(Value *Leader, const Expression *E) {\n    auto *result = new CongruenceClass(NextCongruenceNum++, Leader, E);\n    CongruenceClasses.emplace_back(result);\n    return result;\n  }\n\n  CongruenceClass *createMemoryClass(MemoryAccess *MA) {\n    auto *CC = createCongruenceClass(nullptr, nullptr);\n    CC->setMemoryLeader(MA);\n    return CC;\n  }\n\n  CongruenceClass *ensureLeaderOfMemoryClass(MemoryAccess *MA) {\n    auto *CC = getMemoryClass(MA);\n    if (CC->getMemoryLeader() != MA)\n      CC = createMemoryClass(MA);\n    return CC;\n  }\n\n  CongruenceClass *createSingletonCongruenceClass(Value *Member) {\n    CongruenceClass *CClass = createCongruenceClass(Member, nullptr);\n    CClass->insert(Member);\n    ValueToClass[Member] = CClass;\n    return CClass;\n  }\n\n  void initializeCongruenceClasses(Function &F);\n  const Expression *makePossiblePHIOfOps(Instruction *,\n                                         SmallPtrSetImpl<Value *> &);\n  Value *findLeaderForInst(Instruction *ValueOp,\n                           SmallPtrSetImpl<Value *> &Visited,\n                           MemoryAccess *MemAccess, Instruction *OrigInst,\n                           BasicBlock *PredBB);\n  bool OpIsSafeForPHIOfOpsHelper(Value *V, const BasicBlock *PHIBlock,\n                                 SmallPtrSetImpl<const Value *> &Visited,\n                                 SmallVectorImpl<Instruction *> &Worklist);\n  bool OpIsSafeForPHIOfOps(Value *Op, const BasicBlock *PHIBlock,\n                           SmallPtrSetImpl<const Value *> &);\n  void addPhiOfOps(PHINode *Op, BasicBlock *BB, Instruction *ExistingValue);\n  void removePhiOfOps(Instruction *I, PHINode *PHITemp);\n\n  // Value number an Instruction or MemoryPhi.\n  void valueNumberMemoryPhi(MemoryPhi *);\n  void valueNumberInstruction(Instruction *);\n\n  // Symbolic evaluation.\n  const Expression *checkSimplificationResults(Expression *, Instruction *,\n                                               Value *) const;\n  const Expression *performSymbolicEvaluation(Value *,\n                                              SmallPtrSetImpl<Value *> &) const;\n  const Expression *performSymbolicLoadCoercion(Type *, Value *, LoadInst *,\n                                                Instruction *,\n                                                MemoryAccess *) const;\n  const Expression *performSymbolicLoadEvaluation(Instruction *) const;\n  const Expression *performSymbolicStoreEvaluation(Instruction *) const;\n  const Expression *performSymbolicCallEvaluation(Instruction *) const;\n  void sortPHIOps(MutableArrayRef<ValPair> Ops) const;\n  const Expression *performSymbolicPHIEvaluation(ArrayRef<ValPair>,\n                                                 Instruction *I,\n                                                 BasicBlock *PHIBlock) const;\n  const Expression *performSymbolicAggrValueEvaluation(Instruction *) const;\n  const Expression *performSymbolicCmpEvaluation(Instruction *) const;\n  const Expression *performSymbolicPredicateInfoEvaluation(Instruction *) const;\n\n  // Congruence finding.\n  bool someEquivalentDominates(const Instruction *, const Instruction *) const;\n  Value *lookupOperandLeader(Value *) const;\n  CongruenceClass *getClassForExpression(const Expression *E) const;\n  void performCongruenceFinding(Instruction *, const Expression *);\n  void moveValueToNewCongruenceClass(Instruction *, const Expression *,\n                                     CongruenceClass *, CongruenceClass *);\n  void moveMemoryToNewCongruenceClass(Instruction *, MemoryAccess *,\n                                      CongruenceClass *, CongruenceClass *);\n  Value *getNextValueLeader(CongruenceClass *) const;\n  const MemoryAccess *getNextMemoryLeader(CongruenceClass *) const;\n  bool setMemoryClass(const MemoryAccess *From, CongruenceClass *To);\n  CongruenceClass *getMemoryClass(const MemoryAccess *MA) const;\n  const MemoryAccess *lookupMemoryLeader(const MemoryAccess *) const;\n  bool isMemoryAccessTOP(const MemoryAccess *) const;\n\n  // Ranking\n  unsigned int getRank(const Value *) const;\n  bool shouldSwapOperands(const Value *, const Value *) const;\n\n  // Reachability handling.\n  void updateReachableEdge(BasicBlock *, BasicBlock *);\n  void processOutgoingEdges(Instruction *, BasicBlock *);\n  Value *findConditionEquivalence(Value *) const;\n\n  // Elimination.\n  struct ValueDFS;\n  void convertClassToDFSOrdered(const CongruenceClass &,\n                                SmallVectorImpl<ValueDFS> &,\n                                DenseMap<const Value *, unsigned int> &,\n                                SmallPtrSetImpl<Instruction *> &) const;\n  void convertClassToLoadsAndStores(const CongruenceClass &,\n                                    SmallVectorImpl<ValueDFS> &) const;\n\n  bool eliminateInstructions(Function &);\n  void replaceInstruction(Instruction *, Value *);\n  void markInstructionForDeletion(Instruction *);\n  void deleteInstructionsInBlock(BasicBlock *);\n  Value *findPHIOfOpsLeader(const Expression *, const Instruction *,\n                            const BasicBlock *) const;\n\n  // Various instruction touch utilities\n  template <typename Map, typename KeyType>\n  void touchAndErase(Map &, const KeyType &);\n  void markUsersTouched(Value *);\n  void markMemoryUsersTouched(const MemoryAccess *);\n  void markMemoryDefTouched(const MemoryAccess *);\n  void markPredicateUsersTouched(Instruction *);\n  void markValueLeaderChangeTouched(CongruenceClass *CC);\n  void markMemoryLeaderChangeTouched(CongruenceClass *CC);\n  void markPhiOfOpsChanged(const Expression *E);\n  void addPredicateUsers(const PredicateBase *, Instruction *) const;\n  void addMemoryUsers(const MemoryAccess *To, MemoryAccess *U) const;\n  void addAdditionalUsers(Value *To, Value *User) const;\n\n  // Main loop of value numbering\n  void iterateTouchedInstructions();\n\n  // Utilities.\n  void cleanupTables();\n  std::pair<unsigned, unsigned> assignDFSNumbers(BasicBlock *, unsigned);\n  void updateProcessedCount(const Value *V);\n  void verifyMemoryCongruency() const;\n  void verifyIterationSettled(Function &F);\n  void verifyStoreExpressions() const;\n  bool singleReachablePHIPath(SmallPtrSet<const MemoryAccess *, 8> &,\n                              const MemoryAccess *, const MemoryAccess *) const;\n  BasicBlock *getBlockForValue(Value *V) const;\n  void deleteExpression(const Expression *E) const;\n  MemoryUseOrDef *getMemoryAccess(const Instruction *) const;\n  MemoryPhi *getMemoryAccess(const BasicBlock *) const;\n  template <class T, class Range> T *getMinDFSOfRange(const Range &) const;\n\n  unsigned InstrToDFSNum(const Value *V) const {\n    assert(isa<Instruction>(V) && \"This should not be used for MemoryAccesses\");\n    return InstrDFS.lookup(V);\n  }\n\n  unsigned InstrToDFSNum(const MemoryAccess *MA) const {\n    return MemoryToDFSNum(MA);\n  }\n\n  Value *InstrFromDFSNum(unsigned DFSNum) { return DFSToInstr[DFSNum]; }\n\n  // Given a MemoryAccess, return the relevant instruction DFS number.  Note:\n  // This deliberately takes a value so it can be used with Use's, which will\n  // auto-convert to Value's but not to MemoryAccess's.\n  unsigned MemoryToDFSNum(const Value *MA) const {\n    assert(isa<MemoryAccess>(MA) &&\n           \"This should not be used with instructions\");\n    return isa<MemoryUseOrDef>(MA)\n               ? InstrToDFSNum(cast<MemoryUseOrDef>(MA)->getMemoryInst())\n               : InstrDFS.lookup(MA);\n  }\n\n  bool isCycleFree(const Instruction *) const;\n  bool isBackedge(BasicBlock *From, BasicBlock *To) const;\n\n  // Debug counter info.  When verifying, we have to reset the value numbering\n  // debug counter to the same state it started in to get the same results.\n  int64_t StartingVNCounter = 0;\n};\n\n} // end anonymous namespace\n\ntemplate <typename T>\nstatic bool equalsLoadStoreHelper(const T &LHS, const Expression &RHS) {\n  if (!isa<LoadExpression>(RHS) && !isa<StoreExpression>(RHS))\n    return false;\n  return LHS.MemoryExpression::equals(RHS);\n}\n\nbool LoadExpression::equals(const Expression &Other) const {\n  return equalsLoadStoreHelper(*this, Other);\n}\n\nbool StoreExpression::equals(const Expression &Other) const {\n  if (!equalsLoadStoreHelper(*this, Other))\n    return false;\n  // Make sure that store vs store includes the value operand.\n  if (const auto *S = dyn_cast<StoreExpression>(&Other))\n    if (getStoredValue() != S->getStoredValue())\n      return false;\n  return true;\n}\n\n// Determine if the edge From->To is a backedge\nbool NewGVN::isBackedge(BasicBlock *From, BasicBlock *To) const {\n  return From == To ||\n         RPOOrdering.lookup(DT->getNode(From)) >=\n             RPOOrdering.lookup(DT->getNode(To));\n}\n\n#ifndef NDEBUG\nstatic std::string getBlockName(const BasicBlock *B) {\n  return DOTGraphTraits<DOTFuncInfo *>::getSimpleNodeLabel(B, nullptr);\n}\n#endif\n\n// Get a MemoryAccess for an instruction, fake or real.\nMemoryUseOrDef *NewGVN::getMemoryAccess(const Instruction *I) const {\n  auto *Result = MSSA->getMemoryAccess(I);\n  return Result ? Result : TempToMemory.lookup(I);\n}\n\n// Get a MemoryPhi for a basic block. These are all real.\nMemoryPhi *NewGVN::getMemoryAccess(const BasicBlock *BB) const {\n  return MSSA->getMemoryAccess(BB);\n}\n\n// Get the basic block from an instruction/memory value.\nBasicBlock *NewGVN::getBlockForValue(Value *V) const {\n  if (auto *I = dyn_cast<Instruction>(V)) {\n    auto *Parent = I->getParent();\n    if (Parent)\n      return Parent;\n    Parent = TempToBlock.lookup(V);\n    assert(Parent && \"Every fake instruction should have a block\");\n    return Parent;\n  }\n\n  auto *MP = dyn_cast<MemoryPhi>(V);\n  assert(MP && \"Should have been an instruction or a MemoryPhi\");\n  return MP->getBlock();\n}\n\n// Delete a definitely dead expression, so it can be reused by the expression\n// allocator.  Some of these are not in creation functions, so we have to accept\n// const versions.\nvoid NewGVN::deleteExpression(const Expression *E) const {\n  assert(isa<BasicExpression>(E));\n  auto *BE = cast<BasicExpression>(E);\n  const_cast<BasicExpression *>(BE)->deallocateOperands(ArgRecycler);\n  ExpressionAllocator.Deallocate(E);\n}\n\n// If V is a predicateinfo copy, get the thing it is a copy of.\nstatic Value *getCopyOf(const Value *V) {\n  if (auto *II = dyn_cast<IntrinsicInst>(V))\n    if (II->getIntrinsicID() == Intrinsic::ssa_copy)\n      return II->getOperand(0);\n  return nullptr;\n}\n\n// Return true if V is really PN, even accounting for predicateinfo copies.\nstatic bool isCopyOfPHI(const Value *V, const PHINode *PN) {\n  return V == PN || getCopyOf(V) == PN;\n}\n\nstatic bool isCopyOfAPHI(const Value *V) {\n  auto *CO = getCopyOf(V);\n  return CO && isa<PHINode>(CO);\n}\n\n// Sort PHI Operands into a canonical order.  What we use here is an RPO\n// order. The BlockInstRange numbers are generated in an RPO walk of the basic\n// blocks.\nvoid NewGVN::sortPHIOps(MutableArrayRef<ValPair> Ops) const {\n  llvm::sort(Ops, [&](const ValPair &P1, const ValPair &P2) {\n    return BlockInstRange.lookup(P1.second).first <\n           BlockInstRange.lookup(P2.second).first;\n  });\n}\n\n// Return true if V is a value that will always be available (IE can\n// be placed anywhere) in the function.  We don't do globals here\n// because they are often worse to put in place.\nstatic bool alwaysAvailable(Value *V) {\n  return isa<Constant>(V) || isa<Argument>(V);\n}\n\n// Create a PHIExpression from an array of {incoming edge, value} pairs.  I is\n// the original instruction we are creating a PHIExpression for (but may not be\n// a phi node). We require, as an invariant, that all the PHIOperands in the\n// same block are sorted the same way. sortPHIOps will sort them into a\n// canonical order.\nPHIExpression *NewGVN::createPHIExpression(ArrayRef<ValPair> PHIOperands,\n                                           const Instruction *I,\n                                           BasicBlock *PHIBlock,\n                                           bool &HasBackedge,\n                                           bool &OriginalOpsConstant) const {\n  unsigned NumOps = PHIOperands.size();\n  auto *E = new (ExpressionAllocator) PHIExpression(NumOps, PHIBlock);\n\n  E->allocateOperands(ArgRecycler, ExpressionAllocator);\n  E->setType(PHIOperands.begin()->first->getType());\n  E->setOpcode(Instruction::PHI);\n\n  // Filter out unreachable phi operands.\n  auto Filtered = make_filter_range(PHIOperands, [&](const ValPair &P) {\n    auto *BB = P.second;\n    if (auto *PHIOp = dyn_cast<PHINode>(I))\n      if (isCopyOfPHI(P.first, PHIOp))\n        return false;\n    if (!ReachableEdges.count({BB, PHIBlock}))\n      return false;\n    // Things in TOPClass are equivalent to everything.\n    if (ValueToClass.lookup(P.first) == TOPClass)\n      return false;\n    OriginalOpsConstant = OriginalOpsConstant && isa<Constant>(P.first);\n    HasBackedge = HasBackedge || isBackedge(BB, PHIBlock);\n    return lookupOperandLeader(P.first) != I;\n  });\n  std::transform(Filtered.begin(), Filtered.end(), op_inserter(E),\n                 [&](const ValPair &P) -> Value * {\n                   return lookupOperandLeader(P.first);\n                 });\n  return E;\n}\n\n// Set basic expression info (Arguments, type, opcode) for Expression\n// E from Instruction I in block B.\nbool NewGVN::setBasicExpressionInfo(Instruction *I, BasicExpression *E) const {\n  bool AllConstant = true;\n  if (auto *GEP = dyn_cast<GetElementPtrInst>(I))\n    E->setType(GEP->getSourceElementType());\n  else\n    E->setType(I->getType());\n  E->setOpcode(I->getOpcode());\n  E->allocateOperands(ArgRecycler, ExpressionAllocator);\n\n  // Transform the operand array into an operand leader array, and keep track of\n  // whether all members are constant.\n  std::transform(I->op_begin(), I->op_end(), op_inserter(E), [&](Value *O) {\n    auto Operand = lookupOperandLeader(O);\n    AllConstant = AllConstant && isa<Constant>(Operand);\n    return Operand;\n  });\n\n  return AllConstant;\n}\n\nconst Expression *NewGVN::createBinaryExpression(unsigned Opcode, Type *T,\n                                                 Value *Arg1, Value *Arg2,\n                                                 Instruction *I) const {\n  auto *E = new (ExpressionAllocator) BasicExpression(2);\n\n  E->setType(T);\n  E->setOpcode(Opcode);\n  E->allocateOperands(ArgRecycler, ExpressionAllocator);\n  if (Instruction::isCommutative(Opcode)) {\n    // Ensure that commutative instructions that only differ by a permutation\n    // of their operands get the same value number by sorting the operand value\n    // numbers.  Since all commutative instructions have two operands it is more\n    // efficient to sort by hand rather than using, say, std::sort.\n    if (shouldSwapOperands(Arg1, Arg2))\n      std::swap(Arg1, Arg2);\n  }\n  E->op_push_back(lookupOperandLeader(Arg1));\n  E->op_push_back(lookupOperandLeader(Arg2));\n\n  Value *V = SimplifyBinOp(Opcode, E->getOperand(0), E->getOperand(1), SQ);\n  if (const Expression *SimplifiedE = checkSimplificationResults(E, I, V))\n    return SimplifiedE;\n  return E;\n}\n\n// Take a Value returned by simplification of Expression E/Instruction\n// I, and see if it resulted in a simpler expression. If so, return\n// that expression.\nconst Expression *NewGVN::checkSimplificationResults(Expression *E,\n                                                     Instruction *I,\n                                                     Value *V) const {\n  if (!V)\n    return nullptr;\n  if (auto *C = dyn_cast<Constant>(V)) {\n    if (I)\n      LLVM_DEBUG(dbgs() << \"Simplified \" << *I << \" to \"\n                        << \" constant \" << *C << \"\\n\");\n    NumGVNOpsSimplified++;\n    assert(isa<BasicExpression>(E) &&\n           \"We should always have had a basic expression here\");\n    deleteExpression(E);\n    return createConstantExpression(C);\n  } else if (isa<Argument>(V) || isa<GlobalVariable>(V)) {\n    if (I)\n      LLVM_DEBUG(dbgs() << \"Simplified \" << *I << \" to \"\n                        << \" variable \" << *V << \"\\n\");\n    deleteExpression(E);\n    return createVariableExpression(V);\n  }\n\n  CongruenceClass *CC = ValueToClass.lookup(V);\n  if (CC) {\n    if (CC->getLeader() && CC->getLeader() != I) {\n      // If we simplified to something else, we need to communicate\n      // that we're users of the value we simplified to.\n      if (I != V) {\n        // Don't add temporary instructions to the user lists.\n        if (!AllTempInstructions.count(I))\n          addAdditionalUsers(V, I);\n      }\n      return createVariableOrConstant(CC->getLeader());\n    }\n    if (CC->getDefiningExpr()) {\n      // If we simplified to something else, we need to communicate\n      // that we're users of the value we simplified to.\n      if (I != V) {\n        // Don't add temporary instructions to the user lists.\n        if (!AllTempInstructions.count(I))\n          addAdditionalUsers(V, I);\n      }\n\n      if (I)\n        LLVM_DEBUG(dbgs() << \"Simplified \" << *I << \" to \"\n                          << \" expression \" << *CC->getDefiningExpr() << \"\\n\");\n      NumGVNOpsSimplified++;\n      deleteExpression(E);\n      return CC->getDefiningExpr();\n    }\n  }\n\n  return nullptr;\n}\n\n// Create a value expression from the instruction I, replacing operands with\n// their leaders.\n\nconst Expression *NewGVN::createExpression(Instruction *I) const {\n  auto *E = new (ExpressionAllocator) BasicExpression(I->getNumOperands());\n\n  bool AllConstant = setBasicExpressionInfo(I, E);\n\n  if (I->isCommutative()) {\n    // Ensure that commutative instructions that only differ by a permutation\n    // of their operands get the same value number by sorting the operand value\n    // numbers.  Since all commutative instructions have two operands it is more\n    // efficient to sort by hand rather than using, say, std::sort.\n    assert(I->getNumOperands() == 2 && \"Unsupported commutative instruction!\");\n    if (shouldSwapOperands(E->getOperand(0), E->getOperand(1)))\n      E->swapOperands(0, 1);\n  }\n  // Perform simplification.\n  if (auto *CI = dyn_cast<CmpInst>(I)) {\n    // Sort the operand value numbers so x<y and y>x get the same value\n    // number.\n    CmpInst::Predicate Predicate = CI->getPredicate();\n    if (shouldSwapOperands(E->getOperand(0), E->getOperand(1))) {\n      E->swapOperands(0, 1);\n      Predicate = CmpInst::getSwappedPredicate(Predicate);\n    }\n    E->setOpcode((CI->getOpcode() << 8) | Predicate);\n    // TODO: 25% of our time is spent in SimplifyCmpInst with pointer operands\n    assert(I->getOperand(0)->getType() == I->getOperand(1)->getType() &&\n           \"Wrong types on cmp instruction\");\n    assert((E->getOperand(0)->getType() == I->getOperand(0)->getType() &&\n            E->getOperand(1)->getType() == I->getOperand(1)->getType()));\n    Value *V =\n        SimplifyCmpInst(Predicate, E->getOperand(0), E->getOperand(1), SQ);\n    if (const Expression *SimplifiedE = checkSimplificationResults(E, I, V))\n      return SimplifiedE;\n  } else if (isa<SelectInst>(I)) {\n    if (isa<Constant>(E->getOperand(0)) ||\n        E->getOperand(1) == E->getOperand(2)) {\n      assert(E->getOperand(1)->getType() == I->getOperand(1)->getType() &&\n             E->getOperand(2)->getType() == I->getOperand(2)->getType());\n      Value *V = SimplifySelectInst(E->getOperand(0), E->getOperand(1),\n                                    E->getOperand(2), SQ);\n      if (const Expression *SimplifiedE = checkSimplificationResults(E, I, V))\n        return SimplifiedE;\n    }\n  } else if (I->isBinaryOp()) {\n    Value *V =\n        SimplifyBinOp(E->getOpcode(), E->getOperand(0), E->getOperand(1), SQ);\n    if (const Expression *SimplifiedE = checkSimplificationResults(E, I, V))\n      return SimplifiedE;\n  } else if (auto *CI = dyn_cast<CastInst>(I)) {\n    Value *V =\n        SimplifyCastInst(CI->getOpcode(), E->getOperand(0), CI->getType(), SQ);\n    if (const Expression *SimplifiedE = checkSimplificationResults(E, I, V))\n      return SimplifiedE;\n  } else if (isa<GetElementPtrInst>(I)) {\n    Value *V = SimplifyGEPInst(\n        E->getType(), ArrayRef<Value *>(E->op_begin(), E->op_end()), SQ);\n    if (const Expression *SimplifiedE = checkSimplificationResults(E, I, V))\n      return SimplifiedE;\n  } else if (AllConstant) {\n    // We don't bother trying to simplify unless all of the operands\n    // were constant.\n    // TODO: There are a lot of Simplify*'s we could call here, if we\n    // wanted to.  The original motivating case for this code was a\n    // zext i1 false to i8, which we don't have an interface to\n    // simplify (IE there is no SimplifyZExt).\n\n    SmallVector<Constant *, 8> C;\n    for (Value *Arg : E->operands())\n      C.emplace_back(cast<Constant>(Arg));\n\n    if (Value *V = ConstantFoldInstOperands(I, C, DL, TLI))\n      if (const Expression *SimplifiedE = checkSimplificationResults(E, I, V))\n        return SimplifiedE;\n  }\n  return E;\n}\n\nconst AggregateValueExpression *\nNewGVN::createAggregateValueExpression(Instruction *I) const {\n  if (auto *II = dyn_cast<InsertValueInst>(I)) {\n    auto *E = new (ExpressionAllocator)\n        AggregateValueExpression(I->getNumOperands(), II->getNumIndices());\n    setBasicExpressionInfo(I, E);\n    E->allocateIntOperands(ExpressionAllocator);\n    std::copy(II->idx_begin(), II->idx_end(), int_op_inserter(E));\n    return E;\n  } else if (auto *EI = dyn_cast<ExtractValueInst>(I)) {\n    auto *E = new (ExpressionAllocator)\n        AggregateValueExpression(I->getNumOperands(), EI->getNumIndices());\n    setBasicExpressionInfo(EI, E);\n    E->allocateIntOperands(ExpressionAllocator);\n    std::copy(EI->idx_begin(), EI->idx_end(), int_op_inserter(E));\n    return E;\n  }\n  llvm_unreachable(\"Unhandled type of aggregate value operation\");\n}\n\nconst DeadExpression *NewGVN::createDeadExpression() const {\n  // DeadExpression has no arguments and all DeadExpression's are the same,\n  // so we only need one of them.\n  return SingletonDeadExpression;\n}\n\nconst VariableExpression *NewGVN::createVariableExpression(Value *V) const {\n  auto *E = new (ExpressionAllocator) VariableExpression(V);\n  E->setOpcode(V->getValueID());\n  return E;\n}\n\nconst Expression *NewGVN::createVariableOrConstant(Value *V) const {\n  if (auto *C = dyn_cast<Constant>(V))\n    return createConstantExpression(C);\n  return createVariableExpression(V);\n}\n\nconst ConstantExpression *NewGVN::createConstantExpression(Constant *C) const {\n  auto *E = new (ExpressionAllocator) ConstantExpression(C);\n  E->setOpcode(C->getValueID());\n  return E;\n}\n\nconst UnknownExpression *NewGVN::createUnknownExpression(Instruction *I) const {\n  auto *E = new (ExpressionAllocator) UnknownExpression(I);\n  E->setOpcode(I->getOpcode());\n  return E;\n}\n\nconst CallExpression *\nNewGVN::createCallExpression(CallInst *CI, const MemoryAccess *MA) const {\n  // FIXME: Add operand bundles for calls.\n  // FIXME: Allow commutative matching for intrinsics.\n  auto *E =\n      new (ExpressionAllocator) CallExpression(CI->getNumOperands(), CI, MA);\n  setBasicExpressionInfo(CI, E);\n  return E;\n}\n\n// Return true if some equivalent of instruction Inst dominates instruction U.\nbool NewGVN::someEquivalentDominates(const Instruction *Inst,\n                                     const Instruction *U) const {\n  auto *CC = ValueToClass.lookup(Inst);\n   // This must be an instruction because we are only called from phi nodes\n  // in the case that the value it needs to check against is an instruction.\n\n  // The most likely candidates for dominance are the leader and the next leader.\n  // The leader or nextleader will dominate in all cases where there is an\n  // equivalent that is higher up in the dom tree.\n  // We can't *only* check them, however, because the\n  // dominator tree could have an infinite number of non-dominating siblings\n  // with instructions that are in the right congruence class.\n  //       A\n  // B C D E F G\n  // |\n  // H\n  // Instruction U could be in H,  with equivalents in every other sibling.\n  // Depending on the rpo order picked, the leader could be the equivalent in\n  // any of these siblings.\n  if (!CC)\n    return false;\n  if (alwaysAvailable(CC->getLeader()))\n    return true;\n  if (DT->dominates(cast<Instruction>(CC->getLeader()), U))\n    return true;\n  if (CC->getNextLeader().first &&\n      DT->dominates(cast<Instruction>(CC->getNextLeader().first), U))\n    return true;\n  return llvm::any_of(*CC, [&](const Value *Member) {\n    return Member != CC->getLeader() &&\n           DT->dominates(cast<Instruction>(Member), U);\n  });\n}\n\n// See if we have a congruence class and leader for this operand, and if so,\n// return it. Otherwise, return the operand itself.\nValue *NewGVN::lookupOperandLeader(Value *V) const {\n  CongruenceClass *CC = ValueToClass.lookup(V);\n  if (CC) {\n    // Everything in TOP is represented by undef, as it can be any value.\n    // We do have to make sure we get the type right though, so we can't set the\n    // RepLeader to undef.\n    if (CC == TOPClass)\n      return UndefValue::get(V->getType());\n    return CC->getStoredValue() ? CC->getStoredValue() : CC->getLeader();\n  }\n\n  return V;\n}\n\nconst MemoryAccess *NewGVN::lookupMemoryLeader(const MemoryAccess *MA) const {\n  auto *CC = getMemoryClass(MA);\n  assert(CC->getMemoryLeader() &&\n         \"Every MemoryAccess should be mapped to a congruence class with a \"\n         \"representative memory access\");\n  return CC->getMemoryLeader();\n}\n\n// Return true if the MemoryAccess is really equivalent to everything. This is\n// equivalent to the lattice value \"TOP\" in most lattices.  This is the initial\n// state of all MemoryAccesses.\nbool NewGVN::isMemoryAccessTOP(const MemoryAccess *MA) const {\n  return getMemoryClass(MA) == TOPClass;\n}\n\nLoadExpression *NewGVN::createLoadExpression(Type *LoadType, Value *PointerOp,\n                                             LoadInst *LI,\n                                             const MemoryAccess *MA) const {\n  auto *E =\n      new (ExpressionAllocator) LoadExpression(1, LI, lookupMemoryLeader(MA));\n  E->allocateOperands(ArgRecycler, ExpressionAllocator);\n  E->setType(LoadType);\n\n  // Give store and loads same opcode so they value number together.\n  E->setOpcode(0);\n  E->op_push_back(PointerOp);\n\n  // TODO: Value number heap versions. We may be able to discover\n  // things alias analysis can't on it's own (IE that a store and a\n  // load have the same value, and thus, it isn't clobbering the load).\n  return E;\n}\n\nconst StoreExpression *\nNewGVN::createStoreExpression(StoreInst *SI, const MemoryAccess *MA) const {\n  auto *StoredValueLeader = lookupOperandLeader(SI->getValueOperand());\n  auto *E = new (ExpressionAllocator)\n      StoreExpression(SI->getNumOperands(), SI, StoredValueLeader, MA);\n  E->allocateOperands(ArgRecycler, ExpressionAllocator);\n  E->setType(SI->getValueOperand()->getType());\n\n  // Give store and loads same opcode so they value number together.\n  E->setOpcode(0);\n  E->op_push_back(lookupOperandLeader(SI->getPointerOperand()));\n\n  // TODO: Value number heap versions. We may be able to discover\n  // things alias analysis can't on it's own (IE that a store and a\n  // load have the same value, and thus, it isn't clobbering the load).\n  return E;\n}\n\nconst Expression *NewGVN::performSymbolicStoreEvaluation(Instruction *I) const {\n  // Unlike loads, we never try to eliminate stores, so we do not check if they\n  // are simple and avoid value numbering them.\n  auto *SI = cast<StoreInst>(I);\n  auto *StoreAccess = getMemoryAccess(SI);\n  // Get the expression, if any, for the RHS of the MemoryDef.\n  const MemoryAccess *StoreRHS = StoreAccess->getDefiningAccess();\n  if (EnableStoreRefinement)\n    StoreRHS = MSSAWalker->getClobberingMemoryAccess(StoreAccess);\n  // If we bypassed the use-def chains, make sure we add a use.\n  StoreRHS = lookupMemoryLeader(StoreRHS);\n  if (StoreRHS != StoreAccess->getDefiningAccess())\n    addMemoryUsers(StoreRHS, StoreAccess);\n  // If we are defined by ourselves, use the live on entry def.\n  if (StoreRHS == StoreAccess)\n    StoreRHS = MSSA->getLiveOnEntryDef();\n\n  if (SI->isSimple()) {\n    // See if we are defined by a previous store expression, it already has a\n    // value, and it's the same value as our current store. FIXME: Right now, we\n    // only do this for simple stores, we should expand to cover memcpys, etc.\n    const auto *LastStore = createStoreExpression(SI, StoreRHS);\n    const auto *LastCC = ExpressionToClass.lookup(LastStore);\n    // We really want to check whether the expression we matched was a store. No\n    // easy way to do that. However, we can check that the class we found has a\n    // store, which, assuming the value numbering state is not corrupt, is\n    // sufficient, because we must also be equivalent to that store's expression\n    // for it to be in the same class as the load.\n    if (LastCC && LastCC->getStoredValue() == LastStore->getStoredValue())\n      return LastStore;\n    // Also check if our value operand is defined by a load of the same memory\n    // location, and the memory state is the same as it was then (otherwise, it\n    // could have been overwritten later. See test32 in\n    // transforms/DeadStoreElimination/simple.ll).\n    if (auto *LI = dyn_cast<LoadInst>(LastStore->getStoredValue()))\n      if ((lookupOperandLeader(LI->getPointerOperand()) ==\n           LastStore->getOperand(0)) &&\n          (lookupMemoryLeader(getMemoryAccess(LI)->getDefiningAccess()) ==\n           StoreRHS))\n        return LastStore;\n    deleteExpression(LastStore);\n  }\n\n  // If the store is not equivalent to anything, value number it as a store that\n  // produces a unique memory state (instead of using it's MemoryUse, we use\n  // it's MemoryDef).\n  return createStoreExpression(SI, StoreAccess);\n}\n\n// See if we can extract the value of a loaded pointer from a load, a store, or\n// a memory instruction.\nconst Expression *\nNewGVN::performSymbolicLoadCoercion(Type *LoadType, Value *LoadPtr,\n                                    LoadInst *LI, Instruction *DepInst,\n                                    MemoryAccess *DefiningAccess) const {\n  assert((!LI || LI->isSimple()) && \"Not a simple load\");\n  if (auto *DepSI = dyn_cast<StoreInst>(DepInst)) {\n    // Can't forward from non-atomic to atomic without violating memory model.\n    // Also don't need to coerce if they are the same type, we will just\n    // propagate.\n    if (LI->isAtomic() > DepSI->isAtomic() ||\n        LoadType == DepSI->getValueOperand()->getType())\n      return nullptr;\n    int Offset = analyzeLoadFromClobberingStore(LoadType, LoadPtr, DepSI, DL);\n    if (Offset >= 0) {\n      if (auto *C = dyn_cast<Constant>(\n              lookupOperandLeader(DepSI->getValueOperand()))) {\n        LLVM_DEBUG(dbgs() << \"Coercing load from store \" << *DepSI\n                          << \" to constant \" << *C << \"\\n\");\n        return createConstantExpression(\n            getConstantStoreValueForLoad(C, Offset, LoadType, DL));\n      }\n    }\n  } else if (auto *DepLI = dyn_cast<LoadInst>(DepInst)) {\n    // Can't forward from non-atomic to atomic without violating memory model.\n    if (LI->isAtomic() > DepLI->isAtomic())\n      return nullptr;\n    int Offset = analyzeLoadFromClobberingLoad(LoadType, LoadPtr, DepLI, DL);\n    if (Offset >= 0) {\n      // We can coerce a constant load into a load.\n      if (auto *C = dyn_cast<Constant>(lookupOperandLeader(DepLI)))\n        if (auto *PossibleConstant =\n                getConstantLoadValueForLoad(C, Offset, LoadType, DL)) {\n          LLVM_DEBUG(dbgs() << \"Coercing load from load \" << *LI\n                            << \" to constant \" << *PossibleConstant << \"\\n\");\n          return createConstantExpression(PossibleConstant);\n        }\n    }\n  } else if (auto *DepMI = dyn_cast<MemIntrinsic>(DepInst)) {\n    int Offset = analyzeLoadFromClobberingMemInst(LoadType, LoadPtr, DepMI, DL);\n    if (Offset >= 0) {\n      if (auto *PossibleConstant =\n              getConstantMemInstValueForLoad(DepMI, Offset, LoadType, DL)) {\n        LLVM_DEBUG(dbgs() << \"Coercing load from meminst \" << *DepMI\n                          << \" to constant \" << *PossibleConstant << \"\\n\");\n        return createConstantExpression(PossibleConstant);\n      }\n    }\n  }\n\n  // All of the below are only true if the loaded pointer is produced\n  // by the dependent instruction.\n  if (LoadPtr != lookupOperandLeader(DepInst) &&\n      !AA->isMustAlias(LoadPtr, DepInst))\n    return nullptr;\n  // If this load really doesn't depend on anything, then we must be loading an\n  // undef value.  This can happen when loading for a fresh allocation with no\n  // intervening stores, for example.  Note that this is only true in the case\n  // that the result of the allocation is pointer equal to the load ptr.\n  if (isa<AllocaInst>(DepInst) || isMallocLikeFn(DepInst, TLI) ||\n      isAlignedAllocLikeFn(DepInst, TLI)) {\n    return createConstantExpression(UndefValue::get(LoadType));\n  }\n  // If this load occurs either right after a lifetime begin,\n  // then the loaded value is undefined.\n  else if (auto *II = dyn_cast<IntrinsicInst>(DepInst)) {\n    if (II->getIntrinsicID() == Intrinsic::lifetime_start)\n      return createConstantExpression(UndefValue::get(LoadType));\n  }\n  // If this load follows a calloc (which zero initializes memory),\n  // then the loaded value is zero\n  else if (isCallocLikeFn(DepInst, TLI)) {\n    return createConstantExpression(Constant::getNullValue(LoadType));\n  }\n\n  return nullptr;\n}\n\nconst Expression *NewGVN::performSymbolicLoadEvaluation(Instruction *I) const {\n  auto *LI = cast<LoadInst>(I);\n\n  // We can eliminate in favor of non-simple loads, but we won't be able to\n  // eliminate the loads themselves.\n  if (!LI->isSimple())\n    return nullptr;\n\n  Value *LoadAddressLeader = lookupOperandLeader(LI->getPointerOperand());\n  // Load of undef is undef.\n  if (isa<UndefValue>(LoadAddressLeader))\n    return createConstantExpression(UndefValue::get(LI->getType()));\n  MemoryAccess *OriginalAccess = getMemoryAccess(I);\n  MemoryAccess *DefiningAccess =\n      MSSAWalker->getClobberingMemoryAccess(OriginalAccess);\n\n  if (!MSSA->isLiveOnEntryDef(DefiningAccess)) {\n    if (auto *MD = dyn_cast<MemoryDef>(DefiningAccess)) {\n      Instruction *DefiningInst = MD->getMemoryInst();\n      // If the defining instruction is not reachable, replace with undef.\n      if (!ReachableBlocks.count(DefiningInst->getParent()))\n        return createConstantExpression(UndefValue::get(LI->getType()));\n      // This will handle stores and memory insts.  We only do if it the\n      // defining access has a different type, or it is a pointer produced by\n      // certain memory operations that cause the memory to have a fixed value\n      // (IE things like calloc).\n      if (const auto *CoercionResult =\n              performSymbolicLoadCoercion(LI->getType(), LoadAddressLeader, LI,\n                                          DefiningInst, DefiningAccess))\n        return CoercionResult;\n    }\n  }\n\n  const auto *LE = createLoadExpression(LI->getType(), LoadAddressLeader, LI,\n                                        DefiningAccess);\n  // If our MemoryLeader is not our defining access, add a use to the\n  // MemoryLeader, so that we get reprocessed when it changes.\n  if (LE->getMemoryLeader() != DefiningAccess)\n    addMemoryUsers(LE->getMemoryLeader(), OriginalAccess);\n  return LE;\n}\n\nconst Expression *\nNewGVN::performSymbolicPredicateInfoEvaluation(Instruction *I) const {\n  auto *PI = PredInfo->getPredicateInfoFor(I);\n  if (!PI)\n    return nullptr;\n\n  LLVM_DEBUG(dbgs() << \"Found predicate info from instruction !\\n\");\n\n  const Optional<PredicateConstraint> &Constraint = PI->getConstraint();\n  if (!Constraint)\n    return nullptr;\n\n  CmpInst::Predicate Predicate = Constraint->Predicate;\n  Value *CmpOp0 = I->getOperand(0);\n  Value *CmpOp1 = Constraint->OtherOp;\n\n  Value *FirstOp = lookupOperandLeader(CmpOp0);\n  Value *SecondOp = lookupOperandLeader(CmpOp1);\n  Value *AdditionallyUsedValue = CmpOp0;\n\n  // Sort the ops.\n  if (shouldSwapOperands(FirstOp, SecondOp)) {\n    std::swap(FirstOp, SecondOp);\n    Predicate = CmpInst::getSwappedPredicate(Predicate);\n    AdditionallyUsedValue = CmpOp1;\n  }\n\n  if (Predicate == CmpInst::ICMP_EQ) {\n    addPredicateUsers(PI, I);\n    addAdditionalUsers(AdditionallyUsedValue, I);\n    return createVariableOrConstant(FirstOp);\n  }\n\n  // Handle the special case of floating point.\n  if (Predicate == CmpInst::FCMP_OEQ && isa<ConstantFP>(FirstOp) &&\n      !cast<ConstantFP>(FirstOp)->isZero()) {\n    addPredicateUsers(PI, I);\n    addAdditionalUsers(AdditionallyUsedValue, I);\n    return createConstantExpression(cast<Constant>(FirstOp));\n  }\n\n  return nullptr;\n}\n\n// Evaluate read only and pure calls, and create an expression result.\nconst Expression *NewGVN::performSymbolicCallEvaluation(Instruction *I) const {\n  auto *CI = cast<CallInst>(I);\n  if (auto *II = dyn_cast<IntrinsicInst>(I)) {\n    // Intrinsics with the returned attribute are copies of arguments.\n    if (auto *ReturnedValue = II->getReturnedArgOperand()) {\n      if (II->getIntrinsicID() == Intrinsic::ssa_copy)\n        if (const auto *Result = performSymbolicPredicateInfoEvaluation(I))\n          return Result;\n      return createVariableOrConstant(ReturnedValue);\n    }\n  }\n  if (AA->doesNotAccessMemory(CI)) {\n    return createCallExpression(CI, TOPClass->getMemoryLeader());\n  } else if (AA->onlyReadsMemory(CI)) {\n    if (auto *MA = MSSA->getMemoryAccess(CI)) {\n      auto *DefiningAccess = MSSAWalker->getClobberingMemoryAccess(MA);\n      return createCallExpression(CI, DefiningAccess);\n    } else // MSSA determined that CI does not access memory.\n      return createCallExpression(CI, TOPClass->getMemoryLeader());\n  }\n  return nullptr;\n}\n\n// Retrieve the memory class for a given MemoryAccess.\nCongruenceClass *NewGVN::getMemoryClass(const MemoryAccess *MA) const {\n  auto *Result = MemoryAccessToClass.lookup(MA);\n  assert(Result && \"Should have found memory class\");\n  return Result;\n}\n\n// Update the MemoryAccess equivalence table to say that From is equal to To,\n// and return true if this is different from what already existed in the table.\nbool NewGVN::setMemoryClass(const MemoryAccess *From,\n                            CongruenceClass *NewClass) {\n  assert(NewClass &&\n         \"Every MemoryAccess should be getting mapped to a non-null class\");\n  LLVM_DEBUG(dbgs() << \"Setting \" << *From);\n  LLVM_DEBUG(dbgs() << \" equivalent to congruence class \");\n  LLVM_DEBUG(dbgs() << NewClass->getID()\n                    << \" with current MemoryAccess leader \");\n  LLVM_DEBUG(dbgs() << *NewClass->getMemoryLeader() << \"\\n\");\n\n  auto LookupResult = MemoryAccessToClass.find(From);\n  bool Changed = false;\n  // If it's already in the table, see if the value changed.\n  if (LookupResult != MemoryAccessToClass.end()) {\n    auto *OldClass = LookupResult->second;\n    if (OldClass != NewClass) {\n      // If this is a phi, we have to handle memory member updates.\n      if (auto *MP = dyn_cast<MemoryPhi>(From)) {\n        OldClass->memory_erase(MP);\n        NewClass->memory_insert(MP);\n        // This may have killed the class if it had no non-memory members\n        if (OldClass->getMemoryLeader() == From) {\n          if (OldClass->definesNoMemory()) {\n            OldClass->setMemoryLeader(nullptr);\n          } else {\n            OldClass->setMemoryLeader(getNextMemoryLeader(OldClass));\n            LLVM_DEBUG(dbgs() << \"Memory class leader change for class \"\n                              << OldClass->getID() << \" to \"\n                              << *OldClass->getMemoryLeader()\n                              << \" due to removal of a memory member \" << *From\n                              << \"\\n\");\n            markMemoryLeaderChangeTouched(OldClass);\n          }\n        }\n      }\n      // It wasn't equivalent before, and now it is.\n      LookupResult->second = NewClass;\n      Changed = true;\n    }\n  }\n\n  return Changed;\n}\n\n// Determine if a instruction is cycle-free.  That means the values in the\n// instruction don't depend on any expressions that can change value as a result\n// of the instruction.  For example, a non-cycle free instruction would be v =\n// phi(0, v+1).\nbool NewGVN::isCycleFree(const Instruction *I) const {\n  // In order to compute cycle-freeness, we do SCC finding on the instruction,\n  // and see what kind of SCC it ends up in.  If it is a singleton, it is\n  // cycle-free.  If it is not in a singleton, it is only cycle free if the\n  // other members are all phi nodes (as they do not compute anything, they are\n  // copies).\n  auto ICS = InstCycleState.lookup(I);\n  if (ICS == ICS_Unknown) {\n    SCCFinder.Start(I);\n    auto &SCC = SCCFinder.getComponentFor(I);\n    // It's cycle free if it's size 1 or the SCC is *only* phi nodes.\n    if (SCC.size() == 1)\n      InstCycleState.insert({I, ICS_CycleFree});\n    else {\n      bool AllPhis = llvm::all_of(SCC, [](const Value *V) {\n        return isa<PHINode>(V) || isCopyOfAPHI(V);\n      });\n      ICS = AllPhis ? ICS_CycleFree : ICS_Cycle;\n      for (auto *Member : SCC)\n        if (auto *MemberPhi = dyn_cast<PHINode>(Member))\n          InstCycleState.insert({MemberPhi, ICS});\n    }\n  }\n  if (ICS == ICS_Cycle)\n    return false;\n  return true;\n}\n\n// Evaluate PHI nodes symbolically and create an expression result.\nconst Expression *\nNewGVN::performSymbolicPHIEvaluation(ArrayRef<ValPair> PHIOps,\n                                     Instruction *I,\n                                     BasicBlock *PHIBlock) const {\n  // True if one of the incoming phi edges is a backedge.\n  bool HasBackedge = false;\n  // All constant tracks the state of whether all the *original* phi operands\n  // This is really shorthand for \"this phi cannot cycle due to forward\n  // change in value of the phi is guaranteed not to later change the value of\n  // the phi. IE it can't be v = phi(undef, v+1)\n  bool OriginalOpsConstant = true;\n  auto *E = cast<PHIExpression>(createPHIExpression(\n      PHIOps, I, PHIBlock, HasBackedge, OriginalOpsConstant));\n  // We match the semantics of SimplifyPhiNode from InstructionSimplify here.\n  // See if all arguments are the same.\n  // We track if any were undef because they need special handling.\n  bool HasUndef = false;\n  auto Filtered = make_filter_range(E->operands(), [&](Value *Arg) {\n    if (isa<UndefValue>(Arg)) {\n      HasUndef = true;\n      return false;\n    }\n    return true;\n  });\n  // If we are left with no operands, it's dead.\n  if (Filtered.empty()) {\n    // If it has undef at this point, it means there are no-non-undef arguments,\n    // and thus, the value of the phi node must be undef.\n    if (HasUndef) {\n      LLVM_DEBUG(\n          dbgs() << \"PHI Node \" << *I\n                 << \" has no non-undef arguments, valuing it as undef\\n\");\n      return createConstantExpression(UndefValue::get(I->getType()));\n    }\n\n    LLVM_DEBUG(dbgs() << \"No arguments of PHI node \" << *I << \" are live\\n\");\n    deleteExpression(E);\n    return createDeadExpression();\n  }\n  Value *AllSameValue = *(Filtered.begin());\n  ++Filtered.begin();\n  // Can't use std::equal here, sadly, because filter.begin moves.\n  if (llvm::all_of(Filtered, [&](Value *Arg) { return Arg == AllSameValue; })) {\n    // In LLVM's non-standard representation of phi nodes, it's possible to have\n    // phi nodes with cycles (IE dependent on other phis that are .... dependent\n    // on the original phi node), especially in weird CFG's where some arguments\n    // are unreachable, or uninitialized along certain paths.  This can cause\n    // infinite loops during evaluation. We work around this by not trying to\n    // really evaluate them independently, but instead using a variable\n    // expression to say if one is equivalent to the other.\n    // We also special case undef, so that if we have an undef, we can't use the\n    // common value unless it dominates the phi block.\n    if (HasUndef) {\n      // If we have undef and at least one other value, this is really a\n      // multivalued phi, and we need to know if it's cycle free in order to\n      // evaluate whether we can ignore the undef.  The other parts of this are\n      // just shortcuts.  If there is no backedge, or all operands are\n      // constants, it also must be cycle free.\n      if (HasBackedge && !OriginalOpsConstant &&\n          !isa<UndefValue>(AllSameValue) && !isCycleFree(I))\n        return E;\n\n      // Only have to check for instructions\n      if (auto *AllSameInst = dyn_cast<Instruction>(AllSameValue))\n        if (!someEquivalentDominates(AllSameInst, I))\n          return E;\n    }\n    // Can't simplify to something that comes later in the iteration.\n    // Otherwise, when and if it changes congruence class, we will never catch\n    // up. We will always be a class behind it.\n    if (isa<Instruction>(AllSameValue) &&\n        InstrToDFSNum(AllSameValue) > InstrToDFSNum(I))\n      return E;\n    NumGVNPhisAllSame++;\n    LLVM_DEBUG(dbgs() << \"Simplified PHI node \" << *I << \" to \" << *AllSameValue\n                      << \"\\n\");\n    deleteExpression(E);\n    return createVariableOrConstant(AllSameValue);\n  }\n  return E;\n}\n\nconst Expression *\nNewGVN::performSymbolicAggrValueEvaluation(Instruction *I) const {\n  if (auto *EI = dyn_cast<ExtractValueInst>(I)) {\n    auto *WO = dyn_cast<WithOverflowInst>(EI->getAggregateOperand());\n    if (WO && EI->getNumIndices() == 1 && *EI->idx_begin() == 0)\n      // EI is an extract from one of our with.overflow intrinsics. Synthesize\n      // a semantically equivalent expression instead of an extract value\n      // expression.\n      return createBinaryExpression(WO->getBinaryOp(), EI->getType(),\n                                    WO->getLHS(), WO->getRHS(), I);\n  }\n\n  return createAggregateValueExpression(I);\n}\n\nconst Expression *NewGVN::performSymbolicCmpEvaluation(Instruction *I) const {\n  assert(isa<CmpInst>(I) && \"Expected a cmp instruction.\");\n\n  auto *CI = cast<CmpInst>(I);\n  // See if our operands are equal to those of a previous predicate, and if so,\n  // if it implies true or false.\n  auto Op0 = lookupOperandLeader(CI->getOperand(0));\n  auto Op1 = lookupOperandLeader(CI->getOperand(1));\n  auto OurPredicate = CI->getPredicate();\n  if (shouldSwapOperands(Op0, Op1)) {\n    std::swap(Op0, Op1);\n    OurPredicate = CI->getSwappedPredicate();\n  }\n\n  // Avoid processing the same info twice.\n  const PredicateBase *LastPredInfo = nullptr;\n  // See if we know something about the comparison itself, like it is the target\n  // of an assume.\n  auto *CmpPI = PredInfo->getPredicateInfoFor(I);\n  if (dyn_cast_or_null<PredicateAssume>(CmpPI))\n    return createConstantExpression(ConstantInt::getTrue(CI->getType()));\n\n  if (Op0 == Op1) {\n    // This condition does not depend on predicates, no need to add users\n    if (CI->isTrueWhenEqual())\n      return createConstantExpression(ConstantInt::getTrue(CI->getType()));\n    else if (CI->isFalseWhenEqual())\n      return createConstantExpression(ConstantInt::getFalse(CI->getType()));\n  }\n\n  // NOTE: Because we are comparing both operands here and below, and using\n  // previous comparisons, we rely on fact that predicateinfo knows to mark\n  // comparisons that use renamed operands as users of the earlier comparisons.\n  // It is *not* enough to just mark predicateinfo renamed operands as users of\n  // the earlier comparisons, because the *other* operand may have changed in a\n  // previous iteration.\n  // Example:\n  // icmp slt %a, %b\n  // %b.0 = ssa.copy(%b)\n  // false branch:\n  // icmp slt %c, %b.0\n\n  // %c and %a may start out equal, and thus, the code below will say the second\n  // %icmp is false.  c may become equal to something else, and in that case the\n  // %second icmp *must* be reexamined, but would not if only the renamed\n  // %operands are considered users of the icmp.\n\n  // *Currently* we only check one level of comparisons back, and only mark one\n  // level back as touched when changes happen.  If you modify this code to look\n  // back farther through comparisons, you *must* mark the appropriate\n  // comparisons as users in PredicateInfo.cpp, or you will cause bugs.  See if\n  // we know something just from the operands themselves\n\n  // See if our operands have predicate info, so that we may be able to derive\n  // something from a previous comparison.\n  for (const auto &Op : CI->operands()) {\n    auto *PI = PredInfo->getPredicateInfoFor(Op);\n    if (const auto *PBranch = dyn_cast_or_null<PredicateBranch>(PI)) {\n      if (PI == LastPredInfo)\n        continue;\n      LastPredInfo = PI;\n      // In phi of ops cases, we may have predicate info that we are evaluating\n      // in a different context.\n      if (!DT->dominates(PBranch->To, getBlockForValue(I)))\n        continue;\n      // TODO: Along the false edge, we may know more things too, like\n      // icmp of\n      // same operands is false.\n      // TODO: We only handle actual comparison conditions below, not\n      // and/or.\n      auto *BranchCond = dyn_cast<CmpInst>(PBranch->Condition);\n      if (!BranchCond)\n        continue;\n      auto *BranchOp0 = lookupOperandLeader(BranchCond->getOperand(0));\n      auto *BranchOp1 = lookupOperandLeader(BranchCond->getOperand(1));\n      auto BranchPredicate = BranchCond->getPredicate();\n      if (shouldSwapOperands(BranchOp0, BranchOp1)) {\n        std::swap(BranchOp0, BranchOp1);\n        BranchPredicate = BranchCond->getSwappedPredicate();\n      }\n      if (BranchOp0 == Op0 && BranchOp1 == Op1) {\n        if (PBranch->TrueEdge) {\n          // If we know the previous predicate is true and we are in the true\n          // edge then we may be implied true or false.\n          if (CmpInst::isImpliedTrueByMatchingCmp(BranchPredicate,\n                                                  OurPredicate)) {\n            addPredicateUsers(PI, I);\n            return createConstantExpression(\n                ConstantInt::getTrue(CI->getType()));\n          }\n\n          if (CmpInst::isImpliedFalseByMatchingCmp(BranchPredicate,\n                                                   OurPredicate)) {\n            addPredicateUsers(PI, I);\n            return createConstantExpression(\n                ConstantInt::getFalse(CI->getType()));\n          }\n        } else {\n          // Just handle the ne and eq cases, where if we have the same\n          // operands, we may know something.\n          if (BranchPredicate == OurPredicate) {\n            addPredicateUsers(PI, I);\n            // Same predicate, same ops,we know it was false, so this is false.\n            return createConstantExpression(\n                ConstantInt::getFalse(CI->getType()));\n          } else if (BranchPredicate ==\n                     CmpInst::getInversePredicate(OurPredicate)) {\n            addPredicateUsers(PI, I);\n            // Inverse predicate, we know the other was false, so this is true.\n            return createConstantExpression(\n                ConstantInt::getTrue(CI->getType()));\n          }\n        }\n      }\n    }\n  }\n  // Create expression will take care of simplifyCmpInst\n  return createExpression(I);\n}\n\n// Substitute and symbolize the value before value numbering.\nconst Expression *\nNewGVN::performSymbolicEvaluation(Value *V,\n                                  SmallPtrSetImpl<Value *> &Visited) const {\n  const Expression *E = nullptr;\n  if (auto *C = dyn_cast<Constant>(V))\n    E = createConstantExpression(C);\n  else if (isa<Argument>(V) || isa<GlobalVariable>(V)) {\n    E = createVariableExpression(V);\n  } else {\n    // TODO: memory intrinsics.\n    // TODO: Some day, we should do the forward propagation and reassociation\n    // parts of the algorithm.\n    auto *I = cast<Instruction>(V);\n    switch (I->getOpcode()) {\n    case Instruction::ExtractValue:\n    case Instruction::InsertValue:\n      E = performSymbolicAggrValueEvaluation(I);\n      break;\n    case Instruction::PHI: {\n      SmallVector<ValPair, 3> Ops;\n      auto *PN = cast<PHINode>(I);\n      for (unsigned i = 0; i < PN->getNumOperands(); ++i)\n        Ops.push_back({PN->getIncomingValue(i), PN->getIncomingBlock(i)});\n      // Sort to ensure the invariant createPHIExpression requires is met.\n      sortPHIOps(Ops);\n      E = performSymbolicPHIEvaluation(Ops, I, getBlockForValue(I));\n    } break;\n    case Instruction::Call:\n      E = performSymbolicCallEvaluation(I);\n      break;\n    case Instruction::Store:\n      E = performSymbolicStoreEvaluation(I);\n      break;\n    case Instruction::Load:\n      E = performSymbolicLoadEvaluation(I);\n      break;\n    case Instruction::BitCast:\n    case Instruction::AddrSpaceCast:\n      E = createExpression(I);\n      break;\n    case Instruction::ICmp:\n    case Instruction::FCmp:\n      E = performSymbolicCmpEvaluation(I);\n      break;\n    case Instruction::FNeg:\n    case Instruction::Add:\n    case Instruction::FAdd:\n    case Instruction::Sub:\n    case Instruction::FSub:\n    case Instruction::Mul:\n    case Instruction::FMul:\n    case Instruction::UDiv:\n    case Instruction::SDiv:\n    case Instruction::FDiv:\n    case Instruction::URem:\n    case Instruction::SRem:\n    case Instruction::FRem:\n    case Instruction::Shl:\n    case Instruction::LShr:\n    case Instruction::AShr:\n    case Instruction::And:\n    case Instruction::Or:\n    case Instruction::Xor:\n    case Instruction::Trunc:\n    case Instruction::ZExt:\n    case Instruction::SExt:\n    case Instruction::FPToUI:\n    case Instruction::FPToSI:\n    case Instruction::UIToFP:\n    case Instruction::SIToFP:\n    case Instruction::FPTrunc:\n    case Instruction::FPExt:\n    case Instruction::PtrToInt:\n    case Instruction::IntToPtr:\n    case Instruction::Select:\n    case Instruction::ExtractElement:\n    case Instruction::InsertElement:\n    case Instruction::GetElementPtr:\n      E = createExpression(I);\n      break;\n    case Instruction::ShuffleVector:\n      // FIXME: Add support for shufflevector to createExpression.\n      return nullptr;\n    default:\n      return nullptr;\n    }\n  }\n  return E;\n}\n\n// Look up a container of values/instructions in a map, and touch all the\n// instructions in the container.  Then erase value from the map.\ntemplate <typename Map, typename KeyType>\nvoid NewGVN::touchAndErase(Map &M, const KeyType &Key) {\n  const auto Result = M.find_as(Key);\n  if (Result != M.end()) {\n    for (const typename Map::mapped_type::value_type Mapped : Result->second)\n      TouchedInstructions.set(InstrToDFSNum(Mapped));\n    M.erase(Result);\n  }\n}\n\nvoid NewGVN::addAdditionalUsers(Value *To, Value *User) const {\n  assert(User && To != User);\n  if (isa<Instruction>(To))\n    AdditionalUsers[To].insert(User);\n}\n\nvoid NewGVN::markUsersTouched(Value *V) {\n  // Now mark the users as touched.\n  for (auto *User : V->users()) {\n    assert(isa<Instruction>(User) && \"Use of value not within an instruction?\");\n    TouchedInstructions.set(InstrToDFSNum(User));\n  }\n  touchAndErase(AdditionalUsers, V);\n}\n\nvoid NewGVN::addMemoryUsers(const MemoryAccess *To, MemoryAccess *U) const {\n  LLVM_DEBUG(dbgs() << \"Adding memory user \" << *U << \" to \" << *To << \"\\n\");\n  MemoryToUsers[To].insert(U);\n}\n\nvoid NewGVN::markMemoryDefTouched(const MemoryAccess *MA) {\n  TouchedInstructions.set(MemoryToDFSNum(MA));\n}\n\nvoid NewGVN::markMemoryUsersTouched(const MemoryAccess *MA) {\n  if (isa<MemoryUse>(MA))\n    return;\n  for (auto U : MA->users())\n    TouchedInstructions.set(MemoryToDFSNum(U));\n  touchAndErase(MemoryToUsers, MA);\n}\n\n// Add I to the set of users of a given predicate.\nvoid NewGVN::addPredicateUsers(const PredicateBase *PB, Instruction *I) const {\n  // Don't add temporary instructions to the user lists.\n  if (AllTempInstructions.count(I))\n    return;\n\n  if (auto *PBranch = dyn_cast<PredicateBranch>(PB))\n    PredicateToUsers[PBranch->Condition].insert(I);\n  else if (auto *PAssume = dyn_cast<PredicateAssume>(PB))\n    PredicateToUsers[PAssume->Condition].insert(I);\n}\n\n// Touch all the predicates that depend on this instruction.\nvoid NewGVN::markPredicateUsersTouched(Instruction *I) {\n  touchAndErase(PredicateToUsers, I);\n}\n\n// Mark users affected by a memory leader change.\nvoid NewGVN::markMemoryLeaderChangeTouched(CongruenceClass *CC) {\n  for (auto M : CC->memory())\n    markMemoryDefTouched(M);\n}\n\n// Touch the instructions that need to be updated after a congruence class has a\n// leader change, and mark changed values.\nvoid NewGVN::markValueLeaderChangeTouched(CongruenceClass *CC) {\n  for (auto M : *CC) {\n    if (auto *I = dyn_cast<Instruction>(M))\n      TouchedInstructions.set(InstrToDFSNum(I));\n    LeaderChanges.insert(M);\n  }\n}\n\n// Give a range of things that have instruction DFS numbers, this will return\n// the member of the range with the smallest dfs number.\ntemplate <class T, class Range>\nT *NewGVN::getMinDFSOfRange(const Range &R) const {\n  std::pair<T *, unsigned> MinDFS = {nullptr, ~0U};\n  for (const auto X : R) {\n    auto DFSNum = InstrToDFSNum(X);\n    if (DFSNum < MinDFS.second)\n      MinDFS = {X, DFSNum};\n  }\n  return MinDFS.first;\n}\n\n// This function returns the MemoryAccess that should be the next leader of\n// congruence class CC, under the assumption that the current leader is going to\n// disappear.\nconst MemoryAccess *NewGVN::getNextMemoryLeader(CongruenceClass *CC) const {\n  // TODO: If this ends up to slow, we can maintain a next memory leader like we\n  // do for regular leaders.\n  // Make sure there will be a leader to find.\n  assert(!CC->definesNoMemory() && \"Can't get next leader if there is none\");\n  if (CC->getStoreCount() > 0) {\n    if (auto *NL = dyn_cast_or_null<StoreInst>(CC->getNextLeader().first))\n      return getMemoryAccess(NL);\n    // Find the store with the minimum DFS number.\n    auto *V = getMinDFSOfRange<Value>(make_filter_range(\n        *CC, [&](const Value *V) { return isa<StoreInst>(V); }));\n    return getMemoryAccess(cast<StoreInst>(V));\n  }\n  assert(CC->getStoreCount() == 0);\n\n  // Given our assertion, hitting this part must mean\n  // !OldClass->memory_empty()\n  if (CC->memory_size() == 1)\n    return *CC->memory_begin();\n  return getMinDFSOfRange<const MemoryPhi>(CC->memory());\n}\n\n// This function returns the next value leader of a congruence class, under the\n// assumption that the current leader is going away.  This should end up being\n// the next most dominating member.\nValue *NewGVN::getNextValueLeader(CongruenceClass *CC) const {\n  // We don't need to sort members if there is only 1, and we don't care about\n  // sorting the TOP class because everything either gets out of it or is\n  // unreachable.\n\n  if (CC->size() == 1 || CC == TOPClass) {\n    return *(CC->begin());\n  } else if (CC->getNextLeader().first) {\n    ++NumGVNAvoidedSortedLeaderChanges;\n    return CC->getNextLeader().first;\n  } else {\n    ++NumGVNSortedLeaderChanges;\n    // NOTE: If this ends up to slow, we can maintain a dual structure for\n    // member testing/insertion, or keep things mostly sorted, and sort only\n    // here, or use SparseBitVector or ....\n    return getMinDFSOfRange<Value>(*CC);\n  }\n}\n\n// Move a MemoryAccess, currently in OldClass, to NewClass, including updates to\n// the memory members, etc for the move.\n//\n// The invariants of this function are:\n//\n// - I must be moving to NewClass from OldClass\n// - The StoreCount of OldClass and NewClass is expected to have been updated\n//   for I already if it is a store.\n// - The OldClass memory leader has not been updated yet if I was the leader.\nvoid NewGVN::moveMemoryToNewCongruenceClass(Instruction *I,\n                                            MemoryAccess *InstMA,\n                                            CongruenceClass *OldClass,\n                                            CongruenceClass *NewClass) {\n  // If the leader is I, and we had a representative MemoryAccess, it should\n  // be the MemoryAccess of OldClass.\n  assert((!InstMA || !OldClass->getMemoryLeader() ||\n          OldClass->getLeader() != I ||\n          MemoryAccessToClass.lookup(OldClass->getMemoryLeader()) ==\n              MemoryAccessToClass.lookup(InstMA)) &&\n         \"Representative MemoryAccess mismatch\");\n  // First, see what happens to the new class\n  if (!NewClass->getMemoryLeader()) {\n    // Should be a new class, or a store becoming a leader of a new class.\n    assert(NewClass->size() == 1 ||\n           (isa<StoreInst>(I) && NewClass->getStoreCount() == 1));\n    NewClass->setMemoryLeader(InstMA);\n    // Mark it touched if we didn't just create a singleton\n    LLVM_DEBUG(dbgs() << \"Memory class leader change for class \"\n                      << NewClass->getID()\n                      << \" due to new memory instruction becoming leader\\n\");\n    markMemoryLeaderChangeTouched(NewClass);\n  }\n  setMemoryClass(InstMA, NewClass);\n  // Now, fixup the old class if necessary\n  if (OldClass->getMemoryLeader() == InstMA) {\n    if (!OldClass->definesNoMemory()) {\n      OldClass->setMemoryLeader(getNextMemoryLeader(OldClass));\n      LLVM_DEBUG(dbgs() << \"Memory class leader change for class \"\n                        << OldClass->getID() << \" to \"\n                        << *OldClass->getMemoryLeader()\n                        << \" due to removal of old leader \" << *InstMA << \"\\n\");\n      markMemoryLeaderChangeTouched(OldClass);\n    } else\n      OldClass->setMemoryLeader(nullptr);\n  }\n}\n\n// Move a value, currently in OldClass, to be part of NewClass\n// Update OldClass and NewClass for the move (including changing leaders, etc).\nvoid NewGVN::moveValueToNewCongruenceClass(Instruction *I, const Expression *E,\n                                           CongruenceClass *OldClass,\n                                           CongruenceClass *NewClass) {\n  if (I == OldClass->getNextLeader().first)\n    OldClass->resetNextLeader();\n\n  OldClass->erase(I);\n  NewClass->insert(I);\n\n  if (NewClass->getLeader() != I)\n    NewClass->addPossibleNextLeader({I, InstrToDFSNum(I)});\n  // Handle our special casing of stores.\n  if (auto *SI = dyn_cast<StoreInst>(I)) {\n    OldClass->decStoreCount();\n    // Okay, so when do we want to make a store a leader of a class?\n    // If we have a store defined by an earlier load, we want the earlier load\n    // to lead the class.\n    // If we have a store defined by something else, we want the store to lead\n    // the class so everything else gets the \"something else\" as a value.\n    // If we have a store as the single member of the class, we want the store\n    // as the leader\n    if (NewClass->getStoreCount() == 0 && !NewClass->getStoredValue()) {\n      // If it's a store expression we are using, it means we are not equivalent\n      // to something earlier.\n      if (auto *SE = dyn_cast<StoreExpression>(E)) {\n        NewClass->setStoredValue(SE->getStoredValue());\n        markValueLeaderChangeTouched(NewClass);\n        // Shift the new class leader to be the store\n        LLVM_DEBUG(dbgs() << \"Changing leader of congruence class \"\n                          << NewClass->getID() << \" from \"\n                          << *NewClass->getLeader() << \" to  \" << *SI\n                          << \" because store joined class\\n\");\n        // If we changed the leader, we have to mark it changed because we don't\n        // know what it will do to symbolic evaluation.\n        NewClass->setLeader(SI);\n      }\n      // We rely on the code below handling the MemoryAccess change.\n    }\n    NewClass->incStoreCount();\n  }\n  // True if there is no memory instructions left in a class that had memory\n  // instructions before.\n\n  // If it's not a memory use, set the MemoryAccess equivalence\n  auto *InstMA = dyn_cast_or_null<MemoryDef>(getMemoryAccess(I));\n  if (InstMA)\n    moveMemoryToNewCongruenceClass(I, InstMA, OldClass, NewClass);\n  ValueToClass[I] = NewClass;\n  // See if we destroyed the class or need to swap leaders.\n  if (OldClass->empty() && OldClass != TOPClass) {\n    if (OldClass->getDefiningExpr()) {\n      LLVM_DEBUG(dbgs() << \"Erasing expression \" << *OldClass->getDefiningExpr()\n                        << \" from table\\n\");\n      // We erase it as an exact expression to make sure we don't just erase an\n      // equivalent one.\n      auto Iter = ExpressionToClass.find_as(\n          ExactEqualsExpression(*OldClass->getDefiningExpr()));\n      if (Iter != ExpressionToClass.end())\n        ExpressionToClass.erase(Iter);\n#ifdef EXPENSIVE_CHECKS\n      assert(\n          (*OldClass->getDefiningExpr() != *E || ExpressionToClass.lookup(E)) &&\n          \"We erased the expression we just inserted, which should not happen\");\n#endif\n    }\n  } else if (OldClass->getLeader() == I) {\n    // When the leader changes, the value numbering of\n    // everything may change due to symbolization changes, so we need to\n    // reprocess.\n    LLVM_DEBUG(dbgs() << \"Value class leader change for class \"\n                      << OldClass->getID() << \"\\n\");\n    ++NumGVNLeaderChanges;\n    // Destroy the stored value if there are no more stores to represent it.\n    // Note that this is basically clean up for the expression removal that\n    // happens below.  If we remove stores from a class, we may leave it as a\n    // class of equivalent memory phis.\n    if (OldClass->getStoreCount() == 0) {\n      if (OldClass->getStoredValue())\n        OldClass->setStoredValue(nullptr);\n    }\n    OldClass->setLeader(getNextValueLeader(OldClass));\n    OldClass->resetNextLeader();\n    markValueLeaderChangeTouched(OldClass);\n  }\n}\n\n// For a given expression, mark the phi of ops instructions that could have\n// changed as a result.\nvoid NewGVN::markPhiOfOpsChanged(const Expression *E) {\n  touchAndErase(ExpressionToPhiOfOps, E);\n}\n\n// Perform congruence finding on a given value numbering expression.\nvoid NewGVN::performCongruenceFinding(Instruction *I, const Expression *E) {\n  // This is guaranteed to return something, since it will at least find\n  // TOP.\n\n  CongruenceClass *IClass = ValueToClass.lookup(I);\n  assert(IClass && \"Should have found a IClass\");\n  // Dead classes should have been eliminated from the mapping.\n  assert(!IClass->isDead() && \"Found a dead class\");\n\n  CongruenceClass *EClass = nullptr;\n  if (const auto *VE = dyn_cast<VariableExpression>(E)) {\n    EClass = ValueToClass.lookup(VE->getVariableValue());\n  } else if (isa<DeadExpression>(E)) {\n    EClass = TOPClass;\n  }\n  if (!EClass) {\n    auto lookupResult = ExpressionToClass.insert({E, nullptr});\n\n    // If it's not in the value table, create a new congruence class.\n    if (lookupResult.second) {\n      CongruenceClass *NewClass = createCongruenceClass(nullptr, E);\n      auto place = lookupResult.first;\n      place->second = NewClass;\n\n      // Constants and variables should always be made the leader.\n      if (const auto *CE = dyn_cast<ConstantExpression>(E)) {\n        NewClass->setLeader(CE->getConstantValue());\n      } else if (const auto *SE = dyn_cast<StoreExpression>(E)) {\n        StoreInst *SI = SE->getStoreInst();\n        NewClass->setLeader(SI);\n        NewClass->setStoredValue(SE->getStoredValue());\n        // The RepMemoryAccess field will be filled in properly by the\n        // moveValueToNewCongruenceClass call.\n      } else {\n        NewClass->setLeader(I);\n      }\n      assert(!isa<VariableExpression>(E) &&\n             \"VariableExpression should have been handled already\");\n\n      EClass = NewClass;\n      LLVM_DEBUG(dbgs() << \"Created new congruence class for \" << *I\n                        << \" using expression \" << *E << \" at \"\n                        << NewClass->getID() << \" and leader \"\n                        << *(NewClass->getLeader()));\n      if (NewClass->getStoredValue())\n        LLVM_DEBUG(dbgs() << \" and stored value \"\n                          << *(NewClass->getStoredValue()));\n      LLVM_DEBUG(dbgs() << \"\\n\");\n    } else {\n      EClass = lookupResult.first->second;\n      if (isa<ConstantExpression>(E))\n        assert((isa<Constant>(EClass->getLeader()) ||\n                (EClass->getStoredValue() &&\n                 isa<Constant>(EClass->getStoredValue()))) &&\n               \"Any class with a constant expression should have a \"\n               \"constant leader\");\n\n      assert(EClass && \"Somehow don't have an eclass\");\n\n      assert(!EClass->isDead() && \"We accidentally looked up a dead class\");\n    }\n  }\n  bool ClassChanged = IClass != EClass;\n  bool LeaderChanged = LeaderChanges.erase(I);\n  if (ClassChanged || LeaderChanged) {\n    LLVM_DEBUG(dbgs() << \"New class \" << EClass->getID() << \" for expression \"\n                      << *E << \"\\n\");\n    if (ClassChanged) {\n      moveValueToNewCongruenceClass(I, E, IClass, EClass);\n      markPhiOfOpsChanged(E);\n    }\n\n    markUsersTouched(I);\n    if (MemoryAccess *MA = getMemoryAccess(I))\n      markMemoryUsersTouched(MA);\n    if (auto *CI = dyn_cast<CmpInst>(I))\n      markPredicateUsersTouched(CI);\n  }\n  // If we changed the class of the store, we want to ensure nothing finds the\n  // old store expression.  In particular, loads do not compare against stored\n  // value, so they will find old store expressions (and associated class\n  // mappings) if we leave them in the table.\n  if (ClassChanged && isa<StoreInst>(I)) {\n    auto *OldE = ValueToExpression.lookup(I);\n    // It could just be that the old class died. We don't want to erase it if we\n    // just moved classes.\n    if (OldE && isa<StoreExpression>(OldE) && *E != *OldE) {\n      // Erase this as an exact expression to ensure we don't erase expressions\n      // equivalent to it.\n      auto Iter = ExpressionToClass.find_as(ExactEqualsExpression(*OldE));\n      if (Iter != ExpressionToClass.end())\n        ExpressionToClass.erase(Iter);\n    }\n  }\n  ValueToExpression[I] = E;\n}\n\n// Process the fact that Edge (from, to) is reachable, including marking\n// any newly reachable blocks and instructions for processing.\nvoid NewGVN::updateReachableEdge(BasicBlock *From, BasicBlock *To) {\n  // Check if the Edge was reachable before.\n  if (ReachableEdges.insert({From, To}).second) {\n    // If this block wasn't reachable before, all instructions are touched.\n    if (ReachableBlocks.insert(To).second) {\n      LLVM_DEBUG(dbgs() << \"Block \" << getBlockName(To)\n                        << \" marked reachable\\n\");\n      const auto &InstRange = BlockInstRange.lookup(To);\n      TouchedInstructions.set(InstRange.first, InstRange.second);\n    } else {\n      LLVM_DEBUG(dbgs() << \"Block \" << getBlockName(To)\n                        << \" was reachable, but new edge {\"\n                        << getBlockName(From) << \",\" << getBlockName(To)\n                        << \"} to it found\\n\");\n\n      // We've made an edge reachable to an existing block, which may\n      // impact predicates. Otherwise, only mark the phi nodes as touched, as\n      // they are the only thing that depend on new edges. Anything using their\n      // values will get propagated to if necessary.\n      if (MemoryAccess *MemPhi = getMemoryAccess(To))\n        TouchedInstructions.set(InstrToDFSNum(MemPhi));\n\n      // FIXME: We should just add a union op on a Bitvector and\n      // SparseBitVector.  We can do it word by word faster than we are doing it\n      // here.\n      for (auto InstNum : RevisitOnReachabilityChange[To])\n        TouchedInstructions.set(InstNum);\n    }\n  }\n}\n\n// Given a predicate condition (from a switch, cmp, or whatever) and a block,\n// see if we know some constant value for it already.\nValue *NewGVN::findConditionEquivalence(Value *Cond) const {\n  auto Result = lookupOperandLeader(Cond);\n  return isa<Constant>(Result) ? Result : nullptr;\n}\n\n// Process the outgoing edges of a block for reachability.\nvoid NewGVN::processOutgoingEdges(Instruction *TI, BasicBlock *B) {\n  // Evaluate reachability of terminator instruction.\n  Value *Cond;\n  BasicBlock *TrueSucc, *FalseSucc;\n  if (match(TI, m_Br(m_Value(Cond), TrueSucc, FalseSucc))) {\n    Value *CondEvaluated = findConditionEquivalence(Cond);\n    if (!CondEvaluated) {\n      if (auto *I = dyn_cast<Instruction>(Cond)) {\n        const Expression *E = createExpression(I);\n        if (const auto *CE = dyn_cast<ConstantExpression>(E)) {\n          CondEvaluated = CE->getConstantValue();\n        }\n      } else if (isa<ConstantInt>(Cond)) {\n        CondEvaluated = Cond;\n      }\n    }\n    ConstantInt *CI;\n    if (CondEvaluated && (CI = dyn_cast<ConstantInt>(CondEvaluated))) {\n      if (CI->isOne()) {\n        LLVM_DEBUG(dbgs() << \"Condition for Terminator \" << *TI\n                          << \" evaluated to true\\n\");\n        updateReachableEdge(B, TrueSucc);\n      } else if (CI->isZero()) {\n        LLVM_DEBUG(dbgs() << \"Condition for Terminator \" << *TI\n                          << \" evaluated to false\\n\");\n        updateReachableEdge(B, FalseSucc);\n      }\n    } else {\n      updateReachableEdge(B, TrueSucc);\n      updateReachableEdge(B, FalseSucc);\n    }\n  } else if (auto *SI = dyn_cast<SwitchInst>(TI)) {\n    // For switches, propagate the case values into the case\n    // destinations.\n\n    Value *SwitchCond = SI->getCondition();\n    Value *CondEvaluated = findConditionEquivalence(SwitchCond);\n    // See if we were able to turn this switch statement into a constant.\n    if (CondEvaluated && isa<ConstantInt>(CondEvaluated)) {\n      auto *CondVal = cast<ConstantInt>(CondEvaluated);\n      // We should be able to get case value for this.\n      auto Case = *SI->findCaseValue(CondVal);\n      if (Case.getCaseSuccessor() == SI->getDefaultDest()) {\n        // We proved the value is outside of the range of the case.\n        // We can't do anything other than mark the default dest as reachable,\n        // and go home.\n        updateReachableEdge(B, SI->getDefaultDest());\n        return;\n      }\n      // Now get where it goes and mark it reachable.\n      BasicBlock *TargetBlock = Case.getCaseSuccessor();\n      updateReachableEdge(B, TargetBlock);\n    } else {\n      for (unsigned i = 0, e = SI->getNumSuccessors(); i != e; ++i) {\n        BasicBlock *TargetBlock = SI->getSuccessor(i);\n        updateReachableEdge(B, TargetBlock);\n      }\n    }\n  } else {\n    // Otherwise this is either unconditional, or a type we have no\n    // idea about. Just mark successors as reachable.\n    for (unsigned i = 0, e = TI->getNumSuccessors(); i != e; ++i) {\n      BasicBlock *TargetBlock = TI->getSuccessor(i);\n      updateReachableEdge(B, TargetBlock);\n    }\n\n    // This also may be a memory defining terminator, in which case, set it\n    // equivalent only to itself.\n    //\n    auto *MA = getMemoryAccess(TI);\n    if (MA && !isa<MemoryUse>(MA)) {\n      auto *CC = ensureLeaderOfMemoryClass(MA);\n      if (setMemoryClass(MA, CC))\n        markMemoryUsersTouched(MA);\n    }\n  }\n}\n\n// Remove the PHI of Ops PHI for I\nvoid NewGVN::removePhiOfOps(Instruction *I, PHINode *PHITemp) {\n  InstrDFS.erase(PHITemp);\n  // It's still a temp instruction. We keep it in the array so it gets erased.\n  // However, it's no longer used by I, or in the block\n  TempToBlock.erase(PHITemp);\n  RealToTemp.erase(I);\n  // We don't remove the users from the phi node uses. This wastes a little\n  // time, but such is life.  We could use two sets to track which were there\n  // are the start of NewGVN, and which were added, but right nowt he cost of\n  // tracking is more than the cost of checking for more phi of ops.\n}\n\n// Add PHI Op in BB as a PHI of operations version of ExistingValue.\nvoid NewGVN::addPhiOfOps(PHINode *Op, BasicBlock *BB,\n                         Instruction *ExistingValue) {\n  InstrDFS[Op] = InstrToDFSNum(ExistingValue);\n  AllTempInstructions.insert(Op);\n  TempToBlock[Op] = BB;\n  RealToTemp[ExistingValue] = Op;\n  // Add all users to phi node use, as they are now uses of the phi of ops phis\n  // and may themselves be phi of ops.\n  for (auto *U : ExistingValue->users())\n    if (auto *UI = dyn_cast<Instruction>(U))\n      PHINodeUses.insert(UI);\n}\n\nstatic bool okayForPHIOfOps(const Instruction *I) {\n  if (!EnablePhiOfOps)\n    return false;\n  return isa<BinaryOperator>(I) || isa<SelectInst>(I) || isa<CmpInst>(I) ||\n         isa<LoadInst>(I);\n}\n\nbool NewGVN::OpIsSafeForPHIOfOpsHelper(\n    Value *V, const BasicBlock *PHIBlock,\n    SmallPtrSetImpl<const Value *> &Visited,\n    SmallVectorImpl<Instruction *> &Worklist) {\n\n  if (!isa<Instruction>(V))\n    return true;\n  auto OISIt = OpSafeForPHIOfOps.find(V);\n  if (OISIt != OpSafeForPHIOfOps.end())\n    return OISIt->second;\n\n  // Keep walking until we either dominate the phi block, or hit a phi, or run\n  // out of things to check.\n  if (DT->properlyDominates(getBlockForValue(V), PHIBlock)) {\n    OpSafeForPHIOfOps.insert({V, true});\n    return true;\n  }\n  // PHI in the same block.\n  if (isa<PHINode>(V) && getBlockForValue(V) == PHIBlock) {\n    OpSafeForPHIOfOps.insert({V, false});\n    return false;\n  }\n\n  auto *OrigI = cast<Instruction>(V);\n  for (auto *Op : OrigI->operand_values()) {\n    if (!isa<Instruction>(Op))\n      continue;\n    // Stop now if we find an unsafe operand.\n    auto OISIt = OpSafeForPHIOfOps.find(OrigI);\n    if (OISIt != OpSafeForPHIOfOps.end()) {\n      if (!OISIt->second) {\n        OpSafeForPHIOfOps.insert({V, false});\n        return false;\n      }\n      continue;\n    }\n    if (!Visited.insert(Op).second)\n      continue;\n    Worklist.push_back(cast<Instruction>(Op));\n  }\n  return true;\n}\n\n// Return true if this operand will be safe to use for phi of ops.\n//\n// The reason some operands are unsafe is that we are not trying to recursively\n// translate everything back through phi nodes.  We actually expect some lookups\n// of expressions to fail.  In particular, a lookup where the expression cannot\n// exist in the predecessor.  This is true even if the expression, as shown, can\n// be determined to be constant.\nbool NewGVN::OpIsSafeForPHIOfOps(Value *V, const BasicBlock *PHIBlock,\n                                 SmallPtrSetImpl<const Value *> &Visited) {\n  SmallVector<Instruction *, 4> Worklist;\n  if (!OpIsSafeForPHIOfOpsHelper(V, PHIBlock, Visited, Worklist))\n    return false;\n  while (!Worklist.empty()) {\n    auto *I = Worklist.pop_back_val();\n    if (!OpIsSafeForPHIOfOpsHelper(I, PHIBlock, Visited, Worklist))\n      return false;\n  }\n  OpSafeForPHIOfOps.insert({V, true});\n  return true;\n}\n\n// Try to find a leader for instruction TransInst, which is a phi translated\n// version of something in our original program.  Visited is used to ensure we\n// don't infinite loop during translations of cycles.  OrigInst is the\n// instruction in the original program, and PredBB is the predecessor we\n// translated it through.\nValue *NewGVN::findLeaderForInst(Instruction *TransInst,\n                                 SmallPtrSetImpl<Value *> &Visited,\n                                 MemoryAccess *MemAccess, Instruction *OrigInst,\n                                 BasicBlock *PredBB) {\n  unsigned IDFSNum = InstrToDFSNum(OrigInst);\n  // Make sure it's marked as a temporary instruction.\n  AllTempInstructions.insert(TransInst);\n  // and make sure anything that tries to add it's DFS number is\n  // redirected to the instruction we are making a phi of ops\n  // for.\n  TempToBlock.insert({TransInst, PredBB});\n  InstrDFS.insert({TransInst, IDFSNum});\n\n  const Expression *E = performSymbolicEvaluation(TransInst, Visited);\n  InstrDFS.erase(TransInst);\n  AllTempInstructions.erase(TransInst);\n  TempToBlock.erase(TransInst);\n  if (MemAccess)\n    TempToMemory.erase(TransInst);\n  if (!E)\n    return nullptr;\n  auto *FoundVal = findPHIOfOpsLeader(E, OrigInst, PredBB);\n  if (!FoundVal) {\n    ExpressionToPhiOfOps[E].insert(OrigInst);\n    LLVM_DEBUG(dbgs() << \"Cannot find phi of ops operand for \" << *TransInst\n                      << \" in block \" << getBlockName(PredBB) << \"\\n\");\n    return nullptr;\n  }\n  if (auto *SI = dyn_cast<StoreInst>(FoundVal))\n    FoundVal = SI->getValueOperand();\n  return FoundVal;\n}\n\n// When we see an instruction that is an op of phis, generate the equivalent phi\n// of ops form.\nconst Expression *\nNewGVN::makePossiblePHIOfOps(Instruction *I,\n                             SmallPtrSetImpl<Value *> &Visited) {\n  if (!okayForPHIOfOps(I))\n    return nullptr;\n\n  if (!Visited.insert(I).second)\n    return nullptr;\n  // For now, we require the instruction be cycle free because we don't\n  // *always* create a phi of ops for instructions that could be done as phi\n  // of ops, we only do it if we think it is useful.  If we did do it all the\n  // time, we could remove the cycle free check.\n  if (!isCycleFree(I))\n    return nullptr;\n\n  SmallPtrSet<const Value *, 8> ProcessedPHIs;\n  // TODO: We don't do phi translation on memory accesses because it's\n  // complicated. For a load, we'd need to be able to simulate a new memoryuse,\n  // which we don't have a good way of doing ATM.\n  auto *MemAccess = getMemoryAccess(I);\n  // If the memory operation is defined by a memory operation this block that\n  // isn't a MemoryPhi, transforming the pointer backwards through a scalar phi\n  // can't help, as it would still be killed by that memory operation.\n  if (MemAccess && !isa<MemoryPhi>(MemAccess->getDefiningAccess()) &&\n      MemAccess->getDefiningAccess()->getBlock() == I->getParent())\n    return nullptr;\n\n  // Convert op of phis to phi of ops\n  SmallPtrSet<const Value *, 10> VisitedOps;\n  SmallVector<Value *, 4> Ops(I->operand_values());\n  BasicBlock *SamePHIBlock = nullptr;\n  PHINode *OpPHI = nullptr;\n  if (!DebugCounter::shouldExecute(PHIOfOpsCounter))\n    return nullptr;\n  for (auto *Op : Ops) {\n    if (!isa<PHINode>(Op)) {\n      auto *ValuePHI = RealToTemp.lookup(Op);\n      if (!ValuePHI)\n        continue;\n      LLVM_DEBUG(dbgs() << \"Found possible dependent phi of ops\\n\");\n      Op = ValuePHI;\n    }\n    OpPHI = cast<PHINode>(Op);\n    if (!SamePHIBlock) {\n      SamePHIBlock = getBlockForValue(OpPHI);\n    } else if (SamePHIBlock != getBlockForValue(OpPHI)) {\n      LLVM_DEBUG(\n          dbgs()\n          << \"PHIs for operands are not all in the same block, aborting\\n\");\n      return nullptr;\n    }\n    // No point in doing this for one-operand phis.\n    if (OpPHI->getNumOperands() == 1) {\n      OpPHI = nullptr;\n      continue;\n    }\n  }\n\n  if (!OpPHI)\n    return nullptr;\n\n  SmallVector<ValPair, 4> PHIOps;\n  SmallPtrSet<Value *, 4> Deps;\n  auto *PHIBlock = getBlockForValue(OpPHI);\n  RevisitOnReachabilityChange[PHIBlock].reset(InstrToDFSNum(I));\n  for (unsigned PredNum = 0; PredNum < OpPHI->getNumOperands(); ++PredNum) {\n    auto *PredBB = OpPHI->getIncomingBlock(PredNum);\n    Value *FoundVal = nullptr;\n    SmallPtrSet<Value *, 4> CurrentDeps;\n    // We could just skip unreachable edges entirely but it's tricky to do\n    // with rewriting existing phi nodes.\n    if (ReachableEdges.count({PredBB, PHIBlock})) {\n      // Clone the instruction, create an expression from it that is\n      // translated back into the predecessor, and see if we have a leader.\n      Instruction *ValueOp = I->clone();\n      if (MemAccess)\n        TempToMemory.insert({ValueOp, MemAccess});\n      bool SafeForPHIOfOps = true;\n      VisitedOps.clear();\n      for (auto &Op : ValueOp->operands()) {\n        auto *OrigOp = &*Op;\n        // When these operand changes, it could change whether there is a\n        // leader for us or not, so we have to add additional users.\n        if (isa<PHINode>(Op)) {\n          Op = Op->DoPHITranslation(PHIBlock, PredBB);\n          if (Op != OrigOp && Op != I)\n            CurrentDeps.insert(Op);\n        } else if (auto *ValuePHI = RealToTemp.lookup(Op)) {\n          if (getBlockForValue(ValuePHI) == PHIBlock)\n            Op = ValuePHI->getIncomingValueForBlock(PredBB);\n        }\n        // If we phi-translated the op, it must be safe.\n        SafeForPHIOfOps =\n            SafeForPHIOfOps &&\n            (Op != OrigOp || OpIsSafeForPHIOfOps(Op, PHIBlock, VisitedOps));\n      }\n      // FIXME: For those things that are not safe we could generate\n      // expressions all the way down, and see if this comes out to a\n      // constant.  For anything where that is true, and unsafe, we should\n      // have made a phi-of-ops (or value numbered it equivalent to something)\n      // for the pieces already.\n      FoundVal = !SafeForPHIOfOps ? nullptr\n                                  : findLeaderForInst(ValueOp, Visited,\n                                                      MemAccess, I, PredBB);\n      ValueOp->deleteValue();\n      if (!FoundVal) {\n        // We failed to find a leader for the current ValueOp, but this might\n        // change in case of the translated operands change.\n        if (SafeForPHIOfOps)\n          for (auto Dep : CurrentDeps)\n            addAdditionalUsers(Dep, I);\n\n        return nullptr;\n      }\n      Deps.insert(CurrentDeps.begin(), CurrentDeps.end());\n    } else {\n      LLVM_DEBUG(dbgs() << \"Skipping phi of ops operand for incoming block \"\n                        << getBlockName(PredBB)\n                        << \" because the block is unreachable\\n\");\n      FoundVal = UndefValue::get(I->getType());\n      RevisitOnReachabilityChange[PHIBlock].set(InstrToDFSNum(I));\n    }\n\n    PHIOps.push_back({FoundVal, PredBB});\n    LLVM_DEBUG(dbgs() << \"Found phi of ops operand \" << *FoundVal << \" in \"\n                      << getBlockName(PredBB) << \"\\n\");\n  }\n  for (auto Dep : Deps)\n    addAdditionalUsers(Dep, I);\n  sortPHIOps(PHIOps);\n  auto *E = performSymbolicPHIEvaluation(PHIOps, I, PHIBlock);\n  if (isa<ConstantExpression>(E) || isa<VariableExpression>(E)) {\n    LLVM_DEBUG(\n        dbgs()\n        << \"Not creating real PHI of ops because it simplified to existing \"\n           \"value or constant\\n\");\n    return E;\n  }\n  auto *ValuePHI = RealToTemp.lookup(I);\n  bool NewPHI = false;\n  if (!ValuePHI) {\n    ValuePHI =\n        PHINode::Create(I->getType(), OpPHI->getNumOperands(), \"phiofops\");\n    addPhiOfOps(ValuePHI, PHIBlock, I);\n    NewPHI = true;\n    NumGVNPHIOfOpsCreated++;\n  }\n  if (NewPHI) {\n    for (auto PHIOp : PHIOps)\n      ValuePHI->addIncoming(PHIOp.first, PHIOp.second);\n  } else {\n    TempToBlock[ValuePHI] = PHIBlock;\n    unsigned int i = 0;\n    for (auto PHIOp : PHIOps) {\n      ValuePHI->setIncomingValue(i, PHIOp.first);\n      ValuePHI->setIncomingBlock(i, PHIOp.second);\n      ++i;\n    }\n  }\n  RevisitOnReachabilityChange[PHIBlock].set(InstrToDFSNum(I));\n  LLVM_DEBUG(dbgs() << \"Created phi of ops \" << *ValuePHI << \" for \" << *I\n                    << \"\\n\");\n\n  return E;\n}\n\n// The algorithm initially places the values of the routine in the TOP\n// congruence class. The leader of TOP is the undetermined value `undef`.\n// When the algorithm has finished, values still in TOP are unreachable.\nvoid NewGVN::initializeCongruenceClasses(Function &F) {\n  NextCongruenceNum = 0;\n\n  // Note that even though we use the live on entry def as a representative\n  // MemoryAccess, it is *not* the same as the actual live on entry def. We\n  // have no real equivalemnt to undef for MemoryAccesses, and so we really\n  // should be checking whether the MemoryAccess is top if we want to know if it\n  // is equivalent to everything.  Otherwise, what this really signifies is that\n  // the access \"it reaches all the way back to the beginning of the function\"\n\n  // Initialize all other instructions to be in TOP class.\n  TOPClass = createCongruenceClass(nullptr, nullptr);\n  TOPClass->setMemoryLeader(MSSA->getLiveOnEntryDef());\n  //  The live on entry def gets put into it's own class\n  MemoryAccessToClass[MSSA->getLiveOnEntryDef()] =\n      createMemoryClass(MSSA->getLiveOnEntryDef());\n\n  for (auto DTN : nodes(DT)) {\n    BasicBlock *BB = DTN->getBlock();\n    // All MemoryAccesses are equivalent to live on entry to start. They must\n    // be initialized to something so that initial changes are noticed. For\n    // the maximal answer, we initialize them all to be the same as\n    // liveOnEntry.\n    auto *MemoryBlockDefs = MSSA->getBlockDefs(BB);\n    if (MemoryBlockDefs)\n      for (const auto &Def : *MemoryBlockDefs) {\n        MemoryAccessToClass[&Def] = TOPClass;\n        auto *MD = dyn_cast<MemoryDef>(&Def);\n        // Insert the memory phis into the member list.\n        if (!MD) {\n          const MemoryPhi *MP = cast<MemoryPhi>(&Def);\n          TOPClass->memory_insert(MP);\n          MemoryPhiState.insert({MP, MPS_TOP});\n        }\n\n        if (MD && isa<StoreInst>(MD->getMemoryInst()))\n          TOPClass->incStoreCount();\n      }\n\n    // FIXME: This is trying to discover which instructions are uses of phi\n    // nodes.  We should move this into one of the myriad of places that walk\n    // all the operands already.\n    for (auto &I : *BB) {\n      if (isa<PHINode>(&I))\n        for (auto *U : I.users())\n          if (auto *UInst = dyn_cast<Instruction>(U))\n            if (InstrToDFSNum(UInst) != 0 && okayForPHIOfOps(UInst))\n              PHINodeUses.insert(UInst);\n      // Don't insert void terminators into the class. We don't value number\n      // them, and they just end up sitting in TOP.\n      if (I.isTerminator() && I.getType()->isVoidTy())\n        continue;\n      TOPClass->insert(&I);\n      ValueToClass[&I] = TOPClass;\n    }\n  }\n\n  // Initialize arguments to be in their own unique congruence classes\n  for (auto &FA : F.args())\n    createSingletonCongruenceClass(&FA);\n}\n\nvoid NewGVN::cleanupTables() {\n  for (unsigned i = 0, e = CongruenceClasses.size(); i != e; ++i) {\n    LLVM_DEBUG(dbgs() << \"Congruence class \" << CongruenceClasses[i]->getID()\n                      << \" has \" << CongruenceClasses[i]->size()\n                      << \" members\\n\");\n    // Make sure we delete the congruence class (probably worth switching to\n    // a unique_ptr at some point.\n    delete CongruenceClasses[i];\n    CongruenceClasses[i] = nullptr;\n  }\n\n  // Destroy the value expressions\n  SmallVector<Instruction *, 8> TempInst(AllTempInstructions.begin(),\n                                         AllTempInstructions.end());\n  AllTempInstructions.clear();\n\n  // We have to drop all references for everything first, so there are no uses\n  // left as we delete them.\n  for (auto *I : TempInst) {\n    I->dropAllReferences();\n  }\n\n  while (!TempInst.empty()) {\n    auto *I = TempInst.pop_back_val();\n    I->deleteValue();\n  }\n\n  ValueToClass.clear();\n  ArgRecycler.clear(ExpressionAllocator);\n  ExpressionAllocator.Reset();\n  CongruenceClasses.clear();\n  ExpressionToClass.clear();\n  ValueToExpression.clear();\n  RealToTemp.clear();\n  AdditionalUsers.clear();\n  ExpressionToPhiOfOps.clear();\n  TempToBlock.clear();\n  TempToMemory.clear();\n  PHINodeUses.clear();\n  OpSafeForPHIOfOps.clear();\n  ReachableBlocks.clear();\n  ReachableEdges.clear();\n#ifndef NDEBUG\n  ProcessedCount.clear();\n#endif\n  InstrDFS.clear();\n  InstructionsToErase.clear();\n  DFSToInstr.clear();\n  BlockInstRange.clear();\n  TouchedInstructions.clear();\n  MemoryAccessToClass.clear();\n  PredicateToUsers.clear();\n  MemoryToUsers.clear();\n  RevisitOnReachabilityChange.clear();\n}\n\n// Assign local DFS number mapping to instructions, and leave space for Value\n// PHI's.\nstd::pair<unsigned, unsigned> NewGVN::assignDFSNumbers(BasicBlock *B,\n                                                       unsigned Start) {\n  unsigned End = Start;\n  if (MemoryAccess *MemPhi = getMemoryAccess(B)) {\n    InstrDFS[MemPhi] = End++;\n    DFSToInstr.emplace_back(MemPhi);\n  }\n\n  // Then the real block goes next.\n  for (auto &I : *B) {\n    // There's no need to call isInstructionTriviallyDead more than once on\n    // an instruction. Therefore, once we know that an instruction is dead\n    // we change its DFS number so that it doesn't get value numbered.\n    if (isInstructionTriviallyDead(&I, TLI)) {\n      InstrDFS[&I] = 0;\n      LLVM_DEBUG(dbgs() << \"Skipping trivially dead instruction \" << I << \"\\n\");\n      markInstructionForDeletion(&I);\n      continue;\n    }\n    if (isa<PHINode>(&I))\n      RevisitOnReachabilityChange[B].set(End);\n    InstrDFS[&I] = End++;\n    DFSToInstr.emplace_back(&I);\n  }\n\n  // All of the range functions taken half-open ranges (open on the end side).\n  // So we do not subtract one from count, because at this point it is one\n  // greater than the last instruction.\n  return std::make_pair(Start, End);\n}\n\nvoid NewGVN::updateProcessedCount(const Value *V) {\n#ifndef NDEBUG\n  if (ProcessedCount.count(V) == 0) {\n    ProcessedCount.insert({V, 1});\n  } else {\n    ++ProcessedCount[V];\n    assert(ProcessedCount[V] < 100 &&\n           \"Seem to have processed the same Value a lot\");\n  }\n#endif\n}\n\n// Evaluate MemoryPhi nodes symbolically, just like PHI nodes\nvoid NewGVN::valueNumberMemoryPhi(MemoryPhi *MP) {\n  // If all the arguments are the same, the MemoryPhi has the same value as the\n  // argument.  Filter out unreachable blocks and self phis from our operands.\n  // TODO: We could do cycle-checking on the memory phis to allow valueizing for\n  // self-phi checking.\n  const BasicBlock *PHIBlock = MP->getBlock();\n  auto Filtered = make_filter_range(MP->operands(), [&](const Use &U) {\n    return cast<MemoryAccess>(U) != MP &&\n           !isMemoryAccessTOP(cast<MemoryAccess>(U)) &&\n           ReachableEdges.count({MP->getIncomingBlock(U), PHIBlock});\n  });\n  // If all that is left is nothing, our memoryphi is undef. We keep it as\n  // InitialClass.  Note: The only case this should happen is if we have at\n  // least one self-argument.\n  if (Filtered.begin() == Filtered.end()) {\n    if (setMemoryClass(MP, TOPClass))\n      markMemoryUsersTouched(MP);\n    return;\n  }\n\n  // Transform the remaining operands into operand leaders.\n  // FIXME: mapped_iterator should have a range version.\n  auto LookupFunc = [&](const Use &U) {\n    return lookupMemoryLeader(cast<MemoryAccess>(U));\n  };\n  auto MappedBegin = map_iterator(Filtered.begin(), LookupFunc);\n  auto MappedEnd = map_iterator(Filtered.end(), LookupFunc);\n\n  // and now check if all the elements are equal.\n  // Sadly, we can't use std::equals since these are random access iterators.\n  const auto *AllSameValue = *MappedBegin;\n  ++MappedBegin;\n  bool AllEqual = std::all_of(\n      MappedBegin, MappedEnd,\n      [&AllSameValue](const MemoryAccess *V) { return V == AllSameValue; });\n\n  if (AllEqual)\n    LLVM_DEBUG(dbgs() << \"Memory Phi value numbered to \" << *AllSameValue\n                      << \"\\n\");\n  else\n    LLVM_DEBUG(dbgs() << \"Memory Phi value numbered to itself\\n\");\n  // If it's equal to something, it's in that class. Otherwise, it has to be in\n  // a class where it is the leader (other things may be equivalent to it, but\n  // it needs to start off in its own class, which means it must have been the\n  // leader, and it can't have stopped being the leader because it was never\n  // removed).\n  CongruenceClass *CC =\n      AllEqual ? getMemoryClass(AllSameValue) : ensureLeaderOfMemoryClass(MP);\n  auto OldState = MemoryPhiState.lookup(MP);\n  assert(OldState != MPS_Invalid && \"Invalid memory phi state\");\n  auto NewState = AllEqual ? MPS_Equivalent : MPS_Unique;\n  MemoryPhiState[MP] = NewState;\n  if (setMemoryClass(MP, CC) || OldState != NewState)\n    markMemoryUsersTouched(MP);\n}\n\n// Value number a single instruction, symbolically evaluating, performing\n// congruence finding, and updating mappings.\nvoid NewGVN::valueNumberInstruction(Instruction *I) {\n  LLVM_DEBUG(dbgs() << \"Processing instruction \" << *I << \"\\n\");\n  if (!I->isTerminator()) {\n    const Expression *Symbolized = nullptr;\n    SmallPtrSet<Value *, 2> Visited;\n    if (DebugCounter::shouldExecute(VNCounter)) {\n      Symbolized = performSymbolicEvaluation(I, Visited);\n      // Make a phi of ops if necessary\n      if (Symbolized && !isa<ConstantExpression>(Symbolized) &&\n          !isa<VariableExpression>(Symbolized) && PHINodeUses.count(I)) {\n        auto *PHIE = makePossiblePHIOfOps(I, Visited);\n        // If we created a phi of ops, use it.\n        // If we couldn't create one, make sure we don't leave one lying around\n        if (PHIE) {\n          Symbolized = PHIE;\n        } else if (auto *Op = RealToTemp.lookup(I)) {\n          removePhiOfOps(I, Op);\n        }\n      }\n    } else {\n      // Mark the instruction as unused so we don't value number it again.\n      InstrDFS[I] = 0;\n    }\n    // If we couldn't come up with a symbolic expression, use the unknown\n    // expression\n    if (Symbolized == nullptr)\n      Symbolized = createUnknownExpression(I);\n    performCongruenceFinding(I, Symbolized);\n  } else {\n    // Handle terminators that return values. All of them produce values we\n    // don't currently understand.  We don't place non-value producing\n    // terminators in a class.\n    if (!I->getType()->isVoidTy()) {\n      auto *Symbolized = createUnknownExpression(I);\n      performCongruenceFinding(I, Symbolized);\n    }\n    processOutgoingEdges(I, I->getParent());\n  }\n}\n\n// Check if there is a path, using single or equal argument phi nodes, from\n// First to Second.\nbool NewGVN::singleReachablePHIPath(\n    SmallPtrSet<const MemoryAccess *, 8> &Visited, const MemoryAccess *First,\n    const MemoryAccess *Second) const {\n  if (First == Second)\n    return true;\n  if (MSSA->isLiveOnEntryDef(First))\n    return false;\n\n  // This is not perfect, but as we're just verifying here, we can live with\n  // the loss of precision. The real solution would be that of doing strongly\n  // connected component finding in this routine, and it's probably not worth\n  // the complexity for the time being. So, we just keep a set of visited\n  // MemoryAccess and return true when we hit a cycle.\n  if (Visited.count(First))\n    return true;\n  Visited.insert(First);\n\n  const auto *EndDef = First;\n  for (auto *ChainDef : optimized_def_chain(First)) {\n    if (ChainDef == Second)\n      return true;\n    if (MSSA->isLiveOnEntryDef(ChainDef))\n      return false;\n    EndDef = ChainDef;\n  }\n  auto *MP = cast<MemoryPhi>(EndDef);\n  auto ReachableOperandPred = [&](const Use &U) {\n    return ReachableEdges.count({MP->getIncomingBlock(U), MP->getBlock()});\n  };\n  auto FilteredPhiArgs =\n      make_filter_range(MP->operands(), ReachableOperandPred);\n  SmallVector<const Value *, 32> OperandList;\n  llvm::copy(FilteredPhiArgs, std::back_inserter(OperandList));\n  bool Okay = is_splat(OperandList);\n  if (Okay)\n    return singleReachablePHIPath(Visited, cast<MemoryAccess>(OperandList[0]),\n                                  Second);\n  return false;\n}\n\n// Verify the that the memory equivalence table makes sense relative to the\n// congruence classes.  Note that this checking is not perfect, and is currently\n// subject to very rare false negatives. It is only useful for\n// testing/debugging.\nvoid NewGVN::verifyMemoryCongruency() const {\n#ifndef NDEBUG\n  // Verify that the memory table equivalence and memory member set match\n  for (const auto *CC : CongruenceClasses) {\n    if (CC == TOPClass || CC->isDead())\n      continue;\n    if (CC->getStoreCount() != 0) {\n      assert((CC->getStoredValue() || !isa<StoreInst>(CC->getLeader())) &&\n             \"Any class with a store as a leader should have a \"\n             \"representative stored value\");\n      assert(CC->getMemoryLeader() &&\n             \"Any congruence class with a store should have a \"\n             \"representative access\");\n    }\n\n    if (CC->getMemoryLeader())\n      assert(MemoryAccessToClass.lookup(CC->getMemoryLeader()) == CC &&\n             \"Representative MemoryAccess does not appear to be reverse \"\n             \"mapped properly\");\n    for (auto M : CC->memory())\n      assert(MemoryAccessToClass.lookup(M) == CC &&\n             \"Memory member does not appear to be reverse mapped properly\");\n  }\n\n  // Anything equivalent in the MemoryAccess table should be in the same\n  // congruence class.\n\n  // Filter out the unreachable and trivially dead entries, because they may\n  // never have been updated if the instructions were not processed.\n  auto ReachableAccessPred =\n      [&](const std::pair<const MemoryAccess *, CongruenceClass *> Pair) {\n        bool Result = ReachableBlocks.count(Pair.first->getBlock());\n        if (!Result || MSSA->isLiveOnEntryDef(Pair.first) ||\n            MemoryToDFSNum(Pair.first) == 0)\n          return false;\n        if (auto *MemDef = dyn_cast<MemoryDef>(Pair.first))\n          return !isInstructionTriviallyDead(MemDef->getMemoryInst());\n\n        // We could have phi nodes which operands are all trivially dead,\n        // so we don't process them.\n        if (auto *MemPHI = dyn_cast<MemoryPhi>(Pair.first)) {\n          for (auto &U : MemPHI->incoming_values()) {\n            if (auto *I = dyn_cast<Instruction>(&*U)) {\n              if (!isInstructionTriviallyDead(I))\n                return true;\n            }\n          }\n          return false;\n        }\n\n        return true;\n      };\n\n  auto Filtered = make_filter_range(MemoryAccessToClass, ReachableAccessPred);\n  for (auto KV : Filtered) {\n    if (auto *FirstMUD = dyn_cast<MemoryUseOrDef>(KV.first)) {\n      auto *SecondMUD = dyn_cast<MemoryUseOrDef>(KV.second->getMemoryLeader());\n      if (FirstMUD && SecondMUD) {\n        SmallPtrSet<const MemoryAccess *, 8> VisitedMAS;\n        assert((singleReachablePHIPath(VisitedMAS, FirstMUD, SecondMUD) ||\n                ValueToClass.lookup(FirstMUD->getMemoryInst()) ==\n                    ValueToClass.lookup(SecondMUD->getMemoryInst())) &&\n               \"The instructions for these memory operations should have \"\n               \"been in the same congruence class or reachable through\"\n               \"a single argument phi\");\n      }\n    } else if (auto *FirstMP = dyn_cast<MemoryPhi>(KV.first)) {\n      // We can only sanely verify that MemoryDefs in the operand list all have\n      // the same class.\n      auto ReachableOperandPred = [&](const Use &U) {\n        return ReachableEdges.count(\n                   {FirstMP->getIncomingBlock(U), FirstMP->getBlock()}) &&\n               isa<MemoryDef>(U);\n\n      };\n      // All arguments should in the same class, ignoring unreachable arguments\n      auto FilteredPhiArgs =\n          make_filter_range(FirstMP->operands(), ReachableOperandPred);\n      SmallVector<const CongruenceClass *, 16> PhiOpClasses;\n      std::transform(FilteredPhiArgs.begin(), FilteredPhiArgs.end(),\n                     std::back_inserter(PhiOpClasses), [&](const Use &U) {\n                       const MemoryDef *MD = cast<MemoryDef>(U);\n                       return ValueToClass.lookup(MD->getMemoryInst());\n                     });\n      assert(is_splat(PhiOpClasses) &&\n             \"All MemoryPhi arguments should be in the same class\");\n    }\n  }\n#endif\n}\n\n// Verify that the sparse propagation we did actually found the maximal fixpoint\n// We do this by storing the value to class mapping, touching all instructions,\n// and redoing the iteration to see if anything changed.\nvoid NewGVN::verifyIterationSettled(Function &F) {\n#ifndef NDEBUG\n  LLVM_DEBUG(dbgs() << \"Beginning iteration verification\\n\");\n  if (DebugCounter::isCounterSet(VNCounter))\n    DebugCounter::setCounterValue(VNCounter, StartingVNCounter);\n\n  // Note that we have to store the actual classes, as we may change existing\n  // classes during iteration.  This is because our memory iteration propagation\n  // is not perfect, and so may waste a little work.  But it should generate\n  // exactly the same congruence classes we have now, with different IDs.\n  std::map<const Value *, CongruenceClass> BeforeIteration;\n\n  for (auto &KV : ValueToClass) {\n    if (auto *I = dyn_cast<Instruction>(KV.first))\n      // Skip unused/dead instructions.\n      if (InstrToDFSNum(I) == 0)\n        continue;\n    BeforeIteration.insert({KV.first, *KV.second});\n  }\n\n  TouchedInstructions.set();\n  TouchedInstructions.reset(0);\n  iterateTouchedInstructions();\n  DenseSet<std::pair<const CongruenceClass *, const CongruenceClass *>>\n      EqualClasses;\n  for (const auto &KV : ValueToClass) {\n    if (auto *I = dyn_cast<Instruction>(KV.first))\n      // Skip unused/dead instructions.\n      if (InstrToDFSNum(I) == 0)\n        continue;\n    // We could sink these uses, but i think this adds a bit of clarity here as\n    // to what we are comparing.\n    auto *BeforeCC = &BeforeIteration.find(KV.first)->second;\n    auto *AfterCC = KV.second;\n    // Note that the classes can't change at this point, so we memoize the set\n    // that are equal.\n    if (!EqualClasses.count({BeforeCC, AfterCC})) {\n      assert(BeforeCC->isEquivalentTo(AfterCC) &&\n             \"Value number changed after main loop completed!\");\n      EqualClasses.insert({BeforeCC, AfterCC});\n    }\n  }\n#endif\n}\n\n// Verify that for each store expression in the expression to class mapping,\n// only the latest appears, and multiple ones do not appear.\n// Because loads do not use the stored value when doing equality with stores,\n// if we don't erase the old store expressions from the table, a load can find\n// a no-longer valid StoreExpression.\nvoid NewGVN::verifyStoreExpressions() const {\n#ifndef NDEBUG\n  // This is the only use of this, and it's not worth defining a complicated\n  // densemapinfo hash/equality function for it.\n  std::set<\n      std::pair<const Value *,\n                std::tuple<const Value *, const CongruenceClass *, Value *>>>\n      StoreExpressionSet;\n  for (const auto &KV : ExpressionToClass) {\n    if (auto *SE = dyn_cast<StoreExpression>(KV.first)) {\n      // Make sure a version that will conflict with loads is not already there\n      auto Res = StoreExpressionSet.insert(\n          {SE->getOperand(0), std::make_tuple(SE->getMemoryLeader(), KV.second,\n                                              SE->getStoredValue())});\n      bool Okay = Res.second;\n      // It's okay to have the same expression already in there if it is\n      // identical in nature.\n      // This can happen when the leader of the stored value changes over time.\n      if (!Okay)\n        Okay = (std::get<1>(Res.first->second) == KV.second) &&\n               (lookupOperandLeader(std::get<2>(Res.first->second)) ==\n                lookupOperandLeader(SE->getStoredValue()));\n      assert(Okay && \"Stored expression conflict exists in expression table\");\n      auto *ValueExpr = ValueToExpression.lookup(SE->getStoreInst());\n      assert(ValueExpr && ValueExpr->equals(*SE) &&\n             \"StoreExpression in ExpressionToClass is not latest \"\n             \"StoreExpression for value\");\n    }\n  }\n#endif\n}\n\n// This is the main value numbering loop, it iterates over the initial touched\n// instruction set, propagating value numbers, marking things touched, etc,\n// until the set of touched instructions is completely empty.\nvoid NewGVN::iterateTouchedInstructions() {\n  unsigned int Iterations = 0;\n  // Figure out where touchedinstructions starts\n  int FirstInstr = TouchedInstructions.find_first();\n  // Nothing set, nothing to iterate, just return.\n  if (FirstInstr == -1)\n    return;\n  const BasicBlock *LastBlock = getBlockForValue(InstrFromDFSNum(FirstInstr));\n  while (TouchedInstructions.any()) {\n    ++Iterations;\n    // Walk through all the instructions in all the blocks in RPO.\n    // TODO: As we hit a new block, we should push and pop equalities into a\n    // table lookupOperandLeader can use, to catch things PredicateInfo\n    // might miss, like edge-only equivalences.\n    for (unsigned InstrNum : TouchedInstructions.set_bits()) {\n\n      // This instruction was found to be dead. We don't bother looking\n      // at it again.\n      if (InstrNum == 0) {\n        TouchedInstructions.reset(InstrNum);\n        continue;\n      }\n\n      Value *V = InstrFromDFSNum(InstrNum);\n      const BasicBlock *CurrBlock = getBlockForValue(V);\n\n      // If we hit a new block, do reachability processing.\n      if (CurrBlock != LastBlock) {\n        LastBlock = CurrBlock;\n        bool BlockReachable = ReachableBlocks.count(CurrBlock);\n        const auto &CurrInstRange = BlockInstRange.lookup(CurrBlock);\n\n        // If it's not reachable, erase any touched instructions and move on.\n        if (!BlockReachable) {\n          TouchedInstructions.reset(CurrInstRange.first, CurrInstRange.second);\n          LLVM_DEBUG(dbgs() << \"Skipping instructions in block \"\n                            << getBlockName(CurrBlock)\n                            << \" because it is unreachable\\n\");\n          continue;\n        }\n        updateProcessedCount(CurrBlock);\n      }\n      // Reset after processing (because we may mark ourselves as touched when\n      // we propagate equalities).\n      TouchedInstructions.reset(InstrNum);\n\n      if (auto *MP = dyn_cast<MemoryPhi>(V)) {\n        LLVM_DEBUG(dbgs() << \"Processing MemoryPhi \" << *MP << \"\\n\");\n        valueNumberMemoryPhi(MP);\n      } else if (auto *I = dyn_cast<Instruction>(V)) {\n        valueNumberInstruction(I);\n      } else {\n        llvm_unreachable(\"Should have been a MemoryPhi or Instruction\");\n      }\n      updateProcessedCount(V);\n    }\n  }\n  NumGVNMaxIterations = std::max(NumGVNMaxIterations.getValue(), Iterations);\n}\n\n// This is the main transformation entry point.\nbool NewGVN::runGVN() {\n  if (DebugCounter::isCounterSet(VNCounter))\n    StartingVNCounter = DebugCounter::getCounterValue(VNCounter);\n  bool Changed = false;\n  NumFuncArgs = F.arg_size();\n  MSSAWalker = MSSA->getWalker();\n  SingletonDeadExpression = new (ExpressionAllocator) DeadExpression();\n\n  // Count number of instructions for sizing of hash tables, and come\n  // up with a global dfs numbering for instructions.\n  unsigned ICount = 1;\n  // Add an empty instruction to account for the fact that we start at 1\n  DFSToInstr.emplace_back(nullptr);\n  // Note: We want ideal RPO traversal of the blocks, which is not quite the\n  // same as dominator tree order, particularly with regard whether backedges\n  // get visited first or second, given a block with multiple successors.\n  // If we visit in the wrong order, we will end up performing N times as many\n  // iterations.\n  // The dominator tree does guarantee that, for a given dom tree node, it's\n  // parent must occur before it in the RPO ordering. Thus, we only need to sort\n  // the siblings.\n  ReversePostOrderTraversal<Function *> RPOT(&F);\n  unsigned Counter = 0;\n  for (auto &B : RPOT) {\n    auto *Node = DT->getNode(B);\n    assert(Node && \"RPO and Dominator tree should have same reachability\");\n    RPOOrdering[Node] = ++Counter;\n  }\n  // Sort dominator tree children arrays into RPO.\n  for (auto &B : RPOT) {\n    auto *Node = DT->getNode(B);\n    if (Node->getNumChildren() > 1)\n      llvm::sort(*Node, [&](const DomTreeNode *A, const DomTreeNode *B) {\n        return RPOOrdering[A] < RPOOrdering[B];\n      });\n  }\n\n  // Now a standard depth first ordering of the domtree is equivalent to RPO.\n  for (auto DTN : depth_first(DT->getRootNode())) {\n    BasicBlock *B = DTN->getBlock();\n    const auto &BlockRange = assignDFSNumbers(B, ICount);\n    BlockInstRange.insert({B, BlockRange});\n    ICount += BlockRange.second - BlockRange.first;\n  }\n  initializeCongruenceClasses(F);\n\n  TouchedInstructions.resize(ICount);\n  // Ensure we don't end up resizing the expressionToClass map, as\n  // that can be quite expensive. At most, we have one expression per\n  // instruction.\n  ExpressionToClass.reserve(ICount);\n\n  // Initialize the touched instructions to include the entry block.\n  const auto &InstRange = BlockInstRange.lookup(&F.getEntryBlock());\n  TouchedInstructions.set(InstRange.first, InstRange.second);\n  LLVM_DEBUG(dbgs() << \"Block \" << getBlockName(&F.getEntryBlock())\n                    << \" marked reachable\\n\");\n  ReachableBlocks.insert(&F.getEntryBlock());\n\n  iterateTouchedInstructions();\n  verifyMemoryCongruency();\n  verifyIterationSettled(F);\n  verifyStoreExpressions();\n\n  Changed |= eliminateInstructions(F);\n\n  // Delete all instructions marked for deletion.\n  for (Instruction *ToErase : InstructionsToErase) {\n    if (!ToErase->use_empty())\n      ToErase->replaceAllUsesWith(UndefValue::get(ToErase->getType()));\n\n    assert(ToErase->getParent() &&\n           \"BB containing ToErase deleted unexpectedly!\");\n    ToErase->eraseFromParent();\n  }\n  Changed |= !InstructionsToErase.empty();\n\n  // Delete all unreachable blocks.\n  auto UnreachableBlockPred = [&](const BasicBlock &BB) {\n    return !ReachableBlocks.count(&BB);\n  };\n\n  for (auto &BB : make_filter_range(F, UnreachableBlockPred)) {\n    LLVM_DEBUG(dbgs() << \"We believe block \" << getBlockName(&BB)\n                      << \" is unreachable\\n\");\n    deleteInstructionsInBlock(&BB);\n    Changed = true;\n  }\n\n  cleanupTables();\n  return Changed;\n}\n\nstruct NewGVN::ValueDFS {\n  int DFSIn = 0;\n  int DFSOut = 0;\n  int LocalNum = 0;\n\n  // Only one of Def and U will be set.\n  // The bool in the Def tells us whether the Def is the stored value of a\n  // store.\n  PointerIntPair<Value *, 1, bool> Def;\n  Use *U = nullptr;\n\n  bool operator<(const ValueDFS &Other) const {\n    // It's not enough that any given field be less than - we have sets\n    // of fields that need to be evaluated together to give a proper ordering.\n    // For example, if you have;\n    // DFS (1, 3)\n    // Val 0\n    // DFS (1, 2)\n    // Val 50\n    // We want the second to be less than the first, but if we just go field\n    // by field, we will get to Val 0 < Val 50 and say the first is less than\n    // the second. We only want it to be less than if the DFS orders are equal.\n    //\n    // Each LLVM instruction only produces one value, and thus the lowest-level\n    // differentiator that really matters for the stack (and what we use as as a\n    // replacement) is the local dfs number.\n    // Everything else in the structure is instruction level, and only affects\n    // the order in which we will replace operands of a given instruction.\n    //\n    // For a given instruction (IE things with equal dfsin, dfsout, localnum),\n    // the order of replacement of uses does not matter.\n    // IE given,\n    //  a = 5\n    //  b = a + a\n    // When you hit b, you will have two valuedfs with the same dfsin, out, and\n    // localnum.\n    // The .val will be the same as well.\n    // The .u's will be different.\n    // You will replace both, and it does not matter what order you replace them\n    // in (IE whether you replace operand 2, then operand 1, or operand 1, then\n    // operand 2).\n    // Similarly for the case of same dfsin, dfsout, localnum, but different\n    // .val's\n    //  a = 5\n    //  b  = 6\n    //  c = a + b\n    // in c, we will a valuedfs for a, and one for b,with everything the same\n    // but .val  and .u.\n    // It does not matter what order we replace these operands in.\n    // You will always end up with the same IR, and this is guaranteed.\n    return std::tie(DFSIn, DFSOut, LocalNum, Def, U) <\n           std::tie(Other.DFSIn, Other.DFSOut, Other.LocalNum, Other.Def,\n                    Other.U);\n  }\n};\n\n// This function converts the set of members for a congruence class from values,\n// to sets of defs and uses with associated DFS info.  The total number of\n// reachable uses for each value is stored in UseCount, and instructions that\n// seem\n// dead (have no non-dead uses) are stored in ProbablyDead.\nvoid NewGVN::convertClassToDFSOrdered(\n    const CongruenceClass &Dense, SmallVectorImpl<ValueDFS> &DFSOrderedSet,\n    DenseMap<const Value *, unsigned int> &UseCounts,\n    SmallPtrSetImpl<Instruction *> &ProbablyDead) const {\n  for (auto D : Dense) {\n    // First add the value.\n    BasicBlock *BB = getBlockForValue(D);\n    // Constants are handled prior to ever calling this function, so\n    // we should only be left with instructions as members.\n    assert(BB && \"Should have figured out a basic block for value\");\n    ValueDFS VDDef;\n    DomTreeNode *DomNode = DT->getNode(BB);\n    VDDef.DFSIn = DomNode->getDFSNumIn();\n    VDDef.DFSOut = DomNode->getDFSNumOut();\n    // If it's a store, use the leader of the value operand, if it's always\n    // available, or the value operand.  TODO: We could do dominance checks to\n    // find a dominating leader, but not worth it ATM.\n    if (auto *SI = dyn_cast<StoreInst>(D)) {\n      auto Leader = lookupOperandLeader(SI->getValueOperand());\n      if (alwaysAvailable(Leader)) {\n        VDDef.Def.setPointer(Leader);\n      } else {\n        VDDef.Def.setPointer(SI->getValueOperand());\n        VDDef.Def.setInt(true);\n      }\n    } else {\n      VDDef.Def.setPointer(D);\n    }\n    assert(isa<Instruction>(D) &&\n           \"The dense set member should always be an instruction\");\n    Instruction *Def = cast<Instruction>(D);\n    VDDef.LocalNum = InstrToDFSNum(D);\n    DFSOrderedSet.push_back(VDDef);\n    // If there is a phi node equivalent, add it\n    if (auto *PN = RealToTemp.lookup(Def)) {\n      auto *PHIE =\n          dyn_cast_or_null<PHIExpression>(ValueToExpression.lookup(Def));\n      if (PHIE) {\n        VDDef.Def.setInt(false);\n        VDDef.Def.setPointer(PN);\n        VDDef.LocalNum = 0;\n        DFSOrderedSet.push_back(VDDef);\n      }\n    }\n\n    unsigned int UseCount = 0;\n    // Now add the uses.\n    for (auto &U : Def->uses()) {\n      if (auto *I = dyn_cast<Instruction>(U.getUser())) {\n        // Don't try to replace into dead uses\n        if (InstructionsToErase.count(I))\n          continue;\n        ValueDFS VDUse;\n        // Put the phi node uses in the incoming block.\n        BasicBlock *IBlock;\n        if (auto *P = dyn_cast<PHINode>(I)) {\n          IBlock = P->getIncomingBlock(U);\n          // Make phi node users appear last in the incoming block\n          // they are from.\n          VDUse.LocalNum = InstrDFS.size() + 1;\n        } else {\n          IBlock = getBlockForValue(I);\n          VDUse.LocalNum = InstrToDFSNum(I);\n        }\n\n        // Skip uses in unreachable blocks, as we're going\n        // to delete them.\n        if (ReachableBlocks.count(IBlock) == 0)\n          continue;\n\n        DomTreeNode *DomNode = DT->getNode(IBlock);\n        VDUse.DFSIn = DomNode->getDFSNumIn();\n        VDUse.DFSOut = DomNode->getDFSNumOut();\n        VDUse.U = &U;\n        ++UseCount;\n        DFSOrderedSet.emplace_back(VDUse);\n      }\n    }\n\n    // If there are no uses, it's probably dead (but it may have side-effects,\n    // so not definitely dead. Otherwise, store the number of uses so we can\n    // track if it becomes dead later).\n    if (UseCount == 0)\n      ProbablyDead.insert(Def);\n    else\n      UseCounts[Def] = UseCount;\n  }\n}\n\n// This function converts the set of members for a congruence class from values,\n// to the set of defs for loads and stores, with associated DFS info.\nvoid NewGVN::convertClassToLoadsAndStores(\n    const CongruenceClass &Dense,\n    SmallVectorImpl<ValueDFS> &LoadsAndStores) const {\n  for (auto D : Dense) {\n    if (!isa<LoadInst>(D) && !isa<StoreInst>(D))\n      continue;\n\n    BasicBlock *BB = getBlockForValue(D);\n    ValueDFS VD;\n    DomTreeNode *DomNode = DT->getNode(BB);\n    VD.DFSIn = DomNode->getDFSNumIn();\n    VD.DFSOut = DomNode->getDFSNumOut();\n    VD.Def.setPointer(D);\n\n    // If it's an instruction, use the real local dfs number.\n    if (auto *I = dyn_cast<Instruction>(D))\n      VD.LocalNum = InstrToDFSNum(I);\n    else\n      llvm_unreachable(\"Should have been an instruction\");\n\n    LoadsAndStores.emplace_back(VD);\n  }\n}\n\nstatic void patchAndReplaceAllUsesWith(Instruction *I, Value *Repl) {\n  patchReplacementInstruction(I, Repl);\n  I->replaceAllUsesWith(Repl);\n}\n\nvoid NewGVN::deleteInstructionsInBlock(BasicBlock *BB) {\n  LLVM_DEBUG(dbgs() << \"  BasicBlock Dead:\" << *BB);\n  ++NumGVNBlocksDeleted;\n\n  // Delete the instructions backwards, as it has a reduced likelihood of having\n  // to update as many def-use and use-def chains. Start after the terminator.\n  auto StartPoint = BB->rbegin();\n  ++StartPoint;\n  // Note that we explicitly recalculate BB->rend() on each iteration,\n  // as it may change when we remove the first instruction.\n  for (BasicBlock::reverse_iterator I(StartPoint); I != BB->rend();) {\n    Instruction &Inst = *I++;\n    if (!Inst.use_empty())\n      Inst.replaceAllUsesWith(UndefValue::get(Inst.getType()));\n    if (isa<LandingPadInst>(Inst))\n      continue;\n    salvageKnowledge(&Inst, AC);\n\n    Inst.eraseFromParent();\n    ++NumGVNInstrDeleted;\n  }\n  // Now insert something that simplifycfg will turn into an unreachable.\n  Type *Int8Ty = Type::getInt8Ty(BB->getContext());\n  new StoreInst(UndefValue::get(Int8Ty),\n                Constant::getNullValue(Int8Ty->getPointerTo()),\n                BB->getTerminator());\n}\n\nvoid NewGVN::markInstructionForDeletion(Instruction *I) {\n  LLVM_DEBUG(dbgs() << \"Marking \" << *I << \" for deletion\\n\");\n  InstructionsToErase.insert(I);\n}\n\nvoid NewGVN::replaceInstruction(Instruction *I, Value *V) {\n  LLVM_DEBUG(dbgs() << \"Replacing \" << *I << \" with \" << *V << \"\\n\");\n  patchAndReplaceAllUsesWith(I, V);\n  // We save the actual erasing to avoid invalidating memory\n  // dependencies until we are done with everything.\n  markInstructionForDeletion(I);\n}\n\nnamespace {\n\n// This is a stack that contains both the value and dfs info of where\n// that value is valid.\nclass ValueDFSStack {\npublic:\n  Value *back() const { return ValueStack.back(); }\n  std::pair<int, int> dfs_back() const { return DFSStack.back(); }\n\n  void push_back(Value *V, int DFSIn, int DFSOut) {\n    ValueStack.emplace_back(V);\n    DFSStack.emplace_back(DFSIn, DFSOut);\n  }\n\n  bool empty() const { return DFSStack.empty(); }\n\n  bool isInScope(int DFSIn, int DFSOut) const {\n    if (empty())\n      return false;\n    return DFSIn >= DFSStack.back().first && DFSOut <= DFSStack.back().second;\n  }\n\n  void popUntilDFSScope(int DFSIn, int DFSOut) {\n\n    // These two should always be in sync at this point.\n    assert(ValueStack.size() == DFSStack.size() &&\n           \"Mismatch between ValueStack and DFSStack\");\n    while (\n        !DFSStack.empty() &&\n        !(DFSIn >= DFSStack.back().first && DFSOut <= DFSStack.back().second)) {\n      DFSStack.pop_back();\n      ValueStack.pop_back();\n    }\n  }\n\nprivate:\n  SmallVector<Value *, 8> ValueStack;\n  SmallVector<std::pair<int, int>, 8> DFSStack;\n};\n\n} // end anonymous namespace\n\n// Given an expression, get the congruence class for it.\nCongruenceClass *NewGVN::getClassForExpression(const Expression *E) const {\n  if (auto *VE = dyn_cast<VariableExpression>(E))\n    return ValueToClass.lookup(VE->getVariableValue());\n  else if (isa<DeadExpression>(E))\n    return TOPClass;\n  return ExpressionToClass.lookup(E);\n}\n\n// Given a value and a basic block we are trying to see if it is available in,\n// see if the value has a leader available in that block.\nValue *NewGVN::findPHIOfOpsLeader(const Expression *E,\n                                  const Instruction *OrigInst,\n                                  const BasicBlock *BB) const {\n  // It would already be constant if we could make it constant\n  if (auto *CE = dyn_cast<ConstantExpression>(E))\n    return CE->getConstantValue();\n  if (auto *VE = dyn_cast<VariableExpression>(E)) {\n    auto *V = VE->getVariableValue();\n    if (alwaysAvailable(V) || DT->dominates(getBlockForValue(V), BB))\n      return VE->getVariableValue();\n  }\n\n  auto *CC = getClassForExpression(E);\n  if (!CC)\n    return nullptr;\n  if (alwaysAvailable(CC->getLeader()))\n    return CC->getLeader();\n\n  for (auto Member : *CC) {\n    auto *MemberInst = dyn_cast<Instruction>(Member);\n    if (MemberInst == OrigInst)\n      continue;\n    // Anything that isn't an instruction is always available.\n    if (!MemberInst)\n      return Member;\n    if (DT->dominates(getBlockForValue(MemberInst), BB))\n      return Member;\n  }\n  return nullptr;\n}\n\nbool NewGVN::eliminateInstructions(Function &F) {\n  // This is a non-standard eliminator. The normal way to eliminate is\n  // to walk the dominator tree in order, keeping track of available\n  // values, and eliminating them.  However, this is mildly\n  // pointless. It requires doing lookups on every instruction,\n  // regardless of whether we will ever eliminate it.  For\n  // instructions part of most singleton congruence classes, we know we\n  // will never eliminate them.\n\n  // Instead, this eliminator looks at the congruence classes directly, sorts\n  // them into a DFS ordering of the dominator tree, and then we just\n  // perform elimination straight on the sets by walking the congruence\n  // class member uses in order, and eliminate the ones dominated by the\n  // last member.   This is worst case O(E log E) where E = number of\n  // instructions in a single congruence class.  In theory, this is all\n  // instructions.   In practice, it is much faster, as most instructions are\n  // either in singleton congruence classes or can't possibly be eliminated\n  // anyway (if there are no overlapping DFS ranges in class).\n  // When we find something not dominated, it becomes the new leader\n  // for elimination purposes.\n  // TODO: If we wanted to be faster, We could remove any members with no\n  // overlapping ranges while sorting, as we will never eliminate anything\n  // with those members, as they don't dominate anything else in our set.\n\n  bool AnythingReplaced = false;\n\n  // Since we are going to walk the domtree anyway, and we can't guarantee the\n  // DFS numbers are updated, we compute some ourselves.\n  DT->updateDFSNumbers();\n\n  // Go through all of our phi nodes, and kill the arguments associated with\n  // unreachable edges.\n  auto ReplaceUnreachablePHIArgs = [&](PHINode *PHI, BasicBlock *BB) {\n    for (auto &Operand : PHI->incoming_values())\n      if (!ReachableEdges.count({PHI->getIncomingBlock(Operand), BB})) {\n        LLVM_DEBUG(dbgs() << \"Replacing incoming value of \" << PHI\n                          << \" for block \"\n                          << getBlockName(PHI->getIncomingBlock(Operand))\n                          << \" with undef due to it being unreachable\\n\");\n        Operand.set(UndefValue::get(PHI->getType()));\n      }\n  };\n  // Replace unreachable phi arguments.\n  // At this point, RevisitOnReachabilityChange only contains:\n  //\n  // 1. PHIs\n  // 2. Temporaries that will convert to PHIs\n  // 3. Operations that are affected by an unreachable edge but do not fit into\n  // 1 or 2 (rare).\n  // So it is a slight overshoot of what we want. We could make it exact by\n  // using two SparseBitVectors per block.\n  DenseMap<const BasicBlock *, unsigned> ReachablePredCount;\n  for (auto &KV : ReachableEdges)\n    ReachablePredCount[KV.getEnd()]++;\n  for (auto &BBPair : RevisitOnReachabilityChange) {\n    for (auto InstNum : BBPair.second) {\n      auto *Inst = InstrFromDFSNum(InstNum);\n      auto *PHI = dyn_cast<PHINode>(Inst);\n      PHI = PHI ? PHI : dyn_cast_or_null<PHINode>(RealToTemp.lookup(Inst));\n      if (!PHI)\n        continue;\n      auto *BB = BBPair.first;\n      if (ReachablePredCount.lookup(BB) != PHI->getNumIncomingValues())\n        ReplaceUnreachablePHIArgs(PHI, BB);\n    }\n  }\n\n  // Map to store the use counts\n  DenseMap<const Value *, unsigned int> UseCounts;\n  for (auto *CC : reverse(CongruenceClasses)) {\n    LLVM_DEBUG(dbgs() << \"Eliminating in congruence class \" << CC->getID()\n                      << \"\\n\");\n    // Track the equivalent store info so we can decide whether to try\n    // dead store elimination.\n    SmallVector<ValueDFS, 8> PossibleDeadStores;\n    SmallPtrSet<Instruction *, 8> ProbablyDead;\n    if (CC->isDead() || CC->empty())\n      continue;\n    // Everything still in the TOP class is unreachable or dead.\n    if (CC == TOPClass) {\n      for (auto M : *CC) {\n        auto *VTE = ValueToExpression.lookup(M);\n        if (VTE && isa<DeadExpression>(VTE))\n          markInstructionForDeletion(cast<Instruction>(M));\n        assert((!ReachableBlocks.count(cast<Instruction>(M)->getParent()) ||\n                InstructionsToErase.count(cast<Instruction>(M))) &&\n               \"Everything in TOP should be unreachable or dead at this \"\n               \"point\");\n      }\n      continue;\n    }\n\n    assert(CC->getLeader() && \"We should have had a leader\");\n    // If this is a leader that is always available, and it's a\n    // constant or has no equivalences, just replace everything with\n    // it. We then update the congruence class with whatever members\n    // are left.\n    Value *Leader =\n        CC->getStoredValue() ? CC->getStoredValue() : CC->getLeader();\n    if (alwaysAvailable(Leader)) {\n      CongruenceClass::MemberSet MembersLeft;\n      for (auto M : *CC) {\n        Value *Member = M;\n        // Void things have no uses we can replace.\n        if (Member == Leader || !isa<Instruction>(Member) ||\n            Member->getType()->isVoidTy()) {\n          MembersLeft.insert(Member);\n          continue;\n        }\n        LLVM_DEBUG(dbgs() << \"Found replacement \" << *(Leader) << \" for \"\n                          << *Member << \"\\n\");\n        auto *I = cast<Instruction>(Member);\n        assert(Leader != I && \"About to accidentally remove our leader\");\n        replaceInstruction(I, Leader);\n        AnythingReplaced = true;\n      }\n      CC->swap(MembersLeft);\n    } else {\n      // If this is a singleton, we can skip it.\n      if (CC->size() != 1 || RealToTemp.count(Leader)) {\n        // This is a stack because equality replacement/etc may place\n        // constants in the middle of the member list, and we want to use\n        // those constant values in preference to the current leader, over\n        // the scope of those constants.\n        ValueDFSStack EliminationStack;\n\n        // Convert the members to DFS ordered sets and then merge them.\n        SmallVector<ValueDFS, 8> DFSOrderedSet;\n        convertClassToDFSOrdered(*CC, DFSOrderedSet, UseCounts, ProbablyDead);\n\n        // Sort the whole thing.\n        llvm::sort(DFSOrderedSet);\n        for (auto &VD : DFSOrderedSet) {\n          int MemberDFSIn = VD.DFSIn;\n          int MemberDFSOut = VD.DFSOut;\n          Value *Def = VD.Def.getPointer();\n          bool FromStore = VD.Def.getInt();\n          Use *U = VD.U;\n          // We ignore void things because we can't get a value from them.\n          if (Def && Def->getType()->isVoidTy())\n            continue;\n          auto *DefInst = dyn_cast_or_null<Instruction>(Def);\n          if (DefInst && AllTempInstructions.count(DefInst)) {\n            auto *PN = cast<PHINode>(DefInst);\n\n            // If this is a value phi and that's the expression we used, insert\n            // it into the program\n            // remove from temp instruction list.\n            AllTempInstructions.erase(PN);\n            auto *DefBlock = getBlockForValue(Def);\n            LLVM_DEBUG(dbgs() << \"Inserting fully real phi of ops\" << *Def\n                              << \" into block \"\n                              << getBlockName(getBlockForValue(Def)) << \"\\n\");\n            PN->insertBefore(&DefBlock->front());\n            Def = PN;\n            NumGVNPHIOfOpsEliminations++;\n          }\n\n          if (EliminationStack.empty()) {\n            LLVM_DEBUG(dbgs() << \"Elimination Stack is empty\\n\");\n          } else {\n            LLVM_DEBUG(dbgs() << \"Elimination Stack Top DFS numbers are (\"\n                              << EliminationStack.dfs_back().first << \",\"\n                              << EliminationStack.dfs_back().second << \")\\n\");\n          }\n\n          LLVM_DEBUG(dbgs() << \"Current DFS numbers are (\" << MemberDFSIn << \",\"\n                            << MemberDFSOut << \")\\n\");\n          // First, we see if we are out of scope or empty.  If so,\n          // and there equivalences, we try to replace the top of\n          // stack with equivalences (if it's on the stack, it must\n          // not have been eliminated yet).\n          // Then we synchronize to our current scope, by\n          // popping until we are back within a DFS scope that\n          // dominates the current member.\n          // Then, what happens depends on a few factors\n          // If the stack is now empty, we need to push\n          // If we have a constant or a local equivalence we want to\n          // start using, we also push.\n          // Otherwise, we walk along, processing members who are\n          // dominated by this scope, and eliminate them.\n          bool ShouldPush = Def && EliminationStack.empty();\n          bool OutOfScope =\n              !EliminationStack.isInScope(MemberDFSIn, MemberDFSOut);\n\n          if (OutOfScope || ShouldPush) {\n            // Sync to our current scope.\n            EliminationStack.popUntilDFSScope(MemberDFSIn, MemberDFSOut);\n            bool ShouldPush = Def && EliminationStack.empty();\n            if (ShouldPush) {\n              EliminationStack.push_back(Def, MemberDFSIn, MemberDFSOut);\n            }\n          }\n\n          // Skip the Def's, we only want to eliminate on their uses.  But mark\n          // dominated defs as dead.\n          if (Def) {\n            // For anything in this case, what and how we value number\n            // guarantees that any side-effets that would have occurred (ie\n            // throwing, etc) can be proven to either still occur (because it's\n            // dominated by something that has the same side-effects), or never\n            // occur.  Otherwise, we would not have been able to prove it value\n            // equivalent to something else. For these things, we can just mark\n            // it all dead.  Note that this is different from the \"ProbablyDead\"\n            // set, which may not be dominated by anything, and thus, are only\n            // easy to prove dead if they are also side-effect free. Note that\n            // because stores are put in terms of the stored value, we skip\n            // stored values here. If the stored value is really dead, it will\n            // still be marked for deletion when we process it in its own class.\n            if (!EliminationStack.empty() && Def != EliminationStack.back() &&\n                isa<Instruction>(Def) && !FromStore)\n              markInstructionForDeletion(cast<Instruction>(Def));\n            continue;\n          }\n          // At this point, we know it is a Use we are trying to possibly\n          // replace.\n\n          assert(isa<Instruction>(U->get()) &&\n                 \"Current def should have been an instruction\");\n          assert(isa<Instruction>(U->getUser()) &&\n                 \"Current user should have been an instruction\");\n\n          // If the thing we are replacing into is already marked to be dead,\n          // this use is dead.  Note that this is true regardless of whether\n          // we have anything dominating the use or not.  We do this here\n          // because we are already walking all the uses anyway.\n          Instruction *InstUse = cast<Instruction>(U->getUser());\n          if (InstructionsToErase.count(InstUse)) {\n            auto &UseCount = UseCounts[U->get()];\n            if (--UseCount == 0) {\n              ProbablyDead.insert(cast<Instruction>(U->get()));\n            }\n          }\n\n          // If we get to this point, and the stack is empty we must have a use\n          // with nothing we can use to eliminate this use, so just skip it.\n          if (EliminationStack.empty())\n            continue;\n\n          Value *DominatingLeader = EliminationStack.back();\n\n          auto *II = dyn_cast<IntrinsicInst>(DominatingLeader);\n          bool isSSACopy = II && II->getIntrinsicID() == Intrinsic::ssa_copy;\n          if (isSSACopy)\n            DominatingLeader = II->getOperand(0);\n\n          // Don't replace our existing users with ourselves.\n          if (U->get() == DominatingLeader)\n            continue;\n          LLVM_DEBUG(dbgs()\n                     << \"Found replacement \" << *DominatingLeader << \" for \"\n                     << *U->get() << \" in \" << *(U->getUser()) << \"\\n\");\n\n          // If we replaced something in an instruction, handle the patching of\n          // metadata.  Skip this if we are replacing predicateinfo with its\n          // original operand, as we already know we can just drop it.\n          auto *ReplacedInst = cast<Instruction>(U->get());\n          auto *PI = PredInfo->getPredicateInfoFor(ReplacedInst);\n          if (!PI || DominatingLeader != PI->OriginalOp)\n            patchReplacementInstruction(ReplacedInst, DominatingLeader);\n          U->set(DominatingLeader);\n          // This is now a use of the dominating leader, which means if the\n          // dominating leader was dead, it's now live!\n          auto &LeaderUseCount = UseCounts[DominatingLeader];\n          // It's about to be alive again.\n          if (LeaderUseCount == 0 && isa<Instruction>(DominatingLeader))\n            ProbablyDead.erase(cast<Instruction>(DominatingLeader));\n          // For copy instructions, we use their operand as a leader,\n          // which means we remove a user of the copy and it may become dead.\n          if (isSSACopy) {\n            unsigned &IIUseCount = UseCounts[II];\n            if (--IIUseCount == 0)\n              ProbablyDead.insert(II);\n          }\n          ++LeaderUseCount;\n          AnythingReplaced = true;\n        }\n      }\n    }\n\n    // At this point, anything still in the ProbablyDead set is actually dead if\n    // would be trivially dead.\n    for (auto *I : ProbablyDead)\n      if (wouldInstructionBeTriviallyDead(I))\n        markInstructionForDeletion(I);\n\n    // Cleanup the congruence class.\n    CongruenceClass::MemberSet MembersLeft;\n    for (auto *Member : *CC)\n      if (!isa<Instruction>(Member) ||\n          !InstructionsToErase.count(cast<Instruction>(Member)))\n        MembersLeft.insert(Member);\n    CC->swap(MembersLeft);\n\n    // If we have possible dead stores to look at, try to eliminate them.\n    if (CC->getStoreCount() > 0) {\n      convertClassToLoadsAndStores(*CC, PossibleDeadStores);\n      llvm::sort(PossibleDeadStores);\n      ValueDFSStack EliminationStack;\n      for (auto &VD : PossibleDeadStores) {\n        int MemberDFSIn = VD.DFSIn;\n        int MemberDFSOut = VD.DFSOut;\n        Instruction *Member = cast<Instruction>(VD.Def.getPointer());\n        if (EliminationStack.empty() ||\n            !EliminationStack.isInScope(MemberDFSIn, MemberDFSOut)) {\n          // Sync to our current scope.\n          EliminationStack.popUntilDFSScope(MemberDFSIn, MemberDFSOut);\n          if (EliminationStack.empty()) {\n            EliminationStack.push_back(Member, MemberDFSIn, MemberDFSOut);\n            continue;\n          }\n        }\n        // We already did load elimination, so nothing to do here.\n        if (isa<LoadInst>(Member))\n          continue;\n        assert(!EliminationStack.empty());\n        Instruction *Leader = cast<Instruction>(EliminationStack.back());\n        (void)Leader;\n        assert(DT->dominates(Leader->getParent(), Member->getParent()));\n        // Member is dominater by Leader, and thus dead\n        LLVM_DEBUG(dbgs() << \"Marking dead store \" << *Member\n                          << \" that is dominated by \" << *Leader << \"\\n\");\n        markInstructionForDeletion(Member);\n        CC->erase(Member);\n        ++NumGVNDeadStores;\n      }\n    }\n  }\n  return AnythingReplaced;\n}\n\n// This function provides global ranking of operations so that we can place them\n// in a canonical order.  Note that rank alone is not necessarily enough for a\n// complete ordering, as constants all have the same rank.  However, generally,\n// we will simplify an operation with all constants so that it doesn't matter\n// what order they appear in.\nunsigned int NewGVN::getRank(const Value *V) const {\n  // Prefer constants to undef to anything else\n  // Undef is a constant, have to check it first.\n  // Prefer smaller constants to constantexprs\n  if (isa<ConstantExpr>(V))\n    return 2;\n  if (isa<UndefValue>(V))\n    return 1;\n  if (isa<Constant>(V))\n    return 0;\n  else if (auto *A = dyn_cast<Argument>(V))\n    return 3 + A->getArgNo();\n\n  // Need to shift the instruction DFS by number of arguments + 3 to account for\n  // the constant and argument ranking above.\n  unsigned Result = InstrToDFSNum(V);\n  if (Result > 0)\n    return 4 + NumFuncArgs + Result;\n  // Unreachable or something else, just return a really large number.\n  return ~0;\n}\n\n// This is a function that says whether two commutative operations should\n// have their order swapped when canonicalizing.\nbool NewGVN::shouldSwapOperands(const Value *A, const Value *B) const {\n  // Because we only care about a total ordering, and don't rewrite expressions\n  // in this order, we order by rank, which will give a strict weak ordering to\n  // everything but constants, and then we order by pointer address.\n  return std::make_pair(getRank(A), A) > std::make_pair(getRank(B), B);\n}\n\nnamespace {\n\nclass NewGVNLegacyPass : public FunctionPass {\npublic:\n  // Pass identification, replacement for typeid.\n  static char ID;\n\n  NewGVNLegacyPass() : FunctionPass(ID) {\n    initializeNewGVNLegacyPassPass(*PassRegistry::getPassRegistry());\n  }\n\n  bool runOnFunction(Function &F) override;\n\nprivate:\n  void getAnalysisUsage(AnalysisUsage &AU) const override {\n    AU.addRequired<AssumptionCacheTracker>();\n    AU.addRequired<DominatorTreeWrapperPass>();\n    AU.addRequired<TargetLibraryInfoWrapperPass>();\n    AU.addRequired<MemorySSAWrapperPass>();\n    AU.addRequired<AAResultsWrapperPass>();\n    AU.addPreserved<DominatorTreeWrapperPass>();\n    AU.addPreserved<GlobalsAAWrapperPass>();\n  }\n};\n\n} // end anonymous namespace\n\nbool NewGVNLegacyPass::runOnFunction(Function &F) {\n  if (skipFunction(F))\n    return false;\n  return NewGVN(F, &getAnalysis<DominatorTreeWrapperPass>().getDomTree(),\n                &getAnalysis<AssumptionCacheTracker>().getAssumptionCache(F),\n                &getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(F),\n                &getAnalysis<AAResultsWrapperPass>().getAAResults(),\n                &getAnalysis<MemorySSAWrapperPass>().getMSSA(),\n                F.getParent()->getDataLayout())\n      .runGVN();\n}\n\nchar NewGVNLegacyPass::ID = 0;\n\nINITIALIZE_PASS_BEGIN(NewGVNLegacyPass, \"newgvn\", \"Global Value Numbering\",\n                      false, false)\nINITIALIZE_PASS_DEPENDENCY(AssumptionCacheTracker)\nINITIALIZE_PASS_DEPENDENCY(MemorySSAWrapperPass)\nINITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)\nINITIALIZE_PASS_DEPENDENCY(TargetLibraryInfoWrapperPass)\nINITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass)\nINITIALIZE_PASS_DEPENDENCY(GlobalsAAWrapperPass)\nINITIALIZE_PASS_END(NewGVNLegacyPass, \"newgvn\", \"Global Value Numbering\", false,\n                    false)\n\n// createGVNPass - The public interface to this file.\nFunctionPass *llvm::createNewGVNPass() { return new NewGVNLegacyPass(); }\n\nPreservedAnalyses NewGVNPass::run(Function &F, AnalysisManager<Function> &AM) {\n  // Apparently the order in which we get these results matter for\n  // the old GVN (see Chandler's comment in GVN.cpp). I'll keep\n  // the same order here, just in case.\n  auto &AC = AM.getResult<AssumptionAnalysis>(F);\n  auto &DT = AM.getResult<DominatorTreeAnalysis>(F);\n  auto &TLI = AM.getResult<TargetLibraryAnalysis>(F);\n  auto &AA = AM.getResult<AAManager>(F);\n  auto &MSSA = AM.getResult<MemorySSAAnalysis>(F).getMSSA();\n  bool Changed =\n      NewGVN(F, &DT, &AC, &TLI, &AA, &MSSA, F.getParent()->getDataLayout())\n          .runGVN();\n  if (!Changed)\n    return PreservedAnalyses::all();\n  PreservedAnalyses PA;\n  PA.preserve<DominatorTreeAnalysis>();\n  PA.preserve<GlobalsAA>();\n  return PA;\n}\n"}}, "reports": [{"events": [{"location": {"col": 8, "file": 57, "line": 440}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp", "reportHash": "db523f6a2562a2a2b319ee19c8d51cb5", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 57, "line": 3446}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp", "reportHash": "8d213aee47ab0607fee96b45e50acd68", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
