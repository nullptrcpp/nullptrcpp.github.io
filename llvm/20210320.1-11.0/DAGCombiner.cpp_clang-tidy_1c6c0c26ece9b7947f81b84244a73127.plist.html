<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"77": {"id": 77, "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp", "content": "//===- DAGCombiner.cpp - Implement a DAG node combiner --------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This pass combines dag nodes to form fewer, simpler DAG nodes.  It can be run\n// both before and after the DAG is legalized.\n//\n// This pass is not a substitute for the LLVM IR instcombine pass. This pass is\n// primarily intended to handle simplification opportunities that are implicit\n// in the LLVM IR and exposed by the various codegen lowering phases.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/IntervalMap.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/SmallBitVector.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/Statistic.h\"\n#include \"llvm/Analysis/AliasAnalysis.h\"\n#include \"llvm/Analysis/MemoryLocation.h\"\n#include \"llvm/Analysis/TargetLibraryInfo.h\"\n#include \"llvm/Analysis/VectorUtils.h\"\n#include \"llvm/CodeGen/DAGCombine.h\"\n#include \"llvm/CodeGen/ISDOpcodes.h\"\n#include \"llvm/CodeGen/MachineFrameInfo.h\"\n#include \"llvm/CodeGen/MachineFunction.h\"\n#include \"llvm/CodeGen/MachineMemOperand.h\"\n#include \"llvm/CodeGen/RuntimeLibcalls.h\"\n#include \"llvm/CodeGen/SelectionDAG.h\"\n#include \"llvm/CodeGen/SelectionDAGAddressAnalysis.h\"\n#include \"llvm/CodeGen/SelectionDAGNodes.h\"\n#include \"llvm/CodeGen/SelectionDAGTargetInfo.h\"\n#include \"llvm/CodeGen/TargetLowering.h\"\n#include \"llvm/CodeGen/TargetRegisterInfo.h\"\n#include \"llvm/CodeGen/TargetSubtargetInfo.h\"\n#include \"llvm/CodeGen/ValueTypes.h\"\n#include \"llvm/IR/Attributes.h\"\n#include \"llvm/IR/Constant.h\"\n#include \"llvm/IR/DataLayout.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/Metadata.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/CodeGen.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/KnownBits.h\"\n#include \"llvm/Support/MachineValueType.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include \"llvm/Target/TargetMachine.h\"\n#include \"llvm/Target/TargetOptions.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iterator>\n#include <string>\n#include <tuple>\n#include <utility>\n\nusing namespace llvm;\n\n#define DEBUG_TYPE \"dagcombine\"\n\nSTATISTIC(NodesCombined   , \"Number of dag nodes combined\");\nSTATISTIC(PreIndexedNodes , \"Number of pre-indexed nodes created\");\nSTATISTIC(PostIndexedNodes, \"Number of post-indexed nodes created\");\nSTATISTIC(OpsNarrowed     , \"Number of load/op/store narrowed\");\nSTATISTIC(LdStFP2Int      , \"Number of fp load/store pairs transformed to int\");\nSTATISTIC(SlicedLoads, \"Number of load sliced\");\nSTATISTIC(NumFPLogicOpsConv, \"Number of logic ops converted to fp ops\");\n\nstatic cl::opt<bool>\nCombinerGlobalAA(\"combiner-global-alias-analysis\", cl::Hidden,\n                 cl::desc(\"Enable DAG combiner's use of IR alias analysis\"));\n\nstatic cl::opt<bool>\nUseTBAA(\"combiner-use-tbaa\", cl::Hidden, cl::init(true),\n        cl::desc(\"Enable DAG combiner's use of TBAA\"));\n\n#ifndef NDEBUG\nstatic cl::opt<std::string>\nCombinerAAOnlyFunc(\"combiner-aa-only-func\", cl::Hidden,\n                   cl::desc(\"Only use DAG-combiner alias analysis in this\"\n                            \" function\"));\n#endif\n\n/// Hidden option to stress test load slicing, i.e., when this option\n/// is enabled, load slicing bypasses most of its profitability guards.\nstatic cl::opt<bool>\nStressLoadSlicing(\"combiner-stress-load-slicing\", cl::Hidden,\n                  cl::desc(\"Bypass the profitability model of load slicing\"),\n                  cl::init(false));\n\nstatic cl::opt<bool>\n  MaySplitLoadIndex(\"combiner-split-load-index\", cl::Hidden, cl::init(true),\n                    cl::desc(\"DAG combiner may split indexing from loads\"));\n\nstatic cl::opt<bool>\n    EnableStoreMerging(\"combiner-store-merging\", cl::Hidden, cl::init(true),\n                       cl::desc(\"DAG combiner enable merging multiple stores \"\n                                \"into a wider store\"));\n\nstatic cl::opt<unsigned> TokenFactorInlineLimit(\n    \"combiner-tokenfactor-inline-limit\", cl::Hidden, cl::init(2048),\n    cl::desc(\"Limit the number of operands to inline for Token Factors\"));\n\nstatic cl::opt<unsigned> StoreMergeDependenceLimit(\n    \"combiner-store-merge-dependence-limit\", cl::Hidden, cl::init(10),\n    cl::desc(\"Limit the number of times for the same StoreNode and RootNode \"\n             \"to bail out in store merging dependence check\"));\n\nstatic cl::opt<bool> EnableReduceLoadOpStoreWidth(\n    \"combiner-reduce-load-op-store-width\", cl::Hidden, cl::init(true),\n    cl::desc(\"DAG cominber enable reducing the width of load/op/store \"\n             \"sequence\"));\n\nstatic cl::opt<bool> EnableShrinkLoadReplaceStoreWithStore(\n    \"combiner-shrink-load-replace-store-with-store\", cl::Hidden, cl::init(true),\n    cl::desc(\"DAG cominber enable load/<replace bytes>/store with \"\n             \"a narrower store\"));\n\nnamespace {\n\n  class DAGCombiner {\n    SelectionDAG &DAG;\n    const TargetLowering &TLI;\n    const SelectionDAGTargetInfo *STI;\n    CombineLevel Level;\n    CodeGenOpt::Level OptLevel;\n    bool LegalDAG = false;\n    bool LegalOperations = false;\n    bool LegalTypes = false;\n    bool ForCodeSize;\n    bool DisableGenericCombines;\n\n    /// Worklist of all of the nodes that need to be simplified.\n    ///\n    /// This must behave as a stack -- new nodes to process are pushed onto the\n    /// back and when processing we pop off of the back.\n    ///\n    /// The worklist will not contain duplicates but may contain null entries\n    /// due to nodes being deleted from the underlying DAG.\n    SmallVector<SDNode *, 64> Worklist;\n\n    /// Mapping from an SDNode to its position on the worklist.\n    ///\n    /// This is used to find and remove nodes from the worklist (by nulling\n    /// them) when they are deleted from the underlying DAG. It relies on\n    /// stable indices of nodes within the worklist.\n    DenseMap<SDNode *, unsigned> WorklistMap;\n    /// This records all nodes attempted to add to the worklist since we\n    /// considered a new worklist entry. As we keep do not add duplicate nodes\n    /// in the worklist, this is different from the tail of the worklist.\n    SmallSetVector<SDNode *, 32> PruningList;\n\n    /// Set of nodes which have been combined (at least once).\n    ///\n    /// This is used to allow us to reliably add any operands of a DAG node\n    /// which have not yet been combined to the worklist.\n    SmallPtrSet<SDNode *, 32> CombinedNodes;\n\n    /// Map from candidate StoreNode to the pair of RootNode and count.\n    /// The count is used to track how many times we have seen the StoreNode\n    /// with the same RootNode bail out in dependence check. If we have seen\n    /// the bail out for the same pair many times over a limit, we won't\n    /// consider the StoreNode with the same RootNode as store merging\n    /// candidate again.\n    DenseMap<SDNode *, std::pair<SDNode *, unsigned>> StoreRootCountMap;\n\n    // AA - Used for DAG load/store alias analysis.\n    AliasAnalysis *AA;\n\n    /// When an instruction is simplified, add all users of the instruction to\n    /// the work lists because they might get more simplified now.\n    void AddUsersToWorklist(SDNode *N) {\n      for (SDNode *Node : N->uses())\n        AddToWorklist(Node);\n    }\n\n    /// Convenient shorthand to add a node and all of its user to the worklist.\n    void AddToWorklistWithUsers(SDNode *N) {\n      AddUsersToWorklist(N);\n      AddToWorklist(N);\n    }\n\n    // Prune potentially dangling nodes. This is called after\n    // any visit to a node, but should also be called during a visit after any\n    // failed combine which may have created a DAG node.\n    void clearAddedDanglingWorklistEntries() {\n      // Check any nodes added to the worklist to see if they are prunable.\n      while (!PruningList.empty()) {\n        auto *N = PruningList.pop_back_val();\n        if (N->use_empty())\n          recursivelyDeleteUnusedNodes(N);\n      }\n    }\n\n    SDNode *getNextWorklistEntry() {\n      // Before we do any work, remove nodes that are not in use.\n      clearAddedDanglingWorklistEntries();\n      SDNode *N = nullptr;\n      // The Worklist holds the SDNodes in order, but it may contain null\n      // entries.\n      while (!N && !Worklist.empty()) {\n        N = Worklist.pop_back_val();\n      }\n\n      if (N) {\n        bool GoodWorklistEntry = WorklistMap.erase(N);\n        (void)GoodWorklistEntry;\n        assert(GoodWorklistEntry &&\n               \"Found a worklist entry without a corresponding map entry!\");\n      }\n      return N;\n    }\n\n    /// Call the node-specific routine that folds each particular type of node.\n    SDValue visit(SDNode *N);\n\n  public:\n    DAGCombiner(SelectionDAG &D, AliasAnalysis *AA, CodeGenOpt::Level OL)\n        : DAG(D), TLI(D.getTargetLoweringInfo()),\n          STI(D.getSubtarget().getSelectionDAGInfo()),\n          Level(BeforeLegalizeTypes), OptLevel(OL), AA(AA) {\n      ForCodeSize = DAG.shouldOptForSize();\n      DisableGenericCombines = STI && STI->disableGenericCombines(OptLevel);\n\n      MaximumLegalStoreInBits = 0;\n      // We use the minimum store size here, since that's all we can guarantee\n      // for the scalable vector types.\n      for (MVT VT : MVT::all_valuetypes())\n        if (EVT(VT).isSimple() && VT != MVT::Other &&\n            TLI.isTypeLegal(EVT(VT)) &&\n            VT.getSizeInBits().getKnownMinSize() >= MaximumLegalStoreInBits)\n          MaximumLegalStoreInBits = VT.getSizeInBits().getKnownMinSize();\n    }\n\n    void ConsiderForPruning(SDNode *N) {\n      // Mark this for potential pruning.\n      PruningList.insert(N);\n    }\n\n    /// Add to the worklist making sure its instance is at the back (next to be\n    /// processed.)\n    void AddToWorklist(SDNode *N) {\n      assert(N->getOpcode() != ISD::DELETED_NODE &&\n             \"Deleted Node added to Worklist\");\n\n      // Skip handle nodes as they can't usefully be combined and confuse the\n      // zero-use deletion strategy.\n      if (N->getOpcode() == ISD::HANDLENODE)\n        return;\n\n      ConsiderForPruning(N);\n\n      if (WorklistMap.insert(std::make_pair(N, Worklist.size())).second)\n        Worklist.push_back(N);\n    }\n\n    /// Remove all instances of N from the worklist.\n    void removeFromWorklist(SDNode *N) {\n      CombinedNodes.erase(N);\n      PruningList.remove(N);\n      StoreRootCountMap.erase(N);\n\n      auto It = WorklistMap.find(N);\n      if (It == WorklistMap.end())\n        return; // Not in the worklist.\n\n      // Null out the entry rather than erasing it to avoid a linear operation.\n      Worklist[It->second] = nullptr;\n      WorklistMap.erase(It);\n    }\n\n    void deleteAndRecombine(SDNode *N);\n    bool recursivelyDeleteUnusedNodes(SDNode *N);\n\n    /// Replaces all uses of the results of one DAG node with new values.\n    SDValue CombineTo(SDNode *N, const SDValue *To, unsigned NumTo,\n                      bool AddTo = true);\n\n    /// Replaces all uses of the results of one DAG node with new values.\n    SDValue CombineTo(SDNode *N, SDValue Res, bool AddTo = true) {\n      return CombineTo(N, &Res, 1, AddTo);\n    }\n\n    /// Replaces all uses of the results of one DAG node with new values.\n    SDValue CombineTo(SDNode *N, SDValue Res0, SDValue Res1,\n                      bool AddTo = true) {\n      SDValue To[] = { Res0, Res1 };\n      return CombineTo(N, To, 2, AddTo);\n    }\n\n    void CommitTargetLoweringOpt(const TargetLowering::TargetLoweringOpt &TLO);\n\n  private:\n    unsigned MaximumLegalStoreInBits;\n\n    /// Check the specified integer node value to see if it can be simplified or\n    /// if things it uses can be simplified by bit propagation.\n    /// If so, return true.\n    bool SimplifyDemandedBits(SDValue Op) {\n      unsigned BitWidth = Op.getScalarValueSizeInBits();\n      APInt DemandedBits = APInt::getAllOnesValue(BitWidth);\n      return SimplifyDemandedBits(Op, DemandedBits);\n    }\n\n    bool SimplifyDemandedBits(SDValue Op, const APInt &DemandedBits) {\n      TargetLowering::TargetLoweringOpt TLO(DAG, LegalTypes, LegalOperations);\n      KnownBits Known;\n      if (!TLI.SimplifyDemandedBits(Op, DemandedBits, Known, TLO, 0, false))\n        return false;\n\n      // Revisit the node.\n      AddToWorklist(Op.getNode());\n\n      CommitTargetLoweringOpt(TLO);\n      return true;\n    }\n\n    /// Check the specified vector node value to see if it can be simplified or\n    /// if things it uses can be simplified as it only uses some of the\n    /// elements. If so, return true.\n    bool SimplifyDemandedVectorElts(SDValue Op) {\n      // TODO: For now just pretend it cannot be simplified.\n      if (Op.getValueType().isScalableVector())\n        return false;\n\n      unsigned NumElts = Op.getValueType().getVectorNumElements();\n      APInt DemandedElts = APInt::getAllOnesValue(NumElts);\n      return SimplifyDemandedVectorElts(Op, DemandedElts);\n    }\n\n    bool SimplifyDemandedBits(SDValue Op, const APInt &DemandedBits,\n                              const APInt &DemandedElts,\n                              bool AssumeSingleUse = false);\n    bool SimplifyDemandedVectorElts(SDValue Op, const APInt &DemandedElts,\n                                    bool AssumeSingleUse = false);\n\n    bool CombineToPreIndexedLoadStore(SDNode *N);\n    bool CombineToPostIndexedLoadStore(SDNode *N);\n    SDValue SplitIndexingFromLoad(LoadSDNode *LD);\n    bool SliceUpLoad(SDNode *N);\n\n    // Scalars have size 0 to distinguish from singleton vectors.\n    SDValue ForwardStoreValueToDirectLoad(LoadSDNode *LD);\n    bool getTruncatedStoreValue(StoreSDNode *ST, SDValue &Val);\n    bool extendLoadedValueToExtension(LoadSDNode *LD, SDValue &Val);\n\n    /// Replace an ISD::EXTRACT_VECTOR_ELT of a load with a narrowed\n    ///   load.\n    ///\n    /// \\param EVE ISD::EXTRACT_VECTOR_ELT to be replaced.\n    /// \\param InVecVT type of the input vector to EVE with bitcasts resolved.\n    /// \\param EltNo index of the vector element to load.\n    /// \\param OriginalLoad load that EVE came from to be replaced.\n    /// \\returns EVE on success SDValue() on failure.\n    SDValue scalarizeExtractedVectorLoad(SDNode *EVE, EVT InVecVT,\n                                         SDValue EltNo,\n                                         LoadSDNode *OriginalLoad);\n    void ReplaceLoadWithPromotedLoad(SDNode *Load, SDNode *ExtLoad);\n    SDValue PromoteOperand(SDValue Op, EVT PVT, bool &Replace);\n    SDValue SExtPromoteOperand(SDValue Op, EVT PVT);\n    SDValue ZExtPromoteOperand(SDValue Op, EVT PVT);\n    SDValue PromoteIntBinOp(SDValue Op);\n    SDValue PromoteIntShiftOp(SDValue Op);\n    SDValue PromoteExtend(SDValue Op);\n    bool PromoteLoad(SDValue Op);\n\n    /// Call the node-specific routine that knows how to fold each\n    /// particular type of node. If that doesn't do anything, try the\n    /// target-specific DAG combines.\n    SDValue combine(SDNode *N);\n\n    // Visitation implementation - Implement dag node combining for different\n    // node types.  The semantics are as follows:\n    // Return Value:\n    //   SDValue.getNode() == 0 - No change was made\n    //   SDValue.getNode() == N - N was replaced, is dead and has been handled.\n    //   otherwise              - N should be replaced by the returned Operand.\n    //\n    SDValue visitTokenFactor(SDNode *N);\n    SDValue visitMERGE_VALUES(SDNode *N);\n    SDValue visitADD(SDNode *N);\n    SDValue visitADDLike(SDNode *N);\n    SDValue visitADDLikeCommutative(SDValue N0, SDValue N1, SDNode *LocReference);\n    SDValue visitSUB(SDNode *N);\n    SDValue visitADDSAT(SDNode *N);\n    SDValue visitSUBSAT(SDNode *N);\n    SDValue visitADDC(SDNode *N);\n    SDValue visitADDO(SDNode *N);\n    SDValue visitUADDOLike(SDValue N0, SDValue N1, SDNode *N);\n    SDValue visitSUBC(SDNode *N);\n    SDValue visitSUBO(SDNode *N);\n    SDValue visitADDE(SDNode *N);\n    SDValue visitADDCARRY(SDNode *N);\n    SDValue visitSADDO_CARRY(SDNode *N);\n    SDValue visitADDCARRYLike(SDValue N0, SDValue N1, SDValue CarryIn, SDNode *N);\n    SDValue visitSUBE(SDNode *N);\n    SDValue visitSUBCARRY(SDNode *N);\n    SDValue visitSSUBO_CARRY(SDNode *N);\n    SDValue visitMUL(SDNode *N);\n    SDValue visitMULFIX(SDNode *N);\n    SDValue useDivRem(SDNode *N);\n    SDValue visitSDIV(SDNode *N);\n    SDValue visitSDIVLike(SDValue N0, SDValue N1, SDNode *N);\n    SDValue visitUDIV(SDNode *N);\n    SDValue visitUDIVLike(SDValue N0, SDValue N1, SDNode *N);\n    SDValue visitREM(SDNode *N);\n    SDValue visitMULHU(SDNode *N);\n    SDValue visitMULHS(SDNode *N);\n    SDValue visitSMUL_LOHI(SDNode *N);\n    SDValue visitUMUL_LOHI(SDNode *N);\n    SDValue visitMULO(SDNode *N);\n    SDValue visitIMINMAX(SDNode *N);\n    SDValue visitAND(SDNode *N);\n    SDValue visitANDLike(SDValue N0, SDValue N1, SDNode *N);\n    SDValue visitOR(SDNode *N);\n    SDValue visitORLike(SDValue N0, SDValue N1, SDNode *N);\n    SDValue visitXOR(SDNode *N);\n    SDValue SimplifyVBinOp(SDNode *N);\n    SDValue visitSHL(SDNode *N);\n    SDValue visitSRA(SDNode *N);\n    SDValue visitSRL(SDNode *N);\n    SDValue visitFunnelShift(SDNode *N);\n    SDValue visitRotate(SDNode *N);\n    SDValue visitABS(SDNode *N);\n    SDValue visitBSWAP(SDNode *N);\n    SDValue visitBITREVERSE(SDNode *N);\n    SDValue visitCTLZ(SDNode *N);\n    SDValue visitCTLZ_ZERO_UNDEF(SDNode *N);\n    SDValue visitCTTZ(SDNode *N);\n    SDValue visitCTTZ_ZERO_UNDEF(SDNode *N);\n    SDValue visitCTPOP(SDNode *N);\n    SDValue visitSELECT(SDNode *N);\n    SDValue visitVSELECT(SDNode *N);\n    SDValue visitSELECT_CC(SDNode *N);\n    SDValue visitSETCC(SDNode *N);\n    SDValue visitSETCCCARRY(SDNode *N);\n    SDValue visitSIGN_EXTEND(SDNode *N);\n    SDValue visitZERO_EXTEND(SDNode *N);\n    SDValue visitANY_EXTEND(SDNode *N);\n    SDValue visitAssertExt(SDNode *N);\n    SDValue visitAssertAlign(SDNode *N);\n    SDValue visitSIGN_EXTEND_INREG(SDNode *N);\n    SDValue visitSIGN_EXTEND_VECTOR_INREG(SDNode *N);\n    SDValue visitZERO_EXTEND_VECTOR_INREG(SDNode *N);\n    SDValue visitTRUNCATE(SDNode *N);\n    SDValue visitBITCAST(SDNode *N);\n    SDValue visitFREEZE(SDNode *N);\n    SDValue visitBUILD_PAIR(SDNode *N);\n    SDValue visitFADD(SDNode *N);\n    SDValue visitSTRICT_FADD(SDNode *N);\n    SDValue visitFSUB(SDNode *N);\n    SDValue visitFMUL(SDNode *N);\n    SDValue visitFMA(SDNode *N);\n    SDValue visitFDIV(SDNode *N);\n    SDValue visitFREM(SDNode *N);\n    SDValue visitFSQRT(SDNode *N);\n    SDValue visitFCOPYSIGN(SDNode *N);\n    SDValue visitFPOW(SDNode *N);\n    SDValue visitSINT_TO_FP(SDNode *N);\n    SDValue visitUINT_TO_FP(SDNode *N);\n    SDValue visitFP_TO_SINT(SDNode *N);\n    SDValue visitFP_TO_UINT(SDNode *N);\n    SDValue visitFP_ROUND(SDNode *N);\n    SDValue visitFP_EXTEND(SDNode *N);\n    SDValue visitFNEG(SDNode *N);\n    SDValue visitFABS(SDNode *N);\n    SDValue visitFCEIL(SDNode *N);\n    SDValue visitFTRUNC(SDNode *N);\n    SDValue visitFFLOOR(SDNode *N);\n    SDValue visitFMINNUM(SDNode *N);\n    SDValue visitFMAXNUM(SDNode *N);\n    SDValue visitFMINIMUM(SDNode *N);\n    SDValue visitFMAXIMUM(SDNode *N);\n    SDValue visitBRCOND(SDNode *N);\n    SDValue visitBR_CC(SDNode *N);\n    SDValue visitLOAD(SDNode *N);\n\n    SDValue replaceStoreChain(StoreSDNode *ST, SDValue BetterChain);\n    SDValue replaceStoreOfFPConstant(StoreSDNode *ST);\n\n    SDValue visitSTORE(SDNode *N);\n    SDValue visitLIFETIME_END(SDNode *N);\n    SDValue visitINSERT_VECTOR_ELT(SDNode *N);\n    SDValue visitEXTRACT_VECTOR_ELT(SDNode *N);\n    SDValue visitBUILD_VECTOR(SDNode *N);\n    SDValue visitCONCAT_VECTORS(SDNode *N);\n    SDValue visitEXTRACT_SUBVECTOR(SDNode *N);\n    SDValue visitVECTOR_SHUFFLE(SDNode *N);\n    SDValue visitSCALAR_TO_VECTOR(SDNode *N);\n    SDValue visitINSERT_SUBVECTOR(SDNode *N);\n    SDValue visitMLOAD(SDNode *N);\n    SDValue visitMSTORE(SDNode *N);\n    SDValue visitMGATHER(SDNode *N);\n    SDValue visitMSCATTER(SDNode *N);\n    SDValue visitFP_TO_FP16(SDNode *N);\n    SDValue visitFP16_TO_FP(SDNode *N);\n    SDValue visitVECREDUCE(SDNode *N);\n\n    SDValue visitFADDForFMACombine(SDNode *N);\n    SDValue visitFSUBForFMACombine(SDNode *N);\n    SDValue visitFMULForFMADistributiveCombine(SDNode *N);\n\n    SDValue XformToShuffleWithZero(SDNode *N);\n    bool reassociationCanBreakAddressingModePattern(unsigned Opc,\n                                                    const SDLoc &DL, SDValue N0,\n                                                    SDValue N1);\n    SDValue reassociateOpsCommutative(unsigned Opc, const SDLoc &DL, SDValue N0,\n                                      SDValue N1);\n    SDValue reassociateOps(unsigned Opc, const SDLoc &DL, SDValue N0,\n                           SDValue N1, SDNodeFlags Flags);\n\n    SDValue visitShiftByConstant(SDNode *N);\n\n    SDValue foldSelectOfConstants(SDNode *N);\n    SDValue foldVSelectOfConstants(SDNode *N);\n    SDValue foldBinOpIntoSelect(SDNode *BO);\n    bool SimplifySelectOps(SDNode *SELECT, SDValue LHS, SDValue RHS);\n    SDValue hoistLogicOpWithSameOpcodeHands(SDNode *N);\n    SDValue SimplifySelect(const SDLoc &DL, SDValue N0, SDValue N1, SDValue N2);\n    SDValue SimplifySelectCC(const SDLoc &DL, SDValue N0, SDValue N1,\n                             SDValue N2, SDValue N3, ISD::CondCode CC,\n                             bool NotExtCompare = false);\n    SDValue convertSelectOfFPConstantsToLoadOffset(\n        const SDLoc &DL, SDValue N0, SDValue N1, SDValue N2, SDValue N3,\n        ISD::CondCode CC);\n    SDValue foldSignChangeInBitcast(SDNode *N);\n    SDValue foldSelectCCToShiftAnd(const SDLoc &DL, SDValue N0, SDValue N1,\n                                   SDValue N2, SDValue N3, ISD::CondCode CC);\n    SDValue foldLogicOfSetCCs(bool IsAnd, SDValue N0, SDValue N1,\n                              const SDLoc &DL);\n    SDValue foldSubToUSubSat(EVT DstVT, SDNode *N);\n    SDValue unfoldMaskedMerge(SDNode *N);\n    SDValue unfoldExtremeBitClearingToShifts(SDNode *N);\n    SDValue SimplifySetCC(EVT VT, SDValue N0, SDValue N1, ISD::CondCode Cond,\n                          const SDLoc &DL, bool foldBooleans);\n    SDValue rebuildSetCC(SDValue N);\n\n    bool isSetCCEquivalent(SDValue N, SDValue &LHS, SDValue &RHS,\n                           SDValue &CC, bool MatchStrict = false) const;\n    bool isOneUseSetCC(SDValue N) const;\n\n    SDValue SimplifyNodeWithTwoResults(SDNode *N, unsigned LoOp,\n                                         unsigned HiOp);\n    SDValue CombineConsecutiveLoads(SDNode *N, EVT VT);\n    SDValue CombineExtLoad(SDNode *N);\n    SDValue CombineZExtLogicopShiftLoad(SDNode *N);\n    SDValue combineRepeatedFPDivisors(SDNode *N);\n    SDValue combineInsertEltToShuffle(SDNode *N, unsigned InsIndex);\n    SDValue ConstantFoldBITCASTofBUILD_VECTOR(SDNode *, EVT);\n    SDValue BuildSDIV(SDNode *N);\n    SDValue BuildSDIVPow2(SDNode *N);\n    SDValue BuildUDIV(SDNode *N);\n    SDValue BuildLogBase2(SDValue V, const SDLoc &DL);\n    SDValue BuildDivEstimate(SDValue N, SDValue Op, SDNodeFlags Flags);\n    SDValue buildRsqrtEstimate(SDValue Op, SDNodeFlags Flags);\n    SDValue buildSqrtEstimate(SDValue Op, SDNodeFlags Flags);\n    SDValue buildSqrtEstimateImpl(SDValue Op, SDNodeFlags Flags, bool Recip);\n    SDValue buildSqrtNROneConst(SDValue Arg, SDValue Est, unsigned Iterations,\n                                SDNodeFlags Flags, bool Reciprocal);\n    SDValue buildSqrtNRTwoConst(SDValue Arg, SDValue Est, unsigned Iterations,\n                                SDNodeFlags Flags, bool Reciprocal);\n    SDValue MatchBSwapHWordLow(SDNode *N, SDValue N0, SDValue N1,\n                               bool DemandHighBits = true);\n    SDValue MatchBSwapHWord(SDNode *N, SDValue N0, SDValue N1);\n    SDValue MatchRotatePosNeg(SDValue Shifted, SDValue Pos, SDValue Neg,\n                              SDValue InnerPos, SDValue InnerNeg,\n                              unsigned PosOpcode, unsigned NegOpcode,\n                              const SDLoc &DL);\n    SDValue MatchFunnelPosNeg(SDValue N0, SDValue N1, SDValue Pos, SDValue Neg,\n                              SDValue InnerPos, SDValue InnerNeg,\n                              unsigned PosOpcode, unsigned NegOpcode,\n                              const SDLoc &DL);\n    SDValue MatchRotate(SDValue LHS, SDValue RHS, const SDLoc &DL);\n    SDValue MatchLoadCombine(SDNode *N);\n    SDValue mergeTruncStores(StoreSDNode *N);\n    SDValue ReduceLoadWidth(SDNode *N);\n    SDValue ReduceLoadOpStoreWidth(SDNode *N);\n    SDValue splitMergedValStore(StoreSDNode *ST);\n    SDValue TransformFPLoadStorePair(SDNode *N);\n    SDValue convertBuildVecZextToZext(SDNode *N);\n    SDValue reduceBuildVecExtToExtBuildVec(SDNode *N);\n    SDValue reduceBuildVecTruncToBitCast(SDNode *N);\n    SDValue reduceBuildVecToShuffle(SDNode *N);\n    SDValue createBuildVecShuffle(const SDLoc &DL, SDNode *N,\n                                  ArrayRef<int> VectorMask, SDValue VecIn1,\n                                  SDValue VecIn2, unsigned LeftIdx,\n                                  bool DidSplitVec);\n    SDValue matchVSelectOpSizesWithSetCC(SDNode *Cast);\n\n    /// Walk up chain skipping non-aliasing memory nodes,\n    /// looking for aliasing nodes and adding them to the Aliases vector.\n    void GatherAllAliases(SDNode *N, SDValue OriginalChain,\n                          SmallVectorImpl<SDValue> &Aliases);\n\n    /// Return true if there is any possibility that the two addresses overlap.\n    bool isAlias(SDNode *Op0, SDNode *Op1) const;\n\n    /// Walk up chain skipping non-aliasing memory nodes, looking for a better\n    /// chain (aliasing node.)\n    SDValue FindBetterChain(SDNode *N, SDValue Chain);\n\n    /// Try to replace a store and any possibly adjacent stores on\n    /// consecutive chains with better chains. Return true only if St is\n    /// replaced.\n    ///\n    /// Notice that other chains may still be replaced even if the function\n    /// returns false.\n    bool findBetterNeighborChains(StoreSDNode *St);\n\n    // Helper for findBetterNeighborChains. Walk up store chain add additional\n    // chained stores that do not overlap and can be parallelized.\n    bool parallelizeChainedStores(StoreSDNode *St);\n\n    /// Holds a pointer to an LSBaseSDNode as well as information on where it\n    /// is located in a sequence of memory operations connected by a chain.\n    struct MemOpLink {\n      // Ptr to the mem node.\n      LSBaseSDNode *MemNode;\n\n      // Offset from the base ptr.\n      int64_t OffsetFromBase;\n\n      MemOpLink(LSBaseSDNode *N, int64_t Offset)\n          : MemNode(N), OffsetFromBase(Offset) {}\n    };\n\n    // Classify the origin of a stored value.\n    enum class StoreSource { Unknown, Constant, Extract, Load };\n    StoreSource getStoreSource(SDValue StoreVal) {\n      switch (StoreVal.getOpcode()) {\n      case ISD::Constant:\n      case ISD::ConstantFP:\n        return StoreSource::Constant;\n      case ISD::EXTRACT_VECTOR_ELT:\n      case ISD::EXTRACT_SUBVECTOR:\n        return StoreSource::Extract;\n      case ISD::LOAD:\n        return StoreSource::Load;\n      default:\n        return StoreSource::Unknown;\n      }\n    }\n\n    /// This is a helper function for visitMUL to check the profitability\n    /// of folding (mul (add x, c1), c2) -> (add (mul x, c2), c1*c2).\n    /// MulNode is the original multiply, AddNode is (add x, c1),\n    /// and ConstNode is c2.\n    bool isMulAddWithConstProfitable(SDNode *MulNode,\n                                     SDValue &AddNode,\n                                     SDValue &ConstNode);\n\n    /// This is a helper function for visitAND and visitZERO_EXTEND.  Returns\n    /// true if the (and (load x) c) pattern matches an extload.  ExtVT returns\n    /// the type of the loaded value to be extended.\n    bool isAndLoadExtLoad(ConstantSDNode *AndC, LoadSDNode *LoadN,\n                          EVT LoadResultTy, EVT &ExtVT);\n\n    /// Helper function to calculate whether the given Load/Store can have its\n    /// width reduced to ExtVT.\n    bool isLegalNarrowLdSt(LSBaseSDNode *LDSTN, ISD::LoadExtType ExtType,\n                           EVT &MemVT, unsigned ShAmt = 0);\n\n    /// Used by BackwardsPropagateMask to find suitable loads.\n    bool SearchForAndLoads(SDNode *N, SmallVectorImpl<LoadSDNode*> &Loads,\n                           SmallPtrSetImpl<SDNode*> &NodesWithConsts,\n                           ConstantSDNode *Mask, SDNode *&NodeToMask);\n    /// Attempt to propagate a given AND node back to load leaves so that they\n    /// can be combined into narrow loads.\n    bool BackwardsPropagateMask(SDNode *N);\n\n    /// Helper function for mergeConsecutiveStores which merges the component\n    /// store chains.\n    SDValue getMergeStoreChains(SmallVectorImpl<MemOpLink> &StoreNodes,\n                                unsigned NumStores);\n\n    /// This is a helper function for mergeConsecutiveStores. When the source\n    /// elements of the consecutive stores are all constants or all extracted\n    /// vector elements, try to merge them into one larger store introducing\n    /// bitcasts if necessary.  \\return True if a merged store was created.\n    bool mergeStoresOfConstantsOrVecElts(SmallVectorImpl<MemOpLink> &StoreNodes,\n                                         EVT MemVT, unsigned NumStores,\n                                         bool IsConstantSrc, bool UseVector,\n                                         bool UseTrunc);\n\n    /// This is a helper function for mergeConsecutiveStores. Stores that\n    /// potentially may be merged with St are placed in StoreNodes. RootNode is\n    /// a chain predecessor to all store candidates.\n    void getStoreMergeCandidates(StoreSDNode *St,\n                                 SmallVectorImpl<MemOpLink> &StoreNodes,\n                                 SDNode *&Root);\n\n    /// Helper function for mergeConsecutiveStores. Checks if candidate stores\n    /// have indirect dependency through their operands. RootNode is the\n    /// predecessor to all stores calculated by getStoreMergeCandidates and is\n    /// used to prune the dependency check. \\return True if safe to merge.\n    bool checkMergeStoreCandidatesForDependencies(\n        SmallVectorImpl<MemOpLink> &StoreNodes, unsigned NumStores,\n        SDNode *RootNode);\n\n    /// This is a helper function for mergeConsecutiveStores. Given a list of\n    /// store candidates, find the first N that are consecutive in memory.\n    /// Returns 0 if there are not at least 2 consecutive stores to try merging.\n    unsigned getConsecutiveStores(SmallVectorImpl<MemOpLink> &StoreNodes,\n                                  int64_t ElementSizeBytes) const;\n\n    /// This is a helper function for mergeConsecutiveStores. It is used for\n    /// store chains that are composed entirely of constant values.\n    bool tryStoreMergeOfConstants(SmallVectorImpl<MemOpLink> &StoreNodes,\n                                  unsigned NumConsecutiveStores,\n                                  EVT MemVT, SDNode *Root, bool AllowVectors);\n\n    /// This is a helper function for mergeConsecutiveStores. It is used for\n    /// store chains that are composed entirely of extracted vector elements.\n    /// When extracting multiple vector elements, try to store them in one\n    /// vector store rather than a sequence of scalar stores.\n    bool tryStoreMergeOfExtracts(SmallVectorImpl<MemOpLink> &StoreNodes,\n                                 unsigned NumConsecutiveStores, EVT MemVT,\n                                 SDNode *Root);\n\n    /// This is a helper function for mergeConsecutiveStores. It is used for\n    /// store chains that are composed entirely of loaded values.\n    bool tryStoreMergeOfLoads(SmallVectorImpl<MemOpLink> &StoreNodes,\n                              unsigned NumConsecutiveStores, EVT MemVT,\n                              SDNode *Root, bool AllowVectors,\n                              bool IsNonTemporalStore, bool IsNonTemporalLoad);\n\n    /// Merge consecutive store operations into a wide store.\n    /// This optimization uses wide integers or vectors when possible.\n    /// \\return true if stores were merged.\n    bool mergeConsecutiveStores(StoreSDNode *St);\n\n    /// Try to transform a truncation where C is a constant:\n    ///     (trunc (and X, C)) -> (and (trunc X), (trunc C))\n    ///\n    /// \\p N needs to be a truncation and its first operand an AND. Other\n    /// requirements are checked by the function (e.g. that trunc is\n    /// single-use) and if missed an empty SDValue is returned.\n    SDValue distributeTruncateThroughAnd(SDNode *N);\n\n    /// Helper function to determine whether the target supports operation\n    /// given by \\p Opcode for type \\p VT, that is, whether the operation\n    /// is legal or custom before legalizing operations, and whether is\n    /// legal (but not custom) after legalization.\n    bool hasOperation(unsigned Opcode, EVT VT) {\n      return TLI.isOperationLegalOrCustom(Opcode, VT, LegalOperations);\n    }\n\n  public:\n    /// Runs the dag combiner on all nodes in the work list\n    void Run(CombineLevel AtLevel);\n\n    SelectionDAG &getDAG() const { return DAG; }\n\n    /// Returns a type large enough to hold any valid shift amount - before type\n    /// legalization these can be huge.\n    EVT getShiftAmountTy(EVT LHSTy) {\n      assert(LHSTy.isInteger() && \"Shift amount is not an integer type!\");\n      return TLI.getShiftAmountTy(LHSTy, DAG.getDataLayout(), LegalTypes);\n    }\n\n    /// This method returns true if we are running before type legalization or\n    /// if the specified VT is legal.\n    bool isTypeLegal(const EVT &VT) {\n      if (!LegalTypes) return true;\n      return TLI.isTypeLegal(VT);\n    }\n\n    /// Convenience wrapper around TargetLowering::getSetCCResultType\n    EVT getSetCCResultType(EVT VT) const {\n      return TLI.getSetCCResultType(DAG.getDataLayout(), *DAG.getContext(), VT);\n    }\n\n    void ExtendSetCCUses(const SmallVectorImpl<SDNode *> &SetCCs,\n                         SDValue OrigLoad, SDValue ExtLoad,\n                         ISD::NodeType ExtType);\n  };\n\n/// This class is a DAGUpdateListener that removes any deleted\n/// nodes from the worklist.\nclass WorklistRemover : public SelectionDAG::DAGUpdateListener {\n  DAGCombiner &DC;\n\npublic:\n  explicit WorklistRemover(DAGCombiner &dc)\n    : SelectionDAG::DAGUpdateListener(dc.getDAG()), DC(dc) {}\n\n  void NodeDeleted(SDNode *N, SDNode *E) override {\n    DC.removeFromWorklist(N);\n  }\n};\n\nclass WorklistInserter : public SelectionDAG::DAGUpdateListener {\n  DAGCombiner &DC;\n\npublic:\n  explicit WorklistInserter(DAGCombiner &dc)\n      : SelectionDAG::DAGUpdateListener(dc.getDAG()), DC(dc) {}\n\n  // FIXME: Ideally we could add N to the worklist, but this causes exponential\n  //        compile time costs in large DAGs, e.g. Halide.\n  void NodeInserted(SDNode *N) override { DC.ConsiderForPruning(N); }\n};\n\n} // end anonymous namespace\n\n//===----------------------------------------------------------------------===//\n//  TargetLowering::DAGCombinerInfo implementation\n//===----------------------------------------------------------------------===//\n\nvoid TargetLowering::DAGCombinerInfo::AddToWorklist(SDNode *N) {\n  ((DAGCombiner*)DC)->AddToWorklist(N);\n}\n\nSDValue TargetLowering::DAGCombinerInfo::\nCombineTo(SDNode *N, ArrayRef<SDValue> To, bool AddTo) {\n  return ((DAGCombiner*)DC)->CombineTo(N, &To[0], To.size(), AddTo);\n}\n\nSDValue TargetLowering::DAGCombinerInfo::\nCombineTo(SDNode *N, SDValue Res, bool AddTo) {\n  return ((DAGCombiner*)DC)->CombineTo(N, Res, AddTo);\n}\n\nSDValue TargetLowering::DAGCombinerInfo::\nCombineTo(SDNode *N, SDValue Res0, SDValue Res1, bool AddTo) {\n  return ((DAGCombiner*)DC)->CombineTo(N, Res0, Res1, AddTo);\n}\n\nbool TargetLowering::DAGCombinerInfo::\nrecursivelyDeleteUnusedNodes(SDNode *N) {\n  return ((DAGCombiner*)DC)->recursivelyDeleteUnusedNodes(N);\n}\n\nvoid TargetLowering::DAGCombinerInfo::\nCommitTargetLoweringOpt(const TargetLowering::TargetLoweringOpt &TLO) {\n  return ((DAGCombiner*)DC)->CommitTargetLoweringOpt(TLO);\n}\n\n//===----------------------------------------------------------------------===//\n// Helper Functions\n//===----------------------------------------------------------------------===//\n\nvoid DAGCombiner::deleteAndRecombine(SDNode *N) {\n  removeFromWorklist(N);\n\n  // If the operands of this node are only used by the node, they will now be\n  // dead. Make sure to re-visit them and recursively delete dead nodes.\n  for (const SDValue &Op : N->ops())\n    // For an operand generating multiple values, one of the values may\n    // become dead allowing further simplification (e.g. split index\n    // arithmetic from an indexed load).\n    if (Op->hasOneUse() || Op->getNumValues() > 1)\n      AddToWorklist(Op.getNode());\n\n  DAG.DeleteNode(N);\n}\n\n// APInts must be the same size for most operations, this helper\n// function zero extends the shorter of the pair so that they match.\n// We provide an Offset so that we can create bitwidths that won't overflow.\nstatic void zeroExtendToMatch(APInt &LHS, APInt &RHS, unsigned Offset = 0) {\n  unsigned Bits = Offset + std::max(LHS.getBitWidth(), RHS.getBitWidth());\n  LHS = LHS.zextOrSelf(Bits);\n  RHS = RHS.zextOrSelf(Bits);\n}\n\n// Return true if this node is a setcc, or is a select_cc\n// that selects between the target values used for true and false, making it\n// equivalent to a setcc. Also, set the incoming LHS, RHS, and CC references to\n// the appropriate nodes based on the type of node we are checking. This\n// simplifies life a bit for the callers.\nbool DAGCombiner::isSetCCEquivalent(SDValue N, SDValue &LHS, SDValue &RHS,\n                                    SDValue &CC, bool MatchStrict) const {\n  if (N.getOpcode() == ISD::SETCC) {\n    LHS = N.getOperand(0);\n    RHS = N.getOperand(1);\n    CC  = N.getOperand(2);\n    return true;\n  }\n\n  if (MatchStrict &&\n      (N.getOpcode() == ISD::STRICT_FSETCC ||\n       N.getOpcode() == ISD::STRICT_FSETCCS)) {\n    LHS = N.getOperand(1);\n    RHS = N.getOperand(2);\n    CC  = N.getOperand(3);\n    return true;\n  }\n\n  if (N.getOpcode() != ISD::SELECT_CC ||\n      !TLI.isConstTrueVal(N.getOperand(2).getNode()) ||\n      !TLI.isConstFalseVal(N.getOperand(3).getNode()))\n    return false;\n\n  if (TLI.getBooleanContents(N.getValueType()) ==\n      TargetLowering::UndefinedBooleanContent)\n    return false;\n\n  LHS = N.getOperand(0);\n  RHS = N.getOperand(1);\n  CC  = N.getOperand(4);\n  return true;\n}\n\n/// Return true if this is a SetCC-equivalent operation with only one use.\n/// If this is true, it allows the users to invert the operation for free when\n/// it is profitable to do so.\nbool DAGCombiner::isOneUseSetCC(SDValue N) const {\n  SDValue N0, N1, N2;\n  if (isSetCCEquivalent(N, N0, N1, N2) && N.getNode()->hasOneUse())\n    return true;\n  return false;\n}\n\nstatic bool isConstantSplatVectorMaskForType(SDNode *N, EVT ScalarTy) {\n  if (!ScalarTy.isSimple())\n    return false;\n\n  uint64_t MaskForTy = 0ULL;\n  switch (ScalarTy.getSimpleVT().SimpleTy) {\n  case MVT::i8:\n    MaskForTy = 0xFFULL;\n    break;\n  case MVT::i16:\n    MaskForTy = 0xFFFFULL;\n    break;\n  case MVT::i32:\n    MaskForTy = 0xFFFFFFFFULL;\n    break;\n  default:\n    return false;\n    break;\n  }\n\n  APInt Val;\n  if (ISD::isConstantSplatVector(N, Val))\n    return Val.getLimitedValue() == MaskForTy;\n\n  return false;\n}\n\n// Determines if it is a constant integer or a splat/build vector of constant\n// integers (and undefs).\n// Do not permit build vector implicit truncation.\nstatic bool isConstantOrConstantVector(SDValue N, bool NoOpaques = false) {\n  if (ConstantSDNode *Const = dyn_cast<ConstantSDNode>(N))\n    return !(Const->isOpaque() && NoOpaques);\n  if (N.getOpcode() != ISD::BUILD_VECTOR && N.getOpcode() != ISD::SPLAT_VECTOR)\n    return false;\n  unsigned BitWidth = N.getScalarValueSizeInBits();\n  for (const SDValue &Op : N->op_values()) {\n    if (Op.isUndef())\n      continue;\n    ConstantSDNode *Const = dyn_cast<ConstantSDNode>(Op);\n    if (!Const || Const->getAPIntValue().getBitWidth() != BitWidth ||\n        (Const->isOpaque() && NoOpaques))\n      return false;\n  }\n  return true;\n}\n\n// Determines if a BUILD_VECTOR is composed of all-constants possibly mixed with\n// undef's.\nstatic bool isAnyConstantBuildVector(SDValue V, bool NoOpaques = false) {\n  if (V.getOpcode() != ISD::BUILD_VECTOR)\n    return false;\n  return isConstantOrConstantVector(V, NoOpaques) ||\n         ISD::isBuildVectorOfConstantFPSDNodes(V.getNode());\n}\n\n// Determine if this an indexed load with an opaque target constant index.\nstatic bool canSplitIdx(LoadSDNode *LD) {\n  return MaySplitLoadIndex &&\n         (LD->getOperand(2).getOpcode() != ISD::TargetConstant ||\n          !cast<ConstantSDNode>(LD->getOperand(2))->isOpaque());\n}\n\nbool DAGCombiner::reassociationCanBreakAddressingModePattern(unsigned Opc,\n                                                             const SDLoc &DL,\n                                                             SDValue N0,\n                                                             SDValue N1) {\n  // Currently this only tries to ensure we don't undo the GEP splits done by\n  // CodeGenPrepare when shouldConsiderGEPOffsetSplit is true. To ensure this,\n  // we check if the following transformation would be problematic:\n  // (load/store (add, (add, x, offset1), offset2)) ->\n  // (load/store (add, x, offset1+offset2)).\n\n  if (Opc != ISD::ADD || N0.getOpcode() != ISD::ADD)\n    return false;\n\n  if (N0.hasOneUse())\n    return false;\n\n  auto *C1 = dyn_cast<ConstantSDNode>(N0.getOperand(1));\n  auto *C2 = dyn_cast<ConstantSDNode>(N1);\n  if (!C1 || !C2)\n    return false;\n\n  const APInt &C1APIntVal = C1->getAPIntValue();\n  const APInt &C2APIntVal = C2->getAPIntValue();\n  if (C1APIntVal.getBitWidth() > 64 || C2APIntVal.getBitWidth() > 64)\n    return false;\n\n  const APInt CombinedValueIntVal = C1APIntVal + C2APIntVal;\n  if (CombinedValueIntVal.getBitWidth() > 64)\n    return false;\n  const int64_t CombinedValue = CombinedValueIntVal.getSExtValue();\n\n  for (SDNode *Node : N0->uses()) {\n    auto LoadStore = dyn_cast<MemSDNode>(Node);\n    if (LoadStore) {\n      // Is x[offset2] already not a legal addressing mode? If so then\n      // reassociating the constants breaks nothing (we test offset2 because\n      // that's the one we hope to fold into the load or store).\n      TargetLoweringBase::AddrMode AM;\n      AM.HasBaseReg = true;\n      AM.BaseOffs = C2APIntVal.getSExtValue();\n      EVT VT = LoadStore->getMemoryVT();\n      unsigned AS = LoadStore->getAddressSpace();\n      Type *AccessTy = VT.getTypeForEVT(*DAG.getContext());\n      if (!TLI.isLegalAddressingMode(DAG.getDataLayout(), AM, AccessTy, AS))\n        continue;\n\n      // Would x[offset1+offset2] still be a legal addressing mode?\n      AM.BaseOffs = CombinedValue;\n      if (!TLI.isLegalAddressingMode(DAG.getDataLayout(), AM, AccessTy, AS))\n        return true;\n    }\n  }\n\n  return false;\n}\n\n// Helper for DAGCombiner::reassociateOps. Try to reassociate an expression\n// such as (Opc N0, N1), if \\p N0 is the same kind of operation as \\p Opc.\nSDValue DAGCombiner::reassociateOpsCommutative(unsigned Opc, const SDLoc &DL,\n                                               SDValue N0, SDValue N1) {\n  EVT VT = N0.getValueType();\n\n  if (N0.getOpcode() != Opc)\n    return SDValue();\n\n  if (DAG.isConstantIntBuildVectorOrConstantInt(N0.getOperand(1))) {\n    if (DAG.isConstantIntBuildVectorOrConstantInt(N1)) {\n      // Reassociate: (op (op x, c1), c2) -> (op x, (op c1, c2))\n      if (SDValue OpNode =\n              DAG.FoldConstantArithmetic(Opc, DL, VT, {N0.getOperand(1), N1}))\n        return DAG.getNode(Opc, DL, VT, N0.getOperand(0), OpNode);\n      return SDValue();\n    }\n    if (N0.hasOneUse()) {\n      // Reassociate: (op (op x, c1), y) -> (op (op x, y), c1)\n      //              iff (op x, c1) has one use\n      SDValue OpNode = DAG.getNode(Opc, SDLoc(N0), VT, N0.getOperand(0), N1);\n      if (!OpNode.getNode())\n        return SDValue();\n      return DAG.getNode(Opc, DL, VT, OpNode, N0.getOperand(1));\n    }\n  }\n  return SDValue();\n}\n\n// Try to reassociate commutative binops.\nSDValue DAGCombiner::reassociateOps(unsigned Opc, const SDLoc &DL, SDValue N0,\n                                    SDValue N1, SDNodeFlags Flags) {\n  assert(TLI.isCommutativeBinOp(Opc) && \"Operation not commutative.\");\n\n  // Floating-point reassociation is not allowed without loose FP math.\n  if (N0.getValueType().isFloatingPoint() ||\n      N1.getValueType().isFloatingPoint())\n    if (!Flags.hasAllowReassociation() || !Flags.hasNoSignedZeros())\n      return SDValue();\n\n  if (SDValue Combined = reassociateOpsCommutative(Opc, DL, N0, N1))\n    return Combined;\n  if (SDValue Combined = reassociateOpsCommutative(Opc, DL, N1, N0))\n    return Combined;\n  return SDValue();\n}\n\nSDValue DAGCombiner::CombineTo(SDNode *N, const SDValue *To, unsigned NumTo,\n                               bool AddTo) {\n  assert(N->getNumValues() == NumTo && \"Broken CombineTo call!\");\n  ++NodesCombined;\n  LLVM_DEBUG(dbgs() << \"\\nReplacing.1 \"; N->dump(&DAG); dbgs() << \"\\nWith: \";\n             To[0].getNode()->dump(&DAG);\n             dbgs() << \" and \" << NumTo - 1 << \" other values\\n\");\n  for (unsigned i = 0, e = NumTo; i != e; ++i)\n    assert((!To[i].getNode() ||\n            N->getValueType(i) == To[i].getValueType()) &&\n           \"Cannot combine value to value of different type!\");\n\n  WorklistRemover DeadNodes(*this);\n  DAG.ReplaceAllUsesWith(N, To);\n  if (AddTo) {\n    // Push the new nodes and any users onto the worklist\n    for (unsigned i = 0, e = NumTo; i != e; ++i) {\n      if (To[i].getNode()) {\n        AddToWorklist(To[i].getNode());\n        AddUsersToWorklist(To[i].getNode());\n      }\n    }\n  }\n\n  // Finally, if the node is now dead, remove it from the graph.  The node\n  // may not be dead if the replacement process recursively simplified to\n  // something else needing this node.\n  if (N->use_empty())\n    deleteAndRecombine(N);\n  return SDValue(N, 0);\n}\n\nvoid DAGCombiner::\nCommitTargetLoweringOpt(const TargetLowering::TargetLoweringOpt &TLO) {\n  // Replace the old value with the new one.\n  ++NodesCombined;\n  LLVM_DEBUG(dbgs() << \"\\nReplacing.2 \"; TLO.Old.getNode()->dump(&DAG);\n             dbgs() << \"\\nWith: \"; TLO.New.getNode()->dump(&DAG);\n             dbgs() << '\\n');\n\n  // Replace all uses.  If any nodes become isomorphic to other nodes and\n  // are deleted, make sure to remove them from our worklist.\n  WorklistRemover DeadNodes(*this);\n  DAG.ReplaceAllUsesOfValueWith(TLO.Old, TLO.New);\n\n  // Push the new node and any (possibly new) users onto the worklist.\n  AddToWorklistWithUsers(TLO.New.getNode());\n\n  // Finally, if the node is now dead, remove it from the graph.  The node\n  // may not be dead if the replacement process recursively simplified to\n  // something else needing this node.\n  if (TLO.Old.getNode()->use_empty())\n    deleteAndRecombine(TLO.Old.getNode());\n}\n\n/// Check the specified integer node value to see if it can be simplified or if\n/// things it uses can be simplified by bit propagation. If so, return true.\nbool DAGCombiner::SimplifyDemandedBits(SDValue Op, const APInt &DemandedBits,\n                                       const APInt &DemandedElts,\n                                       bool AssumeSingleUse) {\n  TargetLowering::TargetLoweringOpt TLO(DAG, LegalTypes, LegalOperations);\n  KnownBits Known;\n  if (!TLI.SimplifyDemandedBits(Op, DemandedBits, DemandedElts, Known, TLO, 0,\n                                AssumeSingleUse))\n    return false;\n\n  // Revisit the node.\n  AddToWorklist(Op.getNode());\n\n  CommitTargetLoweringOpt(TLO);\n  return true;\n}\n\n/// Check the specified vector node value to see if it can be simplified or\n/// if things it uses can be simplified as it only uses some of the elements.\n/// If so, return true.\nbool DAGCombiner::SimplifyDemandedVectorElts(SDValue Op,\n                                             const APInt &DemandedElts,\n                                             bool AssumeSingleUse) {\n  TargetLowering::TargetLoweringOpt TLO(DAG, LegalTypes, LegalOperations);\n  APInt KnownUndef, KnownZero;\n  if (!TLI.SimplifyDemandedVectorElts(Op, DemandedElts, KnownUndef, KnownZero,\n                                      TLO, 0, AssumeSingleUse))\n    return false;\n\n  // Revisit the node.\n  AddToWorklist(Op.getNode());\n\n  CommitTargetLoweringOpt(TLO);\n  return true;\n}\n\nvoid DAGCombiner::ReplaceLoadWithPromotedLoad(SDNode *Load, SDNode *ExtLoad) {\n  SDLoc DL(Load);\n  EVT VT = Load->getValueType(0);\n  SDValue Trunc = DAG.getNode(ISD::TRUNCATE, DL, VT, SDValue(ExtLoad, 0));\n\n  LLVM_DEBUG(dbgs() << \"\\nReplacing.9 \"; Load->dump(&DAG); dbgs() << \"\\nWith: \";\n             Trunc.getNode()->dump(&DAG); dbgs() << '\\n');\n  WorklistRemover DeadNodes(*this);\n  DAG.ReplaceAllUsesOfValueWith(SDValue(Load, 0), Trunc);\n  DAG.ReplaceAllUsesOfValueWith(SDValue(Load, 1), SDValue(ExtLoad, 1));\n  deleteAndRecombine(Load);\n  AddToWorklist(Trunc.getNode());\n}\n\nSDValue DAGCombiner::PromoteOperand(SDValue Op, EVT PVT, bool &Replace) {\n  Replace = false;\n  SDLoc DL(Op);\n  if (ISD::isUNINDEXEDLoad(Op.getNode())) {\n    LoadSDNode *LD = cast<LoadSDNode>(Op);\n    EVT MemVT = LD->getMemoryVT();\n    ISD::LoadExtType ExtType = ISD::isNON_EXTLoad(LD) ? ISD::EXTLOAD\n                                                      : LD->getExtensionType();\n    Replace = true;\n    return DAG.getExtLoad(ExtType, DL, PVT,\n                          LD->getChain(), LD->getBasePtr(),\n                          MemVT, LD->getMemOperand());\n  }\n\n  unsigned Opc = Op.getOpcode();\n  switch (Opc) {\n  default: break;\n  case ISD::AssertSext:\n    if (SDValue Op0 = SExtPromoteOperand(Op.getOperand(0), PVT))\n      return DAG.getNode(ISD::AssertSext, DL, PVT, Op0, Op.getOperand(1));\n    break;\n  case ISD::AssertZext:\n    if (SDValue Op0 = ZExtPromoteOperand(Op.getOperand(0), PVT))\n      return DAG.getNode(ISD::AssertZext, DL, PVT, Op0, Op.getOperand(1));\n    break;\n  case ISD::Constant: {\n    unsigned ExtOpc =\n      Op.getValueType().isByteSized() ? ISD::SIGN_EXTEND : ISD::ZERO_EXTEND;\n    return DAG.getNode(ExtOpc, DL, PVT, Op);\n  }\n  }\n\n  if (!TLI.isOperationLegal(ISD::ANY_EXTEND, PVT))\n    return SDValue();\n  return DAG.getNode(ISD::ANY_EXTEND, DL, PVT, Op);\n}\n\nSDValue DAGCombiner::SExtPromoteOperand(SDValue Op, EVT PVT) {\n  if (!TLI.isOperationLegal(ISD::SIGN_EXTEND_INREG, PVT))\n    return SDValue();\n  EVT OldVT = Op.getValueType();\n  SDLoc DL(Op);\n  bool Replace = false;\n  SDValue NewOp = PromoteOperand(Op, PVT, Replace);\n  if (!NewOp.getNode())\n    return SDValue();\n  AddToWorklist(NewOp.getNode());\n\n  if (Replace)\n    ReplaceLoadWithPromotedLoad(Op.getNode(), NewOp.getNode());\n  return DAG.getNode(ISD::SIGN_EXTEND_INREG, DL, NewOp.getValueType(), NewOp,\n                     DAG.getValueType(OldVT));\n}\n\nSDValue DAGCombiner::ZExtPromoteOperand(SDValue Op, EVT PVT) {\n  EVT OldVT = Op.getValueType();\n  SDLoc DL(Op);\n  bool Replace = false;\n  SDValue NewOp = PromoteOperand(Op, PVT, Replace);\n  if (!NewOp.getNode())\n    return SDValue();\n  AddToWorklist(NewOp.getNode());\n\n  if (Replace)\n    ReplaceLoadWithPromotedLoad(Op.getNode(), NewOp.getNode());\n  return DAG.getZeroExtendInReg(NewOp, DL, OldVT);\n}\n\n/// Promote the specified integer binary operation if the target indicates it is\n/// beneficial. e.g. On x86, it's usually better to promote i16 operations to\n/// i32 since i16 instructions are longer.\nSDValue DAGCombiner::PromoteIntBinOp(SDValue Op) {\n  if (!LegalOperations)\n    return SDValue();\n\n  EVT VT = Op.getValueType();\n  if (VT.isVector() || !VT.isInteger())\n    return SDValue();\n\n  // If operation type is 'undesirable', e.g. i16 on x86, consider\n  // promoting it.\n  unsigned Opc = Op.getOpcode();\n  if (TLI.isTypeDesirableForOp(Opc, VT))\n    return SDValue();\n\n  EVT PVT = VT;\n  // Consult target whether it is a good idea to promote this operation and\n  // what's the right type to promote it to.\n  if (TLI.IsDesirableToPromoteOp(Op, PVT)) {\n    assert(PVT != VT && \"Don't know what type to promote to!\");\n\n    LLVM_DEBUG(dbgs() << \"\\nPromoting \"; Op.getNode()->dump(&DAG));\n\n    bool Replace0 = false;\n    SDValue N0 = Op.getOperand(0);\n    SDValue NN0 = PromoteOperand(N0, PVT, Replace0);\n\n    bool Replace1 = false;\n    SDValue N1 = Op.getOperand(1);\n    SDValue NN1 = PromoteOperand(N1, PVT, Replace1);\n    SDLoc DL(Op);\n\n    SDValue RV =\n        DAG.getNode(ISD::TRUNCATE, DL, VT, DAG.getNode(Opc, DL, PVT, NN0, NN1));\n\n    // We are always replacing N0/N1's use in N and only need additional\n    // replacements if there are additional uses.\n    // Note: We are checking uses of the *nodes* (SDNode) rather than values\n    //       (SDValue) here because the node may reference multiple values\n    //       (for example, the chain value of a load node).\n    Replace0 &= !N0->hasOneUse();\n    Replace1 &= (N0 != N1) && !N1->hasOneUse();\n\n    // Combine Op here so it is preserved past replacements.\n    CombineTo(Op.getNode(), RV);\n\n    // If operands have a use ordering, make sure we deal with\n    // predecessor first.\n    if (Replace0 && Replace1 && N0.getNode()->isPredecessorOf(N1.getNode())) {\n      std::swap(N0, N1);\n      std::swap(NN0, NN1);\n    }\n\n    if (Replace0) {\n      AddToWorklist(NN0.getNode());\n      ReplaceLoadWithPromotedLoad(N0.getNode(), NN0.getNode());\n    }\n    if (Replace1) {\n      AddToWorklist(NN1.getNode());\n      ReplaceLoadWithPromotedLoad(N1.getNode(), NN1.getNode());\n    }\n    return Op;\n  }\n  return SDValue();\n}\n\n/// Promote the specified integer shift operation if the target indicates it is\n/// beneficial. e.g. On x86, it's usually better to promote i16 operations to\n/// i32 since i16 instructions are longer.\nSDValue DAGCombiner::PromoteIntShiftOp(SDValue Op) {\n  if (!LegalOperations)\n    return SDValue();\n\n  EVT VT = Op.getValueType();\n  if (VT.isVector() || !VT.isInteger())\n    return SDValue();\n\n  // If operation type is 'undesirable', e.g. i16 on x86, consider\n  // promoting it.\n  unsigned Opc = Op.getOpcode();\n  if (TLI.isTypeDesirableForOp(Opc, VT))\n    return SDValue();\n\n  EVT PVT = VT;\n  // Consult target whether it is a good idea to promote this operation and\n  // what's the right type to promote it to.\n  if (TLI.IsDesirableToPromoteOp(Op, PVT)) {\n    assert(PVT != VT && \"Don't know what type to promote to!\");\n\n    LLVM_DEBUG(dbgs() << \"\\nPromoting \"; Op.getNode()->dump(&DAG));\n\n    bool Replace = false;\n    SDValue N0 = Op.getOperand(0);\n    SDValue N1 = Op.getOperand(1);\n    if (Opc == ISD::SRA)\n      N0 = SExtPromoteOperand(N0, PVT);\n    else if (Opc == ISD::SRL)\n      N0 = ZExtPromoteOperand(N0, PVT);\n    else\n      N0 = PromoteOperand(N0, PVT, Replace);\n\n    if (!N0.getNode())\n      return SDValue();\n\n    SDLoc DL(Op);\n    SDValue RV =\n        DAG.getNode(ISD::TRUNCATE, DL, VT, DAG.getNode(Opc, DL, PVT, N0, N1));\n\n    if (Replace)\n      ReplaceLoadWithPromotedLoad(Op.getOperand(0).getNode(), N0.getNode());\n\n    // Deal with Op being deleted.\n    if (Op && Op.getOpcode() != ISD::DELETED_NODE)\n      return RV;\n  }\n  return SDValue();\n}\n\nSDValue DAGCombiner::PromoteExtend(SDValue Op) {\n  if (!LegalOperations)\n    return SDValue();\n\n  EVT VT = Op.getValueType();\n  if (VT.isVector() || !VT.isInteger())\n    return SDValue();\n\n  // If operation type is 'undesirable', e.g. i16 on x86, consider\n  // promoting it.\n  unsigned Opc = Op.getOpcode();\n  if (TLI.isTypeDesirableForOp(Opc, VT))\n    return SDValue();\n\n  EVT PVT = VT;\n  // Consult target whether it is a good idea to promote this operation and\n  // what's the right type to promote it to.\n  if (TLI.IsDesirableToPromoteOp(Op, PVT)) {\n    assert(PVT != VT && \"Don't know what type to promote to!\");\n    // fold (aext (aext x)) -> (aext x)\n    // fold (aext (zext x)) -> (zext x)\n    // fold (aext (sext x)) -> (sext x)\n    LLVM_DEBUG(dbgs() << \"\\nPromoting \"; Op.getNode()->dump(&DAG));\n    return DAG.getNode(Op.getOpcode(), SDLoc(Op), VT, Op.getOperand(0));\n  }\n  return SDValue();\n}\n\nbool DAGCombiner::PromoteLoad(SDValue Op) {\n  if (!LegalOperations)\n    return false;\n\n  if (!ISD::isUNINDEXEDLoad(Op.getNode()))\n    return false;\n\n  EVT VT = Op.getValueType();\n  if (VT.isVector() || !VT.isInteger())\n    return false;\n\n  // If operation type is 'undesirable', e.g. i16 on x86, consider\n  // promoting it.\n  unsigned Opc = Op.getOpcode();\n  if (TLI.isTypeDesirableForOp(Opc, VT))\n    return false;\n\n  EVT PVT = VT;\n  // Consult target whether it is a good idea to promote this operation and\n  // what's the right type to promote it to.\n  if (TLI.IsDesirableToPromoteOp(Op, PVT)) {\n    assert(PVT != VT && \"Don't know what type to promote to!\");\n\n    SDLoc DL(Op);\n    SDNode *N = Op.getNode();\n    LoadSDNode *LD = cast<LoadSDNode>(N);\n    EVT MemVT = LD->getMemoryVT();\n    ISD::LoadExtType ExtType = ISD::isNON_EXTLoad(LD) ? ISD::EXTLOAD\n                                                      : LD->getExtensionType();\n    SDValue NewLD = DAG.getExtLoad(ExtType, DL, PVT,\n                                   LD->getChain(), LD->getBasePtr(),\n                                   MemVT, LD->getMemOperand());\n    SDValue Result = DAG.getNode(ISD::TRUNCATE, DL, VT, NewLD);\n\n    LLVM_DEBUG(dbgs() << \"\\nPromoting \"; N->dump(&DAG); dbgs() << \"\\nTo: \";\n               Result.getNode()->dump(&DAG); dbgs() << '\\n');\n    WorklistRemover DeadNodes(*this);\n    DAG.ReplaceAllUsesOfValueWith(SDValue(N, 0), Result);\n    DAG.ReplaceAllUsesOfValueWith(SDValue(N, 1), NewLD.getValue(1));\n    deleteAndRecombine(N);\n    AddToWorklist(Result.getNode());\n    return true;\n  }\n  return false;\n}\n\n/// Recursively delete a node which has no uses and any operands for\n/// which it is the only use.\n///\n/// Note that this both deletes the nodes and removes them from the worklist.\n/// It also adds any nodes who have had a user deleted to the worklist as they\n/// may now have only one use and subject to other combines.\nbool DAGCombiner::recursivelyDeleteUnusedNodes(SDNode *N) {\n  if (!N->use_empty())\n    return false;\n\n  SmallSetVector<SDNode *, 16> Nodes;\n  Nodes.insert(N);\n  do {\n    N = Nodes.pop_back_val();\n    if (!N)\n      continue;\n\n    if (N->use_empty()) {\n      for (const SDValue &ChildN : N->op_values())\n        Nodes.insert(ChildN.getNode());\n\n      removeFromWorklist(N);\n      DAG.DeleteNode(N);\n    } else {\n      AddToWorklist(N);\n    }\n  } while (!Nodes.empty());\n  return true;\n}\n\n//===----------------------------------------------------------------------===//\n//  Main DAG Combiner implementation\n//===----------------------------------------------------------------------===//\n\nvoid DAGCombiner::Run(CombineLevel AtLevel) {\n  // set the instance variables, so that the various visit routines may use it.\n  Level = AtLevel;\n  LegalDAG = Level >= AfterLegalizeDAG;\n  LegalOperations = Level >= AfterLegalizeVectorOps;\n  LegalTypes = Level >= AfterLegalizeTypes;\n\n  WorklistInserter AddNodes(*this);\n\n  // Add all the dag nodes to the worklist.\n  for (SDNode &Node : DAG.allnodes())\n    AddToWorklist(&Node);\n\n  // Create a dummy node (which is not added to allnodes), that adds a reference\n  // to the root node, preventing it from being deleted, and tracking any\n  // changes of the root.\n  HandleSDNode Dummy(DAG.getRoot());\n\n  // While we have a valid worklist entry node, try to combine it.\n  while (SDNode *N = getNextWorklistEntry()) {\n    // If N has no uses, it is dead.  Make sure to revisit all N's operands once\n    // N is deleted from the DAG, since they too may now be dead or may have a\n    // reduced number of uses, allowing other xforms.\n    if (recursivelyDeleteUnusedNodes(N))\n      continue;\n\n    WorklistRemover DeadNodes(*this);\n\n    // If this combine is running after legalizing the DAG, re-legalize any\n    // nodes pulled off the worklist.\n    if (LegalDAG) {\n      SmallSetVector<SDNode *, 16> UpdatedNodes;\n      bool NIsValid = DAG.LegalizeOp(N, UpdatedNodes);\n\n      for (SDNode *LN : UpdatedNodes)\n        AddToWorklistWithUsers(LN);\n\n      if (!NIsValid)\n        continue;\n    }\n\n    LLVM_DEBUG(dbgs() << \"\\nCombining: \"; N->dump(&DAG));\n\n    // Add any operands of the new node which have not yet been combined to the\n    // worklist as well. Because the worklist uniques things already, this\n    // won't repeatedly process the same operand.\n    CombinedNodes.insert(N);\n    for (const SDValue &ChildN : N->op_values())\n      if (!CombinedNodes.count(ChildN.getNode()))\n        AddToWorklist(ChildN.getNode());\n\n    SDValue RV = combine(N);\n\n    if (!RV.getNode())\n      continue;\n\n    ++NodesCombined;\n\n    // If we get back the same node we passed in, rather than a new node or\n    // zero, we know that the node must have defined multiple values and\n    // CombineTo was used.  Since CombineTo takes care of the worklist\n    // mechanics for us, we have no work to do in this case.\n    if (RV.getNode() == N)\n      continue;\n\n    assert(N->getOpcode() != ISD::DELETED_NODE &&\n           RV.getOpcode() != ISD::DELETED_NODE &&\n           \"Node was deleted but visit returned new node!\");\n\n    LLVM_DEBUG(dbgs() << \" ... into: \"; RV.getNode()->dump(&DAG));\n\n    if (N->getNumValues() == RV.getNode()->getNumValues())\n      DAG.ReplaceAllUsesWith(N, RV.getNode());\n    else {\n      assert(N->getValueType(0) == RV.getValueType() &&\n             N->getNumValues() == 1 && \"Type mismatch\");\n      DAG.ReplaceAllUsesWith(N, &RV);\n    }\n\n    // Push the new node and any users onto the worklist.  Omit this if the\n    // new node is the EntryToken (e.g. if a store managed to get optimized\n    // out), because re-visiting the EntryToken and its users will not uncover\n    // any additional opportunities, but there may be a large number of such\n    // users, potentially causing compile time explosion.\n    if (RV.getOpcode() != ISD::EntryToken) {\n      AddToWorklist(RV.getNode());\n      AddUsersToWorklist(RV.getNode());\n    }\n\n    // Finally, if the node is now dead, remove it from the graph.  The node\n    // may not be dead if the replacement process recursively simplified to\n    // something else needing this node. This will also take care of adding any\n    // operands which have lost a user to the worklist.\n    recursivelyDeleteUnusedNodes(N);\n  }\n\n  // If the root changed (e.g. it was a dead load, update the root).\n  DAG.setRoot(Dummy.getValue());\n  DAG.RemoveDeadNodes();\n}\n\nSDValue DAGCombiner::visit(SDNode *N) {\n  switch (N->getOpcode()) {\n  default: break;\n  case ISD::TokenFactor:        return visitTokenFactor(N);\n  case ISD::MERGE_VALUES:       return visitMERGE_VALUES(N);\n  case ISD::ADD:                return visitADD(N);\n  case ISD::SUB:                return visitSUB(N);\n  case ISD::SADDSAT:\n  case ISD::UADDSAT:            return visitADDSAT(N);\n  case ISD::SSUBSAT:\n  case ISD::USUBSAT:            return visitSUBSAT(N);\n  case ISD::ADDC:               return visitADDC(N);\n  case ISD::SADDO:\n  case ISD::UADDO:              return visitADDO(N);\n  case ISD::SUBC:               return visitSUBC(N);\n  case ISD::SSUBO:\n  case ISD::USUBO:              return visitSUBO(N);\n  case ISD::ADDE:               return visitADDE(N);\n  case ISD::ADDCARRY:           return visitADDCARRY(N);\n  case ISD::SADDO_CARRY:        return visitSADDO_CARRY(N);\n  case ISD::SUBE:               return visitSUBE(N);\n  case ISD::SUBCARRY:           return visitSUBCARRY(N);\n  case ISD::SSUBO_CARRY:        return visitSSUBO_CARRY(N);\n  case ISD::SMULFIX:\n  case ISD::SMULFIXSAT:\n  case ISD::UMULFIX:\n  case ISD::UMULFIXSAT:         return visitMULFIX(N);\n  case ISD::MUL:                return visitMUL(N);\n  case ISD::SDIV:               return visitSDIV(N);\n  case ISD::UDIV:               return visitUDIV(N);\n  case ISD::SREM:\n  case ISD::UREM:               return visitREM(N);\n  case ISD::MULHU:              return visitMULHU(N);\n  case ISD::MULHS:              return visitMULHS(N);\n  case ISD::SMUL_LOHI:          return visitSMUL_LOHI(N);\n  case ISD::UMUL_LOHI:          return visitUMUL_LOHI(N);\n  case ISD::SMULO:\n  case ISD::UMULO:              return visitMULO(N);\n  case ISD::SMIN:\n  case ISD::SMAX:\n  case ISD::UMIN:\n  case ISD::UMAX:               return visitIMINMAX(N);\n  case ISD::AND:                return visitAND(N);\n  case ISD::OR:                 return visitOR(N);\n  case ISD::XOR:                return visitXOR(N);\n  case ISD::SHL:                return visitSHL(N);\n  case ISD::SRA:                return visitSRA(N);\n  case ISD::SRL:                return visitSRL(N);\n  case ISD::ROTR:\n  case ISD::ROTL:               return visitRotate(N);\n  case ISD::FSHL:\n  case ISD::FSHR:               return visitFunnelShift(N);\n  case ISD::ABS:                return visitABS(N);\n  case ISD::BSWAP:              return visitBSWAP(N);\n  case ISD::BITREVERSE:         return visitBITREVERSE(N);\n  case ISD::CTLZ:               return visitCTLZ(N);\n  case ISD::CTLZ_ZERO_UNDEF:    return visitCTLZ_ZERO_UNDEF(N);\n  case ISD::CTTZ:               return visitCTTZ(N);\n  case ISD::CTTZ_ZERO_UNDEF:    return visitCTTZ_ZERO_UNDEF(N);\n  case ISD::CTPOP:              return visitCTPOP(N);\n  case ISD::SELECT:             return visitSELECT(N);\n  case ISD::VSELECT:            return visitVSELECT(N);\n  case ISD::SELECT_CC:          return visitSELECT_CC(N);\n  case ISD::SETCC:              return visitSETCC(N);\n  case ISD::SETCCCARRY:         return visitSETCCCARRY(N);\n  case ISD::SIGN_EXTEND:        return visitSIGN_EXTEND(N);\n  case ISD::ZERO_EXTEND:        return visitZERO_EXTEND(N);\n  case ISD::ANY_EXTEND:         return visitANY_EXTEND(N);\n  case ISD::AssertSext:\n  case ISD::AssertZext:         return visitAssertExt(N);\n  case ISD::AssertAlign:        return visitAssertAlign(N);\n  case ISD::SIGN_EXTEND_INREG:  return visitSIGN_EXTEND_INREG(N);\n  case ISD::SIGN_EXTEND_VECTOR_INREG: return visitSIGN_EXTEND_VECTOR_INREG(N);\n  case ISD::ZERO_EXTEND_VECTOR_INREG: return visitZERO_EXTEND_VECTOR_INREG(N);\n  case ISD::TRUNCATE:           return visitTRUNCATE(N);\n  case ISD::BITCAST:            return visitBITCAST(N);\n  case ISD::BUILD_PAIR:         return visitBUILD_PAIR(N);\n  case ISD::FADD:               return visitFADD(N);\n  case ISD::STRICT_FADD:        return visitSTRICT_FADD(N);\n  case ISD::FSUB:               return visitFSUB(N);\n  case ISD::FMUL:               return visitFMUL(N);\n  case ISD::FMA:                return visitFMA(N);\n  case ISD::FDIV:               return visitFDIV(N);\n  case ISD::FREM:               return visitFREM(N);\n  case ISD::FSQRT:              return visitFSQRT(N);\n  case ISD::FCOPYSIGN:          return visitFCOPYSIGN(N);\n  case ISD::FPOW:               return visitFPOW(N);\n  case ISD::SINT_TO_FP:         return visitSINT_TO_FP(N);\n  case ISD::UINT_TO_FP:         return visitUINT_TO_FP(N);\n  case ISD::FP_TO_SINT:         return visitFP_TO_SINT(N);\n  case ISD::FP_TO_UINT:         return visitFP_TO_UINT(N);\n  case ISD::FP_ROUND:           return visitFP_ROUND(N);\n  case ISD::FP_EXTEND:          return visitFP_EXTEND(N);\n  case ISD::FNEG:               return visitFNEG(N);\n  case ISD::FABS:               return visitFABS(N);\n  case ISD::FFLOOR:             return visitFFLOOR(N);\n  case ISD::FMINNUM:            return visitFMINNUM(N);\n  case ISD::FMAXNUM:            return visitFMAXNUM(N);\n  case ISD::FMINIMUM:           return visitFMINIMUM(N);\n  case ISD::FMAXIMUM:           return visitFMAXIMUM(N);\n  case ISD::FCEIL:              return visitFCEIL(N);\n  case ISD::FTRUNC:             return visitFTRUNC(N);\n  case ISD::BRCOND:             return visitBRCOND(N);\n  case ISD::BR_CC:              return visitBR_CC(N);\n  case ISD::LOAD:               return visitLOAD(N);\n  case ISD::STORE:              return visitSTORE(N);\n  case ISD::INSERT_VECTOR_ELT:  return visitINSERT_VECTOR_ELT(N);\n  case ISD::EXTRACT_VECTOR_ELT: return visitEXTRACT_VECTOR_ELT(N);\n  case ISD::BUILD_VECTOR:       return visitBUILD_VECTOR(N);\n  case ISD::CONCAT_VECTORS:     return visitCONCAT_VECTORS(N);\n  case ISD::EXTRACT_SUBVECTOR:  return visitEXTRACT_SUBVECTOR(N);\n  case ISD::VECTOR_SHUFFLE:     return visitVECTOR_SHUFFLE(N);\n  case ISD::SCALAR_TO_VECTOR:   return visitSCALAR_TO_VECTOR(N);\n  case ISD::INSERT_SUBVECTOR:   return visitINSERT_SUBVECTOR(N);\n  case ISD::MGATHER:            return visitMGATHER(N);\n  case ISD::MLOAD:              return visitMLOAD(N);\n  case ISD::MSCATTER:           return visitMSCATTER(N);\n  case ISD::MSTORE:             return visitMSTORE(N);\n  case ISD::LIFETIME_END:       return visitLIFETIME_END(N);\n  case ISD::FP_TO_FP16:         return visitFP_TO_FP16(N);\n  case ISD::FP16_TO_FP:         return visitFP16_TO_FP(N);\n  case ISD::FREEZE:             return visitFREEZE(N);\n  case ISD::VECREDUCE_FADD:\n  case ISD::VECREDUCE_FMUL:\n  case ISD::VECREDUCE_ADD:\n  case ISD::VECREDUCE_MUL:\n  case ISD::VECREDUCE_AND:\n  case ISD::VECREDUCE_OR:\n  case ISD::VECREDUCE_XOR:\n  case ISD::VECREDUCE_SMAX:\n  case ISD::VECREDUCE_SMIN:\n  case ISD::VECREDUCE_UMAX:\n  case ISD::VECREDUCE_UMIN:\n  case ISD::VECREDUCE_FMAX:\n  case ISD::VECREDUCE_FMIN:     return visitVECREDUCE(N);\n  }\n  return SDValue();\n}\n\nSDValue DAGCombiner::combine(SDNode *N) {\n  SDValue RV;\n  if (!DisableGenericCombines)\n    RV = visit(N);\n\n  // If nothing happened, try a target-specific DAG combine.\n  if (!RV.getNode()) {\n    assert(N->getOpcode() != ISD::DELETED_NODE &&\n           \"Node was deleted but visit returned NULL!\");\n\n    if (N->getOpcode() >= ISD::BUILTIN_OP_END ||\n        TLI.hasTargetDAGCombine((ISD::NodeType)N->getOpcode())) {\n\n      // Expose the DAG combiner to the target combiner impls.\n      TargetLowering::DAGCombinerInfo\n        DagCombineInfo(DAG, Level, false, this);\n\n      RV = TLI.PerformDAGCombine(N, DagCombineInfo);\n    }\n  }\n\n  // If nothing happened still, try promoting the operation.\n  if (!RV.getNode()) {\n    switch (N->getOpcode()) {\n    default: break;\n    case ISD::ADD:\n    case ISD::SUB:\n    case ISD::MUL:\n    case ISD::AND:\n    case ISD::OR:\n    case ISD::XOR:\n      RV = PromoteIntBinOp(SDValue(N, 0));\n      break;\n    case ISD::SHL:\n    case ISD::SRA:\n    case ISD::SRL:\n      RV = PromoteIntShiftOp(SDValue(N, 0));\n      break;\n    case ISD::SIGN_EXTEND:\n    case ISD::ZERO_EXTEND:\n    case ISD::ANY_EXTEND:\n      RV = PromoteExtend(SDValue(N, 0));\n      break;\n    case ISD::LOAD:\n      if (PromoteLoad(SDValue(N, 0)))\n        RV = SDValue(N, 0);\n      break;\n    }\n  }\n\n  // If N is a commutative binary node, try to eliminate it if the commuted\n  // version is already present in the DAG.\n  if (!RV.getNode() && TLI.isCommutativeBinOp(N->getOpcode()) &&\n      N->getNumValues() == 1) {\n    SDValue N0 = N->getOperand(0);\n    SDValue N1 = N->getOperand(1);\n\n    // Constant operands are canonicalized to RHS.\n    if (N0 != N1 && (isa<ConstantSDNode>(N0) || !isa<ConstantSDNode>(N1))) {\n      SDValue Ops[] = {N1, N0};\n      SDNode *CSENode = DAG.getNodeIfExists(N->getOpcode(), N->getVTList(), Ops,\n                                            N->getFlags());\n      if (CSENode)\n        return SDValue(CSENode, 0);\n    }\n  }\n\n  return RV;\n}\n\n/// Given a node, return its input chain if it has one, otherwise return a null\n/// sd operand.\nstatic SDValue getInputChainForNode(SDNode *N) {\n  if (unsigned NumOps = N->getNumOperands()) {\n    if (N->getOperand(0).getValueType() == MVT::Other)\n      return N->getOperand(0);\n    if (N->getOperand(NumOps-1).getValueType() == MVT::Other)\n      return N->getOperand(NumOps-1);\n    for (unsigned i = 1; i < NumOps-1; ++i)\n      if (N->getOperand(i).getValueType() == MVT::Other)\n        return N->getOperand(i);\n  }\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitTokenFactor(SDNode *N) {\n  // If N has two operands, where one has an input chain equal to the other,\n  // the 'other' chain is redundant.\n  if (N->getNumOperands() == 2) {\n    if (getInputChainForNode(N->getOperand(0).getNode()) == N->getOperand(1))\n      return N->getOperand(0);\n    if (getInputChainForNode(N->getOperand(1).getNode()) == N->getOperand(0))\n      return N->getOperand(1);\n  }\n\n  // Don't simplify token factors if optnone.\n  if (OptLevel == CodeGenOpt::None)\n    return SDValue();\n\n  // Don't simplify the token factor if the node itself has too many operands.\n  if (N->getNumOperands() > TokenFactorInlineLimit)\n    return SDValue();\n\n  // If the sole user is a token factor, we should make sure we have a\n  // chance to merge them together. This prevents TF chains from inhibiting\n  // optimizations.\n  if (N->hasOneUse() && N->use_begin()->getOpcode() == ISD::TokenFactor)\n    AddToWorklist(*(N->use_begin()));\n\n  SmallVector<SDNode *, 8> TFs;     // List of token factors to visit.\n  SmallVector<SDValue, 8> Ops;      // Ops for replacing token factor.\n  SmallPtrSet<SDNode*, 16> SeenOps;\n  bool Changed = false;             // If we should replace this token factor.\n\n  // Start out with this token factor.\n  TFs.push_back(N);\n\n  // Iterate through token factors.  The TFs grows when new token factors are\n  // encountered.\n  for (unsigned i = 0; i < TFs.size(); ++i) {\n    // Limit number of nodes to inline, to avoid quadratic compile times.\n    // We have to add the outstanding Token Factors to Ops, otherwise we might\n    // drop Ops from the resulting Token Factors.\n    if (Ops.size() > TokenFactorInlineLimit) {\n      for (unsigned j = i; j < TFs.size(); j++)\n        Ops.emplace_back(TFs[j], 0);\n      // Drop unprocessed Token Factors from TFs, so we do not add them to the\n      // combiner worklist later.\n      TFs.resize(i);\n      break;\n    }\n\n    SDNode *TF = TFs[i];\n    // Check each of the operands.\n    for (const SDValue &Op : TF->op_values()) {\n      switch (Op.getOpcode()) {\n      case ISD::EntryToken:\n        // Entry tokens don't need to be added to the list. They are\n        // redundant.\n        Changed = true;\n        break;\n\n      case ISD::TokenFactor:\n        if (Op.hasOneUse() && !is_contained(TFs, Op.getNode())) {\n          // Queue up for processing.\n          TFs.push_back(Op.getNode());\n          Changed = true;\n          break;\n        }\n        LLVM_FALLTHROUGH;\n\n      default:\n        // Only add if it isn't already in the list.\n        if (SeenOps.insert(Op.getNode()).second)\n          Ops.push_back(Op);\n        else\n          Changed = true;\n        break;\n      }\n    }\n  }\n\n  // Re-visit inlined Token Factors, to clean them up in case they have been\n  // removed. Skip the first Token Factor, as this is the current node.\n  for (unsigned i = 1, e = TFs.size(); i < e; i++)\n    AddToWorklist(TFs[i]);\n\n  // Remove Nodes that are chained to another node in the list. Do so\n  // by walking up chains breath-first stopping when we've seen\n  // another operand. In general we must climb to the EntryNode, but we can exit\n  // early if we find all remaining work is associated with just one operand as\n  // no further pruning is possible.\n\n  // List of nodes to search through and original Ops from which they originate.\n  SmallVector<std::pair<SDNode *, unsigned>, 8> Worklist;\n  SmallVector<unsigned, 8> OpWorkCount; // Count of work for each Op.\n  SmallPtrSet<SDNode *, 16> SeenChains;\n  bool DidPruneOps = false;\n\n  unsigned NumLeftToConsider = 0;\n  for (const SDValue &Op : Ops) {\n    Worklist.push_back(std::make_pair(Op.getNode(), NumLeftToConsider++));\n    OpWorkCount.push_back(1);\n  }\n\n  auto AddToWorklist = [&](unsigned CurIdx, SDNode *Op, unsigned OpNumber) {\n    // If this is an Op, we can remove the op from the list. Remark any\n    // search associated with it as from the current OpNumber.\n    if (SeenOps.contains(Op)) {\n      Changed = true;\n      DidPruneOps = true;\n      unsigned OrigOpNumber = 0;\n      while (OrigOpNumber < Ops.size() && Ops[OrigOpNumber].getNode() != Op)\n        OrigOpNumber++;\n      assert((OrigOpNumber != Ops.size()) &&\n             \"expected to find TokenFactor Operand\");\n      // Re-mark worklist from OrigOpNumber to OpNumber\n      for (unsigned i = CurIdx + 1; i < Worklist.size(); ++i) {\n        if (Worklist[i].second == OrigOpNumber) {\n          Worklist[i].second = OpNumber;\n        }\n      }\n      OpWorkCount[OpNumber] += OpWorkCount[OrigOpNumber];\n      OpWorkCount[OrigOpNumber] = 0;\n      NumLeftToConsider--;\n    }\n    // Add if it's a new chain\n    if (SeenChains.insert(Op).second) {\n      OpWorkCount[OpNumber]++;\n      Worklist.push_back(std::make_pair(Op, OpNumber));\n    }\n  };\n\n  for (unsigned i = 0; i < Worklist.size() && i < 1024; ++i) {\n    // We need at least be consider at least 2 Ops to prune.\n    if (NumLeftToConsider <= 1)\n      break;\n    auto CurNode = Worklist[i].first;\n    auto CurOpNumber = Worklist[i].second;\n    assert((OpWorkCount[CurOpNumber] > 0) &&\n           \"Node should not appear in worklist\");\n    switch (CurNode->getOpcode()) {\n    case ISD::EntryToken:\n      // Hitting EntryToken is the only way for the search to terminate without\n      // hitting\n      // another operand's search. Prevent us from marking this operand\n      // considered.\n      NumLeftToConsider++;\n      break;\n    case ISD::TokenFactor:\n      for (const SDValue &Op : CurNode->op_values())\n        AddToWorklist(i, Op.getNode(), CurOpNumber);\n      break;\n    case ISD::LIFETIME_START:\n    case ISD::LIFETIME_END:\n    case ISD::CopyFromReg:\n    case ISD::CopyToReg:\n      AddToWorklist(i, CurNode->getOperand(0).getNode(), CurOpNumber);\n      break;\n    default:\n      if (auto *MemNode = dyn_cast<MemSDNode>(CurNode))\n        AddToWorklist(i, MemNode->getChain().getNode(), CurOpNumber);\n      break;\n    }\n    OpWorkCount[CurOpNumber]--;\n    if (OpWorkCount[CurOpNumber] == 0)\n      NumLeftToConsider--;\n  }\n\n  // If we've changed things around then replace token factor.\n  if (Changed) {\n    SDValue Result;\n    if (Ops.empty()) {\n      // The entry token is the only possible outcome.\n      Result = DAG.getEntryNode();\n    } else {\n      if (DidPruneOps) {\n        SmallVector<SDValue, 8> PrunedOps;\n        //\n        for (const SDValue &Op : Ops) {\n          if (SeenChains.count(Op.getNode()) == 0)\n            PrunedOps.push_back(Op);\n        }\n        Result = DAG.getTokenFactor(SDLoc(N), PrunedOps);\n      } else {\n        Result = DAG.getTokenFactor(SDLoc(N), Ops);\n      }\n    }\n    return Result;\n  }\n  return SDValue();\n}\n\n/// MERGE_VALUES can always be eliminated.\nSDValue DAGCombiner::visitMERGE_VALUES(SDNode *N) {\n  WorklistRemover DeadNodes(*this);\n  // Replacing results may cause a different MERGE_VALUES to suddenly\n  // be CSE'd with N, and carry its uses with it. Iterate until no\n  // uses remain, to ensure that the node can be safely deleted.\n  // First add the users of this node to the work list so that they\n  // can be tried again once they have new operands.\n  AddUsersToWorklist(N);\n  do {\n    // Do as a single replacement to avoid rewalking use lists.\n    SmallVector<SDValue, 8> Ops;\n    for (unsigned i = 0, e = N->getNumOperands(); i != e; ++i)\n      Ops.push_back(N->getOperand(i));\n    DAG.ReplaceAllUsesWith(N, Ops.data());\n  } while (!N->use_empty());\n  deleteAndRecombine(N);\n  return SDValue(N, 0);   // Return N so it doesn't get rechecked!\n}\n\n/// If \\p N is a ConstantSDNode with isOpaque() == false return it casted to a\n/// ConstantSDNode pointer else nullptr.\nstatic ConstantSDNode *getAsNonOpaqueConstant(SDValue N) {\n  ConstantSDNode *Const = dyn_cast<ConstantSDNode>(N);\n  return Const != nullptr && !Const->isOpaque() ? Const : nullptr;\n}\n\n/// Return true if 'Use' is a load or a store that uses N as its base pointer\n/// and that N may be folded in the load / store addressing mode.\nstatic bool canFoldInAddressingMode(SDNode *N, SDNode *Use, SelectionDAG &DAG,\n                                    const TargetLowering &TLI) {\n  EVT VT;\n  unsigned AS;\n\n  if (LoadSDNode *LD = dyn_cast<LoadSDNode>(Use)) {\n    if (LD->isIndexed() || LD->getBasePtr().getNode() != N)\n      return false;\n    VT = LD->getMemoryVT();\n    AS = LD->getAddressSpace();\n  } else if (StoreSDNode *ST = dyn_cast<StoreSDNode>(Use)) {\n    if (ST->isIndexed() || ST->getBasePtr().getNode() != N)\n      return false;\n    VT = ST->getMemoryVT();\n    AS = ST->getAddressSpace();\n  } else if (MaskedLoadSDNode *LD = dyn_cast<MaskedLoadSDNode>(Use)) {\n    if (LD->isIndexed() || LD->getBasePtr().getNode() != N)\n      return false;\n    VT = LD->getMemoryVT();\n    AS = LD->getAddressSpace();\n  } else if (MaskedStoreSDNode *ST = dyn_cast<MaskedStoreSDNode>(Use)) {\n    if (ST->isIndexed() || ST->getBasePtr().getNode() != N)\n      return false;\n    VT = ST->getMemoryVT();\n    AS = ST->getAddressSpace();\n  } else\n    return false;\n\n  TargetLowering::AddrMode AM;\n  if (N->getOpcode() == ISD::ADD) {\n    AM.HasBaseReg = true;\n    ConstantSDNode *Offset = dyn_cast<ConstantSDNode>(N->getOperand(1));\n    if (Offset)\n      // [reg +/- imm]\n      AM.BaseOffs = Offset->getSExtValue();\n    else\n      // [reg +/- reg]\n      AM.Scale = 1;\n  } else if (N->getOpcode() == ISD::SUB) {\n    AM.HasBaseReg = true;\n    ConstantSDNode *Offset = dyn_cast<ConstantSDNode>(N->getOperand(1));\n    if (Offset)\n      // [reg +/- imm]\n      AM.BaseOffs = -Offset->getSExtValue();\n    else\n      // [reg +/- reg]\n      AM.Scale = 1;\n  } else\n    return false;\n\n  return TLI.isLegalAddressingMode(DAG.getDataLayout(), AM,\n                                   VT.getTypeForEVT(*DAG.getContext()), AS);\n}\n\nSDValue DAGCombiner::foldBinOpIntoSelect(SDNode *BO) {\n  assert(TLI.isBinOp(BO->getOpcode()) && BO->getNumValues() == 1 &&\n         \"Unexpected binary operator\");\n\n  // Don't do this unless the old select is going away. We want to eliminate the\n  // binary operator, not replace a binop with a select.\n  // TODO: Handle ISD::SELECT_CC.\n  unsigned SelOpNo = 0;\n  SDValue Sel = BO->getOperand(0);\n  if (Sel.getOpcode() != ISD::SELECT || !Sel.hasOneUse()) {\n    SelOpNo = 1;\n    Sel = BO->getOperand(1);\n  }\n\n  if (Sel.getOpcode() != ISD::SELECT || !Sel.hasOneUse())\n    return SDValue();\n\n  SDValue CT = Sel.getOperand(1);\n  if (!isConstantOrConstantVector(CT, true) &&\n      !DAG.isConstantFPBuildVectorOrConstantFP(CT))\n    return SDValue();\n\n  SDValue CF = Sel.getOperand(2);\n  if (!isConstantOrConstantVector(CF, true) &&\n      !DAG.isConstantFPBuildVectorOrConstantFP(CF))\n    return SDValue();\n\n  // Bail out if any constants are opaque because we can't constant fold those.\n  // The exception is \"and\" and \"or\" with either 0 or -1 in which case we can\n  // propagate non constant operands into select. I.e.:\n  // and (select Cond, 0, -1), X --> select Cond, 0, X\n  // or X, (select Cond, -1, 0) --> select Cond, -1, X\n  auto BinOpcode = BO->getOpcode();\n  bool CanFoldNonConst =\n      (BinOpcode == ISD::AND || BinOpcode == ISD::OR) &&\n      (isNullOrNullSplat(CT) || isAllOnesOrAllOnesSplat(CT)) &&\n      (isNullOrNullSplat(CF) || isAllOnesOrAllOnesSplat(CF));\n\n  SDValue CBO = BO->getOperand(SelOpNo ^ 1);\n  if (!CanFoldNonConst &&\n      !isConstantOrConstantVector(CBO, true) &&\n      !DAG.isConstantFPBuildVectorOrConstantFP(CBO))\n    return SDValue();\n\n  EVT VT = BO->getValueType(0);\n\n  // We have a select-of-constants followed by a binary operator with a\n  // constant. Eliminate the binop by pulling the constant math into the select.\n  // Example: add (select Cond, CT, CF), CBO --> select Cond, CT + CBO, CF + CBO\n  SDLoc DL(Sel);\n  SDValue NewCT = SelOpNo ? DAG.getNode(BinOpcode, DL, VT, CBO, CT)\n                          : DAG.getNode(BinOpcode, DL, VT, CT, CBO);\n  if (!CanFoldNonConst && !NewCT.isUndef() &&\n      !isConstantOrConstantVector(NewCT, true) &&\n      !DAG.isConstantFPBuildVectorOrConstantFP(NewCT))\n    return SDValue();\n\n  SDValue NewCF = SelOpNo ? DAG.getNode(BinOpcode, DL, VT, CBO, CF)\n                          : DAG.getNode(BinOpcode, DL, VT, CF, CBO);\n  if (!CanFoldNonConst && !NewCF.isUndef() &&\n      !isConstantOrConstantVector(NewCF, true) &&\n      !DAG.isConstantFPBuildVectorOrConstantFP(NewCF))\n    return SDValue();\n\n  SDValue SelectOp = DAG.getSelect(DL, VT, Sel.getOperand(0), NewCT, NewCF);\n  SelectOp->setFlags(BO->getFlags());\n  return SelectOp;\n}\n\nstatic SDValue foldAddSubBoolOfMaskedVal(SDNode *N, SelectionDAG &DAG) {\n  assert((N->getOpcode() == ISD::ADD || N->getOpcode() == ISD::SUB) &&\n         \"Expecting add or sub\");\n\n  // Match a constant operand and a zext operand for the math instruction:\n  // add Z, C\n  // sub C, Z\n  bool IsAdd = N->getOpcode() == ISD::ADD;\n  SDValue C = IsAdd ? N->getOperand(1) : N->getOperand(0);\n  SDValue Z = IsAdd ? N->getOperand(0) : N->getOperand(1);\n  auto *CN = dyn_cast<ConstantSDNode>(C);\n  if (!CN || Z.getOpcode() != ISD::ZERO_EXTEND)\n    return SDValue();\n\n  // Match the zext operand as a setcc of a boolean.\n  if (Z.getOperand(0).getOpcode() != ISD::SETCC ||\n      Z.getOperand(0).getValueType() != MVT::i1)\n    return SDValue();\n\n  // Match the compare as: setcc (X & 1), 0, eq.\n  SDValue SetCC = Z.getOperand(0);\n  ISD::CondCode CC = cast<CondCodeSDNode>(SetCC->getOperand(2))->get();\n  if (CC != ISD::SETEQ || !isNullConstant(SetCC.getOperand(1)) ||\n      SetCC.getOperand(0).getOpcode() != ISD::AND ||\n      !isOneConstant(SetCC.getOperand(0).getOperand(1)))\n    return SDValue();\n\n  // We are adding/subtracting a constant and an inverted low bit. Turn that\n  // into a subtract/add of the low bit with incremented/decremented constant:\n  // add (zext i1 (seteq (X & 1), 0)), C --> sub C+1, (zext (X & 1))\n  // sub C, (zext i1 (seteq (X & 1), 0)) --> add C-1, (zext (X & 1))\n  EVT VT = C.getValueType();\n  SDLoc DL(N);\n  SDValue LowBit = DAG.getZExtOrTrunc(SetCC.getOperand(0), DL, VT);\n  SDValue C1 = IsAdd ? DAG.getConstant(CN->getAPIntValue() + 1, DL, VT) :\n                       DAG.getConstant(CN->getAPIntValue() - 1, DL, VT);\n  return DAG.getNode(IsAdd ? ISD::SUB : ISD::ADD, DL, VT, C1, LowBit);\n}\n\n/// Try to fold a 'not' shifted sign-bit with add/sub with constant operand into\n/// a shift and add with a different constant.\nstatic SDValue foldAddSubOfSignBit(SDNode *N, SelectionDAG &DAG) {\n  assert((N->getOpcode() == ISD::ADD || N->getOpcode() == ISD::SUB) &&\n         \"Expecting add or sub\");\n\n  // We need a constant operand for the add/sub, and the other operand is a\n  // logical shift right: add (srl), C or sub C, (srl).\n  bool IsAdd = N->getOpcode() == ISD::ADD;\n  SDValue ConstantOp = IsAdd ? N->getOperand(1) : N->getOperand(0);\n  SDValue ShiftOp = IsAdd ? N->getOperand(0) : N->getOperand(1);\n  if (!DAG.isConstantIntBuildVectorOrConstantInt(ConstantOp) ||\n      ShiftOp.getOpcode() != ISD::SRL)\n    return SDValue();\n\n  // The shift must be of a 'not' value.\n  SDValue Not = ShiftOp.getOperand(0);\n  if (!Not.hasOneUse() || !isBitwiseNot(Not))\n    return SDValue();\n\n  // The shift must be moving the sign bit to the least-significant-bit.\n  EVT VT = ShiftOp.getValueType();\n  SDValue ShAmt = ShiftOp.getOperand(1);\n  ConstantSDNode *ShAmtC = isConstOrConstSplat(ShAmt);\n  if (!ShAmtC || ShAmtC->getAPIntValue() != (VT.getScalarSizeInBits() - 1))\n    return SDValue();\n\n  // Eliminate the 'not' by adjusting the shift and add/sub constant:\n  // add (srl (not X), 31), C --> add (sra X, 31), (C + 1)\n  // sub C, (srl (not X), 31) --> add (srl X, 31), (C - 1)\n  SDLoc DL(N);\n  auto ShOpcode = IsAdd ? ISD::SRA : ISD::SRL;\n  SDValue NewShift = DAG.getNode(ShOpcode, DL, VT, Not.getOperand(0), ShAmt);\n  if (SDValue NewC =\n          DAG.FoldConstantArithmetic(IsAdd ? ISD::ADD : ISD::SUB, DL, VT,\n                                     {ConstantOp, DAG.getConstant(1, DL, VT)}))\n    return DAG.getNode(ISD::ADD, DL, VT, NewShift, NewC);\n  return SDValue();\n}\n\n/// Try to fold a node that behaves like an ADD (note that N isn't necessarily\n/// an ISD::ADD here, it could for example be an ISD::OR if we know that there\n/// are no common bits set in the operands).\nSDValue DAGCombiner::visitADDLike(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  EVT VT = N0.getValueType();\n  SDLoc DL(N);\n\n  // fold vector ops\n  if (VT.isVector()) {\n    if (SDValue FoldedVOp = SimplifyVBinOp(N))\n      return FoldedVOp;\n\n    // fold (add x, 0) -> x, vector edition\n    if (ISD::isBuildVectorAllZeros(N1.getNode()))\n      return N0;\n    if (ISD::isBuildVectorAllZeros(N0.getNode()))\n      return N1;\n  }\n\n  // fold (add x, undef) -> undef\n  if (N0.isUndef())\n    return N0;\n\n  if (N1.isUndef())\n    return N1;\n\n  if (DAG.isConstantIntBuildVectorOrConstantInt(N0)) {\n    // canonicalize constant to RHS\n    if (!DAG.isConstantIntBuildVectorOrConstantInt(N1))\n      return DAG.getNode(ISD::ADD, DL, VT, N1, N0);\n    // fold (add c1, c2) -> c1+c2\n    return DAG.FoldConstantArithmetic(ISD::ADD, DL, VT, {N0, N1});\n  }\n\n  // fold (add x, 0) -> x\n  if (isNullConstant(N1))\n    return N0;\n\n  if (isConstantOrConstantVector(N1, /* NoOpaque */ true)) {\n    // fold ((A-c1)+c2) -> (A+(c2-c1))\n    if (N0.getOpcode() == ISD::SUB &&\n        isConstantOrConstantVector(N0.getOperand(1), /* NoOpaque */ true)) {\n      SDValue Sub =\n          DAG.FoldConstantArithmetic(ISD::SUB, DL, VT, {N1, N0.getOperand(1)});\n      assert(Sub && \"Constant folding failed\");\n      return DAG.getNode(ISD::ADD, DL, VT, N0.getOperand(0), Sub);\n    }\n\n    // fold ((c1-A)+c2) -> (c1+c2)-A\n    if (N0.getOpcode() == ISD::SUB &&\n        isConstantOrConstantVector(N0.getOperand(0), /* NoOpaque */ true)) {\n      SDValue Add =\n          DAG.FoldConstantArithmetic(ISD::ADD, DL, VT, {N1, N0.getOperand(0)});\n      assert(Add && \"Constant folding failed\");\n      return DAG.getNode(ISD::SUB, DL, VT, Add, N0.getOperand(1));\n    }\n\n    // add (sext i1 X), 1 -> zext (not i1 X)\n    // We don't transform this pattern:\n    //   add (zext i1 X), -1 -> sext (not i1 X)\n    // because most (?) targets generate better code for the zext form.\n    if (N0.getOpcode() == ISD::SIGN_EXTEND && N0.hasOneUse() &&\n        isOneOrOneSplat(N1)) {\n      SDValue X = N0.getOperand(0);\n      if ((!LegalOperations ||\n           (TLI.isOperationLegal(ISD::XOR, X.getValueType()) &&\n            TLI.isOperationLegal(ISD::ZERO_EXTEND, VT))) &&\n          X.getScalarValueSizeInBits() == 1) {\n        SDValue Not = DAG.getNOT(DL, X, X.getValueType());\n        return DAG.getNode(ISD::ZERO_EXTEND, DL, VT, Not);\n      }\n    }\n\n    // Fold (add (or x, c0), c1) -> (add x, (c0 + c1)) if (or x, c0) is\n    // equivalent to (add x, c0).\n    if (N0.getOpcode() == ISD::OR &&\n        isConstantOrConstantVector(N0.getOperand(1), /* NoOpaque */ true) &&\n        DAG.haveNoCommonBitsSet(N0.getOperand(0), N0.getOperand(1))) {\n      if (SDValue Add0 = DAG.FoldConstantArithmetic(ISD::ADD, DL, VT,\n                                                    {N1, N0.getOperand(1)}))\n        return DAG.getNode(ISD::ADD, DL, VT, N0.getOperand(0), Add0);\n    }\n  }\n\n  if (SDValue NewSel = foldBinOpIntoSelect(N))\n    return NewSel;\n\n  // reassociate add\n  if (!reassociationCanBreakAddressingModePattern(ISD::ADD, DL, N0, N1)) {\n    if (SDValue RADD = reassociateOps(ISD::ADD, DL, N0, N1, N->getFlags()))\n      return RADD;\n  }\n  // fold ((0-A) + B) -> B-A\n  if (N0.getOpcode() == ISD::SUB && isNullOrNullSplat(N0.getOperand(0)))\n    return DAG.getNode(ISD::SUB, DL, VT, N1, N0.getOperand(1));\n\n  // fold (A + (0-B)) -> A-B\n  if (N1.getOpcode() == ISD::SUB && isNullOrNullSplat(N1.getOperand(0)))\n    return DAG.getNode(ISD::SUB, DL, VT, N0, N1.getOperand(1));\n\n  // fold (A+(B-A)) -> B\n  if (N1.getOpcode() == ISD::SUB && N0 == N1.getOperand(1))\n    return N1.getOperand(0);\n\n  // fold ((B-A)+A) -> B\n  if (N0.getOpcode() == ISD::SUB && N1 == N0.getOperand(1))\n    return N0.getOperand(0);\n\n  // fold ((A-B)+(C-A)) -> (C-B)\n  if (N0.getOpcode() == ISD::SUB && N1.getOpcode() == ISD::SUB &&\n      N0.getOperand(0) == N1.getOperand(1))\n    return DAG.getNode(ISD::SUB, DL, VT, N1.getOperand(0),\n                       N0.getOperand(1));\n\n  // fold ((A-B)+(B-C)) -> (A-C)\n  if (N0.getOpcode() == ISD::SUB && N1.getOpcode() == ISD::SUB &&\n      N0.getOperand(1) == N1.getOperand(0))\n    return DAG.getNode(ISD::SUB, DL, VT, N0.getOperand(0),\n                       N1.getOperand(1));\n\n  // fold (A+(B-(A+C))) to (B-C)\n  if (N1.getOpcode() == ISD::SUB && N1.getOperand(1).getOpcode() == ISD::ADD &&\n      N0 == N1.getOperand(1).getOperand(0))\n    return DAG.getNode(ISD::SUB, DL, VT, N1.getOperand(0),\n                       N1.getOperand(1).getOperand(1));\n\n  // fold (A+(B-(C+A))) to (B-C)\n  if (N1.getOpcode() == ISD::SUB && N1.getOperand(1).getOpcode() == ISD::ADD &&\n      N0 == N1.getOperand(1).getOperand(1))\n    return DAG.getNode(ISD::SUB, DL, VT, N1.getOperand(0),\n                       N1.getOperand(1).getOperand(0));\n\n  // fold (A+((B-A)+or-C)) to (B+or-C)\n  if ((N1.getOpcode() == ISD::SUB || N1.getOpcode() == ISD::ADD) &&\n      N1.getOperand(0).getOpcode() == ISD::SUB &&\n      N0 == N1.getOperand(0).getOperand(1))\n    return DAG.getNode(N1.getOpcode(), DL, VT, N1.getOperand(0).getOperand(0),\n                       N1.getOperand(1));\n\n  // fold (A-B)+(C-D) to (A+C)-(B+D) when A or C is constant\n  if (N0.getOpcode() == ISD::SUB && N1.getOpcode() == ISD::SUB) {\n    SDValue N00 = N0.getOperand(0);\n    SDValue N01 = N0.getOperand(1);\n    SDValue N10 = N1.getOperand(0);\n    SDValue N11 = N1.getOperand(1);\n\n    if (isConstantOrConstantVector(N00) || isConstantOrConstantVector(N10))\n      return DAG.getNode(ISD::SUB, DL, VT,\n                         DAG.getNode(ISD::ADD, SDLoc(N0), VT, N00, N10),\n                         DAG.getNode(ISD::ADD, SDLoc(N1), VT, N01, N11));\n  }\n\n  // fold (add (umax X, C), -C) --> (usubsat X, C)\n  if (N0.getOpcode() == ISD::UMAX && hasOperation(ISD::USUBSAT, VT)) {\n    auto MatchUSUBSAT = [](ConstantSDNode *Max, ConstantSDNode *Op) {\n      return (!Max && !Op) ||\n             (Max && Op && Max->getAPIntValue() == (-Op->getAPIntValue()));\n    };\n    if (ISD::matchBinaryPredicate(N0.getOperand(1), N1, MatchUSUBSAT,\n                                  /*AllowUndefs*/ true))\n      return DAG.getNode(ISD::USUBSAT, DL, VT, N0.getOperand(0),\n                         N0.getOperand(1));\n  }\n\n  if (SimplifyDemandedBits(SDValue(N, 0)))\n    return SDValue(N, 0);\n\n  if (isOneOrOneSplat(N1)) {\n    // fold (add (xor a, -1), 1) -> (sub 0, a)\n    if (isBitwiseNot(N0))\n      return DAG.getNode(ISD::SUB, DL, VT, DAG.getConstant(0, DL, VT),\n                         N0.getOperand(0));\n\n    // fold (add (add (xor a, -1), b), 1) -> (sub b, a)\n    if (N0.getOpcode() == ISD::ADD ||\n        N0.getOpcode() == ISD::UADDO ||\n        N0.getOpcode() == ISD::SADDO) {\n      SDValue A, Xor;\n\n      if (isBitwiseNot(N0.getOperand(0))) {\n        A = N0.getOperand(1);\n        Xor = N0.getOperand(0);\n      } else if (isBitwiseNot(N0.getOperand(1))) {\n        A = N0.getOperand(0);\n        Xor = N0.getOperand(1);\n      }\n\n      if (Xor)\n        return DAG.getNode(ISD::SUB, DL, VT, A, Xor.getOperand(0));\n    }\n\n    // Look for:\n    //   add (add x, y), 1\n    // And if the target does not like this form then turn into:\n    //   sub y, (xor x, -1)\n    if (!TLI.preferIncOfAddToSubOfNot(VT) && N0.hasOneUse() &&\n        N0.getOpcode() == ISD::ADD) {\n      SDValue Not = DAG.getNode(ISD::XOR, DL, VT, N0.getOperand(0),\n                                DAG.getAllOnesConstant(DL, VT));\n      return DAG.getNode(ISD::SUB, DL, VT, N0.getOperand(1), Not);\n    }\n  }\n\n  // (x - y) + -1  ->  add (xor y, -1), x\n  if (N0.hasOneUse() && N0.getOpcode() == ISD::SUB &&\n      isAllOnesOrAllOnesSplat(N1)) {\n    SDValue Xor = DAG.getNode(ISD::XOR, DL, VT, N0.getOperand(1), N1);\n    return DAG.getNode(ISD::ADD, DL, VT, Xor, N0.getOperand(0));\n  }\n\n  if (SDValue Combined = visitADDLikeCommutative(N0, N1, N))\n    return Combined;\n\n  if (SDValue Combined = visitADDLikeCommutative(N1, N0, N))\n    return Combined;\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitADD(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  EVT VT = N0.getValueType();\n  SDLoc DL(N);\n\n  if (SDValue Combined = visitADDLike(N))\n    return Combined;\n\n  if (SDValue V = foldAddSubBoolOfMaskedVal(N, DAG))\n    return V;\n\n  if (SDValue V = foldAddSubOfSignBit(N, DAG))\n    return V;\n\n  // fold (a+b) -> (a|b) iff a and b share no bits.\n  if ((!LegalOperations || TLI.isOperationLegal(ISD::OR, VT)) &&\n      DAG.haveNoCommonBitsSet(N0, N1))\n    return DAG.getNode(ISD::OR, DL, VT, N0, N1);\n\n  // Fold (add (vscale * C0), (vscale * C1)) to (vscale * (C0 + C1)).\n  if (N0.getOpcode() == ISD::VSCALE && N1.getOpcode() == ISD::VSCALE) {\n    const APInt &C0 = N0->getConstantOperandAPInt(0);\n    const APInt &C1 = N1->getConstantOperandAPInt(0);\n    return DAG.getVScale(DL, VT, C0 + C1);\n  }\n\n  // fold a+vscale(c1)+vscale(c2) -> a+vscale(c1+c2)\n  if ((N0.getOpcode() == ISD::ADD) &&\n      (N0.getOperand(1).getOpcode() == ISD::VSCALE) &&\n      (N1.getOpcode() == ISD::VSCALE)) {\n    const APInt &VS0 = N0.getOperand(1)->getConstantOperandAPInt(0);\n    const APInt &VS1 = N1->getConstantOperandAPInt(0);\n    SDValue VS = DAG.getVScale(DL, VT, VS0 + VS1);\n    return DAG.getNode(ISD::ADD, DL, VT, N0.getOperand(0), VS);\n  }\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitADDSAT(SDNode *N) {\n  unsigned Opcode = N->getOpcode();\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  EVT VT = N0.getValueType();\n  SDLoc DL(N);\n\n  // fold vector ops\n  if (VT.isVector()) {\n    // TODO SimplifyVBinOp\n\n    // fold (add_sat x, 0) -> x, vector edition\n    if (ISD::isBuildVectorAllZeros(N1.getNode()))\n      return N0;\n    if (ISD::isBuildVectorAllZeros(N0.getNode()))\n      return N1;\n  }\n\n  // fold (add_sat x, undef) -> -1\n  if (N0.isUndef() || N1.isUndef())\n    return DAG.getAllOnesConstant(DL, VT);\n\n  if (DAG.isConstantIntBuildVectorOrConstantInt(N0)) {\n    // canonicalize constant to RHS\n    if (!DAG.isConstantIntBuildVectorOrConstantInt(N1))\n      return DAG.getNode(Opcode, DL, VT, N1, N0);\n    // fold (add_sat c1, c2) -> c3\n    return DAG.FoldConstantArithmetic(Opcode, DL, VT, {N0, N1});\n  }\n\n  // fold (add_sat x, 0) -> x\n  if (isNullConstant(N1))\n    return N0;\n\n  // If it cannot overflow, transform into an add.\n  if (Opcode == ISD::UADDSAT)\n    if (DAG.computeOverflowKind(N0, N1) == SelectionDAG::OFK_Never)\n      return DAG.getNode(ISD::ADD, DL, VT, N0, N1);\n\n  return SDValue();\n}\n\nstatic SDValue getAsCarry(const TargetLowering &TLI, SDValue V) {\n  bool Masked = false;\n\n  // First, peel away TRUNCATE/ZERO_EXTEND/AND nodes due to legalization.\n  while (true) {\n    if (V.getOpcode() == ISD::TRUNCATE || V.getOpcode() == ISD::ZERO_EXTEND) {\n      V = V.getOperand(0);\n      continue;\n    }\n\n    if (V.getOpcode() == ISD::AND && isOneConstant(V.getOperand(1))) {\n      Masked = true;\n      V = V.getOperand(0);\n      continue;\n    }\n\n    break;\n  }\n\n  // If this is not a carry, return.\n  if (V.getResNo() != 1)\n    return SDValue();\n\n  if (V.getOpcode() != ISD::ADDCARRY && V.getOpcode() != ISD::SUBCARRY &&\n      V.getOpcode() != ISD::UADDO && V.getOpcode() != ISD::USUBO)\n    return SDValue();\n\n  EVT VT = V.getNode()->getValueType(0);\n  if (!TLI.isOperationLegalOrCustom(V.getOpcode(), VT))\n    return SDValue();\n\n  // If the result is masked, then no matter what kind of bool it is we can\n  // return. If it isn't, then we need to make sure the bool type is either 0 or\n  // 1 and not other values.\n  if (Masked ||\n      TLI.getBooleanContents(V.getValueType()) ==\n          TargetLoweringBase::ZeroOrOneBooleanContent)\n    return V;\n\n  return SDValue();\n}\n\n/// Given the operands of an add/sub operation, see if the 2nd operand is a\n/// masked 0/1 whose source operand is actually known to be 0/-1. If so, invert\n/// the opcode and bypass the mask operation.\nstatic SDValue foldAddSubMasked1(bool IsAdd, SDValue N0, SDValue N1,\n                                 SelectionDAG &DAG, const SDLoc &DL) {\n  if (N1.getOpcode() != ISD::AND || !isOneOrOneSplat(N1->getOperand(1)))\n    return SDValue();\n\n  EVT VT = N0.getValueType();\n  if (DAG.ComputeNumSignBits(N1.getOperand(0)) != VT.getScalarSizeInBits())\n    return SDValue();\n\n  // add N0, (and (AssertSext X, i1), 1) --> sub N0, X\n  // sub N0, (and (AssertSext X, i1), 1) --> add N0, X\n  return DAG.getNode(IsAdd ? ISD::SUB : ISD::ADD, DL, VT, N0, N1.getOperand(0));\n}\n\n/// Helper for doing combines based on N0 and N1 being added to each other.\nSDValue DAGCombiner::visitADDLikeCommutative(SDValue N0, SDValue N1,\n                                          SDNode *LocReference) {\n  EVT VT = N0.getValueType();\n  SDLoc DL(LocReference);\n\n  // fold (add x, shl(0 - y, n)) -> sub(x, shl(y, n))\n  if (N1.getOpcode() == ISD::SHL && N1.getOperand(0).getOpcode() == ISD::SUB &&\n      isNullOrNullSplat(N1.getOperand(0).getOperand(0)))\n    return DAG.getNode(ISD::SUB, DL, VT, N0,\n                       DAG.getNode(ISD::SHL, DL, VT,\n                                   N1.getOperand(0).getOperand(1),\n                                   N1.getOperand(1)));\n\n  if (SDValue V = foldAddSubMasked1(true, N0, N1, DAG, DL))\n    return V;\n\n  // Look for:\n  //   add (add x, 1), y\n  // And if the target does not like this form then turn into:\n  //   sub y, (xor x, -1)\n  if (!TLI.preferIncOfAddToSubOfNot(VT) && N0.hasOneUse() &&\n      N0.getOpcode() == ISD::ADD && isOneOrOneSplat(N0.getOperand(1))) {\n    SDValue Not = DAG.getNode(ISD::XOR, DL, VT, N0.getOperand(0),\n                              DAG.getAllOnesConstant(DL, VT));\n    return DAG.getNode(ISD::SUB, DL, VT, N1, Not);\n  }\n\n  // Hoist one-use subtraction by non-opaque constant:\n  //   (x - C) + y  ->  (x + y) - C\n  // This is necessary because SUB(X,C) -> ADD(X,-C) doesn't work for vectors.\n  if (N0.hasOneUse() && N0.getOpcode() == ISD::SUB &&\n      isConstantOrConstantVector(N0.getOperand(1), /*NoOpaques=*/true)) {\n    SDValue Add = DAG.getNode(ISD::ADD, DL, VT, N0.getOperand(0), N1);\n    return DAG.getNode(ISD::SUB, DL, VT, Add, N0.getOperand(1));\n  }\n  // Hoist one-use subtraction from non-opaque constant:\n  //   (C - x) + y  ->  (y - x) + C\n  if (N0.hasOneUse() && N0.getOpcode() == ISD::SUB &&\n      isConstantOrConstantVector(N0.getOperand(0), /*NoOpaques=*/true)) {\n    SDValue Sub = DAG.getNode(ISD::SUB, DL, VT, N1, N0.getOperand(1));\n    return DAG.getNode(ISD::ADD, DL, VT, Sub, N0.getOperand(0));\n  }\n\n  // If the target's bool is represented as 0/1, prefer to make this 'sub 0/1'\n  // rather than 'add 0/-1' (the zext should get folded).\n  // add (sext i1 Y), X --> sub X, (zext i1 Y)\n  if (N0.getOpcode() == ISD::SIGN_EXTEND &&\n      N0.getOperand(0).getScalarValueSizeInBits() == 1 &&\n      TLI.getBooleanContents(VT) == TargetLowering::ZeroOrOneBooleanContent) {\n    SDValue ZExt = DAG.getNode(ISD::ZERO_EXTEND, DL, VT, N0.getOperand(0));\n    return DAG.getNode(ISD::SUB, DL, VT, N1, ZExt);\n  }\n\n  // add X, (sextinreg Y i1) -> sub X, (and Y 1)\n  if (N1.getOpcode() == ISD::SIGN_EXTEND_INREG) {\n    VTSDNode *TN = cast<VTSDNode>(N1.getOperand(1));\n    if (TN->getVT() == MVT::i1) {\n      SDValue ZExt = DAG.getNode(ISD::AND, DL, VT, N1.getOperand(0),\n                                 DAG.getConstant(1, DL, VT));\n      return DAG.getNode(ISD::SUB, DL, VT, N0, ZExt);\n    }\n  }\n\n  // (add X, (addcarry Y, 0, Carry)) -> (addcarry X, Y, Carry)\n  if (N1.getOpcode() == ISD::ADDCARRY && isNullConstant(N1.getOperand(1)) &&\n      N1.getResNo() == 0)\n    return DAG.getNode(ISD::ADDCARRY, DL, N1->getVTList(),\n                       N0, N1.getOperand(0), N1.getOperand(2));\n\n  // (add X, Carry) -> (addcarry X, 0, Carry)\n  if (TLI.isOperationLegalOrCustom(ISD::ADDCARRY, VT))\n    if (SDValue Carry = getAsCarry(TLI, N1))\n      return DAG.getNode(ISD::ADDCARRY, DL,\n                         DAG.getVTList(VT, Carry.getValueType()), N0,\n                         DAG.getConstant(0, DL, VT), Carry);\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitADDC(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  EVT VT = N0.getValueType();\n  SDLoc DL(N);\n\n  // If the flag result is dead, turn this into an ADD.\n  if (!N->hasAnyUseOfValue(1))\n    return CombineTo(N, DAG.getNode(ISD::ADD, DL, VT, N0, N1),\n                     DAG.getNode(ISD::CARRY_FALSE, DL, MVT::Glue));\n\n  // canonicalize constant to RHS.\n  ConstantSDNode *N0C = dyn_cast<ConstantSDNode>(N0);\n  ConstantSDNode *N1C = dyn_cast<ConstantSDNode>(N1);\n  if (N0C && !N1C)\n    return DAG.getNode(ISD::ADDC, DL, N->getVTList(), N1, N0);\n\n  // fold (addc x, 0) -> x + no carry out\n  if (isNullConstant(N1))\n    return CombineTo(N, N0, DAG.getNode(ISD::CARRY_FALSE,\n                                        DL, MVT::Glue));\n\n  // If it cannot overflow, transform into an add.\n  if (DAG.computeOverflowKind(N0, N1) == SelectionDAG::OFK_Never)\n    return CombineTo(N, DAG.getNode(ISD::ADD, DL, VT, N0, N1),\n                     DAG.getNode(ISD::CARRY_FALSE, DL, MVT::Glue));\n\n  return SDValue();\n}\n\n/**\n * Flips a boolean if it is cheaper to compute. If the Force parameters is set,\n * then the flip also occurs if computing the inverse is the same cost.\n * This function returns an empty SDValue in case it cannot flip the boolean\n * without increasing the cost of the computation. If you want to flip a boolean\n * no matter what, use DAG.getLogicalNOT.\n */\nstatic SDValue extractBooleanFlip(SDValue V, SelectionDAG &DAG,\n                                  const TargetLowering &TLI,\n                                  bool Force) {\n  if (Force && isa<ConstantSDNode>(V))\n    return DAG.getLogicalNOT(SDLoc(V), V, V.getValueType());\n\n  if (V.getOpcode() != ISD::XOR)\n    return SDValue();\n\n  ConstantSDNode *Const = isConstOrConstSplat(V.getOperand(1), false);\n  if (!Const)\n    return SDValue();\n\n  EVT VT = V.getValueType();\n\n  bool IsFlip = false;\n  switch(TLI.getBooleanContents(VT)) {\n    case TargetLowering::ZeroOrOneBooleanContent:\n      IsFlip = Const->isOne();\n      break;\n    case TargetLowering::ZeroOrNegativeOneBooleanContent:\n      IsFlip = Const->isAllOnesValue();\n      break;\n    case TargetLowering::UndefinedBooleanContent:\n      IsFlip = (Const->getAPIntValue() & 0x01) == 1;\n      break;\n  }\n\n  if (IsFlip)\n    return V.getOperand(0);\n  if (Force)\n    return DAG.getLogicalNOT(SDLoc(V), V, V.getValueType());\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitADDO(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  EVT VT = N0.getValueType();\n  bool IsSigned = (ISD::SADDO == N->getOpcode());\n\n  EVT CarryVT = N->getValueType(1);\n  SDLoc DL(N);\n\n  // If the flag result is dead, turn this into an ADD.\n  if (!N->hasAnyUseOfValue(1))\n    return CombineTo(N, DAG.getNode(ISD::ADD, DL, VT, N0, N1),\n                     DAG.getUNDEF(CarryVT));\n\n  // canonicalize constant to RHS.\n  if (DAG.isConstantIntBuildVectorOrConstantInt(N0) &&\n      !DAG.isConstantIntBuildVectorOrConstantInt(N1))\n    return DAG.getNode(N->getOpcode(), DL, N->getVTList(), N1, N0);\n\n  // fold (addo x, 0) -> x + no carry out\n  if (isNullOrNullSplat(N1))\n    return CombineTo(N, N0, DAG.getConstant(0, DL, CarryVT));\n\n  if (!IsSigned) {\n    // If it cannot overflow, transform into an add.\n    if (DAG.computeOverflowKind(N0, N1) == SelectionDAG::OFK_Never)\n      return CombineTo(N, DAG.getNode(ISD::ADD, DL, VT, N0, N1),\n                       DAG.getConstant(0, DL, CarryVT));\n\n    // fold (uaddo (xor a, -1), 1) -> (usub 0, a) and flip carry.\n    if (isBitwiseNot(N0) && isOneOrOneSplat(N1)) {\n      SDValue Sub = DAG.getNode(ISD::USUBO, DL, N->getVTList(),\n                                DAG.getConstant(0, DL, VT), N0.getOperand(0));\n      return CombineTo(\n          N, Sub, DAG.getLogicalNOT(DL, Sub.getValue(1), Sub->getValueType(1)));\n    }\n\n    if (SDValue Combined = visitUADDOLike(N0, N1, N))\n      return Combined;\n\n    if (SDValue Combined = visitUADDOLike(N1, N0, N))\n      return Combined;\n  }\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitUADDOLike(SDValue N0, SDValue N1, SDNode *N) {\n  EVT VT = N0.getValueType();\n  if (VT.isVector())\n    return SDValue();\n\n  // (uaddo X, (addcarry Y, 0, Carry)) -> (addcarry X, Y, Carry)\n  // If Y + 1 cannot overflow.\n  if (N1.getOpcode() == ISD::ADDCARRY && isNullConstant(N1.getOperand(1))) {\n    SDValue Y = N1.getOperand(0);\n    SDValue One = DAG.getConstant(1, SDLoc(N), Y.getValueType());\n    if (DAG.computeOverflowKind(Y, One) == SelectionDAG::OFK_Never)\n      return DAG.getNode(ISD::ADDCARRY, SDLoc(N), N->getVTList(), N0, Y,\n                         N1.getOperand(2));\n  }\n\n  // (uaddo X, Carry) -> (addcarry X, 0, Carry)\n  if (TLI.isOperationLegalOrCustom(ISD::ADDCARRY, VT))\n    if (SDValue Carry = getAsCarry(TLI, N1))\n      return DAG.getNode(ISD::ADDCARRY, SDLoc(N), N->getVTList(), N0,\n                         DAG.getConstant(0, SDLoc(N), VT), Carry);\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitADDE(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  SDValue CarryIn = N->getOperand(2);\n\n  // canonicalize constant to RHS\n  ConstantSDNode *N0C = dyn_cast<ConstantSDNode>(N0);\n  ConstantSDNode *N1C = dyn_cast<ConstantSDNode>(N1);\n  if (N0C && !N1C)\n    return DAG.getNode(ISD::ADDE, SDLoc(N), N->getVTList(),\n                       N1, N0, CarryIn);\n\n  // fold (adde x, y, false) -> (addc x, y)\n  if (CarryIn.getOpcode() == ISD::CARRY_FALSE)\n    return DAG.getNode(ISD::ADDC, SDLoc(N), N->getVTList(), N0, N1);\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitADDCARRY(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  SDValue CarryIn = N->getOperand(2);\n  SDLoc DL(N);\n\n  // canonicalize constant to RHS\n  ConstantSDNode *N0C = dyn_cast<ConstantSDNode>(N0);\n  ConstantSDNode *N1C = dyn_cast<ConstantSDNode>(N1);\n  if (N0C && !N1C)\n    return DAG.getNode(ISD::ADDCARRY, DL, N->getVTList(), N1, N0, CarryIn);\n\n  // fold (addcarry x, y, false) -> (uaddo x, y)\n  if (isNullConstant(CarryIn)) {\n    if (!LegalOperations ||\n        TLI.isOperationLegalOrCustom(ISD::UADDO, N->getValueType(0)))\n      return DAG.getNode(ISD::UADDO, DL, N->getVTList(), N0, N1);\n  }\n\n  // fold (addcarry 0, 0, X) -> (and (ext/trunc X), 1) and no carry.\n  if (isNullConstant(N0) && isNullConstant(N1)) {\n    EVT VT = N0.getValueType();\n    EVT CarryVT = CarryIn.getValueType();\n    SDValue CarryExt = DAG.getBoolExtOrTrunc(CarryIn, DL, VT, CarryVT);\n    AddToWorklist(CarryExt.getNode());\n    return CombineTo(N, DAG.getNode(ISD::AND, DL, VT, CarryExt,\n                                    DAG.getConstant(1, DL, VT)),\n                     DAG.getConstant(0, DL, CarryVT));\n  }\n\n  if (SDValue Combined = visitADDCARRYLike(N0, N1, CarryIn, N))\n    return Combined;\n\n  if (SDValue Combined = visitADDCARRYLike(N1, N0, CarryIn, N))\n    return Combined;\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitSADDO_CARRY(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  SDValue CarryIn = N->getOperand(2);\n  SDLoc DL(N);\n\n  // canonicalize constant to RHS\n  ConstantSDNode *N0C = dyn_cast<ConstantSDNode>(N0);\n  ConstantSDNode *N1C = dyn_cast<ConstantSDNode>(N1);\n  if (N0C && !N1C)\n    return DAG.getNode(ISD::SADDO_CARRY, DL, N->getVTList(), N1, N0, CarryIn);\n\n  // fold (saddo_carry x, y, false) -> (saddo x, y)\n  if (isNullConstant(CarryIn)) {\n    if (!LegalOperations ||\n        TLI.isOperationLegalOrCustom(ISD::SADDO, N->getValueType(0)))\n      return DAG.getNode(ISD::SADDO, DL, N->getVTList(), N0, N1);\n  }\n\n  return SDValue();\n}\n\n/**\n * If we are facing some sort of diamond carry propapagtion pattern try to\n * break it up to generate something like:\n *   (addcarry X, 0, (addcarry A, B, Z):Carry)\n *\n * The end result is usually an increase in operation required, but because the\n * carry is now linearized, other tranforms can kick in and optimize the DAG.\n *\n * Patterns typically look something like\n *            (uaddo A, B)\n *             /       \\\n *          Carry      Sum\n *            |          \\\n *            | (addcarry *, 0, Z)\n *            |       /\n *             \\   Carry\n *              |   /\n * (addcarry X, *, *)\n *\n * But numerous variation exist. Our goal is to identify A, B, X and Z and\n * produce a combine with a single path for carry propagation.\n */\nstatic SDValue combineADDCARRYDiamond(DAGCombiner &Combiner, SelectionDAG &DAG,\n                                      SDValue X, SDValue Carry0, SDValue Carry1,\n                                      SDNode *N) {\n  if (Carry1.getResNo() != 1 || Carry0.getResNo() != 1)\n    return SDValue();\n  if (Carry1.getOpcode() != ISD::UADDO)\n    return SDValue();\n\n  SDValue Z;\n\n  /**\n   * First look for a suitable Z. It will present itself in the form of\n   * (addcarry Y, 0, Z) or its equivalent (uaddo Y, 1) for Z=true\n   */\n  if (Carry0.getOpcode() == ISD::ADDCARRY &&\n      isNullConstant(Carry0.getOperand(1))) {\n    Z = Carry0.getOperand(2);\n  } else if (Carry0.getOpcode() == ISD::UADDO &&\n             isOneConstant(Carry0.getOperand(1))) {\n    EVT VT = Combiner.getSetCCResultType(Carry0.getValueType());\n    Z = DAG.getConstant(1, SDLoc(Carry0.getOperand(1)), VT);\n  } else {\n    // We couldn't find a suitable Z.\n    return SDValue();\n  }\n\n\n  auto cancelDiamond = [&](SDValue A,SDValue B) {\n    SDLoc DL(N);\n    SDValue NewY = DAG.getNode(ISD::ADDCARRY, DL, Carry0->getVTList(), A, B, Z);\n    Combiner.AddToWorklist(NewY.getNode());\n    return DAG.getNode(ISD::ADDCARRY, DL, N->getVTList(), X,\n                       DAG.getConstant(0, DL, X.getValueType()),\n                       NewY.getValue(1));\n  };\n\n  /**\n   *      (uaddo A, B)\n   *           |\n   *          Sum\n   *           |\n   * (addcarry *, 0, Z)\n   */\n  if (Carry0.getOperand(0) == Carry1.getValue(0)) {\n    return cancelDiamond(Carry1.getOperand(0), Carry1.getOperand(1));\n  }\n\n  /**\n   * (addcarry A, 0, Z)\n   *         |\n   *        Sum\n   *         |\n   *  (uaddo *, B)\n   */\n  if (Carry1.getOperand(0) == Carry0.getValue(0)) {\n    return cancelDiamond(Carry0.getOperand(0), Carry1.getOperand(1));\n  }\n\n  if (Carry1.getOperand(1) == Carry0.getValue(0)) {\n    return cancelDiamond(Carry1.getOperand(0), Carry0.getOperand(0));\n  }\n\n  return SDValue();\n}\n\n// If we are facing some sort of diamond carry/borrow in/out pattern try to\n// match patterns like:\n//\n//          (uaddo A, B)            CarryIn\n//            |  \\                     |\n//            |   \\                    |\n//    PartialSum   PartialCarryOutX   /\n//            |        |             /\n//            |    ____|____________/\n//            |   /    |\n//     (uaddo *, *)    \\________\n//       |  \\                   \\\n//       |   \\                   |\n//       |    PartialCarryOutY   |\n//       |        \\              |\n//       |         \\            /\n//   AddCarrySum    |    ______/\n//                  |   /\n//   CarryOut = (or *, *)\n//\n// And generate ADDCARRY (or SUBCARRY) with two result values:\n//\n//    {AddCarrySum, CarryOut} = (addcarry A, B, CarryIn)\n//\n// Our goal is to identify A, B, and CarryIn and produce ADDCARRY/SUBCARRY with\n// a single path for carry/borrow out propagation:\nstatic SDValue combineCarryDiamond(DAGCombiner &Combiner, SelectionDAG &DAG,\n                                   const TargetLowering &TLI, SDValue Carry0,\n                                   SDValue Carry1, SDNode *N) {\n  if (Carry0.getResNo() != 1 || Carry1.getResNo() != 1)\n    return SDValue();\n  unsigned Opcode = Carry0.getOpcode();\n  if (Opcode != Carry1.getOpcode())\n    return SDValue();\n  if (Opcode != ISD::UADDO && Opcode != ISD::USUBO)\n    return SDValue();\n\n  // Canonicalize the add/sub of A and B as Carry0 and the add/sub of the\n  // carry/borrow in as Carry1. (The top and middle uaddo nodes respectively in\n  // the above ASCII art.)\n  if (Carry1.getOperand(0) != Carry0.getValue(0) &&\n      Carry1.getOperand(1) != Carry0.getValue(0))\n    std::swap(Carry0, Carry1);\n  if (Carry1.getOperand(0) != Carry0.getValue(0) &&\n      Carry1.getOperand(1) != Carry0.getValue(0))\n    return SDValue();\n\n  // The carry in value must be on the righthand side for subtraction.\n  unsigned CarryInOperandNum =\n      Carry1.getOperand(0) == Carry0.getValue(0) ? 1 : 0;\n  if (Opcode == ISD::USUBO && CarryInOperandNum != 1)\n    return SDValue();\n  SDValue CarryIn = Carry1.getOperand(CarryInOperandNum);\n\n  unsigned NewOp = Opcode == ISD::UADDO ? ISD::ADDCARRY : ISD::SUBCARRY;\n  if (!TLI.isOperationLegalOrCustom(NewOp, Carry0.getValue(0).getValueType()))\n    return SDValue();\n\n  // Verify that the carry/borrow in is plausibly a carry/borrow bit.\n  // TODO: make getAsCarry() aware of how partial carries are merged.\n  if (CarryIn.getOpcode() != ISD::ZERO_EXTEND)\n    return SDValue();\n  CarryIn = CarryIn.getOperand(0);\n  if (CarryIn.getValueType() != MVT::i1)\n    return SDValue();\n\n  SDLoc DL(N);\n  SDValue Merged =\n      DAG.getNode(NewOp, DL, Carry1->getVTList(), Carry0.getOperand(0),\n                  Carry0.getOperand(1), CarryIn);\n\n  // Please note that because we have proven that the result of the UADDO/USUBO\n  // of A and B feeds into the UADDO/USUBO that does the carry/borrow in, we can\n  // therefore prove that if the first UADDO/USUBO overflows, the second\n  // UADDO/USUBO cannot. For example consider 8-bit numbers where 0xFF is the\n  // maximum value.\n  //\n  //   0xFF + 0xFF == 0xFE with carry but 0xFE + 1 does not carry\n  //   0x00 - 0xFF == 1 with a carry/borrow but 1 - 1 == 0 (no carry/borrow)\n  //\n  // This is important because it means that OR and XOR can be used to merge\n  // carry flags; and that AND can return a constant zero.\n  //\n  // TODO: match other operations that can merge flags (ADD, etc)\n  DAG.ReplaceAllUsesOfValueWith(Carry1.getValue(0), Merged.getValue(0));\n  if (N->getOpcode() == ISD::AND)\n    return DAG.getConstant(0, DL, MVT::i1);\n  return Merged.getValue(1);\n}\n\nSDValue DAGCombiner::visitADDCARRYLike(SDValue N0, SDValue N1, SDValue CarryIn,\n                                       SDNode *N) {\n  // fold (addcarry (xor a, -1), b, c) -> (subcarry b, a, !c) and flip carry.\n  if (isBitwiseNot(N0))\n    if (SDValue NotC = extractBooleanFlip(CarryIn, DAG, TLI, true)) {\n      SDLoc DL(N);\n      SDValue Sub = DAG.getNode(ISD::SUBCARRY, DL, N->getVTList(), N1,\n                                N0.getOperand(0), NotC);\n      return CombineTo(\n          N, Sub, DAG.getLogicalNOT(DL, Sub.getValue(1), Sub->getValueType(1)));\n    }\n\n  // Iff the flag result is dead:\n  // (addcarry (add|uaddo X, Y), 0, Carry) -> (addcarry X, Y, Carry)\n  // Don't do this if the Carry comes from the uaddo. It won't remove the uaddo\n  // or the dependency between the instructions.\n  if ((N0.getOpcode() == ISD::ADD ||\n       (N0.getOpcode() == ISD::UADDO && N0.getResNo() == 0 &&\n        N0.getValue(1) != CarryIn)) &&\n      isNullConstant(N1) && !N->hasAnyUseOfValue(1))\n    return DAG.getNode(ISD::ADDCARRY, SDLoc(N), N->getVTList(),\n                       N0.getOperand(0), N0.getOperand(1), CarryIn);\n\n  /**\n   * When one of the addcarry argument is itself a carry, we may be facing\n   * a diamond carry propagation. In which case we try to transform the DAG\n   * to ensure linear carry propagation if that is possible.\n   */\n  if (auto Y = getAsCarry(TLI, N1)) {\n    // Because both are carries, Y and Z can be swapped.\n    if (auto R = combineADDCARRYDiamond(*this, DAG, N0, Y, CarryIn, N))\n      return R;\n    if (auto R = combineADDCARRYDiamond(*this, DAG, N0, CarryIn, Y, N))\n      return R;\n  }\n\n  return SDValue();\n}\n\n// Attempt to create a USUBSAT(LHS, RHS) node with DstVT, performing a\n// clamp/truncation if necessary.\nstatic SDValue getTruncatedUSUBSAT(EVT DstVT, EVT SrcVT, SDValue LHS,\n                                   SDValue RHS, SelectionDAG &DAG,\n                                   const SDLoc &DL) {\n  assert(DstVT.getScalarSizeInBits() <= SrcVT.getScalarSizeInBits() &&\n         \"Illegal truncation\");\n\n  if (DstVT == SrcVT)\n    return DAG.getNode(ISD::USUBSAT, DL, DstVT, LHS, RHS);\n\n  // If the LHS is zero-extended then we can perform the USUBSAT as DstVT by\n  // clamping RHS.\n  APInt UpperBits = APInt::getBitsSetFrom(SrcVT.getScalarSizeInBits(),\n                                          DstVT.getScalarSizeInBits());\n  if (!DAG.MaskedValueIsZero(LHS, UpperBits))\n    return SDValue();\n\n  SDValue SatLimit =\n      DAG.getConstant(APInt::getLowBitsSet(SrcVT.getScalarSizeInBits(),\n                                           DstVT.getScalarSizeInBits()),\n                      DL, SrcVT);\n  RHS = DAG.getNode(ISD::UMIN, DL, SrcVT, RHS, SatLimit);\n  RHS = DAG.getNode(ISD::TRUNCATE, DL, DstVT, RHS);\n  LHS = DAG.getNode(ISD::TRUNCATE, DL, DstVT, LHS);\n  return DAG.getNode(ISD::USUBSAT, DL, DstVT, LHS, RHS);\n}\n\n// Try to find umax(a,b) - b or a - umin(a,b) patterns that may be converted to\n// usubsat(a,b), optionally as a truncated type.\nSDValue DAGCombiner::foldSubToUSubSat(EVT DstVT, SDNode *N) {\n  if (N->getOpcode() != ISD::SUB ||\n      !(!LegalOperations || hasOperation(ISD::USUBSAT, DstVT)))\n    return SDValue();\n\n  EVT SubVT = N->getValueType(0);\n  SDValue Op0 = N->getOperand(0);\n  SDValue Op1 = N->getOperand(1);\n\n  // Try to find umax(a,b) - b or a - umin(a,b) patterns\n  // they may be converted to usubsat(a,b).\n  if (Op0.getOpcode() == ISD::UMAX) {\n    SDValue MaxLHS = Op0.getOperand(0);\n    SDValue MaxRHS = Op0.getOperand(1);\n    if (MaxLHS == Op1)\n      return getTruncatedUSUBSAT(DstVT, SubVT, MaxRHS, Op1, DAG, SDLoc(N));\n    if (MaxRHS == Op1)\n      return getTruncatedUSUBSAT(DstVT, SubVT, MaxLHS, Op1, DAG, SDLoc(N));\n  }\n\n  if (Op1.getOpcode() == ISD::UMIN) {\n    SDValue MinLHS = Op1.getOperand(0);\n    SDValue MinRHS = Op1.getOperand(1);\n    if (MinLHS == Op0)\n      return getTruncatedUSUBSAT(DstVT, SubVT, Op0, MinRHS, DAG, SDLoc(N));\n    if (MinRHS == Op0)\n      return getTruncatedUSUBSAT(DstVT, SubVT, Op0, MinLHS, DAG, SDLoc(N));\n  }\n\n  // sub(a,trunc(umin(zext(a),b))) -> usubsat(a,trunc(umin(b,SatLimit)))\n  if (Op1.getOpcode() == ISD::TRUNCATE &&\n      Op1.getOperand(0).getOpcode() == ISD::UMIN) {\n    SDValue MinLHS = Op1.getOperand(0).getOperand(0);\n    SDValue MinRHS = Op1.getOperand(0).getOperand(1);\n    if (MinLHS.getOpcode() == ISD::ZERO_EXTEND && MinLHS.getOperand(0) == Op0)\n      return getTruncatedUSUBSAT(DstVT, MinLHS.getValueType(), MinLHS, MinRHS,\n                                 DAG, SDLoc(N));\n    if (MinRHS.getOpcode() == ISD::ZERO_EXTEND && MinRHS.getOperand(0) == Op0)\n      return getTruncatedUSUBSAT(DstVT, MinLHS.getValueType(), MinRHS, MinLHS,\n                                 DAG, SDLoc(N));\n  }\n\n  return SDValue();\n}\n\n// Since it may not be valid to emit a fold to zero for vector initializers\n// check if we can before folding.\nstatic SDValue tryFoldToZero(const SDLoc &DL, const TargetLowering &TLI, EVT VT,\n                             SelectionDAG &DAG, bool LegalOperations) {\n  if (!VT.isVector())\n    return DAG.getConstant(0, DL, VT);\n  if (!LegalOperations || TLI.isOperationLegal(ISD::BUILD_VECTOR, VT))\n    return DAG.getConstant(0, DL, VT);\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitSUB(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  EVT VT = N0.getValueType();\n  SDLoc DL(N);\n\n  // fold vector ops\n  if (VT.isVector()) {\n    if (SDValue FoldedVOp = SimplifyVBinOp(N))\n      return FoldedVOp;\n\n    // fold (sub x, 0) -> x, vector edition\n    if (ISD::isBuildVectorAllZeros(N1.getNode()))\n      return N0;\n  }\n\n  // fold (sub x, x) -> 0\n  // FIXME: Refactor this and xor and other similar operations together.\n  if (N0 == N1)\n    return tryFoldToZero(DL, TLI, VT, DAG, LegalOperations);\n\n  // fold (sub c1, c2) -> c3\n  if (SDValue C = DAG.FoldConstantArithmetic(ISD::SUB, DL, VT, {N0, N1}))\n    return C;\n\n  if (SDValue NewSel = foldBinOpIntoSelect(N))\n    return NewSel;\n\n  ConstantSDNode *N1C = getAsNonOpaqueConstant(N1);\n\n  // fold (sub x, c) -> (add x, -c)\n  if (N1C) {\n    return DAG.getNode(ISD::ADD, DL, VT, N0,\n                       DAG.getConstant(-N1C->getAPIntValue(), DL, VT));\n  }\n\n  if (isNullOrNullSplat(N0)) {\n    unsigned BitWidth = VT.getScalarSizeInBits();\n    // Right-shifting everything out but the sign bit followed by negation is\n    // the same as flipping arithmetic/logical shift type without the negation:\n    // -(X >>u 31) -> (X >>s 31)\n    // -(X >>s 31) -> (X >>u 31)\n    if (N1->getOpcode() == ISD::SRA || N1->getOpcode() == ISD::SRL) {\n      ConstantSDNode *ShiftAmt = isConstOrConstSplat(N1.getOperand(1));\n      if (ShiftAmt && ShiftAmt->getAPIntValue() == (BitWidth - 1)) {\n        auto NewSh = N1->getOpcode() == ISD::SRA ? ISD::SRL : ISD::SRA;\n        if (!LegalOperations || TLI.isOperationLegal(NewSh, VT))\n          return DAG.getNode(NewSh, DL, VT, N1.getOperand(0), N1.getOperand(1));\n      }\n    }\n\n    // 0 - X --> 0 if the sub is NUW.\n    if (N->getFlags().hasNoUnsignedWrap())\n      return N0;\n\n    if (DAG.MaskedValueIsZero(N1, ~APInt::getSignMask(BitWidth))) {\n      // N1 is either 0 or the minimum signed value. If the sub is NSW, then\n      // N1 must be 0 because negating the minimum signed value is undefined.\n      if (N->getFlags().hasNoSignedWrap())\n        return N0;\n\n      // 0 - X --> X if X is 0 or the minimum signed value.\n      return N1;\n    }\n\n    // Convert 0 - abs(x).\n    SDValue Result;\n    if (N1->getOpcode() == ISD::ABS &&\n        !TLI.isOperationLegalOrCustom(ISD::ABS, VT) &&\n        TLI.expandABS(N1.getNode(), Result, DAG, true))\n      return Result;\n  }\n\n  // Canonicalize (sub -1, x) -> ~x, i.e. (xor x, -1)\n  if (isAllOnesOrAllOnesSplat(N0))\n    return DAG.getNode(ISD::XOR, DL, VT, N1, N0);\n\n  // fold (A - (0-B)) -> A+B\n  if (N1.getOpcode() == ISD::SUB && isNullOrNullSplat(N1.getOperand(0)))\n    return DAG.getNode(ISD::ADD, DL, VT, N0, N1.getOperand(1));\n\n  // fold A-(A-B) -> B\n  if (N1.getOpcode() == ISD::SUB && N0 == N1.getOperand(0))\n    return N1.getOperand(1);\n\n  // fold (A+B)-A -> B\n  if (N0.getOpcode() == ISD::ADD && N0.getOperand(0) == N1)\n    return N0.getOperand(1);\n\n  // fold (A+B)-B -> A\n  if (N0.getOpcode() == ISD::ADD && N0.getOperand(1) == N1)\n    return N0.getOperand(0);\n\n  // fold (A+C1)-C2 -> A+(C1-C2)\n  if (N0.getOpcode() == ISD::ADD &&\n      isConstantOrConstantVector(N1, /* NoOpaques */ true) &&\n      isConstantOrConstantVector(N0.getOperand(1), /* NoOpaques */ true)) {\n    SDValue NewC =\n        DAG.FoldConstantArithmetic(ISD::SUB, DL, VT, {N0.getOperand(1), N1});\n    assert(NewC && \"Constant folding failed\");\n    return DAG.getNode(ISD::ADD, DL, VT, N0.getOperand(0), NewC);\n  }\n\n  // fold C2-(A+C1) -> (C2-C1)-A\n  if (N1.getOpcode() == ISD::ADD) {\n    SDValue N11 = N1.getOperand(1);\n    if (isConstantOrConstantVector(N0, /* NoOpaques */ true) &&\n        isConstantOrConstantVector(N11, /* NoOpaques */ true)) {\n      SDValue NewC = DAG.FoldConstantArithmetic(ISD::SUB, DL, VT, {N0, N11});\n      assert(NewC && \"Constant folding failed\");\n      return DAG.getNode(ISD::SUB, DL, VT, NewC, N1.getOperand(0));\n    }\n  }\n\n  // fold (A-C1)-C2 -> A-(C1+C2)\n  if (N0.getOpcode() == ISD::SUB &&\n      isConstantOrConstantVector(N1, /* NoOpaques */ true) &&\n      isConstantOrConstantVector(N0.getOperand(1), /* NoOpaques */ true)) {\n    SDValue NewC =\n        DAG.FoldConstantArithmetic(ISD::ADD, DL, VT, {N0.getOperand(1), N1});\n    assert(NewC && \"Constant folding failed\");\n    return DAG.getNode(ISD::SUB, DL, VT, N0.getOperand(0), NewC);\n  }\n\n  // fold (c1-A)-c2 -> (c1-c2)-A\n  if (N0.getOpcode() == ISD::SUB &&\n      isConstantOrConstantVector(N1, /* NoOpaques */ true) &&\n      isConstantOrConstantVector(N0.getOperand(0), /* NoOpaques */ true)) {\n    SDValue NewC =\n        DAG.FoldConstantArithmetic(ISD::SUB, DL, VT, {N0.getOperand(0), N1});\n    assert(NewC && \"Constant folding failed\");\n    return DAG.getNode(ISD::SUB, DL, VT, NewC, N0.getOperand(1));\n  }\n\n  // fold ((A+(B+or-C))-B) -> A+or-C\n  if (N0.getOpcode() == ISD::ADD &&\n      (N0.getOperand(1).getOpcode() == ISD::SUB ||\n       N0.getOperand(1).getOpcode() == ISD::ADD) &&\n      N0.getOperand(1).getOperand(0) == N1)\n    return DAG.getNode(N0.getOperand(1).getOpcode(), DL, VT, N0.getOperand(0),\n                       N0.getOperand(1).getOperand(1));\n\n  // fold ((A+(C+B))-B) -> A+C\n  if (N0.getOpcode() == ISD::ADD && N0.getOperand(1).getOpcode() == ISD::ADD &&\n      N0.getOperand(1).getOperand(1) == N1)\n    return DAG.getNode(ISD::ADD, DL, VT, N0.getOperand(0),\n                       N0.getOperand(1).getOperand(0));\n\n  // fold ((A-(B-C))-C) -> A-B\n  if (N0.getOpcode() == ISD::SUB && N0.getOperand(1).getOpcode() == ISD::SUB &&\n      N0.getOperand(1).getOperand(1) == N1)\n    return DAG.getNode(ISD::SUB, DL, VT, N0.getOperand(0),\n                       N0.getOperand(1).getOperand(0));\n\n  // fold (A-(B-C)) -> A+(C-B)\n  if (N1.getOpcode() == ISD::SUB && N1.hasOneUse())\n    return DAG.getNode(ISD::ADD, DL, VT, N0,\n                       DAG.getNode(ISD::SUB, DL, VT, N1.getOperand(1),\n                                   N1.getOperand(0)));\n\n  // A - (A & B)  ->  A & (~B)\n  if (N1.getOpcode() == ISD::AND) {\n    SDValue A = N1.getOperand(0);\n    SDValue B = N1.getOperand(1);\n    if (A != N0)\n      std::swap(A, B);\n    if (A == N0 &&\n        (N1.hasOneUse() || isConstantOrConstantVector(B, /*NoOpaques=*/true))) {\n      SDValue InvB =\n          DAG.getNode(ISD::XOR, DL, VT, B, DAG.getAllOnesConstant(DL, VT));\n      return DAG.getNode(ISD::AND, DL, VT, A, InvB);\n    }\n  }\n\n  // fold (X - (-Y * Z)) -> (X + (Y * Z))\n  if (N1.getOpcode() == ISD::MUL && N1.hasOneUse()) {\n    if (N1.getOperand(0).getOpcode() == ISD::SUB &&\n        isNullOrNullSplat(N1.getOperand(0).getOperand(0))) {\n      SDValue Mul = DAG.getNode(ISD::MUL, DL, VT,\n                                N1.getOperand(0).getOperand(1),\n                                N1.getOperand(1));\n      return DAG.getNode(ISD::ADD, DL, VT, N0, Mul);\n    }\n    if (N1.getOperand(1).getOpcode() == ISD::SUB &&\n        isNullOrNullSplat(N1.getOperand(1).getOperand(0))) {\n      SDValue Mul = DAG.getNode(ISD::MUL, DL, VT,\n                                N1.getOperand(0),\n                                N1.getOperand(1).getOperand(1));\n      return DAG.getNode(ISD::ADD, DL, VT, N0, Mul);\n    }\n  }\n\n  // If either operand of a sub is undef, the result is undef\n  if (N0.isUndef())\n    return N0;\n  if (N1.isUndef())\n    return N1;\n\n  if (SDValue V = foldAddSubBoolOfMaskedVal(N, DAG))\n    return V;\n\n  if (SDValue V = foldAddSubOfSignBit(N, DAG))\n    return V;\n\n  if (SDValue V = foldAddSubMasked1(false, N0, N1, DAG, SDLoc(N)))\n    return V;\n\n  if (SDValue V = foldSubToUSubSat(VT, N))\n    return V;\n\n  // (x - y) - 1  ->  add (xor y, -1), x\n  if (N0.hasOneUse() && N0.getOpcode() == ISD::SUB && isOneOrOneSplat(N1)) {\n    SDValue Xor = DAG.getNode(ISD::XOR, DL, VT, N0.getOperand(1),\n                              DAG.getAllOnesConstant(DL, VT));\n    return DAG.getNode(ISD::ADD, DL, VT, Xor, N0.getOperand(0));\n  }\n\n  // Look for:\n  //   sub y, (xor x, -1)\n  // And if the target does not like this form then turn into:\n  //   add (add x, y), 1\n  if (TLI.preferIncOfAddToSubOfNot(VT) && N1.hasOneUse() && isBitwiseNot(N1)) {\n    SDValue Add = DAG.getNode(ISD::ADD, DL, VT, N0, N1.getOperand(0));\n    return DAG.getNode(ISD::ADD, DL, VT, Add, DAG.getConstant(1, DL, VT));\n  }\n\n  // Hoist one-use addition by non-opaque constant:\n  //   (x + C) - y  ->  (x - y) + C\n  if (N0.hasOneUse() && N0.getOpcode() == ISD::ADD &&\n      isConstantOrConstantVector(N0.getOperand(1), /*NoOpaques=*/true)) {\n    SDValue Sub = DAG.getNode(ISD::SUB, DL, VT, N0.getOperand(0), N1);\n    return DAG.getNode(ISD::ADD, DL, VT, Sub, N0.getOperand(1));\n  }\n  // y - (x + C)  ->  (y - x) - C\n  if (N1.hasOneUse() && N1.getOpcode() == ISD::ADD &&\n      isConstantOrConstantVector(N1.getOperand(1), /*NoOpaques=*/true)) {\n    SDValue Sub = DAG.getNode(ISD::SUB, DL, VT, N0, N1.getOperand(0));\n    return DAG.getNode(ISD::SUB, DL, VT, Sub, N1.getOperand(1));\n  }\n  // (x - C) - y  ->  (x - y) - C\n  // This is necessary because SUB(X,C) -> ADD(X,-C) doesn't work for vectors.\n  if (N0.hasOneUse() && N0.getOpcode() == ISD::SUB &&\n      isConstantOrConstantVector(N0.getOperand(1), /*NoOpaques=*/true)) {\n    SDValue Sub = DAG.getNode(ISD::SUB, DL, VT, N0.getOperand(0), N1);\n    return DAG.getNode(ISD::SUB, DL, VT, Sub, N0.getOperand(1));\n  }\n  // (C - x) - y  ->  C - (x + y)\n  if (N0.hasOneUse() && N0.getOpcode() == ISD::SUB &&\n      isConstantOrConstantVector(N0.getOperand(0), /*NoOpaques=*/true)) {\n    SDValue Add = DAG.getNode(ISD::ADD, DL, VT, N0.getOperand(1), N1);\n    return DAG.getNode(ISD::SUB, DL, VT, N0.getOperand(0), Add);\n  }\n\n  // If the target's bool is represented as 0/-1, prefer to make this 'add 0/-1'\n  // rather than 'sub 0/1' (the sext should get folded).\n  // sub X, (zext i1 Y) --> add X, (sext i1 Y)\n  if (N1.getOpcode() == ISD::ZERO_EXTEND &&\n      N1.getOperand(0).getScalarValueSizeInBits() == 1 &&\n      TLI.getBooleanContents(VT) ==\n          TargetLowering::ZeroOrNegativeOneBooleanContent) {\n    SDValue SExt = DAG.getNode(ISD::SIGN_EXTEND, DL, VT, N1.getOperand(0));\n    return DAG.getNode(ISD::ADD, DL, VT, N0, SExt);\n  }\n\n  // fold Y = sra (X, size(X)-1); sub (xor (X, Y), Y) -> (abs X)\n  if (TLI.isOperationLegalOrCustom(ISD::ABS, VT)) {\n    if (N0.getOpcode() == ISD::XOR && N1.getOpcode() == ISD::SRA) {\n      SDValue X0 = N0.getOperand(0), X1 = N0.getOperand(1);\n      SDValue S0 = N1.getOperand(0);\n      if ((X0 == S0 && X1 == N1) || (X0 == N1 && X1 == S0))\n        if (ConstantSDNode *C = isConstOrConstSplat(N1.getOperand(1)))\n          if (C->getAPIntValue() == (VT.getScalarSizeInBits() - 1))\n            return DAG.getNode(ISD::ABS, SDLoc(N), VT, S0);\n    }\n  }\n\n  // If the relocation model supports it, consider symbol offsets.\n  if (GlobalAddressSDNode *GA = dyn_cast<GlobalAddressSDNode>(N0))\n    if (!LegalOperations && TLI.isOffsetFoldingLegal(GA)) {\n      // fold (sub Sym, c) -> Sym-c\n      if (N1C && GA->getOpcode() == ISD::GlobalAddress)\n        return DAG.getGlobalAddress(GA->getGlobal(), SDLoc(N1C), VT,\n                                    GA->getOffset() -\n                                        (uint64_t)N1C->getSExtValue());\n      // fold (sub Sym+c1, Sym+c2) -> c1-c2\n      if (GlobalAddressSDNode *GB = dyn_cast<GlobalAddressSDNode>(N1))\n        if (GA->getGlobal() == GB->getGlobal())\n          return DAG.getConstant((uint64_t)GA->getOffset() - GB->getOffset(),\n                                 DL, VT);\n    }\n\n  // sub X, (sextinreg Y i1) -> add X, (and Y 1)\n  if (N1.getOpcode() == ISD::SIGN_EXTEND_INREG) {\n    VTSDNode *TN = cast<VTSDNode>(N1.getOperand(1));\n    if (TN->getVT() == MVT::i1) {\n      SDValue ZExt = DAG.getNode(ISD::AND, DL, VT, N1.getOperand(0),\n                                 DAG.getConstant(1, DL, VT));\n      return DAG.getNode(ISD::ADD, DL, VT, N0, ZExt);\n    }\n  }\n\n  // canonicalize (sub X, (vscale * C)) to (add X,  (vscale * -C))\n  if (N1.getOpcode() == ISD::VSCALE) {\n    const APInt &IntVal = N1.getConstantOperandAPInt(0);\n    return DAG.getNode(ISD::ADD, DL, VT, N0, DAG.getVScale(DL, VT, -IntVal));\n  }\n\n  // Prefer an add for more folding potential and possibly better codegen:\n  // sub N0, (lshr N10, width-1) --> add N0, (ashr N10, width-1)\n  if (!LegalOperations && N1.getOpcode() == ISD::SRL && N1.hasOneUse()) {\n    SDValue ShAmt = N1.getOperand(1);\n    ConstantSDNode *ShAmtC = isConstOrConstSplat(ShAmt);\n    if (ShAmtC &&\n        ShAmtC->getAPIntValue() == (N1.getScalarValueSizeInBits() - 1)) {\n      SDValue SRA = DAG.getNode(ISD::SRA, DL, VT, N1.getOperand(0), ShAmt);\n      return DAG.getNode(ISD::ADD, DL, VT, N0, SRA);\n    }\n  }\n\n  if (TLI.isOperationLegalOrCustom(ISD::ADDCARRY, VT)) {\n    // (sub Carry, X)  ->  (addcarry (sub 0, X), 0, Carry)\n    if (SDValue Carry = getAsCarry(TLI, N0)) {\n      SDValue X = N1;\n      SDValue Zero = DAG.getConstant(0, DL, VT);\n      SDValue NegX = DAG.getNode(ISD::SUB, DL, VT, Zero, X);\n      return DAG.getNode(ISD::ADDCARRY, DL,\n                         DAG.getVTList(VT, Carry.getValueType()), NegX, Zero,\n                         Carry);\n    }\n  }\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitSUBSAT(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  EVT VT = N0.getValueType();\n  SDLoc DL(N);\n\n  // fold vector ops\n  if (VT.isVector()) {\n    // TODO SimplifyVBinOp\n\n    // fold (sub_sat x, 0) -> x, vector edition\n    if (ISD::isBuildVectorAllZeros(N1.getNode()))\n      return N0;\n  }\n\n  // fold (sub_sat x, undef) -> 0\n  if (N0.isUndef() || N1.isUndef())\n    return DAG.getConstant(0, DL, VT);\n\n  // fold (sub_sat x, x) -> 0\n  if (N0 == N1)\n    return DAG.getConstant(0, DL, VT);\n\n  // fold (sub_sat c1, c2) -> c3\n  if (SDValue C = DAG.FoldConstantArithmetic(N->getOpcode(), DL, VT, {N0, N1}))\n    return C;\n\n  // fold (sub_sat x, 0) -> x\n  if (isNullConstant(N1))\n    return N0;\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitSUBC(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  EVT VT = N0.getValueType();\n  SDLoc DL(N);\n\n  // If the flag result is dead, turn this into an SUB.\n  if (!N->hasAnyUseOfValue(1))\n    return CombineTo(N, DAG.getNode(ISD::SUB, DL, VT, N0, N1),\n                     DAG.getNode(ISD::CARRY_FALSE, DL, MVT::Glue));\n\n  // fold (subc x, x) -> 0 + no borrow\n  if (N0 == N1)\n    return CombineTo(N, DAG.getConstant(0, DL, VT),\n                     DAG.getNode(ISD::CARRY_FALSE, DL, MVT::Glue));\n\n  // fold (subc x, 0) -> x + no borrow\n  if (isNullConstant(N1))\n    return CombineTo(N, N0, DAG.getNode(ISD::CARRY_FALSE, DL, MVT::Glue));\n\n  // Canonicalize (sub -1, x) -> ~x, i.e. (xor x, -1) + no borrow\n  if (isAllOnesConstant(N0))\n    return CombineTo(N, DAG.getNode(ISD::XOR, DL, VT, N1, N0),\n                     DAG.getNode(ISD::CARRY_FALSE, DL, MVT::Glue));\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitSUBO(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  EVT VT = N0.getValueType();\n  bool IsSigned = (ISD::SSUBO == N->getOpcode());\n\n  EVT CarryVT = N->getValueType(1);\n  SDLoc DL(N);\n\n  // If the flag result is dead, turn this into an SUB.\n  if (!N->hasAnyUseOfValue(1))\n    return CombineTo(N, DAG.getNode(ISD::SUB, DL, VT, N0, N1),\n                     DAG.getUNDEF(CarryVT));\n\n  // fold (subo x, x) -> 0 + no borrow\n  if (N0 == N1)\n    return CombineTo(N, DAG.getConstant(0, DL, VT),\n                     DAG.getConstant(0, DL, CarryVT));\n\n  ConstantSDNode *N1C = getAsNonOpaqueConstant(N1);\n\n  // fold (subox, c) -> (addo x, -c)\n  if (IsSigned && N1C && !N1C->getAPIntValue().isMinSignedValue()) {\n    return DAG.getNode(ISD::SADDO, DL, N->getVTList(), N0,\n                       DAG.getConstant(-N1C->getAPIntValue(), DL, VT));\n  }\n\n  // fold (subo x, 0) -> x + no borrow\n  if (isNullOrNullSplat(N1))\n    return CombineTo(N, N0, DAG.getConstant(0, DL, CarryVT));\n\n  // Canonicalize (usubo -1, x) -> ~x, i.e. (xor x, -1) + no borrow\n  if (!IsSigned && isAllOnesOrAllOnesSplat(N0))\n    return CombineTo(N, DAG.getNode(ISD::XOR, DL, VT, N1, N0),\n                     DAG.getConstant(0, DL, CarryVT));\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitSUBE(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  SDValue CarryIn = N->getOperand(2);\n\n  // fold (sube x, y, false) -> (subc x, y)\n  if (CarryIn.getOpcode() == ISD::CARRY_FALSE)\n    return DAG.getNode(ISD::SUBC, SDLoc(N), N->getVTList(), N0, N1);\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitSUBCARRY(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  SDValue CarryIn = N->getOperand(2);\n\n  // fold (subcarry x, y, false) -> (usubo x, y)\n  if (isNullConstant(CarryIn)) {\n    if (!LegalOperations ||\n        TLI.isOperationLegalOrCustom(ISD::USUBO, N->getValueType(0)))\n      return DAG.getNode(ISD::USUBO, SDLoc(N), N->getVTList(), N0, N1);\n  }\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitSSUBO_CARRY(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  SDValue CarryIn = N->getOperand(2);\n\n  // fold (ssubo_carry x, y, false) -> (ssubo x, y)\n  if (isNullConstant(CarryIn)) {\n    if (!LegalOperations ||\n        TLI.isOperationLegalOrCustom(ISD::SSUBO, N->getValueType(0)))\n      return DAG.getNode(ISD::SSUBO, SDLoc(N), N->getVTList(), N0, N1);\n  }\n\n  return SDValue();\n}\n\n// Notice that \"mulfix\" can be any of SMULFIX, SMULFIXSAT, UMULFIX and\n// UMULFIXSAT here.\nSDValue DAGCombiner::visitMULFIX(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  SDValue Scale = N->getOperand(2);\n  EVT VT = N0.getValueType();\n\n  // fold (mulfix x, undef, scale) -> 0\n  if (N0.isUndef() || N1.isUndef())\n    return DAG.getConstant(0, SDLoc(N), VT);\n\n  // Canonicalize constant to RHS (vector doesn't have to splat)\n  if (DAG.isConstantIntBuildVectorOrConstantInt(N0) &&\n     !DAG.isConstantIntBuildVectorOrConstantInt(N1))\n    return DAG.getNode(N->getOpcode(), SDLoc(N), VT, N1, N0, Scale);\n\n  // fold (mulfix x, 0, scale) -> 0\n  if (isNullConstant(N1))\n    return DAG.getConstant(0, SDLoc(N), VT);\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitMUL(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  EVT VT = N0.getValueType();\n\n  // fold (mul x, undef) -> 0\n  if (N0.isUndef() || N1.isUndef())\n    return DAG.getConstant(0, SDLoc(N), VT);\n\n  bool N1IsConst = false;\n  bool N1IsOpaqueConst = false;\n  APInt ConstValue1;\n\n  // fold vector ops\n  if (VT.isVector()) {\n    if (SDValue FoldedVOp = SimplifyVBinOp(N))\n      return FoldedVOp;\n\n    N1IsConst = ISD::isConstantSplatVector(N1.getNode(), ConstValue1);\n    assert((!N1IsConst ||\n            ConstValue1.getBitWidth() == VT.getScalarSizeInBits()) &&\n           \"Splat APInt should be element width\");\n  } else {\n    N1IsConst = isa<ConstantSDNode>(N1);\n    if (N1IsConst) {\n      ConstValue1 = cast<ConstantSDNode>(N1)->getAPIntValue();\n      N1IsOpaqueConst = cast<ConstantSDNode>(N1)->isOpaque();\n    }\n  }\n\n  // fold (mul c1, c2) -> c1*c2\n  if (SDValue C = DAG.FoldConstantArithmetic(ISD::MUL, SDLoc(N), VT, {N0, N1}))\n    return C;\n\n  // canonicalize constant to RHS (vector doesn't have to splat)\n  if (DAG.isConstantIntBuildVectorOrConstantInt(N0) &&\n     !DAG.isConstantIntBuildVectorOrConstantInt(N1))\n    return DAG.getNode(ISD::MUL, SDLoc(N), VT, N1, N0);\n\n  // fold (mul x, 0) -> 0\n  if (N1IsConst && ConstValue1.isNullValue())\n    return N1;\n\n  // fold (mul x, 1) -> x\n  if (N1IsConst && ConstValue1.isOneValue())\n    return N0;\n\n  if (SDValue NewSel = foldBinOpIntoSelect(N))\n    return NewSel;\n\n  // fold (mul x, -1) -> 0-x\n  if (N1IsConst && ConstValue1.isAllOnesValue()) {\n    SDLoc DL(N);\n    return DAG.getNode(ISD::SUB, DL, VT,\n                       DAG.getConstant(0, DL, VT), N0);\n  }\n\n  // fold (mul x, (1 << c)) -> x << c\n  if (isConstantOrConstantVector(N1, /*NoOpaques*/ true) &&\n      DAG.isKnownToBeAPowerOfTwo(N1) &&\n      (!VT.isVector() || Level <= AfterLegalizeVectorOps)) {\n    SDLoc DL(N);\n    SDValue LogBase2 = BuildLogBase2(N1, DL);\n    EVT ShiftVT = getShiftAmountTy(N0.getValueType());\n    SDValue Trunc = DAG.getZExtOrTrunc(LogBase2, DL, ShiftVT);\n    return DAG.getNode(ISD::SHL, DL, VT, N0, Trunc);\n  }\n\n  // fold (mul x, -(1 << c)) -> -(x << c) or (-x) << c\n  if (N1IsConst && !N1IsOpaqueConst && (-ConstValue1).isPowerOf2()) {\n    unsigned Log2Val = (-ConstValue1).logBase2();\n    SDLoc DL(N);\n    // FIXME: If the input is something that is easily negated (e.g. a\n    // single-use add), we should put the negate there.\n    return DAG.getNode(ISD::SUB, DL, VT,\n                       DAG.getConstant(0, DL, VT),\n                       DAG.getNode(ISD::SHL, DL, VT, N0,\n                            DAG.getConstant(Log2Val, DL,\n                                      getShiftAmountTy(N0.getValueType()))));\n  }\n\n  // Try to transform:\n  // (1) multiply-by-(power-of-2 +/- 1) into shift and add/sub.\n  // mul x, (2^N + 1) --> add (shl x, N), x\n  // mul x, (2^N - 1) --> sub (shl x, N), x\n  // Examples: x * 33 --> (x << 5) + x\n  //           x * 15 --> (x << 4) - x\n  //           x * -33 --> -((x << 5) + x)\n  //           x * -15 --> -((x << 4) - x) ; this reduces --> x - (x << 4)\n  // (2) multiply-by-(power-of-2 +/- power-of-2) into shifts and add/sub.\n  // mul x, (2^N + 2^M) --> (add (shl x, N), (shl x, M))\n  // mul x, (2^N - 2^M) --> (sub (shl x, N), (shl x, M))\n  // Examples: x * 0x8800 --> (x << 15) + (x << 11)\n  //           x * 0xf800 --> (x << 16) - (x << 11)\n  //           x * -0x8800 --> -((x << 15) + (x << 11))\n  //           x * -0xf800 --> -((x << 16) - (x << 11)) ; (x << 11) - (x << 16)\n  if (N1IsConst && TLI.decomposeMulByConstant(*DAG.getContext(), VT, N1)) {\n    // TODO: We could handle more general decomposition of any constant by\n    //       having the target set a limit on number of ops and making a\n    //       callback to determine that sequence (similar to sqrt expansion).\n    unsigned MathOp = ISD::DELETED_NODE;\n    APInt MulC = ConstValue1.abs();\n    // The constant `2` should be treated as (2^0 + 1).\n    unsigned TZeros = MulC == 2 ? 0 : MulC.countTrailingZeros();\n    MulC.lshrInPlace(TZeros);\n    if ((MulC - 1).isPowerOf2())\n      MathOp = ISD::ADD;\n    else if ((MulC + 1).isPowerOf2())\n      MathOp = ISD::SUB;\n\n    if (MathOp != ISD::DELETED_NODE) {\n      unsigned ShAmt =\n          MathOp == ISD::ADD ? (MulC - 1).logBase2() : (MulC + 1).logBase2();\n      ShAmt += TZeros;\n      assert(ShAmt < VT.getScalarSizeInBits() &&\n             \"multiply-by-constant generated out of bounds shift\");\n      SDLoc DL(N);\n      SDValue Shl =\n          DAG.getNode(ISD::SHL, DL, VT, N0, DAG.getConstant(ShAmt, DL, VT));\n      SDValue R =\n          TZeros ? DAG.getNode(MathOp, DL, VT, Shl,\n                               DAG.getNode(ISD::SHL, DL, VT, N0,\n                                           DAG.getConstant(TZeros, DL, VT)))\n                 : DAG.getNode(MathOp, DL, VT, Shl, N0);\n      if (ConstValue1.isNegative())\n        R = DAG.getNode(ISD::SUB, DL, VT, DAG.getConstant(0, DL, VT), R);\n      return R;\n    }\n  }\n\n  // (mul (shl X, c1), c2) -> (mul X, c2 << c1)\n  if (N0.getOpcode() == ISD::SHL &&\n      isConstantOrConstantVector(N1, /* NoOpaques */ true) &&\n      isConstantOrConstantVector(N0.getOperand(1), /* NoOpaques */ true)) {\n    SDValue C3 = DAG.getNode(ISD::SHL, SDLoc(N), VT, N1, N0.getOperand(1));\n    if (isConstantOrConstantVector(C3))\n      return DAG.getNode(ISD::MUL, SDLoc(N), VT, N0.getOperand(0), C3);\n  }\n\n  // Change (mul (shl X, C), Y) -> (shl (mul X, Y), C) when the shift has one\n  // use.\n  {\n    SDValue Sh(nullptr, 0), Y(nullptr, 0);\n\n    // Check for both (mul (shl X, C), Y)  and  (mul Y, (shl X, C)).\n    if (N0.getOpcode() == ISD::SHL &&\n        isConstantOrConstantVector(N0.getOperand(1)) &&\n        N0.getNode()->hasOneUse()) {\n      Sh = N0; Y = N1;\n    } else if (N1.getOpcode() == ISD::SHL &&\n               isConstantOrConstantVector(N1.getOperand(1)) &&\n               N1.getNode()->hasOneUse()) {\n      Sh = N1; Y = N0;\n    }\n\n    if (Sh.getNode()) {\n      SDValue Mul = DAG.getNode(ISD::MUL, SDLoc(N), VT, Sh.getOperand(0), Y);\n      return DAG.getNode(ISD::SHL, SDLoc(N), VT, Mul, Sh.getOperand(1));\n    }\n  }\n\n  // fold (mul (add x, c1), c2) -> (add (mul x, c2), c1*c2)\n  if (DAG.isConstantIntBuildVectorOrConstantInt(N1) &&\n      N0.getOpcode() == ISD::ADD &&\n      DAG.isConstantIntBuildVectorOrConstantInt(N0.getOperand(1)) &&\n      isMulAddWithConstProfitable(N, N0, N1))\n      return DAG.getNode(ISD::ADD, SDLoc(N), VT,\n                         DAG.getNode(ISD::MUL, SDLoc(N0), VT,\n                                     N0.getOperand(0), N1),\n                         DAG.getNode(ISD::MUL, SDLoc(N1), VT,\n                                     N0.getOperand(1), N1));\n\n  // Fold (mul (vscale * C0), C1) to (vscale * (C0 * C1)).\n  if (N0.getOpcode() == ISD::VSCALE)\n    if (ConstantSDNode *NC1 = isConstOrConstSplat(N1)) {\n      const APInt &C0 = N0.getConstantOperandAPInt(0);\n      const APInt &C1 = NC1->getAPIntValue();\n      return DAG.getVScale(SDLoc(N), VT, C0 * C1);\n    }\n\n  // Fold ((mul x, 0/undef) -> 0,\n  //       (mul x, 1) -> x) -> x)\n  // -> and(x, mask)\n  // We can replace vectors with '0' and '1' factors with a clearing mask.\n  if (VT.isFixedLengthVector()) {\n    unsigned NumElts = VT.getVectorNumElements();\n    SmallBitVector ClearMask;\n    ClearMask.reserve(NumElts);\n    auto IsClearMask = [&ClearMask](ConstantSDNode *V) {\n      if (!V || V->isNullValue()) {\n        ClearMask.push_back(true);\n        return true;\n      }\n      ClearMask.push_back(false);\n      return V->isOne();\n    };\n    if ((!LegalOperations || TLI.isOperationLegalOrCustom(ISD::AND, VT)) &&\n        ISD::matchUnaryPredicate(N1, IsClearMask, /*AllowUndefs*/ true)) {\n      assert(N1.getOpcode() == ISD::BUILD_VECTOR && \"Unknown constant vector\");\n      SDLoc DL(N);\n      EVT LegalSVT = N1.getOperand(0).getValueType();\n      SDValue Zero = DAG.getConstant(0, DL, LegalSVT);\n      SDValue AllOnes = DAG.getAllOnesConstant(DL, LegalSVT);\n      SmallVector<SDValue, 16> Mask(NumElts, AllOnes);\n      for (unsigned I = 0; I != NumElts; ++I)\n        if (ClearMask[I])\n          Mask[I] = Zero;\n      return DAG.getNode(ISD::AND, DL, VT, N0, DAG.getBuildVector(VT, DL, Mask));\n    }\n  }\n\n  // reassociate mul\n  if (SDValue RMUL = reassociateOps(ISD::MUL, SDLoc(N), N0, N1, N->getFlags()))\n    return RMUL;\n\n  return SDValue();\n}\n\n/// Return true if divmod libcall is available.\nstatic bool isDivRemLibcallAvailable(SDNode *Node, bool isSigned,\n                                     const TargetLowering &TLI) {\n  RTLIB::Libcall LC;\n  EVT NodeType = Node->getValueType(0);\n  if (!NodeType.isSimple())\n    return false;\n  switch (NodeType.getSimpleVT().SimpleTy) {\n  default: return false; // No libcall for vector types.\n  case MVT::i8:   LC= isSigned ? RTLIB::SDIVREM_I8  : RTLIB::UDIVREM_I8;  break;\n  case MVT::i16:  LC= isSigned ? RTLIB::SDIVREM_I16 : RTLIB::UDIVREM_I16; break;\n  case MVT::i32:  LC= isSigned ? RTLIB::SDIVREM_I32 : RTLIB::UDIVREM_I32; break;\n  case MVT::i64:  LC= isSigned ? RTLIB::SDIVREM_I64 : RTLIB::UDIVREM_I64; break;\n  case MVT::i128: LC= isSigned ? RTLIB::SDIVREM_I128:RTLIB::UDIVREM_I128; break;\n  }\n\n  return TLI.getLibcallName(LC) != nullptr;\n}\n\n/// Issue divrem if both quotient and remainder are needed.\nSDValue DAGCombiner::useDivRem(SDNode *Node) {\n  if (Node->use_empty())\n    return SDValue(); // This is a dead node, leave it alone.\n\n  unsigned Opcode = Node->getOpcode();\n  bool isSigned = (Opcode == ISD::SDIV) || (Opcode == ISD::SREM);\n  unsigned DivRemOpc = isSigned ? ISD::SDIVREM : ISD::UDIVREM;\n\n  // DivMod lib calls can still work on non-legal types if using lib-calls.\n  EVT VT = Node->getValueType(0);\n  if (VT.isVector() || !VT.isInteger())\n    return SDValue();\n\n  if (!TLI.isTypeLegal(VT) && !TLI.isOperationCustom(DivRemOpc, VT))\n    return SDValue();\n\n  // If DIVREM is going to get expanded into a libcall,\n  // but there is no libcall available, then don't combine.\n  if (!TLI.isOperationLegalOrCustom(DivRemOpc, VT) &&\n      !isDivRemLibcallAvailable(Node, isSigned, TLI))\n    return SDValue();\n\n  // If div is legal, it's better to do the normal expansion\n  unsigned OtherOpcode = 0;\n  if ((Opcode == ISD::SDIV) || (Opcode == ISD::UDIV)) {\n    OtherOpcode = isSigned ? ISD::SREM : ISD::UREM;\n    if (TLI.isOperationLegalOrCustom(Opcode, VT))\n      return SDValue();\n  } else {\n    OtherOpcode = isSigned ? ISD::SDIV : ISD::UDIV;\n    if (TLI.isOperationLegalOrCustom(OtherOpcode, VT))\n      return SDValue();\n  }\n\n  SDValue Op0 = Node->getOperand(0);\n  SDValue Op1 = Node->getOperand(1);\n  SDValue combined;\n  for (SDNode::use_iterator UI = Op0.getNode()->use_begin(),\n         UE = Op0.getNode()->use_end(); UI != UE; ++UI) {\n    SDNode *User = *UI;\n    if (User == Node || User->getOpcode() == ISD::DELETED_NODE ||\n        User->use_empty())\n      continue;\n    // Convert the other matching node(s), too;\n    // otherwise, the DIVREM may get target-legalized into something\n    // target-specific that we won't be able to recognize.\n    unsigned UserOpc = User->getOpcode();\n    if ((UserOpc == Opcode || UserOpc == OtherOpcode || UserOpc == DivRemOpc) &&\n        User->getOperand(0) == Op0 &&\n        User->getOperand(1) == Op1) {\n      if (!combined) {\n        if (UserOpc == OtherOpcode) {\n          SDVTList VTs = DAG.getVTList(VT, VT);\n          combined = DAG.getNode(DivRemOpc, SDLoc(Node), VTs, Op0, Op1);\n        } else if (UserOpc == DivRemOpc) {\n          combined = SDValue(User, 0);\n        } else {\n          assert(UserOpc == Opcode);\n          continue;\n        }\n      }\n      if (UserOpc == ISD::SDIV || UserOpc == ISD::UDIV)\n        CombineTo(User, combined);\n      else if (UserOpc == ISD::SREM || UserOpc == ISD::UREM)\n        CombineTo(User, combined.getValue(1));\n    }\n  }\n  return combined;\n}\n\nstatic SDValue simplifyDivRem(SDNode *N, SelectionDAG &DAG) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  EVT VT = N->getValueType(0);\n  SDLoc DL(N);\n\n  unsigned Opc = N->getOpcode();\n  bool IsDiv = (ISD::SDIV == Opc) || (ISD::UDIV == Opc);\n  ConstantSDNode *N1C = isConstOrConstSplat(N1);\n\n  // X / undef -> undef\n  // X % undef -> undef\n  // X / 0 -> undef\n  // X % 0 -> undef\n  // NOTE: This includes vectors where any divisor element is zero/undef.\n  if (DAG.isUndef(Opc, {N0, N1}))\n    return DAG.getUNDEF(VT);\n\n  // undef / X -> 0\n  // undef % X -> 0\n  if (N0.isUndef())\n    return DAG.getConstant(0, DL, VT);\n\n  // 0 / X -> 0\n  // 0 % X -> 0\n  ConstantSDNode *N0C = isConstOrConstSplat(N0);\n  if (N0C && N0C->isNullValue())\n    return N0;\n\n  // X / X -> 1\n  // X % X -> 0\n  if (N0 == N1)\n    return DAG.getConstant(IsDiv ? 1 : 0, DL, VT);\n\n  // X / 1 -> X\n  // X % 1 -> 0\n  // If this is a boolean op (single-bit element type), we can't have\n  // division-by-zero or remainder-by-zero, so assume the divisor is 1.\n  // TODO: Similarly, if we're zero-extending a boolean divisor, then assume\n  // it's a 1.\n  if ((N1C && N1C->isOne()) || (VT.getScalarType() == MVT::i1))\n    return IsDiv ? N0 : DAG.getConstant(0, DL, VT);\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitSDIV(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  EVT VT = N->getValueType(0);\n  EVT CCVT = getSetCCResultType(VT);\n\n  // fold vector ops\n  if (VT.isVector())\n    if (SDValue FoldedVOp = SimplifyVBinOp(N))\n      return FoldedVOp;\n\n  SDLoc DL(N);\n\n  // fold (sdiv c1, c2) -> c1/c2\n  ConstantSDNode *N1C = isConstOrConstSplat(N1);\n  if (SDValue C = DAG.FoldConstantArithmetic(ISD::SDIV, DL, VT, {N0, N1}))\n    return C;\n\n  // fold (sdiv X, -1) -> 0-X\n  if (N1C && N1C->isAllOnesValue())\n    return DAG.getNode(ISD::SUB, DL, VT, DAG.getConstant(0, DL, VT), N0);\n\n  // fold (sdiv X, MIN_SIGNED) -> select(X == MIN_SIGNED, 1, 0)\n  if (N1C && N1C->getAPIntValue().isMinSignedValue())\n    return DAG.getSelect(DL, VT, DAG.getSetCC(DL, CCVT, N0, N1, ISD::SETEQ),\n                         DAG.getConstant(1, DL, VT),\n                         DAG.getConstant(0, DL, VT));\n\n  if (SDValue V = simplifyDivRem(N, DAG))\n    return V;\n\n  if (SDValue NewSel = foldBinOpIntoSelect(N))\n    return NewSel;\n\n  // If we know the sign bits of both operands are zero, strength reduce to a\n  // udiv instead.  Handles (X&15) /s 4 -> X&15 >> 2\n  if (DAG.SignBitIsZero(N1) && DAG.SignBitIsZero(N0))\n    return DAG.getNode(ISD::UDIV, DL, N1.getValueType(), N0, N1);\n\n  if (SDValue V = visitSDIVLike(N0, N1, N)) {\n    // If the corresponding remainder node exists, update its users with\n    // (Dividend - (Quotient * Divisor).\n    if (SDNode *RemNode = DAG.getNodeIfExists(ISD::SREM, N->getVTList(),\n                                              { N0, N1 })) {\n      SDValue Mul = DAG.getNode(ISD::MUL, DL, VT, V, N1);\n      SDValue Sub = DAG.getNode(ISD::SUB, DL, VT, N0, Mul);\n      AddToWorklist(Mul.getNode());\n      AddToWorklist(Sub.getNode());\n      CombineTo(RemNode, Sub);\n    }\n    return V;\n  }\n\n  // sdiv, srem -> sdivrem\n  // If the divisor is constant, then return DIVREM only if isIntDivCheap() is\n  // true.  Otherwise, we break the simplification logic in visitREM().\n  AttributeList Attr = DAG.getMachineFunction().getFunction().getAttributes();\n  if (!N1C || TLI.isIntDivCheap(N->getValueType(0), Attr))\n    if (SDValue DivRem = useDivRem(N))\n        return DivRem;\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitSDIVLike(SDValue N0, SDValue N1, SDNode *N) {\n  SDLoc DL(N);\n  EVT VT = N->getValueType(0);\n  EVT CCVT = getSetCCResultType(VT);\n  unsigned BitWidth = VT.getScalarSizeInBits();\n\n  // Helper for determining whether a value is a power-2 constant scalar or a\n  // vector of such elements.\n  auto IsPowerOfTwo = [](ConstantSDNode *C) {\n    if (C->isNullValue() || C->isOpaque())\n      return false;\n    if (C->getAPIntValue().isPowerOf2())\n      return true;\n    if ((-C->getAPIntValue()).isPowerOf2())\n      return true;\n    return false;\n  };\n\n  // fold (sdiv X, pow2) -> simple ops after legalize\n  // FIXME: We check for the exact bit here because the generic lowering gives\n  // better results in that case. The target-specific lowering should learn how\n  // to handle exact sdivs efficiently.\n  if (!N->getFlags().hasExact() && ISD::matchUnaryPredicate(N1, IsPowerOfTwo)) {\n    // Target-specific implementation of sdiv x, pow2.\n    if (SDValue Res = BuildSDIVPow2(N))\n      return Res;\n\n    // Create constants that are functions of the shift amount value.\n    EVT ShiftAmtTy = getShiftAmountTy(N0.getValueType());\n    SDValue Bits = DAG.getConstant(BitWidth, DL, ShiftAmtTy);\n    SDValue C1 = DAG.getNode(ISD::CTTZ, DL, VT, N1);\n    C1 = DAG.getZExtOrTrunc(C1, DL, ShiftAmtTy);\n    SDValue Inexact = DAG.getNode(ISD::SUB, DL, ShiftAmtTy, Bits, C1);\n    if (!isConstantOrConstantVector(Inexact))\n      return SDValue();\n\n    // Splat the sign bit into the register\n    SDValue Sign = DAG.getNode(ISD::SRA, DL, VT, N0,\n                               DAG.getConstant(BitWidth - 1, DL, ShiftAmtTy));\n    AddToWorklist(Sign.getNode());\n\n    // Add (N0 < 0) ? abs2 - 1 : 0;\n    SDValue Srl = DAG.getNode(ISD::SRL, DL, VT, Sign, Inexact);\n    AddToWorklist(Srl.getNode());\n    SDValue Add = DAG.getNode(ISD::ADD, DL, VT, N0, Srl);\n    AddToWorklist(Add.getNode());\n    SDValue Sra = DAG.getNode(ISD::SRA, DL, VT, Add, C1);\n    AddToWorklist(Sra.getNode());\n\n    // Special case: (sdiv X, 1) -> X\n    // Special Case: (sdiv X, -1) -> 0-X\n    SDValue One = DAG.getConstant(1, DL, VT);\n    SDValue AllOnes = DAG.getAllOnesConstant(DL, VT);\n    SDValue IsOne = DAG.getSetCC(DL, CCVT, N1, One, ISD::SETEQ);\n    SDValue IsAllOnes = DAG.getSetCC(DL, CCVT, N1, AllOnes, ISD::SETEQ);\n    SDValue IsOneOrAllOnes = DAG.getNode(ISD::OR, DL, CCVT, IsOne, IsAllOnes);\n    Sra = DAG.getSelect(DL, VT, IsOneOrAllOnes, N0, Sra);\n\n    // If dividing by a positive value, we're done. Otherwise, the result must\n    // be negated.\n    SDValue Zero = DAG.getConstant(0, DL, VT);\n    SDValue Sub = DAG.getNode(ISD::SUB, DL, VT, Zero, Sra);\n\n    // FIXME: Use SELECT_CC once we improve SELECT_CC constant-folding.\n    SDValue IsNeg = DAG.getSetCC(DL, CCVT, N1, Zero, ISD::SETLT);\n    SDValue Res = DAG.getSelect(DL, VT, IsNeg, Sub, Sra);\n    return Res;\n  }\n\n  // If integer divide is expensive and we satisfy the requirements, emit an\n  // alternate sequence.  Targets may check function attributes for size/speed\n  // trade-offs.\n  AttributeList Attr = DAG.getMachineFunction().getFunction().getAttributes();\n  if (isConstantOrConstantVector(N1) &&\n      !TLI.isIntDivCheap(N->getValueType(0), Attr))\n    if (SDValue Op = BuildSDIV(N))\n      return Op;\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitUDIV(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  EVT VT = N->getValueType(0);\n  EVT CCVT = getSetCCResultType(VT);\n\n  // fold vector ops\n  if (VT.isVector())\n    if (SDValue FoldedVOp = SimplifyVBinOp(N))\n      return FoldedVOp;\n\n  SDLoc DL(N);\n\n  // fold (udiv c1, c2) -> c1/c2\n  ConstantSDNode *N1C = isConstOrConstSplat(N1);\n  if (SDValue C = DAG.FoldConstantArithmetic(ISD::UDIV, DL, VT, {N0, N1}))\n    return C;\n\n  // fold (udiv X, -1) -> select(X == -1, 1, 0)\n  if (N1C && N1C->getAPIntValue().isAllOnesValue())\n    return DAG.getSelect(DL, VT, DAG.getSetCC(DL, CCVT, N0, N1, ISD::SETEQ),\n                         DAG.getConstant(1, DL, VT),\n                         DAG.getConstant(0, DL, VT));\n\n  if (SDValue V = simplifyDivRem(N, DAG))\n    return V;\n\n  if (SDValue NewSel = foldBinOpIntoSelect(N))\n    return NewSel;\n\n  if (SDValue V = visitUDIVLike(N0, N1, N)) {\n    // If the corresponding remainder node exists, update its users with\n    // (Dividend - (Quotient * Divisor).\n    if (SDNode *RemNode = DAG.getNodeIfExists(ISD::UREM, N->getVTList(),\n                                              { N0, N1 })) {\n      SDValue Mul = DAG.getNode(ISD::MUL, DL, VT, V, N1);\n      SDValue Sub = DAG.getNode(ISD::SUB, DL, VT, N0, Mul);\n      AddToWorklist(Mul.getNode());\n      AddToWorklist(Sub.getNode());\n      CombineTo(RemNode, Sub);\n    }\n    return V;\n  }\n\n  // sdiv, srem -> sdivrem\n  // If the divisor is constant, then return DIVREM only if isIntDivCheap() is\n  // true.  Otherwise, we break the simplification logic in visitREM().\n  AttributeList Attr = DAG.getMachineFunction().getFunction().getAttributes();\n  if (!N1C || TLI.isIntDivCheap(N->getValueType(0), Attr))\n    if (SDValue DivRem = useDivRem(N))\n        return DivRem;\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitUDIVLike(SDValue N0, SDValue N1, SDNode *N) {\n  SDLoc DL(N);\n  EVT VT = N->getValueType(0);\n\n  // fold (udiv x, (1 << c)) -> x >>u c\n  if (isConstantOrConstantVector(N1, /*NoOpaques*/ true) &&\n      DAG.isKnownToBeAPowerOfTwo(N1)) {\n    SDValue LogBase2 = BuildLogBase2(N1, DL);\n    AddToWorklist(LogBase2.getNode());\n\n    EVT ShiftVT = getShiftAmountTy(N0.getValueType());\n    SDValue Trunc = DAG.getZExtOrTrunc(LogBase2, DL, ShiftVT);\n    AddToWorklist(Trunc.getNode());\n    return DAG.getNode(ISD::SRL, DL, VT, N0, Trunc);\n  }\n\n  // fold (udiv x, (shl c, y)) -> x >>u (log2(c)+y) iff c is power of 2\n  if (N1.getOpcode() == ISD::SHL) {\n    SDValue N10 = N1.getOperand(0);\n    if (isConstantOrConstantVector(N10, /*NoOpaques*/ true) &&\n        DAG.isKnownToBeAPowerOfTwo(N10)) {\n      SDValue LogBase2 = BuildLogBase2(N10, DL);\n      AddToWorklist(LogBase2.getNode());\n\n      EVT ADDVT = N1.getOperand(1).getValueType();\n      SDValue Trunc = DAG.getZExtOrTrunc(LogBase2, DL, ADDVT);\n      AddToWorklist(Trunc.getNode());\n      SDValue Add = DAG.getNode(ISD::ADD, DL, ADDVT, N1.getOperand(1), Trunc);\n      AddToWorklist(Add.getNode());\n      return DAG.getNode(ISD::SRL, DL, VT, N0, Add);\n    }\n  }\n\n  // fold (udiv x, c) -> alternate\n  AttributeList Attr = DAG.getMachineFunction().getFunction().getAttributes();\n  if (isConstantOrConstantVector(N1) &&\n      !TLI.isIntDivCheap(N->getValueType(0), Attr))\n    if (SDValue Op = BuildUDIV(N))\n      return Op;\n\n  return SDValue();\n}\n\n// handles ISD::SREM and ISD::UREM\nSDValue DAGCombiner::visitREM(SDNode *N) {\n  unsigned Opcode = N->getOpcode();\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  EVT VT = N->getValueType(0);\n  EVT CCVT = getSetCCResultType(VT);\n\n  bool isSigned = (Opcode == ISD::SREM);\n  SDLoc DL(N);\n\n  // fold (rem c1, c2) -> c1%c2\n  ConstantSDNode *N1C = isConstOrConstSplat(N1);\n  if (SDValue C = DAG.FoldConstantArithmetic(Opcode, DL, VT, {N0, N1}))\n    return C;\n\n  // fold (urem X, -1) -> select(X == -1, 0, x)\n  if (!isSigned && N1C && N1C->getAPIntValue().isAllOnesValue())\n    return DAG.getSelect(DL, VT, DAG.getSetCC(DL, CCVT, N0, N1, ISD::SETEQ),\n                         DAG.getConstant(0, DL, VT), N0);\n\n  if (SDValue V = simplifyDivRem(N, DAG))\n    return V;\n\n  if (SDValue NewSel = foldBinOpIntoSelect(N))\n    return NewSel;\n\n  if (isSigned) {\n    // If we know the sign bits of both operands are zero, strength reduce to a\n    // urem instead.  Handles (X & 0x0FFFFFFF) %s 16 -> X&15\n    if (DAG.SignBitIsZero(N1) && DAG.SignBitIsZero(N0))\n      return DAG.getNode(ISD::UREM, DL, VT, N0, N1);\n  } else {\n    if (DAG.isKnownToBeAPowerOfTwo(N1)) {\n      // fold (urem x, pow2) -> (and x, pow2-1)\n      SDValue NegOne = DAG.getAllOnesConstant(DL, VT);\n      SDValue Add = DAG.getNode(ISD::ADD, DL, VT, N1, NegOne);\n      AddToWorklist(Add.getNode());\n      return DAG.getNode(ISD::AND, DL, VT, N0, Add);\n    }\n    if (N1.getOpcode() == ISD::SHL &&\n        DAG.isKnownToBeAPowerOfTwo(N1.getOperand(0))) {\n      // fold (urem x, (shl pow2, y)) -> (and x, (add (shl pow2, y), -1))\n      SDValue NegOne = DAG.getAllOnesConstant(DL, VT);\n      SDValue Add = DAG.getNode(ISD::ADD, DL, VT, N1, NegOne);\n      AddToWorklist(Add.getNode());\n      return DAG.getNode(ISD::AND, DL, VT, N0, Add);\n    }\n  }\n\n  AttributeList Attr = DAG.getMachineFunction().getFunction().getAttributes();\n\n  // If X/C can be simplified by the division-by-constant logic, lower\n  // X%C to the equivalent of X-X/C*C.\n  // Reuse the SDIVLike/UDIVLike combines - to avoid mangling nodes, the\n  // speculative DIV must not cause a DIVREM conversion.  We guard against this\n  // by skipping the simplification if isIntDivCheap().  When div is not cheap,\n  // combine will not return a DIVREM.  Regardless, checking cheapness here\n  // makes sense since the simplification results in fatter code.\n  if (DAG.isKnownNeverZero(N1) && !TLI.isIntDivCheap(VT, Attr)) {\n    SDValue OptimizedDiv =\n        isSigned ? visitSDIVLike(N0, N1, N) : visitUDIVLike(N0, N1, N);\n    if (OptimizedDiv.getNode()) {\n      // If the equivalent Div node also exists, update its users.\n      unsigned DivOpcode = isSigned ? ISD::SDIV : ISD::UDIV;\n      if (SDNode *DivNode = DAG.getNodeIfExists(DivOpcode, N->getVTList(),\n                                                { N0, N1 }))\n        CombineTo(DivNode, OptimizedDiv);\n      SDValue Mul = DAG.getNode(ISD::MUL, DL, VT, OptimizedDiv, N1);\n      SDValue Sub = DAG.getNode(ISD::SUB, DL, VT, N0, Mul);\n      AddToWorklist(OptimizedDiv.getNode());\n      AddToWorklist(Mul.getNode());\n      return Sub;\n    }\n  }\n\n  // sdiv, srem -> sdivrem\n  if (SDValue DivRem = useDivRem(N))\n    return DivRem.getValue(1);\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitMULHS(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  EVT VT = N->getValueType(0);\n  SDLoc DL(N);\n\n  if (VT.isVector()) {\n    // fold (mulhs x, 0) -> 0\n    // do not return N0/N1, because undef node may exist.\n    if (ISD::isBuildVectorAllZeros(N0.getNode()) ||\n        ISD::isBuildVectorAllZeros(N1.getNode()))\n      return DAG.getConstant(0, DL, VT);\n  }\n\n  // fold (mulhs x, 0) -> 0\n  if (isNullConstant(N1))\n    return N1;\n  // fold (mulhs x, 1) -> (sra x, size(x)-1)\n  if (isOneConstant(N1))\n    return DAG.getNode(ISD::SRA, DL, N0.getValueType(), N0,\n                       DAG.getConstant(N0.getScalarValueSizeInBits() - 1, DL,\n                                       getShiftAmountTy(N0.getValueType())));\n\n  // fold (mulhs x, undef) -> 0\n  if (N0.isUndef() || N1.isUndef())\n    return DAG.getConstant(0, DL, VT);\n\n  // If the type twice as wide is legal, transform the mulhs to a wider multiply\n  // plus a shift.\n  if (!TLI.isOperationLegalOrCustom(ISD::MULHS, VT) && VT.isSimple() &&\n      !VT.isVector()) {\n    MVT Simple = VT.getSimpleVT();\n    unsigned SimpleSize = Simple.getSizeInBits();\n    EVT NewVT = EVT::getIntegerVT(*DAG.getContext(), SimpleSize*2);\n    if (TLI.isOperationLegal(ISD::MUL, NewVT)) {\n      N0 = DAG.getNode(ISD::SIGN_EXTEND, DL, NewVT, N0);\n      N1 = DAG.getNode(ISD::SIGN_EXTEND, DL, NewVT, N1);\n      N1 = DAG.getNode(ISD::MUL, DL, NewVT, N0, N1);\n      N1 = DAG.getNode(ISD::SRL, DL, NewVT, N1,\n            DAG.getConstant(SimpleSize, DL,\n                            getShiftAmountTy(N1.getValueType())));\n      return DAG.getNode(ISD::TRUNCATE, DL, VT, N1);\n    }\n  }\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitMULHU(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  EVT VT = N->getValueType(0);\n  SDLoc DL(N);\n\n  if (VT.isVector()) {\n    // fold (mulhu x, 0) -> 0\n    // do not return N0/N1, because undef node may exist.\n    if (ISD::isBuildVectorAllZeros(N0.getNode()) ||\n        ISD::isBuildVectorAllZeros(N1.getNode()))\n      return DAG.getConstant(0, DL, VT);\n  }\n\n  // fold (mulhu x, 0) -> 0\n  if (isNullConstant(N1))\n    return N1;\n  // fold (mulhu x, 1) -> 0\n  if (isOneConstant(N1))\n    return DAG.getConstant(0, DL, N0.getValueType());\n  // fold (mulhu x, undef) -> 0\n  if (N0.isUndef() || N1.isUndef())\n    return DAG.getConstant(0, DL, VT);\n\n  // fold (mulhu x, (1 << c)) -> x >> (bitwidth - c)\n  if (isConstantOrConstantVector(N1, /*NoOpaques*/ true) &&\n      DAG.isKnownToBeAPowerOfTwo(N1) && hasOperation(ISD::SRL, VT)) {\n    unsigned NumEltBits = VT.getScalarSizeInBits();\n    SDValue LogBase2 = BuildLogBase2(N1, DL);\n    SDValue SRLAmt = DAG.getNode(\n        ISD::SUB, DL, VT, DAG.getConstant(NumEltBits, DL, VT), LogBase2);\n    EVT ShiftVT = getShiftAmountTy(N0.getValueType());\n    SDValue Trunc = DAG.getZExtOrTrunc(SRLAmt, DL, ShiftVT);\n    return DAG.getNode(ISD::SRL, DL, VT, N0, Trunc);\n  }\n\n  // If the type twice as wide is legal, transform the mulhu to a wider multiply\n  // plus a shift.\n  if (!TLI.isOperationLegalOrCustom(ISD::MULHU, VT) && VT.isSimple() &&\n      !VT.isVector()) {\n    MVT Simple = VT.getSimpleVT();\n    unsigned SimpleSize = Simple.getSizeInBits();\n    EVT NewVT = EVT::getIntegerVT(*DAG.getContext(), SimpleSize*2);\n    if (TLI.isOperationLegal(ISD::MUL, NewVT)) {\n      N0 = DAG.getNode(ISD::ZERO_EXTEND, DL, NewVT, N0);\n      N1 = DAG.getNode(ISD::ZERO_EXTEND, DL, NewVT, N1);\n      N1 = DAG.getNode(ISD::MUL, DL, NewVT, N0, N1);\n      N1 = DAG.getNode(ISD::SRL, DL, NewVT, N1,\n            DAG.getConstant(SimpleSize, DL,\n                            getShiftAmountTy(N1.getValueType())));\n      return DAG.getNode(ISD::TRUNCATE, DL, VT, N1);\n    }\n  }\n\n  return SDValue();\n}\n\n/// Perform optimizations common to nodes that compute two values. LoOp and HiOp\n/// give the opcodes for the two computations that are being performed. Return\n/// true if a simplification was made.\nSDValue DAGCombiner::SimplifyNodeWithTwoResults(SDNode *N, unsigned LoOp,\n                                                unsigned HiOp) {\n  // If the high half is not needed, just compute the low half.\n  bool HiExists = N->hasAnyUseOfValue(1);\n  if (!HiExists && (!LegalOperations ||\n                    TLI.isOperationLegalOrCustom(LoOp, N->getValueType(0)))) {\n    SDValue Res = DAG.getNode(LoOp, SDLoc(N), N->getValueType(0), N->ops());\n    return CombineTo(N, Res, Res);\n  }\n\n  // If the low half is not needed, just compute the high half.\n  bool LoExists = N->hasAnyUseOfValue(0);\n  if (!LoExists && (!LegalOperations ||\n                    TLI.isOperationLegalOrCustom(HiOp, N->getValueType(1)))) {\n    SDValue Res = DAG.getNode(HiOp, SDLoc(N), N->getValueType(1), N->ops());\n    return CombineTo(N, Res, Res);\n  }\n\n  // If both halves are used, return as it is.\n  if (LoExists && HiExists)\n    return SDValue();\n\n  // If the two computed results can be simplified separately, separate them.\n  if (LoExists) {\n    SDValue Lo = DAG.getNode(LoOp, SDLoc(N), N->getValueType(0), N->ops());\n    AddToWorklist(Lo.getNode());\n    SDValue LoOpt = combine(Lo.getNode());\n    if (LoOpt.getNode() && LoOpt.getNode() != Lo.getNode() &&\n        (!LegalOperations ||\n         TLI.isOperationLegalOrCustom(LoOpt.getOpcode(), LoOpt.getValueType())))\n      return CombineTo(N, LoOpt, LoOpt);\n  }\n\n  if (HiExists) {\n    SDValue Hi = DAG.getNode(HiOp, SDLoc(N), N->getValueType(1), N->ops());\n    AddToWorklist(Hi.getNode());\n    SDValue HiOpt = combine(Hi.getNode());\n    if (HiOpt.getNode() && HiOpt != Hi &&\n        (!LegalOperations ||\n         TLI.isOperationLegalOrCustom(HiOpt.getOpcode(), HiOpt.getValueType())))\n      return CombineTo(N, HiOpt, HiOpt);\n  }\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitSMUL_LOHI(SDNode *N) {\n  if (SDValue Res = SimplifyNodeWithTwoResults(N, ISD::MUL, ISD::MULHS))\n    return Res;\n\n  EVT VT = N->getValueType(0);\n  SDLoc DL(N);\n\n  // If the type is twice as wide is legal, transform the mulhu to a wider\n  // multiply plus a shift.\n  if (VT.isSimple() && !VT.isVector()) {\n    MVT Simple = VT.getSimpleVT();\n    unsigned SimpleSize = Simple.getSizeInBits();\n    EVT NewVT = EVT::getIntegerVT(*DAG.getContext(), SimpleSize*2);\n    if (TLI.isOperationLegal(ISD::MUL, NewVT)) {\n      SDValue Lo = DAG.getNode(ISD::SIGN_EXTEND, DL, NewVT, N->getOperand(0));\n      SDValue Hi = DAG.getNode(ISD::SIGN_EXTEND, DL, NewVT, N->getOperand(1));\n      Lo = DAG.getNode(ISD::MUL, DL, NewVT, Lo, Hi);\n      // Compute the high part as N1.\n      Hi = DAG.getNode(ISD::SRL, DL, NewVT, Lo,\n            DAG.getConstant(SimpleSize, DL,\n                            getShiftAmountTy(Lo.getValueType())));\n      Hi = DAG.getNode(ISD::TRUNCATE, DL, VT, Hi);\n      // Compute the low part as N0.\n      Lo = DAG.getNode(ISD::TRUNCATE, DL, VT, Lo);\n      return CombineTo(N, Lo, Hi);\n    }\n  }\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitUMUL_LOHI(SDNode *N) {\n  if (SDValue Res = SimplifyNodeWithTwoResults(N, ISD::MUL, ISD::MULHU))\n    return Res;\n\n  EVT VT = N->getValueType(0);\n  SDLoc DL(N);\n\n  // (umul_lohi N0, 0) -> (0, 0)\n  if (isNullConstant(N->getOperand(1))) {\n    SDValue Zero = DAG.getConstant(0, DL, VT);\n    return CombineTo(N, Zero, Zero);\n  }\n\n  // (umul_lohi N0, 1) -> (N0, 0)\n  if (isOneConstant(N->getOperand(1))) {\n    SDValue Zero = DAG.getConstant(0, DL, VT);\n    return CombineTo(N, N->getOperand(0), Zero);\n  }\n\n  // If the type is twice as wide is legal, transform the mulhu to a wider\n  // multiply plus a shift.\n  if (VT.isSimple() && !VT.isVector()) {\n    MVT Simple = VT.getSimpleVT();\n    unsigned SimpleSize = Simple.getSizeInBits();\n    EVT NewVT = EVT::getIntegerVT(*DAG.getContext(), SimpleSize*2);\n    if (TLI.isOperationLegal(ISD::MUL, NewVT)) {\n      SDValue Lo = DAG.getNode(ISD::ZERO_EXTEND, DL, NewVT, N->getOperand(0));\n      SDValue Hi = DAG.getNode(ISD::ZERO_EXTEND, DL, NewVT, N->getOperand(1));\n      Lo = DAG.getNode(ISD::MUL, DL, NewVT, Lo, Hi);\n      // Compute the high part as N1.\n      Hi = DAG.getNode(ISD::SRL, DL, NewVT, Lo,\n            DAG.getConstant(SimpleSize, DL,\n                            getShiftAmountTy(Lo.getValueType())));\n      Hi = DAG.getNode(ISD::TRUNCATE, DL, VT, Hi);\n      // Compute the low part as N0.\n      Lo = DAG.getNode(ISD::TRUNCATE, DL, VT, Lo);\n      return CombineTo(N, Lo, Hi);\n    }\n  }\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitMULO(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  EVT VT = N0.getValueType();\n  bool IsSigned = (ISD::SMULO == N->getOpcode());\n\n  EVT CarryVT = N->getValueType(1);\n  SDLoc DL(N);\n\n  ConstantSDNode *N0C = isConstOrConstSplat(N0);\n  ConstantSDNode *N1C = isConstOrConstSplat(N1);\n\n  // fold operation with constant operands.\n  // TODO: Move this to FoldConstantArithmetic when it supports nodes with\n  // multiple results.\n  if (N0C && N1C) {\n    bool Overflow;\n    APInt Result =\n        IsSigned ? N0C->getAPIntValue().smul_ov(N1C->getAPIntValue(), Overflow)\n                 : N0C->getAPIntValue().umul_ov(N1C->getAPIntValue(), Overflow);\n    return CombineTo(N, DAG.getConstant(Result, DL, VT),\n                     DAG.getBoolConstant(Overflow, DL, CarryVT, CarryVT));\n  }\n\n  // canonicalize constant to RHS.\n  if (DAG.isConstantIntBuildVectorOrConstantInt(N0) &&\n      !DAG.isConstantIntBuildVectorOrConstantInt(N1))\n    return DAG.getNode(N->getOpcode(), DL, N->getVTList(), N1, N0);\n\n  // fold (mulo x, 0) -> 0 + no carry out\n  if (isNullOrNullSplat(N1))\n    return CombineTo(N, DAG.getConstant(0, DL, VT),\n                     DAG.getConstant(0, DL, CarryVT));\n\n  // (mulo x, 2) -> (addo x, x)\n  if (N1C && N1C->getAPIntValue() == 2)\n    return DAG.getNode(IsSigned ? ISD::SADDO : ISD::UADDO, DL,\n                       N->getVTList(), N0, N0);\n\n  if (IsSigned) {\n    // A 1 bit SMULO overflows if both inputs are 1.\n    if (VT.getScalarSizeInBits() == 1) {\n      SDValue And = DAG.getNode(ISD::AND, DL, VT, N0, N1);\n      return CombineTo(N, And,\n                       DAG.getSetCC(DL, CarryVT, And,\n                                    DAG.getConstant(0, DL, VT), ISD::SETNE));\n    }\n\n    // Multiplying n * m significant bits yields a result of n + m significant\n    // bits. If the total number of significant bits does not exceed the\n    // result bit width (minus 1), there is no overflow.\n    unsigned SignBits = DAG.ComputeNumSignBits(N0);\n    if (SignBits > 1)\n      SignBits += DAG.ComputeNumSignBits(N1);\n    if (SignBits > VT.getScalarSizeInBits() + 1)\n      return CombineTo(N, DAG.getNode(ISD::MUL, DL, VT, N0, N1),\n                       DAG.getConstant(0, DL, CarryVT));\n  } else {\n    KnownBits N1Known = DAG.computeKnownBits(N1);\n    KnownBits N0Known = DAG.computeKnownBits(N0);\n    bool Overflow;\n    (void)N0Known.getMaxValue().umul_ov(N1Known.getMaxValue(), Overflow);\n    if (!Overflow)\n      return CombineTo(N, DAG.getNode(ISD::MUL, DL, VT, N0, N1),\n                       DAG.getConstant(0, DL, CarryVT));\n  }\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitIMINMAX(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  EVT VT = N0.getValueType();\n  unsigned Opcode = N->getOpcode();\n\n  // fold vector ops\n  if (VT.isVector())\n    if (SDValue FoldedVOp = SimplifyVBinOp(N))\n      return FoldedVOp;\n\n  // fold operation with constant operands.\n  if (SDValue C = DAG.FoldConstantArithmetic(Opcode, SDLoc(N), VT, {N0, N1}))\n    return C;\n\n  // canonicalize constant to RHS\n  if (DAG.isConstantIntBuildVectorOrConstantInt(N0) &&\n      !DAG.isConstantIntBuildVectorOrConstantInt(N1))\n    return DAG.getNode(N->getOpcode(), SDLoc(N), VT, N1, N0);\n\n  // Is sign bits are zero, flip between UMIN/UMAX and SMIN/SMAX.\n  // Only do this if the current op isn't legal and the flipped is.\n  if (!TLI.isOperationLegal(Opcode, VT) &&\n      (N0.isUndef() || DAG.SignBitIsZero(N0)) &&\n      (N1.isUndef() || DAG.SignBitIsZero(N1))) {\n    unsigned AltOpcode;\n    switch (Opcode) {\n    case ISD::SMIN: AltOpcode = ISD::UMIN; break;\n    case ISD::SMAX: AltOpcode = ISD::UMAX; break;\n    case ISD::UMIN: AltOpcode = ISD::SMIN; break;\n    case ISD::UMAX: AltOpcode = ISD::SMAX; break;\n    default: llvm_unreachable(\"Unknown MINMAX opcode\");\n    }\n    if (TLI.isOperationLegal(AltOpcode, VT))\n      return DAG.getNode(AltOpcode, SDLoc(N), VT, N0, N1);\n  }\n\n  // Simplify the operands using demanded-bits information.\n  if (SimplifyDemandedBits(SDValue(N, 0)))\n    return SDValue(N, 0);\n\n  return SDValue();\n}\n\n/// If this is a bitwise logic instruction and both operands have the same\n/// opcode, try to sink the other opcode after the logic instruction.\nSDValue DAGCombiner::hoistLogicOpWithSameOpcodeHands(SDNode *N) {\n  SDValue N0 = N->getOperand(0), N1 = N->getOperand(1);\n  EVT VT = N0.getValueType();\n  unsigned LogicOpcode = N->getOpcode();\n  unsigned HandOpcode = N0.getOpcode();\n  assert((LogicOpcode == ISD::AND || LogicOpcode == ISD::OR ||\n          LogicOpcode == ISD::XOR) && \"Expected logic opcode\");\n  assert(HandOpcode == N1.getOpcode() && \"Bad input!\");\n\n  // Bail early if none of these transforms apply.\n  if (N0.getNumOperands() == 0)\n    return SDValue();\n\n  // FIXME: We should check number of uses of the operands to not increase\n  //        the instruction count for all transforms.\n\n  // Handle size-changing casts.\n  SDValue X = N0.getOperand(0);\n  SDValue Y = N1.getOperand(0);\n  EVT XVT = X.getValueType();\n  SDLoc DL(N);\n  if (HandOpcode == ISD::ANY_EXTEND || HandOpcode == ISD::ZERO_EXTEND ||\n      HandOpcode == ISD::SIGN_EXTEND) {\n    // If both operands have other uses, this transform would create extra\n    // instructions without eliminating anything.\n    if (!N0.hasOneUse() && !N1.hasOneUse())\n      return SDValue();\n    // We need matching integer source types.\n    if (XVT != Y.getValueType())\n      return SDValue();\n    // Don't create an illegal op during or after legalization. Don't ever\n    // create an unsupported vector op.\n    if ((VT.isVector() || LegalOperations) &&\n        !TLI.isOperationLegalOrCustom(LogicOpcode, XVT))\n      return SDValue();\n    // Avoid infinite looping with PromoteIntBinOp.\n    // TODO: Should we apply desirable/legal constraints to all opcodes?\n    if (HandOpcode == ISD::ANY_EXTEND && LegalTypes &&\n        !TLI.isTypeDesirableForOp(LogicOpcode, XVT))\n      return SDValue();\n    // logic_op (hand_op X), (hand_op Y) --> hand_op (logic_op X, Y)\n    SDValue Logic = DAG.getNode(LogicOpcode, DL, XVT, X, Y);\n    return DAG.getNode(HandOpcode, DL, VT, Logic);\n  }\n\n  // logic_op (truncate x), (truncate y) --> truncate (logic_op x, y)\n  if (HandOpcode == ISD::TRUNCATE) {\n    // If both operands have other uses, this transform would create extra\n    // instructions without eliminating anything.\n    if (!N0.hasOneUse() && !N1.hasOneUse())\n      return SDValue();\n    // We need matching source types.\n    if (XVT != Y.getValueType())\n      return SDValue();\n    // Don't create an illegal op during or after legalization.\n    if (LegalOperations && !TLI.isOperationLegal(LogicOpcode, XVT))\n      return SDValue();\n    // Be extra careful sinking truncate. If it's free, there's no benefit in\n    // widening a binop. Also, don't create a logic op on an illegal type.\n    if (TLI.isZExtFree(VT, XVT) && TLI.isTruncateFree(XVT, VT))\n      return SDValue();\n    if (!TLI.isTypeLegal(XVT))\n      return SDValue();\n    SDValue Logic = DAG.getNode(LogicOpcode, DL, XVT, X, Y);\n    return DAG.getNode(HandOpcode, DL, VT, Logic);\n  }\n\n  // For binops SHL/SRL/SRA/AND:\n  //   logic_op (OP x, z), (OP y, z) --> OP (logic_op x, y), z\n  if ((HandOpcode == ISD::SHL || HandOpcode == ISD::SRL ||\n       HandOpcode == ISD::SRA || HandOpcode == ISD::AND) &&\n      N0.getOperand(1) == N1.getOperand(1)) {\n    // If either operand has other uses, this transform is not an improvement.\n    if (!N0.hasOneUse() || !N1.hasOneUse())\n      return SDValue();\n    SDValue Logic = DAG.getNode(LogicOpcode, DL, XVT, X, Y);\n    return DAG.getNode(HandOpcode, DL, VT, Logic, N0.getOperand(1));\n  }\n\n  // Unary ops: logic_op (bswap x), (bswap y) --> bswap (logic_op x, y)\n  if (HandOpcode == ISD::BSWAP) {\n    // If either operand has other uses, this transform is not an improvement.\n    if (!N0.hasOneUse() || !N1.hasOneUse())\n      return SDValue();\n    SDValue Logic = DAG.getNode(LogicOpcode, DL, XVT, X, Y);\n    return DAG.getNode(HandOpcode, DL, VT, Logic);\n  }\n\n  // Simplify xor/and/or (bitcast(A), bitcast(B)) -> bitcast(op (A,B))\n  // Only perform this optimization up until type legalization, before\n  // LegalizeVectorOprs. LegalizeVectorOprs promotes vector operations by\n  // adding bitcasts. For example (xor v4i32) is promoted to (v2i64), and\n  // we don't want to undo this promotion.\n  // We also handle SCALAR_TO_VECTOR because xor/or/and operations are cheaper\n  // on scalars.\n  if ((HandOpcode == ISD::BITCAST || HandOpcode == ISD::SCALAR_TO_VECTOR) &&\n       Level <= AfterLegalizeTypes) {\n    // Input types must be integer and the same.\n    if (XVT.isInteger() && XVT == Y.getValueType() &&\n        !(VT.isVector() && TLI.isTypeLegal(VT) &&\n          !XVT.isVector() && !TLI.isTypeLegal(XVT))) {\n      SDValue Logic = DAG.getNode(LogicOpcode, DL, XVT, X, Y);\n      return DAG.getNode(HandOpcode, DL, VT, Logic);\n    }\n  }\n\n  // Xor/and/or are indifferent to the swizzle operation (shuffle of one value).\n  // Simplify xor/and/or (shuff(A), shuff(B)) -> shuff(op (A,B))\n  // If both shuffles use the same mask, and both shuffle within a single\n  // vector, then it is worthwhile to move the swizzle after the operation.\n  // The type-legalizer generates this pattern when loading illegal\n  // vector types from memory. In many cases this allows additional shuffle\n  // optimizations.\n  // There are other cases where moving the shuffle after the xor/and/or\n  // is profitable even if shuffles don't perform a swizzle.\n  // If both shuffles use the same mask, and both shuffles have the same first\n  // or second operand, then it might still be profitable to move the shuffle\n  // after the xor/and/or operation.\n  if (HandOpcode == ISD::VECTOR_SHUFFLE && Level < AfterLegalizeDAG) {\n    auto *SVN0 = cast<ShuffleVectorSDNode>(N0);\n    auto *SVN1 = cast<ShuffleVectorSDNode>(N1);\n    assert(X.getValueType() == Y.getValueType() &&\n           \"Inputs to shuffles are not the same type\");\n\n    // Check that both shuffles use the same mask. The masks are known to be of\n    // the same length because the result vector type is the same.\n    // Check also that shuffles have only one use to avoid introducing extra\n    // instructions.\n    if (!SVN0->hasOneUse() || !SVN1->hasOneUse() ||\n        !SVN0->getMask().equals(SVN1->getMask()))\n      return SDValue();\n\n    // Don't try to fold this node if it requires introducing a\n    // build vector of all zeros that might be illegal at this stage.\n    SDValue ShOp = N0.getOperand(1);\n    if (LogicOpcode == ISD::XOR && !ShOp.isUndef())\n      ShOp = tryFoldToZero(DL, TLI, VT, DAG, LegalOperations);\n\n    // (logic_op (shuf (A, C), shuf (B, C))) --> shuf (logic_op (A, B), C)\n    if (N0.getOperand(1) == N1.getOperand(1) && ShOp.getNode()) {\n      SDValue Logic = DAG.getNode(LogicOpcode, DL, VT,\n                                  N0.getOperand(0), N1.getOperand(0));\n      return DAG.getVectorShuffle(VT, DL, Logic, ShOp, SVN0->getMask());\n    }\n\n    // Don't try to fold this node if it requires introducing a\n    // build vector of all zeros that might be illegal at this stage.\n    ShOp = N0.getOperand(0);\n    if (LogicOpcode == ISD::XOR && !ShOp.isUndef())\n      ShOp = tryFoldToZero(DL, TLI, VT, DAG, LegalOperations);\n\n    // (logic_op (shuf (C, A), shuf (C, B))) --> shuf (C, logic_op (A, B))\n    if (N0.getOperand(0) == N1.getOperand(0) && ShOp.getNode()) {\n      SDValue Logic = DAG.getNode(LogicOpcode, DL, VT, N0.getOperand(1),\n                                  N1.getOperand(1));\n      return DAG.getVectorShuffle(VT, DL, ShOp, Logic, SVN0->getMask());\n    }\n  }\n\n  return SDValue();\n}\n\n/// Try to make (and/or setcc (LL, LR), setcc (RL, RR)) more efficient.\nSDValue DAGCombiner::foldLogicOfSetCCs(bool IsAnd, SDValue N0, SDValue N1,\n                                       const SDLoc &DL) {\n  SDValue LL, LR, RL, RR, N0CC, N1CC;\n  if (!isSetCCEquivalent(N0, LL, LR, N0CC) ||\n      !isSetCCEquivalent(N1, RL, RR, N1CC))\n    return SDValue();\n\n  assert(N0.getValueType() == N1.getValueType() &&\n         \"Unexpected operand types for bitwise logic op\");\n  assert(LL.getValueType() == LR.getValueType() &&\n         RL.getValueType() == RR.getValueType() &&\n         \"Unexpected operand types for setcc\");\n\n  // If we're here post-legalization or the logic op type is not i1, the logic\n  // op type must match a setcc result type. Also, all folds require new\n  // operations on the left and right operands, so those types must match.\n  EVT VT = N0.getValueType();\n  EVT OpVT = LL.getValueType();\n  if (LegalOperations || VT.getScalarType() != MVT::i1)\n    if (VT != getSetCCResultType(OpVT))\n      return SDValue();\n  if (OpVT != RL.getValueType())\n    return SDValue();\n\n  ISD::CondCode CC0 = cast<CondCodeSDNode>(N0CC)->get();\n  ISD::CondCode CC1 = cast<CondCodeSDNode>(N1CC)->get();\n  bool IsInteger = OpVT.isInteger();\n  if (LR == RR && CC0 == CC1 && IsInteger) {\n    bool IsZero = isNullOrNullSplat(LR);\n    bool IsNeg1 = isAllOnesOrAllOnesSplat(LR);\n\n    // All bits clear?\n    bool AndEqZero = IsAnd && CC1 == ISD::SETEQ && IsZero;\n    // All sign bits clear?\n    bool AndGtNeg1 = IsAnd && CC1 == ISD::SETGT && IsNeg1;\n    // Any bits set?\n    bool OrNeZero = !IsAnd && CC1 == ISD::SETNE && IsZero;\n    // Any sign bits set?\n    bool OrLtZero = !IsAnd && CC1 == ISD::SETLT && IsZero;\n\n    // (and (seteq X,  0), (seteq Y,  0)) --> (seteq (or X, Y),  0)\n    // (and (setgt X, -1), (setgt Y, -1)) --> (setgt (or X, Y), -1)\n    // (or  (setne X,  0), (setne Y,  0)) --> (setne (or X, Y),  0)\n    // (or  (setlt X,  0), (setlt Y,  0)) --> (setlt (or X, Y),  0)\n    if (AndEqZero || AndGtNeg1 || OrNeZero || OrLtZero) {\n      SDValue Or = DAG.getNode(ISD::OR, SDLoc(N0), OpVT, LL, RL);\n      AddToWorklist(Or.getNode());\n      return DAG.getSetCC(DL, VT, Or, LR, CC1);\n    }\n\n    // All bits set?\n    bool AndEqNeg1 = IsAnd && CC1 == ISD::SETEQ && IsNeg1;\n    // All sign bits set?\n    bool AndLtZero = IsAnd && CC1 == ISD::SETLT && IsZero;\n    // Any bits clear?\n    bool OrNeNeg1 = !IsAnd && CC1 == ISD::SETNE && IsNeg1;\n    // Any sign bits clear?\n    bool OrGtNeg1 = !IsAnd && CC1 == ISD::SETGT && IsNeg1;\n\n    // (and (seteq X, -1), (seteq Y, -1)) --> (seteq (and X, Y), -1)\n    // (and (setlt X,  0), (setlt Y,  0)) --> (setlt (and X, Y),  0)\n    // (or  (setne X, -1), (setne Y, -1)) --> (setne (and X, Y), -1)\n    // (or  (setgt X, -1), (setgt Y  -1)) --> (setgt (and X, Y), -1)\n    if (AndEqNeg1 || AndLtZero || OrNeNeg1 || OrGtNeg1) {\n      SDValue And = DAG.getNode(ISD::AND, SDLoc(N0), OpVT, LL, RL);\n      AddToWorklist(And.getNode());\n      return DAG.getSetCC(DL, VT, And, LR, CC1);\n    }\n  }\n\n  // TODO: What is the 'or' equivalent of this fold?\n  // (and (setne X, 0), (setne X, -1)) --> (setuge (add X, 1), 2)\n  if (IsAnd && LL == RL && CC0 == CC1 && OpVT.getScalarSizeInBits() > 1 &&\n      IsInteger && CC0 == ISD::SETNE &&\n      ((isNullConstant(LR) && isAllOnesConstant(RR)) ||\n       (isAllOnesConstant(LR) && isNullConstant(RR)))) {\n    SDValue One = DAG.getConstant(1, DL, OpVT);\n    SDValue Two = DAG.getConstant(2, DL, OpVT);\n    SDValue Add = DAG.getNode(ISD::ADD, SDLoc(N0), OpVT, LL, One);\n    AddToWorklist(Add.getNode());\n    return DAG.getSetCC(DL, VT, Add, Two, ISD::SETUGE);\n  }\n\n  // Try more general transforms if the predicates match and the only user of\n  // the compares is the 'and' or 'or'.\n  if (IsInteger && TLI.convertSetCCLogicToBitwiseLogic(OpVT) && CC0 == CC1 &&\n      N0.hasOneUse() && N1.hasOneUse()) {\n    // and (seteq A, B), (seteq C, D) --> seteq (or (xor A, B), (xor C, D)), 0\n    // or  (setne A, B), (setne C, D) --> setne (or (xor A, B), (xor C, D)), 0\n    if ((IsAnd && CC1 == ISD::SETEQ) || (!IsAnd && CC1 == ISD::SETNE)) {\n      SDValue XorL = DAG.getNode(ISD::XOR, SDLoc(N0), OpVT, LL, LR);\n      SDValue XorR = DAG.getNode(ISD::XOR, SDLoc(N1), OpVT, RL, RR);\n      SDValue Or = DAG.getNode(ISD::OR, DL, OpVT, XorL, XorR);\n      SDValue Zero = DAG.getConstant(0, DL, OpVT);\n      return DAG.getSetCC(DL, VT, Or, Zero, CC1);\n    }\n\n    // Turn compare of constants whose difference is 1 bit into add+and+setcc.\n    // TODO - support non-uniform vector amounts.\n    if ((IsAnd && CC1 == ISD::SETNE) || (!IsAnd && CC1 == ISD::SETEQ)) {\n      // Match a shared variable operand and 2 non-opaque constant operands.\n      ConstantSDNode *C0 = isConstOrConstSplat(LR);\n      ConstantSDNode *C1 = isConstOrConstSplat(RR);\n      if (LL == RL && C0 && C1 && !C0->isOpaque() && !C1->isOpaque()) {\n        const APInt &CMax =\n            APIntOps::umax(C0->getAPIntValue(), C1->getAPIntValue());\n        const APInt &CMin =\n            APIntOps::umin(C0->getAPIntValue(), C1->getAPIntValue());\n        // The difference of the constants must be a single bit.\n        if ((CMax - CMin).isPowerOf2()) {\n          // and/or (setcc X, CMax, ne), (setcc X, CMin, ne/eq) -->\n          // setcc ((sub X, CMin), ~(CMax - CMin)), 0, ne/eq\n          SDValue Max = DAG.getNode(ISD::UMAX, DL, OpVT, LR, RR);\n          SDValue Min = DAG.getNode(ISD::UMIN, DL, OpVT, LR, RR);\n          SDValue Offset = DAG.getNode(ISD::SUB, DL, OpVT, LL, Min);\n          SDValue Diff = DAG.getNode(ISD::SUB, DL, OpVT, Max, Min);\n          SDValue Mask = DAG.getNOT(DL, Diff, OpVT);\n          SDValue And = DAG.getNode(ISD::AND, DL, OpVT, Offset, Mask);\n          SDValue Zero = DAG.getConstant(0, DL, OpVT);\n          return DAG.getSetCC(DL, VT, And, Zero, CC0);\n        }\n      }\n    }\n  }\n\n  // Canonicalize equivalent operands to LL == RL.\n  if (LL == RR && LR == RL) {\n    CC1 = ISD::getSetCCSwappedOperands(CC1);\n    std::swap(RL, RR);\n  }\n\n  // (and (setcc X, Y, CC0), (setcc X, Y, CC1)) --> (setcc X, Y, NewCC)\n  // (or  (setcc X, Y, CC0), (setcc X, Y, CC1)) --> (setcc X, Y, NewCC)\n  if (LL == RL && LR == RR) {\n    ISD::CondCode NewCC = IsAnd ? ISD::getSetCCAndOperation(CC0, CC1, OpVT)\n                                : ISD::getSetCCOrOperation(CC0, CC1, OpVT);\n    if (NewCC != ISD::SETCC_INVALID &&\n        (!LegalOperations ||\n         (TLI.isCondCodeLegal(NewCC, LL.getSimpleValueType()) &&\n          TLI.isOperationLegal(ISD::SETCC, OpVT))))\n      return DAG.getSetCC(DL, VT, LL, LR, NewCC);\n  }\n\n  return SDValue();\n}\n\n/// This contains all DAGCombine rules which reduce two values combined by\n/// an And operation to a single value. This makes them reusable in the context\n/// of visitSELECT(). Rules involving constants are not included as\n/// visitSELECT() already handles those cases.\nSDValue DAGCombiner::visitANDLike(SDValue N0, SDValue N1, SDNode *N) {\n  EVT VT = N1.getValueType();\n  SDLoc DL(N);\n\n  // fold (and x, undef) -> 0\n  if (N0.isUndef() || N1.isUndef())\n    return DAG.getConstant(0, DL, VT);\n\n  if (SDValue V = foldLogicOfSetCCs(true, N0, N1, DL))\n    return V;\n\n  if (N0.getOpcode() == ISD::ADD && N1.getOpcode() == ISD::SRL &&\n      VT.getSizeInBits() <= 64) {\n    if (ConstantSDNode *ADDI = dyn_cast<ConstantSDNode>(N0.getOperand(1))) {\n      if (ConstantSDNode *SRLI = dyn_cast<ConstantSDNode>(N1.getOperand(1))) {\n        // Look for (and (add x, c1), (lshr y, c2)). If C1 wasn't a legal\n        // immediate for an add, but it is legal if its top c2 bits are set,\n        // transform the ADD so the immediate doesn't need to be materialized\n        // in a register.\n        APInt ADDC = ADDI->getAPIntValue();\n        APInt SRLC = SRLI->getAPIntValue();\n        if (ADDC.getMinSignedBits() <= 64 &&\n            SRLC.ult(VT.getSizeInBits()) &&\n            !TLI.isLegalAddImmediate(ADDC.getSExtValue())) {\n          APInt Mask = APInt::getHighBitsSet(VT.getSizeInBits(),\n                                             SRLC.getZExtValue());\n          if (DAG.MaskedValueIsZero(N0.getOperand(1), Mask)) {\n            ADDC |= Mask;\n            if (TLI.isLegalAddImmediate(ADDC.getSExtValue())) {\n              SDLoc DL0(N0);\n              SDValue NewAdd =\n                DAG.getNode(ISD::ADD, DL0, VT,\n                            N0.getOperand(0), DAG.getConstant(ADDC, DL, VT));\n              CombineTo(N0.getNode(), NewAdd);\n              // Return N so it doesn't get rechecked!\n              return SDValue(N, 0);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Reduce bit extract of low half of an integer to the narrower type.\n  // (and (srl i64:x, K), KMask) ->\n  //   (i64 zero_extend (and (srl (i32 (trunc i64:x)), K)), KMask)\n  if (N0.getOpcode() == ISD::SRL && N0.hasOneUse()) {\n    if (ConstantSDNode *CAnd = dyn_cast<ConstantSDNode>(N1)) {\n      if (ConstantSDNode *CShift = dyn_cast<ConstantSDNode>(N0.getOperand(1))) {\n        unsigned Size = VT.getSizeInBits();\n        const APInt &AndMask = CAnd->getAPIntValue();\n        unsigned ShiftBits = CShift->getZExtValue();\n\n        // Bail out, this node will probably disappear anyway.\n        if (ShiftBits == 0)\n          return SDValue();\n\n        unsigned MaskBits = AndMask.countTrailingOnes();\n        EVT HalfVT = EVT::getIntegerVT(*DAG.getContext(), Size / 2);\n\n        if (AndMask.isMask() &&\n            // Required bits must not span the two halves of the integer and\n            // must fit in the half size type.\n            (ShiftBits + MaskBits <= Size / 2) &&\n            TLI.isNarrowingProfitable(VT, HalfVT) &&\n            TLI.isTypeDesirableForOp(ISD::AND, HalfVT) &&\n            TLI.isTypeDesirableForOp(ISD::SRL, HalfVT) &&\n            TLI.isTruncateFree(VT, HalfVT) &&\n            TLI.isZExtFree(HalfVT, VT)) {\n          // The isNarrowingProfitable is to avoid regressions on PPC and\n          // AArch64 which match a few 64-bit bit insert / bit extract patterns\n          // on downstream users of this. Those patterns could probably be\n          // extended to handle extensions mixed in.\n\n          SDValue SL(N0);\n          assert(MaskBits <= Size);\n\n          // Extracting the highest bit of the low half.\n          EVT ShiftVT = TLI.getShiftAmountTy(HalfVT, DAG.getDataLayout());\n          SDValue Trunc = DAG.getNode(ISD::TRUNCATE, SL, HalfVT,\n                                      N0.getOperand(0));\n\n          SDValue NewMask = DAG.getConstant(AndMask.trunc(Size / 2), SL, HalfVT);\n          SDValue ShiftK = DAG.getConstant(ShiftBits, SL, ShiftVT);\n          SDValue Shift = DAG.getNode(ISD::SRL, SL, HalfVT, Trunc, ShiftK);\n          SDValue And = DAG.getNode(ISD::AND, SL, HalfVT, Shift, NewMask);\n          return DAG.getNode(ISD::ZERO_EXTEND, SL, VT, And);\n        }\n      }\n    }\n  }\n\n  return SDValue();\n}\n\nbool DAGCombiner::isAndLoadExtLoad(ConstantSDNode *AndC, LoadSDNode *LoadN,\n                                   EVT LoadResultTy, EVT &ExtVT) {\n  if (!AndC->getAPIntValue().isMask())\n    return false;\n\n  unsigned ActiveBits = AndC->getAPIntValue().countTrailingOnes();\n\n  ExtVT = EVT::getIntegerVT(*DAG.getContext(), ActiveBits);\n  EVT LoadedVT = LoadN->getMemoryVT();\n\n  if (ExtVT == LoadedVT &&\n      (!LegalOperations ||\n       TLI.isLoadExtLegal(ISD::ZEXTLOAD, LoadResultTy, ExtVT))) {\n    // ZEXTLOAD will match without needing to change the size of the value being\n    // loaded.\n    return true;\n  }\n\n  // Do not change the width of a volatile or atomic loads.\n  if (!LoadN->isSimple())\n    return false;\n\n  // Do not generate loads of non-round integer types since these can\n  // be expensive (and would be wrong if the type is not byte sized).\n  if (!LoadedVT.bitsGT(ExtVT) || !ExtVT.isRound())\n    return false;\n\n  if (LegalOperations &&\n      !TLI.isLoadExtLegal(ISD::ZEXTLOAD, LoadResultTy, ExtVT))\n    return false;\n\n  if (!TLI.shouldReduceLoadWidth(LoadN, ISD::ZEXTLOAD, ExtVT))\n    return false;\n\n  return true;\n}\n\nbool DAGCombiner::isLegalNarrowLdSt(LSBaseSDNode *LDST,\n                                    ISD::LoadExtType ExtType, EVT &MemVT,\n                                    unsigned ShAmt) {\n  if (!LDST)\n    return false;\n  // Only allow byte offsets.\n  if (ShAmt % 8)\n    return false;\n\n  // Do not generate loads of non-round integer types since these can\n  // be expensive (and would be wrong if the type is not byte sized).\n  if (!MemVT.isRound())\n    return false;\n\n  // Don't change the width of a volatile or atomic loads.\n  if (!LDST->isSimple())\n    return false;\n\n  EVT LdStMemVT = LDST->getMemoryVT();\n\n  // Bail out when changing the scalable property, since we can't be sure that\n  // we're actually narrowing here.\n  if (LdStMemVT.isScalableVector() != MemVT.isScalableVector())\n    return false;\n\n  // Verify that we are actually reducing a load width here.\n  if (LdStMemVT.bitsLT(MemVT))\n    return false;\n\n  // Ensure that this isn't going to produce an unsupported memory access.\n  if (ShAmt) {\n    assert(ShAmt % 8 == 0 && \"ShAmt is byte offset\");\n    const unsigned ByteShAmt = ShAmt / 8;\n    const Align LDSTAlign = LDST->getAlign();\n    const Align NarrowAlign = commonAlignment(LDSTAlign, ByteShAmt);\n    if (!TLI.allowsMemoryAccess(*DAG.getContext(), DAG.getDataLayout(), MemVT,\n                                LDST->getAddressSpace(), NarrowAlign,\n                                LDST->getMemOperand()->getFlags()))\n      return false;\n  }\n\n  // It's not possible to generate a constant of extended or untyped type.\n  EVT PtrType = LDST->getBasePtr().getValueType();\n  if (PtrType == MVT::Untyped || PtrType.isExtended())\n    return false;\n\n  if (isa<LoadSDNode>(LDST)) {\n    LoadSDNode *Load = cast<LoadSDNode>(LDST);\n    // Don't transform one with multiple uses, this would require adding a new\n    // load.\n    if (!SDValue(Load, 0).hasOneUse())\n      return false;\n\n    if (LegalOperations &&\n        !TLI.isLoadExtLegal(ExtType, Load->getValueType(0), MemVT))\n      return false;\n\n    // For the transform to be legal, the load must produce only two values\n    // (the value loaded and the chain).  Don't transform a pre-increment\n    // load, for example, which produces an extra value.  Otherwise the\n    // transformation is not equivalent, and the downstream logic to replace\n    // uses gets things wrong.\n    if (Load->getNumValues() > 2)\n      return false;\n\n    // If the load that we're shrinking is an extload and we're not just\n    // discarding the extension we can't simply shrink the load. Bail.\n    // TODO: It would be possible to merge the extensions in some cases.\n    if (Load->getExtensionType() != ISD::NON_EXTLOAD &&\n        Load->getMemoryVT().getSizeInBits() < MemVT.getSizeInBits() + ShAmt)\n      return false;\n\n    if (!TLI.shouldReduceLoadWidth(Load, ExtType, MemVT))\n      return false;\n  } else {\n    assert(isa<StoreSDNode>(LDST) && \"It is not a Load nor a Store SDNode\");\n    StoreSDNode *Store = cast<StoreSDNode>(LDST);\n    // Can't write outside the original store\n    if (Store->getMemoryVT().getSizeInBits() < MemVT.getSizeInBits() + ShAmt)\n      return false;\n\n    if (LegalOperations &&\n        !TLI.isTruncStoreLegal(Store->getValue().getValueType(), MemVT))\n      return false;\n  }\n  return true;\n}\n\nbool DAGCombiner::SearchForAndLoads(SDNode *N,\n                                    SmallVectorImpl<LoadSDNode*> &Loads,\n                                    SmallPtrSetImpl<SDNode*> &NodesWithConsts,\n                                    ConstantSDNode *Mask,\n                                    SDNode *&NodeToMask) {\n  // Recursively search for the operands, looking for loads which can be\n  // narrowed.\n  for (SDValue Op : N->op_values()) {\n    if (Op.getValueType().isVector())\n      return false;\n\n    // Some constants may need fixing up later if they are too large.\n    if (auto *C = dyn_cast<ConstantSDNode>(Op)) {\n      if ((N->getOpcode() == ISD::OR || N->getOpcode() == ISD::XOR) &&\n          (Mask->getAPIntValue() & C->getAPIntValue()) != C->getAPIntValue())\n        NodesWithConsts.insert(N);\n      continue;\n    }\n\n    if (!Op.hasOneUse())\n      return false;\n\n    switch(Op.getOpcode()) {\n    case ISD::LOAD: {\n      auto *Load = cast<LoadSDNode>(Op);\n      EVT ExtVT;\n      if (isAndLoadExtLoad(Mask, Load, Load->getValueType(0), ExtVT) &&\n          isLegalNarrowLdSt(Load, ISD::ZEXTLOAD, ExtVT)) {\n\n        // ZEXTLOAD is already small enough.\n        if (Load->getExtensionType() == ISD::ZEXTLOAD &&\n            ExtVT.bitsGE(Load->getMemoryVT()))\n          continue;\n\n        // Use LE to convert equal sized loads to zext.\n        if (ExtVT.bitsLE(Load->getMemoryVT()))\n          Loads.push_back(Load);\n\n        continue;\n      }\n      return false;\n    }\n    case ISD::ZERO_EXTEND:\n    case ISD::AssertZext: {\n      unsigned ActiveBits = Mask->getAPIntValue().countTrailingOnes();\n      EVT ExtVT = EVT::getIntegerVT(*DAG.getContext(), ActiveBits);\n      EVT VT = Op.getOpcode() == ISD::AssertZext ?\n        cast<VTSDNode>(Op.getOperand(1))->getVT() :\n        Op.getOperand(0).getValueType();\n\n      // We can accept extending nodes if the mask is wider or an equal\n      // width to the original type.\n      if (ExtVT.bitsGE(VT))\n        continue;\n      break;\n    }\n    case ISD::OR:\n    case ISD::XOR:\n    case ISD::AND:\n      if (!SearchForAndLoads(Op.getNode(), Loads, NodesWithConsts, Mask,\n                             NodeToMask))\n        return false;\n      continue;\n    }\n\n    // Allow one node which will masked along with any loads found.\n    if (NodeToMask)\n      return false;\n\n    // Also ensure that the node to be masked only produces one data result.\n    NodeToMask = Op.getNode();\n    if (NodeToMask->getNumValues() > 1) {\n      bool HasValue = false;\n      for (unsigned i = 0, e = NodeToMask->getNumValues(); i < e; ++i) {\n        MVT VT = SDValue(NodeToMask, i).getSimpleValueType();\n        if (VT != MVT::Glue && VT != MVT::Other) {\n          if (HasValue) {\n            NodeToMask = nullptr;\n            return false;\n          }\n          HasValue = true;\n        }\n      }\n      assert(HasValue && \"Node to be masked has no data result?\");\n    }\n  }\n  return true;\n}\n\nbool DAGCombiner::BackwardsPropagateMask(SDNode *N) {\n  auto *Mask = dyn_cast<ConstantSDNode>(N->getOperand(1));\n  if (!Mask)\n    return false;\n\n  if (!Mask->getAPIntValue().isMask())\n    return false;\n\n  // No need to do anything if the and directly uses a load.\n  if (isa<LoadSDNode>(N->getOperand(0)))\n    return false;\n\n  SmallVector<LoadSDNode*, 8> Loads;\n  SmallPtrSet<SDNode*, 2> NodesWithConsts;\n  SDNode *FixupNode = nullptr;\n  if (SearchForAndLoads(N, Loads, NodesWithConsts, Mask, FixupNode)) {\n    if (Loads.size() == 0)\n      return false;\n\n    LLVM_DEBUG(dbgs() << \"Backwards propagate AND: \"; N->dump());\n    SDValue MaskOp = N->getOperand(1);\n\n    // If it exists, fixup the single node we allow in the tree that needs\n    // masking.\n    if (FixupNode) {\n      LLVM_DEBUG(dbgs() << \"First, need to fix up: \"; FixupNode->dump());\n      SDValue And = DAG.getNode(ISD::AND, SDLoc(FixupNode),\n                                FixupNode->getValueType(0),\n                                SDValue(FixupNode, 0), MaskOp);\n      DAG.ReplaceAllUsesOfValueWith(SDValue(FixupNode, 0), And);\n      if (And.getOpcode() == ISD ::AND)\n        DAG.UpdateNodeOperands(And.getNode(), SDValue(FixupNode, 0), MaskOp);\n    }\n\n    // Narrow any constants that need it.\n    for (auto *LogicN : NodesWithConsts) {\n      SDValue Op0 = LogicN->getOperand(0);\n      SDValue Op1 = LogicN->getOperand(1);\n\n      if (isa<ConstantSDNode>(Op0))\n          std::swap(Op0, Op1);\n\n      SDValue And = DAG.getNode(ISD::AND, SDLoc(Op1), Op1.getValueType(),\n                                Op1, MaskOp);\n\n      DAG.UpdateNodeOperands(LogicN, Op0, And);\n    }\n\n    // Create narrow loads.\n    for (auto *Load : Loads) {\n      LLVM_DEBUG(dbgs() << \"Propagate AND back to: \"; Load->dump());\n      SDValue And = DAG.getNode(ISD::AND, SDLoc(Load), Load->getValueType(0),\n                                SDValue(Load, 0), MaskOp);\n      DAG.ReplaceAllUsesOfValueWith(SDValue(Load, 0), And);\n      if (And.getOpcode() == ISD ::AND)\n        And = SDValue(\n            DAG.UpdateNodeOperands(And.getNode(), SDValue(Load, 0), MaskOp), 0);\n      SDValue NewLoad = ReduceLoadWidth(And.getNode());\n      assert(NewLoad &&\n             \"Shouldn't be masking the load if it can't be narrowed\");\n      CombineTo(Load, NewLoad, NewLoad.getValue(1));\n    }\n    DAG.ReplaceAllUsesWith(N, N->getOperand(0).getNode());\n    return true;\n  }\n  return false;\n}\n\n// Unfold\n//    x &  (-1 'logical shift' y)\n// To\n//    (x 'opposite logical shift' y) 'logical shift' y\n// if it is better for performance.\nSDValue DAGCombiner::unfoldExtremeBitClearingToShifts(SDNode *N) {\n  assert(N->getOpcode() == ISD::AND);\n\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n\n  // Do we actually prefer shifts over mask?\n  if (!TLI.shouldFoldMaskToVariableShiftPair(N0))\n    return SDValue();\n\n  // Try to match  (-1 '[outer] logical shift' y)\n  unsigned OuterShift;\n  unsigned InnerShift; // The opposite direction to the OuterShift.\n  SDValue Y;           // Shift amount.\n  auto matchMask = [&OuterShift, &InnerShift, &Y](SDValue M) -> bool {\n    if (!M.hasOneUse())\n      return false;\n    OuterShift = M->getOpcode();\n    if (OuterShift == ISD::SHL)\n      InnerShift = ISD::SRL;\n    else if (OuterShift == ISD::SRL)\n      InnerShift = ISD::SHL;\n    else\n      return false;\n    if (!isAllOnesConstant(M->getOperand(0)))\n      return false;\n    Y = M->getOperand(1);\n    return true;\n  };\n\n  SDValue X;\n  if (matchMask(N1))\n    X = N0;\n  else if (matchMask(N0))\n    X = N1;\n  else\n    return SDValue();\n\n  SDLoc DL(N);\n  EVT VT = N->getValueType(0);\n\n  //     tmp = x   'opposite logical shift' y\n  SDValue T0 = DAG.getNode(InnerShift, DL, VT, X, Y);\n  //     ret = tmp 'logical shift' y\n  SDValue T1 = DAG.getNode(OuterShift, DL, VT, T0, Y);\n\n  return T1;\n}\n\n/// Try to replace shift/logic that tests if a bit is clear with mask + setcc.\n/// For a target with a bit test, this is expected to become test + set and save\n/// at least 1 instruction.\nstatic SDValue combineShiftAnd1ToBitTest(SDNode *And, SelectionDAG &DAG) {\n  assert(And->getOpcode() == ISD::AND && \"Expected an 'and' op\");\n\n  // This is probably not worthwhile without a supported type.\n  EVT VT = And->getValueType(0);\n  const TargetLowering &TLI = DAG.getTargetLoweringInfo();\n  if (!TLI.isTypeLegal(VT))\n    return SDValue();\n\n  // Look through an optional extension and find a 'not'.\n  // TODO: Should we favor test+set even without the 'not' op?\n  SDValue Not = And->getOperand(0), And1 = And->getOperand(1);\n  if (Not.getOpcode() == ISD::ANY_EXTEND)\n    Not = Not.getOperand(0);\n  if (!isBitwiseNot(Not) || !Not.hasOneUse() || !isOneConstant(And1))\n    return SDValue();\n\n  // Look though an optional truncation. The source operand may not be the same\n  // type as the original 'and', but that is ok because we are masking off\n  // everything but the low bit.\n  SDValue Srl = Not.getOperand(0);\n  if (Srl.getOpcode() == ISD::TRUNCATE)\n    Srl = Srl.getOperand(0);\n\n  // Match a shift-right by constant.\n  if (Srl.getOpcode() != ISD::SRL || !Srl.hasOneUse() ||\n      !isa<ConstantSDNode>(Srl.getOperand(1)))\n    return SDValue();\n\n  // We might have looked through casts that make this transform invalid.\n  // TODO: If the source type is wider than the result type, do the mask and\n  //       compare in the source type.\n  const APInt &ShiftAmt = Srl.getConstantOperandAPInt(1);\n  unsigned VTBitWidth = VT.getSizeInBits();\n  if (ShiftAmt.uge(VTBitWidth))\n    return SDValue();\n\n  // Turn this into a bit-test pattern using mask op + setcc:\n  // and (not (srl X, C)), 1 --> (and X, 1<<C) == 0\n  SDLoc DL(And);\n  SDValue X = DAG.getZExtOrTrunc(Srl.getOperand(0), DL, VT);\n  EVT CCVT = TLI.getSetCCResultType(DAG.getDataLayout(), *DAG.getContext(), VT);\n  SDValue Mask = DAG.getConstant(\n      APInt::getOneBitSet(VTBitWidth, ShiftAmt.getZExtValue()), DL, VT);\n  SDValue NewAnd = DAG.getNode(ISD::AND, DL, VT, X, Mask);\n  SDValue Zero = DAG.getConstant(0, DL, VT);\n  SDValue Setcc = DAG.getSetCC(DL, CCVT, NewAnd, Zero, ISD::SETEQ);\n  return DAG.getZExtOrTrunc(Setcc, DL, VT);\n}\n\nSDValue DAGCombiner::visitAND(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  EVT VT = N1.getValueType();\n\n  // x & x --> x\n  if (N0 == N1)\n    return N0;\n\n  // fold vector ops\n  if (VT.isVector()) {\n    if (SDValue FoldedVOp = SimplifyVBinOp(N))\n      return FoldedVOp;\n\n    // fold (and x, 0) -> 0, vector edition\n    if (ISD::isBuildVectorAllZeros(N0.getNode()))\n      // do not return N0, because undef node may exist in N0\n      return DAG.getConstant(APInt::getNullValue(N0.getScalarValueSizeInBits()),\n                             SDLoc(N), N0.getValueType());\n    if (ISD::isBuildVectorAllZeros(N1.getNode()))\n      // do not return N1, because undef node may exist in N1\n      return DAG.getConstant(APInt::getNullValue(N1.getScalarValueSizeInBits()),\n                             SDLoc(N), N1.getValueType());\n\n    // fold (and x, -1) -> x, vector edition\n    if (ISD::isBuildVectorAllOnes(N0.getNode()))\n      return N1;\n    if (ISD::isBuildVectorAllOnes(N1.getNode()))\n      return N0;\n\n    // fold (and (masked_load) (build_vec (x, ...))) to zext_masked_load\n    auto *MLoad = dyn_cast<MaskedLoadSDNode>(N0);\n    auto *BVec = dyn_cast<BuildVectorSDNode>(N1);\n    if (MLoad && BVec && MLoad->getExtensionType() == ISD::EXTLOAD &&\n        N0.hasOneUse() && N1.hasOneUse()) {\n      EVT LoadVT = MLoad->getMemoryVT();\n      EVT ExtVT = VT;\n      if (TLI.isLoadExtLegal(ISD::ZEXTLOAD, ExtVT, LoadVT)) {\n        // For this AND to be a zero extension of the masked load the elements\n        // of the BuildVec must mask the bottom bits of the extended element\n        // type\n        if (ConstantSDNode *Splat = BVec->getConstantSplatNode()) {\n          uint64_t ElementSize =\n              LoadVT.getVectorElementType().getScalarSizeInBits();\n          if (Splat->getAPIntValue().isMask(ElementSize)) {\n            return DAG.getMaskedLoad(\n                ExtVT, SDLoc(N), MLoad->getChain(), MLoad->getBasePtr(),\n                MLoad->getOffset(), MLoad->getMask(), MLoad->getPassThru(),\n                LoadVT, MLoad->getMemOperand(), MLoad->getAddressingMode(),\n                ISD::ZEXTLOAD, MLoad->isExpandingLoad());\n          }\n        }\n      }\n    }\n  }\n\n  // fold (and c1, c2) -> c1&c2\n  ConstantSDNode *N1C = isConstOrConstSplat(N1);\n  if (SDValue C = DAG.FoldConstantArithmetic(ISD::AND, SDLoc(N), VT, {N0, N1}))\n    return C;\n\n  // canonicalize constant to RHS\n  if (DAG.isConstantIntBuildVectorOrConstantInt(N0) &&\n      !DAG.isConstantIntBuildVectorOrConstantInt(N1))\n    return DAG.getNode(ISD::AND, SDLoc(N), VT, N1, N0);\n\n  // fold (and x, -1) -> x\n  if (isAllOnesConstant(N1))\n    return N0;\n\n  // if (and x, c) is known to be zero, return 0\n  unsigned BitWidth = VT.getScalarSizeInBits();\n  if (N1C && DAG.MaskedValueIsZero(SDValue(N, 0),\n                                   APInt::getAllOnesValue(BitWidth)))\n    return DAG.getConstant(0, SDLoc(N), VT);\n\n  if (SDValue NewSel = foldBinOpIntoSelect(N))\n    return NewSel;\n\n  // reassociate and\n  if (SDValue RAND = reassociateOps(ISD::AND, SDLoc(N), N0, N1, N->getFlags()))\n    return RAND;\n\n  // Try to convert a constant mask AND into a shuffle clear mask.\n  if (VT.isVector())\n    if (SDValue Shuffle = XformToShuffleWithZero(N))\n      return Shuffle;\n\n  if (SDValue Combined = combineCarryDiamond(*this, DAG, TLI, N0, N1, N))\n    return Combined;\n\n  // fold (and (or x, C), D) -> D if (C & D) == D\n  auto MatchSubset = [](ConstantSDNode *LHS, ConstantSDNode *RHS) {\n    return RHS->getAPIntValue().isSubsetOf(LHS->getAPIntValue());\n  };\n  if (N0.getOpcode() == ISD::OR &&\n      ISD::matchBinaryPredicate(N0.getOperand(1), N1, MatchSubset))\n    return N1;\n  // fold (and (any_ext V), c) -> (zero_ext V) if 'and' only clears top bits.\n  if (N1C && N0.getOpcode() == ISD::ANY_EXTEND) {\n    SDValue N0Op0 = N0.getOperand(0);\n    APInt Mask = ~N1C->getAPIntValue();\n    Mask = Mask.trunc(N0Op0.getScalarValueSizeInBits());\n    if (DAG.MaskedValueIsZero(N0Op0, Mask)) {\n      SDValue Zext = DAG.getNode(ISD::ZERO_EXTEND, SDLoc(N),\n                                 N0.getValueType(), N0Op0);\n\n      // Replace uses of the AND with uses of the Zero extend node.\n      CombineTo(N, Zext);\n\n      // We actually want to replace all uses of the any_extend with the\n      // zero_extend, to avoid duplicating things.  This will later cause this\n      // AND to be folded.\n      CombineTo(N0.getNode(), Zext);\n      return SDValue(N, 0);   // Return N so it doesn't get rechecked!\n    }\n  }\n\n  // similarly fold (and (X (load ([non_ext|any_ext|zero_ext] V))), c) ->\n  // (X (load ([non_ext|zero_ext] V))) if 'and' only clears top bits which must\n  // already be zero by virtue of the width of the base type of the load.\n  //\n  // the 'X' node here can either be nothing or an extract_vector_elt to catch\n  // more cases.\n  if ((N0.getOpcode() == ISD::EXTRACT_VECTOR_ELT &&\n       N0.getValueSizeInBits() == N0.getOperand(0).getScalarValueSizeInBits() &&\n       N0.getOperand(0).getOpcode() == ISD::LOAD &&\n       N0.getOperand(0).getResNo() == 0) ||\n      (N0.getOpcode() == ISD::LOAD && N0.getResNo() == 0)) {\n    LoadSDNode *Load = cast<LoadSDNode>( (N0.getOpcode() == ISD::LOAD) ?\n                                         N0 : N0.getOperand(0) );\n\n    // Get the constant (if applicable) the zero'th operand is being ANDed with.\n    // This can be a pure constant or a vector splat, in which case we treat the\n    // vector as a scalar and use the splat value.\n    APInt Constant = APInt::getNullValue(1);\n    if (const ConstantSDNode *C = dyn_cast<ConstantSDNode>(N1)) {\n      Constant = C->getAPIntValue();\n    } else if (BuildVectorSDNode *Vector = dyn_cast<BuildVectorSDNode>(N1)) {\n      APInt SplatValue, SplatUndef;\n      unsigned SplatBitSize;\n      bool HasAnyUndefs;\n      bool IsSplat = Vector->isConstantSplat(SplatValue, SplatUndef,\n                                             SplatBitSize, HasAnyUndefs);\n      if (IsSplat) {\n        // Undef bits can contribute to a possible optimisation if set, so\n        // set them.\n        SplatValue |= SplatUndef;\n\n        // The splat value may be something like \"0x00FFFFFF\", which means 0 for\n        // the first vector value and FF for the rest, repeating. We need a mask\n        // that will apply equally to all members of the vector, so AND all the\n        // lanes of the constant together.\n        unsigned EltBitWidth = Vector->getValueType(0).getScalarSizeInBits();\n\n        // If the splat value has been compressed to a bitlength lower\n        // than the size of the vector lane, we need to re-expand it to\n        // the lane size.\n        if (EltBitWidth > SplatBitSize)\n          for (SplatValue = SplatValue.zextOrTrunc(EltBitWidth);\n               SplatBitSize < EltBitWidth; SplatBitSize = SplatBitSize * 2)\n            SplatValue |= SplatValue.shl(SplatBitSize);\n\n        // Make sure that variable 'Constant' is only set if 'SplatBitSize' is a\n        // multiple of 'BitWidth'. Otherwise, we could propagate a wrong value.\n        if ((SplatBitSize % EltBitWidth) == 0) {\n          Constant = APInt::getAllOnesValue(EltBitWidth);\n          for (unsigned i = 0, n = (SplatBitSize / EltBitWidth); i < n; ++i)\n            Constant &= SplatValue.extractBits(EltBitWidth, i * EltBitWidth);\n        }\n      }\n    }\n\n    // If we want to change an EXTLOAD to a ZEXTLOAD, ensure a ZEXTLOAD is\n    // actually legal and isn't going to get expanded, else this is a false\n    // optimisation.\n    bool CanZextLoadProfitably = TLI.isLoadExtLegal(ISD::ZEXTLOAD,\n                                                    Load->getValueType(0),\n                                                    Load->getMemoryVT());\n\n    // Resize the constant to the same size as the original memory access before\n    // extension. If it is still the AllOnesValue then this AND is completely\n    // unneeded.\n    Constant = Constant.zextOrTrunc(Load->getMemoryVT().getScalarSizeInBits());\n\n    bool B;\n    switch (Load->getExtensionType()) {\n    default: B = false; break;\n    case ISD::EXTLOAD: B = CanZextLoadProfitably; break;\n    case ISD::ZEXTLOAD:\n    case ISD::NON_EXTLOAD: B = true; break;\n    }\n\n    if (B && Constant.isAllOnesValue()) {\n      // If the load type was an EXTLOAD, convert to ZEXTLOAD in order to\n      // preserve semantics once we get rid of the AND.\n      SDValue NewLoad(Load, 0);\n\n      // Fold the AND away. NewLoad may get replaced immediately.\n      CombineTo(N, (N0.getNode() == Load) ? NewLoad : N0);\n\n      if (Load->getExtensionType() == ISD::EXTLOAD) {\n        NewLoad = DAG.getLoad(Load->getAddressingMode(), ISD::ZEXTLOAD,\n                              Load->getValueType(0), SDLoc(Load),\n                              Load->getChain(), Load->getBasePtr(),\n                              Load->getOffset(), Load->getMemoryVT(),\n                              Load->getMemOperand());\n        // Replace uses of the EXTLOAD with the new ZEXTLOAD.\n        if (Load->getNumValues() == 3) {\n          // PRE/POST_INC loads have 3 values.\n          SDValue To[] = { NewLoad.getValue(0), NewLoad.getValue(1),\n                           NewLoad.getValue(2) };\n          CombineTo(Load, To, 3, true);\n        } else {\n          CombineTo(Load, NewLoad.getValue(0), NewLoad.getValue(1));\n        }\n      }\n\n      return SDValue(N, 0); // Return N so it doesn't get rechecked!\n    }\n  }\n\n  // fold (and (masked_gather x)) -> (zext_masked_gather x)\n  if (auto *GN0 = dyn_cast<MaskedGatherSDNode>(N0)) {\n    EVT MemVT = GN0->getMemoryVT();\n    EVT ScalarVT = MemVT.getScalarType();\n\n    if (SDValue(GN0, 0).hasOneUse() &&\n        isConstantSplatVectorMaskForType(N1.getNode(), ScalarVT) &&\n        TLI.isVectorLoadExtDesirable(SDValue(SDValue(GN0, 0)))) {\n      SDValue Ops[] = {GN0->getChain(),   GN0->getPassThru(), GN0->getMask(),\n                       GN0->getBasePtr(), GN0->getIndex(),    GN0->getScale()};\n\n      SDValue ZExtLoad = DAG.getMaskedGather(\n          DAG.getVTList(VT, MVT::Other), MemVT, SDLoc(N), Ops,\n          GN0->getMemOperand(), GN0->getIndexType(), ISD::ZEXTLOAD);\n\n      CombineTo(N, ZExtLoad);\n      AddToWorklist(ZExtLoad.getNode());\n      // Avoid recheck of N.\n      return SDValue(N, 0);\n    }\n  }\n\n  // fold (and (load x), 255) -> (zextload x, i8)\n  // fold (and (extload x, i16), 255) -> (zextload x, i8)\n  // fold (and (any_ext (extload x, i16)), 255) -> (zextload x, i8)\n  if (!VT.isVector() && N1C && (N0.getOpcode() == ISD::LOAD ||\n                                (N0.getOpcode() == ISD::ANY_EXTEND &&\n                                 N0.getOperand(0).getOpcode() == ISD::LOAD))) {\n    if (SDValue Res = ReduceLoadWidth(N)) {\n      LoadSDNode *LN0 = N0->getOpcode() == ISD::ANY_EXTEND\n        ? cast<LoadSDNode>(N0.getOperand(0)) : cast<LoadSDNode>(N0);\n      AddToWorklist(N);\n      DAG.ReplaceAllUsesOfValueWith(SDValue(LN0, 0), Res);\n      return SDValue(N, 0);\n    }\n  }\n\n  if (LegalTypes) {\n    // Attempt to propagate the AND back up to the leaves which, if they're\n    // loads, can be combined to narrow loads and the AND node can be removed.\n    // Perform after legalization so that extend nodes will already be\n    // combined into the loads.\n    if (BackwardsPropagateMask(N))\n      return SDValue(N, 0);\n  }\n\n  if (SDValue Combined = visitANDLike(N0, N1, N))\n    return Combined;\n\n  // Simplify: (and (op x...), (op y...))  -> (op (and x, y))\n  if (N0.getOpcode() == N1.getOpcode())\n    if (SDValue V = hoistLogicOpWithSameOpcodeHands(N))\n      return V;\n\n  // Masking the negated extension of a boolean is just the zero-extended\n  // boolean:\n  // and (sub 0, zext(bool X)), 1 --> zext(bool X)\n  // and (sub 0, sext(bool X)), 1 --> zext(bool X)\n  //\n  // Note: the SimplifyDemandedBits fold below can make an information-losing\n  // transform, and then we have no way to find this better fold.\n  if (N1C && N1C->isOne() && N0.getOpcode() == ISD::SUB) {\n    if (isNullOrNullSplat(N0.getOperand(0))) {\n      SDValue SubRHS = N0.getOperand(1);\n      if (SubRHS.getOpcode() == ISD::ZERO_EXTEND &&\n          SubRHS.getOperand(0).getScalarValueSizeInBits() == 1)\n        return SubRHS;\n      if (SubRHS.getOpcode() == ISD::SIGN_EXTEND &&\n          SubRHS.getOperand(0).getScalarValueSizeInBits() == 1)\n        return DAG.getNode(ISD::ZERO_EXTEND, SDLoc(N), VT, SubRHS.getOperand(0));\n    }\n  }\n\n  // fold (and (sign_extend_inreg x, i16 to i32), 1) -> (and x, 1)\n  // fold (and (sra)) -> (and (srl)) when possible.\n  if (SimplifyDemandedBits(SDValue(N, 0)))\n    return SDValue(N, 0);\n\n  // fold (zext_inreg (extload x)) -> (zextload x)\n  // fold (zext_inreg (sextload x)) -> (zextload x) iff load has one use\n  if (ISD::isUNINDEXEDLoad(N0.getNode()) &&\n      (ISD::isEXTLoad(N0.getNode()) ||\n       (ISD::isSEXTLoad(N0.getNode()) && N0.hasOneUse()))) {\n    LoadSDNode *LN0 = cast<LoadSDNode>(N0);\n    EVT MemVT = LN0->getMemoryVT();\n    // If we zero all the possible extended bits, then we can turn this into\n    // a zextload if we are running before legalize or the operation is legal.\n    unsigned ExtBitSize = N1.getScalarValueSizeInBits();\n    unsigned MemBitSize = MemVT.getScalarSizeInBits();\n    APInt ExtBits = APInt::getHighBitsSet(ExtBitSize, ExtBitSize - MemBitSize);\n    if (DAG.MaskedValueIsZero(N1, ExtBits) &&\n        ((!LegalOperations && LN0->isSimple()) ||\n         TLI.isLoadExtLegal(ISD::ZEXTLOAD, VT, MemVT))) {\n      SDValue ExtLoad =\n          DAG.getExtLoad(ISD::ZEXTLOAD, SDLoc(N0), VT, LN0->getChain(),\n                         LN0->getBasePtr(), MemVT, LN0->getMemOperand());\n      AddToWorklist(N);\n      CombineTo(N0.getNode(), ExtLoad, ExtLoad.getValue(1));\n      return SDValue(N, 0); // Return N so it doesn't get rechecked!\n    }\n  }\n\n  // fold (and (or (srl N, 8), (shl N, 8)), 0xffff) -> (srl (bswap N), const)\n  if (N1C && N1C->getAPIntValue() == 0xffff && N0.getOpcode() == ISD::OR) {\n    if (SDValue BSwap = MatchBSwapHWordLow(N0.getNode(), N0.getOperand(0),\n                                           N0.getOperand(1), false))\n      return BSwap;\n  }\n\n  if (SDValue Shifts = unfoldExtremeBitClearingToShifts(N))\n    return Shifts;\n\n  if (TLI.hasBitTest(N0, N1))\n    if (SDValue V = combineShiftAnd1ToBitTest(N, DAG))\n      return V;\n\n  // Recognize the following pattern:\n  //\n  // AndVT = (and (sign_extend NarrowVT to AndVT) #bitmask)\n  //\n  // where bitmask is a mask that clears the upper bits of AndVT. The\n  // number of bits in bitmask must be a power of two.\n  auto IsAndZeroExtMask = [](SDValue LHS, SDValue RHS) {\n    if (LHS->getOpcode() != ISD::SIGN_EXTEND)\n      return false;\n\n    auto *C = dyn_cast<ConstantSDNode>(RHS);\n    if (!C)\n      return false;\n\n    if (!C->getAPIntValue().isMask(\n            LHS.getOperand(0).getValueType().getFixedSizeInBits()))\n      return false;\n\n    return true;\n  };\n\n  // Replace (and (sign_extend ...) #bitmask) with (zero_extend ...).\n  if (IsAndZeroExtMask(N0, N1))\n    return DAG.getNode(ISD::ZERO_EXTEND, SDLoc(N), VT, N0.getOperand(0));\n\n  return SDValue();\n}\n\n/// Match (a >> 8) | (a << 8) as (bswap a) >> 16.\nSDValue DAGCombiner::MatchBSwapHWordLow(SDNode *N, SDValue N0, SDValue N1,\n                                        bool DemandHighBits) {\n  if (!LegalOperations)\n    return SDValue();\n\n  EVT VT = N->getValueType(0);\n  if (VT != MVT::i64 && VT != MVT::i32 && VT != MVT::i16)\n    return SDValue();\n  if (!TLI.isOperationLegalOrCustom(ISD::BSWAP, VT))\n    return SDValue();\n\n  // Recognize (and (shl a, 8), 0xff00), (and (srl a, 8), 0xff)\n  bool LookPassAnd0 = false;\n  bool LookPassAnd1 = false;\n  if (N0.getOpcode() == ISD::AND && N0.getOperand(0).getOpcode() == ISD::SRL)\n      std::swap(N0, N1);\n  if (N1.getOpcode() == ISD::AND && N1.getOperand(0).getOpcode() == ISD::SHL)\n      std::swap(N0, N1);\n  if (N0.getOpcode() == ISD::AND) {\n    if (!N0.getNode()->hasOneUse())\n      return SDValue();\n    ConstantSDNode *N01C = dyn_cast<ConstantSDNode>(N0.getOperand(1));\n    // Also handle 0xffff since the LHS is guaranteed to have zeros there.\n    // This is needed for X86.\n    if (!N01C || (N01C->getZExtValue() != 0xFF00 &&\n                  N01C->getZExtValue() != 0xFFFF))\n      return SDValue();\n    N0 = N0.getOperand(0);\n    LookPassAnd0 = true;\n  }\n\n  if (N1.getOpcode() == ISD::AND) {\n    if (!N1.getNode()->hasOneUse())\n      return SDValue();\n    ConstantSDNode *N11C = dyn_cast<ConstantSDNode>(N1.getOperand(1));\n    if (!N11C || N11C->getZExtValue() != 0xFF)\n      return SDValue();\n    N1 = N1.getOperand(0);\n    LookPassAnd1 = true;\n  }\n\n  if (N0.getOpcode() == ISD::SRL && N1.getOpcode() == ISD::SHL)\n    std::swap(N0, N1);\n  if (N0.getOpcode() != ISD::SHL || N1.getOpcode() != ISD::SRL)\n    return SDValue();\n  if (!N0.getNode()->hasOneUse() || !N1.getNode()->hasOneUse())\n    return SDValue();\n\n  ConstantSDNode *N01C = dyn_cast<ConstantSDNode>(N0.getOperand(1));\n  ConstantSDNode *N11C = dyn_cast<ConstantSDNode>(N1.getOperand(1));\n  if (!N01C || !N11C)\n    return SDValue();\n  if (N01C->getZExtValue() != 8 || N11C->getZExtValue() != 8)\n    return SDValue();\n\n  // Look for (shl (and a, 0xff), 8), (srl (and a, 0xff00), 8)\n  SDValue N00 = N0->getOperand(0);\n  if (!LookPassAnd0 && N00.getOpcode() == ISD::AND) {\n    if (!N00.getNode()->hasOneUse())\n      return SDValue();\n    ConstantSDNode *N001C = dyn_cast<ConstantSDNode>(N00.getOperand(1));\n    if (!N001C || N001C->getZExtValue() != 0xFF)\n      return SDValue();\n    N00 = N00.getOperand(0);\n    LookPassAnd0 = true;\n  }\n\n  SDValue N10 = N1->getOperand(0);\n  if (!LookPassAnd1 && N10.getOpcode() == ISD::AND) {\n    if (!N10.getNode()->hasOneUse())\n      return SDValue();\n    ConstantSDNode *N101C = dyn_cast<ConstantSDNode>(N10.getOperand(1));\n    // Also allow 0xFFFF since the bits will be shifted out. This is needed\n    // for X86.\n    if (!N101C || (N101C->getZExtValue() != 0xFF00 &&\n                   N101C->getZExtValue() != 0xFFFF))\n      return SDValue();\n    N10 = N10.getOperand(0);\n    LookPassAnd1 = true;\n  }\n\n  if (N00 != N10)\n    return SDValue();\n\n  // Make sure everything beyond the low halfword gets set to zero since the SRL\n  // 16 will clear the top bits.\n  unsigned OpSizeInBits = VT.getSizeInBits();\n  if (DemandHighBits && OpSizeInBits > 16) {\n    // If the left-shift isn't masked out then the only way this is a bswap is\n    // if all bits beyond the low 8 are 0. In that case the entire pattern\n    // reduces to a left shift anyway: leave it for other parts of the combiner.\n    if (!LookPassAnd0)\n      return SDValue();\n\n    // However, if the right shift isn't masked out then it might be because\n    // it's not needed. See if we can spot that too.\n    if (!LookPassAnd1 &&\n        !DAG.MaskedValueIsZero(\n            N10, APInt::getHighBitsSet(OpSizeInBits, OpSizeInBits - 16)))\n      return SDValue();\n  }\n\n  SDValue Res = DAG.getNode(ISD::BSWAP, SDLoc(N), VT, N00);\n  if (OpSizeInBits > 16) {\n    SDLoc DL(N);\n    Res = DAG.getNode(ISD::SRL, DL, VT, Res,\n                      DAG.getConstant(OpSizeInBits - 16, DL,\n                                      getShiftAmountTy(VT)));\n  }\n  return Res;\n}\n\n/// Return true if the specified node is an element that makes up a 32-bit\n/// packed halfword byteswap.\n/// ((x & 0x000000ff) << 8) |\n/// ((x & 0x0000ff00) >> 8) |\n/// ((x & 0x00ff0000) << 8) |\n/// ((x & 0xff000000) >> 8)\nstatic bool isBSwapHWordElement(SDValue N, MutableArrayRef<SDNode *> Parts) {\n  if (!N.getNode()->hasOneUse())\n    return false;\n\n  unsigned Opc = N.getOpcode();\n  if (Opc != ISD::AND && Opc != ISD::SHL && Opc != ISD::SRL)\n    return false;\n\n  SDValue N0 = N.getOperand(0);\n  unsigned Opc0 = N0.getOpcode();\n  if (Opc0 != ISD::AND && Opc0 != ISD::SHL && Opc0 != ISD::SRL)\n    return false;\n\n  ConstantSDNode *N1C = nullptr;\n  // SHL or SRL: look upstream for AND mask operand\n  if (Opc == ISD::AND)\n    N1C = dyn_cast<ConstantSDNode>(N.getOperand(1));\n  else if (Opc0 == ISD::AND)\n    N1C = dyn_cast<ConstantSDNode>(N0.getOperand(1));\n  if (!N1C)\n    return false;\n\n  unsigned MaskByteOffset;\n  switch (N1C->getZExtValue()) {\n  default:\n    return false;\n  case 0xFF:       MaskByteOffset = 0; break;\n  case 0xFF00:     MaskByteOffset = 1; break;\n  case 0xFFFF:\n    // In case demanded bits didn't clear the bits that will be shifted out.\n    // This is needed for X86.\n    if (Opc == ISD::SRL || (Opc == ISD::AND && Opc0 == ISD::SHL)) {\n      MaskByteOffset = 1;\n      break;\n    }\n    return false;\n  case 0xFF0000:   MaskByteOffset = 2; break;\n  case 0xFF000000: MaskByteOffset = 3; break;\n  }\n\n  // Look for (x & 0xff) << 8 as well as ((x << 8) & 0xff00).\n  if (Opc == ISD::AND) {\n    if (MaskByteOffset == 0 || MaskByteOffset == 2) {\n      // (x >> 8) & 0xff\n      // (x >> 8) & 0xff0000\n      if (Opc0 != ISD::SRL)\n        return false;\n      ConstantSDNode *C = dyn_cast<ConstantSDNode>(N0.getOperand(1));\n      if (!C || C->getZExtValue() != 8)\n        return false;\n    } else {\n      // (x << 8) & 0xff00\n      // (x << 8) & 0xff000000\n      if (Opc0 != ISD::SHL)\n        return false;\n      ConstantSDNode *C = dyn_cast<ConstantSDNode>(N0.getOperand(1));\n      if (!C || C->getZExtValue() != 8)\n        return false;\n    }\n  } else if (Opc == ISD::SHL) {\n    // (x & 0xff) << 8\n    // (x & 0xff0000) << 8\n    if (MaskByteOffset != 0 && MaskByteOffset != 2)\n      return false;\n    ConstantSDNode *C = dyn_cast<ConstantSDNode>(N.getOperand(1));\n    if (!C || C->getZExtValue() != 8)\n      return false;\n  } else { // Opc == ISD::SRL\n    // (x & 0xff00) >> 8\n    // (x & 0xff000000) >> 8\n    if (MaskByteOffset != 1 && MaskByteOffset != 3)\n      return false;\n    ConstantSDNode *C = dyn_cast<ConstantSDNode>(N.getOperand(1));\n    if (!C || C->getZExtValue() != 8)\n      return false;\n  }\n\n  if (Parts[MaskByteOffset])\n    return false;\n\n  Parts[MaskByteOffset] = N0.getOperand(0).getNode();\n  return true;\n}\n\n// Match 2 elements of a packed halfword bswap.\nstatic bool isBSwapHWordPair(SDValue N, MutableArrayRef<SDNode *> Parts) {\n  if (N.getOpcode() == ISD::OR)\n    return isBSwapHWordElement(N.getOperand(0), Parts) &&\n           isBSwapHWordElement(N.getOperand(1), Parts);\n\n  if (N.getOpcode() == ISD::SRL && N.getOperand(0).getOpcode() == ISD::BSWAP) {\n    ConstantSDNode *C = isConstOrConstSplat(N.getOperand(1));\n    if (!C || C->getAPIntValue() != 16)\n      return false;\n    Parts[0] = Parts[1] = N.getOperand(0).getOperand(0).getNode();\n    return true;\n  }\n\n  return false;\n}\n\n// Match this pattern:\n//   (or (and (shl (A, 8)), 0xff00ff00), (and (srl (A, 8)), 0x00ff00ff))\n// And rewrite this to:\n//   (rotr (bswap A), 16)\nstatic SDValue matchBSwapHWordOrAndAnd(const TargetLowering &TLI,\n                                       SelectionDAG &DAG, SDNode *N, SDValue N0,\n                                       SDValue N1, EVT VT, EVT ShiftAmountTy) {\n  assert(N->getOpcode() == ISD::OR && VT == MVT::i32 &&\n         \"MatchBSwapHWordOrAndAnd: expecting i32\");\n  if (!TLI.isOperationLegalOrCustom(ISD::ROTR, VT))\n    return SDValue();\n  if (N0.getOpcode() != ISD::AND || N1.getOpcode() != ISD::AND)\n    return SDValue();\n  // TODO: this is too restrictive; lifting this restriction requires more tests\n  if (!N0->hasOneUse() || !N1->hasOneUse())\n    return SDValue();\n  ConstantSDNode *Mask0 = isConstOrConstSplat(N0.getOperand(1));\n  ConstantSDNode *Mask1 = isConstOrConstSplat(N1.getOperand(1));\n  if (!Mask0 || !Mask1)\n    return SDValue();\n  if (Mask0->getAPIntValue() != 0xff00ff00 ||\n      Mask1->getAPIntValue() != 0x00ff00ff)\n    return SDValue();\n  SDValue Shift0 = N0.getOperand(0);\n  SDValue Shift1 = N1.getOperand(0);\n  if (Shift0.getOpcode() != ISD::SHL || Shift1.getOpcode() != ISD::SRL)\n    return SDValue();\n  ConstantSDNode *ShiftAmt0 = isConstOrConstSplat(Shift0.getOperand(1));\n  ConstantSDNode *ShiftAmt1 = isConstOrConstSplat(Shift1.getOperand(1));\n  if (!ShiftAmt0 || !ShiftAmt1)\n    return SDValue();\n  if (ShiftAmt0->getAPIntValue() != 8 || ShiftAmt1->getAPIntValue() != 8)\n    return SDValue();\n  if (Shift0.getOperand(0) != Shift1.getOperand(0))\n    return SDValue();\n\n  SDLoc DL(N);\n  SDValue BSwap = DAG.getNode(ISD::BSWAP, DL, VT, Shift0.getOperand(0));\n  SDValue ShAmt = DAG.getConstant(16, DL, ShiftAmountTy);\n  return DAG.getNode(ISD::ROTR, DL, VT, BSwap, ShAmt);\n}\n\n/// Match a 32-bit packed halfword bswap. That is\n/// ((x & 0x000000ff) << 8) |\n/// ((x & 0x0000ff00) >> 8) |\n/// ((x & 0x00ff0000) << 8) |\n/// ((x & 0xff000000) >> 8)\n/// => (rotl (bswap x), 16)\nSDValue DAGCombiner::MatchBSwapHWord(SDNode *N, SDValue N0, SDValue N1) {\n  if (!LegalOperations)\n    return SDValue();\n\n  EVT VT = N->getValueType(0);\n  if (VT != MVT::i32)\n    return SDValue();\n  if (!TLI.isOperationLegalOrCustom(ISD::BSWAP, VT))\n    return SDValue();\n\n  if (SDValue BSwap = matchBSwapHWordOrAndAnd(TLI, DAG, N, N0, N1, VT,\n                                              getShiftAmountTy(VT)))\n  return BSwap;\n\n  // Try again with commuted operands.\n  if (SDValue BSwap = matchBSwapHWordOrAndAnd(TLI, DAG, N, N1, N0, VT,\n                                              getShiftAmountTy(VT)))\n  return BSwap;\n\n\n  // Look for either\n  // (or (bswaphpair), (bswaphpair))\n  // (or (or (bswaphpair), (and)), (and))\n  // (or (or (and), (bswaphpair)), (and))\n  SDNode *Parts[4] = {};\n\n  if (isBSwapHWordPair(N0, Parts)) {\n    // (or (or (and), (and)), (or (and), (and)))\n    if (!isBSwapHWordPair(N1, Parts))\n      return SDValue();\n  } else if (N0.getOpcode() == ISD::OR) {\n    // (or (or (or (and), (and)), (and)), (and))\n    if (!isBSwapHWordElement(N1, Parts))\n      return SDValue();\n    SDValue N00 = N0.getOperand(0);\n    SDValue N01 = N0.getOperand(1);\n    if (!(isBSwapHWordElement(N01, Parts) && isBSwapHWordPair(N00, Parts)) &&\n        !(isBSwapHWordElement(N00, Parts) && isBSwapHWordPair(N01, Parts)))\n      return SDValue();\n  } else\n    return SDValue();\n\n  // Make sure the parts are all coming from the same node.\n  if (Parts[0] != Parts[1] || Parts[0] != Parts[2] || Parts[0] != Parts[3])\n    return SDValue();\n\n  SDLoc DL(N);\n  SDValue BSwap = DAG.getNode(ISD::BSWAP, DL, VT,\n                              SDValue(Parts[0], 0));\n\n  // Result of the bswap should be rotated by 16. If it's not legal, then\n  // do  (x << 16) | (x >> 16).\n  SDValue ShAmt = DAG.getConstant(16, DL, getShiftAmountTy(VT));\n  if (TLI.isOperationLegalOrCustom(ISD::ROTL, VT))\n    return DAG.getNode(ISD::ROTL, DL, VT, BSwap, ShAmt);\n  if (TLI.isOperationLegalOrCustom(ISD::ROTR, VT))\n    return DAG.getNode(ISD::ROTR, DL, VT, BSwap, ShAmt);\n  return DAG.getNode(ISD::OR, DL, VT,\n                     DAG.getNode(ISD::SHL, DL, VT, BSwap, ShAmt),\n                     DAG.getNode(ISD::SRL, DL, VT, BSwap, ShAmt));\n}\n\n/// This contains all DAGCombine rules which reduce two values combined by\n/// an Or operation to a single value \\see visitANDLike().\nSDValue DAGCombiner::visitORLike(SDValue N0, SDValue N1, SDNode *N) {\n  EVT VT = N1.getValueType();\n  SDLoc DL(N);\n\n  // fold (or x, undef) -> -1\n  if (!LegalOperations && (N0.isUndef() || N1.isUndef()))\n    return DAG.getAllOnesConstant(DL, VT);\n\n  if (SDValue V = foldLogicOfSetCCs(false, N0, N1, DL))\n    return V;\n\n  // (or (and X, C1), (and Y, C2))  -> (and (or X, Y), C3) if possible.\n  if (N0.getOpcode() == ISD::AND && N1.getOpcode() == ISD::AND &&\n      // Don't increase # computations.\n      (N0.getNode()->hasOneUse() || N1.getNode()->hasOneUse())) {\n    // We can only do this xform if we know that bits from X that are set in C2\n    // but not in C1 are already zero.  Likewise for Y.\n    if (const ConstantSDNode *N0O1C =\n        getAsNonOpaqueConstant(N0.getOperand(1))) {\n      if (const ConstantSDNode *N1O1C =\n          getAsNonOpaqueConstant(N1.getOperand(1))) {\n        // We can only do this xform if we know that bits from X that are set in\n        // C2 but not in C1 are already zero.  Likewise for Y.\n        const APInt &LHSMask = N0O1C->getAPIntValue();\n        const APInt &RHSMask = N1O1C->getAPIntValue();\n\n        if (DAG.MaskedValueIsZero(N0.getOperand(0), RHSMask&~LHSMask) &&\n            DAG.MaskedValueIsZero(N1.getOperand(0), LHSMask&~RHSMask)) {\n          SDValue X = DAG.getNode(ISD::OR, SDLoc(N0), VT,\n                                  N0.getOperand(0), N1.getOperand(0));\n          return DAG.getNode(ISD::AND, DL, VT, X,\n                             DAG.getConstant(LHSMask | RHSMask, DL, VT));\n        }\n      }\n    }\n  }\n\n  // (or (and X, M), (and X, N)) -> (and X, (or M, N))\n  if (N0.getOpcode() == ISD::AND &&\n      N1.getOpcode() == ISD::AND &&\n      N0.getOperand(0) == N1.getOperand(0) &&\n      // Don't increase # computations.\n      (N0.getNode()->hasOneUse() || N1.getNode()->hasOneUse())) {\n    SDValue X = DAG.getNode(ISD::OR, SDLoc(N0), VT,\n                            N0.getOperand(1), N1.getOperand(1));\n    return DAG.getNode(ISD::AND, DL, VT, N0.getOperand(0), X);\n  }\n\n  return SDValue();\n}\n\n/// OR combines for which the commuted variant will be tried as well.\nstatic SDValue visitORCommutative(\n    SelectionDAG &DAG, SDValue N0, SDValue N1, SDNode *N) {\n  EVT VT = N0.getValueType();\n  if (N0.getOpcode() == ISD::AND) {\n    // fold (or (and X, (xor Y, -1)), Y) -> (or X, Y)\n    if (isBitwiseNot(N0.getOperand(1)) && N0.getOperand(1).getOperand(0) == N1)\n      return DAG.getNode(ISD::OR, SDLoc(N), VT, N0.getOperand(0), N1);\n\n    // fold (or (and (xor Y, -1), X), Y) -> (or X, Y)\n    if (isBitwiseNot(N0.getOperand(0)) && N0.getOperand(0).getOperand(0) == N1)\n      return DAG.getNode(ISD::OR, SDLoc(N), VT, N0.getOperand(1), N1);\n  }\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitOR(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  EVT VT = N1.getValueType();\n\n  // x | x --> x\n  if (N0 == N1)\n    return N0;\n\n  // fold vector ops\n  if (VT.isVector()) {\n    if (SDValue FoldedVOp = SimplifyVBinOp(N))\n      return FoldedVOp;\n\n    // fold (or x, 0) -> x, vector edition\n    if (ISD::isBuildVectorAllZeros(N0.getNode()))\n      return N1;\n    if (ISD::isBuildVectorAllZeros(N1.getNode()))\n      return N0;\n\n    // fold (or x, -1) -> -1, vector edition\n    if (ISD::isBuildVectorAllOnes(N0.getNode()))\n      // do not return N0, because undef node may exist in N0\n      return DAG.getAllOnesConstant(SDLoc(N), N0.getValueType());\n    if (ISD::isBuildVectorAllOnes(N1.getNode()))\n      // do not return N1, because undef node may exist in N1\n      return DAG.getAllOnesConstant(SDLoc(N), N1.getValueType());\n\n    // fold (or (shuf A, V_0, MA), (shuf B, V_0, MB)) -> (shuf A, B, Mask)\n    // Do this only if the resulting shuffle is legal.\n    if (isa<ShuffleVectorSDNode>(N0) &&\n        isa<ShuffleVectorSDNode>(N1) &&\n        // Avoid folding a node with illegal type.\n        TLI.isTypeLegal(VT)) {\n      bool ZeroN00 = ISD::isBuildVectorAllZeros(N0.getOperand(0).getNode());\n      bool ZeroN01 = ISD::isBuildVectorAllZeros(N0.getOperand(1).getNode());\n      bool ZeroN10 = ISD::isBuildVectorAllZeros(N1.getOperand(0).getNode());\n      bool ZeroN11 = ISD::isBuildVectorAllZeros(N1.getOperand(1).getNode());\n      // Ensure both shuffles have a zero input.\n      if ((ZeroN00 != ZeroN01) && (ZeroN10 != ZeroN11)) {\n        assert((!ZeroN00 || !ZeroN01) && \"Both inputs zero!\");\n        assert((!ZeroN10 || !ZeroN11) && \"Both inputs zero!\");\n        const ShuffleVectorSDNode *SV0 = cast<ShuffleVectorSDNode>(N0);\n        const ShuffleVectorSDNode *SV1 = cast<ShuffleVectorSDNode>(N1);\n        bool CanFold = true;\n        int NumElts = VT.getVectorNumElements();\n        SmallVector<int, 4> Mask(NumElts);\n\n        for (int i = 0; i != NumElts; ++i) {\n          int M0 = SV0->getMaskElt(i);\n          int M1 = SV1->getMaskElt(i);\n\n          // Determine if either index is pointing to a zero vector.\n          bool M0Zero = M0 < 0 || (ZeroN00 == (M0 < NumElts));\n          bool M1Zero = M1 < 0 || (ZeroN10 == (M1 < NumElts));\n\n          // If one element is zero and the otherside is undef, keep undef.\n          // This also handles the case that both are undef.\n          if ((M0Zero && M1 < 0) || (M1Zero && M0 < 0)) {\n            Mask[i] = -1;\n            continue;\n          }\n\n          // Make sure only one of the elements is zero.\n          if (M0Zero == M1Zero) {\n            CanFold = false;\n            break;\n          }\n\n          assert((M0 >= 0 || M1 >= 0) && \"Undef index!\");\n\n          // We have a zero and non-zero element. If the non-zero came from\n          // SV0 make the index a LHS index. If it came from SV1, make it\n          // a RHS index. We need to mod by NumElts because we don't care\n          // which operand it came from in the original shuffles.\n          Mask[i] = M1Zero ? M0 % NumElts : (M1 % NumElts) + NumElts;\n        }\n\n        if (CanFold) {\n          SDValue NewLHS = ZeroN00 ? N0.getOperand(1) : N0.getOperand(0);\n          SDValue NewRHS = ZeroN10 ? N1.getOperand(1) : N1.getOperand(0);\n\n          SDValue LegalShuffle =\n              TLI.buildLegalVectorShuffle(VT, SDLoc(N), NewLHS, NewRHS,\n                                          Mask, DAG);\n          if (LegalShuffle)\n            return LegalShuffle;\n        }\n      }\n    }\n  }\n\n  // fold (or c1, c2) -> c1|c2\n  ConstantSDNode *N1C = dyn_cast<ConstantSDNode>(N1);\n  if (SDValue C = DAG.FoldConstantArithmetic(ISD::OR, SDLoc(N), VT, {N0, N1}))\n    return C;\n\n  // canonicalize constant to RHS\n  if (DAG.isConstantIntBuildVectorOrConstantInt(N0) &&\n     !DAG.isConstantIntBuildVectorOrConstantInt(N1))\n    return DAG.getNode(ISD::OR, SDLoc(N), VT, N1, N0);\n\n  // fold (or x, 0) -> x\n  if (isNullConstant(N1))\n    return N0;\n\n  // fold (or x, -1) -> -1\n  if (isAllOnesConstant(N1))\n    return N1;\n\n  if (SDValue NewSel = foldBinOpIntoSelect(N))\n    return NewSel;\n\n  // fold (or x, c) -> c iff (x & ~c) == 0\n  if (N1C && DAG.MaskedValueIsZero(N0, ~N1C->getAPIntValue()))\n    return N1;\n\n  if (SDValue Combined = visitORLike(N0, N1, N))\n    return Combined;\n\n  if (SDValue Combined = combineCarryDiamond(*this, DAG, TLI, N0, N1, N))\n    return Combined;\n\n  // Recognize halfword bswaps as (bswap + rotl 16) or (bswap + shl 16)\n  if (SDValue BSwap = MatchBSwapHWord(N, N0, N1))\n    return BSwap;\n  if (SDValue BSwap = MatchBSwapHWordLow(N, N0, N1))\n    return BSwap;\n\n  // reassociate or\n  if (SDValue ROR = reassociateOps(ISD::OR, SDLoc(N), N0, N1, N->getFlags()))\n    return ROR;\n\n  // Canonicalize (or (and X, c1), c2) -> (and (or X, c2), c1|c2)\n  // iff (c1 & c2) != 0 or c1/c2 are undef.\n  auto MatchIntersect = [](ConstantSDNode *C1, ConstantSDNode *C2) {\n    return !C1 || !C2 || C1->getAPIntValue().intersects(C2->getAPIntValue());\n  };\n  if (N0.getOpcode() == ISD::AND && N0.getNode()->hasOneUse() &&\n      ISD::matchBinaryPredicate(N0.getOperand(1), N1, MatchIntersect, true)) {\n    if (SDValue COR = DAG.FoldConstantArithmetic(ISD::OR, SDLoc(N1), VT,\n                                                 {N1, N0.getOperand(1)})) {\n      SDValue IOR = DAG.getNode(ISD::OR, SDLoc(N0), VT, N0.getOperand(0), N1);\n      AddToWorklist(IOR.getNode());\n      return DAG.getNode(ISD::AND, SDLoc(N), VT, COR, IOR);\n    }\n  }\n\n  if (SDValue Combined = visitORCommutative(DAG, N0, N1, N))\n    return Combined;\n  if (SDValue Combined = visitORCommutative(DAG, N1, N0, N))\n    return Combined;\n\n  // Simplify: (or (op x...), (op y...))  -> (op (or x, y))\n  if (N0.getOpcode() == N1.getOpcode())\n    if (SDValue V = hoistLogicOpWithSameOpcodeHands(N))\n      return V;\n\n  // See if this is some rotate idiom.\n  if (SDValue Rot = MatchRotate(N0, N1, SDLoc(N)))\n    return Rot;\n\n  if (SDValue Load = MatchLoadCombine(N))\n    return Load;\n\n  // Simplify the operands using demanded-bits information.\n  if (SimplifyDemandedBits(SDValue(N, 0)))\n    return SDValue(N, 0);\n\n  // If OR can be rewritten into ADD, try combines based on ADD.\n  if ((!LegalOperations || TLI.isOperationLegal(ISD::ADD, VT)) &&\n      DAG.haveNoCommonBitsSet(N0, N1))\n    if (SDValue Combined = visitADDLike(N))\n      return Combined;\n\n  return SDValue();\n}\n\nstatic SDValue stripConstantMask(SelectionDAG &DAG, SDValue Op, SDValue &Mask) {\n  if (Op.getOpcode() == ISD::AND &&\n      DAG.isConstantIntBuildVectorOrConstantInt(Op.getOperand(1))) {\n    Mask = Op.getOperand(1);\n    return Op.getOperand(0);\n  }\n  return Op;\n}\n\n/// Match \"(X shl/srl V1) & V2\" where V2 may not be present.\nstatic bool matchRotateHalf(SelectionDAG &DAG, SDValue Op, SDValue &Shift,\n                            SDValue &Mask) {\n  Op = stripConstantMask(DAG, Op, Mask);\n  if (Op.getOpcode() == ISD::SRL || Op.getOpcode() == ISD::SHL) {\n    Shift = Op;\n    return true;\n  }\n  return false;\n}\n\n/// Helper function for visitOR to extract the needed side of a rotate idiom\n/// from a shl/srl/mul/udiv.  This is meant to handle cases where\n/// InstCombine merged some outside op with one of the shifts from\n/// the rotate pattern.\n/// \\returns An empty \\c SDValue if the needed shift couldn't be extracted.\n/// Otherwise, returns an expansion of \\p ExtractFrom based on the following\n/// patterns:\n///\n///   (or (add v v) (shrl v bitwidth-1)):\n///     expands (add v v) -> (shl v 1)\n///\n///   (or (mul v c0) (shrl (mul v c1) c2)):\n///     expands (mul v c0) -> (shl (mul v c1) c3)\n///\n///   (or (udiv v c0) (shl (udiv v c1) c2)):\n///     expands (udiv v c0) -> (shrl (udiv v c1) c3)\n///\n///   (or (shl v c0) (shrl (shl v c1) c2)):\n///     expands (shl v c0) -> (shl (shl v c1) c3)\n///\n///   (or (shrl v c0) (shl (shrl v c1) c2)):\n///     expands (shrl v c0) -> (shrl (shrl v c1) c3)\n///\n/// Such that in all cases, c3+c2==bitwidth(op v c1).\nstatic SDValue extractShiftForRotate(SelectionDAG &DAG, SDValue OppShift,\n                                     SDValue ExtractFrom, SDValue &Mask,\n                                     const SDLoc &DL) {\n  assert(OppShift && ExtractFrom && \"Empty SDValue\");\n  assert(\n      (OppShift.getOpcode() == ISD::SHL || OppShift.getOpcode() == ISD::SRL) &&\n      \"Existing shift must be valid as a rotate half\");\n\n  ExtractFrom = stripConstantMask(DAG, ExtractFrom, Mask);\n\n  // Value and Type of the shift.\n  SDValue OppShiftLHS = OppShift.getOperand(0);\n  EVT ShiftedVT = OppShiftLHS.getValueType();\n\n  // Amount of the existing shift.\n  ConstantSDNode *OppShiftCst = isConstOrConstSplat(OppShift.getOperand(1));\n\n  // (add v v) -> (shl v 1)\n  // TODO: Should this be a general DAG canonicalization?\n  if (OppShift.getOpcode() == ISD::SRL && OppShiftCst &&\n      ExtractFrom.getOpcode() == ISD::ADD &&\n      ExtractFrom.getOperand(0) == ExtractFrom.getOperand(1) &&\n      ExtractFrom.getOperand(0) == OppShiftLHS &&\n      OppShiftCst->getAPIntValue() == ShiftedVT.getScalarSizeInBits() - 1)\n    return DAG.getNode(ISD::SHL, DL, ShiftedVT, OppShiftLHS,\n                       DAG.getShiftAmountConstant(1, ShiftedVT, DL));\n\n  // Preconditions:\n  //    (or (op0 v c0) (shiftl/r (op0 v c1) c2))\n  //\n  // Find opcode of the needed shift to be extracted from (op0 v c0).\n  unsigned Opcode = ISD::DELETED_NODE;\n  bool IsMulOrDiv = false;\n  // Set Opcode and IsMulOrDiv if the extract opcode matches the needed shift\n  // opcode or its arithmetic (mul or udiv) variant.\n  auto SelectOpcode = [&](unsigned NeededShift, unsigned MulOrDivVariant) {\n    IsMulOrDiv = ExtractFrom.getOpcode() == MulOrDivVariant;\n    if (!IsMulOrDiv && ExtractFrom.getOpcode() != NeededShift)\n      return false;\n    Opcode = NeededShift;\n    return true;\n  };\n  // op0 must be either the needed shift opcode or the mul/udiv equivalent\n  // that the needed shift can be extracted from.\n  if ((OppShift.getOpcode() != ISD::SRL || !SelectOpcode(ISD::SHL, ISD::MUL)) &&\n      (OppShift.getOpcode() != ISD::SHL || !SelectOpcode(ISD::SRL, ISD::UDIV)))\n    return SDValue();\n\n  // op0 must be the same opcode on both sides, have the same LHS argument,\n  // and produce the same value type.\n  if (OppShiftLHS.getOpcode() != ExtractFrom.getOpcode() ||\n      OppShiftLHS.getOperand(0) != ExtractFrom.getOperand(0) ||\n      ShiftedVT != ExtractFrom.getValueType())\n    return SDValue();\n\n  // Constant mul/udiv/shift amount from the RHS of the shift's LHS op.\n  ConstantSDNode *OppLHSCst = isConstOrConstSplat(OppShiftLHS.getOperand(1));\n  // Constant mul/udiv/shift amount from the RHS of the ExtractFrom op.\n  ConstantSDNode *ExtractFromCst =\n      isConstOrConstSplat(ExtractFrom.getOperand(1));\n  // TODO: We should be able to handle non-uniform constant vectors for these values\n  // Check that we have constant values.\n  if (!OppShiftCst || !OppShiftCst->getAPIntValue() ||\n      !OppLHSCst || !OppLHSCst->getAPIntValue() ||\n      !ExtractFromCst || !ExtractFromCst->getAPIntValue())\n    return SDValue();\n\n  // Compute the shift amount we need to extract to complete the rotate.\n  const unsigned VTWidth = ShiftedVT.getScalarSizeInBits();\n  if (OppShiftCst->getAPIntValue().ugt(VTWidth))\n    return SDValue();\n  APInt NeededShiftAmt = VTWidth - OppShiftCst->getAPIntValue();\n  // Normalize the bitwidth of the two mul/udiv/shift constant operands.\n  APInt ExtractFromAmt = ExtractFromCst->getAPIntValue();\n  APInt OppLHSAmt = OppLHSCst->getAPIntValue();\n  zeroExtendToMatch(ExtractFromAmt, OppLHSAmt);\n\n  // Now try extract the needed shift from the ExtractFrom op and see if the\n  // result matches up with the existing shift's LHS op.\n  if (IsMulOrDiv) {\n    // Op to extract from is a mul or udiv by a constant.\n    // Check:\n    //     c2 / (1 << (bitwidth(op0 v c0) - c1)) == c0\n    //     c2 % (1 << (bitwidth(op0 v c0) - c1)) == 0\n    const APInt ExtractDiv = APInt::getOneBitSet(ExtractFromAmt.getBitWidth(),\n                                                 NeededShiftAmt.getZExtValue());\n    APInt ResultAmt;\n    APInt Rem;\n    APInt::udivrem(ExtractFromAmt, ExtractDiv, ResultAmt, Rem);\n    if (Rem != 0 || ResultAmt != OppLHSAmt)\n      return SDValue();\n  } else {\n    // Op to extract from is a shift by a constant.\n    // Check:\n    //      c2 - (bitwidth(op0 v c0) - c1) == c0\n    if (OppLHSAmt != ExtractFromAmt - NeededShiftAmt.zextOrTrunc(\n                                          ExtractFromAmt.getBitWidth()))\n      return SDValue();\n  }\n\n  // Return the expanded shift op that should allow a rotate to be formed.\n  EVT ShiftVT = OppShift.getOperand(1).getValueType();\n  EVT ResVT = ExtractFrom.getValueType();\n  SDValue NewShiftNode = DAG.getConstant(NeededShiftAmt, DL, ShiftVT);\n  return DAG.getNode(Opcode, DL, ResVT, OppShiftLHS, NewShiftNode);\n}\n\n// Return true if we can prove that, whenever Neg and Pos are both in the\n// range [0, EltSize), Neg == (Pos == 0 ? 0 : EltSize - Pos).  This means that\n// for two opposing shifts shift1 and shift2 and a value X with OpBits bits:\n//\n//     (or (shift1 X, Neg), (shift2 X, Pos))\n//\n// reduces to a rotate in direction shift2 by Pos or (equivalently) a rotate\n// in direction shift1 by Neg.  The range [0, EltSize) means that we only need\n// to consider shift amounts with defined behavior.\n//\n// The IsRotate flag should be set when the LHS of both shifts is the same.\n// Otherwise if matching a general funnel shift, it should be clear.\nstatic bool matchRotateSub(SDValue Pos, SDValue Neg, unsigned EltSize,\n                           SelectionDAG &DAG, bool IsRotate) {\n  // If EltSize is a power of 2 then:\n  //\n  //  (a) (Pos == 0 ? 0 : EltSize - Pos) == (EltSize - Pos) & (EltSize - 1)\n  //  (b) Neg == Neg & (EltSize - 1) whenever Neg is in [0, EltSize).\n  //\n  // So if EltSize is a power of 2 and Neg is (and Neg', EltSize-1), we check\n  // for the stronger condition:\n  //\n  //     Neg & (EltSize - 1) == (EltSize - Pos) & (EltSize - 1)    [A]\n  //\n  // for all Neg and Pos.  Since Neg & (EltSize - 1) == Neg' & (EltSize - 1)\n  // we can just replace Neg with Neg' for the rest of the function.\n  //\n  // In other cases we check for the even stronger condition:\n  //\n  //     Neg == EltSize - Pos                                    [B]\n  //\n  // for all Neg and Pos.  Note that the (or ...) then invokes undefined\n  // behavior if Pos == 0 (and consequently Neg == EltSize).\n  //\n  // We could actually use [A] whenever EltSize is a power of 2, but the\n  // only extra cases that it would match are those uninteresting ones\n  // where Neg and Pos are never in range at the same time.  E.g. for\n  // EltSize == 32, using [A] would allow a Neg of the form (sub 64, Pos)\n  // as well as (sub 32, Pos), but:\n  //\n  //     (or (shift1 X, (sub 64, Pos)), (shift2 X, Pos))\n  //\n  // always invokes undefined behavior for 32-bit X.\n  //\n  // Below, Mask == EltSize - 1 when using [A] and is all-ones otherwise.\n  //\n  // NOTE: We can only do this when matching an AND and not a general\n  // funnel shift.\n  unsigned MaskLoBits = 0;\n  if (IsRotate && Neg.getOpcode() == ISD::AND && isPowerOf2_64(EltSize)) {\n    if (ConstantSDNode *NegC = isConstOrConstSplat(Neg.getOperand(1))) {\n      KnownBits Known = DAG.computeKnownBits(Neg.getOperand(0));\n      unsigned Bits = Log2_64(EltSize);\n      if (NegC->getAPIntValue().getActiveBits() <= Bits &&\n          ((NegC->getAPIntValue() | Known.Zero).countTrailingOnes() >= Bits)) {\n        Neg = Neg.getOperand(0);\n        MaskLoBits = Bits;\n      }\n    }\n  }\n\n  // Check whether Neg has the form (sub NegC, NegOp1) for some NegC and NegOp1.\n  if (Neg.getOpcode() != ISD::SUB)\n    return false;\n  ConstantSDNode *NegC = isConstOrConstSplat(Neg.getOperand(0));\n  if (!NegC)\n    return false;\n  SDValue NegOp1 = Neg.getOperand(1);\n\n  // On the RHS of [A], if Pos is Pos' & (EltSize - 1), just replace Pos with\n  // Pos'.  The truncation is redundant for the purpose of the equality.\n  if (MaskLoBits && Pos.getOpcode() == ISD::AND) {\n    if (ConstantSDNode *PosC = isConstOrConstSplat(Pos.getOperand(1))) {\n      KnownBits Known = DAG.computeKnownBits(Pos.getOperand(0));\n      if (PosC->getAPIntValue().getActiveBits() <= MaskLoBits &&\n          ((PosC->getAPIntValue() | Known.Zero).countTrailingOnes() >=\n           MaskLoBits))\n        Pos = Pos.getOperand(0);\n    }\n  }\n\n  // The condition we need is now:\n  //\n  //     (NegC - NegOp1) & Mask == (EltSize - Pos) & Mask\n  //\n  // If NegOp1 == Pos then we need:\n  //\n  //              EltSize & Mask == NegC & Mask\n  //\n  // (because \"x & Mask\" is a truncation and distributes through subtraction).\n  //\n  // We also need to account for a potential truncation of NegOp1 if the amount\n  // has already been legalized to a shift amount type.\n  APInt Width;\n  if ((Pos == NegOp1) ||\n      (NegOp1.getOpcode() == ISD::TRUNCATE && Pos == NegOp1.getOperand(0)))\n    Width = NegC->getAPIntValue();\n\n  // Check for cases where Pos has the form (add NegOp1, PosC) for some PosC.\n  // Then the condition we want to prove becomes:\n  //\n  //     (NegC - NegOp1) & Mask == (EltSize - (NegOp1 + PosC)) & Mask\n  //\n  // which, again because \"x & Mask\" is a truncation, becomes:\n  //\n  //                NegC & Mask == (EltSize - PosC) & Mask\n  //             EltSize & Mask == (NegC + PosC) & Mask\n  else if (Pos.getOpcode() == ISD::ADD && Pos.getOperand(0) == NegOp1) {\n    if (ConstantSDNode *PosC = isConstOrConstSplat(Pos.getOperand(1)))\n      Width = PosC->getAPIntValue() + NegC->getAPIntValue();\n    else\n      return false;\n  } else\n    return false;\n\n  // Now we just need to check that EltSize & Mask == Width & Mask.\n  if (MaskLoBits)\n    // EltSize & Mask is 0 since Mask is EltSize - 1.\n    return Width.getLoBits(MaskLoBits) == 0;\n  return Width == EltSize;\n}\n\n// A subroutine of MatchRotate used once we have found an OR of two opposite\n// shifts of Shifted.  If Neg == <operand size> - Pos then the OR reduces\n// to both (PosOpcode Shifted, Pos) and (NegOpcode Shifted, Neg), with the\n// former being preferred if supported.  InnerPos and InnerNeg are Pos and\n// Neg with outer conversions stripped away.\nSDValue DAGCombiner::MatchRotatePosNeg(SDValue Shifted, SDValue Pos,\n                                       SDValue Neg, SDValue InnerPos,\n                                       SDValue InnerNeg, unsigned PosOpcode,\n                                       unsigned NegOpcode, const SDLoc &DL) {\n  // fold (or (shl x, (*ext y)),\n  //          (srl x, (*ext (sub 32, y)))) ->\n  //   (rotl x, y) or (rotr x, (sub 32, y))\n  //\n  // fold (or (shl x, (*ext (sub 32, y))),\n  //          (srl x, (*ext y))) ->\n  //   (rotr x, y) or (rotl x, (sub 32, y))\n  EVT VT = Shifted.getValueType();\n  if (matchRotateSub(InnerPos, InnerNeg, VT.getScalarSizeInBits(), DAG,\n                     /*IsRotate*/ true)) {\n    bool HasPos = TLI.isOperationLegalOrCustom(PosOpcode, VT);\n    return DAG.getNode(HasPos ? PosOpcode : NegOpcode, DL, VT, Shifted,\n                       HasPos ? Pos : Neg);\n  }\n\n  return SDValue();\n}\n\n// A subroutine of MatchRotate used once we have found an OR of two opposite\n// shifts of N0 + N1.  If Neg == <operand size> - Pos then the OR reduces\n// to both (PosOpcode N0, N1, Pos) and (NegOpcode N0, N1, Neg), with the\n// former being preferred if supported.  InnerPos and InnerNeg are Pos and\n// Neg with outer conversions stripped away.\n// TODO: Merge with MatchRotatePosNeg.\nSDValue DAGCombiner::MatchFunnelPosNeg(SDValue N0, SDValue N1, SDValue Pos,\n                                       SDValue Neg, SDValue InnerPos,\n                                       SDValue InnerNeg, unsigned PosOpcode,\n                                       unsigned NegOpcode, const SDLoc &DL) {\n  EVT VT = N0.getValueType();\n  unsigned EltBits = VT.getScalarSizeInBits();\n\n  // fold (or (shl x0, (*ext y)),\n  //          (srl x1, (*ext (sub 32, y)))) ->\n  //   (fshl x0, x1, y) or (fshr x0, x1, (sub 32, y))\n  //\n  // fold (or (shl x0, (*ext (sub 32, y))),\n  //          (srl x1, (*ext y))) ->\n  //   (fshr x0, x1, y) or (fshl x0, x1, (sub 32, y))\n  if (matchRotateSub(InnerPos, InnerNeg, EltBits, DAG, /*IsRotate*/ N0 == N1)) {\n    bool HasPos = TLI.isOperationLegalOrCustom(PosOpcode, VT);\n    return DAG.getNode(HasPos ? PosOpcode : NegOpcode, DL, VT, N0, N1,\n                       HasPos ? Pos : Neg);\n  }\n\n  // Matching the shift+xor cases, we can't easily use the xor'd shift amount\n  // so for now just use the PosOpcode case if its legal.\n  // TODO: When can we use the NegOpcode case?\n  if (PosOpcode == ISD::FSHL && isPowerOf2_32(EltBits)) {\n    auto IsBinOpImm = [](SDValue Op, unsigned BinOpc, unsigned Imm) {\n      if (Op.getOpcode() != BinOpc)\n        return false;\n      ConstantSDNode *Cst = isConstOrConstSplat(Op.getOperand(1));\n      return Cst && (Cst->getAPIntValue() == Imm);\n    };\n\n    // fold (or (shl x0, y), (srl (srl x1, 1), (xor y, 31)))\n    //   -> (fshl x0, x1, y)\n    if (IsBinOpImm(N1, ISD::SRL, 1) &&\n        IsBinOpImm(InnerNeg, ISD::XOR, EltBits - 1) &&\n        InnerPos == InnerNeg.getOperand(0) &&\n        TLI.isOperationLegalOrCustom(ISD::FSHL, VT)) {\n      return DAG.getNode(ISD::FSHL, DL, VT, N0, N1.getOperand(0), Pos);\n    }\n\n    // fold (or (shl (shl x0, 1), (xor y, 31)), (srl x1, y))\n    //   -> (fshr x0, x1, y)\n    if (IsBinOpImm(N0, ISD::SHL, 1) &&\n        IsBinOpImm(InnerPos, ISD::XOR, EltBits - 1) &&\n        InnerNeg == InnerPos.getOperand(0) &&\n        TLI.isOperationLegalOrCustom(ISD::FSHR, VT)) {\n      return DAG.getNode(ISD::FSHR, DL, VT, N0.getOperand(0), N1, Neg);\n    }\n\n    // fold (or (shl (add x0, x0), (xor y, 31)), (srl x1, y))\n    //   -> (fshr x0, x1, y)\n    // TODO: Should add(x,x) -> shl(x,1) be a general DAG canonicalization?\n    if (N0.getOpcode() == ISD::ADD && N0.getOperand(0) == N0.getOperand(1) &&\n        IsBinOpImm(InnerPos, ISD::XOR, EltBits - 1) &&\n        InnerNeg == InnerPos.getOperand(0) &&\n        TLI.isOperationLegalOrCustom(ISD::FSHR, VT)) {\n      return DAG.getNode(ISD::FSHR, DL, VT, N0.getOperand(0), N1, Neg);\n    }\n  }\n\n  return SDValue();\n}\n\n// MatchRotate - Handle an 'or' of two operands.  If this is one of the many\n// idioms for rotate, and if the target supports rotation instructions, generate\n// a rot[lr]. This also matches funnel shift patterns, similar to rotation but\n// with different shifted sources.\nSDValue DAGCombiner::MatchRotate(SDValue LHS, SDValue RHS, const SDLoc &DL) {\n  // Must be a legal type.  Expanded 'n promoted things won't work with rotates.\n  EVT VT = LHS.getValueType();\n  if (!TLI.isTypeLegal(VT))\n    return SDValue();\n\n  // The target must have at least one rotate/funnel flavor.\n  bool HasROTL = hasOperation(ISD::ROTL, VT);\n  bool HasROTR = hasOperation(ISD::ROTR, VT);\n  bool HasFSHL = hasOperation(ISD::FSHL, VT);\n  bool HasFSHR = hasOperation(ISD::FSHR, VT);\n  if (!HasROTL && !HasROTR && !HasFSHL && !HasFSHR)\n    return SDValue();\n\n  // Check for truncated rotate.\n  if (LHS.getOpcode() == ISD::TRUNCATE && RHS.getOpcode() == ISD::TRUNCATE &&\n      LHS.getOperand(0).getValueType() == RHS.getOperand(0).getValueType()) {\n    assert(LHS.getValueType() == RHS.getValueType());\n    if (SDValue Rot = MatchRotate(LHS.getOperand(0), RHS.getOperand(0), DL)) {\n      return DAG.getNode(ISD::TRUNCATE, SDLoc(LHS), LHS.getValueType(), Rot);\n    }\n  }\n\n  // Match \"(X shl/srl V1) & V2\" where V2 may not be present.\n  SDValue LHSShift;   // The shift.\n  SDValue LHSMask;    // AND value if any.\n  matchRotateHalf(DAG, LHS, LHSShift, LHSMask);\n\n  SDValue RHSShift;   // The shift.\n  SDValue RHSMask;    // AND value if any.\n  matchRotateHalf(DAG, RHS, RHSShift, RHSMask);\n\n  // If neither side matched a rotate half, bail\n  if (!LHSShift && !RHSShift)\n    return SDValue();\n\n  // InstCombine may have combined a constant shl, srl, mul, or udiv with one\n  // side of the rotate, so try to handle that here. In all cases we need to\n  // pass the matched shift from the opposite side to compute the opcode and\n  // needed shift amount to extract.  We still want to do this if both sides\n  // matched a rotate half because one half may be a potential overshift that\n  // can be broken down (ie if InstCombine merged two shl or srl ops into a\n  // single one).\n\n  // Have LHS side of the rotate, try to extract the needed shift from the RHS.\n  if (LHSShift)\n    if (SDValue NewRHSShift =\n            extractShiftForRotate(DAG, LHSShift, RHS, RHSMask, DL))\n      RHSShift = NewRHSShift;\n  // Have RHS side of the rotate, try to extract the needed shift from the LHS.\n  if (RHSShift)\n    if (SDValue NewLHSShift =\n            extractShiftForRotate(DAG, RHSShift, LHS, LHSMask, DL))\n      LHSShift = NewLHSShift;\n\n  // If a side is still missing, nothing else we can do.\n  if (!RHSShift || !LHSShift)\n    return SDValue();\n\n  // At this point we've matched or extracted a shift op on each side.\n\n  if (LHSShift.getOpcode() == RHSShift.getOpcode())\n    return SDValue(); // Shifts must disagree.\n\n  bool IsRotate = LHSShift.getOperand(0) == RHSShift.getOperand(0);\n  if (!IsRotate && !(HasFSHL || HasFSHR))\n    return SDValue(); // Requires funnel shift support.\n\n  // Canonicalize shl to left side in a shl/srl pair.\n  if (RHSShift.getOpcode() == ISD::SHL) {\n    std::swap(LHS, RHS);\n    std::swap(LHSShift, RHSShift);\n    std::swap(LHSMask, RHSMask);\n  }\n\n  unsigned EltSizeInBits = VT.getScalarSizeInBits();\n  SDValue LHSShiftArg = LHSShift.getOperand(0);\n  SDValue LHSShiftAmt = LHSShift.getOperand(1);\n  SDValue RHSShiftArg = RHSShift.getOperand(0);\n  SDValue RHSShiftAmt = RHSShift.getOperand(1);\n\n  // fold (or (shl x, C1), (srl x, C2)) -> (rotl x, C1)\n  // fold (or (shl x, C1), (srl x, C2)) -> (rotr x, C2)\n  // fold (or (shl x, C1), (srl y, C2)) -> (fshl x, y, C1)\n  // fold (or (shl x, C1), (srl y, C2)) -> (fshr x, y, C2)\n  // iff C1+C2 == EltSizeInBits\n  auto MatchRotateSum = [EltSizeInBits](ConstantSDNode *LHS,\n                                        ConstantSDNode *RHS) {\n    return (LHS->getAPIntValue() + RHS->getAPIntValue()) == EltSizeInBits;\n  };\n  if (ISD::matchBinaryPredicate(LHSShiftAmt, RHSShiftAmt, MatchRotateSum)) {\n    SDValue Res;\n    if (IsRotate && (HasROTL || HasROTR))\n      Res = DAG.getNode(HasROTL ? ISD::ROTL : ISD::ROTR, DL, VT, LHSShiftArg,\n                        HasROTL ? LHSShiftAmt : RHSShiftAmt);\n    else\n      Res = DAG.getNode(HasFSHL ? ISD::FSHL : ISD::FSHR, DL, VT, LHSShiftArg,\n                        RHSShiftArg, HasFSHL ? LHSShiftAmt : RHSShiftAmt);\n\n    // If there is an AND of either shifted operand, apply it to the result.\n    if (LHSMask.getNode() || RHSMask.getNode()) {\n      SDValue AllOnes = DAG.getAllOnesConstant(DL, VT);\n      SDValue Mask = AllOnes;\n\n      if (LHSMask.getNode()) {\n        SDValue RHSBits = DAG.getNode(ISD::SRL, DL, VT, AllOnes, RHSShiftAmt);\n        Mask = DAG.getNode(ISD::AND, DL, VT, Mask,\n                           DAG.getNode(ISD::OR, DL, VT, LHSMask, RHSBits));\n      }\n      if (RHSMask.getNode()) {\n        SDValue LHSBits = DAG.getNode(ISD::SHL, DL, VT, AllOnes, LHSShiftAmt);\n        Mask = DAG.getNode(ISD::AND, DL, VT, Mask,\n                           DAG.getNode(ISD::OR, DL, VT, RHSMask, LHSBits));\n      }\n\n      Res = DAG.getNode(ISD::AND, DL, VT, Res, Mask);\n    }\n\n    return Res;\n  }\n\n  // If there is a mask here, and we have a variable shift, we can't be sure\n  // that we're masking out the right stuff.\n  if (LHSMask.getNode() || RHSMask.getNode())\n    return SDValue();\n\n  // If the shift amount is sign/zext/any-extended just peel it off.\n  SDValue LExtOp0 = LHSShiftAmt;\n  SDValue RExtOp0 = RHSShiftAmt;\n  if ((LHSShiftAmt.getOpcode() == ISD::SIGN_EXTEND ||\n       LHSShiftAmt.getOpcode() == ISD::ZERO_EXTEND ||\n       LHSShiftAmt.getOpcode() == ISD::ANY_EXTEND ||\n       LHSShiftAmt.getOpcode() == ISD::TRUNCATE) &&\n      (RHSShiftAmt.getOpcode() == ISD::SIGN_EXTEND ||\n       RHSShiftAmt.getOpcode() == ISD::ZERO_EXTEND ||\n       RHSShiftAmt.getOpcode() == ISD::ANY_EXTEND ||\n       RHSShiftAmt.getOpcode() == ISD::TRUNCATE)) {\n    LExtOp0 = LHSShiftAmt.getOperand(0);\n    RExtOp0 = RHSShiftAmt.getOperand(0);\n  }\n\n  if (IsRotate && (HasROTL || HasROTR)) {\n    SDValue TryL =\n        MatchRotatePosNeg(LHSShiftArg, LHSShiftAmt, RHSShiftAmt, LExtOp0,\n                          RExtOp0, ISD::ROTL, ISD::ROTR, DL);\n    if (TryL)\n      return TryL;\n\n    SDValue TryR =\n        MatchRotatePosNeg(RHSShiftArg, RHSShiftAmt, LHSShiftAmt, RExtOp0,\n                          LExtOp0, ISD::ROTR, ISD::ROTL, DL);\n    if (TryR)\n      return TryR;\n  }\n\n  SDValue TryL =\n      MatchFunnelPosNeg(LHSShiftArg, RHSShiftArg, LHSShiftAmt, RHSShiftAmt,\n                        LExtOp0, RExtOp0, ISD::FSHL, ISD::FSHR, DL);\n  if (TryL)\n    return TryL;\n\n  SDValue TryR =\n      MatchFunnelPosNeg(LHSShiftArg, RHSShiftArg, RHSShiftAmt, LHSShiftAmt,\n                        RExtOp0, LExtOp0, ISD::FSHR, ISD::FSHL, DL);\n  if (TryR)\n    return TryR;\n\n  return SDValue();\n}\n\nnamespace {\n\n/// Represents known origin of an individual byte in load combine pattern. The\n/// value of the byte is either constant zero or comes from memory.\nstruct ByteProvider {\n  // For constant zero providers Load is set to nullptr. For memory providers\n  // Load represents the node which loads the byte from memory.\n  // ByteOffset is the offset of the byte in the value produced by the load.\n  LoadSDNode *Load = nullptr;\n  unsigned ByteOffset = 0;\n\n  ByteProvider() = default;\n\n  static ByteProvider getMemory(LoadSDNode *Load, unsigned ByteOffset) {\n    return ByteProvider(Load, ByteOffset);\n  }\n\n  static ByteProvider getConstantZero() { return ByteProvider(nullptr, 0); }\n\n  bool isConstantZero() const { return !Load; }\n  bool isMemory() const { return Load; }\n\n  bool operator==(const ByteProvider &Other) const {\n    return Other.Load == Load && Other.ByteOffset == ByteOffset;\n  }\n\nprivate:\n  ByteProvider(LoadSDNode *Load, unsigned ByteOffset)\n      : Load(Load), ByteOffset(ByteOffset) {}\n};\n\n} // end anonymous namespace\n\n/// Recursively traverses the expression calculating the origin of the requested\n/// byte of the given value. Returns None if the provider can't be calculated.\n///\n/// For all the values except the root of the expression verifies that the value\n/// has exactly one use and if it's not true return None. This way if the origin\n/// of the byte is returned it's guaranteed that the values which contribute to\n/// the byte are not used outside of this expression.\n///\n/// Because the parts of the expression are not allowed to have more than one\n/// use this function iterates over trees, not DAGs. So it never visits the same\n/// node more than once.\nstatic const Optional<ByteProvider>\ncalculateByteProvider(SDValue Op, unsigned Index, unsigned Depth,\n                      bool Root = false) {\n  // Typical i64 by i8 pattern requires recursion up to 8 calls depth\n  if (Depth == 10)\n    return None;\n\n  if (!Root && !Op.hasOneUse())\n    return None;\n\n  assert(Op.getValueType().isScalarInteger() && \"can't handle other types\");\n  unsigned BitWidth = Op.getValueSizeInBits();\n  if (BitWidth % 8 != 0)\n    return None;\n  unsigned ByteWidth = BitWidth / 8;\n  assert(Index < ByteWidth && \"invalid index requested\");\n  (void) ByteWidth;\n\n  switch (Op.getOpcode()) {\n  case ISD::OR: {\n    auto LHS = calculateByteProvider(Op->getOperand(0), Index, Depth + 1);\n    if (!LHS)\n      return None;\n    auto RHS = calculateByteProvider(Op->getOperand(1), Index, Depth + 1);\n    if (!RHS)\n      return None;\n\n    if (LHS->isConstantZero())\n      return RHS;\n    if (RHS->isConstantZero())\n      return LHS;\n    return None;\n  }\n  case ISD::SHL: {\n    auto ShiftOp = dyn_cast<ConstantSDNode>(Op->getOperand(1));\n    if (!ShiftOp)\n      return None;\n\n    uint64_t BitShift = ShiftOp->getZExtValue();\n    if (BitShift % 8 != 0)\n      return None;\n    uint64_t ByteShift = BitShift / 8;\n\n    return Index < ByteShift\n               ? ByteProvider::getConstantZero()\n               : calculateByteProvider(Op->getOperand(0), Index - ByteShift,\n                                       Depth + 1);\n  }\n  case ISD::ANY_EXTEND:\n  case ISD::SIGN_EXTEND:\n  case ISD::ZERO_EXTEND: {\n    SDValue NarrowOp = Op->getOperand(0);\n    unsigned NarrowBitWidth = NarrowOp.getScalarValueSizeInBits();\n    if (NarrowBitWidth % 8 != 0)\n      return None;\n    uint64_t NarrowByteWidth = NarrowBitWidth / 8;\n\n    if (Index >= NarrowByteWidth)\n      return Op.getOpcode() == ISD::ZERO_EXTEND\n                 ? Optional<ByteProvider>(ByteProvider::getConstantZero())\n                 : None;\n    return calculateByteProvider(NarrowOp, Index, Depth + 1);\n  }\n  case ISD::BSWAP:\n    return calculateByteProvider(Op->getOperand(0), ByteWidth - Index - 1,\n                                 Depth + 1);\n  case ISD::LOAD: {\n    auto L = cast<LoadSDNode>(Op.getNode());\n    if (!L->isSimple() || L->isIndexed())\n      return None;\n\n    unsigned NarrowBitWidth = L->getMemoryVT().getSizeInBits();\n    if (NarrowBitWidth % 8 != 0)\n      return None;\n    uint64_t NarrowByteWidth = NarrowBitWidth / 8;\n\n    if (Index >= NarrowByteWidth)\n      return L->getExtensionType() == ISD::ZEXTLOAD\n                 ? Optional<ByteProvider>(ByteProvider::getConstantZero())\n                 : None;\n    return ByteProvider::getMemory(L, Index);\n  }\n  }\n\n  return None;\n}\n\nstatic unsigned littleEndianByteAt(unsigned BW, unsigned i) {\n  return i;\n}\n\nstatic unsigned bigEndianByteAt(unsigned BW, unsigned i) {\n  return BW - i - 1;\n}\n\n// Check if the bytes offsets we are looking at match with either big or\n// little endian value loaded. Return true for big endian, false for little\n// endian, and None if match failed.\nstatic Optional<bool> isBigEndian(const ArrayRef<int64_t> ByteOffsets,\n                                  int64_t FirstOffset) {\n  // The endian can be decided only when it is 2 bytes at least.\n  unsigned Width = ByteOffsets.size();\n  if (Width < 2)\n    return None;\n\n  bool BigEndian = true, LittleEndian = true;\n  for (unsigned i = 0; i < Width; i++) {\n    int64_t CurrentByteOffset = ByteOffsets[i] - FirstOffset;\n    LittleEndian &= CurrentByteOffset == littleEndianByteAt(Width, i);\n    BigEndian &= CurrentByteOffset == bigEndianByteAt(Width, i);\n    if (!BigEndian && !LittleEndian)\n      return None;\n  }\n\n  assert((BigEndian != LittleEndian) && \"It should be either big endian or\"\n                                        \"little endian\");\n  return BigEndian;\n}\n\nstatic SDValue stripTruncAndExt(SDValue Value) {\n  switch (Value.getOpcode()) {\n  case ISD::TRUNCATE:\n  case ISD::ZERO_EXTEND:\n  case ISD::SIGN_EXTEND:\n  case ISD::ANY_EXTEND:\n    return stripTruncAndExt(Value.getOperand(0));\n  }\n  return Value;\n}\n\n/// Match a pattern where a wide type scalar value is stored by several narrow\n/// stores. Fold it into a single store or a BSWAP and a store if the targets\n/// supports it.\n///\n/// Assuming little endian target:\n///  i8 *p = ...\n///  i32 val = ...\n///  p[0] = (val >> 0) & 0xFF;\n///  p[1] = (val >> 8) & 0xFF;\n///  p[2] = (val >> 16) & 0xFF;\n///  p[3] = (val >> 24) & 0xFF;\n/// =>\n///  *((i32)p) = val;\n///\n///  i8 *p = ...\n///  i32 val = ...\n///  p[0] = (val >> 24) & 0xFF;\n///  p[1] = (val >> 16) & 0xFF;\n///  p[2] = (val >> 8) & 0xFF;\n///  p[3] = (val >> 0) & 0xFF;\n/// =>\n///  *((i32)p) = BSWAP(val);\nSDValue DAGCombiner::mergeTruncStores(StoreSDNode *N) {\n  // The matching looks for \"store (trunc x)\" patterns that appear early but are\n  // likely to be replaced by truncating store nodes during combining.\n  // TODO: If there is evidence that running this later would help, this\n  //       limitation could be removed. Legality checks may need to be added\n  //       for the created store and optional bswap/rotate.\n  if (LegalOperations)\n    return SDValue();\n\n  // Collect all the stores in the chain.\n  SDValue Chain;\n  SmallVector<StoreSDNode *, 8> Stores;\n  for (StoreSDNode *Store = N; Store; Store = dyn_cast<StoreSDNode>(Chain)) {\n    // TODO: Allow unordered atomics when wider type is legal (see D66309)\n    EVT MemVT = Store->getMemoryVT();\n    if (!(MemVT == MVT::i8 || MemVT == MVT::i16 || MemVT == MVT::i32) ||\n        !Store->isSimple() || Store->isIndexed())\n      return SDValue();\n    Stores.push_back(Store);\n    Chain = Store->getChain();\n  }\n  // There is no reason to continue if we do not have at least a pair of stores.\n  if (Stores.size() < 2)\n    return SDValue();\n\n  // Handle simple types only.\n  LLVMContext &Context = *DAG.getContext();\n  unsigned NumStores = Stores.size();\n  unsigned NarrowNumBits = N->getMemoryVT().getScalarSizeInBits();\n  unsigned WideNumBits = NumStores * NarrowNumBits;\n  EVT WideVT = EVT::getIntegerVT(Context, WideNumBits);\n  if (WideVT != MVT::i16 && WideVT != MVT::i32 && WideVT != MVT::i64)\n    return SDValue();\n\n  // Check if all bytes of the source value that we are looking at are stored\n  // to the same base address. Collect offsets from Base address into OffsetMap.\n  SDValue SourceValue;\n  SmallVector<int64_t, 8> OffsetMap(NumStores, INT64_MAX);\n  int64_t FirstOffset = INT64_MAX;\n  StoreSDNode *FirstStore = nullptr;\n  Optional<BaseIndexOffset> Base;\n  for (auto Store : Stores) {\n    // All the stores store different parts of the CombinedValue. A truncate is\n    // required to get the partial value.\n    SDValue Trunc = Store->getValue();\n    if (Trunc.getOpcode() != ISD::TRUNCATE)\n      return SDValue();\n    // Other than the first/last part, a shift operation is required to get the\n    // offset.\n    int64_t Offset = 0;\n    SDValue WideVal = Trunc.getOperand(0);\n    if ((WideVal.getOpcode() == ISD::SRL || WideVal.getOpcode() == ISD::SRA) &&\n        isa<ConstantSDNode>(WideVal.getOperand(1))) {\n      // The shift amount must be a constant multiple of the narrow type.\n      // It is translated to the offset address in the wide source value \"y\".\n      //\n      // x = srl y, ShiftAmtC\n      // i8 z = trunc x\n      // store z, ...\n      uint64_t ShiftAmtC = WideVal.getConstantOperandVal(1);\n      if (ShiftAmtC % NarrowNumBits != 0)\n        return SDValue();\n\n      Offset = ShiftAmtC / NarrowNumBits;\n      WideVal = WideVal.getOperand(0);\n    }\n\n    // Stores must share the same source value with different offsets.\n    // Truncate and extends should be stripped to get the single source value.\n    if (!SourceValue)\n      SourceValue = WideVal;\n    else if (stripTruncAndExt(SourceValue) != stripTruncAndExt(WideVal))\n      return SDValue();\n    else if (SourceValue.getValueType() != WideVT) {\n      if (WideVal.getValueType() == WideVT ||\n          WideVal.getScalarValueSizeInBits() >\n              SourceValue.getScalarValueSizeInBits())\n        SourceValue = WideVal;\n      // Give up if the source value type is smaller than the store size.\n      if (SourceValue.getScalarValueSizeInBits() < WideVT.getScalarSizeInBits())\n        return SDValue();\n    }\n\n    // Stores must share the same base address.\n    BaseIndexOffset Ptr = BaseIndexOffset::match(Store, DAG);\n    int64_t ByteOffsetFromBase = 0;\n    if (!Base)\n      Base = Ptr;\n    else if (!Base->equalBaseIndex(Ptr, DAG, ByteOffsetFromBase))\n      return SDValue();\n\n    // Remember the first store.\n    if (ByteOffsetFromBase < FirstOffset) {\n      FirstStore = Store;\n      FirstOffset = ByteOffsetFromBase;\n    }\n    // Map the offset in the store and the offset in the combined value, and\n    // early return if it has been set before.\n    if (Offset < 0 || Offset >= NumStores || OffsetMap[Offset] != INT64_MAX)\n      return SDValue();\n    OffsetMap[Offset] = ByteOffsetFromBase;\n  }\n\n  assert(FirstOffset != INT64_MAX && \"First byte offset must be set\");\n  assert(FirstStore && \"First store must be set\");\n\n  // Check that a store of the wide type is both allowed and fast on the target\n  const DataLayout &Layout = DAG.getDataLayout();\n  bool Fast = false;\n  bool Allowed = TLI.allowsMemoryAccess(Context, Layout, WideVT,\n                                        *FirstStore->getMemOperand(), &Fast);\n  if (!Allowed || !Fast)\n    return SDValue();\n\n  // Check if the pieces of the value are going to the expected places in memory\n  // to merge the stores.\n  auto checkOffsets = [&](bool MatchLittleEndian) {\n    if (MatchLittleEndian) {\n      for (unsigned i = 0; i != NumStores; ++i)\n        if (OffsetMap[i] != i * (NarrowNumBits / 8) + FirstOffset)\n          return false;\n    } else { // MatchBigEndian by reversing loop counter.\n      for (unsigned i = 0, j = NumStores - 1; i != NumStores; ++i, --j)\n        if (OffsetMap[j] != i * (NarrowNumBits / 8) + FirstOffset)\n          return false;\n    }\n    return true;\n  };\n\n  // Check if the offsets line up for the native data layout of this target.\n  bool NeedBswap = false;\n  bool NeedRotate = false;\n  if (!checkOffsets(Layout.isLittleEndian())) {\n    // Special-case: check if byte offsets line up for the opposite endian.\n    if (NarrowNumBits == 8 && checkOffsets(Layout.isBigEndian()))\n      NeedBswap = true;\n    else if (NumStores == 2 && checkOffsets(Layout.isBigEndian()))\n      NeedRotate = true;\n    else\n      return SDValue();\n  }\n\n  SDLoc DL(N);\n  if (WideVT != SourceValue.getValueType()) {\n    assert(SourceValue.getValueType().getScalarSizeInBits() > WideNumBits &&\n           \"Unexpected store value to merge\");\n    SourceValue = DAG.getNode(ISD::TRUNCATE, DL, WideVT, SourceValue);\n  }\n\n  // Before legalize we can introduce illegal bswaps/rotates which will be later\n  // converted to an explicit bswap sequence. This way we end up with a single\n  // store and byte shuffling instead of several stores and byte shuffling.\n  if (NeedBswap) {\n    SourceValue = DAG.getNode(ISD::BSWAP, DL, WideVT, SourceValue);\n  } else if (NeedRotate) {\n    assert(WideNumBits % 2 == 0 && \"Unexpected type for rotate\");\n    SDValue RotAmt = DAG.getConstant(WideNumBits / 2, DL, WideVT);\n    SourceValue = DAG.getNode(ISD::ROTR, DL, WideVT, SourceValue, RotAmt);\n  }\n\n  SDValue NewStore =\n      DAG.getStore(Chain, DL, SourceValue, FirstStore->getBasePtr(),\n                   FirstStore->getPointerInfo(), FirstStore->getAlign());\n\n  // Rely on other DAG combine rules to remove the other individual stores.\n  DAG.ReplaceAllUsesWith(N, NewStore.getNode());\n  return NewStore;\n}\n\n/// Match a pattern where a wide type scalar value is loaded by several narrow\n/// loads and combined by shifts and ors. Fold it into a single load or a load\n/// and a BSWAP if the targets supports it.\n///\n/// Assuming little endian target:\n///  i8 *a = ...\n///  i32 val = a[0] | (a[1] << 8) | (a[2] << 16) | (a[3] << 24)\n/// =>\n///  i32 val = *((i32)a)\n///\n///  i8 *a = ...\n///  i32 val = (a[0] << 24) | (a[1] << 16) | (a[2] << 8) | a[3]\n/// =>\n///  i32 val = BSWAP(*((i32)a))\n///\n/// TODO: This rule matches complex patterns with OR node roots and doesn't\n/// interact well with the worklist mechanism. When a part of the pattern is\n/// updated (e.g. one of the loads) its direct users are put into the worklist,\n/// but the root node of the pattern which triggers the load combine is not\n/// necessarily a direct user of the changed node. For example, once the address\n/// of t28 load is reassociated load combine won't be triggered:\n///             t25: i32 = add t4, Constant:i32<2>\n///           t26: i64 = sign_extend t25\n///        t27: i64 = add t2, t26\n///       t28: i8,ch = load<LD1[%tmp9]> t0, t27, undef:i64\n///     t29: i32 = zero_extend t28\n///   t32: i32 = shl t29, Constant:i8<8>\n/// t33: i32 = or t23, t32\n/// As a possible fix visitLoad can check if the load can be a part of a load\n/// combine pattern and add corresponding OR roots to the worklist.\nSDValue DAGCombiner::MatchLoadCombine(SDNode *N) {\n  assert(N->getOpcode() == ISD::OR &&\n         \"Can only match load combining against OR nodes\");\n\n  // Handles simple types only\n  EVT VT = N->getValueType(0);\n  if (VT != MVT::i16 && VT != MVT::i32 && VT != MVT::i64)\n    return SDValue();\n  unsigned ByteWidth = VT.getSizeInBits() / 8;\n\n  bool IsBigEndianTarget = DAG.getDataLayout().isBigEndian();\n  auto MemoryByteOffset = [&] (ByteProvider P) {\n    assert(P.isMemory() && \"Must be a memory byte provider\");\n    unsigned LoadBitWidth = P.Load->getMemoryVT().getSizeInBits();\n    assert(LoadBitWidth % 8 == 0 &&\n           \"can only analyze providers for individual bytes not bit\");\n    unsigned LoadByteWidth = LoadBitWidth / 8;\n    return IsBigEndianTarget\n            ? bigEndianByteAt(LoadByteWidth, P.ByteOffset)\n            : littleEndianByteAt(LoadByteWidth, P.ByteOffset);\n  };\n\n  Optional<BaseIndexOffset> Base;\n  SDValue Chain;\n\n  SmallPtrSet<LoadSDNode *, 8> Loads;\n  Optional<ByteProvider> FirstByteProvider;\n  int64_t FirstOffset = INT64_MAX;\n\n  // Check if all the bytes of the OR we are looking at are loaded from the same\n  // base address. Collect bytes offsets from Base address in ByteOffsets.\n  SmallVector<int64_t, 8> ByteOffsets(ByteWidth);\n  unsigned ZeroExtendedBytes = 0;\n  for (int i = ByteWidth - 1; i >= 0; --i) {\n    auto P = calculateByteProvider(SDValue(N, 0), i, 0, /*Root=*/true);\n    if (!P)\n      return SDValue();\n\n    if (P->isConstantZero()) {\n      // It's OK for the N most significant bytes to be 0, we can just\n      // zero-extend the load.\n      if (++ZeroExtendedBytes != (ByteWidth - static_cast<unsigned>(i)))\n        return SDValue();\n      continue;\n    }\n    assert(P->isMemory() && \"provenance should either be memory or zero\");\n\n    LoadSDNode *L = P->Load;\n    assert(L->hasNUsesOfValue(1, 0) && L->isSimple() &&\n           !L->isIndexed() &&\n           \"Must be enforced by calculateByteProvider\");\n    assert(L->getOffset().isUndef() && \"Unindexed load must have undef offset\");\n\n    // All loads must share the same chain\n    SDValue LChain = L->getChain();\n    if (!Chain)\n      Chain = LChain;\n    else if (Chain != LChain)\n      return SDValue();\n\n    // Loads must share the same base address\n    BaseIndexOffset Ptr = BaseIndexOffset::match(L, DAG);\n    int64_t ByteOffsetFromBase = 0;\n    if (!Base)\n      Base = Ptr;\n    else if (!Base->equalBaseIndex(Ptr, DAG, ByteOffsetFromBase))\n      return SDValue();\n\n    // Calculate the offset of the current byte from the base address\n    ByteOffsetFromBase += MemoryByteOffset(*P);\n    ByteOffsets[i] = ByteOffsetFromBase;\n\n    // Remember the first byte load\n    if (ByteOffsetFromBase < FirstOffset) {\n      FirstByteProvider = P;\n      FirstOffset = ByteOffsetFromBase;\n    }\n\n    Loads.insert(L);\n  }\n  assert(!Loads.empty() && \"All the bytes of the value must be loaded from \"\n         \"memory, so there must be at least one load which produces the value\");\n  assert(Base && \"Base address of the accessed memory location must be set\");\n  assert(FirstOffset != INT64_MAX && \"First byte offset must be set\");\n\n  bool NeedsZext = ZeroExtendedBytes > 0;\n\n  EVT MemVT =\n      EVT::getIntegerVT(*DAG.getContext(), (ByteWidth - ZeroExtendedBytes) * 8);\n\n  if (!MemVT.isSimple())\n    return SDValue();\n\n  // Before legalize we can introduce too wide illegal loads which will be later\n  // split into legal sized loads. This enables us to combine i64 load by i8\n  // patterns to a couple of i32 loads on 32 bit targets.\n  if (LegalOperations &&\n      !TLI.isOperationLegal(NeedsZext ? ISD::ZEXTLOAD : ISD::NON_EXTLOAD,\n                            MemVT))\n    return SDValue();\n\n  // Check if the bytes of the OR we are looking at match with either big or\n  // little endian value load\n  Optional<bool> IsBigEndian = isBigEndian(\n      makeArrayRef(ByteOffsets).drop_back(ZeroExtendedBytes), FirstOffset);\n  if (!IsBigEndian.hasValue())\n    return SDValue();\n\n  assert(FirstByteProvider && \"must be set\");\n\n  // Ensure that the first byte is loaded from zero offset of the first load.\n  // So the combined value can be loaded from the first load address.\n  if (MemoryByteOffset(*FirstByteProvider) != 0)\n    return SDValue();\n  LoadSDNode *FirstLoad = FirstByteProvider->Load;\n\n  // The node we are looking at matches with the pattern, check if we can\n  // replace it with a single (possibly zero-extended) load and bswap + shift if\n  // needed.\n\n  // If the load needs byte swap check if the target supports it\n  bool NeedsBswap = IsBigEndianTarget != *IsBigEndian;\n\n  // Before legalize we can introduce illegal bswaps which will be later\n  // converted to an explicit bswap sequence. This way we end up with a single\n  // load and byte shuffling instead of several loads and byte shuffling.\n  // We do not introduce illegal bswaps when zero-extending as this tends to\n  // introduce too many arithmetic instructions.\n  if (NeedsBswap && (LegalOperations || NeedsZext) &&\n      !TLI.isOperationLegal(ISD::BSWAP, VT))\n    return SDValue();\n\n  // If we need to bswap and zero extend, we have to insert a shift. Check that\n  // it is legal.\n  if (NeedsBswap && NeedsZext && LegalOperations &&\n      !TLI.isOperationLegal(ISD::SHL, VT))\n    return SDValue();\n\n  // Check that a load of the wide type is both allowed and fast on the target\n  bool Fast = false;\n  bool Allowed =\n      TLI.allowsMemoryAccess(*DAG.getContext(), DAG.getDataLayout(), MemVT,\n                             *FirstLoad->getMemOperand(), &Fast);\n  if (!Allowed || !Fast)\n    return SDValue();\n\n  SDValue NewLoad =\n      DAG.getExtLoad(NeedsZext ? ISD::ZEXTLOAD : ISD::NON_EXTLOAD, SDLoc(N), VT,\n                     Chain, FirstLoad->getBasePtr(),\n                     FirstLoad->getPointerInfo(), MemVT, FirstLoad->getAlign());\n\n  // Transfer chain users from old loads to the new load.\n  for (LoadSDNode *L : Loads)\n    DAG.ReplaceAllUsesOfValueWith(SDValue(L, 1), SDValue(NewLoad.getNode(), 1));\n\n  if (!NeedsBswap)\n    return NewLoad;\n\n  SDValue ShiftedLoad =\n      NeedsZext\n          ? DAG.getNode(ISD::SHL, SDLoc(N), VT, NewLoad,\n                        DAG.getShiftAmountConstant(ZeroExtendedBytes * 8, VT,\n                                                   SDLoc(N), LegalOperations))\n          : NewLoad;\n  return DAG.getNode(ISD::BSWAP, SDLoc(N), VT, ShiftedLoad);\n}\n\n// If the target has andn, bsl, or a similar bit-select instruction,\n// we want to unfold masked merge, with canonical pattern of:\n//   |        A  |  |B|\n//   ((x ^ y) & m) ^ y\n//    |  D  |\n// Into:\n//   (x & m) | (y & ~m)\n// If y is a constant, and the 'andn' does not work with immediates,\n// we unfold into a different pattern:\n//   ~(~x & m) & (m | y)\n// NOTE: we don't unfold the pattern if 'xor' is actually a 'not', because at\n//       the very least that breaks andnpd / andnps patterns, and because those\n//       patterns are simplified in IR and shouldn't be created in the DAG\nSDValue DAGCombiner::unfoldMaskedMerge(SDNode *N) {\n  assert(N->getOpcode() == ISD::XOR);\n\n  // Don't touch 'not' (i.e. where y = -1).\n  if (isAllOnesOrAllOnesSplat(N->getOperand(1)))\n    return SDValue();\n\n  EVT VT = N->getValueType(0);\n\n  // There are 3 commutable operators in the pattern,\n  // so we have to deal with 8 possible variants of the basic pattern.\n  SDValue X, Y, M;\n  auto matchAndXor = [&X, &Y, &M](SDValue And, unsigned XorIdx, SDValue Other) {\n    if (And.getOpcode() != ISD::AND || !And.hasOneUse())\n      return false;\n    SDValue Xor = And.getOperand(XorIdx);\n    if (Xor.getOpcode() != ISD::XOR || !Xor.hasOneUse())\n      return false;\n    SDValue Xor0 = Xor.getOperand(0);\n    SDValue Xor1 = Xor.getOperand(1);\n    // Don't touch 'not' (i.e. where y = -1).\n    if (isAllOnesOrAllOnesSplat(Xor1))\n      return false;\n    if (Other == Xor0)\n      std::swap(Xor0, Xor1);\n    if (Other != Xor1)\n      return false;\n    X = Xor0;\n    Y = Xor1;\n    M = And.getOperand(XorIdx ? 0 : 1);\n    return true;\n  };\n\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  if (!matchAndXor(N0, 0, N1) && !matchAndXor(N0, 1, N1) &&\n      !matchAndXor(N1, 0, N0) && !matchAndXor(N1, 1, N0))\n    return SDValue();\n\n  // Don't do anything if the mask is constant. This should not be reachable.\n  // InstCombine should have already unfolded this pattern, and DAGCombiner\n  // probably shouldn't produce it, too.\n  if (isa<ConstantSDNode>(M.getNode()))\n    return SDValue();\n\n  // We can transform if the target has AndNot\n  if (!TLI.hasAndNot(M))\n    return SDValue();\n\n  SDLoc DL(N);\n\n  // If Y is a constant, check that 'andn' works with immediates.\n  if (!TLI.hasAndNot(Y)) {\n    assert(TLI.hasAndNot(X) && \"Only mask is a variable? Unreachable.\");\n    // If not, we need to do a bit more work to make sure andn is still used.\n    SDValue NotX = DAG.getNOT(DL, X, VT);\n    SDValue LHS = DAG.getNode(ISD::AND, DL, VT, NotX, M);\n    SDValue NotLHS = DAG.getNOT(DL, LHS, VT);\n    SDValue RHS = DAG.getNode(ISD::OR, DL, VT, M, Y);\n    return DAG.getNode(ISD::AND, DL, VT, NotLHS, RHS);\n  }\n\n  SDValue LHS = DAG.getNode(ISD::AND, DL, VT, X, M);\n  SDValue NotM = DAG.getNOT(DL, M, VT);\n  SDValue RHS = DAG.getNode(ISD::AND, DL, VT, Y, NotM);\n\n  return DAG.getNode(ISD::OR, DL, VT, LHS, RHS);\n}\n\nSDValue DAGCombiner::visitXOR(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  EVT VT = N0.getValueType();\n\n  // fold vector ops\n  if (VT.isVector()) {\n    if (SDValue FoldedVOp = SimplifyVBinOp(N))\n      return FoldedVOp;\n\n    // fold (xor x, 0) -> x, vector edition\n    if (ISD::isBuildVectorAllZeros(N0.getNode()))\n      return N1;\n    if (ISD::isBuildVectorAllZeros(N1.getNode()))\n      return N0;\n  }\n\n  // fold (xor undef, undef) -> 0. This is a common idiom (misuse).\n  SDLoc DL(N);\n  if (N0.isUndef() && N1.isUndef())\n    return DAG.getConstant(0, DL, VT);\n\n  // fold (xor x, undef) -> undef\n  if (N0.isUndef())\n    return N0;\n  if (N1.isUndef())\n    return N1;\n\n  // fold (xor c1, c2) -> c1^c2\n  if (SDValue C = DAG.FoldConstantArithmetic(ISD::XOR, DL, VT, {N0, N1}))\n    return C;\n\n  // canonicalize constant to RHS\n  if (DAG.isConstantIntBuildVectorOrConstantInt(N0) &&\n     !DAG.isConstantIntBuildVectorOrConstantInt(N1))\n    return DAG.getNode(ISD::XOR, DL, VT, N1, N0);\n\n  // fold (xor x, 0) -> x\n  if (isNullConstant(N1))\n    return N0;\n\n  if (SDValue NewSel = foldBinOpIntoSelect(N))\n    return NewSel;\n\n  // reassociate xor\n  if (SDValue RXOR = reassociateOps(ISD::XOR, DL, N0, N1, N->getFlags()))\n    return RXOR;\n\n  // fold !(x cc y) -> (x !cc y)\n  unsigned N0Opcode = N0.getOpcode();\n  SDValue LHS, RHS, CC;\n  if (TLI.isConstTrueVal(N1.getNode()) &&\n      isSetCCEquivalent(N0, LHS, RHS, CC, /*MatchStrict*/true)) {\n    ISD::CondCode NotCC = ISD::getSetCCInverse(cast<CondCodeSDNode>(CC)->get(),\n                                               LHS.getValueType());\n    if (!LegalOperations ||\n        TLI.isCondCodeLegal(NotCC, LHS.getSimpleValueType())) {\n      switch (N0Opcode) {\n      default:\n        llvm_unreachable(\"Unhandled SetCC Equivalent!\");\n      case ISD::SETCC:\n        return DAG.getSetCC(SDLoc(N0), VT, LHS, RHS, NotCC);\n      case ISD::SELECT_CC:\n        return DAG.getSelectCC(SDLoc(N0), LHS, RHS, N0.getOperand(2),\n                               N0.getOperand(3), NotCC);\n      case ISD::STRICT_FSETCC:\n      case ISD::STRICT_FSETCCS: {\n        if (N0.hasOneUse()) {\n          // FIXME Can we handle multiple uses? Could we token factor the chain\n          // results from the new/old setcc?\n          SDValue SetCC =\n              DAG.getSetCC(SDLoc(N0), VT, LHS, RHS, NotCC,\n                           N0.getOperand(0), N0Opcode == ISD::STRICT_FSETCCS);\n          CombineTo(N, SetCC);\n          DAG.ReplaceAllUsesOfValueWith(N0.getValue(1), SetCC.getValue(1));\n          recursivelyDeleteUnusedNodes(N0.getNode());\n          return SDValue(N, 0); // Return N so it doesn't get rechecked!\n        }\n        break;\n      }\n      }\n    }\n  }\n\n  // fold (not (zext (setcc x, y))) -> (zext (not (setcc x, y)))\n  if (isOneConstant(N1) && N0Opcode == ISD::ZERO_EXTEND && N0.hasOneUse() &&\n      isSetCCEquivalent(N0.getOperand(0), LHS, RHS, CC)){\n    SDValue V = N0.getOperand(0);\n    SDLoc DL0(N0);\n    V = DAG.getNode(ISD::XOR, DL0, V.getValueType(), V,\n                    DAG.getConstant(1, DL0, V.getValueType()));\n    AddToWorklist(V.getNode());\n    return DAG.getNode(ISD::ZERO_EXTEND, DL, VT, V);\n  }\n\n  // fold (not (or x, y)) -> (and (not x), (not y)) iff x or y are setcc\n  if (isOneConstant(N1) && VT == MVT::i1 && N0.hasOneUse() &&\n      (N0Opcode == ISD::OR || N0Opcode == ISD::AND)) {\n    SDValue N00 = N0.getOperand(0), N01 = N0.getOperand(1);\n    if (isOneUseSetCC(N01) || isOneUseSetCC(N00)) {\n      unsigned NewOpcode = N0Opcode == ISD::AND ? ISD::OR : ISD::AND;\n      N00 = DAG.getNode(ISD::XOR, SDLoc(N00), VT, N00, N1); // N00 = ~N00\n      N01 = DAG.getNode(ISD::XOR, SDLoc(N01), VT, N01, N1); // N01 = ~N01\n      AddToWorklist(N00.getNode()); AddToWorklist(N01.getNode());\n      return DAG.getNode(NewOpcode, DL, VT, N00, N01);\n    }\n  }\n  // fold (not (or x, y)) -> (and (not x), (not y)) iff x or y are constants\n  if (isAllOnesConstant(N1) && N0.hasOneUse() &&\n      (N0Opcode == ISD::OR || N0Opcode == ISD::AND)) {\n    SDValue N00 = N0.getOperand(0), N01 = N0.getOperand(1);\n    if (isa<ConstantSDNode>(N01) || isa<ConstantSDNode>(N00)) {\n      unsigned NewOpcode = N0Opcode == ISD::AND ? ISD::OR : ISD::AND;\n      N00 = DAG.getNode(ISD::XOR, SDLoc(N00), VT, N00, N1); // N00 = ~N00\n      N01 = DAG.getNode(ISD::XOR, SDLoc(N01), VT, N01, N1); // N01 = ~N01\n      AddToWorklist(N00.getNode()); AddToWorklist(N01.getNode());\n      return DAG.getNode(NewOpcode, DL, VT, N00, N01);\n    }\n  }\n\n  // fold (not (neg x)) -> (add X, -1)\n  // FIXME: This can be generalized to (not (sub Y, X)) -> (add X, ~Y) if\n  // Y is a constant or the subtract has a single use.\n  if (isAllOnesConstant(N1) && N0.getOpcode() == ISD::SUB &&\n      isNullConstant(N0.getOperand(0))) {\n    return DAG.getNode(ISD::ADD, DL, VT, N0.getOperand(1),\n                       DAG.getAllOnesConstant(DL, VT));\n  }\n\n  // fold (not (add X, -1)) -> (neg X)\n  if (isAllOnesConstant(N1) && N0.getOpcode() == ISD::ADD &&\n      isAllOnesOrAllOnesSplat(N0.getOperand(1))) {\n    return DAG.getNode(ISD::SUB, DL, VT, DAG.getConstant(0, DL, VT),\n                       N0.getOperand(0));\n  }\n\n  // fold (xor (and x, y), y) -> (and (not x), y)\n  if (N0Opcode == ISD::AND && N0.hasOneUse() && N0->getOperand(1) == N1) {\n    SDValue X = N0.getOperand(0);\n    SDValue NotX = DAG.getNOT(SDLoc(X), X, VT);\n    AddToWorklist(NotX.getNode());\n    return DAG.getNode(ISD::AND, DL, VT, NotX, N1);\n  }\n\n  if ((N0Opcode == ISD::SRL || N0Opcode == ISD::SHL) && N0.hasOneUse()) {\n    ConstantSDNode *XorC = isConstOrConstSplat(N1);\n    ConstantSDNode *ShiftC = isConstOrConstSplat(N0.getOperand(1));\n    unsigned BitWidth = VT.getScalarSizeInBits();\n    if (XorC && ShiftC) {\n      // Don't crash on an oversized shift. We can not guarantee that a bogus\n      // shift has been simplified to undef.\n      uint64_t ShiftAmt = ShiftC->getLimitedValue();\n      if (ShiftAmt < BitWidth) {\n        APInt Ones = APInt::getAllOnesValue(BitWidth);\n        Ones = N0Opcode == ISD::SHL ? Ones.shl(ShiftAmt) : Ones.lshr(ShiftAmt);\n        if (XorC->getAPIntValue() == Ones) {\n          // If the xor constant is a shifted -1, do a 'not' before the shift:\n          // xor (X << ShiftC), XorC --> (not X) << ShiftC\n          // xor (X >> ShiftC), XorC --> (not X) >> ShiftC\n          SDValue Not = DAG.getNOT(DL, N0.getOperand(0), VT);\n          return DAG.getNode(N0Opcode, DL, VT, Not, N0.getOperand(1));\n        }\n      }\n    }\n  }\n\n  // fold Y = sra (X, size(X)-1); xor (add (X, Y), Y) -> (abs X)\n  if (TLI.isOperationLegalOrCustom(ISD::ABS, VT)) {\n    SDValue A = N0Opcode == ISD::ADD ? N0 : N1;\n    SDValue S = N0Opcode == ISD::SRA ? N0 : N1;\n    if (A.getOpcode() == ISD::ADD && S.getOpcode() == ISD::SRA) {\n      SDValue A0 = A.getOperand(0), A1 = A.getOperand(1);\n      SDValue S0 = S.getOperand(0);\n      if ((A0 == S && A1 == S0) || (A1 == S && A0 == S0))\n        if (ConstantSDNode *C = isConstOrConstSplat(S.getOperand(1)))\n          if (C->getAPIntValue() == (VT.getScalarSizeInBits() - 1))\n            return DAG.getNode(ISD::ABS, DL, VT, S0);\n    }\n  }\n\n  // fold (xor x, x) -> 0\n  if (N0 == N1)\n    return tryFoldToZero(DL, TLI, VT, DAG, LegalOperations);\n\n  // fold (xor (shl 1, x), -1) -> (rotl ~1, x)\n  // Here is a concrete example of this equivalence:\n  // i16   x ==  14\n  // i16 shl ==   1 << 14  == 16384 == 0b0100000000000000\n  // i16 xor == ~(1 << 14) == 49151 == 0b1011111111111111\n  //\n  // =>\n  //\n  // i16     ~1      == 0b1111111111111110\n  // i16 rol(~1, 14) == 0b1011111111111111\n  //\n  // Some additional tips to help conceptualize this transform:\n  // - Try to see the operation as placing a single zero in a value of all ones.\n  // - There exists no value for x which would allow the result to contain zero.\n  // - Values of x larger than the bitwidth are undefined and do not require a\n  //   consistent result.\n  // - Pushing the zero left requires shifting one bits in from the right.\n  // A rotate left of ~1 is a nice way of achieving the desired result.\n  if (TLI.isOperationLegalOrCustom(ISD::ROTL, VT) && N0Opcode == ISD::SHL &&\n      isAllOnesConstant(N1) && isOneConstant(N0.getOperand(0))) {\n    return DAG.getNode(ISD::ROTL, DL, VT, DAG.getConstant(~1, DL, VT),\n                       N0.getOperand(1));\n  }\n\n  // Simplify: xor (op x...), (op y...)  -> (op (xor x, y))\n  if (N0Opcode == N1.getOpcode())\n    if (SDValue V = hoistLogicOpWithSameOpcodeHands(N))\n      return V;\n\n  // Unfold  ((x ^ y) & m) ^ y  into  (x & m) | (y & ~m)  if profitable\n  if (SDValue MM = unfoldMaskedMerge(N))\n    return MM;\n\n  // Simplify the expression using non-local knowledge.\n  if (SimplifyDemandedBits(SDValue(N, 0)))\n    return SDValue(N, 0);\n\n  if (SDValue Combined = combineCarryDiamond(*this, DAG, TLI, N0, N1, N))\n    return Combined;\n\n  return SDValue();\n}\n\n/// If we have a shift-by-constant of a bitwise logic op that itself has a\n/// shift-by-constant operand with identical opcode, we may be able to convert\n/// that into 2 independent shifts followed by the logic op. This is a\n/// throughput improvement.\nstatic SDValue combineShiftOfShiftedLogic(SDNode *Shift, SelectionDAG &DAG) {\n  // Match a one-use bitwise logic op.\n  SDValue LogicOp = Shift->getOperand(0);\n  if (!LogicOp.hasOneUse())\n    return SDValue();\n\n  unsigned LogicOpcode = LogicOp.getOpcode();\n  if (LogicOpcode != ISD::AND && LogicOpcode != ISD::OR &&\n      LogicOpcode != ISD::XOR)\n    return SDValue();\n\n  // Find a matching one-use shift by constant.\n  unsigned ShiftOpcode = Shift->getOpcode();\n  SDValue C1 = Shift->getOperand(1);\n  ConstantSDNode *C1Node = isConstOrConstSplat(C1);\n  assert(C1Node && \"Expected a shift with constant operand\");\n  const APInt &C1Val = C1Node->getAPIntValue();\n  auto matchFirstShift = [&](SDValue V, SDValue &ShiftOp,\n                             const APInt *&ShiftAmtVal) {\n    if (V.getOpcode() != ShiftOpcode || !V.hasOneUse())\n      return false;\n\n    ConstantSDNode *ShiftCNode = isConstOrConstSplat(V.getOperand(1));\n    if (!ShiftCNode)\n      return false;\n\n    // Capture the shifted operand and shift amount value.\n    ShiftOp = V.getOperand(0);\n    ShiftAmtVal = &ShiftCNode->getAPIntValue();\n\n    // Shift amount types do not have to match their operand type, so check that\n    // the constants are the same width.\n    if (ShiftAmtVal->getBitWidth() != C1Val.getBitWidth())\n      return false;\n\n    // The fold is not valid if the sum of the shift values exceeds bitwidth.\n    if ((*ShiftAmtVal + C1Val).uge(V.getScalarValueSizeInBits()))\n      return false;\n\n    return true;\n  };\n\n  // Logic ops are commutative, so check each operand for a match.\n  SDValue X, Y;\n  const APInt *C0Val;\n  if (matchFirstShift(LogicOp.getOperand(0), X, C0Val))\n    Y = LogicOp.getOperand(1);\n  else if (matchFirstShift(LogicOp.getOperand(1), X, C0Val))\n    Y = LogicOp.getOperand(0);\n  else\n    return SDValue();\n\n  // shift (logic (shift X, C0), Y), C1 -> logic (shift X, C0+C1), (shift Y, C1)\n  SDLoc DL(Shift);\n  EVT VT = Shift->getValueType(0);\n  EVT ShiftAmtVT = Shift->getOperand(1).getValueType();\n  SDValue ShiftSumC = DAG.getConstant(*C0Val + C1Val, DL, ShiftAmtVT);\n  SDValue NewShift1 = DAG.getNode(ShiftOpcode, DL, VT, X, ShiftSumC);\n  SDValue NewShift2 = DAG.getNode(ShiftOpcode, DL, VT, Y, C1);\n  return DAG.getNode(LogicOpcode, DL, VT, NewShift1, NewShift2);\n}\n\n/// Handle transforms common to the three shifts, when the shift amount is a\n/// constant.\n/// We are looking for: (shift being one of shl/sra/srl)\n///   shift (binop X, C0), C1\n/// And want to transform into:\n///   binop (shift X, C1), (shift C0, C1)\nSDValue DAGCombiner::visitShiftByConstant(SDNode *N) {\n  assert(isConstOrConstSplat(N->getOperand(1)) && \"Expected constant operand\");\n\n  // Do not turn a 'not' into a regular xor.\n  if (isBitwiseNot(N->getOperand(0)))\n    return SDValue();\n\n  // The inner binop must be one-use, since we want to replace it.\n  SDValue LHS = N->getOperand(0);\n  if (!LHS.hasOneUse() || !TLI.isDesirableToCommuteWithShift(N, Level))\n    return SDValue();\n\n  // TODO: This is limited to early combining because it may reveal regressions\n  //       otherwise. But since we just checked a target hook to see if this is\n  //       desirable, that should have filtered out cases where this interferes\n  //       with some other pattern matching.\n  if (!LegalTypes)\n    if (SDValue R = combineShiftOfShiftedLogic(N, DAG))\n      return R;\n\n  // We want to pull some binops through shifts, so that we have (and (shift))\n  // instead of (shift (and)), likewise for add, or, xor, etc.  This sort of\n  // thing happens with address calculations, so it's important to canonicalize\n  // it.\n  switch (LHS.getOpcode()) {\n  default:\n    return SDValue();\n  case ISD::OR:\n  case ISD::XOR:\n  case ISD::AND:\n    break;\n  case ISD::ADD:\n    if (N->getOpcode() != ISD::SHL)\n      return SDValue(); // only shl(add) not sr[al](add).\n    break;\n  }\n\n  // We require the RHS of the binop to be a constant and not opaque as well.\n  ConstantSDNode *BinOpCst = getAsNonOpaqueConstant(LHS.getOperand(1));\n  if (!BinOpCst)\n    return SDValue();\n\n  // FIXME: disable this unless the input to the binop is a shift by a constant\n  // or is copy/select. Enable this in other cases when figure out it's exactly\n  // profitable.\n  SDValue BinOpLHSVal = LHS.getOperand(0);\n  bool IsShiftByConstant = (BinOpLHSVal.getOpcode() == ISD::SHL ||\n                            BinOpLHSVal.getOpcode() == ISD::SRA ||\n                            BinOpLHSVal.getOpcode() == ISD::SRL) &&\n                           isa<ConstantSDNode>(BinOpLHSVal.getOperand(1));\n  bool IsCopyOrSelect = BinOpLHSVal.getOpcode() == ISD::CopyFromReg ||\n                        BinOpLHSVal.getOpcode() == ISD::SELECT;\n\n  if (!IsShiftByConstant && !IsCopyOrSelect)\n    return SDValue();\n\n  if (IsCopyOrSelect && N->hasOneUse())\n    return SDValue();\n\n  // Fold the constants, shifting the binop RHS by the shift amount.\n  SDLoc DL(N);\n  EVT VT = N->getValueType(0);\n  SDValue NewRHS = DAG.getNode(N->getOpcode(), DL, VT, LHS.getOperand(1),\n                               N->getOperand(1));\n  assert(isa<ConstantSDNode>(NewRHS) && \"Folding was not successful!\");\n\n  SDValue NewShift = DAG.getNode(N->getOpcode(), DL, VT, LHS.getOperand(0),\n                                 N->getOperand(1));\n  return DAG.getNode(LHS.getOpcode(), DL, VT, NewShift, NewRHS);\n}\n\nSDValue DAGCombiner::distributeTruncateThroughAnd(SDNode *N) {\n  assert(N->getOpcode() == ISD::TRUNCATE);\n  assert(N->getOperand(0).getOpcode() == ISD::AND);\n\n  // (truncate:TruncVT (and N00, N01C)) -> (and (truncate:TruncVT N00), TruncC)\n  EVT TruncVT = N->getValueType(0);\n  if (N->hasOneUse() && N->getOperand(0).hasOneUse() &&\n      TLI.isTypeDesirableForOp(ISD::AND, TruncVT)) {\n    SDValue N01 = N->getOperand(0).getOperand(1);\n    if (isConstantOrConstantVector(N01, /* NoOpaques */ true)) {\n      SDLoc DL(N);\n      SDValue N00 = N->getOperand(0).getOperand(0);\n      SDValue Trunc00 = DAG.getNode(ISD::TRUNCATE, DL, TruncVT, N00);\n      SDValue Trunc01 = DAG.getNode(ISD::TRUNCATE, DL, TruncVT, N01);\n      AddToWorklist(Trunc00.getNode());\n      AddToWorklist(Trunc01.getNode());\n      return DAG.getNode(ISD::AND, DL, TruncVT, Trunc00, Trunc01);\n    }\n  }\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitRotate(SDNode *N) {\n  SDLoc dl(N);\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  EVT VT = N->getValueType(0);\n  unsigned Bitsize = VT.getScalarSizeInBits();\n\n  // fold (rot x, 0) -> x\n  if (isNullOrNullSplat(N1))\n    return N0;\n\n  // fold (rot x, c) -> x iff (c % BitSize) == 0\n  if (isPowerOf2_32(Bitsize) && Bitsize > 1) {\n    APInt ModuloMask(N1.getScalarValueSizeInBits(), Bitsize - 1);\n    if (DAG.MaskedValueIsZero(N1, ModuloMask))\n      return N0;\n  }\n\n  // fold (rot x, c) -> (rot x, c % BitSize)\n  bool OutOfRange = false;\n  auto MatchOutOfRange = [Bitsize, &OutOfRange](ConstantSDNode *C) {\n    OutOfRange |= C->getAPIntValue().uge(Bitsize);\n    return true;\n  };\n  if (ISD::matchUnaryPredicate(N1, MatchOutOfRange) && OutOfRange) {\n    EVT AmtVT = N1.getValueType();\n    SDValue Bits = DAG.getConstant(Bitsize, dl, AmtVT);\n    if (SDValue Amt =\n            DAG.FoldConstantArithmetic(ISD::UREM, dl, AmtVT, {N1, Bits}))\n      return DAG.getNode(N->getOpcode(), dl, VT, N0, Amt);\n  }\n\n  // rot i16 X, 8 --> bswap X\n  auto *RotAmtC = isConstOrConstSplat(N1);\n  if (RotAmtC && RotAmtC->getAPIntValue() == 8 &&\n      VT.getScalarSizeInBits() == 16 && hasOperation(ISD::BSWAP, VT))\n    return DAG.getNode(ISD::BSWAP, dl, VT, N0);\n\n  // Simplify the operands using demanded-bits information.\n  if (SimplifyDemandedBits(SDValue(N, 0)))\n    return SDValue(N, 0);\n\n  // fold (rot* x, (trunc (and y, c))) -> (rot* x, (and (trunc y), (trunc c))).\n  if (N1.getOpcode() == ISD::TRUNCATE &&\n      N1.getOperand(0).getOpcode() == ISD::AND) {\n    if (SDValue NewOp1 = distributeTruncateThroughAnd(N1.getNode()))\n      return DAG.getNode(N->getOpcode(), dl, VT, N0, NewOp1);\n  }\n\n  unsigned NextOp = N0.getOpcode();\n  // fold (rot* (rot* x, c2), c1) -> (rot* x, c1 +- c2 % bitsize)\n  if (NextOp == ISD::ROTL || NextOp == ISD::ROTR) {\n    SDNode *C1 = DAG.isConstantIntBuildVectorOrConstantInt(N1);\n    SDNode *C2 = DAG.isConstantIntBuildVectorOrConstantInt(N0.getOperand(1));\n    if (C1 && C2 && C1->getValueType(0) == C2->getValueType(0)) {\n      EVT ShiftVT = C1->getValueType(0);\n      bool SameSide = (N->getOpcode() == NextOp);\n      unsigned CombineOp = SameSide ? ISD::ADD : ISD::SUB;\n      if (SDValue CombinedShift = DAG.FoldConstantArithmetic(\n              CombineOp, dl, ShiftVT, {N1, N0.getOperand(1)})) {\n        SDValue BitsizeC = DAG.getConstant(Bitsize, dl, ShiftVT);\n        SDValue CombinedShiftNorm = DAG.FoldConstantArithmetic(\n            ISD::SREM, dl, ShiftVT, {CombinedShift, BitsizeC});\n        return DAG.getNode(N->getOpcode(), dl, VT, N0->getOperand(0),\n                           CombinedShiftNorm);\n      }\n    }\n  }\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitSHL(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  if (SDValue V = DAG.simplifyShift(N0, N1))\n    return V;\n\n  EVT VT = N0.getValueType();\n  EVT ShiftVT = N1.getValueType();\n  unsigned OpSizeInBits = VT.getScalarSizeInBits();\n\n  // fold vector ops\n  if (VT.isVector()) {\n    if (SDValue FoldedVOp = SimplifyVBinOp(N))\n      return FoldedVOp;\n\n    BuildVectorSDNode *N1CV = dyn_cast<BuildVectorSDNode>(N1);\n    // If setcc produces all-one true value then:\n    // (shl (and (setcc) N01CV) N1CV) -> (and (setcc) N01CV<<N1CV)\n    if (N1CV && N1CV->isConstant()) {\n      if (N0.getOpcode() == ISD::AND) {\n        SDValue N00 = N0->getOperand(0);\n        SDValue N01 = N0->getOperand(1);\n        BuildVectorSDNode *N01CV = dyn_cast<BuildVectorSDNode>(N01);\n\n        if (N01CV && N01CV->isConstant() && N00.getOpcode() == ISD::SETCC &&\n            TLI.getBooleanContents(N00.getOperand(0).getValueType()) ==\n                TargetLowering::ZeroOrNegativeOneBooleanContent) {\n          if (SDValue C =\n                  DAG.FoldConstantArithmetic(ISD::SHL, SDLoc(N), VT, {N01, N1}))\n            return DAG.getNode(ISD::AND, SDLoc(N), VT, N00, C);\n        }\n      }\n    }\n  }\n\n  ConstantSDNode *N1C = isConstOrConstSplat(N1);\n\n  // fold (shl c1, c2) -> c1<<c2\n  if (SDValue C = DAG.FoldConstantArithmetic(ISD::SHL, SDLoc(N), VT, {N0, N1}))\n    return C;\n\n  if (SDValue NewSel = foldBinOpIntoSelect(N))\n    return NewSel;\n\n  // if (shl x, c) is known to be zero, return 0\n  if (DAG.MaskedValueIsZero(SDValue(N, 0),\n                            APInt::getAllOnesValue(OpSizeInBits)))\n    return DAG.getConstant(0, SDLoc(N), VT);\n\n  // fold (shl x, (trunc (and y, c))) -> (shl x, (and (trunc y), (trunc c))).\n  if (N1.getOpcode() == ISD::TRUNCATE &&\n      N1.getOperand(0).getOpcode() == ISD::AND) {\n    if (SDValue NewOp1 = distributeTruncateThroughAnd(N1.getNode()))\n      return DAG.getNode(ISD::SHL, SDLoc(N), VT, N0, NewOp1);\n  }\n\n  if (SimplifyDemandedBits(SDValue(N, 0)))\n    return SDValue(N, 0);\n\n  // fold (shl (shl x, c1), c2) -> 0 or (shl x, (add c1, c2))\n  if (N0.getOpcode() == ISD::SHL) {\n    auto MatchOutOfRange = [OpSizeInBits](ConstantSDNode *LHS,\n                                          ConstantSDNode *RHS) {\n      APInt c1 = LHS->getAPIntValue();\n      APInt c2 = RHS->getAPIntValue();\n      zeroExtendToMatch(c1, c2, 1 /* Overflow Bit */);\n      return (c1 + c2).uge(OpSizeInBits);\n    };\n    if (ISD::matchBinaryPredicate(N1, N0.getOperand(1), MatchOutOfRange))\n      return DAG.getConstant(0, SDLoc(N), VT);\n\n    auto MatchInRange = [OpSizeInBits](ConstantSDNode *LHS,\n                                       ConstantSDNode *RHS) {\n      APInt c1 = LHS->getAPIntValue();\n      APInt c2 = RHS->getAPIntValue();\n      zeroExtendToMatch(c1, c2, 1 /* Overflow Bit */);\n      return (c1 + c2).ult(OpSizeInBits);\n    };\n    if (ISD::matchBinaryPredicate(N1, N0.getOperand(1), MatchInRange)) {\n      SDLoc DL(N);\n      SDValue Sum = DAG.getNode(ISD::ADD, DL, ShiftVT, N1, N0.getOperand(1));\n      return DAG.getNode(ISD::SHL, DL, VT, N0.getOperand(0), Sum);\n    }\n  }\n\n  // fold (shl (ext (shl x, c1)), c2) -> (shl (ext x), (add c1, c2))\n  // For this to be valid, the second form must not preserve any of the bits\n  // that are shifted out by the inner shift in the first form.  This means\n  // the outer shift size must be >= the number of bits added by the ext.\n  // As a corollary, we don't care what kind of ext it is.\n  if ((N0.getOpcode() == ISD::ZERO_EXTEND ||\n       N0.getOpcode() == ISD::ANY_EXTEND ||\n       N0.getOpcode() == ISD::SIGN_EXTEND) &&\n      N0.getOperand(0).getOpcode() == ISD::SHL) {\n    SDValue N0Op0 = N0.getOperand(0);\n    SDValue InnerShiftAmt = N0Op0.getOperand(1);\n    EVT InnerVT = N0Op0.getValueType();\n    uint64_t InnerBitwidth = InnerVT.getScalarSizeInBits();\n\n    auto MatchOutOfRange = [OpSizeInBits, InnerBitwidth](ConstantSDNode *LHS,\n                                                         ConstantSDNode *RHS) {\n      APInt c1 = LHS->getAPIntValue();\n      APInt c2 = RHS->getAPIntValue();\n      zeroExtendToMatch(c1, c2, 1 /* Overflow Bit */);\n      return c2.uge(OpSizeInBits - InnerBitwidth) &&\n             (c1 + c2).uge(OpSizeInBits);\n    };\n    if (ISD::matchBinaryPredicate(InnerShiftAmt, N1, MatchOutOfRange,\n                                  /*AllowUndefs*/ false,\n                                  /*AllowTypeMismatch*/ true))\n      return DAG.getConstant(0, SDLoc(N), VT);\n\n    auto MatchInRange = [OpSizeInBits, InnerBitwidth](ConstantSDNode *LHS,\n                                                      ConstantSDNode *RHS) {\n      APInt c1 = LHS->getAPIntValue();\n      APInt c2 = RHS->getAPIntValue();\n      zeroExtendToMatch(c1, c2, 1 /* Overflow Bit */);\n      return c2.uge(OpSizeInBits - InnerBitwidth) &&\n             (c1 + c2).ult(OpSizeInBits);\n    };\n    if (ISD::matchBinaryPredicate(InnerShiftAmt, N1, MatchInRange,\n                                  /*AllowUndefs*/ false,\n                                  /*AllowTypeMismatch*/ true)) {\n      SDLoc DL(N);\n      SDValue Ext = DAG.getNode(N0.getOpcode(), DL, VT, N0Op0.getOperand(0));\n      SDValue Sum = DAG.getZExtOrTrunc(InnerShiftAmt, DL, ShiftVT);\n      Sum = DAG.getNode(ISD::ADD, DL, ShiftVT, Sum, N1);\n      return DAG.getNode(ISD::SHL, DL, VT, Ext, Sum);\n    }\n  }\n\n  // fold (shl (zext (srl x, C)), C) -> (zext (shl (srl x, C), C))\n  // Only fold this if the inner zext has no other uses to avoid increasing\n  // the total number of instructions.\n  if (N0.getOpcode() == ISD::ZERO_EXTEND && N0.hasOneUse() &&\n      N0.getOperand(0).getOpcode() == ISD::SRL) {\n    SDValue N0Op0 = N0.getOperand(0);\n    SDValue InnerShiftAmt = N0Op0.getOperand(1);\n\n    auto MatchEqual = [VT](ConstantSDNode *LHS, ConstantSDNode *RHS) {\n      APInt c1 = LHS->getAPIntValue();\n      APInt c2 = RHS->getAPIntValue();\n      zeroExtendToMatch(c1, c2);\n      return c1.ult(VT.getScalarSizeInBits()) && (c1 == c2);\n    };\n    if (ISD::matchBinaryPredicate(InnerShiftAmt, N1, MatchEqual,\n                                  /*AllowUndefs*/ false,\n                                  /*AllowTypeMismatch*/ true)) {\n      SDLoc DL(N);\n      EVT InnerShiftAmtVT = N0Op0.getOperand(1).getValueType();\n      SDValue NewSHL = DAG.getZExtOrTrunc(N1, DL, InnerShiftAmtVT);\n      NewSHL = DAG.getNode(ISD::SHL, DL, N0Op0.getValueType(), N0Op0, NewSHL);\n      AddToWorklist(NewSHL.getNode());\n      return DAG.getNode(ISD::ZERO_EXTEND, SDLoc(N0), VT, NewSHL);\n    }\n  }\n\n  // fold (shl (sr[la] exact X,  C1), C2) -> (shl    X, (C2-C1)) if C1 <= C2\n  // fold (shl (sr[la] exact X,  C1), C2) -> (sr[la] X, (C2-C1)) if C1  > C2\n  // TODO - support non-uniform vector shift amounts.\n  if (N1C && (N0.getOpcode() == ISD::SRL || N0.getOpcode() == ISD::SRA) &&\n      N0->getFlags().hasExact()) {\n    if (ConstantSDNode *N0C1 = isConstOrConstSplat(N0.getOperand(1))) {\n      uint64_t C1 = N0C1->getZExtValue();\n      uint64_t C2 = N1C->getZExtValue();\n      SDLoc DL(N);\n      if (C1 <= C2)\n        return DAG.getNode(ISD::SHL, DL, VT, N0.getOperand(0),\n                           DAG.getConstant(C2 - C1, DL, ShiftVT));\n      return DAG.getNode(N0.getOpcode(), DL, VT, N0.getOperand(0),\n                         DAG.getConstant(C1 - C2, DL, ShiftVT));\n    }\n  }\n\n  // fold (shl (srl x, c1), c2) -> (and (shl x, (sub c2, c1), MASK) or\n  //                               (and (srl x, (sub c1, c2), MASK)\n  // Only fold this if the inner shift has no other uses -- if it does, folding\n  // this will increase the total number of instructions.\n  // TODO - drop hasOneUse requirement if c1 == c2?\n  // TODO - support non-uniform vector shift amounts.\n  if (N1C && N0.getOpcode() == ISD::SRL && N0.hasOneUse() &&\n      TLI.shouldFoldConstantShiftPairToMask(N, Level)) {\n    if (ConstantSDNode *N0C1 = isConstOrConstSplat(N0.getOperand(1))) {\n      if (N0C1->getAPIntValue().ult(OpSizeInBits)) {\n        uint64_t c1 = N0C1->getZExtValue();\n        uint64_t c2 = N1C->getZExtValue();\n        APInt Mask = APInt::getHighBitsSet(OpSizeInBits, OpSizeInBits - c1);\n        SDValue Shift;\n        if (c2 > c1) {\n          Mask <<= c2 - c1;\n          SDLoc DL(N);\n          Shift = DAG.getNode(ISD::SHL, DL, VT, N0.getOperand(0),\n                              DAG.getConstant(c2 - c1, DL, ShiftVT));\n        } else {\n          Mask.lshrInPlace(c1 - c2);\n          SDLoc DL(N);\n          Shift = DAG.getNode(ISD::SRL, DL, VT, N0.getOperand(0),\n                              DAG.getConstant(c1 - c2, DL, ShiftVT));\n        }\n        SDLoc DL(N0);\n        return DAG.getNode(ISD::AND, DL, VT, Shift,\n                           DAG.getConstant(Mask, DL, VT));\n      }\n    }\n  }\n\n  // fold (shl (sra x, c1), c1) -> (and x, (shl -1, c1))\n  if (N0.getOpcode() == ISD::SRA && N1 == N0.getOperand(1) &&\n      isConstantOrConstantVector(N1, /* No Opaques */ true)) {\n    SDLoc DL(N);\n    SDValue AllBits = DAG.getAllOnesConstant(DL, VT);\n    SDValue HiBitsMask = DAG.getNode(ISD::SHL, DL, VT, AllBits, N1);\n    return DAG.getNode(ISD::AND, DL, VT, N0.getOperand(0), HiBitsMask);\n  }\n\n  // fold (shl (add x, c1), c2) -> (add (shl x, c2), c1 << c2)\n  // fold (shl (or x, c1), c2) -> (or (shl x, c2), c1 << c2)\n  // Variant of version done on multiply, except mul by a power of 2 is turned\n  // into a shift.\n  if ((N0.getOpcode() == ISD::ADD || N0.getOpcode() == ISD::OR) &&\n      N0.getNode()->hasOneUse() &&\n      isConstantOrConstantVector(N1, /* No Opaques */ true) &&\n      isConstantOrConstantVector(N0.getOperand(1), /* No Opaques */ true) &&\n      TLI.isDesirableToCommuteWithShift(N, Level)) {\n    SDValue Shl0 = DAG.getNode(ISD::SHL, SDLoc(N0), VT, N0.getOperand(0), N1);\n    SDValue Shl1 = DAG.getNode(ISD::SHL, SDLoc(N1), VT, N0.getOperand(1), N1);\n    AddToWorklist(Shl0.getNode());\n    AddToWorklist(Shl1.getNode());\n    return DAG.getNode(N0.getOpcode(), SDLoc(N), VT, Shl0, Shl1);\n  }\n\n  // fold (shl (mul x, c1), c2) -> (mul x, c1 << c2)\n  if (N0.getOpcode() == ISD::MUL && N0.getNode()->hasOneUse() &&\n      isConstantOrConstantVector(N1, /* No Opaques */ true) &&\n      isConstantOrConstantVector(N0.getOperand(1), /* No Opaques */ true)) {\n    SDValue Shl = DAG.getNode(ISD::SHL, SDLoc(N1), VT, N0.getOperand(1), N1);\n    if (isConstantOrConstantVector(Shl))\n      return DAG.getNode(ISD::MUL, SDLoc(N), VT, N0.getOperand(0), Shl);\n  }\n\n  if (N1C && !N1C->isOpaque())\n    if (SDValue NewSHL = visitShiftByConstant(N))\n      return NewSHL;\n\n  // Fold (shl (vscale * C0), C1) to (vscale * (C0 << C1)).\n  if (N0.getOpcode() == ISD::VSCALE)\n    if (ConstantSDNode *NC1 = isConstOrConstSplat(N->getOperand(1))) {\n      const APInt &C0 = N0.getConstantOperandAPInt(0);\n      const APInt &C1 = NC1->getAPIntValue();\n      return DAG.getVScale(SDLoc(N), VT, C0 << C1);\n    }\n\n  return SDValue();\n}\n\n// Transform a right shift of a multiply into a multiply-high.\n// Examples:\n// (srl (mul (zext i32:$a to i64), (zext i32:$a to i64)), 32) -> (mulhu $a, $b)\n// (sra (mul (sext i32:$a to i64), (sext i32:$a to i64)), 32) -> (mulhs $a, $b)\nstatic SDValue combineShiftToMULH(SDNode *N, SelectionDAG &DAG,\n                                  const TargetLowering &TLI) {\n  assert((N->getOpcode() == ISD::SRL || N->getOpcode() == ISD::SRA) &&\n         \"SRL or SRA node is required here!\");\n\n  // Check the shift amount. Proceed with the transformation if the shift\n  // amount is constant.\n  ConstantSDNode *ShiftAmtSrc = isConstOrConstSplat(N->getOperand(1));\n  if (!ShiftAmtSrc)\n    return SDValue();\n\n  SDLoc DL(N);\n\n  // The operation feeding into the shift must be a multiply.\n  SDValue ShiftOperand = N->getOperand(0);\n  if (ShiftOperand.getOpcode() != ISD::MUL)\n    return SDValue();\n\n  // Both operands must be equivalent extend nodes.\n  SDValue LeftOp = ShiftOperand.getOperand(0);\n  SDValue RightOp = ShiftOperand.getOperand(1);\n  bool IsSignExt = LeftOp.getOpcode() == ISD::SIGN_EXTEND;\n  bool IsZeroExt = LeftOp.getOpcode() == ISD::ZERO_EXTEND;\n\n  if ((!(IsSignExt || IsZeroExt)) || LeftOp.getOpcode() != RightOp.getOpcode())\n    return SDValue();\n\n  EVT WideVT1 = LeftOp.getValueType();\n  EVT WideVT2 = RightOp.getValueType();\n  (void)WideVT2;\n  // Proceed with the transformation if the wide types match.\n  assert((WideVT1 == WideVT2) &&\n         \"Cannot have a multiply node with two different operand types.\");\n\n  EVT NarrowVT = LeftOp.getOperand(0).getValueType();\n  // Check that the two extend nodes are the same type.\n  if (NarrowVT !=  RightOp.getOperand(0).getValueType())\n    return SDValue();\n\n  // Proceed with the transformation if the wide type is twice as large\n  // as the narrow type.\n  unsigned NarrowVTSize = NarrowVT.getScalarSizeInBits();\n  if (WideVT1.getScalarSizeInBits() != 2 * NarrowVTSize)\n    return SDValue();\n\n  // Check the shift amount with the narrow type size.\n  // Proceed with the transformation if the shift amount is the width\n  // of the narrow type.\n  unsigned ShiftAmt = ShiftAmtSrc->getZExtValue();\n  if (ShiftAmt != NarrowVTSize)\n    return SDValue();\n\n  // If the operation feeding into the MUL is a sign extend (sext),\n  // we use mulhs. Othewise, zero extends (zext) use mulhu.\n  unsigned MulhOpcode = IsSignExt ? ISD::MULHS : ISD::MULHU;\n\n  // Combine to mulh if mulh is legal/custom for the narrow type on the target.\n  if (!TLI.isOperationLegalOrCustom(MulhOpcode, NarrowVT))\n    return SDValue();\n\n  SDValue Result = DAG.getNode(MulhOpcode, DL, NarrowVT, LeftOp.getOperand(0),\n                               RightOp.getOperand(0));\n  return (N->getOpcode() == ISD::SRA ? DAG.getSExtOrTrunc(Result, DL, WideVT1)\n                                     : DAG.getZExtOrTrunc(Result, DL, WideVT1));\n}\n\nSDValue DAGCombiner::visitSRA(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  if (SDValue V = DAG.simplifyShift(N0, N1))\n    return V;\n\n  EVT VT = N0.getValueType();\n  unsigned OpSizeInBits = VT.getScalarSizeInBits();\n\n  // Arithmetic shifting an all-sign-bit value is a no-op.\n  // fold (sra 0, x) -> 0\n  // fold (sra -1, x) -> -1\n  if (DAG.ComputeNumSignBits(N0) == OpSizeInBits)\n    return N0;\n\n  // fold vector ops\n  if (VT.isVector())\n    if (SDValue FoldedVOp = SimplifyVBinOp(N))\n      return FoldedVOp;\n\n  ConstantSDNode *N1C = isConstOrConstSplat(N1);\n\n  // fold (sra c1, c2) -> (sra c1, c2)\n  if (SDValue C = DAG.FoldConstantArithmetic(ISD::SRA, SDLoc(N), VT, {N0, N1}))\n    return C;\n\n  if (SDValue NewSel = foldBinOpIntoSelect(N))\n    return NewSel;\n\n  // fold (sra (shl x, c1), c1) -> sext_inreg for some c1 and target supports\n  // sext_inreg.\n  if (N1C && N0.getOpcode() == ISD::SHL && N1 == N0.getOperand(1)) {\n    unsigned LowBits = OpSizeInBits - (unsigned)N1C->getZExtValue();\n    EVT ExtVT = EVT::getIntegerVT(*DAG.getContext(), LowBits);\n    if (VT.isVector())\n      ExtVT = EVT::getVectorVT(*DAG.getContext(), ExtVT,\n                               VT.getVectorElementCount());\n    if (!LegalOperations ||\n        TLI.getOperationAction(ISD::SIGN_EXTEND_INREG, ExtVT) ==\n        TargetLowering::Legal)\n      return DAG.getNode(ISD::SIGN_EXTEND_INREG, SDLoc(N), VT,\n                         N0.getOperand(0), DAG.getValueType(ExtVT));\n    // Even if we can't convert to sext_inreg, we might be able to remove\n    // this shift pair if the input is already sign extended.\n    if (DAG.ComputeNumSignBits(N0.getOperand(0)) > N1C->getZExtValue())\n      return N0.getOperand(0);\n  }\n\n  // fold (sra (sra x, c1), c2) -> (sra x, (add c1, c2))\n  // clamp (add c1, c2) to max shift.\n  if (N0.getOpcode() == ISD::SRA) {\n    SDLoc DL(N);\n    EVT ShiftVT = N1.getValueType();\n    EVT ShiftSVT = ShiftVT.getScalarType();\n    SmallVector<SDValue, 16> ShiftValues;\n\n    auto SumOfShifts = [&](ConstantSDNode *LHS, ConstantSDNode *RHS) {\n      APInt c1 = LHS->getAPIntValue();\n      APInt c2 = RHS->getAPIntValue();\n      zeroExtendToMatch(c1, c2, 1 /* Overflow Bit */);\n      APInt Sum = c1 + c2;\n      unsigned ShiftSum =\n          Sum.uge(OpSizeInBits) ? (OpSizeInBits - 1) : Sum.getZExtValue();\n      ShiftValues.push_back(DAG.getConstant(ShiftSum, DL, ShiftSVT));\n      return true;\n    };\n    if (ISD::matchBinaryPredicate(N1, N0.getOperand(1), SumOfShifts)) {\n      SDValue ShiftValue;\n      if (VT.isVector())\n        ShiftValue = DAG.getBuildVector(ShiftVT, DL, ShiftValues);\n      else\n        ShiftValue = ShiftValues[0];\n      return DAG.getNode(ISD::SRA, DL, VT, N0.getOperand(0), ShiftValue);\n    }\n  }\n\n  // fold (sra (shl X, m), (sub result_size, n))\n  // -> (sign_extend (trunc (shl X, (sub (sub result_size, n), m)))) for\n  // result_size - n != m.\n  // If truncate is free for the target sext(shl) is likely to result in better\n  // code.\n  if (N0.getOpcode() == ISD::SHL && N1C) {\n    // Get the two constanst of the shifts, CN0 = m, CN = n.\n    const ConstantSDNode *N01C = isConstOrConstSplat(N0.getOperand(1));\n    if (N01C) {\n      LLVMContext &Ctx = *DAG.getContext();\n      // Determine what the truncate's result bitsize and type would be.\n      EVT TruncVT = EVT::getIntegerVT(Ctx, OpSizeInBits - N1C->getZExtValue());\n\n      if (VT.isVector())\n        TruncVT = EVT::getVectorVT(Ctx, TruncVT, VT.getVectorElementCount());\n\n      // Determine the residual right-shift amount.\n      int ShiftAmt = N1C->getZExtValue() - N01C->getZExtValue();\n\n      // If the shift is not a no-op (in which case this should be just a sign\n      // extend already), the truncated to type is legal, sign_extend is legal\n      // on that type, and the truncate to that type is both legal and free,\n      // perform the transform.\n      if ((ShiftAmt > 0) &&\n          TLI.isOperationLegalOrCustom(ISD::SIGN_EXTEND, TruncVT) &&\n          TLI.isOperationLegalOrCustom(ISD::TRUNCATE, VT) &&\n          TLI.isTruncateFree(VT, TruncVT)) {\n        SDLoc DL(N);\n        SDValue Amt = DAG.getConstant(ShiftAmt, DL,\n            getShiftAmountTy(N0.getOperand(0).getValueType()));\n        SDValue Shift = DAG.getNode(ISD::SRL, DL, VT,\n                                    N0.getOperand(0), Amt);\n        SDValue Trunc = DAG.getNode(ISD::TRUNCATE, DL, TruncVT,\n                                    Shift);\n        return DAG.getNode(ISD::SIGN_EXTEND, DL,\n                           N->getValueType(0), Trunc);\n      }\n    }\n  }\n\n  // We convert trunc/ext to opposing shifts in IR, but casts may be cheaper.\n  //   sra (add (shl X, N1C), AddC), N1C -->\n  //   sext (add (trunc X to (width - N1C)), AddC')\n  if (N0.getOpcode() == ISD::ADD && N0.hasOneUse() && N1C &&\n      N0.getOperand(0).getOpcode() == ISD::SHL &&\n      N0.getOperand(0).getOperand(1) == N1 && N0.getOperand(0).hasOneUse()) {\n    if (ConstantSDNode *AddC = isConstOrConstSplat(N0.getOperand(1))) {\n      SDValue Shl = N0.getOperand(0);\n      // Determine what the truncate's type would be and ask the target if that\n      // is a free operation.\n      LLVMContext &Ctx = *DAG.getContext();\n      unsigned ShiftAmt = N1C->getZExtValue();\n      EVT TruncVT = EVT::getIntegerVT(Ctx, OpSizeInBits - ShiftAmt);\n      if (VT.isVector())\n        TruncVT = EVT::getVectorVT(Ctx, TruncVT, VT.getVectorElementCount());\n\n      // TODO: The simple type check probably belongs in the default hook\n      //       implementation and/or target-specific overrides (because\n      //       non-simple types likely require masking when legalized), but that\n      //       restriction may conflict with other transforms.\n      if (TruncVT.isSimple() && isTypeLegal(TruncVT) &&\n          TLI.isTruncateFree(VT, TruncVT)) {\n        SDLoc DL(N);\n        SDValue Trunc = DAG.getZExtOrTrunc(Shl.getOperand(0), DL, TruncVT);\n        SDValue ShiftC = DAG.getConstant(AddC->getAPIntValue().lshr(ShiftAmt).\n                             trunc(TruncVT.getScalarSizeInBits()), DL, TruncVT);\n        SDValue Add = DAG.getNode(ISD::ADD, DL, TruncVT, Trunc, ShiftC);\n        return DAG.getSExtOrTrunc(Add, DL, VT);\n      }\n    }\n  }\n\n  // fold (sra x, (trunc (and y, c))) -> (sra x, (and (trunc y), (trunc c))).\n  if (N1.getOpcode() == ISD::TRUNCATE &&\n      N1.getOperand(0).getOpcode() == ISD::AND) {\n    if (SDValue NewOp1 = distributeTruncateThroughAnd(N1.getNode()))\n      return DAG.getNode(ISD::SRA, SDLoc(N), VT, N0, NewOp1);\n  }\n\n  // fold (sra (trunc (sra x, c1)), c2) -> (trunc (sra x, c1 + c2))\n  // fold (sra (trunc (srl x, c1)), c2) -> (trunc (sra x, c1 + c2))\n  //      if c1 is equal to the number of bits the trunc removes\n  // TODO - support non-uniform vector shift amounts.\n  if (N0.getOpcode() == ISD::TRUNCATE &&\n      (N0.getOperand(0).getOpcode() == ISD::SRL ||\n       N0.getOperand(0).getOpcode() == ISD::SRA) &&\n      N0.getOperand(0).hasOneUse() &&\n      N0.getOperand(0).getOperand(1).hasOneUse() && N1C) {\n    SDValue N0Op0 = N0.getOperand(0);\n    if (ConstantSDNode *LargeShift = isConstOrConstSplat(N0Op0.getOperand(1))) {\n      EVT LargeVT = N0Op0.getValueType();\n      unsigned TruncBits = LargeVT.getScalarSizeInBits() - OpSizeInBits;\n      if (LargeShift->getAPIntValue() == TruncBits) {\n        SDLoc DL(N);\n        SDValue Amt = DAG.getConstant(N1C->getZExtValue() + TruncBits, DL,\n                                      getShiftAmountTy(LargeVT));\n        SDValue SRA =\n            DAG.getNode(ISD::SRA, DL, LargeVT, N0Op0.getOperand(0), Amt);\n        return DAG.getNode(ISD::TRUNCATE, DL, VT, SRA);\n      }\n    }\n  }\n\n  // Simplify, based on bits shifted out of the LHS.\n  if (SimplifyDemandedBits(SDValue(N, 0)))\n    return SDValue(N, 0);\n\n  // If the sign bit is known to be zero, switch this to a SRL.\n  if (DAG.SignBitIsZero(N0))\n    return DAG.getNode(ISD::SRL, SDLoc(N), VT, N0, N1);\n\n  if (N1C && !N1C->isOpaque())\n    if (SDValue NewSRA = visitShiftByConstant(N))\n      return NewSRA;\n\n  // Try to transform this shift into a multiply-high if\n  // it matches the appropriate pattern detected in combineShiftToMULH.\n  if (SDValue MULH = combineShiftToMULH(N, DAG, TLI))\n    return MULH;\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitSRL(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  if (SDValue V = DAG.simplifyShift(N0, N1))\n    return V;\n\n  EVT VT = N0.getValueType();\n  unsigned OpSizeInBits = VT.getScalarSizeInBits();\n\n  // fold vector ops\n  if (VT.isVector())\n    if (SDValue FoldedVOp = SimplifyVBinOp(N))\n      return FoldedVOp;\n\n  ConstantSDNode *N1C = isConstOrConstSplat(N1);\n\n  // fold (srl c1, c2) -> c1 >>u c2\n  if (SDValue C = DAG.FoldConstantArithmetic(ISD::SRL, SDLoc(N), VT, {N0, N1}))\n    return C;\n\n  if (SDValue NewSel = foldBinOpIntoSelect(N))\n    return NewSel;\n\n  // if (srl x, c) is known to be zero, return 0\n  if (N1C && DAG.MaskedValueIsZero(SDValue(N, 0),\n                                   APInt::getAllOnesValue(OpSizeInBits)))\n    return DAG.getConstant(0, SDLoc(N), VT);\n\n  // fold (srl (srl x, c1), c2) -> 0 or (srl x, (add c1, c2))\n  if (N0.getOpcode() == ISD::SRL) {\n    auto MatchOutOfRange = [OpSizeInBits](ConstantSDNode *LHS,\n                                          ConstantSDNode *RHS) {\n      APInt c1 = LHS->getAPIntValue();\n      APInt c2 = RHS->getAPIntValue();\n      zeroExtendToMatch(c1, c2, 1 /* Overflow Bit */);\n      return (c1 + c2).uge(OpSizeInBits);\n    };\n    if (ISD::matchBinaryPredicate(N1, N0.getOperand(1), MatchOutOfRange))\n      return DAG.getConstant(0, SDLoc(N), VT);\n\n    auto MatchInRange = [OpSizeInBits](ConstantSDNode *LHS,\n                                       ConstantSDNode *RHS) {\n      APInt c1 = LHS->getAPIntValue();\n      APInt c2 = RHS->getAPIntValue();\n      zeroExtendToMatch(c1, c2, 1 /* Overflow Bit */);\n      return (c1 + c2).ult(OpSizeInBits);\n    };\n    if (ISD::matchBinaryPredicate(N1, N0.getOperand(1), MatchInRange)) {\n      SDLoc DL(N);\n      EVT ShiftVT = N1.getValueType();\n      SDValue Sum = DAG.getNode(ISD::ADD, DL, ShiftVT, N1, N0.getOperand(1));\n      return DAG.getNode(ISD::SRL, DL, VT, N0.getOperand(0), Sum);\n    }\n  }\n\n  if (N1C && N0.getOpcode() == ISD::TRUNCATE &&\n      N0.getOperand(0).getOpcode() == ISD::SRL) {\n    SDValue InnerShift = N0.getOperand(0);\n    // TODO - support non-uniform vector shift amounts.\n    if (auto *N001C = isConstOrConstSplat(InnerShift.getOperand(1))) {\n      uint64_t c1 = N001C->getZExtValue();\n      uint64_t c2 = N1C->getZExtValue();\n      EVT InnerShiftVT = InnerShift.getValueType();\n      EVT ShiftAmtVT = InnerShift.getOperand(1).getValueType();\n      uint64_t InnerShiftSize = InnerShiftVT.getScalarSizeInBits();\n      // srl (trunc (srl x, c1)), c2 --> 0 or (trunc (srl x, (add c1, c2)))\n      // This is only valid if the OpSizeInBits + c1 = size of inner shift.\n      if (c1 + OpSizeInBits == InnerShiftSize) {\n        SDLoc DL(N);\n        if (c1 + c2 >= InnerShiftSize)\n          return DAG.getConstant(0, DL, VT);\n        SDValue NewShiftAmt = DAG.getConstant(c1 + c2, DL, ShiftAmtVT);\n        SDValue NewShift = DAG.getNode(ISD::SRL, DL, InnerShiftVT,\n                                       InnerShift.getOperand(0), NewShiftAmt);\n        return DAG.getNode(ISD::TRUNCATE, DL, VT, NewShift);\n      }\n      // In the more general case, we can clear the high bits after the shift:\n      // srl (trunc (srl x, c1)), c2 --> trunc (and (srl x, (c1+c2)), Mask)\n      if (N0.hasOneUse() && InnerShift.hasOneUse() &&\n          c1 + c2 < InnerShiftSize) {\n        SDLoc DL(N);\n        SDValue NewShiftAmt = DAG.getConstant(c1 + c2, DL, ShiftAmtVT);\n        SDValue NewShift = DAG.getNode(ISD::SRL, DL, InnerShiftVT,\n                                       InnerShift.getOperand(0), NewShiftAmt);\n        SDValue Mask = DAG.getConstant(APInt::getLowBitsSet(InnerShiftSize,\n                                                            OpSizeInBits - c2),\n                                       DL, InnerShiftVT);\n        SDValue And = DAG.getNode(ISD::AND, DL, InnerShiftVT, NewShift, Mask);\n        return DAG.getNode(ISD::TRUNCATE, DL, VT, And);\n      }\n    }\n  }\n\n  // fold (srl (shl x, c), c) -> (and x, cst2)\n  // TODO - (srl (shl x, c1), c2).\n  if (N0.getOpcode() == ISD::SHL && N0.getOperand(1) == N1 &&\n      isConstantOrConstantVector(N1, /* NoOpaques */ true)) {\n    SDLoc DL(N);\n    SDValue Mask =\n        DAG.getNode(ISD::SRL, DL, VT, DAG.getAllOnesConstant(DL, VT), N1);\n    AddToWorklist(Mask.getNode());\n    return DAG.getNode(ISD::AND, DL, VT, N0.getOperand(0), Mask);\n  }\n\n  // fold (srl (anyextend x), c) -> (and (anyextend (srl x, c)), mask)\n  // TODO - support non-uniform vector shift amounts.\n  if (N1C && N0.getOpcode() == ISD::ANY_EXTEND) {\n    // Shifting in all undef bits?\n    EVT SmallVT = N0.getOperand(0).getValueType();\n    unsigned BitSize = SmallVT.getScalarSizeInBits();\n    if (N1C->getAPIntValue().uge(BitSize))\n      return DAG.getUNDEF(VT);\n\n    if (!LegalTypes || TLI.isTypeDesirableForOp(ISD::SRL, SmallVT)) {\n      uint64_t ShiftAmt = N1C->getZExtValue();\n      SDLoc DL0(N0);\n      SDValue SmallShift = DAG.getNode(ISD::SRL, DL0, SmallVT,\n                                       N0.getOperand(0),\n                          DAG.getConstant(ShiftAmt, DL0,\n                                          getShiftAmountTy(SmallVT)));\n      AddToWorklist(SmallShift.getNode());\n      APInt Mask = APInt::getLowBitsSet(OpSizeInBits, OpSizeInBits - ShiftAmt);\n      SDLoc DL(N);\n      return DAG.getNode(ISD::AND, DL, VT,\n                         DAG.getNode(ISD::ANY_EXTEND, DL, VT, SmallShift),\n                         DAG.getConstant(Mask, DL, VT));\n    }\n  }\n\n  // fold (srl (sra X, Y), 31) -> (srl X, 31).  This srl only looks at the sign\n  // bit, which is unmodified by sra.\n  if (N1C && N1C->getAPIntValue() == (OpSizeInBits - 1)) {\n    if (N0.getOpcode() == ISD::SRA)\n      return DAG.getNode(ISD::SRL, SDLoc(N), VT, N0.getOperand(0), N1);\n  }\n\n  // fold (srl (ctlz x), \"5\") -> x  iff x has one bit set (the low bit).\n  if (N1C && N0.getOpcode() == ISD::CTLZ &&\n      N1C->getAPIntValue() == Log2_32(OpSizeInBits)) {\n    KnownBits Known = DAG.computeKnownBits(N0.getOperand(0));\n\n    // If any of the input bits are KnownOne, then the input couldn't be all\n    // zeros, thus the result of the srl will always be zero.\n    if (Known.One.getBoolValue()) return DAG.getConstant(0, SDLoc(N0), VT);\n\n    // If all of the bits input the to ctlz node are known to be zero, then\n    // the result of the ctlz is \"32\" and the result of the shift is one.\n    APInt UnknownBits = ~Known.Zero;\n    if (UnknownBits == 0) return DAG.getConstant(1, SDLoc(N0), VT);\n\n    // Otherwise, check to see if there is exactly one bit input to the ctlz.\n    if (UnknownBits.isPowerOf2()) {\n      // Okay, we know that only that the single bit specified by UnknownBits\n      // could be set on input to the CTLZ node. If this bit is set, the SRL\n      // will return 0, if it is clear, it returns 1. Change the CTLZ/SRL pair\n      // to an SRL/XOR pair, which is likely to simplify more.\n      unsigned ShAmt = UnknownBits.countTrailingZeros();\n      SDValue Op = N0.getOperand(0);\n\n      if (ShAmt) {\n        SDLoc DL(N0);\n        Op = DAG.getNode(ISD::SRL, DL, VT, Op,\n                  DAG.getConstant(ShAmt, DL,\n                                  getShiftAmountTy(Op.getValueType())));\n        AddToWorklist(Op.getNode());\n      }\n\n      SDLoc DL(N);\n      return DAG.getNode(ISD::XOR, DL, VT,\n                         Op, DAG.getConstant(1, DL, VT));\n    }\n  }\n\n  // fold (srl x, (trunc (and y, c))) -> (srl x, (and (trunc y), (trunc c))).\n  if (N1.getOpcode() == ISD::TRUNCATE &&\n      N1.getOperand(0).getOpcode() == ISD::AND) {\n    if (SDValue NewOp1 = distributeTruncateThroughAnd(N1.getNode()))\n      return DAG.getNode(ISD::SRL, SDLoc(N), VT, N0, NewOp1);\n  }\n\n  // fold operands of srl based on knowledge that the low bits are not\n  // demanded.\n  if (SimplifyDemandedBits(SDValue(N, 0)))\n    return SDValue(N, 0);\n\n  if (N1C && !N1C->isOpaque())\n    if (SDValue NewSRL = visitShiftByConstant(N))\n      return NewSRL;\n\n  // Attempt to convert a srl of a load into a narrower zero-extending load.\n  if (SDValue NarrowLoad = ReduceLoadWidth(N))\n    return NarrowLoad;\n\n  // Here is a common situation. We want to optimize:\n  //\n  //   %a = ...\n  //   %b = and i32 %a, 2\n  //   %c = srl i32 %b, 1\n  //   brcond i32 %c ...\n  //\n  // into\n  //\n  //   %a = ...\n  //   %b = and %a, 2\n  //   %c = setcc eq %b, 0\n  //   brcond %c ...\n  //\n  // However when after the source operand of SRL is optimized into AND, the SRL\n  // itself may not be optimized further. Look for it and add the BRCOND into\n  // the worklist.\n  if (N->hasOneUse()) {\n    SDNode *Use = *N->use_begin();\n    if (Use->getOpcode() == ISD::BRCOND)\n      AddToWorklist(Use);\n    else if (Use->getOpcode() == ISD::TRUNCATE && Use->hasOneUse()) {\n      // Also look pass the truncate.\n      Use = *Use->use_begin();\n      if (Use->getOpcode() == ISD::BRCOND)\n        AddToWorklist(Use);\n    }\n  }\n\n  // Try to transform this shift into a multiply-high if\n  // it matches the appropriate pattern detected in combineShiftToMULH.\n  if (SDValue MULH = combineShiftToMULH(N, DAG, TLI))\n    return MULH;\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitFunnelShift(SDNode *N) {\n  EVT VT = N->getValueType(0);\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  SDValue N2 = N->getOperand(2);\n  bool IsFSHL = N->getOpcode() == ISD::FSHL;\n  unsigned BitWidth = VT.getScalarSizeInBits();\n\n  // fold (fshl N0, N1, 0) -> N0\n  // fold (fshr N0, N1, 0) -> N1\n  if (isPowerOf2_32(BitWidth))\n    if (DAG.MaskedValueIsZero(\n            N2, APInt(N2.getScalarValueSizeInBits(), BitWidth - 1)))\n      return IsFSHL ? N0 : N1;\n\n  auto IsUndefOrZero = [](SDValue V) {\n    return V.isUndef() || isNullOrNullSplat(V, /*AllowUndefs*/ true);\n  };\n\n  // TODO - support non-uniform vector shift amounts.\n  if (ConstantSDNode *Cst = isConstOrConstSplat(N2)) {\n    EVT ShAmtTy = N2.getValueType();\n\n    // fold (fsh* N0, N1, c) -> (fsh* N0, N1, c % BitWidth)\n    if (Cst->getAPIntValue().uge(BitWidth)) {\n      uint64_t RotAmt = Cst->getAPIntValue().urem(BitWidth);\n      return DAG.getNode(N->getOpcode(), SDLoc(N), VT, N0, N1,\n                         DAG.getConstant(RotAmt, SDLoc(N), ShAmtTy));\n    }\n\n    unsigned ShAmt = Cst->getZExtValue();\n    if (ShAmt == 0)\n      return IsFSHL ? N0 : N1;\n\n    // fold fshl(undef_or_zero, N1, C) -> lshr(N1, BW-C)\n    // fold fshr(undef_or_zero, N1, C) -> lshr(N1, C)\n    // fold fshl(N0, undef_or_zero, C) -> shl(N0, C)\n    // fold fshr(N0, undef_or_zero, C) -> shl(N0, BW-C)\n    if (IsUndefOrZero(N0))\n      return DAG.getNode(ISD::SRL, SDLoc(N), VT, N1,\n                         DAG.getConstant(IsFSHL ? BitWidth - ShAmt : ShAmt,\n                                         SDLoc(N), ShAmtTy));\n    if (IsUndefOrZero(N1))\n      return DAG.getNode(ISD::SHL, SDLoc(N), VT, N0,\n                         DAG.getConstant(IsFSHL ? ShAmt : BitWidth - ShAmt,\n                                         SDLoc(N), ShAmtTy));\n\n    // fold (fshl ld1, ld0, c) -> (ld0[ofs]) iff ld0 and ld1 are consecutive.\n    // fold (fshr ld1, ld0, c) -> (ld0[ofs]) iff ld0 and ld1 are consecutive.\n    // TODO - bigendian support once we have test coverage.\n    // TODO - can we merge this with CombineConseutiveLoads/MatchLoadCombine?\n    // TODO - permit LHS EXTLOAD if extensions are shifted out.\n    if ((BitWidth % 8) == 0 && (ShAmt % 8) == 0 && !VT.isVector() &&\n        !DAG.getDataLayout().isBigEndian()) {\n      auto *LHS = dyn_cast<LoadSDNode>(N0);\n      auto *RHS = dyn_cast<LoadSDNode>(N1);\n      if (LHS && RHS && LHS->isSimple() && RHS->isSimple() &&\n          LHS->getAddressSpace() == RHS->getAddressSpace() &&\n          (LHS->hasOneUse() || RHS->hasOneUse()) && ISD::isNON_EXTLoad(RHS) &&\n          ISD::isNON_EXTLoad(LHS)) {\n        if (DAG.areNonVolatileConsecutiveLoads(LHS, RHS, BitWidth / 8, 1)) {\n          SDLoc DL(RHS);\n          uint64_t PtrOff =\n              IsFSHL ? (((BitWidth - ShAmt) % BitWidth) / 8) : (ShAmt / 8);\n          Align NewAlign = commonAlignment(RHS->getAlign(), PtrOff);\n          bool Fast = false;\n          if (TLI.allowsMemoryAccess(*DAG.getContext(), DAG.getDataLayout(), VT,\n                                     RHS->getAddressSpace(), NewAlign,\n                                     RHS->getMemOperand()->getFlags(), &Fast) &&\n              Fast) {\n            SDValue NewPtr = DAG.getMemBasePlusOffset(\n                RHS->getBasePtr(), TypeSize::Fixed(PtrOff), DL);\n            AddToWorklist(NewPtr.getNode());\n            SDValue Load = DAG.getLoad(\n                VT, DL, RHS->getChain(), NewPtr,\n                RHS->getPointerInfo().getWithOffset(PtrOff), NewAlign,\n                RHS->getMemOperand()->getFlags(), RHS->getAAInfo());\n            // Replace the old load's chain with the new load's chain.\n            WorklistRemover DeadNodes(*this);\n            DAG.ReplaceAllUsesOfValueWith(N1.getValue(1), Load.getValue(1));\n            return Load;\n          }\n        }\n      }\n    }\n  }\n\n  // fold fshr(undef_or_zero, N1, N2) -> lshr(N1, N2)\n  // fold fshl(N0, undef_or_zero, N2) -> shl(N0, N2)\n  // iff We know the shift amount is in range.\n  // TODO: when is it worth doing SUB(BW, N2) as well?\n  if (isPowerOf2_32(BitWidth)) {\n    APInt ModuloBits(N2.getScalarValueSizeInBits(), BitWidth - 1);\n    if (IsUndefOrZero(N0) && !IsFSHL && DAG.MaskedValueIsZero(N2, ~ModuloBits))\n      return DAG.getNode(ISD::SRL, SDLoc(N), VT, N1, N2);\n    if (IsUndefOrZero(N1) && IsFSHL && DAG.MaskedValueIsZero(N2, ~ModuloBits))\n      return DAG.getNode(ISD::SHL, SDLoc(N), VT, N0, N2);\n  }\n\n  // fold (fshl N0, N0, N2) -> (rotl N0, N2)\n  // fold (fshr N0, N0, N2) -> (rotr N0, N2)\n  // TODO: Investigate flipping this rotate if only one is legal, if funnel shift\n  // is legal as well we might be better off avoiding non-constant (BW - N2).\n  unsigned RotOpc = IsFSHL ? ISD::ROTL : ISD::ROTR;\n  if (N0 == N1 && hasOperation(RotOpc, VT))\n    return DAG.getNode(RotOpc, SDLoc(N), VT, N0, N2);\n\n  // Simplify, based on bits shifted out of N0/N1.\n  if (SimplifyDemandedBits(SDValue(N, 0)))\n    return SDValue(N, 0);\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitABS(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  EVT VT = N->getValueType(0);\n\n  // fold (abs c1) -> c2\n  if (DAG.isConstantIntBuildVectorOrConstantInt(N0))\n    return DAG.getNode(ISD::ABS, SDLoc(N), VT, N0);\n  // fold (abs (abs x)) -> (abs x)\n  if (N0.getOpcode() == ISD::ABS)\n    return N0;\n  // fold (abs x) -> x iff not-negative\n  if (DAG.SignBitIsZero(N0))\n    return N0;\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitBSWAP(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  EVT VT = N->getValueType(0);\n\n  // fold (bswap c1) -> c2\n  if (DAG.isConstantIntBuildVectorOrConstantInt(N0))\n    return DAG.getNode(ISD::BSWAP, SDLoc(N), VT, N0);\n  // fold (bswap (bswap x)) -> x\n  if (N0.getOpcode() == ISD::BSWAP)\n    return N0->getOperand(0);\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitBITREVERSE(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  EVT VT = N->getValueType(0);\n\n  // fold (bitreverse c1) -> c2\n  if (DAG.isConstantIntBuildVectorOrConstantInt(N0))\n    return DAG.getNode(ISD::BITREVERSE, SDLoc(N), VT, N0);\n  // fold (bitreverse (bitreverse x)) -> x\n  if (N0.getOpcode() == ISD::BITREVERSE)\n    return N0.getOperand(0);\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitCTLZ(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  EVT VT = N->getValueType(0);\n\n  // fold (ctlz c1) -> c2\n  if (DAG.isConstantIntBuildVectorOrConstantInt(N0))\n    return DAG.getNode(ISD::CTLZ, SDLoc(N), VT, N0);\n\n  // If the value is known never to be zero, switch to the undef version.\n  if (!LegalOperations || TLI.isOperationLegal(ISD::CTLZ_ZERO_UNDEF, VT)) {\n    if (DAG.isKnownNeverZero(N0))\n      return DAG.getNode(ISD::CTLZ_ZERO_UNDEF, SDLoc(N), VT, N0);\n  }\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitCTLZ_ZERO_UNDEF(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  EVT VT = N->getValueType(0);\n\n  // fold (ctlz_zero_undef c1) -> c2\n  if (DAG.isConstantIntBuildVectorOrConstantInt(N0))\n    return DAG.getNode(ISD::CTLZ_ZERO_UNDEF, SDLoc(N), VT, N0);\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitCTTZ(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  EVT VT = N->getValueType(0);\n\n  // fold (cttz c1) -> c2\n  if (DAG.isConstantIntBuildVectorOrConstantInt(N0))\n    return DAG.getNode(ISD::CTTZ, SDLoc(N), VT, N0);\n\n  // If the value is known never to be zero, switch to the undef version.\n  if (!LegalOperations || TLI.isOperationLegal(ISD::CTTZ_ZERO_UNDEF, VT)) {\n    if (DAG.isKnownNeverZero(N0))\n      return DAG.getNode(ISD::CTTZ_ZERO_UNDEF, SDLoc(N), VT, N0);\n  }\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitCTTZ_ZERO_UNDEF(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  EVT VT = N->getValueType(0);\n\n  // fold (cttz_zero_undef c1) -> c2\n  if (DAG.isConstantIntBuildVectorOrConstantInt(N0))\n    return DAG.getNode(ISD::CTTZ_ZERO_UNDEF, SDLoc(N), VT, N0);\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitCTPOP(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  EVT VT = N->getValueType(0);\n\n  // fold (ctpop c1) -> c2\n  if (DAG.isConstantIntBuildVectorOrConstantInt(N0))\n    return DAG.getNode(ISD::CTPOP, SDLoc(N), VT, N0);\n  return SDValue();\n}\n\n// FIXME: This should be checking for no signed zeros on individual operands, as\n// well as no nans.\nstatic bool isLegalToCombineMinNumMaxNum(SelectionDAG &DAG, SDValue LHS,\n                                         SDValue RHS,\n                                         const TargetLowering &TLI) {\n  const TargetOptions &Options = DAG.getTarget().Options;\n  EVT VT = LHS.getValueType();\n\n  return Options.NoSignedZerosFPMath && VT.isFloatingPoint() &&\n         TLI.isProfitableToCombineMinNumMaxNum(VT) &&\n         DAG.isKnownNeverNaN(LHS) && DAG.isKnownNeverNaN(RHS);\n}\n\n/// Generate Min/Max node\nstatic SDValue combineMinNumMaxNum(const SDLoc &DL, EVT VT, SDValue LHS,\n                                   SDValue RHS, SDValue True, SDValue False,\n                                   ISD::CondCode CC, const TargetLowering &TLI,\n                                   SelectionDAG &DAG) {\n  if (!(LHS == True && RHS == False) && !(LHS == False && RHS == True))\n    return SDValue();\n\n  EVT TransformVT = TLI.getTypeToTransformTo(*DAG.getContext(), VT);\n  switch (CC) {\n  case ISD::SETOLT:\n  case ISD::SETOLE:\n  case ISD::SETLT:\n  case ISD::SETLE:\n  case ISD::SETULT:\n  case ISD::SETULE: {\n    // Since it's known never nan to get here already, either fminnum or\n    // fminnum_ieee are OK. Try the ieee version first, since it's fminnum is\n    // expanded in terms of it.\n    unsigned IEEEOpcode = (LHS == True) ? ISD::FMINNUM_IEEE : ISD::FMAXNUM_IEEE;\n    if (TLI.isOperationLegalOrCustom(IEEEOpcode, VT))\n      return DAG.getNode(IEEEOpcode, DL, VT, LHS, RHS);\n\n    unsigned Opcode = (LHS == True) ? ISD::FMINNUM : ISD::FMAXNUM;\n    if (TLI.isOperationLegalOrCustom(Opcode, TransformVT))\n      return DAG.getNode(Opcode, DL, VT, LHS, RHS);\n    return SDValue();\n  }\n  case ISD::SETOGT:\n  case ISD::SETOGE:\n  case ISD::SETGT:\n  case ISD::SETGE:\n  case ISD::SETUGT:\n  case ISD::SETUGE: {\n    unsigned IEEEOpcode = (LHS == True) ? ISD::FMAXNUM_IEEE : ISD::FMINNUM_IEEE;\n    if (TLI.isOperationLegalOrCustom(IEEEOpcode, VT))\n      return DAG.getNode(IEEEOpcode, DL, VT, LHS, RHS);\n\n    unsigned Opcode = (LHS == True) ? ISD::FMAXNUM : ISD::FMINNUM;\n    if (TLI.isOperationLegalOrCustom(Opcode, TransformVT))\n      return DAG.getNode(Opcode, DL, VT, LHS, RHS);\n    return SDValue();\n  }\n  default:\n    return SDValue();\n  }\n}\n\n/// If a (v)select has a condition value that is a sign-bit test, try to smear\n/// the condition operand sign-bit across the value width and use it as a mask.\nstatic SDValue foldSelectOfConstantsUsingSra(SDNode *N, SelectionDAG &DAG) {\n  SDValue Cond = N->getOperand(0);\n  SDValue C1 = N->getOperand(1);\n  SDValue C2 = N->getOperand(2);\n  assert(isConstantOrConstantVector(C1) && isConstantOrConstantVector(C2) &&\n         \"Expected select-of-constants\");\n\n  EVT VT = N->getValueType(0);\n  if (Cond.getOpcode() != ISD::SETCC || !Cond.hasOneUse() ||\n      VT != Cond.getOperand(0).getValueType())\n    return SDValue();\n\n  // The inverted-condition + commuted-select variants of these patterns are\n  // canonicalized to these forms in IR.\n  SDValue X = Cond.getOperand(0);\n  SDValue CondC = Cond.getOperand(1);\n  ISD::CondCode CC = cast<CondCodeSDNode>(Cond.getOperand(2))->get();\n  if (CC == ISD::SETGT && isAllOnesOrAllOnesSplat(CondC) &&\n      isAllOnesOrAllOnesSplat(C2)) {\n    // i32 X > -1 ? C1 : -1 --> (X >>s 31) | C1\n    SDLoc DL(N);\n    SDValue ShAmtC = DAG.getConstant(X.getScalarValueSizeInBits() - 1, DL, VT);\n    SDValue Sra = DAG.getNode(ISD::SRA, DL, VT, X, ShAmtC);\n    return DAG.getNode(ISD::OR, DL, VT, Sra, C1);\n  }\n  if (CC == ISD::SETLT && isNullOrNullSplat(CondC) && isNullOrNullSplat(C2)) {\n    // i8 X < 0 ? C1 : 0 --> (X >>s 7) & C1\n    SDLoc DL(N);\n    SDValue ShAmtC = DAG.getConstant(X.getScalarValueSizeInBits() - 1, DL, VT);\n    SDValue Sra = DAG.getNode(ISD::SRA, DL, VT, X, ShAmtC);\n    return DAG.getNode(ISD::AND, DL, VT, Sra, C1);\n  }\n  return SDValue();\n}\n\nSDValue DAGCombiner::foldSelectOfConstants(SDNode *N) {\n  SDValue Cond = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  SDValue N2 = N->getOperand(2);\n  EVT VT = N->getValueType(0);\n  EVT CondVT = Cond.getValueType();\n  SDLoc DL(N);\n\n  if (!VT.isInteger())\n    return SDValue();\n\n  auto *C1 = dyn_cast<ConstantSDNode>(N1);\n  auto *C2 = dyn_cast<ConstantSDNode>(N2);\n  if (!C1 || !C2)\n    return SDValue();\n\n  // Only do this before legalization to avoid conflicting with target-specific\n  // transforms in the other direction (create a select from a zext/sext). There\n  // is also a target-independent combine here in DAGCombiner in the other\n  // direction for (select Cond, -1, 0) when the condition is not i1.\n  if (CondVT == MVT::i1 && !LegalOperations) {\n    if (C1->isNullValue() && C2->isOne()) {\n      // select Cond, 0, 1 --> zext (!Cond)\n      SDValue NotCond = DAG.getNOT(DL, Cond, MVT::i1);\n      if (VT != MVT::i1)\n        NotCond = DAG.getNode(ISD::ZERO_EXTEND, DL, VT, NotCond);\n      return NotCond;\n    }\n    if (C1->isNullValue() && C2->isAllOnesValue()) {\n      // select Cond, 0, -1 --> sext (!Cond)\n      SDValue NotCond = DAG.getNOT(DL, Cond, MVT::i1);\n      if (VT != MVT::i1)\n        NotCond = DAG.getNode(ISD::SIGN_EXTEND, DL, VT, NotCond);\n      return NotCond;\n    }\n    if (C1->isOne() && C2->isNullValue()) {\n      // select Cond, 1, 0 --> zext (Cond)\n      if (VT != MVT::i1)\n        Cond = DAG.getNode(ISD::ZERO_EXTEND, DL, VT, Cond);\n      return Cond;\n    }\n    if (C1->isAllOnesValue() && C2->isNullValue()) {\n      // select Cond, -1, 0 --> sext (Cond)\n      if (VT != MVT::i1)\n        Cond = DAG.getNode(ISD::SIGN_EXTEND, DL, VT, Cond);\n      return Cond;\n    }\n\n    // Use a target hook because some targets may prefer to transform in the\n    // other direction.\n    if (TLI.convertSelectOfConstantsToMath(VT)) {\n      // For any constants that differ by 1, we can transform the select into an\n      // extend and add.\n      const APInt &C1Val = C1->getAPIntValue();\n      const APInt &C2Val = C2->getAPIntValue();\n      if (C1Val - 1 == C2Val) {\n        // select Cond, C1, C1-1 --> add (zext Cond), C1-1\n        if (VT != MVT::i1)\n          Cond = DAG.getNode(ISD::ZERO_EXTEND, DL, VT, Cond);\n        return DAG.getNode(ISD::ADD, DL, VT, Cond, N2);\n      }\n      if (C1Val + 1 == C2Val) {\n        // select Cond, C1, C1+1 --> add (sext Cond), C1+1\n        if (VT != MVT::i1)\n          Cond = DAG.getNode(ISD::SIGN_EXTEND, DL, VT, Cond);\n        return DAG.getNode(ISD::ADD, DL, VT, Cond, N2);\n      }\n\n      // select Cond, Pow2, 0 --> (zext Cond) << log2(Pow2)\n      if (C1Val.isPowerOf2() && C2Val.isNullValue()) {\n        if (VT != MVT::i1)\n          Cond = DAG.getNode(ISD::ZERO_EXTEND, DL, VT, Cond);\n        SDValue ShAmtC = DAG.getConstant(C1Val.exactLogBase2(), DL, VT);\n        return DAG.getNode(ISD::SHL, DL, VT, Cond, ShAmtC);\n      }\n\n      if (SDValue V = foldSelectOfConstantsUsingSra(N, DAG))\n        return V;\n    }\n\n    return SDValue();\n  }\n\n  // fold (select Cond, 0, 1) -> (xor Cond, 1)\n  // We can't do this reliably if integer based booleans have different contents\n  // to floating point based booleans. This is because we can't tell whether we\n  // have an integer-based boolean or a floating-point-based boolean unless we\n  // can find the SETCC that produced it and inspect its operands. This is\n  // fairly easy if C is the SETCC node, but it can potentially be\n  // undiscoverable (or not reasonably discoverable). For example, it could be\n  // in another basic block or it could require searching a complicated\n  // expression.\n  if (CondVT.isInteger() &&\n      TLI.getBooleanContents(/*isVec*/false, /*isFloat*/true) ==\n          TargetLowering::ZeroOrOneBooleanContent &&\n      TLI.getBooleanContents(/*isVec*/false, /*isFloat*/false) ==\n          TargetLowering::ZeroOrOneBooleanContent &&\n      C1->isNullValue() && C2->isOne()) {\n    SDValue NotCond =\n        DAG.getNode(ISD::XOR, DL, CondVT, Cond, DAG.getConstant(1, DL, CondVT));\n    if (VT.bitsEq(CondVT))\n      return NotCond;\n    return DAG.getZExtOrTrunc(NotCond, DL, VT);\n  }\n\n  return SDValue();\n}\n\nstatic SDValue foldBoolSelectToLogic(SDNode *N, SelectionDAG &DAG) {\n  assert((N->getOpcode() == ISD::SELECT || N->getOpcode() == ISD::VSELECT) &&\n         \"Expected a (v)select\");\n  SDValue Cond = N->getOperand(0);\n  SDValue T = N->getOperand(1), F = N->getOperand(2);\n  EVT VT = N->getValueType(0);\n  if (VT != Cond.getValueType() || VT.getScalarSizeInBits() != 1)\n    return SDValue();\n\n  // select Cond, Cond, F --> or Cond, F\n  // select Cond, 1, F    --> or Cond, F\n  if (Cond == T || isOneOrOneSplat(T, /* AllowUndefs */ true))\n    return DAG.getNode(ISD::OR, SDLoc(N), VT, Cond, F);\n\n  // select Cond, T, Cond --> and Cond, T\n  // select Cond, T, 0    --> and Cond, T\n  if (Cond == F || isNullOrNullSplat(F, /* AllowUndefs */ true))\n    return DAG.getNode(ISD::AND, SDLoc(N), VT, Cond, T);\n\n  // select Cond, T, 1 --> or (not Cond), T\n  if (isOneOrOneSplat(F, /* AllowUndefs */ true)) {\n    SDValue NotCond = DAG.getNOT(SDLoc(N), Cond, VT);\n    return DAG.getNode(ISD::OR, SDLoc(N), VT, NotCond, T);\n  }\n\n  // select Cond, 0, F --> and (not Cond), F\n  if (isNullOrNullSplat(T, /* AllowUndefs */ true)) {\n    SDValue NotCond = DAG.getNOT(SDLoc(N), Cond, VT);\n    return DAG.getNode(ISD::AND, SDLoc(N), VT, NotCond, F);\n  }\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitSELECT(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  SDValue N2 = N->getOperand(2);\n  EVT VT = N->getValueType(0);\n  EVT VT0 = N0.getValueType();\n  SDLoc DL(N);\n  SDNodeFlags Flags = N->getFlags();\n\n  if (SDValue V = DAG.simplifySelect(N0, N1, N2))\n    return V;\n\n  if (SDValue V = foldSelectOfConstants(N))\n    return V;\n\n  if (SDValue V = foldBoolSelectToLogic(N, DAG))\n    return V;\n\n  // If we can fold this based on the true/false value, do so.\n  if (SimplifySelectOps(N, N1, N2))\n    return SDValue(N, 0); // Don't revisit N.\n\n  if (VT0 == MVT::i1) {\n    // The code in this block deals with the following 2 equivalences:\n    //    select(C0|C1, x, y) <=> select(C0, x, select(C1, x, y))\n    //    select(C0&C1, x, y) <=> select(C0, select(C1, x, y), y)\n    // The target can specify its preferred form with the\n    // shouldNormalizeToSelectSequence() callback. However we always transform\n    // to the right anyway if we find the inner select exists in the DAG anyway\n    // and we always transform to the left side if we know that we can further\n    // optimize the combination of the conditions.\n    bool normalizeToSequence =\n        TLI.shouldNormalizeToSelectSequence(*DAG.getContext(), VT);\n    // select (and Cond0, Cond1), X, Y\n    //   -> select Cond0, (select Cond1, X, Y), Y\n    if (N0->getOpcode() == ISD::AND && N0->hasOneUse()) {\n      SDValue Cond0 = N0->getOperand(0);\n      SDValue Cond1 = N0->getOperand(1);\n      SDValue InnerSelect =\n          DAG.getNode(ISD::SELECT, DL, N1.getValueType(), Cond1, N1, N2, Flags);\n      if (normalizeToSequence || !InnerSelect.use_empty())\n        return DAG.getNode(ISD::SELECT, DL, N1.getValueType(), Cond0,\n                           InnerSelect, N2, Flags);\n      // Cleanup on failure.\n      if (InnerSelect.use_empty())\n        recursivelyDeleteUnusedNodes(InnerSelect.getNode());\n    }\n    // select (or Cond0, Cond1), X, Y -> select Cond0, X, (select Cond1, X, Y)\n    if (N0->getOpcode() == ISD::OR && N0->hasOneUse()) {\n      SDValue Cond0 = N0->getOperand(0);\n      SDValue Cond1 = N0->getOperand(1);\n      SDValue InnerSelect = DAG.getNode(ISD::SELECT, DL, N1.getValueType(),\n                                        Cond1, N1, N2, Flags);\n      if (normalizeToSequence || !InnerSelect.use_empty())\n        return DAG.getNode(ISD::SELECT, DL, N1.getValueType(), Cond0, N1,\n                           InnerSelect, Flags);\n      // Cleanup on failure.\n      if (InnerSelect.use_empty())\n        recursivelyDeleteUnusedNodes(InnerSelect.getNode());\n    }\n\n    // select Cond0, (select Cond1, X, Y), Y -> select (and Cond0, Cond1), X, Y\n    if (N1->getOpcode() == ISD::SELECT && N1->hasOneUse()) {\n      SDValue N1_0 = N1->getOperand(0);\n      SDValue N1_1 = N1->getOperand(1);\n      SDValue N1_2 = N1->getOperand(2);\n      if (N1_2 == N2 && N0.getValueType() == N1_0.getValueType()) {\n        // Create the actual and node if we can generate good code for it.\n        if (!normalizeToSequence) {\n          SDValue And = DAG.getNode(ISD::AND, DL, N0.getValueType(), N0, N1_0);\n          return DAG.getNode(ISD::SELECT, DL, N1.getValueType(), And, N1_1,\n                             N2, Flags);\n        }\n        // Otherwise see if we can optimize the \"and\" to a better pattern.\n        if (SDValue Combined = visitANDLike(N0, N1_0, N)) {\n          return DAG.getNode(ISD::SELECT, DL, N1.getValueType(), Combined, N1_1,\n                             N2, Flags);\n        }\n      }\n    }\n    // select Cond0, X, (select Cond1, X, Y) -> select (or Cond0, Cond1), X, Y\n    if (N2->getOpcode() == ISD::SELECT && N2->hasOneUse()) {\n      SDValue N2_0 = N2->getOperand(0);\n      SDValue N2_1 = N2->getOperand(1);\n      SDValue N2_2 = N2->getOperand(2);\n      if (N2_1 == N1 && N0.getValueType() == N2_0.getValueType()) {\n        // Create the actual or node if we can generate good code for it.\n        if (!normalizeToSequence) {\n          SDValue Or = DAG.getNode(ISD::OR, DL, N0.getValueType(), N0, N2_0);\n          return DAG.getNode(ISD::SELECT, DL, N1.getValueType(), Or, N1,\n                             N2_2, Flags);\n        }\n        // Otherwise see if we can optimize to a better pattern.\n        if (SDValue Combined = visitORLike(N0, N2_0, N))\n          return DAG.getNode(ISD::SELECT, DL, N1.getValueType(), Combined, N1,\n                             N2_2, Flags);\n      }\n    }\n  }\n\n  // select (not Cond), N1, N2 -> select Cond, N2, N1\n  if (SDValue F = extractBooleanFlip(N0, DAG, TLI, false)) {\n    SDValue SelectOp = DAG.getSelect(DL, VT, F, N2, N1);\n    SelectOp->setFlags(Flags);\n    return SelectOp;\n  }\n\n  // Fold selects based on a setcc into other things, such as min/max/abs.\n  if (N0.getOpcode() == ISD::SETCC) {\n    SDValue Cond0 = N0.getOperand(0), Cond1 = N0.getOperand(1);\n    ISD::CondCode CC = cast<CondCodeSDNode>(N0.getOperand(2))->get();\n\n    // select (fcmp lt x, y), x, y -> fminnum x, y\n    // select (fcmp gt x, y), x, y -> fmaxnum x, y\n    //\n    // This is OK if we don't care what happens if either operand is a NaN.\n    if (N0.hasOneUse() && isLegalToCombineMinNumMaxNum(DAG, N1, N2, TLI))\n      if (SDValue FMinMax = combineMinNumMaxNum(DL, VT, Cond0, Cond1, N1, N2,\n                                                CC, TLI, DAG))\n        return FMinMax;\n\n    // Use 'unsigned add with overflow' to optimize an unsigned saturating add.\n    // This is conservatively limited to pre-legal-operations to give targets\n    // a chance to reverse the transform if they want to do that. Also, it is\n    // unlikely that the pattern would be formed late, so it's probably not\n    // worth going through the other checks.\n    if (!LegalOperations && TLI.isOperationLegalOrCustom(ISD::UADDO, VT) &&\n        CC == ISD::SETUGT && N0.hasOneUse() && isAllOnesConstant(N1) &&\n        N2.getOpcode() == ISD::ADD && Cond0 == N2.getOperand(0)) {\n      auto *C = dyn_cast<ConstantSDNode>(N2.getOperand(1));\n      auto *NotC = dyn_cast<ConstantSDNode>(Cond1);\n      if (C && NotC && C->getAPIntValue() == ~NotC->getAPIntValue()) {\n        // select (setcc Cond0, ~C, ugt), -1, (add Cond0, C) -->\n        // uaddo Cond0, C; select uaddo.1, -1, uaddo.0\n        //\n        // The IR equivalent of this transform would have this form:\n        //   %a = add %x, C\n        //   %c = icmp ugt %x, ~C\n        //   %r = select %c, -1, %a\n        //   =>\n        //   %u = call {iN,i1} llvm.uadd.with.overflow(%x, C)\n        //   %u0 = extractvalue %u, 0\n        //   %u1 = extractvalue %u, 1\n        //   %r = select %u1, -1, %u0\n        SDVTList VTs = DAG.getVTList(VT, VT0);\n        SDValue UAO = DAG.getNode(ISD::UADDO, DL, VTs, Cond0, N2.getOperand(1));\n        return DAG.getSelect(DL, VT, UAO.getValue(1), N1, UAO.getValue(0));\n      }\n    }\n\n    if (TLI.isOperationLegal(ISD::SELECT_CC, VT) ||\n        (!LegalOperations &&\n         TLI.isOperationLegalOrCustom(ISD::SELECT_CC, VT))) {\n      // Any flags available in a select/setcc fold will be on the setcc as they\n      // migrated from fcmp\n      Flags = N0.getNode()->getFlags();\n      SDValue SelectNode = DAG.getNode(ISD::SELECT_CC, DL, VT, Cond0, Cond1, N1,\n                                       N2, N0.getOperand(2));\n      SelectNode->setFlags(Flags);\n      return SelectNode;\n    }\n\n    return SimplifySelect(DL, N0, N1, N2);\n  }\n\n  return SDValue();\n}\n\n// This function assumes all the vselect's arguments are CONCAT_VECTOR\n// nodes and that the condition is a BV of ConstantSDNodes (or undefs).\nstatic SDValue ConvertSelectToConcatVector(SDNode *N, SelectionDAG &DAG) {\n  SDLoc DL(N);\n  SDValue Cond = N->getOperand(0);\n  SDValue LHS = N->getOperand(1);\n  SDValue RHS = N->getOperand(2);\n  EVT VT = N->getValueType(0);\n  int NumElems = VT.getVectorNumElements();\n  assert(LHS.getOpcode() == ISD::CONCAT_VECTORS &&\n         RHS.getOpcode() == ISD::CONCAT_VECTORS &&\n         Cond.getOpcode() == ISD::BUILD_VECTOR);\n\n  // CONCAT_VECTOR can take an arbitrary number of arguments. We only care about\n  // binary ones here.\n  if (LHS->getNumOperands() != 2 || RHS->getNumOperands() != 2)\n    return SDValue();\n\n  // We're sure we have an even number of elements due to the\n  // concat_vectors we have as arguments to vselect.\n  // Skip BV elements until we find one that's not an UNDEF\n  // After we find an UNDEF element, keep looping until we get to half the\n  // length of the BV and see if all the non-undef nodes are the same.\n  ConstantSDNode *BottomHalf = nullptr;\n  for (int i = 0; i < NumElems / 2; ++i) {\n    if (Cond->getOperand(i)->isUndef())\n      continue;\n\n    if (BottomHalf == nullptr)\n      BottomHalf = cast<ConstantSDNode>(Cond.getOperand(i));\n    else if (Cond->getOperand(i).getNode() != BottomHalf)\n      return SDValue();\n  }\n\n  // Do the same for the second half of the BuildVector\n  ConstantSDNode *TopHalf = nullptr;\n  for (int i = NumElems / 2; i < NumElems; ++i) {\n    if (Cond->getOperand(i)->isUndef())\n      continue;\n\n    if (TopHalf == nullptr)\n      TopHalf = cast<ConstantSDNode>(Cond.getOperand(i));\n    else if (Cond->getOperand(i).getNode() != TopHalf)\n      return SDValue();\n  }\n\n  assert(TopHalf && BottomHalf &&\n         \"One half of the selector was all UNDEFs and the other was all the \"\n         \"same value. This should have been addressed before this function.\");\n  return DAG.getNode(\n      ISD::CONCAT_VECTORS, DL, VT,\n      BottomHalf->isNullValue() ? RHS->getOperand(0) : LHS->getOperand(0),\n      TopHalf->isNullValue() ? RHS->getOperand(1) : LHS->getOperand(1));\n}\n\nbool refineUniformBase(SDValue &BasePtr, SDValue &Index, SelectionDAG &DAG) {\n  if (!isNullConstant(BasePtr) || Index.getOpcode() != ISD::ADD)\n    return false;\n\n  // For now we check only the LHS of the add.\n  SDValue LHS = Index.getOperand(0);\n  SDValue SplatVal = DAG.getSplatValue(LHS);\n  if (!SplatVal)\n    return false;\n\n  BasePtr = SplatVal;\n  Index = Index.getOperand(1);\n  return true;\n}\n\n// Fold sext/zext of index into index type.\nbool refineIndexType(MaskedGatherScatterSDNode *MGS, SDValue &Index,\n                     bool Scaled, SelectionDAG &DAG) {\n  const TargetLowering &TLI = DAG.getTargetLoweringInfo();\n\n  if (Index.getOpcode() == ISD::ZERO_EXTEND) {\n    SDValue Op = Index.getOperand(0);\n    MGS->setIndexType(Scaled ? ISD::UNSIGNED_SCALED : ISD::UNSIGNED_UNSCALED);\n    if (TLI.shouldRemoveExtendFromGSIndex(Op.getValueType())) {\n      Index = Op;\n      return true;\n    }\n  }\n\n  if (Index.getOpcode() == ISD::SIGN_EXTEND) {\n    SDValue Op = Index.getOperand(0);\n    MGS->setIndexType(Scaled ? ISD::SIGNED_SCALED : ISD::SIGNED_UNSCALED);\n    if (TLI.shouldRemoveExtendFromGSIndex(Op.getValueType())) {\n      Index = Op;\n      return true;\n    }\n  }\n\n  return false;\n}\n\nSDValue DAGCombiner::visitMSCATTER(SDNode *N) {\n  MaskedScatterSDNode *MSC = cast<MaskedScatterSDNode>(N);\n  SDValue Mask = MSC->getMask();\n  SDValue Chain = MSC->getChain();\n  SDValue Index = MSC->getIndex();\n  SDValue Scale = MSC->getScale();\n  SDValue StoreVal = MSC->getValue();\n  SDValue BasePtr = MSC->getBasePtr();\n  SDLoc DL(N);\n\n  // Zap scatters with a zero mask.\n  if (ISD::isConstantSplatVectorAllZeros(Mask.getNode()))\n    return Chain;\n\n  if (refineUniformBase(BasePtr, Index, DAG)) {\n    SDValue Ops[] = {Chain, StoreVal, Mask, BasePtr, Index, Scale};\n    return DAG.getMaskedScatter(\n        DAG.getVTList(MVT::Other), StoreVal.getValueType(), DL, Ops,\n        MSC->getMemOperand(), MSC->getIndexType(), MSC->isTruncatingStore());\n  }\n\n  if (refineIndexType(MSC, Index, MSC->isIndexScaled(), DAG)) {\n    SDValue Ops[] = {Chain, StoreVal, Mask, BasePtr, Index, Scale};\n    return DAG.getMaskedScatter(\n        DAG.getVTList(MVT::Other), StoreVal.getValueType(), DL, Ops,\n        MSC->getMemOperand(), MSC->getIndexType(), MSC->isTruncatingStore());\n  }\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitMSTORE(SDNode *N) {\n  MaskedStoreSDNode *MST = cast<MaskedStoreSDNode>(N);\n  SDValue Mask = MST->getMask();\n  SDValue Chain = MST->getChain();\n  SDLoc DL(N);\n\n  // Zap masked stores with a zero mask.\n  if (ISD::isConstantSplatVectorAllZeros(Mask.getNode()))\n    return Chain;\n\n  // If this is a masked load with an all ones mask, we can use a unmasked load.\n  // FIXME: Can we do this for indexed, compressing, or truncating stores?\n  if (ISD::isConstantSplatVectorAllOnes(Mask.getNode()) &&\n      MST->isUnindexed() && !MST->isCompressingStore() &&\n      !MST->isTruncatingStore())\n    return DAG.getStore(MST->getChain(), SDLoc(N), MST->getValue(),\n                        MST->getBasePtr(), MST->getMemOperand());\n\n  // Try transforming N to an indexed store.\n  if (CombineToPreIndexedLoadStore(N) || CombineToPostIndexedLoadStore(N))\n    return SDValue(N, 0);\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitMGATHER(SDNode *N) {\n  MaskedGatherSDNode *MGT = cast<MaskedGatherSDNode>(N);\n  SDValue Mask = MGT->getMask();\n  SDValue Chain = MGT->getChain();\n  SDValue Index = MGT->getIndex();\n  SDValue Scale = MGT->getScale();\n  SDValue PassThru = MGT->getPassThru();\n  SDValue BasePtr = MGT->getBasePtr();\n  SDLoc DL(N);\n\n  // Zap gathers with a zero mask.\n  if (ISD::isConstantSplatVectorAllZeros(Mask.getNode()))\n    return CombineTo(N, PassThru, MGT->getChain());\n\n  if (refineUniformBase(BasePtr, Index, DAG)) {\n    SDValue Ops[] = {Chain, PassThru, Mask, BasePtr, Index, Scale};\n    return DAG.getMaskedGather(DAG.getVTList(N->getValueType(0), MVT::Other),\n                               PassThru.getValueType(), DL, Ops,\n                               MGT->getMemOperand(), MGT->getIndexType(),\n                               MGT->getExtensionType());\n  }\n\n  if (refineIndexType(MGT, Index, MGT->isIndexScaled(), DAG)) {\n    SDValue Ops[] = {Chain, PassThru, Mask, BasePtr, Index, Scale};\n    return DAG.getMaskedGather(DAG.getVTList(N->getValueType(0), MVT::Other),\n                               PassThru.getValueType(), DL, Ops,\n                               MGT->getMemOperand(), MGT->getIndexType(),\n                               MGT->getExtensionType());\n  }\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitMLOAD(SDNode *N) {\n  MaskedLoadSDNode *MLD = cast<MaskedLoadSDNode>(N);\n  SDValue Mask = MLD->getMask();\n  SDLoc DL(N);\n\n  // Zap masked loads with a zero mask.\n  if (ISD::isConstantSplatVectorAllZeros(Mask.getNode()))\n    return CombineTo(N, MLD->getPassThru(), MLD->getChain());\n\n  // If this is a masked load with an all ones mask, we can use a unmasked load.\n  // FIXME: Can we do this for indexed, expanding, or extending loads?\n  if (ISD::isConstantSplatVectorAllOnes(Mask.getNode()) &&\n      MLD->isUnindexed() && !MLD->isExpandingLoad() &&\n      MLD->getExtensionType() == ISD::NON_EXTLOAD) {\n    SDValue NewLd = DAG.getLoad(N->getValueType(0), SDLoc(N), MLD->getChain(),\n                                MLD->getBasePtr(), MLD->getMemOperand());\n    return CombineTo(N, NewLd, NewLd.getValue(1));\n  }\n\n  // Try transforming N to an indexed load.\n  if (CombineToPreIndexedLoadStore(N) || CombineToPostIndexedLoadStore(N))\n    return SDValue(N, 0);\n\n  return SDValue();\n}\n\n/// A vector select of 2 constant vectors can be simplified to math/logic to\n/// avoid a variable select instruction and possibly avoid constant loads.\nSDValue DAGCombiner::foldVSelectOfConstants(SDNode *N) {\n  SDValue Cond = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  SDValue N2 = N->getOperand(2);\n  EVT VT = N->getValueType(0);\n  if (!Cond.hasOneUse() || Cond.getScalarValueSizeInBits() != 1 ||\n      !TLI.convertSelectOfConstantsToMath(VT) ||\n      !ISD::isBuildVectorOfConstantSDNodes(N1.getNode()) ||\n      !ISD::isBuildVectorOfConstantSDNodes(N2.getNode()))\n    return SDValue();\n\n  // Check if we can use the condition value to increment/decrement a single\n  // constant value. This simplifies a select to an add and removes a constant\n  // load/materialization from the general case.\n  bool AllAddOne = true;\n  bool AllSubOne = true;\n  unsigned Elts = VT.getVectorNumElements();\n  for (unsigned i = 0; i != Elts; ++i) {\n    SDValue N1Elt = N1.getOperand(i);\n    SDValue N2Elt = N2.getOperand(i);\n    if (N1Elt.isUndef() || N2Elt.isUndef())\n      continue;\n    if (N1Elt.getValueType() != N2Elt.getValueType())\n      continue;\n\n    const APInt &C1 = cast<ConstantSDNode>(N1Elt)->getAPIntValue();\n    const APInt &C2 = cast<ConstantSDNode>(N2Elt)->getAPIntValue();\n    if (C1 != C2 + 1)\n      AllAddOne = false;\n    if (C1 != C2 - 1)\n      AllSubOne = false;\n  }\n\n  // Further simplifications for the extra-special cases where the constants are\n  // all 0 or all -1 should be implemented as folds of these patterns.\n  SDLoc DL(N);\n  if (AllAddOne || AllSubOne) {\n    // vselect <N x i1> Cond, C+1, C --> add (zext Cond), C\n    // vselect <N x i1> Cond, C-1, C --> add (sext Cond), C\n    auto ExtendOpcode = AllAddOne ? ISD::ZERO_EXTEND : ISD::SIGN_EXTEND;\n    SDValue ExtendedCond = DAG.getNode(ExtendOpcode, DL, VT, Cond);\n    return DAG.getNode(ISD::ADD, DL, VT, ExtendedCond, N2);\n  }\n\n  // select Cond, Pow2C, 0 --> (zext Cond) << log2(Pow2C)\n  APInt Pow2C;\n  if (ISD::isConstantSplatVector(N1.getNode(), Pow2C) && Pow2C.isPowerOf2() &&\n      isNullOrNullSplat(N2)) {\n    SDValue ZextCond = DAG.getZExtOrTrunc(Cond, DL, VT);\n    SDValue ShAmtC = DAG.getConstant(Pow2C.exactLogBase2(), DL, VT);\n    return DAG.getNode(ISD::SHL, DL, VT, ZextCond, ShAmtC);\n  }\n\n  if (SDValue V = foldSelectOfConstantsUsingSra(N, DAG))\n    return V;\n\n  // The general case for select-of-constants:\n  // vselect <N x i1> Cond, C1, C2 --> xor (and (sext Cond), (C1^C2)), C2\n  // ...but that only makes sense if a vselect is slower than 2 logic ops, so\n  // leave that to a machine-specific pass.\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitVSELECT(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  SDValue N2 = N->getOperand(2);\n  EVT VT = N->getValueType(0);\n  SDLoc DL(N);\n\n  if (SDValue V = DAG.simplifySelect(N0, N1, N2))\n    return V;\n\n  if (SDValue V = foldBoolSelectToLogic(N, DAG))\n    return V;\n\n  // vselect (not Cond), N1, N2 -> vselect Cond, N2, N1\n  if (SDValue F = extractBooleanFlip(N0, DAG, TLI, false))\n    return DAG.getSelect(DL, VT, F, N2, N1);\n\n  // Canonicalize integer abs.\n  // vselect (setg[te] X,  0),  X, -X ->\n  // vselect (setgt    X, -1),  X, -X ->\n  // vselect (setl[te] X,  0), -X,  X ->\n  // Y = sra (X, size(X)-1); xor (add (X, Y), Y)\n  if (N0.getOpcode() == ISD::SETCC) {\n    SDValue LHS = N0.getOperand(0), RHS = N0.getOperand(1);\n    ISD::CondCode CC = cast<CondCodeSDNode>(N0.getOperand(2))->get();\n    bool isAbs = false;\n    bool RHSIsAllZeros = ISD::isBuildVectorAllZeros(RHS.getNode());\n\n    if (((RHSIsAllZeros && (CC == ISD::SETGT || CC == ISD::SETGE)) ||\n         (ISD::isBuildVectorAllOnes(RHS.getNode()) && CC == ISD::SETGT)) &&\n        N1 == LHS && N2.getOpcode() == ISD::SUB && N1 == N2.getOperand(1))\n      isAbs = ISD::isBuildVectorAllZeros(N2.getOperand(0).getNode());\n    else if ((RHSIsAllZeros && (CC == ISD::SETLT || CC == ISD::SETLE)) &&\n             N2 == LHS && N1.getOpcode() == ISD::SUB && N2 == N1.getOperand(1))\n      isAbs = ISD::isBuildVectorAllZeros(N1.getOperand(0).getNode());\n\n    if (isAbs) {\n      if (TLI.isOperationLegalOrCustom(ISD::ABS, VT))\n        return DAG.getNode(ISD::ABS, DL, VT, LHS);\n\n      SDValue Shift = DAG.getNode(ISD::SRA, DL, VT, LHS,\n                                  DAG.getConstant(VT.getScalarSizeInBits() - 1,\n                                                  DL, getShiftAmountTy(VT)));\n      SDValue Add = DAG.getNode(ISD::ADD, DL, VT, LHS, Shift);\n      AddToWorklist(Shift.getNode());\n      AddToWorklist(Add.getNode());\n      return DAG.getNode(ISD::XOR, DL, VT, Add, Shift);\n    }\n\n    // vselect x, y (fcmp lt x, y) -> fminnum x, y\n    // vselect x, y (fcmp gt x, y) -> fmaxnum x, y\n    //\n    // This is OK if we don't care about what happens if either operand is a\n    // NaN.\n    //\n    if (N0.hasOneUse() && isLegalToCombineMinNumMaxNum(DAG, LHS, RHS, TLI)) {\n      if (SDValue FMinMax =\n              combineMinNumMaxNum(DL, VT, LHS, RHS, N1, N2, CC, TLI, DAG))\n        return FMinMax;\n    }\n\n    // If this select has a condition (setcc) with narrower operands than the\n    // select, try to widen the compare to match the select width.\n    // TODO: This should be extended to handle any constant.\n    // TODO: This could be extended to handle non-loading patterns, but that\n    //       requires thorough testing to avoid regressions.\n    if (isNullOrNullSplat(RHS)) {\n      EVT NarrowVT = LHS.getValueType();\n      EVT WideVT = N1.getValueType().changeVectorElementTypeToInteger();\n      EVT SetCCVT = getSetCCResultType(LHS.getValueType());\n      unsigned SetCCWidth = SetCCVT.getScalarSizeInBits();\n      unsigned WideWidth = WideVT.getScalarSizeInBits();\n      bool IsSigned = isSignedIntSetCC(CC);\n      auto LoadExtOpcode = IsSigned ? ISD::SEXTLOAD : ISD::ZEXTLOAD;\n      if (LHS.getOpcode() == ISD::LOAD && LHS.hasOneUse() &&\n          SetCCWidth != 1 && SetCCWidth < WideWidth &&\n          TLI.isLoadExtLegalOrCustom(LoadExtOpcode, WideVT, NarrowVT) &&\n          TLI.isOperationLegalOrCustom(ISD::SETCC, WideVT)) {\n        // Both compare operands can be widened for free. The LHS can use an\n        // extended load, and the RHS is a constant:\n        //   vselect (ext (setcc load(X), C)), N1, N2 -->\n        //   vselect (setcc extload(X), C'), N1, N2\n        auto ExtOpcode = IsSigned ? ISD::SIGN_EXTEND : ISD::ZERO_EXTEND;\n        SDValue WideLHS = DAG.getNode(ExtOpcode, DL, WideVT, LHS);\n        SDValue WideRHS = DAG.getNode(ExtOpcode, DL, WideVT, RHS);\n        EVT WideSetCCVT = getSetCCResultType(WideVT);\n        SDValue WideSetCC = DAG.getSetCC(DL, WideSetCCVT, WideLHS, WideRHS, CC);\n        return DAG.getSelect(DL, N1.getValueType(), WideSetCC, N1, N2);\n      }\n    }\n\n    // Match VSELECTs into add with unsigned saturation.\n    if (hasOperation(ISD::UADDSAT, VT)) {\n      // Check if one of the arms of the VSELECT is vector with all bits set.\n      // If it's on the left side invert the predicate to simplify logic below.\n      SDValue Other;\n      ISD::CondCode SatCC = CC;\n      if (ISD::isBuildVectorAllOnes(N1.getNode())) {\n        Other = N2;\n        SatCC = ISD::getSetCCInverse(SatCC, VT.getScalarType());\n      } else if (ISD::isBuildVectorAllOnes(N2.getNode())) {\n        Other = N1;\n      }\n\n      if (Other && Other.getOpcode() == ISD::ADD) {\n        SDValue CondLHS = LHS, CondRHS = RHS;\n        SDValue OpLHS = Other.getOperand(0), OpRHS = Other.getOperand(1);\n\n        // Canonicalize condition operands.\n        if (SatCC == ISD::SETUGE) {\n          std::swap(CondLHS, CondRHS);\n          SatCC = ISD::SETULE;\n        }\n\n        // We can test against either of the addition operands.\n        // x <= x+y ? x+y : ~0 --> uaddsat x, y\n        // x+y >= x ? x+y : ~0 --> uaddsat x, y\n        if (SatCC == ISD::SETULE && Other == CondRHS &&\n            (OpLHS == CondLHS || OpRHS == CondLHS))\n          return DAG.getNode(ISD::UADDSAT, DL, VT, OpLHS, OpRHS);\n\n        if (isa<BuildVectorSDNode>(OpRHS) && isa<BuildVectorSDNode>(CondRHS) &&\n            CondLHS == OpLHS) {\n          // If the RHS is a constant we have to reverse the const\n          // canonicalization.\n          // x >= ~C ? x+C : ~0 --> uaddsat x, C\n          auto MatchUADDSAT = [](ConstantSDNode *Op, ConstantSDNode *Cond) {\n            return Cond->getAPIntValue() == ~Op->getAPIntValue();\n          };\n          if (SatCC == ISD::SETULE &&\n              ISD::matchBinaryPredicate(OpRHS, CondRHS, MatchUADDSAT))\n            return DAG.getNode(ISD::UADDSAT, DL, VT, OpLHS, OpRHS);\n        }\n      }\n    }\n\n    // Match VSELECTs into sub with unsigned saturation.\n    if (hasOperation(ISD::USUBSAT, VT)) {\n      // Check if one of the arms of the VSELECT is a zero vector. If it's on\n      // the left side invert the predicate to simplify logic below.\n      SDValue Other;\n      ISD::CondCode SatCC = CC;\n      if (ISD::isBuildVectorAllZeros(N1.getNode())) {\n        Other = N2;\n        SatCC = ISD::getSetCCInverse(SatCC, VT.getScalarType());\n      } else if (ISD::isBuildVectorAllZeros(N2.getNode())) {\n        Other = N1;\n      }\n\n      if (Other && Other.getNumOperands() == 2) {\n        SDValue CondRHS = RHS;\n        SDValue OpLHS = Other.getOperand(0), OpRHS = Other.getOperand(1);\n\n        if (Other.getOpcode() == ISD::SUB &&\n            LHS.getOpcode() == ISD::ZERO_EXTEND && LHS.getOperand(0) == OpLHS &&\n            OpRHS.getOpcode() == ISD::TRUNCATE && OpRHS.getOperand(0) == RHS) {\n          // Look for a general sub with unsigned saturation first.\n          // zext(x) >= y ? x - trunc(y) : 0\n          // --> usubsat(x,trunc(umin(y,SatLimit)))\n          // zext(x) >  y ? x - trunc(y) : 0\n          // --> usubsat(x,trunc(umin(y,SatLimit)))\n          if (SatCC == ISD::SETUGE || SatCC == ISD::SETUGT)\n            return getTruncatedUSUBSAT(VT, LHS.getValueType(), LHS, RHS, DAG,\n                                       DL);\n        }\n\n        if (OpLHS == LHS) {\n          // Look for a general sub with unsigned saturation first.\n          // x >= y ? x-y : 0 --> usubsat x, y\n          // x >  y ? x-y : 0 --> usubsat x, y\n          if ((SatCC == ISD::SETUGE || SatCC == ISD::SETUGT) &&\n              Other.getOpcode() == ISD::SUB && OpRHS == CondRHS)\n            return DAG.getNode(ISD::USUBSAT, DL, VT, OpLHS, OpRHS);\n\n          if (auto *OpRHSBV = dyn_cast<BuildVectorSDNode>(OpRHS)) {\n            if (isa<BuildVectorSDNode>(CondRHS)) {\n              // If the RHS is a constant we have to reverse the const\n              // canonicalization.\n              // x > C-1 ? x+-C : 0 --> usubsat x, C\n              auto MatchUSUBSAT = [](ConstantSDNode *Op, ConstantSDNode *Cond) {\n                return (!Op && !Cond) ||\n                       (Op && Cond &&\n                        Cond->getAPIntValue() == (-Op->getAPIntValue() - 1));\n              };\n              if (SatCC == ISD::SETUGT && Other.getOpcode() == ISD::ADD &&\n                  ISD::matchBinaryPredicate(OpRHS, CondRHS, MatchUSUBSAT,\n                                            /*AllowUndefs*/ true)) {\n                OpRHS = DAG.getNode(ISD::SUB, DL, VT,\n                                    DAG.getConstant(0, DL, VT), OpRHS);\n                return DAG.getNode(ISD::USUBSAT, DL, VT, OpLHS, OpRHS);\n              }\n\n              // Another special case: If C was a sign bit, the sub has been\n              // canonicalized into a xor.\n              // FIXME: Would it be better to use computeKnownBits to determine\n              //        whether it's safe to decanonicalize the xor?\n              // x s< 0 ? x^C : 0 --> usubsat x, C\n              if (auto *OpRHSConst = OpRHSBV->getConstantSplatNode()) {\n                if (SatCC == ISD::SETLT && Other.getOpcode() == ISD::XOR &&\n                    ISD::isBuildVectorAllZeros(CondRHS.getNode()) &&\n                    OpRHSConst->getAPIntValue().isSignMask()) {\n                  // Note that we have to rebuild the RHS constant here to\n                  // ensure we don't rely on particular values of undef lanes.\n                  OpRHS = DAG.getConstant(OpRHSConst->getAPIntValue(), DL, VT);\n                  return DAG.getNode(ISD::USUBSAT, DL, VT, OpLHS, OpRHS);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  if (SimplifySelectOps(N, N1, N2))\n    return SDValue(N, 0);  // Don't revisit N.\n\n  // Fold (vselect (build_vector all_ones), N1, N2) -> N1\n  if (ISD::isBuildVectorAllOnes(N0.getNode()))\n    return N1;\n  // Fold (vselect (build_vector all_zeros), N1, N2) -> N2\n  if (ISD::isBuildVectorAllZeros(N0.getNode()))\n    return N2;\n\n  // The ConvertSelectToConcatVector function is assuming both the above\n  // checks for (vselect (build_vector all{ones,zeros) ...) have been made\n  // and addressed.\n  if (N1.getOpcode() == ISD::CONCAT_VECTORS &&\n      N2.getOpcode() == ISD::CONCAT_VECTORS &&\n      ISD::isBuildVectorOfConstantSDNodes(N0.getNode())) {\n    if (SDValue CV = ConvertSelectToConcatVector(N, DAG))\n      return CV;\n  }\n\n  if (SDValue V = foldVSelectOfConstants(N))\n    return V;\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitSELECT_CC(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  SDValue N2 = N->getOperand(2);\n  SDValue N3 = N->getOperand(3);\n  SDValue N4 = N->getOperand(4);\n  ISD::CondCode CC = cast<CondCodeSDNode>(N4)->get();\n\n  // fold select_cc lhs, rhs, x, x, cc -> x\n  if (N2 == N3)\n    return N2;\n\n  // Determine if the condition we're dealing with is constant\n  if (SDValue SCC = SimplifySetCC(getSetCCResultType(N0.getValueType()), N0, N1,\n                                  CC, SDLoc(N), false)) {\n    AddToWorklist(SCC.getNode());\n\n    if (ConstantSDNode *SCCC = dyn_cast<ConstantSDNode>(SCC.getNode())) {\n      if (!SCCC->isNullValue())\n        return N2;    // cond always true -> true val\n      else\n        return N3;    // cond always false -> false val\n    } else if (SCC->isUndef()) {\n      // When the condition is UNDEF, just return the first operand. This is\n      // coherent the DAG creation, no setcc node is created in this case\n      return N2;\n    } else if (SCC.getOpcode() == ISD::SETCC) {\n      // Fold to a simpler select_cc\n      SDValue SelectOp = DAG.getNode(\n          ISD::SELECT_CC, SDLoc(N), N2.getValueType(), SCC.getOperand(0),\n          SCC.getOperand(1), N2, N3, SCC.getOperand(2));\n      SelectOp->setFlags(SCC->getFlags());\n      return SelectOp;\n    }\n  }\n\n  // If we can fold this based on the true/false value, do so.\n  if (SimplifySelectOps(N, N2, N3))\n    return SDValue(N, 0);  // Don't revisit N.\n\n  // fold select_cc into other things, such as min/max/abs\n  return SimplifySelectCC(SDLoc(N), N0, N1, N2, N3, CC);\n}\n\nSDValue DAGCombiner::visitSETCC(SDNode *N) {\n  // setcc is very commonly used as an argument to brcond. This pattern\n  // also lend itself to numerous combines and, as a result, it is desired\n  // we keep the argument to a brcond as a setcc as much as possible.\n  bool PreferSetCC =\n      N->hasOneUse() && N->use_begin()->getOpcode() == ISD::BRCOND;\n\n  SDValue Combined = SimplifySetCC(\n      N->getValueType(0), N->getOperand(0), N->getOperand(1),\n      cast<CondCodeSDNode>(N->getOperand(2))->get(), SDLoc(N), !PreferSetCC);\n\n  if (!Combined)\n    return SDValue();\n\n  // If we prefer to have a setcc, and we don't, we'll try our best to\n  // recreate one using rebuildSetCC.\n  if (PreferSetCC && Combined.getOpcode() != ISD::SETCC) {\n    SDValue NewSetCC = rebuildSetCC(Combined);\n\n    // We don't have anything interesting to combine to.\n    if (NewSetCC.getNode() == N)\n      return SDValue();\n\n    if (NewSetCC)\n      return NewSetCC;\n  }\n\n  return Combined;\n}\n\nSDValue DAGCombiner::visitSETCCCARRY(SDNode *N) {\n  SDValue LHS = N->getOperand(0);\n  SDValue RHS = N->getOperand(1);\n  SDValue Carry = N->getOperand(2);\n  SDValue Cond = N->getOperand(3);\n\n  // If Carry is false, fold to a regular SETCC.\n  if (isNullConstant(Carry))\n    return DAG.getNode(ISD::SETCC, SDLoc(N), N->getVTList(), LHS, RHS, Cond);\n\n  return SDValue();\n}\n\n/// Check if N satisfies:\n///   N is used once.\n///   N is a Load.\n///   The load is compatible with ExtOpcode. It means\n///     If load has explicit zero/sign extension, ExpOpcode must have the same\n///     extension.\n///     Otherwise returns true.\nstatic bool isCompatibleLoad(SDValue N, unsigned ExtOpcode) {\n  if (!N.hasOneUse())\n    return false;\n\n  if (!isa<LoadSDNode>(N))\n    return false;\n\n  LoadSDNode *Load = cast<LoadSDNode>(N);\n  ISD::LoadExtType LoadExt = Load->getExtensionType();\n  if (LoadExt == ISD::NON_EXTLOAD || LoadExt == ISD::EXTLOAD)\n    return true;\n\n  // Now LoadExt is either SEXTLOAD or ZEXTLOAD, ExtOpcode must have the same\n  // extension.\n  if ((LoadExt == ISD::SEXTLOAD && ExtOpcode != ISD::SIGN_EXTEND) ||\n      (LoadExt == ISD::ZEXTLOAD && ExtOpcode != ISD::ZERO_EXTEND))\n    return false;\n\n  return true;\n}\n\n/// Fold\n///   (sext (select c, load x, load y)) -> (select c, sextload x, sextload y)\n///   (zext (select c, load x, load y)) -> (select c, zextload x, zextload y)\n///   (aext (select c, load x, load y)) -> (select c, extload x, extload y)\n/// This function is called by the DAGCombiner when visiting sext/zext/aext\n/// dag nodes (see for example method DAGCombiner::visitSIGN_EXTEND).\nstatic SDValue tryToFoldExtendSelectLoad(SDNode *N, const TargetLowering &TLI,\n                                         SelectionDAG &DAG) {\n  unsigned Opcode = N->getOpcode();\n  SDValue N0 = N->getOperand(0);\n  EVT VT = N->getValueType(0);\n  SDLoc DL(N);\n\n  assert((Opcode == ISD::SIGN_EXTEND || Opcode == ISD::ZERO_EXTEND ||\n          Opcode == ISD::ANY_EXTEND) &&\n         \"Expected EXTEND dag node in input!\");\n\n  if (!(N0->getOpcode() == ISD::SELECT || N0->getOpcode() == ISD::VSELECT) ||\n      !N0.hasOneUse())\n    return SDValue();\n\n  SDValue Op1 = N0->getOperand(1);\n  SDValue Op2 = N0->getOperand(2);\n  if (!isCompatibleLoad(Op1, Opcode) || !isCompatibleLoad(Op2, Opcode))\n    return SDValue();\n\n  auto ExtLoadOpcode = ISD::EXTLOAD;\n  if (Opcode == ISD::SIGN_EXTEND)\n    ExtLoadOpcode = ISD::SEXTLOAD;\n  else if (Opcode == ISD::ZERO_EXTEND)\n    ExtLoadOpcode = ISD::ZEXTLOAD;\n\n  LoadSDNode *Load1 = cast<LoadSDNode>(Op1);\n  LoadSDNode *Load2 = cast<LoadSDNode>(Op2);\n  if (!TLI.isLoadExtLegal(ExtLoadOpcode, VT, Load1->getMemoryVT()) ||\n      !TLI.isLoadExtLegal(ExtLoadOpcode, VT, Load2->getMemoryVT()))\n    return SDValue();\n\n  SDValue Ext1 = DAG.getNode(Opcode, DL, VT, Op1);\n  SDValue Ext2 = DAG.getNode(Opcode, DL, VT, Op2);\n  return DAG.getSelect(DL, VT, N0->getOperand(0), Ext1, Ext2);\n}\n\n/// Try to fold a sext/zext/aext dag node into a ConstantSDNode or\n/// a build_vector of constants.\n/// This function is called by the DAGCombiner when visiting sext/zext/aext\n/// dag nodes (see for example method DAGCombiner::visitSIGN_EXTEND).\n/// Vector extends are not folded if operations are legal; this is to\n/// avoid introducing illegal build_vector dag nodes.\nstatic SDValue tryToFoldExtendOfConstant(SDNode *N, const TargetLowering &TLI,\n                                         SelectionDAG &DAG, bool LegalTypes) {\n  unsigned Opcode = N->getOpcode();\n  SDValue N0 = N->getOperand(0);\n  EVT VT = N->getValueType(0);\n  SDLoc DL(N);\n\n  assert((Opcode == ISD::SIGN_EXTEND || Opcode == ISD::ZERO_EXTEND ||\n         Opcode == ISD::ANY_EXTEND || Opcode == ISD::SIGN_EXTEND_VECTOR_INREG ||\n         Opcode == ISD::ZERO_EXTEND_VECTOR_INREG)\n         && \"Expected EXTEND dag node in input!\");\n\n  // fold (sext c1) -> c1\n  // fold (zext c1) -> c1\n  // fold (aext c1) -> c1\n  if (isa<ConstantSDNode>(N0))\n    return DAG.getNode(Opcode, DL, VT, N0);\n\n  // fold (sext (select cond, c1, c2)) -> (select cond, sext c1, sext c2)\n  // fold (zext (select cond, c1, c2)) -> (select cond, zext c1, zext c2)\n  // fold (aext (select cond, c1, c2)) -> (select cond, sext c1, sext c2)\n  if (N0->getOpcode() == ISD::SELECT) {\n    SDValue Op1 = N0->getOperand(1);\n    SDValue Op2 = N0->getOperand(2);\n    if (isa<ConstantSDNode>(Op1) && isa<ConstantSDNode>(Op2) &&\n        (Opcode != ISD::ZERO_EXTEND || !TLI.isZExtFree(N0.getValueType(), VT))) {\n      // For any_extend, choose sign extension of the constants to allow a\n      // possible further transform to sign_extend_inreg.i.e.\n      //\n      // t1: i8 = select t0, Constant:i8<-1>, Constant:i8<0>\n      // t2: i64 = any_extend t1\n      // -->\n      // t3: i64 = select t0, Constant:i64<-1>, Constant:i64<0>\n      // -->\n      // t4: i64 = sign_extend_inreg t3\n      unsigned FoldOpc = Opcode;\n      if (FoldOpc == ISD::ANY_EXTEND)\n        FoldOpc = ISD::SIGN_EXTEND;\n      return DAG.getSelect(DL, VT, N0->getOperand(0),\n                           DAG.getNode(FoldOpc, DL, VT, Op1),\n                           DAG.getNode(FoldOpc, DL, VT, Op2));\n    }\n  }\n\n  // fold (sext (build_vector AllConstants) -> (build_vector AllConstants)\n  // fold (zext (build_vector AllConstants) -> (build_vector AllConstants)\n  // fold (aext (build_vector AllConstants) -> (build_vector AllConstants)\n  EVT SVT = VT.getScalarType();\n  if (!(VT.isVector() && (!LegalTypes || TLI.isTypeLegal(SVT)) &&\n      ISD::isBuildVectorOfConstantSDNodes(N0.getNode())))\n    return SDValue();\n\n  // We can fold this node into a build_vector.\n  unsigned VTBits = SVT.getSizeInBits();\n  unsigned EVTBits = N0->getValueType(0).getScalarSizeInBits();\n  SmallVector<SDValue, 8> Elts;\n  unsigned NumElts = VT.getVectorNumElements();\n\n  // For zero-extensions, UNDEF elements still guarantee to have the upper\n  // bits set to zero.\n  bool IsZext =\n      Opcode == ISD::ZERO_EXTEND || Opcode == ISD::ZERO_EXTEND_VECTOR_INREG;\n\n  for (unsigned i = 0; i != NumElts; ++i) {\n    SDValue Op = N0.getOperand(i);\n    if (Op.isUndef()) {\n      Elts.push_back(IsZext ? DAG.getConstant(0, DL, SVT) : DAG.getUNDEF(SVT));\n      continue;\n    }\n\n    SDLoc DL(Op);\n    // Get the constant value and if needed trunc it to the size of the type.\n    // Nodes like build_vector might have constants wider than the scalar type.\n    APInt C = cast<ConstantSDNode>(Op)->getAPIntValue().zextOrTrunc(EVTBits);\n    if (Opcode == ISD::SIGN_EXTEND || Opcode == ISD::SIGN_EXTEND_VECTOR_INREG)\n      Elts.push_back(DAG.getConstant(C.sext(VTBits), DL, SVT));\n    else\n      Elts.push_back(DAG.getConstant(C.zext(VTBits), DL, SVT));\n  }\n\n  return DAG.getBuildVector(VT, DL, Elts);\n}\n\n// ExtendUsesToFormExtLoad - Trying to extend uses of a load to enable this:\n// \"fold ({s|z|a}ext (load x)) -> ({s|z|a}ext (truncate ({s|z|a}extload x)))\"\n// transformation. Returns true if extension are possible and the above\n// mentioned transformation is profitable.\nstatic bool ExtendUsesToFormExtLoad(EVT VT, SDNode *N, SDValue N0,\n                                    unsigned ExtOpc,\n                                    SmallVectorImpl<SDNode *> &ExtendNodes,\n                                    const TargetLowering &TLI) {\n  bool HasCopyToRegUses = false;\n  bool isTruncFree = TLI.isTruncateFree(VT, N0.getValueType());\n  for (SDNode::use_iterator UI = N0.getNode()->use_begin(),\n                            UE = N0.getNode()->use_end();\n       UI != UE; ++UI) {\n    SDNode *User = *UI;\n    if (User == N)\n      continue;\n    if (UI.getUse().getResNo() != N0.getResNo())\n      continue;\n    // FIXME: Only extend SETCC N, N and SETCC N, c for now.\n    if (ExtOpc != ISD::ANY_EXTEND && User->getOpcode() == ISD::SETCC) {\n      ISD::CondCode CC = cast<CondCodeSDNode>(User->getOperand(2))->get();\n      if (ExtOpc == ISD::ZERO_EXTEND && ISD::isSignedIntSetCC(CC))\n        // Sign bits will be lost after a zext.\n        return false;\n      bool Add = false;\n      for (unsigned i = 0; i != 2; ++i) {\n        SDValue UseOp = User->getOperand(i);\n        if (UseOp == N0)\n          continue;\n        if (!isa<ConstantSDNode>(UseOp))\n          return false;\n        Add = true;\n      }\n      if (Add)\n        ExtendNodes.push_back(User);\n      continue;\n    }\n    // If truncates aren't free and there are users we can't\n    // extend, it isn't worthwhile.\n    if (!isTruncFree)\n      return false;\n    // Remember if this value is live-out.\n    if (User->getOpcode() == ISD::CopyToReg)\n      HasCopyToRegUses = true;\n  }\n\n  if (HasCopyToRegUses) {\n    bool BothLiveOut = false;\n    for (SDNode::use_iterator UI = N->use_begin(), UE = N->use_end();\n         UI != UE; ++UI) {\n      SDUse &Use = UI.getUse();\n      if (Use.getResNo() == 0 && Use.getUser()->getOpcode() == ISD::CopyToReg) {\n        BothLiveOut = true;\n        break;\n      }\n    }\n    if (BothLiveOut)\n      // Both unextended and extended values are live out. There had better be\n      // a good reason for the transformation.\n      return ExtendNodes.size();\n  }\n  return true;\n}\n\nvoid DAGCombiner::ExtendSetCCUses(const SmallVectorImpl<SDNode *> &SetCCs,\n                                  SDValue OrigLoad, SDValue ExtLoad,\n                                  ISD::NodeType ExtType) {\n  // Extend SetCC uses if necessary.\n  SDLoc DL(ExtLoad);\n  for (SDNode *SetCC : SetCCs) {\n    SmallVector<SDValue, 4> Ops;\n\n    for (unsigned j = 0; j != 2; ++j) {\n      SDValue SOp = SetCC->getOperand(j);\n      if (SOp == OrigLoad)\n        Ops.push_back(ExtLoad);\n      else\n        Ops.push_back(DAG.getNode(ExtType, DL, ExtLoad->getValueType(0), SOp));\n    }\n\n    Ops.push_back(SetCC->getOperand(2));\n    CombineTo(SetCC, DAG.getNode(ISD::SETCC, DL, SetCC->getValueType(0), Ops));\n  }\n}\n\n// FIXME: Bring more similar combines here, common to sext/zext (maybe aext?).\nSDValue DAGCombiner::CombineExtLoad(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  EVT DstVT = N->getValueType(0);\n  EVT SrcVT = N0.getValueType();\n\n  assert((N->getOpcode() == ISD::SIGN_EXTEND ||\n          N->getOpcode() == ISD::ZERO_EXTEND) &&\n         \"Unexpected node type (not an extend)!\");\n\n  // fold (sext (load x)) to multiple smaller sextloads; same for zext.\n  // For example, on a target with legal v4i32, but illegal v8i32, turn:\n  //   (v8i32 (sext (v8i16 (load x))))\n  // into:\n  //   (v8i32 (concat_vectors (v4i32 (sextload x)),\n  //                          (v4i32 (sextload (x + 16)))))\n  // Where uses of the original load, i.e.:\n  //   (v8i16 (load x))\n  // are replaced with:\n  //   (v8i16 (truncate\n  //     (v8i32 (concat_vectors (v4i32 (sextload x)),\n  //                            (v4i32 (sextload (x + 16)))))))\n  //\n  // This combine is only applicable to illegal, but splittable, vectors.\n  // All legal types, and illegal non-vector types, are handled elsewhere.\n  // This combine is controlled by TargetLowering::isVectorLoadExtDesirable.\n  //\n  if (N0->getOpcode() != ISD::LOAD)\n    return SDValue();\n\n  LoadSDNode *LN0 = cast<LoadSDNode>(N0);\n\n  if (!ISD::isNON_EXTLoad(LN0) || !ISD::isUNINDEXEDLoad(LN0) ||\n      !N0.hasOneUse() || !LN0->isSimple() ||\n      !DstVT.isVector() || !DstVT.isPow2VectorType() ||\n      !TLI.isVectorLoadExtDesirable(SDValue(N, 0)))\n    return SDValue();\n\n  SmallVector<SDNode *, 4> SetCCs;\n  if (!ExtendUsesToFormExtLoad(DstVT, N, N0, N->getOpcode(), SetCCs, TLI))\n    return SDValue();\n\n  ISD::LoadExtType ExtType =\n      N->getOpcode() == ISD::SIGN_EXTEND ? ISD::SEXTLOAD : ISD::ZEXTLOAD;\n\n  // Try to split the vector types to get down to legal types.\n  EVT SplitSrcVT = SrcVT;\n  EVT SplitDstVT = DstVT;\n  while (!TLI.isLoadExtLegalOrCustom(ExtType, SplitDstVT, SplitSrcVT) &&\n         SplitSrcVT.getVectorNumElements() > 1) {\n    SplitDstVT = DAG.GetSplitDestVTs(SplitDstVT).first;\n    SplitSrcVT = DAG.GetSplitDestVTs(SplitSrcVT).first;\n  }\n\n  if (!TLI.isLoadExtLegalOrCustom(ExtType, SplitDstVT, SplitSrcVT))\n    return SDValue();\n\n  assert(!DstVT.isScalableVector() && \"Unexpected scalable vector type\");\n\n  SDLoc DL(N);\n  const unsigned NumSplits =\n      DstVT.getVectorNumElements() / SplitDstVT.getVectorNumElements();\n  const unsigned Stride = SplitSrcVT.getStoreSize();\n  SmallVector<SDValue, 4> Loads;\n  SmallVector<SDValue, 4> Chains;\n\n  SDValue BasePtr = LN0->getBasePtr();\n  for (unsigned Idx = 0; Idx < NumSplits; Idx++) {\n    const unsigned Offset = Idx * Stride;\n    const Align Align = commonAlignment(LN0->getAlign(), Offset);\n\n    SDValue SplitLoad = DAG.getExtLoad(\n        ExtType, SDLoc(LN0), SplitDstVT, LN0->getChain(), BasePtr,\n        LN0->getPointerInfo().getWithOffset(Offset), SplitSrcVT, Align,\n        LN0->getMemOperand()->getFlags(), LN0->getAAInfo());\n\n    BasePtr = DAG.getMemBasePlusOffset(BasePtr, TypeSize::Fixed(Stride), DL);\n\n    Loads.push_back(SplitLoad.getValue(0));\n    Chains.push_back(SplitLoad.getValue(1));\n  }\n\n  SDValue NewChain = DAG.getNode(ISD::TokenFactor, DL, MVT::Other, Chains);\n  SDValue NewValue = DAG.getNode(ISD::CONCAT_VECTORS, DL, DstVT, Loads);\n\n  // Simplify TF.\n  AddToWorklist(NewChain.getNode());\n\n  CombineTo(N, NewValue);\n\n  // Replace uses of the original load (before extension)\n  // with a truncate of the concatenated sextloaded vectors.\n  SDValue Trunc =\n      DAG.getNode(ISD::TRUNCATE, SDLoc(N0), N0.getValueType(), NewValue);\n  ExtendSetCCUses(SetCCs, N0, NewValue, (ISD::NodeType)N->getOpcode());\n  CombineTo(N0.getNode(), Trunc, NewChain);\n  return SDValue(N, 0); // Return N so it doesn't get rechecked!\n}\n\n// fold (zext (and/or/xor (shl/shr (load x), cst), cst)) ->\n//      (and/or/xor (shl/shr (zextload x), (zext cst)), (zext cst))\nSDValue DAGCombiner::CombineZExtLogicopShiftLoad(SDNode *N) {\n  assert(N->getOpcode() == ISD::ZERO_EXTEND);\n  EVT VT = N->getValueType(0);\n  EVT OrigVT = N->getOperand(0).getValueType();\n  if (TLI.isZExtFree(OrigVT, VT))\n    return SDValue();\n\n  // and/or/xor\n  SDValue N0 = N->getOperand(0);\n  if (!(N0.getOpcode() == ISD::AND || N0.getOpcode() == ISD::OR ||\n        N0.getOpcode() == ISD::XOR) ||\n      N0.getOperand(1).getOpcode() != ISD::Constant ||\n      (LegalOperations && !TLI.isOperationLegal(N0.getOpcode(), VT)))\n    return SDValue();\n\n  // shl/shr\n  SDValue N1 = N0->getOperand(0);\n  if (!(N1.getOpcode() == ISD::SHL || N1.getOpcode() == ISD::SRL) ||\n      N1.getOperand(1).getOpcode() != ISD::Constant ||\n      (LegalOperations && !TLI.isOperationLegal(N1.getOpcode(), VT)))\n    return SDValue();\n\n  // load\n  if (!isa<LoadSDNode>(N1.getOperand(0)))\n    return SDValue();\n  LoadSDNode *Load = cast<LoadSDNode>(N1.getOperand(0));\n  EVT MemVT = Load->getMemoryVT();\n  if (!TLI.isLoadExtLegal(ISD::ZEXTLOAD, VT, MemVT) ||\n      Load->getExtensionType() == ISD::SEXTLOAD || Load->isIndexed())\n    return SDValue();\n\n\n  // If the shift op is SHL, the logic op must be AND, otherwise the result\n  // will be wrong.\n  if (N1.getOpcode() == ISD::SHL && N0.getOpcode() != ISD::AND)\n    return SDValue();\n\n  if (!N0.hasOneUse() || !N1.hasOneUse())\n    return SDValue();\n\n  SmallVector<SDNode*, 4> SetCCs;\n  if (!ExtendUsesToFormExtLoad(VT, N1.getNode(), N1.getOperand(0),\n                               ISD::ZERO_EXTEND, SetCCs, TLI))\n    return SDValue();\n\n  // Actually do the transformation.\n  SDValue ExtLoad = DAG.getExtLoad(ISD::ZEXTLOAD, SDLoc(Load), VT,\n                                   Load->getChain(), Load->getBasePtr(),\n                                   Load->getMemoryVT(), Load->getMemOperand());\n\n  SDLoc DL1(N1);\n  SDValue Shift = DAG.getNode(N1.getOpcode(), DL1, VT, ExtLoad,\n                              N1.getOperand(1));\n\n  APInt Mask = N0.getConstantOperandAPInt(1).zext(VT.getSizeInBits());\n  SDLoc DL0(N0);\n  SDValue And = DAG.getNode(N0.getOpcode(), DL0, VT, Shift,\n                            DAG.getConstant(Mask, DL0, VT));\n\n  ExtendSetCCUses(SetCCs, N1.getOperand(0), ExtLoad, ISD::ZERO_EXTEND);\n  CombineTo(N, And);\n  if (SDValue(Load, 0).hasOneUse()) {\n    DAG.ReplaceAllUsesOfValueWith(SDValue(Load, 1), ExtLoad.getValue(1));\n  } else {\n    SDValue Trunc = DAG.getNode(ISD::TRUNCATE, SDLoc(Load),\n                                Load->getValueType(0), ExtLoad);\n    CombineTo(Load, Trunc, ExtLoad.getValue(1));\n  }\n\n  // N0 is dead at this point.\n  recursivelyDeleteUnusedNodes(N0.getNode());\n\n  return SDValue(N,0); // Return N so it doesn't get rechecked!\n}\n\n/// If we're narrowing or widening the result of a vector select and the final\n/// size is the same size as a setcc (compare) feeding the select, then try to\n/// apply the cast operation to the select's operands because matching vector\n/// sizes for a select condition and other operands should be more efficient.\nSDValue DAGCombiner::matchVSelectOpSizesWithSetCC(SDNode *Cast) {\n  unsigned CastOpcode = Cast->getOpcode();\n  assert((CastOpcode == ISD::SIGN_EXTEND || CastOpcode == ISD::ZERO_EXTEND ||\n          CastOpcode == ISD::TRUNCATE || CastOpcode == ISD::FP_EXTEND ||\n          CastOpcode == ISD::FP_ROUND) &&\n         \"Unexpected opcode for vector select narrowing/widening\");\n\n  // We only do this transform before legal ops because the pattern may be\n  // obfuscated by target-specific operations after legalization. Do not create\n  // an illegal select op, however, because that may be difficult to lower.\n  EVT VT = Cast->getValueType(0);\n  if (LegalOperations || !TLI.isOperationLegalOrCustom(ISD::VSELECT, VT))\n    return SDValue();\n\n  SDValue VSel = Cast->getOperand(0);\n  if (VSel.getOpcode() != ISD::VSELECT || !VSel.hasOneUse() ||\n      VSel.getOperand(0).getOpcode() != ISD::SETCC)\n    return SDValue();\n\n  // Does the setcc have the same vector size as the casted select?\n  SDValue SetCC = VSel.getOperand(0);\n  EVT SetCCVT = getSetCCResultType(SetCC.getOperand(0).getValueType());\n  if (SetCCVT.getSizeInBits() != VT.getSizeInBits())\n    return SDValue();\n\n  // cast (vsel (setcc X), A, B) --> vsel (setcc X), (cast A), (cast B)\n  SDValue A = VSel.getOperand(1);\n  SDValue B = VSel.getOperand(2);\n  SDValue CastA, CastB;\n  SDLoc DL(Cast);\n  if (CastOpcode == ISD::FP_ROUND) {\n    // FP_ROUND (fptrunc) has an extra flag operand to pass along.\n    CastA = DAG.getNode(CastOpcode, DL, VT, A, Cast->getOperand(1));\n    CastB = DAG.getNode(CastOpcode, DL, VT, B, Cast->getOperand(1));\n  } else {\n    CastA = DAG.getNode(CastOpcode, DL, VT, A);\n    CastB = DAG.getNode(CastOpcode, DL, VT, B);\n  }\n  return DAG.getNode(ISD::VSELECT, DL, VT, SetCC, CastA, CastB);\n}\n\n// fold ([s|z]ext ([s|z]extload x)) -> ([s|z]ext (truncate ([s|z]extload x)))\n// fold ([s|z]ext (     extload x)) -> ([s|z]ext (truncate ([s|z]extload x)))\nstatic SDValue tryToFoldExtOfExtload(SelectionDAG &DAG, DAGCombiner &Combiner,\n                                     const TargetLowering &TLI, EVT VT,\n                                     bool LegalOperations, SDNode *N,\n                                     SDValue N0, ISD::LoadExtType ExtLoadType) {\n  SDNode *N0Node = N0.getNode();\n  bool isAExtLoad = (ExtLoadType == ISD::SEXTLOAD) ? ISD::isSEXTLoad(N0Node)\n                                                   : ISD::isZEXTLoad(N0Node);\n  if ((!isAExtLoad && !ISD::isEXTLoad(N0Node)) ||\n      !ISD::isUNINDEXEDLoad(N0Node) || !N0.hasOneUse())\n    return SDValue();\n\n  LoadSDNode *LN0 = cast<LoadSDNode>(N0);\n  EVT MemVT = LN0->getMemoryVT();\n  if ((LegalOperations || !LN0->isSimple() ||\n       VT.isVector()) &&\n      !TLI.isLoadExtLegal(ExtLoadType, VT, MemVT))\n    return SDValue();\n\n  SDValue ExtLoad =\n      DAG.getExtLoad(ExtLoadType, SDLoc(LN0), VT, LN0->getChain(),\n                     LN0->getBasePtr(), MemVT, LN0->getMemOperand());\n  Combiner.CombineTo(N, ExtLoad);\n  DAG.ReplaceAllUsesOfValueWith(SDValue(LN0, 1), ExtLoad.getValue(1));\n  if (LN0->use_empty())\n    Combiner.recursivelyDeleteUnusedNodes(LN0);\n  return SDValue(N, 0); // Return N so it doesn't get rechecked!\n}\n\n// fold ([s|z]ext (load x)) -> ([s|z]ext (truncate ([s|z]extload x)))\n// Only generate vector extloads when 1) they're legal, and 2) they are\n// deemed desirable by the target.\nstatic SDValue tryToFoldExtOfLoad(SelectionDAG &DAG, DAGCombiner &Combiner,\n                                  const TargetLowering &TLI, EVT VT,\n                                  bool LegalOperations, SDNode *N, SDValue N0,\n                                  ISD::LoadExtType ExtLoadType,\n                                  ISD::NodeType ExtOpc) {\n  if (!ISD::isNON_EXTLoad(N0.getNode()) ||\n      !ISD::isUNINDEXEDLoad(N0.getNode()) ||\n      ((LegalOperations || VT.isVector() ||\n        !cast<LoadSDNode>(N0)->isSimple()) &&\n       !TLI.isLoadExtLegal(ExtLoadType, VT, N0.getValueType())))\n    return {};\n\n  bool DoXform = true;\n  SmallVector<SDNode *, 4> SetCCs;\n  if (!N0.hasOneUse())\n    DoXform = ExtendUsesToFormExtLoad(VT, N, N0, ExtOpc, SetCCs, TLI);\n  if (VT.isVector())\n    DoXform &= TLI.isVectorLoadExtDesirable(SDValue(N, 0));\n  if (!DoXform)\n    return {};\n\n  LoadSDNode *LN0 = cast<LoadSDNode>(N0);\n  SDValue ExtLoad = DAG.getExtLoad(ExtLoadType, SDLoc(LN0), VT, LN0->getChain(),\n                                   LN0->getBasePtr(), N0.getValueType(),\n                                   LN0->getMemOperand());\n  Combiner.ExtendSetCCUses(SetCCs, N0, ExtLoad, ExtOpc);\n  // If the load value is used only by N, replace it via CombineTo N.\n  bool NoReplaceTrunc = SDValue(LN0, 0).hasOneUse();\n  Combiner.CombineTo(N, ExtLoad);\n  if (NoReplaceTrunc) {\n    DAG.ReplaceAllUsesOfValueWith(SDValue(LN0, 1), ExtLoad.getValue(1));\n    Combiner.recursivelyDeleteUnusedNodes(LN0);\n  } else {\n    SDValue Trunc =\n        DAG.getNode(ISD::TRUNCATE, SDLoc(N0), N0.getValueType(), ExtLoad);\n    Combiner.CombineTo(LN0, Trunc, ExtLoad.getValue(1));\n  }\n  return SDValue(N, 0); // Return N so it doesn't get rechecked!\n}\n\nstatic SDValue tryToFoldExtOfMaskedLoad(SelectionDAG &DAG,\n                                        const TargetLowering &TLI, EVT VT,\n                                        SDNode *N, SDValue N0,\n                                        ISD::LoadExtType ExtLoadType,\n                                        ISD::NodeType ExtOpc) {\n  if (!N0.hasOneUse())\n    return SDValue();\n\n  MaskedLoadSDNode *Ld = dyn_cast<MaskedLoadSDNode>(N0);\n  if (!Ld || Ld->getExtensionType() != ISD::NON_EXTLOAD)\n    return SDValue();\n\n  if (!TLI.isLoadExtLegal(ExtLoadType, VT, Ld->getValueType(0)))\n    return SDValue();\n\n  if (!TLI.isVectorLoadExtDesirable(SDValue(N, 0)))\n    return SDValue();\n\n  SDLoc dl(Ld);\n  SDValue PassThru = DAG.getNode(ExtOpc, dl, VT, Ld->getPassThru());\n  SDValue NewLoad = DAG.getMaskedLoad(\n      VT, dl, Ld->getChain(), Ld->getBasePtr(), Ld->getOffset(), Ld->getMask(),\n      PassThru, Ld->getMemoryVT(), Ld->getMemOperand(), Ld->getAddressingMode(),\n      ExtLoadType, Ld->isExpandingLoad());\n  DAG.ReplaceAllUsesOfValueWith(SDValue(Ld, 1), SDValue(NewLoad.getNode(), 1));\n  return NewLoad;\n}\n\nstatic SDValue foldExtendedSignBitTest(SDNode *N, SelectionDAG &DAG,\n                                       bool LegalOperations) {\n  assert((N->getOpcode() == ISD::SIGN_EXTEND ||\n          N->getOpcode() == ISD::ZERO_EXTEND) && \"Expected sext or zext\");\n\n  SDValue SetCC = N->getOperand(0);\n  if (LegalOperations || SetCC.getOpcode() != ISD::SETCC ||\n      !SetCC.hasOneUse() || SetCC.getValueType() != MVT::i1)\n    return SDValue();\n\n  SDValue X = SetCC.getOperand(0);\n  SDValue Ones = SetCC.getOperand(1);\n  ISD::CondCode CC = cast<CondCodeSDNode>(SetCC.getOperand(2))->get();\n  EVT VT = N->getValueType(0);\n  EVT XVT = X.getValueType();\n  // setge X, C is canonicalized to setgt, so we do not need to match that\n  // pattern. The setlt sibling is folded in SimplifySelectCC() because it does\n  // not require the 'not' op.\n  if (CC == ISD::SETGT && isAllOnesConstant(Ones) && VT == XVT) {\n    // Invert and smear/shift the sign bit:\n    // sext i1 (setgt iN X, -1) --> sra (not X), (N - 1)\n    // zext i1 (setgt iN X, -1) --> srl (not X), (N - 1)\n    SDLoc DL(N);\n    unsigned ShCt = VT.getSizeInBits() - 1;\n    const TargetLowering &TLI = DAG.getTargetLoweringInfo();\n    if (!TLI.shouldAvoidTransformToShift(VT, ShCt)) {\n      SDValue NotX = DAG.getNOT(DL, X, VT);\n      SDValue ShiftAmount = DAG.getConstant(ShCt, DL, VT);\n      auto ShiftOpcode =\n        N->getOpcode() == ISD::SIGN_EXTEND ? ISD::SRA : ISD::SRL;\n      return DAG.getNode(ShiftOpcode, DL, VT, NotX, ShiftAmount);\n    }\n  }\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitSIGN_EXTEND(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  EVT VT = N->getValueType(0);\n  SDLoc DL(N);\n\n  if (SDValue Res = tryToFoldExtendOfConstant(N, TLI, DAG, LegalTypes))\n    return Res;\n\n  // fold (sext (sext x)) -> (sext x)\n  // fold (sext (aext x)) -> (sext x)\n  if (N0.getOpcode() == ISD::SIGN_EXTEND || N0.getOpcode() == ISD::ANY_EXTEND)\n    return DAG.getNode(ISD::SIGN_EXTEND, DL, VT, N0.getOperand(0));\n\n  if (N0.getOpcode() == ISD::TRUNCATE) {\n    // fold (sext (truncate (load x))) -> (sext (smaller load x))\n    // fold (sext (truncate (srl (load x), c))) -> (sext (smaller load (x+c/n)))\n    if (SDValue NarrowLoad = ReduceLoadWidth(N0.getNode())) {\n      SDNode *oye = N0.getOperand(0).getNode();\n      if (NarrowLoad.getNode() != N0.getNode()) {\n        CombineTo(N0.getNode(), NarrowLoad);\n        // CombineTo deleted the truncate, if needed, but not what's under it.\n        AddToWorklist(oye);\n      }\n      return SDValue(N, 0);   // Return N so it doesn't get rechecked!\n    }\n\n    // See if the value being truncated is already sign extended.  If so, just\n    // eliminate the trunc/sext pair.\n    SDValue Op = N0.getOperand(0);\n    unsigned OpBits   = Op.getScalarValueSizeInBits();\n    unsigned MidBits  = N0.getScalarValueSizeInBits();\n    unsigned DestBits = VT.getScalarSizeInBits();\n    unsigned NumSignBits = DAG.ComputeNumSignBits(Op);\n\n    if (OpBits == DestBits) {\n      // Op is i32, Mid is i8, and Dest is i32.  If Op has more than 24 sign\n      // bits, it is already ready.\n      if (NumSignBits > DestBits-MidBits)\n        return Op;\n    } else if (OpBits < DestBits) {\n      // Op is i32, Mid is i8, and Dest is i64.  If Op has more than 24 sign\n      // bits, just sext from i32.\n      if (NumSignBits > OpBits-MidBits)\n        return DAG.getNode(ISD::SIGN_EXTEND, DL, VT, Op);\n    } else {\n      // Op is i64, Mid is i8, and Dest is i32.  If Op has more than 56 sign\n      // bits, just truncate to i32.\n      if (NumSignBits > OpBits-MidBits)\n        return DAG.getNode(ISD::TRUNCATE, DL, VT, Op);\n    }\n\n    // fold (sext (truncate x)) -> (sextinreg x).\n    if (!LegalOperations || TLI.isOperationLegal(ISD::SIGN_EXTEND_INREG,\n                                                 N0.getValueType())) {\n      if (OpBits < DestBits)\n        Op = DAG.getNode(ISD::ANY_EXTEND, SDLoc(N0), VT, Op);\n      else if (OpBits > DestBits)\n        Op = DAG.getNode(ISD::TRUNCATE, SDLoc(N0), VT, Op);\n      return DAG.getNode(ISD::SIGN_EXTEND_INREG, DL, VT, Op,\n                         DAG.getValueType(N0.getValueType()));\n    }\n  }\n\n  // Try to simplify (sext (load x)).\n  if (SDValue foldedExt =\n          tryToFoldExtOfLoad(DAG, *this, TLI, VT, LegalOperations, N, N0,\n                             ISD::SEXTLOAD, ISD::SIGN_EXTEND))\n    return foldedExt;\n\n  if (SDValue foldedExt =\n      tryToFoldExtOfMaskedLoad(DAG, TLI, VT, N, N0, ISD::SEXTLOAD,\n                               ISD::SIGN_EXTEND))\n    return foldedExt;\n\n  // fold (sext (load x)) to multiple smaller sextloads.\n  // Only on illegal but splittable vectors.\n  if (SDValue ExtLoad = CombineExtLoad(N))\n    return ExtLoad;\n\n  // Try to simplify (sext (sextload x)).\n  if (SDValue foldedExt = tryToFoldExtOfExtload(\n          DAG, *this, TLI, VT, LegalOperations, N, N0, ISD::SEXTLOAD))\n    return foldedExt;\n\n  // fold (sext (and/or/xor (load x), cst)) ->\n  //      (and/or/xor (sextload x), (sext cst))\n  if ((N0.getOpcode() == ISD::AND || N0.getOpcode() == ISD::OR ||\n       N0.getOpcode() == ISD::XOR) &&\n      isa<LoadSDNode>(N0.getOperand(0)) &&\n      N0.getOperand(1).getOpcode() == ISD::Constant &&\n      (!LegalOperations && TLI.isOperationLegal(N0.getOpcode(), VT))) {\n    LoadSDNode *LN00 = cast<LoadSDNode>(N0.getOperand(0));\n    EVT MemVT = LN00->getMemoryVT();\n    if (TLI.isLoadExtLegal(ISD::SEXTLOAD, VT, MemVT) &&\n      LN00->getExtensionType() != ISD::ZEXTLOAD && LN00->isUnindexed()) {\n      SmallVector<SDNode*, 4> SetCCs;\n      bool DoXform = ExtendUsesToFormExtLoad(VT, N0.getNode(), N0.getOperand(0),\n                                             ISD::SIGN_EXTEND, SetCCs, TLI);\n      if (DoXform) {\n        SDValue ExtLoad = DAG.getExtLoad(ISD::SEXTLOAD, SDLoc(LN00), VT,\n                                         LN00->getChain(), LN00->getBasePtr(),\n                                         LN00->getMemoryVT(),\n                                         LN00->getMemOperand());\n        APInt Mask = N0.getConstantOperandAPInt(1).sext(VT.getSizeInBits());\n        SDValue And = DAG.getNode(N0.getOpcode(), DL, VT,\n                                  ExtLoad, DAG.getConstant(Mask, DL, VT));\n        ExtendSetCCUses(SetCCs, N0.getOperand(0), ExtLoad, ISD::SIGN_EXTEND);\n        bool NoReplaceTruncAnd = !N0.hasOneUse();\n        bool NoReplaceTrunc = SDValue(LN00, 0).hasOneUse();\n        CombineTo(N, And);\n        // If N0 has multiple uses, change other uses as well.\n        if (NoReplaceTruncAnd) {\n          SDValue TruncAnd =\n              DAG.getNode(ISD::TRUNCATE, DL, N0.getValueType(), And);\n          CombineTo(N0.getNode(), TruncAnd);\n        }\n        if (NoReplaceTrunc) {\n          DAG.ReplaceAllUsesOfValueWith(SDValue(LN00, 1), ExtLoad.getValue(1));\n        } else {\n          SDValue Trunc = DAG.getNode(ISD::TRUNCATE, SDLoc(LN00),\n                                      LN00->getValueType(0), ExtLoad);\n          CombineTo(LN00, Trunc, ExtLoad.getValue(1));\n        }\n        return SDValue(N,0); // Return N so it doesn't get rechecked!\n      }\n    }\n  }\n\n  if (SDValue V = foldExtendedSignBitTest(N, DAG, LegalOperations))\n    return V;\n\n  if (N0.getOpcode() == ISD::SETCC) {\n    SDValue N00 = N0.getOperand(0);\n    SDValue N01 = N0.getOperand(1);\n    ISD::CondCode CC = cast<CondCodeSDNode>(N0.getOperand(2))->get();\n    EVT N00VT = N00.getValueType();\n\n    // sext(setcc) -> sext_in_reg(vsetcc) for vectors.\n    // Only do this before legalize for now.\n    if (VT.isVector() && !LegalOperations &&\n        TLI.getBooleanContents(N00VT) ==\n            TargetLowering::ZeroOrNegativeOneBooleanContent) {\n      // On some architectures (such as SSE/NEON/etc) the SETCC result type is\n      // of the same size as the compared operands. Only optimize sext(setcc())\n      // if this is the case.\n      EVT SVT = getSetCCResultType(N00VT);\n\n      // If we already have the desired type, don't change it.\n      if (SVT != N0.getValueType()) {\n        // We know that the # elements of the results is the same as the\n        // # elements of the compare (and the # elements of the compare result\n        // for that matter).  Check to see that they are the same size.  If so,\n        // we know that the element size of the sext'd result matches the\n        // element size of the compare operands.\n        if (VT.getSizeInBits() == SVT.getSizeInBits())\n          return DAG.getSetCC(DL, VT, N00, N01, CC);\n\n        // If the desired elements are smaller or larger than the source\n        // elements, we can use a matching integer vector type and then\n        // truncate/sign extend.\n        EVT MatchingVecType = N00VT.changeVectorElementTypeToInteger();\n        if (SVT == MatchingVecType) {\n          SDValue VsetCC = DAG.getSetCC(DL, MatchingVecType, N00, N01, CC);\n          return DAG.getSExtOrTrunc(VsetCC, DL, VT);\n        }\n      }\n    }\n\n    // sext(setcc x, y, cc) -> (select (setcc x, y, cc), T, 0)\n    // Here, T can be 1 or -1, depending on the type of the setcc and\n    // getBooleanContents().\n    unsigned SetCCWidth = N0.getScalarValueSizeInBits();\n\n    // To determine the \"true\" side of the select, we need to know the high bit\n    // of the value returned by the setcc if it evaluates to true.\n    // If the type of the setcc is i1, then the true case of the select is just\n    // sext(i1 1), that is, -1.\n    // If the type of the setcc is larger (say, i8) then the value of the high\n    // bit depends on getBooleanContents(), so ask TLI for a real \"true\" value\n    // of the appropriate width.\n    SDValue ExtTrueVal = (SetCCWidth == 1)\n                             ? DAG.getAllOnesConstant(DL, VT)\n                             : DAG.getBoolConstant(true, DL, VT, N00VT);\n    SDValue Zero = DAG.getConstant(0, DL, VT);\n    if (SDValue SCC =\n            SimplifySelectCC(DL, N00, N01, ExtTrueVal, Zero, CC, true))\n      return SCC;\n\n    if (!VT.isVector() && !TLI.convertSelectOfConstantsToMath(VT)) {\n      EVT SetCCVT = getSetCCResultType(N00VT);\n      // Don't do this transform for i1 because there's a select transform\n      // that would reverse it.\n      // TODO: We should not do this transform at all without a target hook\n      // because a sext is likely cheaper than a select?\n      if (SetCCVT.getScalarSizeInBits() != 1 &&\n          (!LegalOperations || TLI.isOperationLegal(ISD::SETCC, N00VT))) {\n        SDValue SetCC = DAG.getSetCC(DL, SetCCVT, N00, N01, CC);\n        return DAG.getSelect(DL, VT, SetCC, ExtTrueVal, Zero);\n      }\n    }\n  }\n\n  // fold (sext x) -> (zext x) if the sign bit is known zero.\n  if ((!LegalOperations || TLI.isOperationLegal(ISD::ZERO_EXTEND, VT)) &&\n      DAG.SignBitIsZero(N0))\n    return DAG.getNode(ISD::ZERO_EXTEND, DL, VT, N0);\n\n  if (SDValue NewVSel = matchVSelectOpSizesWithSetCC(N))\n    return NewVSel;\n\n  // Eliminate this sign extend by doing a negation in the destination type:\n  // sext i32 (0 - (zext i8 X to i32)) to i64 --> 0 - (zext i8 X to i64)\n  if (N0.getOpcode() == ISD::SUB && N0.hasOneUse() &&\n      isNullOrNullSplat(N0.getOperand(0)) &&\n      N0.getOperand(1).getOpcode() == ISD::ZERO_EXTEND &&\n      TLI.isOperationLegalOrCustom(ISD::SUB, VT)) {\n    SDValue Zext = DAG.getZExtOrTrunc(N0.getOperand(1).getOperand(0), DL, VT);\n    return DAG.getNode(ISD::SUB, DL, VT, DAG.getConstant(0, DL, VT), Zext);\n  }\n  // Eliminate this sign extend by doing a decrement in the destination type:\n  // sext i32 ((zext i8 X to i32) + (-1)) to i64 --> (zext i8 X to i64) + (-1)\n  if (N0.getOpcode() == ISD::ADD && N0.hasOneUse() &&\n      isAllOnesOrAllOnesSplat(N0.getOperand(1)) &&\n      N0.getOperand(0).getOpcode() == ISD::ZERO_EXTEND &&\n      TLI.isOperationLegalOrCustom(ISD::ADD, VT)) {\n    SDValue Zext = DAG.getZExtOrTrunc(N0.getOperand(0).getOperand(0), DL, VT);\n    return DAG.getNode(ISD::ADD, DL, VT, Zext, DAG.getAllOnesConstant(DL, VT));\n  }\n\n  // fold sext (not i1 X) -> add (zext i1 X), -1\n  // TODO: This could be extended to handle bool vectors.\n  if (N0.getValueType() == MVT::i1 && isBitwiseNot(N0) && N0.hasOneUse() &&\n      (!LegalOperations || (TLI.isOperationLegal(ISD::ZERO_EXTEND, VT) &&\n                            TLI.isOperationLegal(ISD::ADD, VT)))) {\n    // If we can eliminate the 'not', the sext form should be better\n    if (SDValue NewXor = visitXOR(N0.getNode())) {\n      // Returning N0 is a form of in-visit replacement that may have\n      // invalidated N0.\n      if (NewXor.getNode() == N0.getNode()) {\n        // Return SDValue here as the xor should have already been replaced in\n        // this sext.\n        return SDValue();\n      } else {\n        // Return a new sext with the new xor.\n        return DAG.getNode(ISD::SIGN_EXTEND, DL, VT, NewXor);\n      }\n    }\n\n    SDValue Zext = DAG.getNode(ISD::ZERO_EXTEND, DL, VT, N0.getOperand(0));\n    return DAG.getNode(ISD::ADD, DL, VT, Zext, DAG.getAllOnesConstant(DL, VT));\n  }\n\n  if (SDValue Res = tryToFoldExtendSelectLoad(N, TLI, DAG))\n    return Res;\n\n  return SDValue();\n}\n\n// isTruncateOf - If N is a truncate of some other value, return true, record\n// the value being truncated in Op and which of Op's bits are zero/one in Known.\n// This function computes KnownBits to avoid a duplicated call to\n// computeKnownBits in the caller.\nstatic bool isTruncateOf(SelectionDAG &DAG, SDValue N, SDValue &Op,\n                         KnownBits &Known) {\n  if (N->getOpcode() == ISD::TRUNCATE) {\n    Op = N->getOperand(0);\n    Known = DAG.computeKnownBits(Op);\n    return true;\n  }\n\n  if (N.getOpcode() != ISD::SETCC ||\n      N.getValueType().getScalarType() != MVT::i1 ||\n      cast<CondCodeSDNode>(N.getOperand(2))->get() != ISD::SETNE)\n    return false;\n\n  SDValue Op0 = N->getOperand(0);\n  SDValue Op1 = N->getOperand(1);\n  assert(Op0.getValueType() == Op1.getValueType());\n\n  if (isNullOrNullSplat(Op0))\n    Op = Op1;\n  else if (isNullOrNullSplat(Op1))\n    Op = Op0;\n  else\n    return false;\n\n  Known = DAG.computeKnownBits(Op);\n\n  return (Known.Zero | 1).isAllOnesValue();\n}\n\n/// Given an extending node with a pop-count operand, if the target does not\n/// support a pop-count in the narrow source type but does support it in the\n/// destination type, widen the pop-count to the destination type.\nstatic SDValue widenCtPop(SDNode *Extend, SelectionDAG &DAG) {\n  assert((Extend->getOpcode() == ISD::ZERO_EXTEND ||\n          Extend->getOpcode() == ISD::ANY_EXTEND) && \"Expected extend op\");\n\n  SDValue CtPop = Extend->getOperand(0);\n  if (CtPop.getOpcode() != ISD::CTPOP || !CtPop.hasOneUse())\n    return SDValue();\n\n  EVT VT = Extend->getValueType(0);\n  const TargetLowering &TLI = DAG.getTargetLoweringInfo();\n  if (TLI.isOperationLegalOrCustom(ISD::CTPOP, CtPop.getValueType()) ||\n      !TLI.isOperationLegalOrCustom(ISD::CTPOP, VT))\n    return SDValue();\n\n  // zext (ctpop X) --> ctpop (zext X)\n  SDLoc DL(Extend);\n  SDValue NewZext = DAG.getZExtOrTrunc(CtPop.getOperand(0), DL, VT);\n  return DAG.getNode(ISD::CTPOP, DL, VT, NewZext);\n}\n\nSDValue DAGCombiner::visitZERO_EXTEND(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  EVT VT = N->getValueType(0);\n\n  if (SDValue Res = tryToFoldExtendOfConstant(N, TLI, DAG, LegalTypes))\n    return Res;\n\n  // fold (zext (zext x)) -> (zext x)\n  // fold (zext (aext x)) -> (zext x)\n  if (N0.getOpcode() == ISD::ZERO_EXTEND || N0.getOpcode() == ISD::ANY_EXTEND)\n    return DAG.getNode(ISD::ZERO_EXTEND, SDLoc(N), VT,\n                       N0.getOperand(0));\n\n  // fold (zext (truncate x)) -> (zext x) or\n  //      (zext (truncate x)) -> (truncate x)\n  // This is valid when the truncated bits of x are already zero.\n  SDValue Op;\n  KnownBits Known;\n  if (isTruncateOf(DAG, N0, Op, Known)) {\n    APInt TruncatedBits =\n      (Op.getScalarValueSizeInBits() == N0.getScalarValueSizeInBits()) ?\n      APInt(Op.getScalarValueSizeInBits(), 0) :\n      APInt::getBitsSet(Op.getScalarValueSizeInBits(),\n                        N0.getScalarValueSizeInBits(),\n                        std::min(Op.getScalarValueSizeInBits(),\n                                 VT.getScalarSizeInBits()));\n    if (TruncatedBits.isSubsetOf(Known.Zero))\n      return DAG.getZExtOrTrunc(Op, SDLoc(N), VT);\n  }\n\n  // fold (zext (truncate x)) -> (and x, mask)\n  if (N0.getOpcode() == ISD::TRUNCATE) {\n    // fold (zext (truncate (load x))) -> (zext (smaller load x))\n    // fold (zext (truncate (srl (load x), c))) -> (zext (smaller load (x+c/n)))\n    if (SDValue NarrowLoad = ReduceLoadWidth(N0.getNode())) {\n      SDNode *oye = N0.getOperand(0).getNode();\n      if (NarrowLoad.getNode() != N0.getNode()) {\n        CombineTo(N0.getNode(), NarrowLoad);\n        // CombineTo deleted the truncate, if needed, but not what's under it.\n        AddToWorklist(oye);\n      }\n      return SDValue(N, 0); // Return N so it doesn't get rechecked!\n    }\n\n    EVT SrcVT = N0.getOperand(0).getValueType();\n    EVT MinVT = N0.getValueType();\n\n    // Try to mask before the extension to avoid having to generate a larger mask,\n    // possibly over several sub-vectors.\n    if (SrcVT.bitsLT(VT) && VT.isVector()) {\n      if (!LegalOperations || (TLI.isOperationLegal(ISD::AND, SrcVT) &&\n                               TLI.isOperationLegal(ISD::ZERO_EXTEND, VT))) {\n        SDValue Op = N0.getOperand(0);\n        Op = DAG.getZeroExtendInReg(Op, SDLoc(N), MinVT);\n        AddToWorklist(Op.getNode());\n        SDValue ZExtOrTrunc = DAG.getZExtOrTrunc(Op, SDLoc(N), VT);\n        // Transfer the debug info; the new node is equivalent to N0.\n        DAG.transferDbgValues(N0, ZExtOrTrunc);\n        return ZExtOrTrunc;\n      }\n    }\n\n    if (!LegalOperations || TLI.isOperationLegal(ISD::AND, VT)) {\n      SDValue Op = DAG.getAnyExtOrTrunc(N0.getOperand(0), SDLoc(N), VT);\n      AddToWorklist(Op.getNode());\n      SDValue And = DAG.getZeroExtendInReg(Op, SDLoc(N), MinVT);\n      // We may safely transfer the debug info describing the truncate node over\n      // to the equivalent and operation.\n      DAG.transferDbgValues(N0, And);\n      return And;\n    }\n  }\n\n  // Fold (zext (and (trunc x), cst)) -> (and x, cst),\n  // if either of the casts is not free.\n  if (N0.getOpcode() == ISD::AND &&\n      N0.getOperand(0).getOpcode() == ISD::TRUNCATE &&\n      N0.getOperand(1).getOpcode() == ISD::Constant &&\n      (!TLI.isTruncateFree(N0.getOperand(0).getOperand(0).getValueType(),\n                           N0.getValueType()) ||\n       !TLI.isZExtFree(N0.getValueType(), VT))) {\n    SDValue X = N0.getOperand(0).getOperand(0);\n    X = DAG.getAnyExtOrTrunc(X, SDLoc(X), VT);\n    APInt Mask = N0.getConstantOperandAPInt(1).zext(VT.getSizeInBits());\n    SDLoc DL(N);\n    return DAG.getNode(ISD::AND, DL, VT,\n                       X, DAG.getConstant(Mask, DL, VT));\n  }\n\n  // Try to simplify (zext (load x)).\n  if (SDValue foldedExt =\n          tryToFoldExtOfLoad(DAG, *this, TLI, VT, LegalOperations, N, N0,\n                             ISD::ZEXTLOAD, ISD::ZERO_EXTEND))\n    return foldedExt;\n\n  if (SDValue foldedExt =\n      tryToFoldExtOfMaskedLoad(DAG, TLI, VT, N, N0, ISD::ZEXTLOAD,\n                               ISD::ZERO_EXTEND))\n    return foldedExt;\n\n  // fold (zext (load x)) to multiple smaller zextloads.\n  // Only on illegal but splittable vectors.\n  if (SDValue ExtLoad = CombineExtLoad(N))\n    return ExtLoad;\n\n  // fold (zext (and/or/xor (load x), cst)) ->\n  //      (and/or/xor (zextload x), (zext cst))\n  // Unless (and (load x) cst) will match as a zextload already and has\n  // additional users.\n  if ((N0.getOpcode() == ISD::AND || N0.getOpcode() == ISD::OR ||\n       N0.getOpcode() == ISD::XOR) &&\n      isa<LoadSDNode>(N0.getOperand(0)) &&\n      N0.getOperand(1).getOpcode() == ISD::Constant &&\n      (!LegalOperations && TLI.isOperationLegal(N0.getOpcode(), VT))) {\n    LoadSDNode *LN00 = cast<LoadSDNode>(N0.getOperand(0));\n    EVT MemVT = LN00->getMemoryVT();\n    if (TLI.isLoadExtLegal(ISD::ZEXTLOAD, VT, MemVT) &&\n        LN00->getExtensionType() != ISD::SEXTLOAD && LN00->isUnindexed()) {\n      bool DoXform = true;\n      SmallVector<SDNode*, 4> SetCCs;\n      if (!N0.hasOneUse()) {\n        if (N0.getOpcode() == ISD::AND) {\n          auto *AndC = cast<ConstantSDNode>(N0.getOperand(1));\n          EVT LoadResultTy = AndC->getValueType(0);\n          EVT ExtVT;\n          if (isAndLoadExtLoad(AndC, LN00, LoadResultTy, ExtVT))\n            DoXform = false;\n        }\n      }\n      if (DoXform)\n        DoXform = ExtendUsesToFormExtLoad(VT, N0.getNode(), N0.getOperand(0),\n                                          ISD::ZERO_EXTEND, SetCCs, TLI);\n      if (DoXform) {\n        SDValue ExtLoad = DAG.getExtLoad(ISD::ZEXTLOAD, SDLoc(LN00), VT,\n                                         LN00->getChain(), LN00->getBasePtr(),\n                                         LN00->getMemoryVT(),\n                                         LN00->getMemOperand());\n        APInt Mask = N0.getConstantOperandAPInt(1).zext(VT.getSizeInBits());\n        SDLoc DL(N);\n        SDValue And = DAG.getNode(N0.getOpcode(), DL, VT,\n                                  ExtLoad, DAG.getConstant(Mask, DL, VT));\n        ExtendSetCCUses(SetCCs, N0.getOperand(0), ExtLoad, ISD::ZERO_EXTEND);\n        bool NoReplaceTruncAnd = !N0.hasOneUse();\n        bool NoReplaceTrunc = SDValue(LN00, 0).hasOneUse();\n        CombineTo(N, And);\n        // If N0 has multiple uses, change other uses as well.\n        if (NoReplaceTruncAnd) {\n          SDValue TruncAnd =\n              DAG.getNode(ISD::TRUNCATE, DL, N0.getValueType(), And);\n          CombineTo(N0.getNode(), TruncAnd);\n        }\n        if (NoReplaceTrunc) {\n          DAG.ReplaceAllUsesOfValueWith(SDValue(LN00, 1), ExtLoad.getValue(1));\n        } else {\n          SDValue Trunc = DAG.getNode(ISD::TRUNCATE, SDLoc(LN00),\n                                      LN00->getValueType(0), ExtLoad);\n          CombineTo(LN00, Trunc, ExtLoad.getValue(1));\n        }\n        return SDValue(N,0); // Return N so it doesn't get rechecked!\n      }\n    }\n  }\n\n  // fold (zext (and/or/xor (shl/shr (load x), cst), cst)) ->\n  //      (and/or/xor (shl/shr (zextload x), (zext cst)), (zext cst))\n  if (SDValue ZExtLoad = CombineZExtLogicopShiftLoad(N))\n    return ZExtLoad;\n\n  // Try to simplify (zext (zextload x)).\n  if (SDValue foldedExt = tryToFoldExtOfExtload(\n          DAG, *this, TLI, VT, LegalOperations, N, N0, ISD::ZEXTLOAD))\n    return foldedExt;\n\n  if (SDValue V = foldExtendedSignBitTest(N, DAG, LegalOperations))\n    return V;\n\n  if (N0.getOpcode() == ISD::SETCC) {\n    // Only do this before legalize for now.\n    if (!LegalOperations && VT.isVector() &&\n        N0.getValueType().getVectorElementType() == MVT::i1) {\n      EVT N00VT = N0.getOperand(0).getValueType();\n      if (getSetCCResultType(N00VT) == N0.getValueType())\n        return SDValue();\n\n      // We know that the # elements of the results is the same as the #\n      // elements of the compare (and the # elements of the compare result for\n      // that matter). Check to see that they are the same size. If so, we know\n      // that the element size of the sext'd result matches the element size of\n      // the compare operands.\n      SDLoc DL(N);\n      if (VT.getSizeInBits() == N00VT.getSizeInBits()) {\n        // zext(setcc) -> zext_in_reg(vsetcc) for vectors.\n        SDValue VSetCC = DAG.getNode(ISD::SETCC, DL, VT, N0.getOperand(0),\n                                     N0.getOperand(1), N0.getOperand(2));\n        return DAG.getZeroExtendInReg(VSetCC, DL, N0.getValueType());\n      }\n\n      // If the desired elements are smaller or larger than the source\n      // elements we can use a matching integer vector type and then\n      // truncate/any extend followed by zext_in_reg.\n      EVT MatchingVectorType = N00VT.changeVectorElementTypeToInteger();\n      SDValue VsetCC =\n          DAG.getNode(ISD::SETCC, DL, MatchingVectorType, N0.getOperand(0),\n                      N0.getOperand(1), N0.getOperand(2));\n      return DAG.getZeroExtendInReg(DAG.getAnyExtOrTrunc(VsetCC, DL, VT), DL,\n                                    N0.getValueType());\n    }\n\n    // zext(setcc x,y,cc) -> zext(select x, y, true, false, cc)\n    SDLoc DL(N);\n    EVT N0VT = N0.getValueType();\n    EVT N00VT = N0.getOperand(0).getValueType();\n    if (SDValue SCC = SimplifySelectCC(\n            DL, N0.getOperand(0), N0.getOperand(1),\n            DAG.getBoolConstant(true, DL, N0VT, N00VT),\n            DAG.getBoolConstant(false, DL, N0VT, N00VT),\n            cast<CondCodeSDNode>(N0.getOperand(2))->get(), true))\n      return DAG.getNode(ISD::ZERO_EXTEND, DL, VT, SCC);\n  }\n\n  // (zext (shl (zext x), cst)) -> (shl (zext x), cst)\n  if ((N0.getOpcode() == ISD::SHL || N0.getOpcode() == ISD::SRL) &&\n      isa<ConstantSDNode>(N0.getOperand(1)) &&\n      N0.getOperand(0).getOpcode() == ISD::ZERO_EXTEND &&\n      N0.hasOneUse()) {\n    SDValue ShAmt = N0.getOperand(1);\n    if (N0.getOpcode() == ISD::SHL) {\n      SDValue InnerZExt = N0.getOperand(0);\n      // If the original shl may be shifting out bits, do not perform this\n      // transformation.\n      unsigned KnownZeroBits = InnerZExt.getValueSizeInBits() -\n        InnerZExt.getOperand(0).getValueSizeInBits();\n      if (cast<ConstantSDNode>(ShAmt)->getAPIntValue().ugt(KnownZeroBits))\n        return SDValue();\n    }\n\n    SDLoc DL(N);\n\n    // Ensure that the shift amount is wide enough for the shifted value.\n    if (Log2_32_Ceil(VT.getSizeInBits()) > ShAmt.getValueSizeInBits())\n      ShAmt = DAG.getNode(ISD::ZERO_EXTEND, DL, MVT::i32, ShAmt);\n\n    return DAG.getNode(N0.getOpcode(), DL, VT,\n                       DAG.getNode(ISD::ZERO_EXTEND, DL, VT, N0.getOperand(0)),\n                       ShAmt);\n  }\n\n  if (SDValue NewVSel = matchVSelectOpSizesWithSetCC(N))\n    return NewVSel;\n\n  if (SDValue NewCtPop = widenCtPop(N, DAG))\n    return NewCtPop;\n\n  if (SDValue Res = tryToFoldExtendSelectLoad(N, TLI, DAG))\n    return Res;\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitANY_EXTEND(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  EVT VT = N->getValueType(0);\n\n  if (SDValue Res = tryToFoldExtendOfConstant(N, TLI, DAG, LegalTypes))\n    return Res;\n\n  // fold (aext (aext x)) -> (aext x)\n  // fold (aext (zext x)) -> (zext x)\n  // fold (aext (sext x)) -> (sext x)\n  if (N0.getOpcode() == ISD::ANY_EXTEND  ||\n      N0.getOpcode() == ISD::ZERO_EXTEND ||\n      N0.getOpcode() == ISD::SIGN_EXTEND)\n    return DAG.getNode(N0.getOpcode(), SDLoc(N), VT, N0.getOperand(0));\n\n  // fold (aext (truncate (load x))) -> (aext (smaller load x))\n  // fold (aext (truncate (srl (load x), c))) -> (aext (small load (x+c/n)))\n  if (N0.getOpcode() == ISD::TRUNCATE) {\n    if (SDValue NarrowLoad = ReduceLoadWidth(N0.getNode())) {\n      SDNode *oye = N0.getOperand(0).getNode();\n      if (NarrowLoad.getNode() != N0.getNode()) {\n        CombineTo(N0.getNode(), NarrowLoad);\n        // CombineTo deleted the truncate, if needed, but not what's under it.\n        AddToWorklist(oye);\n      }\n      return SDValue(N, 0);   // Return N so it doesn't get rechecked!\n    }\n  }\n\n  // fold (aext (truncate x))\n  if (N0.getOpcode() == ISD::TRUNCATE)\n    return DAG.getAnyExtOrTrunc(N0.getOperand(0), SDLoc(N), VT);\n\n  // Fold (aext (and (trunc x), cst)) -> (and x, cst)\n  // if the trunc is not free.\n  if (N0.getOpcode() == ISD::AND &&\n      N0.getOperand(0).getOpcode() == ISD::TRUNCATE &&\n      N0.getOperand(1).getOpcode() == ISD::Constant &&\n      !TLI.isTruncateFree(N0.getOperand(0).getOperand(0).getValueType(),\n                          N0.getValueType())) {\n    SDLoc DL(N);\n    SDValue X = N0.getOperand(0).getOperand(0);\n    X = DAG.getAnyExtOrTrunc(X, DL, VT);\n    APInt Mask = N0.getConstantOperandAPInt(1).zext(VT.getSizeInBits());\n    return DAG.getNode(ISD::AND, DL, VT,\n                       X, DAG.getConstant(Mask, DL, VT));\n  }\n\n  // fold (aext (load x)) -> (aext (truncate (extload x)))\n  // None of the supported targets knows how to perform load and any_ext\n  // on vectors in one instruction, so attempt to fold to zext instead.\n  if (VT.isVector()) {\n    // Try to simplify (zext (load x)).\n    if (SDValue foldedExt =\n            tryToFoldExtOfLoad(DAG, *this, TLI, VT, LegalOperations, N, N0,\n                               ISD::ZEXTLOAD, ISD::ZERO_EXTEND))\n      return foldedExt;\n  } else if (ISD::isNON_EXTLoad(N0.getNode()) &&\n             ISD::isUNINDEXEDLoad(N0.getNode()) &&\n             TLI.isLoadExtLegal(ISD::EXTLOAD, VT, N0.getValueType())) {\n    bool DoXform = true;\n    SmallVector<SDNode *, 4> SetCCs;\n    if (!N0.hasOneUse())\n      DoXform =\n          ExtendUsesToFormExtLoad(VT, N, N0, ISD::ANY_EXTEND, SetCCs, TLI);\n    if (DoXform) {\n      LoadSDNode *LN0 = cast<LoadSDNode>(N0);\n      SDValue ExtLoad = DAG.getExtLoad(ISD::EXTLOAD, SDLoc(N), VT,\n                                       LN0->getChain(), LN0->getBasePtr(),\n                                       N0.getValueType(), LN0->getMemOperand());\n      ExtendSetCCUses(SetCCs, N0, ExtLoad, ISD::ANY_EXTEND);\n      // If the load value is used only by N, replace it via CombineTo N.\n      bool NoReplaceTrunc = N0.hasOneUse();\n      CombineTo(N, ExtLoad);\n      if (NoReplaceTrunc) {\n        DAG.ReplaceAllUsesOfValueWith(SDValue(LN0, 1), ExtLoad.getValue(1));\n        recursivelyDeleteUnusedNodes(LN0);\n      } else {\n        SDValue Trunc =\n            DAG.getNode(ISD::TRUNCATE, SDLoc(N0), N0.getValueType(), ExtLoad);\n        CombineTo(LN0, Trunc, ExtLoad.getValue(1));\n      }\n      return SDValue(N, 0); // Return N so it doesn't get rechecked!\n    }\n  }\n\n  // fold (aext (zextload x)) -> (aext (truncate (zextload x)))\n  // fold (aext (sextload x)) -> (aext (truncate (sextload x)))\n  // fold (aext ( extload x)) -> (aext (truncate (extload  x)))\n  if (N0.getOpcode() == ISD::LOAD && !ISD::isNON_EXTLoad(N0.getNode()) &&\n      ISD::isUNINDEXEDLoad(N0.getNode()) && N0.hasOneUse()) {\n    LoadSDNode *LN0 = cast<LoadSDNode>(N0);\n    ISD::LoadExtType ExtType = LN0->getExtensionType();\n    EVT MemVT = LN0->getMemoryVT();\n    if (!LegalOperations || TLI.isLoadExtLegal(ExtType, VT, MemVT)) {\n      SDValue ExtLoad = DAG.getExtLoad(ExtType, SDLoc(N),\n                                       VT, LN0->getChain(), LN0->getBasePtr(),\n                                       MemVT, LN0->getMemOperand());\n      CombineTo(N, ExtLoad);\n      DAG.ReplaceAllUsesOfValueWith(SDValue(LN0, 1), ExtLoad.getValue(1));\n      recursivelyDeleteUnusedNodes(LN0);\n      return SDValue(N, 0);   // Return N so it doesn't get rechecked!\n    }\n  }\n\n  if (N0.getOpcode() == ISD::SETCC) {\n    // For vectors:\n    // aext(setcc) -> vsetcc\n    // aext(setcc) -> truncate(vsetcc)\n    // aext(setcc) -> aext(vsetcc)\n    // Only do this before legalize for now.\n    if (VT.isVector() && !LegalOperations) {\n      EVT N00VT = N0.getOperand(0).getValueType();\n      if (getSetCCResultType(N00VT) == N0.getValueType())\n        return SDValue();\n\n      // We know that the # elements of the results is the same as the\n      // # elements of the compare (and the # elements of the compare result\n      // for that matter).  Check to see that they are the same size.  If so,\n      // we know that the element size of the sext'd result matches the\n      // element size of the compare operands.\n      if (VT.getSizeInBits() == N00VT.getSizeInBits())\n        return DAG.getSetCC(SDLoc(N), VT, N0.getOperand(0),\n                             N0.getOperand(1),\n                             cast<CondCodeSDNode>(N0.getOperand(2))->get());\n\n      // If the desired elements are smaller or larger than the source\n      // elements we can use a matching integer vector type and then\n      // truncate/any extend\n      EVT MatchingVectorType = N00VT.changeVectorElementTypeToInteger();\n      SDValue VsetCC =\n        DAG.getSetCC(SDLoc(N), MatchingVectorType, N0.getOperand(0),\n                      N0.getOperand(1),\n                      cast<CondCodeSDNode>(N0.getOperand(2))->get());\n      return DAG.getAnyExtOrTrunc(VsetCC, SDLoc(N), VT);\n    }\n\n    // aext(setcc x,y,cc) -> select_cc x, y, 1, 0, cc\n    SDLoc DL(N);\n    if (SDValue SCC = SimplifySelectCC(\n            DL, N0.getOperand(0), N0.getOperand(1), DAG.getConstant(1, DL, VT),\n            DAG.getConstant(0, DL, VT),\n            cast<CondCodeSDNode>(N0.getOperand(2))->get(), true))\n      return SCC;\n  }\n\n  if (SDValue NewCtPop = widenCtPop(N, DAG))\n    return NewCtPop;\n\n  if (SDValue Res = tryToFoldExtendSelectLoad(N, TLI, DAG))\n    return Res;\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitAssertExt(SDNode *N) {\n  unsigned Opcode = N->getOpcode();\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  EVT AssertVT = cast<VTSDNode>(N1)->getVT();\n\n  // fold (assert?ext (assert?ext x, vt), vt) -> (assert?ext x, vt)\n  if (N0.getOpcode() == Opcode &&\n      AssertVT == cast<VTSDNode>(N0.getOperand(1))->getVT())\n    return N0;\n\n  if (N0.getOpcode() == ISD::TRUNCATE && N0.hasOneUse() &&\n      N0.getOperand(0).getOpcode() == Opcode) {\n    // We have an assert, truncate, assert sandwich. Make one stronger assert\n    // by asserting on the smallest asserted type to the larger source type.\n    // This eliminates the later assert:\n    // assert (trunc (assert X, i8) to iN), i1 --> trunc (assert X, i1) to iN\n    // assert (trunc (assert X, i1) to iN), i8 --> trunc (assert X, i1) to iN\n    SDValue BigA = N0.getOperand(0);\n    EVT BigA_AssertVT = cast<VTSDNode>(BigA.getOperand(1))->getVT();\n    assert(BigA_AssertVT.bitsLE(N0.getValueType()) &&\n           \"Asserting zero/sign-extended bits to a type larger than the \"\n           \"truncated destination does not provide information\");\n\n    SDLoc DL(N);\n    EVT MinAssertVT = AssertVT.bitsLT(BigA_AssertVT) ? AssertVT : BigA_AssertVT;\n    SDValue MinAssertVTVal = DAG.getValueType(MinAssertVT);\n    SDValue NewAssert = DAG.getNode(Opcode, DL, BigA.getValueType(),\n                                    BigA.getOperand(0), MinAssertVTVal);\n    return DAG.getNode(ISD::TRUNCATE, DL, N->getValueType(0), NewAssert);\n  }\n\n  // If we have (AssertZext (truncate (AssertSext X, iX)), iY) and Y is smaller\n  // than X. Just move the AssertZext in front of the truncate and drop the\n  // AssertSExt.\n  if (N0.getOpcode() == ISD::TRUNCATE && N0.hasOneUse() &&\n      N0.getOperand(0).getOpcode() == ISD::AssertSext &&\n      Opcode == ISD::AssertZext) {\n    SDValue BigA = N0.getOperand(0);\n    EVT BigA_AssertVT = cast<VTSDNode>(BigA.getOperand(1))->getVT();\n    assert(BigA_AssertVT.bitsLE(N0.getValueType()) &&\n           \"Asserting zero/sign-extended bits to a type larger than the \"\n           \"truncated destination does not provide information\");\n\n    if (AssertVT.bitsLT(BigA_AssertVT)) {\n      SDLoc DL(N);\n      SDValue NewAssert = DAG.getNode(Opcode, DL, BigA.getValueType(),\n                                      BigA.getOperand(0), N1);\n      return DAG.getNode(ISD::TRUNCATE, DL, N->getValueType(0), NewAssert);\n    }\n  }\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitAssertAlign(SDNode *N) {\n  SDLoc DL(N);\n\n  Align AL = cast<AssertAlignSDNode>(N)->getAlign();\n  SDValue N0 = N->getOperand(0);\n\n  // Fold (assertalign (assertalign x, AL0), AL1) ->\n  // (assertalign x, max(AL0, AL1))\n  if (auto *AAN = dyn_cast<AssertAlignSDNode>(N0))\n    return DAG.getAssertAlign(DL, N0.getOperand(0),\n                              std::max(AL, AAN->getAlign()));\n\n  // In rare cases, there are trivial arithmetic ops in source operands. Sink\n  // this assert down to source operands so that those arithmetic ops could be\n  // exposed to the DAG combining.\n  switch (N0.getOpcode()) {\n  default:\n    break;\n  case ISD::ADD:\n  case ISD::SUB: {\n    unsigned AlignShift = Log2(AL);\n    SDValue LHS = N0.getOperand(0);\n    SDValue RHS = N0.getOperand(1);\n    unsigned LHSAlignShift = DAG.computeKnownBits(LHS).countMinTrailingZeros();\n    unsigned RHSAlignShift = DAG.computeKnownBits(RHS).countMinTrailingZeros();\n    if (LHSAlignShift >= AlignShift || RHSAlignShift >= AlignShift) {\n      if (LHSAlignShift < AlignShift)\n        LHS = DAG.getAssertAlign(DL, LHS, AL);\n      if (RHSAlignShift < AlignShift)\n        RHS = DAG.getAssertAlign(DL, RHS, AL);\n      return DAG.getNode(N0.getOpcode(), DL, N0.getValueType(), LHS, RHS);\n    }\n    break;\n  }\n  }\n\n  return SDValue();\n}\n\n/// If the result of a wider load is shifted to right of N  bits and then\n/// truncated to a narrower type and where N is a multiple of number of bits of\n/// the narrower type, transform it to a narrower load from address + N / num of\n/// bits of new type. Also narrow the load if the result is masked with an AND\n/// to effectively produce a smaller type. If the result is to be extended, also\n/// fold the extension to form a extending load.\nSDValue DAGCombiner::ReduceLoadWidth(SDNode *N) {\n  unsigned Opc = N->getOpcode();\n\n  ISD::LoadExtType ExtType = ISD::NON_EXTLOAD;\n  SDValue N0 = N->getOperand(0);\n  EVT VT = N->getValueType(0);\n  EVT ExtVT = VT;\n\n  // This transformation isn't valid for vector loads.\n  if (VT.isVector())\n    return SDValue();\n\n  unsigned ShAmt = 0;\n  bool HasShiftedOffset = false;\n  // Special case: SIGN_EXTEND_INREG is basically truncating to ExtVT then\n  // extended to VT.\n  if (Opc == ISD::SIGN_EXTEND_INREG) {\n    ExtType = ISD::SEXTLOAD;\n    ExtVT = cast<VTSDNode>(N->getOperand(1))->getVT();\n  } else if (Opc == ISD::SRL) {\n    // Another special-case: SRL is basically zero-extending a narrower value,\n    // or it maybe shifting a higher subword, half or byte into the lowest\n    // bits.\n    ExtType = ISD::ZEXTLOAD;\n    N0 = SDValue(N, 0);\n\n    auto *LN0 = dyn_cast<LoadSDNode>(N0.getOperand(0));\n    auto *N01 = dyn_cast<ConstantSDNode>(N0.getOperand(1));\n    if (!N01 || !LN0)\n      return SDValue();\n\n    uint64_t ShiftAmt = N01->getZExtValue();\n    uint64_t MemoryWidth = LN0->getMemoryVT().getScalarSizeInBits();\n    if (LN0->getExtensionType() != ISD::SEXTLOAD && MemoryWidth > ShiftAmt)\n      ExtVT = EVT::getIntegerVT(*DAG.getContext(), MemoryWidth - ShiftAmt);\n    else\n      ExtVT = EVT::getIntegerVT(*DAG.getContext(),\n                                VT.getScalarSizeInBits() - ShiftAmt);\n  } else if (Opc == ISD::AND) {\n    // An AND with a constant mask is the same as a truncate + zero-extend.\n    auto AndC = dyn_cast<ConstantSDNode>(N->getOperand(1));\n    if (!AndC)\n      return SDValue();\n\n    const APInt &Mask = AndC->getAPIntValue();\n    unsigned ActiveBits = 0;\n    if (Mask.isMask()) {\n      ActiveBits = Mask.countTrailingOnes();\n    } else if (Mask.isShiftedMask()) {\n      ShAmt = Mask.countTrailingZeros();\n      APInt ShiftedMask = Mask.lshr(ShAmt);\n      ActiveBits = ShiftedMask.countTrailingOnes();\n      HasShiftedOffset = true;\n    } else\n      return SDValue();\n\n    ExtType = ISD::ZEXTLOAD;\n    ExtVT = EVT::getIntegerVT(*DAG.getContext(), ActiveBits);\n  }\n\n  if (N0.getOpcode() == ISD::SRL && N0.hasOneUse()) {\n    SDValue SRL = N0;\n    if (auto *ConstShift = dyn_cast<ConstantSDNode>(SRL.getOperand(1))) {\n      ShAmt = ConstShift->getZExtValue();\n      unsigned EVTBits = ExtVT.getScalarSizeInBits();\n      // Is the shift amount a multiple of size of VT?\n      if ((ShAmt & (EVTBits-1)) == 0) {\n        N0 = N0.getOperand(0);\n        // Is the load width a multiple of size of VT?\n        if ((N0.getScalarValueSizeInBits() & (EVTBits - 1)) != 0)\n          return SDValue();\n      }\n\n      // At this point, we must have a load or else we can't do the transform.\n      auto *LN0 = dyn_cast<LoadSDNode>(N0);\n      if (!LN0) return SDValue();\n\n      // Because a SRL must be assumed to *need* to zero-extend the high bits\n      // (as opposed to anyext the high bits), we can't combine the zextload\n      // lowering of SRL and an sextload.\n      if (LN0->getExtensionType() == ISD::SEXTLOAD)\n        return SDValue();\n\n      // If the shift amount is larger than the input type then we're not\n      // accessing any of the loaded bytes.  If the load was a zextload/extload\n      // then the result of the shift+trunc is zero/undef (handled elsewhere).\n      if (ShAmt >= LN0->getMemoryVT().getSizeInBits())\n        return SDValue();\n\n      // If the SRL is only used by a masking AND, we may be able to adjust\n      // the ExtVT to make the AND redundant.\n      SDNode *Mask = *(SRL->use_begin());\n      if (Mask->getOpcode() == ISD::AND &&\n          isa<ConstantSDNode>(Mask->getOperand(1))) {\n        const APInt& ShiftMask = Mask->getConstantOperandAPInt(1);\n        if (ShiftMask.isMask()) {\n          EVT MaskedVT = EVT::getIntegerVT(*DAG.getContext(),\n                                           ShiftMask.countTrailingOnes());\n          // If the mask is smaller, recompute the type.\n          if ((ExtVT.getScalarSizeInBits() > MaskedVT.getScalarSizeInBits()) &&\n              TLI.isLoadExtLegal(ExtType, N0.getValueType(), MaskedVT))\n            ExtVT = MaskedVT;\n        }\n      }\n    }\n  }\n\n  // If the load is shifted left (and the result isn't shifted back right),\n  // we can fold the truncate through the shift.\n  unsigned ShLeftAmt = 0;\n  if (ShAmt == 0 && N0.getOpcode() == ISD::SHL && N0.hasOneUse() &&\n      ExtVT == VT && TLI.isNarrowingProfitable(N0.getValueType(), VT)) {\n    if (ConstantSDNode *N01 = dyn_cast<ConstantSDNode>(N0.getOperand(1))) {\n      ShLeftAmt = N01->getZExtValue();\n      N0 = N0.getOperand(0);\n    }\n  }\n\n  // If we haven't found a load, we can't narrow it.\n  if (!isa<LoadSDNode>(N0))\n    return SDValue();\n\n  LoadSDNode *LN0 = cast<LoadSDNode>(N0);\n  // Reducing the width of a volatile load is illegal.  For atomics, we may be\n  // able to reduce the width provided we never widen again. (see D66309)\n  if (!LN0->isSimple() ||\n      !isLegalNarrowLdSt(LN0, ExtType, ExtVT, ShAmt))\n    return SDValue();\n\n  auto AdjustBigEndianShift = [&](unsigned ShAmt) {\n    unsigned LVTStoreBits =\n        LN0->getMemoryVT().getStoreSizeInBits().getFixedSize();\n    unsigned EVTStoreBits = ExtVT.getStoreSizeInBits().getFixedSize();\n    return LVTStoreBits - EVTStoreBits - ShAmt;\n  };\n\n  // For big endian targets, we need to adjust the offset to the pointer to\n  // load the correct bytes.\n  if (DAG.getDataLayout().isBigEndian())\n    ShAmt = AdjustBigEndianShift(ShAmt);\n\n  uint64_t PtrOff = ShAmt / 8;\n  Align NewAlign = commonAlignment(LN0->getAlign(), PtrOff);\n  SDLoc DL(LN0);\n  // The original load itself didn't wrap, so an offset within it doesn't.\n  SDNodeFlags Flags;\n  Flags.setNoUnsignedWrap(true);\n  SDValue NewPtr = DAG.getMemBasePlusOffset(LN0->getBasePtr(),\n                                            TypeSize::Fixed(PtrOff), DL, Flags);\n  AddToWorklist(NewPtr.getNode());\n\n  SDValue Load;\n  if (ExtType == ISD::NON_EXTLOAD)\n    Load = DAG.getLoad(VT, DL, LN0->getChain(), NewPtr,\n                       LN0->getPointerInfo().getWithOffset(PtrOff), NewAlign,\n                       LN0->getMemOperand()->getFlags(), LN0->getAAInfo());\n  else\n    Load = DAG.getExtLoad(ExtType, DL, VT, LN0->getChain(), NewPtr,\n                          LN0->getPointerInfo().getWithOffset(PtrOff), ExtVT,\n                          NewAlign, LN0->getMemOperand()->getFlags(),\n                          LN0->getAAInfo());\n\n  // Replace the old load's chain with the new load's chain.\n  WorklistRemover DeadNodes(*this);\n  DAG.ReplaceAllUsesOfValueWith(N0.getValue(1), Load.getValue(1));\n\n  // Shift the result left, if we've swallowed a left shift.\n  SDValue Result = Load;\n  if (ShLeftAmt != 0) {\n    EVT ShImmTy = getShiftAmountTy(Result.getValueType());\n    if (!isUIntN(ShImmTy.getScalarSizeInBits(), ShLeftAmt))\n      ShImmTy = VT;\n    // If the shift amount is as large as the result size (but, presumably,\n    // no larger than the source) then the useful bits of the result are\n    // zero; we can't simply return the shortened shift, because the result\n    // of that operation is undefined.\n    if (ShLeftAmt >= VT.getScalarSizeInBits())\n      Result = DAG.getConstant(0, DL, VT);\n    else\n      Result = DAG.getNode(ISD::SHL, DL, VT,\n                          Result, DAG.getConstant(ShLeftAmt, DL, ShImmTy));\n  }\n\n  if (HasShiftedOffset) {\n    // Recalculate the shift amount after it has been altered to calculate\n    // the offset.\n    if (DAG.getDataLayout().isBigEndian())\n      ShAmt = AdjustBigEndianShift(ShAmt);\n\n    // We're using a shifted mask, so the load now has an offset. This means\n    // that data has been loaded into the lower bytes than it would have been\n    // before, so we need to shl the loaded data into the correct position in the\n    // register.\n    SDValue ShiftC = DAG.getConstant(ShAmt, DL, VT);\n    Result = DAG.getNode(ISD::SHL, DL, VT, Result, ShiftC);\n    DAG.ReplaceAllUsesOfValueWith(SDValue(N, 0), Result);\n  }\n\n  // Return the new loaded value.\n  return Result;\n}\n\nSDValue DAGCombiner::visitSIGN_EXTEND_INREG(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  EVT VT = N->getValueType(0);\n  EVT ExtVT = cast<VTSDNode>(N1)->getVT();\n  unsigned VTBits = VT.getScalarSizeInBits();\n  unsigned ExtVTBits = ExtVT.getScalarSizeInBits();\n\n  // sext_vector_inreg(undef) = 0 because the top bit will all be the same.\n  if (N0.isUndef())\n    return DAG.getConstant(0, SDLoc(N), VT);\n\n  // fold (sext_in_reg c1) -> c1\n  if (DAG.isConstantIntBuildVectorOrConstantInt(N0))\n    return DAG.getNode(ISD::SIGN_EXTEND_INREG, SDLoc(N), VT, N0, N1);\n\n  // If the input is already sign extended, just drop the extension.\n  if (DAG.ComputeNumSignBits(N0) >= (VTBits - ExtVTBits + 1))\n    return N0;\n\n  // fold (sext_in_reg (sext_in_reg x, VT2), VT1) -> (sext_in_reg x, minVT) pt2\n  if (N0.getOpcode() == ISD::SIGN_EXTEND_INREG &&\n      ExtVT.bitsLT(cast<VTSDNode>(N0.getOperand(1))->getVT()))\n    return DAG.getNode(ISD::SIGN_EXTEND_INREG, SDLoc(N), VT, N0.getOperand(0),\n                       N1);\n\n  // fold (sext_in_reg (sext x)) -> (sext x)\n  // fold (sext_in_reg (aext x)) -> (sext x)\n  // if x is small enough or if we know that x has more than 1 sign bit and the\n  // sign_extend_inreg is extending from one of them.\n  if (N0.getOpcode() == ISD::SIGN_EXTEND || N0.getOpcode() == ISD::ANY_EXTEND) {\n    SDValue N00 = N0.getOperand(0);\n    unsigned N00Bits = N00.getScalarValueSizeInBits();\n    if ((N00Bits <= ExtVTBits ||\n         (N00Bits - DAG.ComputeNumSignBits(N00)) < ExtVTBits) &&\n        (!LegalOperations || TLI.isOperationLegal(ISD::SIGN_EXTEND, VT)))\n      return DAG.getNode(ISD::SIGN_EXTEND, SDLoc(N), VT, N00);\n  }\n\n  // fold (sext_in_reg (*_extend_vector_inreg x)) -> (sext_vector_inreg x)\n  // if x is small enough or if we know that x has more than 1 sign bit and the\n  // sign_extend_inreg is extending from one of them.\n  if (N0.getOpcode() == ISD::ANY_EXTEND_VECTOR_INREG ||\n      N0.getOpcode() == ISD::SIGN_EXTEND_VECTOR_INREG ||\n      N0.getOpcode() == ISD::ZERO_EXTEND_VECTOR_INREG) {\n    SDValue N00 = N0.getOperand(0);\n    unsigned N00Bits = N00.getScalarValueSizeInBits();\n    unsigned DstElts = N0.getValueType().getVectorMinNumElements();\n    unsigned SrcElts = N00.getValueType().getVectorMinNumElements();\n    APInt DemandedSrcElts = APInt::getLowBitsSet(SrcElts, DstElts);\n    if ((N00Bits == ExtVTBits ||\n         (N00Bits - DAG.ComputeNumSignBits(N00, DemandedSrcElts)) <\n             ExtVTBits) &&\n        (!LegalOperations ||\n         TLI.isOperationLegal(ISD::SIGN_EXTEND_VECTOR_INREG, VT)))\n      return DAG.getNode(ISD::SIGN_EXTEND_VECTOR_INREG, SDLoc(N), VT, N00);\n  }\n\n  // fold (sext_in_reg (zext x)) -> (sext x)\n  // iff we are extending the source sign bit.\n  if (N0.getOpcode() == ISD::ZERO_EXTEND) {\n    SDValue N00 = N0.getOperand(0);\n    if (N00.getScalarValueSizeInBits() == ExtVTBits &&\n        (!LegalOperations || TLI.isOperationLegal(ISD::SIGN_EXTEND, VT)))\n      return DAG.getNode(ISD::SIGN_EXTEND, SDLoc(N), VT, N00, N1);\n  }\n\n  // fold (sext_in_reg x) -> (zext_in_reg x) if the sign bit is known zero.\n  if (DAG.MaskedValueIsZero(N0, APInt::getOneBitSet(VTBits, ExtVTBits - 1)))\n    return DAG.getZeroExtendInReg(N0, SDLoc(N), ExtVT);\n\n  // fold operands of sext_in_reg based on knowledge that the top bits are not\n  // demanded.\n  if (SimplifyDemandedBits(SDValue(N, 0)))\n    return SDValue(N, 0);\n\n  // fold (sext_in_reg (load x)) -> (smaller sextload x)\n  // fold (sext_in_reg (srl (load x), c)) -> (smaller sextload (x+c/evtbits))\n  if (SDValue NarrowLoad = ReduceLoadWidth(N))\n    return NarrowLoad;\n\n  // fold (sext_in_reg (srl X, 24), i8) -> (sra X, 24)\n  // fold (sext_in_reg (srl X, 23), i8) -> (sra X, 23) iff possible.\n  // We already fold \"(sext_in_reg (srl X, 25), i8) -> srl X, 25\" above.\n  if (N0.getOpcode() == ISD::SRL) {\n    if (auto *ShAmt = dyn_cast<ConstantSDNode>(N0.getOperand(1)))\n      if (ShAmt->getAPIntValue().ule(VTBits - ExtVTBits)) {\n        // We can turn this into an SRA iff the input to the SRL is already sign\n        // extended enough.\n        unsigned InSignBits = DAG.ComputeNumSignBits(N0.getOperand(0));\n        if (((VTBits - ExtVTBits) - ShAmt->getZExtValue()) < InSignBits)\n          return DAG.getNode(ISD::SRA, SDLoc(N), VT, N0.getOperand(0),\n                             N0.getOperand(1));\n      }\n  }\n\n  // fold (sext_inreg (extload x)) -> (sextload x)\n  // If sextload is not supported by target, we can only do the combine when\n  // load has one use. Doing otherwise can block folding the extload with other\n  // extends that the target does support.\n  if (ISD::isEXTLoad(N0.getNode()) &&\n      ISD::isUNINDEXEDLoad(N0.getNode()) &&\n      ExtVT == cast<LoadSDNode>(N0)->getMemoryVT() &&\n      ((!LegalOperations && cast<LoadSDNode>(N0)->isSimple() &&\n        N0.hasOneUse()) ||\n       TLI.isLoadExtLegal(ISD::SEXTLOAD, VT, ExtVT))) {\n    LoadSDNode *LN0 = cast<LoadSDNode>(N0);\n    SDValue ExtLoad = DAG.getExtLoad(ISD::SEXTLOAD, SDLoc(N), VT,\n                                     LN0->getChain(),\n                                     LN0->getBasePtr(), ExtVT,\n                                     LN0->getMemOperand());\n    CombineTo(N, ExtLoad);\n    CombineTo(N0.getNode(), ExtLoad, ExtLoad.getValue(1));\n    AddToWorklist(ExtLoad.getNode());\n    return SDValue(N, 0);   // Return N so it doesn't get rechecked!\n  }\n  // fold (sext_inreg (zextload x)) -> (sextload x) iff load has one use\n  if (ISD::isZEXTLoad(N0.getNode()) && ISD::isUNINDEXEDLoad(N0.getNode()) &&\n      N0.hasOneUse() &&\n      ExtVT == cast<LoadSDNode>(N0)->getMemoryVT() &&\n      ((!LegalOperations && cast<LoadSDNode>(N0)->isSimple()) &&\n       TLI.isLoadExtLegal(ISD::SEXTLOAD, VT, ExtVT))) {\n    LoadSDNode *LN0 = cast<LoadSDNode>(N0);\n    SDValue ExtLoad = DAG.getExtLoad(ISD::SEXTLOAD, SDLoc(N), VT,\n                                     LN0->getChain(),\n                                     LN0->getBasePtr(), ExtVT,\n                                     LN0->getMemOperand());\n    CombineTo(N, ExtLoad);\n    CombineTo(N0.getNode(), ExtLoad, ExtLoad.getValue(1));\n    return SDValue(N, 0);   // Return N so it doesn't get rechecked!\n  }\n\n  // fold (sext_inreg (masked_load x)) -> (sext_masked_load x)\n  // ignore it if the masked load is already sign extended\n  if (MaskedLoadSDNode *Ld = dyn_cast<MaskedLoadSDNode>(N0)) {\n    if (ExtVT == Ld->getMemoryVT() && N0.hasOneUse() &&\n        Ld->getExtensionType() != ISD::LoadExtType::NON_EXTLOAD &&\n        TLI.isLoadExtLegal(ISD::SEXTLOAD, VT, ExtVT)) {\n      SDValue ExtMaskedLoad = DAG.getMaskedLoad(\n          VT, SDLoc(N), Ld->getChain(), Ld->getBasePtr(), Ld->getOffset(),\n          Ld->getMask(), Ld->getPassThru(), ExtVT, Ld->getMemOperand(),\n          Ld->getAddressingMode(), ISD::SEXTLOAD, Ld->isExpandingLoad());\n      CombineTo(N, ExtMaskedLoad);\n      CombineTo(N0.getNode(), ExtMaskedLoad, ExtMaskedLoad.getValue(1));\n      return SDValue(N, 0); // Return N so it doesn't get rechecked!\n    }\n  }\n\n  // fold (sext_inreg (masked_gather x)) -> (sext_masked_gather x)\n  if (auto *GN0 = dyn_cast<MaskedGatherSDNode>(N0)) {\n    if (SDValue(GN0, 0).hasOneUse() &&\n        ExtVT == GN0->getMemoryVT() &&\n        TLI.isVectorLoadExtDesirable(SDValue(SDValue(GN0, 0)))) {\n      SDValue Ops[] = {GN0->getChain(),   GN0->getPassThru(), GN0->getMask(),\n                       GN0->getBasePtr(), GN0->getIndex(),    GN0->getScale()};\n\n      SDValue ExtLoad = DAG.getMaskedGather(\n          DAG.getVTList(VT, MVT::Other), ExtVT, SDLoc(N), Ops,\n          GN0->getMemOperand(), GN0->getIndexType(), ISD::SEXTLOAD);\n\n      CombineTo(N, ExtLoad);\n      CombineTo(N0.getNode(), ExtLoad, ExtLoad.getValue(1));\n      AddToWorklist(ExtLoad.getNode());\n      return SDValue(N, 0); // Return N so it doesn't get rechecked!\n    }\n  }\n\n  // Form (sext_inreg (bswap >> 16)) or (sext_inreg (rotl (bswap) 16))\n  if (ExtVTBits <= 16 && N0.getOpcode() == ISD::OR) {\n    if (SDValue BSwap = MatchBSwapHWordLow(N0.getNode(), N0.getOperand(0),\n                                           N0.getOperand(1), false))\n      return DAG.getNode(ISD::SIGN_EXTEND_INREG, SDLoc(N), VT, BSwap, N1);\n  }\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitSIGN_EXTEND_VECTOR_INREG(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  EVT VT = N->getValueType(0);\n\n  // sext_vector_inreg(undef) = 0 because the top bit will all be the same.\n  if (N0.isUndef())\n    return DAG.getConstant(0, SDLoc(N), VT);\n\n  if (SDValue Res = tryToFoldExtendOfConstant(N, TLI, DAG, LegalTypes))\n    return Res;\n\n  if (SimplifyDemandedVectorElts(SDValue(N, 0)))\n    return SDValue(N, 0);\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitZERO_EXTEND_VECTOR_INREG(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  EVT VT = N->getValueType(0);\n\n  // zext_vector_inreg(undef) = 0 because the top bits will be zero.\n  if (N0.isUndef())\n    return DAG.getConstant(0, SDLoc(N), VT);\n\n  if (SDValue Res = tryToFoldExtendOfConstant(N, TLI, DAG, LegalTypes))\n    return Res;\n\n  if (SimplifyDemandedVectorElts(SDValue(N, 0)))\n    return SDValue(N, 0);\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitTRUNCATE(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  EVT VT = N->getValueType(0);\n  EVT SrcVT = N0.getValueType();\n  bool isLE = DAG.getDataLayout().isLittleEndian();\n\n  // noop truncate\n  if (SrcVT == VT)\n    return N0;\n\n  // fold (truncate (truncate x)) -> (truncate x)\n  if (N0.getOpcode() == ISD::TRUNCATE)\n    return DAG.getNode(ISD::TRUNCATE, SDLoc(N), VT, N0.getOperand(0));\n\n  // fold (truncate c1) -> c1\n  if (DAG.isConstantIntBuildVectorOrConstantInt(N0)) {\n    SDValue C = DAG.getNode(ISD::TRUNCATE, SDLoc(N), VT, N0);\n    if (C.getNode() != N)\n      return C;\n  }\n\n  // fold (truncate (ext x)) -> (ext x) or (truncate x) or x\n  if (N0.getOpcode() == ISD::ZERO_EXTEND ||\n      N0.getOpcode() == ISD::SIGN_EXTEND ||\n      N0.getOpcode() == ISD::ANY_EXTEND) {\n    // if the source is smaller than the dest, we still need an extend.\n    if (N0.getOperand(0).getValueType().bitsLT(VT))\n      return DAG.getNode(N0.getOpcode(), SDLoc(N), VT, N0.getOperand(0));\n    // if the source is larger than the dest, than we just need the truncate.\n    if (N0.getOperand(0).getValueType().bitsGT(VT))\n      return DAG.getNode(ISD::TRUNCATE, SDLoc(N), VT, N0.getOperand(0));\n    // if the source and dest are the same type, we can drop both the extend\n    // and the truncate.\n    return N0.getOperand(0);\n  }\n\n  // If this is anyext(trunc), don't fold it, allow ourselves to be folded.\n  if (N->hasOneUse() && (N->use_begin()->getOpcode() == ISD::ANY_EXTEND))\n    return SDValue();\n\n  // Fold extract-and-trunc into a narrow extract. For example:\n  //   i64 x = EXTRACT_VECTOR_ELT(v2i64 val, i32 1)\n  //   i32 y = TRUNCATE(i64 x)\n  //        -- becomes --\n  //   v16i8 b = BITCAST (v2i64 val)\n  //   i8 x = EXTRACT_VECTOR_ELT(v16i8 b, i32 8)\n  //\n  // Note: We only run this optimization after type legalization (which often\n  // creates this pattern) and before operation legalization after which\n  // we need to be more careful about the vector instructions that we generate.\n  if (N0.getOpcode() == ISD::EXTRACT_VECTOR_ELT &&\n      LegalTypes && !LegalOperations && N0->hasOneUse() && VT != MVT::i1) {\n    EVT VecTy = N0.getOperand(0).getValueType();\n    EVT ExTy = N0.getValueType();\n    EVT TrTy = N->getValueType(0);\n\n    auto EltCnt = VecTy.getVectorElementCount();\n    unsigned SizeRatio = ExTy.getSizeInBits()/TrTy.getSizeInBits();\n    auto NewEltCnt = EltCnt * SizeRatio;\n\n    EVT NVT = EVT::getVectorVT(*DAG.getContext(), TrTy, NewEltCnt);\n    assert(NVT.getSizeInBits() == VecTy.getSizeInBits() && \"Invalid Size\");\n\n    SDValue EltNo = N0->getOperand(1);\n    if (isa<ConstantSDNode>(EltNo) && isTypeLegal(NVT)) {\n      int Elt = cast<ConstantSDNode>(EltNo)->getZExtValue();\n      int Index = isLE ? (Elt*SizeRatio) : (Elt*SizeRatio + (SizeRatio-1));\n\n      SDLoc DL(N);\n      return DAG.getNode(ISD::EXTRACT_VECTOR_ELT, DL, TrTy,\n                         DAG.getBitcast(NVT, N0.getOperand(0)),\n                         DAG.getVectorIdxConstant(Index, DL));\n    }\n  }\n\n  // trunc (select c, a, b) -> select c, (trunc a), (trunc b)\n  if (N0.getOpcode() == ISD::SELECT && N0.hasOneUse()) {\n    if ((!LegalOperations || TLI.isOperationLegal(ISD::SELECT, SrcVT)) &&\n        TLI.isTruncateFree(SrcVT, VT)) {\n      SDLoc SL(N0);\n      SDValue Cond = N0.getOperand(0);\n      SDValue TruncOp0 = DAG.getNode(ISD::TRUNCATE, SL, VT, N0.getOperand(1));\n      SDValue TruncOp1 = DAG.getNode(ISD::TRUNCATE, SL, VT, N0.getOperand(2));\n      return DAG.getNode(ISD::SELECT, SDLoc(N), VT, Cond, TruncOp0, TruncOp1);\n    }\n  }\n\n  // trunc (shl x, K) -> shl (trunc x), K => K < VT.getScalarSizeInBits()\n  if (N0.getOpcode() == ISD::SHL && N0.hasOneUse() &&\n      (!LegalOperations || TLI.isOperationLegal(ISD::SHL, VT)) &&\n      TLI.isTypeDesirableForOp(ISD::SHL, VT)) {\n    SDValue Amt = N0.getOperand(1);\n    KnownBits Known = DAG.computeKnownBits(Amt);\n    unsigned Size = VT.getScalarSizeInBits();\n    if (Known.getBitWidth() - Known.countMinLeadingZeros() <= Log2_32(Size)) {\n      SDLoc SL(N);\n      EVT AmtVT = TLI.getShiftAmountTy(VT, DAG.getDataLayout());\n\n      SDValue Trunc = DAG.getNode(ISD::TRUNCATE, SL, VT, N0.getOperand(0));\n      if (AmtVT != Amt.getValueType()) {\n        Amt = DAG.getZExtOrTrunc(Amt, SL, AmtVT);\n        AddToWorklist(Amt.getNode());\n      }\n      return DAG.getNode(ISD::SHL, SL, VT, Trunc, Amt);\n    }\n  }\n\n  if (SDValue V = foldSubToUSubSat(VT, N0.getNode()))\n    return V;\n\n  // Attempt to pre-truncate BUILD_VECTOR sources.\n  if (N0.getOpcode() == ISD::BUILD_VECTOR && !LegalOperations &&\n      TLI.isTruncateFree(SrcVT.getScalarType(), VT.getScalarType()) &&\n      // Avoid creating illegal types if running after type legalizer.\n      (!LegalTypes || TLI.isTypeLegal(VT.getScalarType()))) {\n    SDLoc DL(N);\n    EVT SVT = VT.getScalarType();\n    SmallVector<SDValue, 8> TruncOps;\n    for (const SDValue &Op : N0->op_values()) {\n      SDValue TruncOp = DAG.getNode(ISD::TRUNCATE, DL, SVT, Op);\n      TruncOps.push_back(TruncOp);\n    }\n    return DAG.getBuildVector(VT, DL, TruncOps);\n  }\n\n  // Fold a series of buildvector, bitcast, and truncate if possible.\n  // For example fold\n  //   (2xi32 trunc (bitcast ((4xi32)buildvector x, x, y, y) 2xi64)) to\n  //   (2xi32 (buildvector x, y)).\n  if (Level == AfterLegalizeVectorOps && VT.isVector() &&\n      N0.getOpcode() == ISD::BITCAST && N0.hasOneUse() &&\n      N0.getOperand(0).getOpcode() == ISD::BUILD_VECTOR &&\n      N0.getOperand(0).hasOneUse()) {\n    SDValue BuildVect = N0.getOperand(0);\n    EVT BuildVectEltTy = BuildVect.getValueType().getVectorElementType();\n    EVT TruncVecEltTy = VT.getVectorElementType();\n\n    // Check that the element types match.\n    if (BuildVectEltTy == TruncVecEltTy) {\n      // Now we only need to compute the offset of the truncated elements.\n      unsigned BuildVecNumElts =  BuildVect.getNumOperands();\n      unsigned TruncVecNumElts = VT.getVectorNumElements();\n      unsigned TruncEltOffset = BuildVecNumElts / TruncVecNumElts;\n\n      assert((BuildVecNumElts % TruncVecNumElts) == 0 &&\n             \"Invalid number of elements\");\n\n      SmallVector<SDValue, 8> Opnds;\n      for (unsigned i = 0, e = BuildVecNumElts; i != e; i += TruncEltOffset)\n        Opnds.push_back(BuildVect.getOperand(i));\n\n      return DAG.getBuildVector(VT, SDLoc(N), Opnds);\n    }\n  }\n\n  // See if we can simplify the input to this truncate through knowledge that\n  // only the low bits are being used.\n  // For example \"trunc (or (shl x, 8), y)\" // -> trunc y\n  // Currently we only perform this optimization on scalars because vectors\n  // may have different active low bits.\n  if (!VT.isVector()) {\n    APInt Mask =\n        APInt::getLowBitsSet(N0.getValueSizeInBits(), VT.getSizeInBits());\n    if (SDValue Shorter = DAG.GetDemandedBits(N0, Mask))\n      return DAG.getNode(ISD::TRUNCATE, SDLoc(N), VT, Shorter);\n  }\n\n  // fold (truncate (load x)) -> (smaller load x)\n  // fold (truncate (srl (load x), c)) -> (smaller load (x+c/evtbits))\n  if (!LegalTypes || TLI.isTypeDesirableForOp(N0.getOpcode(), VT)) {\n    if (SDValue Reduced = ReduceLoadWidth(N))\n      return Reduced;\n\n    // Handle the case where the load remains an extending load even\n    // after truncation.\n    if (N0.hasOneUse() && ISD::isUNINDEXEDLoad(N0.getNode())) {\n      LoadSDNode *LN0 = cast<LoadSDNode>(N0);\n      if (LN0->isSimple() && LN0->getMemoryVT().bitsLT(VT)) {\n        SDValue NewLoad = DAG.getExtLoad(LN0->getExtensionType(), SDLoc(LN0),\n                                         VT, LN0->getChain(), LN0->getBasePtr(),\n                                         LN0->getMemoryVT(),\n                                         LN0->getMemOperand());\n        DAG.ReplaceAllUsesOfValueWith(N0.getValue(1), NewLoad.getValue(1));\n        return NewLoad;\n      }\n    }\n  }\n\n  // fold (trunc (concat ... x ...)) -> (concat ..., (trunc x), ...)),\n  // where ... are all 'undef'.\n  if (N0.getOpcode() == ISD::CONCAT_VECTORS && !LegalTypes) {\n    SmallVector<EVT, 8> VTs;\n    SDValue V;\n    unsigned Idx = 0;\n    unsigned NumDefs = 0;\n\n    for (unsigned i = 0, e = N0.getNumOperands(); i != e; ++i) {\n      SDValue X = N0.getOperand(i);\n      if (!X.isUndef()) {\n        V = X;\n        Idx = i;\n        NumDefs++;\n      }\n      // Stop if more than one members are non-undef.\n      if (NumDefs > 1)\n        break;\n\n      VTs.push_back(EVT::getVectorVT(*DAG.getContext(),\n                                     VT.getVectorElementType(),\n                                     X.getValueType().getVectorElementCount()));\n    }\n\n    if (NumDefs == 0)\n      return DAG.getUNDEF(VT);\n\n    if (NumDefs == 1) {\n      assert(V.getNode() && \"The single defined operand is empty!\");\n      SmallVector<SDValue, 8> Opnds;\n      for (unsigned i = 0, e = VTs.size(); i != e; ++i) {\n        if (i != Idx) {\n          Opnds.push_back(DAG.getUNDEF(VTs[i]));\n          continue;\n        }\n        SDValue NV = DAG.getNode(ISD::TRUNCATE, SDLoc(V), VTs[i], V);\n        AddToWorklist(NV.getNode());\n        Opnds.push_back(NV);\n      }\n      return DAG.getNode(ISD::CONCAT_VECTORS, SDLoc(N), VT, Opnds);\n    }\n  }\n\n  // Fold truncate of a bitcast of a vector to an extract of the low vector\n  // element.\n  //\n  // e.g. trunc (i64 (bitcast v2i32:x)) -> extract_vector_elt v2i32:x, idx\n  if (N0.getOpcode() == ISD::BITCAST && !VT.isVector()) {\n    SDValue VecSrc = N0.getOperand(0);\n    EVT VecSrcVT = VecSrc.getValueType();\n    if (VecSrcVT.isVector() && VecSrcVT.getScalarType() == VT &&\n        (!LegalOperations ||\n         TLI.isOperationLegal(ISD::EXTRACT_VECTOR_ELT, VecSrcVT))) {\n      SDLoc SL(N);\n\n      unsigned Idx = isLE ? 0 : VecSrcVT.getVectorNumElements() - 1;\n      return DAG.getNode(ISD::EXTRACT_VECTOR_ELT, SL, VT, VecSrc,\n                         DAG.getVectorIdxConstant(Idx, SL));\n    }\n  }\n\n  // Simplify the operands using demanded-bits information.\n  if (SimplifyDemandedBits(SDValue(N, 0)))\n    return SDValue(N, 0);\n\n  // (trunc adde(X, Y, Carry)) -> (adde trunc(X), trunc(Y), Carry)\n  // (trunc addcarry(X, Y, Carry)) -> (addcarry trunc(X), trunc(Y), Carry)\n  // When the adde's carry is not used.\n  if ((N0.getOpcode() == ISD::ADDE || N0.getOpcode() == ISD::ADDCARRY) &&\n      N0.hasOneUse() && !N0.getNode()->hasAnyUseOfValue(1) &&\n      // We only do for addcarry before legalize operation\n      ((!LegalOperations && N0.getOpcode() == ISD::ADDCARRY) ||\n       TLI.isOperationLegal(N0.getOpcode(), VT))) {\n    SDLoc SL(N);\n    auto X = DAG.getNode(ISD::TRUNCATE, SL, VT, N0.getOperand(0));\n    auto Y = DAG.getNode(ISD::TRUNCATE, SL, VT, N0.getOperand(1));\n    auto VTs = DAG.getVTList(VT, N0->getValueType(1));\n    return DAG.getNode(N0.getOpcode(), SL, VTs, X, Y, N0.getOperand(2));\n  }\n\n  // fold (truncate (extract_subvector(ext x))) ->\n  //      (extract_subvector x)\n  // TODO: This can be generalized to cover cases where the truncate and extract\n  // do not fully cancel each other out.\n  if (!LegalTypes && N0.getOpcode() == ISD::EXTRACT_SUBVECTOR) {\n    SDValue N00 = N0.getOperand(0);\n    if (N00.getOpcode() == ISD::SIGN_EXTEND ||\n        N00.getOpcode() == ISD::ZERO_EXTEND ||\n        N00.getOpcode() == ISD::ANY_EXTEND) {\n      if (N00.getOperand(0)->getValueType(0).getVectorElementType() ==\n          VT.getVectorElementType())\n        return DAG.getNode(ISD::EXTRACT_SUBVECTOR, SDLoc(N0->getOperand(0)), VT,\n                           N00.getOperand(0), N0.getOperand(1));\n    }\n  }\n\n  if (SDValue NewVSel = matchVSelectOpSizesWithSetCC(N))\n    return NewVSel;\n\n  // Narrow a suitable binary operation with a non-opaque constant operand by\n  // moving it ahead of the truncate. This is limited to pre-legalization\n  // because targets may prefer a wider type during later combines and invert\n  // this transform.\n  switch (N0.getOpcode()) {\n  case ISD::ADD:\n  case ISD::SUB:\n  case ISD::MUL:\n  case ISD::AND:\n  case ISD::OR:\n  case ISD::XOR:\n    if (!LegalOperations && N0.hasOneUse() &&\n        (isConstantOrConstantVector(N0.getOperand(0), true) ||\n         isConstantOrConstantVector(N0.getOperand(1), true))) {\n      // TODO: We already restricted this to pre-legalization, but for vectors\n      // we are extra cautious to not create an unsupported operation.\n      // Target-specific changes are likely needed to avoid regressions here.\n      if (VT.isScalarInteger() || TLI.isOperationLegal(N0.getOpcode(), VT)) {\n        SDLoc DL(N);\n        SDValue NarrowL = DAG.getNode(ISD::TRUNCATE, DL, VT, N0.getOperand(0));\n        SDValue NarrowR = DAG.getNode(ISD::TRUNCATE, DL, VT, N0.getOperand(1));\n        return DAG.getNode(N0.getOpcode(), DL, VT, NarrowL, NarrowR);\n      }\n    }\n    break;\n  case ISD::USUBSAT:\n    // Truncate the USUBSAT only if LHS is a known zero-extension, its not\n    // enough to know that the upper bits are zero we must ensure that we don't\n    // introduce an extra truncate.\n    if (!LegalOperations && N0.hasOneUse() &&\n        N0.getOperand(0).getOpcode() == ISD::ZERO_EXTEND &&\n        N0.getOperand(0).getOperand(0).getScalarValueSizeInBits() <=\n            VT.getScalarSizeInBits() &&\n        hasOperation(N0.getOpcode(), VT)) {\n      return getTruncatedUSUBSAT(VT, SrcVT, N0.getOperand(0), N0.getOperand(1),\n                                 DAG, SDLoc(N));\n    }\n    break;\n  }\n\n  return SDValue();\n}\n\nstatic SDNode *getBuildPairElt(SDNode *N, unsigned i) {\n  SDValue Elt = N->getOperand(i);\n  if (Elt.getOpcode() != ISD::MERGE_VALUES)\n    return Elt.getNode();\n  return Elt.getOperand(Elt.getResNo()).getNode();\n}\n\n/// build_pair (load, load) -> load\n/// if load locations are consecutive.\nSDValue DAGCombiner::CombineConsecutiveLoads(SDNode *N, EVT VT) {\n  assert(N->getOpcode() == ISD::BUILD_PAIR);\n\n  LoadSDNode *LD1 = dyn_cast<LoadSDNode>(getBuildPairElt(N, 0));\n  LoadSDNode *LD2 = dyn_cast<LoadSDNode>(getBuildPairElt(N, 1));\n\n  // A BUILD_PAIR is always having the least significant part in elt 0 and the\n  // most significant part in elt 1. So when combining into one large load, we\n  // need to consider the endianness.\n  if (DAG.getDataLayout().isBigEndian())\n    std::swap(LD1, LD2);\n\n  if (!LD1 || !LD2 || !ISD::isNON_EXTLoad(LD1) || !LD1->hasOneUse() ||\n      LD1->getAddressSpace() != LD2->getAddressSpace())\n    return SDValue();\n  EVT LD1VT = LD1->getValueType(0);\n  unsigned LD1Bytes = LD1VT.getStoreSize();\n  if (ISD::isNON_EXTLoad(LD2) && LD2->hasOneUse() &&\n      DAG.areNonVolatileConsecutiveLoads(LD2, LD1, LD1Bytes, 1)) {\n    Align Alignment = LD1->getAlign();\n    Align NewAlign = DAG.getDataLayout().getABITypeAlign(\n        VT.getTypeForEVT(*DAG.getContext()));\n\n    if (NewAlign <= Alignment &&\n        (!LegalOperations || TLI.isOperationLegal(ISD::LOAD, VT)))\n      return DAG.getLoad(VT, SDLoc(N), LD1->getChain(), LD1->getBasePtr(),\n                         LD1->getPointerInfo(), Alignment);\n  }\n\n  return SDValue();\n}\n\nstatic unsigned getPPCf128HiElementSelector(const SelectionDAG &DAG) {\n  // On little-endian machines, bitcasting from ppcf128 to i128 does swap the Hi\n  // and Lo parts; on big-endian machines it doesn't.\n  return DAG.getDataLayout().isBigEndian() ? 1 : 0;\n}\n\nstatic SDValue foldBitcastedFPLogic(SDNode *N, SelectionDAG &DAG,\n                                    const TargetLowering &TLI) {\n  // If this is not a bitcast to an FP type or if the target doesn't have\n  // IEEE754-compliant FP logic, we're done.\n  EVT VT = N->getValueType(0);\n  if (!VT.isFloatingPoint() || !TLI.hasBitPreservingFPLogic(VT))\n    return SDValue();\n\n  // TODO: Handle cases where the integer constant is a different scalar\n  // bitwidth to the FP.\n  SDValue N0 = N->getOperand(0);\n  EVT SourceVT = N0.getValueType();\n  if (VT.getScalarSizeInBits() != SourceVT.getScalarSizeInBits())\n    return SDValue();\n\n  unsigned FPOpcode;\n  APInt SignMask;\n  switch (N0.getOpcode()) {\n  case ISD::AND:\n    FPOpcode = ISD::FABS;\n    SignMask = ~APInt::getSignMask(SourceVT.getScalarSizeInBits());\n    break;\n  case ISD::XOR:\n    FPOpcode = ISD::FNEG;\n    SignMask = APInt::getSignMask(SourceVT.getScalarSizeInBits());\n    break;\n  case ISD::OR:\n    FPOpcode = ISD::FABS;\n    SignMask = APInt::getSignMask(SourceVT.getScalarSizeInBits());\n    break;\n  default:\n    return SDValue();\n  }\n\n  // Fold (bitcast int (and (bitcast fp X to int), 0x7fff...) to fp) -> fabs X\n  // Fold (bitcast int (xor (bitcast fp X to int), 0x8000...) to fp) -> fneg X\n  // Fold (bitcast int (or (bitcast fp X to int), 0x8000...) to fp) ->\n  //   fneg (fabs X)\n  SDValue LogicOp0 = N0.getOperand(0);\n  ConstantSDNode *LogicOp1 = isConstOrConstSplat(N0.getOperand(1), true);\n  if (LogicOp1 && LogicOp1->getAPIntValue() == SignMask &&\n      LogicOp0.getOpcode() == ISD::BITCAST &&\n      LogicOp0.getOperand(0).getValueType() == VT) {\n    SDValue FPOp = DAG.getNode(FPOpcode, SDLoc(N), VT, LogicOp0.getOperand(0));\n    NumFPLogicOpsConv++;\n    if (N0.getOpcode() == ISD::OR)\n      return DAG.getNode(ISD::FNEG, SDLoc(N), VT, FPOp);\n    return FPOp;\n  }\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitBITCAST(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  EVT VT = N->getValueType(0);\n\n  if (N0.isUndef())\n    return DAG.getUNDEF(VT);\n\n  // If the input is a BUILD_VECTOR with all constant elements, fold this now.\n  // Only do this before legalize types, unless both types are integer and the\n  // scalar type is legal. Only do this before legalize ops, since the target\n  // maybe depending on the bitcast.\n  // First check to see if this is all constant.\n  // TODO: Support FP bitcasts after legalize types.\n  if (VT.isVector() &&\n      (!LegalTypes ||\n       (!LegalOperations && VT.isInteger() && N0.getValueType().isInteger() &&\n        TLI.isTypeLegal(VT.getVectorElementType()))) &&\n      N0.getOpcode() == ISD::BUILD_VECTOR && N0.getNode()->hasOneUse() &&\n      cast<BuildVectorSDNode>(N0)->isConstant())\n    return ConstantFoldBITCASTofBUILD_VECTOR(N0.getNode(),\n                                             VT.getVectorElementType());\n\n  // If the input is a constant, let getNode fold it.\n  if (isa<ConstantSDNode>(N0) || isa<ConstantFPSDNode>(N0)) {\n    // If we can't allow illegal operations, we need to check that this is just\n    // a fp -> int or int -> conversion and that the resulting operation will\n    // be legal.\n    if (!LegalOperations ||\n        (isa<ConstantSDNode>(N0) && VT.isFloatingPoint() && !VT.isVector() &&\n         TLI.isOperationLegal(ISD::ConstantFP, VT)) ||\n        (isa<ConstantFPSDNode>(N0) && VT.isInteger() && !VT.isVector() &&\n         TLI.isOperationLegal(ISD::Constant, VT))) {\n      SDValue C = DAG.getBitcast(VT, N0);\n      if (C.getNode() != N)\n        return C;\n    }\n  }\n\n  // (conv (conv x, t1), t2) -> (conv x, t2)\n  if (N0.getOpcode() == ISD::BITCAST)\n    return DAG.getBitcast(VT, N0.getOperand(0));\n\n  // fold (conv (load x)) -> (load (conv*)x)\n  // If the resultant load doesn't need a higher alignment than the original!\n  if (ISD::isNormalLoad(N0.getNode()) && N0.hasOneUse() &&\n      // Do not remove the cast if the types differ in endian layout.\n      TLI.hasBigEndianPartOrdering(N0.getValueType(), DAG.getDataLayout()) ==\n          TLI.hasBigEndianPartOrdering(VT, DAG.getDataLayout()) &&\n      // If the load is volatile, we only want to change the load type if the\n      // resulting load is legal. Otherwise we might increase the number of\n      // memory accesses. We don't care if the original type was legal or not\n      // as we assume software couldn't rely on the number of accesses of an\n      // illegal type.\n      ((!LegalOperations && cast<LoadSDNode>(N0)->isSimple()) ||\n       TLI.isOperationLegal(ISD::LOAD, VT))) {\n    LoadSDNode *LN0 = cast<LoadSDNode>(N0);\n\n    if (TLI.isLoadBitCastBeneficial(N0.getValueType(), VT, DAG,\n                                    *LN0->getMemOperand())) {\n      SDValue Load =\n          DAG.getLoad(VT, SDLoc(N), LN0->getChain(), LN0->getBasePtr(),\n                      LN0->getPointerInfo(), LN0->getAlign(),\n                      LN0->getMemOperand()->getFlags(), LN0->getAAInfo());\n      DAG.ReplaceAllUsesOfValueWith(N0.getValue(1), Load.getValue(1));\n      return Load;\n    }\n  }\n\n  if (SDValue V = foldBitcastedFPLogic(N, DAG, TLI))\n    return V;\n\n  // fold (bitconvert (fneg x)) -> (xor (bitconvert x), signbit)\n  // fold (bitconvert (fabs x)) -> (and (bitconvert x), (not signbit))\n  //\n  // For ppc_fp128:\n  // fold (bitcast (fneg x)) ->\n  //     flipbit = signbit\n  //     (xor (bitcast x) (build_pair flipbit, flipbit))\n  //\n  // fold (bitcast (fabs x)) ->\n  //     flipbit = (and (extract_element (bitcast x), 0), signbit)\n  //     (xor (bitcast x) (build_pair flipbit, flipbit))\n  // This often reduces constant pool loads.\n  if (((N0.getOpcode() == ISD::FNEG && !TLI.isFNegFree(N0.getValueType())) ||\n       (N0.getOpcode() == ISD::FABS && !TLI.isFAbsFree(N0.getValueType()))) &&\n      N0.getNode()->hasOneUse() && VT.isInteger() &&\n      !VT.isVector() && !N0.getValueType().isVector()) {\n    SDValue NewConv = DAG.getBitcast(VT, N0.getOperand(0));\n    AddToWorklist(NewConv.getNode());\n\n    SDLoc DL(N);\n    if (N0.getValueType() == MVT::ppcf128 && !LegalTypes) {\n      assert(VT.getSizeInBits() == 128);\n      SDValue SignBit = DAG.getConstant(\n          APInt::getSignMask(VT.getSizeInBits() / 2), SDLoc(N0), MVT::i64);\n      SDValue FlipBit;\n      if (N0.getOpcode() == ISD::FNEG) {\n        FlipBit = SignBit;\n        AddToWorklist(FlipBit.getNode());\n      } else {\n        assert(N0.getOpcode() == ISD::FABS);\n        SDValue Hi =\n            DAG.getNode(ISD::EXTRACT_ELEMENT, SDLoc(NewConv), MVT::i64, NewConv,\n                        DAG.getIntPtrConstant(getPPCf128HiElementSelector(DAG),\n                                              SDLoc(NewConv)));\n        AddToWorklist(Hi.getNode());\n        FlipBit = DAG.getNode(ISD::AND, SDLoc(N0), MVT::i64, Hi, SignBit);\n        AddToWorklist(FlipBit.getNode());\n      }\n      SDValue FlipBits =\n          DAG.getNode(ISD::BUILD_PAIR, SDLoc(N0), VT, FlipBit, FlipBit);\n      AddToWorklist(FlipBits.getNode());\n      return DAG.getNode(ISD::XOR, DL, VT, NewConv, FlipBits);\n    }\n    APInt SignBit = APInt::getSignMask(VT.getSizeInBits());\n    if (N0.getOpcode() == ISD::FNEG)\n      return DAG.getNode(ISD::XOR, DL, VT,\n                         NewConv, DAG.getConstant(SignBit, DL, VT));\n    assert(N0.getOpcode() == ISD::FABS);\n    return DAG.getNode(ISD::AND, DL, VT,\n                       NewConv, DAG.getConstant(~SignBit, DL, VT));\n  }\n\n  // fold (bitconvert (fcopysign cst, x)) ->\n  //         (or (and (bitconvert x), sign), (and cst, (not sign)))\n  // Note that we don't handle (copysign x, cst) because this can always be\n  // folded to an fneg or fabs.\n  //\n  // For ppc_fp128:\n  // fold (bitcast (fcopysign cst, x)) ->\n  //     flipbit = (and (extract_element\n  //                     (xor (bitcast cst), (bitcast x)), 0),\n  //                    signbit)\n  //     (xor (bitcast cst) (build_pair flipbit, flipbit))\n  if (N0.getOpcode() == ISD::FCOPYSIGN && N0.getNode()->hasOneUse() &&\n      isa<ConstantFPSDNode>(N0.getOperand(0)) &&\n      VT.isInteger() && !VT.isVector()) {\n    unsigned OrigXWidth = N0.getOperand(1).getValueSizeInBits();\n    EVT IntXVT = EVT::getIntegerVT(*DAG.getContext(), OrigXWidth);\n    if (isTypeLegal(IntXVT)) {\n      SDValue X = DAG.getBitcast(IntXVT, N0.getOperand(1));\n      AddToWorklist(X.getNode());\n\n      // If X has a different width than the result/lhs, sext it or truncate it.\n      unsigned VTWidth = VT.getSizeInBits();\n      if (OrigXWidth < VTWidth) {\n        X = DAG.getNode(ISD::SIGN_EXTEND, SDLoc(N), VT, X);\n        AddToWorklist(X.getNode());\n      } else if (OrigXWidth > VTWidth) {\n        // To get the sign bit in the right place, we have to shift it right\n        // before truncating.\n        SDLoc DL(X);\n        X = DAG.getNode(ISD::SRL, DL,\n                        X.getValueType(), X,\n                        DAG.getConstant(OrigXWidth-VTWidth, DL,\n                                        X.getValueType()));\n        AddToWorklist(X.getNode());\n        X = DAG.getNode(ISD::TRUNCATE, SDLoc(X), VT, X);\n        AddToWorklist(X.getNode());\n      }\n\n      if (N0.getValueType() == MVT::ppcf128 && !LegalTypes) {\n        APInt SignBit = APInt::getSignMask(VT.getSizeInBits() / 2);\n        SDValue Cst = DAG.getBitcast(VT, N0.getOperand(0));\n        AddToWorklist(Cst.getNode());\n        SDValue X = DAG.getBitcast(VT, N0.getOperand(1));\n        AddToWorklist(X.getNode());\n        SDValue XorResult = DAG.getNode(ISD::XOR, SDLoc(N0), VT, Cst, X);\n        AddToWorklist(XorResult.getNode());\n        SDValue XorResult64 = DAG.getNode(\n            ISD::EXTRACT_ELEMENT, SDLoc(XorResult), MVT::i64, XorResult,\n            DAG.getIntPtrConstant(getPPCf128HiElementSelector(DAG),\n                                  SDLoc(XorResult)));\n        AddToWorklist(XorResult64.getNode());\n        SDValue FlipBit =\n            DAG.getNode(ISD::AND, SDLoc(XorResult64), MVT::i64, XorResult64,\n                        DAG.getConstant(SignBit, SDLoc(XorResult64), MVT::i64));\n        AddToWorklist(FlipBit.getNode());\n        SDValue FlipBits =\n            DAG.getNode(ISD::BUILD_PAIR, SDLoc(N0), VT, FlipBit, FlipBit);\n        AddToWorklist(FlipBits.getNode());\n        return DAG.getNode(ISD::XOR, SDLoc(N), VT, Cst, FlipBits);\n      }\n      APInt SignBit = APInt::getSignMask(VT.getSizeInBits());\n      X = DAG.getNode(ISD::AND, SDLoc(X), VT,\n                      X, DAG.getConstant(SignBit, SDLoc(X), VT));\n      AddToWorklist(X.getNode());\n\n      SDValue Cst = DAG.getBitcast(VT, N0.getOperand(0));\n      Cst = DAG.getNode(ISD::AND, SDLoc(Cst), VT,\n                        Cst, DAG.getConstant(~SignBit, SDLoc(Cst), VT));\n      AddToWorklist(Cst.getNode());\n\n      return DAG.getNode(ISD::OR, SDLoc(N), VT, X, Cst);\n    }\n  }\n\n  // bitconvert(build_pair(ld, ld)) -> ld iff load locations are consecutive.\n  if (N0.getOpcode() == ISD::BUILD_PAIR)\n    if (SDValue CombineLD = CombineConsecutiveLoads(N0.getNode(), VT))\n      return CombineLD;\n\n  // Remove double bitcasts from shuffles - this is often a legacy of\n  // XformToShuffleWithZero being used to combine bitmaskings (of\n  // float vectors bitcast to integer vectors) into shuffles.\n  // bitcast(shuffle(bitcast(s0),bitcast(s1))) -> shuffle(s0,s1)\n  if (Level < AfterLegalizeDAG && TLI.isTypeLegal(VT) && VT.isVector() &&\n      N0->getOpcode() == ISD::VECTOR_SHUFFLE && N0.hasOneUse() &&\n      VT.getVectorNumElements() >= N0.getValueType().getVectorNumElements() &&\n      !(VT.getVectorNumElements() % N0.getValueType().getVectorNumElements())) {\n    ShuffleVectorSDNode *SVN = cast<ShuffleVectorSDNode>(N0);\n\n    // If operands are a bitcast, peek through if it casts the original VT.\n    // If operands are a constant, just bitcast back to original VT.\n    auto PeekThroughBitcast = [&](SDValue Op) {\n      if (Op.getOpcode() == ISD::BITCAST &&\n          Op.getOperand(0).getValueType() == VT)\n        return SDValue(Op.getOperand(0));\n      if (Op.isUndef() || ISD::isBuildVectorOfConstantSDNodes(Op.getNode()) ||\n          ISD::isBuildVectorOfConstantFPSDNodes(Op.getNode()))\n        return DAG.getBitcast(VT, Op);\n      return SDValue();\n    };\n\n    // FIXME: If either input vector is bitcast, try to convert the shuffle to\n    // the result type of this bitcast. This would eliminate at least one\n    // bitcast. See the transform in InstCombine.\n    SDValue SV0 = PeekThroughBitcast(N0->getOperand(0));\n    SDValue SV1 = PeekThroughBitcast(N0->getOperand(1));\n    if (!(SV0 && SV1))\n      return SDValue();\n\n    int MaskScale =\n        VT.getVectorNumElements() / N0.getValueType().getVectorNumElements();\n    SmallVector<int, 8> NewMask;\n    for (int M : SVN->getMask())\n      for (int i = 0; i != MaskScale; ++i)\n        NewMask.push_back(M < 0 ? -1 : M * MaskScale + i);\n\n    SDValue LegalShuffle =\n        TLI.buildLegalVectorShuffle(VT, SDLoc(N), SV0, SV1, NewMask, DAG);\n    if (LegalShuffle)\n      return LegalShuffle;\n  }\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitBUILD_PAIR(SDNode *N) {\n  EVT VT = N->getValueType(0);\n  return CombineConsecutiveLoads(N, VT);\n}\n\nSDValue DAGCombiner::visitFREEZE(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n\n  // (freeze (freeze x)) -> (freeze x)\n  if (N0.getOpcode() == ISD::FREEZE)\n    return N0;\n\n  // If the input is a constant, return it.\n  if (isa<ConstantSDNode>(N0) || isa<ConstantFPSDNode>(N0))\n    return N0;\n\n  return SDValue();\n}\n\n/// We know that BV is a build_vector node with Constant, ConstantFP or Undef\n/// operands. DstEltVT indicates the destination element value type.\nSDValue DAGCombiner::\nConstantFoldBITCASTofBUILD_VECTOR(SDNode *BV, EVT DstEltVT) {\n  EVT SrcEltVT = BV->getValueType(0).getVectorElementType();\n\n  // If this is already the right type, we're done.\n  if (SrcEltVT == DstEltVT) return SDValue(BV, 0);\n\n  unsigned SrcBitSize = SrcEltVT.getSizeInBits();\n  unsigned DstBitSize = DstEltVT.getSizeInBits();\n\n  // If this is a conversion of N elements of one type to N elements of another\n  // type, convert each element.  This handles FP<->INT cases.\n  if (SrcBitSize == DstBitSize) {\n    SmallVector<SDValue, 8> Ops;\n    for (SDValue Op : BV->op_values()) {\n      // If the vector element type is not legal, the BUILD_VECTOR operands\n      // are promoted and implicitly truncated.  Make that explicit here.\n      if (Op.getValueType() != SrcEltVT)\n        Op = DAG.getNode(ISD::TRUNCATE, SDLoc(BV), SrcEltVT, Op);\n      Ops.push_back(DAG.getBitcast(DstEltVT, Op));\n      AddToWorklist(Ops.back().getNode());\n    }\n    EVT VT = EVT::getVectorVT(*DAG.getContext(), DstEltVT,\n                              BV->getValueType(0).getVectorNumElements());\n    return DAG.getBuildVector(VT, SDLoc(BV), Ops);\n  }\n\n  // Otherwise, we're growing or shrinking the elements.  To avoid having to\n  // handle annoying details of growing/shrinking FP values, we convert them to\n  // int first.\n  if (SrcEltVT.isFloatingPoint()) {\n    // Convert the input float vector to a int vector where the elements are the\n    // same sizes.\n    EVT IntVT = EVT::getIntegerVT(*DAG.getContext(), SrcEltVT.getSizeInBits());\n    BV = ConstantFoldBITCASTofBUILD_VECTOR(BV, IntVT).getNode();\n    SrcEltVT = IntVT;\n  }\n\n  // Now we know the input is an integer vector.  If the output is a FP type,\n  // convert to integer first, then to FP of the right size.\n  if (DstEltVT.isFloatingPoint()) {\n    EVT TmpVT = EVT::getIntegerVT(*DAG.getContext(), DstEltVT.getSizeInBits());\n    SDNode *Tmp = ConstantFoldBITCASTofBUILD_VECTOR(BV, TmpVT).getNode();\n\n    // Next, convert to FP elements of the same size.\n    return ConstantFoldBITCASTofBUILD_VECTOR(Tmp, DstEltVT);\n  }\n\n  SDLoc DL(BV);\n\n  // Okay, we know the src/dst types are both integers of differing types.\n  // Handling growing first.\n  assert(SrcEltVT.isInteger() && DstEltVT.isInteger());\n  if (SrcBitSize < DstBitSize) {\n    unsigned NumInputsPerOutput = DstBitSize/SrcBitSize;\n\n    SmallVector<SDValue, 8> Ops;\n    for (unsigned i = 0, e = BV->getNumOperands(); i != e;\n         i += NumInputsPerOutput) {\n      bool isLE = DAG.getDataLayout().isLittleEndian();\n      APInt NewBits = APInt(DstBitSize, 0);\n      bool EltIsUndef = true;\n      for (unsigned j = 0; j != NumInputsPerOutput; ++j) {\n        // Shift the previously computed bits over.\n        NewBits <<= SrcBitSize;\n        SDValue Op = BV->getOperand(i+ (isLE ? (NumInputsPerOutput-j-1) : j));\n        if (Op.isUndef()) continue;\n        EltIsUndef = false;\n\n        NewBits |= cast<ConstantSDNode>(Op)->getAPIntValue().\n                   zextOrTrunc(SrcBitSize).zext(DstBitSize);\n      }\n\n      if (EltIsUndef)\n        Ops.push_back(DAG.getUNDEF(DstEltVT));\n      else\n        Ops.push_back(DAG.getConstant(NewBits, DL, DstEltVT));\n    }\n\n    EVT VT = EVT::getVectorVT(*DAG.getContext(), DstEltVT, Ops.size());\n    return DAG.getBuildVector(VT, DL, Ops);\n  }\n\n  // Finally, this must be the case where we are shrinking elements: each input\n  // turns into multiple outputs.\n  unsigned NumOutputsPerInput = SrcBitSize/DstBitSize;\n  EVT VT = EVT::getVectorVT(*DAG.getContext(), DstEltVT,\n                            NumOutputsPerInput*BV->getNumOperands());\n  SmallVector<SDValue, 8> Ops;\n\n  for (const SDValue &Op : BV->op_values()) {\n    if (Op.isUndef()) {\n      Ops.append(NumOutputsPerInput, DAG.getUNDEF(DstEltVT));\n      continue;\n    }\n\n    APInt OpVal = cast<ConstantSDNode>(Op)->\n                  getAPIntValue().zextOrTrunc(SrcBitSize);\n\n    for (unsigned j = 0; j != NumOutputsPerInput; ++j) {\n      APInt ThisVal = OpVal.trunc(DstBitSize);\n      Ops.push_back(DAG.getConstant(ThisVal, DL, DstEltVT));\n      OpVal.lshrInPlace(DstBitSize);\n    }\n\n    // For big endian targets, swap the order of the pieces of each element.\n    if (DAG.getDataLayout().isBigEndian())\n      std::reverse(Ops.end()-NumOutputsPerInput, Ops.end());\n  }\n\n  return DAG.getBuildVector(VT, DL, Ops);\n}\n\nstatic bool isContractable(SDNode *N) {\n  SDNodeFlags F = N->getFlags();\n  return F.hasAllowContract() || F.hasAllowReassociation();\n}\n\n/// Try to perform FMA combining on a given FADD node.\nSDValue DAGCombiner::visitFADDForFMACombine(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  EVT VT = N->getValueType(0);\n  SDLoc SL(N);\n\n  const TargetOptions &Options = DAG.getTarget().Options;\n\n  // Floating-point multiply-add with intermediate rounding.\n  bool HasFMAD = (LegalOperations && TLI.isFMADLegal(DAG, N));\n\n  // Floating-point multiply-add without intermediate rounding.\n  bool HasFMA =\n      TLI.isFMAFasterThanFMulAndFAdd(DAG.getMachineFunction(), VT) &&\n      (!LegalOperations || TLI.isOperationLegalOrCustom(ISD::FMA, VT));\n\n  // No valid opcode, do not combine.\n  if (!HasFMAD && !HasFMA)\n    return SDValue();\n\n  bool CanFuse = Options.UnsafeFPMath || isContractable(N);\n  bool CanReassociate =\n      Options.UnsafeFPMath || N->getFlags().hasAllowReassociation();\n  bool AllowFusionGlobally = (Options.AllowFPOpFusion == FPOpFusion::Fast ||\n                              CanFuse || HasFMAD);\n  // If the addition is not contractable, do not combine.\n  if (!AllowFusionGlobally && !isContractable(N))\n    return SDValue();\n\n  if (TLI.generateFMAsInMachineCombiner(VT, OptLevel))\n    return SDValue();\n\n  // Always prefer FMAD to FMA for precision.\n  unsigned PreferredFusedOpcode = HasFMAD ? ISD::FMAD : ISD::FMA;\n  bool Aggressive = TLI.enableAggressiveFMAFusion(VT);\n\n  // Is the node an FMUL and contractable either due to global flags or\n  // SDNodeFlags.\n  auto isContractableFMUL = [AllowFusionGlobally](SDValue N) {\n    if (N.getOpcode() != ISD::FMUL)\n      return false;\n    return AllowFusionGlobally || isContractable(N.getNode());\n  };\n  // If we have two choices trying to fold (fadd (fmul u, v), (fmul x, y)),\n  // prefer to fold the multiply with fewer uses.\n  if (Aggressive && isContractableFMUL(N0) && isContractableFMUL(N1)) {\n    if (N0.getNode()->use_size() > N1.getNode()->use_size())\n      std::swap(N0, N1);\n  }\n\n  // fold (fadd (fmul x, y), z) -> (fma x, y, z)\n  if (isContractableFMUL(N0) && (Aggressive || N0->hasOneUse())) {\n    return DAG.getNode(PreferredFusedOpcode, SL, VT, N0.getOperand(0),\n                       N0.getOperand(1), N1);\n  }\n\n  // fold (fadd x, (fmul y, z)) -> (fma y, z, x)\n  // Note: Commutes FADD operands.\n  if (isContractableFMUL(N1) && (Aggressive || N1->hasOneUse())) {\n    return DAG.getNode(PreferredFusedOpcode, SL, VT, N1.getOperand(0),\n                       N1.getOperand(1), N0);\n  }\n\n  // fadd (fma A, B, (fmul C, D)), E --> fma A, B, (fma C, D, E)\n  // fadd E, (fma A, B, (fmul C, D)) --> fma A, B, (fma C, D, E)\n  // This requires reassociation because it changes the order of operations.\n  SDValue FMA, E;\n  if (CanReassociate && N0.getOpcode() == PreferredFusedOpcode &&\n      N0.getOperand(2).getOpcode() == ISD::FMUL && N0.hasOneUse() &&\n      N0.getOperand(2).hasOneUse()) {\n    FMA = N0;\n    E = N1;\n  } else if (CanReassociate && N1.getOpcode() == PreferredFusedOpcode &&\n             N1.getOperand(2).getOpcode() == ISD::FMUL && N1.hasOneUse() &&\n             N1.getOperand(2).hasOneUse()) {\n    FMA = N1;\n    E = N0;\n  }\n  if (FMA && E) {\n    SDValue A = FMA.getOperand(0);\n    SDValue B = FMA.getOperand(1);\n    SDValue C = FMA.getOperand(2).getOperand(0);\n    SDValue D = FMA.getOperand(2).getOperand(1);\n    SDValue CDE = DAG.getNode(PreferredFusedOpcode, SL, VT, C, D, E);\n    return DAG.getNode(PreferredFusedOpcode, SL, VT, A, B, CDE);\n  }\n\n  // Look through FP_EXTEND nodes to do more combining.\n\n  // fold (fadd (fpext (fmul x, y)), z) -> (fma (fpext x), (fpext y), z)\n  if (N0.getOpcode() == ISD::FP_EXTEND) {\n    SDValue N00 = N0.getOperand(0);\n    if (isContractableFMUL(N00) &&\n        TLI.isFPExtFoldable(DAG, PreferredFusedOpcode, VT,\n                            N00.getValueType())) {\n      return DAG.getNode(PreferredFusedOpcode, SL, VT,\n                         DAG.getNode(ISD::FP_EXTEND, SL, VT, N00.getOperand(0)),\n                         DAG.getNode(ISD::FP_EXTEND, SL, VT, N00.getOperand(1)),\n                         N1);\n    }\n  }\n\n  // fold (fadd x, (fpext (fmul y, z))) -> (fma (fpext y), (fpext z), x)\n  // Note: Commutes FADD operands.\n  if (N1.getOpcode() == ISD::FP_EXTEND) {\n    SDValue N10 = N1.getOperand(0);\n    if (isContractableFMUL(N10) &&\n        TLI.isFPExtFoldable(DAG, PreferredFusedOpcode, VT,\n                            N10.getValueType())) {\n      return DAG.getNode(PreferredFusedOpcode, SL, VT,\n                         DAG.getNode(ISD::FP_EXTEND, SL, VT, N10.getOperand(0)),\n                         DAG.getNode(ISD::FP_EXTEND, SL, VT, N10.getOperand(1)),\n                         N0);\n    }\n  }\n\n  // More folding opportunities when target permits.\n  if (Aggressive) {\n    // fold (fadd (fma x, y, (fpext (fmul u, v))), z)\n    //   -> (fma x, y, (fma (fpext u), (fpext v), z))\n    auto FoldFAddFMAFPExtFMul = [&](SDValue X, SDValue Y, SDValue U, SDValue V,\n                                    SDValue Z) {\n      return DAG.getNode(PreferredFusedOpcode, SL, VT, X, Y,\n                         DAG.getNode(PreferredFusedOpcode, SL, VT,\n                                     DAG.getNode(ISD::FP_EXTEND, SL, VT, U),\n                                     DAG.getNode(ISD::FP_EXTEND, SL, VT, V),\n                                     Z));\n    };\n    if (N0.getOpcode() == PreferredFusedOpcode) {\n      SDValue N02 = N0.getOperand(2);\n      if (N02.getOpcode() == ISD::FP_EXTEND) {\n        SDValue N020 = N02.getOperand(0);\n        if (isContractableFMUL(N020) &&\n            TLI.isFPExtFoldable(DAG, PreferredFusedOpcode, VT,\n                                N020.getValueType())) {\n          return FoldFAddFMAFPExtFMul(N0.getOperand(0), N0.getOperand(1),\n                                      N020.getOperand(0), N020.getOperand(1),\n                                      N1);\n        }\n      }\n    }\n\n    // fold (fadd (fpext (fma x, y, (fmul u, v))), z)\n    //   -> (fma (fpext x), (fpext y), (fma (fpext u), (fpext v), z))\n    // FIXME: This turns two single-precision and one double-precision\n    // operation into two double-precision operations, which might not be\n    // interesting for all targets, especially GPUs.\n    auto FoldFAddFPExtFMAFMul = [&](SDValue X, SDValue Y, SDValue U, SDValue V,\n                                    SDValue Z) {\n      return DAG.getNode(\n          PreferredFusedOpcode, SL, VT, DAG.getNode(ISD::FP_EXTEND, SL, VT, X),\n          DAG.getNode(ISD::FP_EXTEND, SL, VT, Y),\n          DAG.getNode(PreferredFusedOpcode, SL, VT,\n                      DAG.getNode(ISD::FP_EXTEND, SL, VT, U),\n                      DAG.getNode(ISD::FP_EXTEND, SL, VT, V), Z));\n    };\n    if (N0.getOpcode() == ISD::FP_EXTEND) {\n      SDValue N00 = N0.getOperand(0);\n      if (N00.getOpcode() == PreferredFusedOpcode) {\n        SDValue N002 = N00.getOperand(2);\n        if (isContractableFMUL(N002) &&\n            TLI.isFPExtFoldable(DAG, PreferredFusedOpcode, VT,\n                                N00.getValueType())) {\n          return FoldFAddFPExtFMAFMul(N00.getOperand(0), N00.getOperand(1),\n                                      N002.getOperand(0), N002.getOperand(1),\n                                      N1);\n        }\n      }\n    }\n\n    // fold (fadd x, (fma y, z, (fpext (fmul u, v)))\n    //   -> (fma y, z, (fma (fpext u), (fpext v), x))\n    if (N1.getOpcode() == PreferredFusedOpcode) {\n      SDValue N12 = N1.getOperand(2);\n      if (N12.getOpcode() == ISD::FP_EXTEND) {\n        SDValue N120 = N12.getOperand(0);\n        if (isContractableFMUL(N120) &&\n            TLI.isFPExtFoldable(DAG, PreferredFusedOpcode, VT,\n                                N120.getValueType())) {\n          return FoldFAddFMAFPExtFMul(N1.getOperand(0), N1.getOperand(1),\n                                      N120.getOperand(0), N120.getOperand(1),\n                                      N0);\n        }\n      }\n    }\n\n    // fold (fadd x, (fpext (fma y, z, (fmul u, v)))\n    //   -> (fma (fpext y), (fpext z), (fma (fpext u), (fpext v), x))\n    // FIXME: This turns two single-precision and one double-precision\n    // operation into two double-precision operations, which might not be\n    // interesting for all targets, especially GPUs.\n    if (N1.getOpcode() == ISD::FP_EXTEND) {\n      SDValue N10 = N1.getOperand(0);\n      if (N10.getOpcode() == PreferredFusedOpcode) {\n        SDValue N102 = N10.getOperand(2);\n        if (isContractableFMUL(N102) &&\n            TLI.isFPExtFoldable(DAG, PreferredFusedOpcode, VT,\n                                N10.getValueType())) {\n          return FoldFAddFPExtFMAFMul(N10.getOperand(0), N10.getOperand(1),\n                                      N102.getOperand(0), N102.getOperand(1),\n                                      N0);\n        }\n      }\n    }\n  }\n\n  return SDValue();\n}\n\n/// Try to perform FMA combining on a given FSUB node.\nSDValue DAGCombiner::visitFSUBForFMACombine(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  EVT VT = N->getValueType(0);\n  SDLoc SL(N);\n\n  const TargetOptions &Options = DAG.getTarget().Options;\n  // Floating-point multiply-add with intermediate rounding.\n  bool HasFMAD = (LegalOperations && TLI.isFMADLegal(DAG, N));\n\n  // Floating-point multiply-add without intermediate rounding.\n  bool HasFMA =\n      TLI.isFMAFasterThanFMulAndFAdd(DAG.getMachineFunction(), VT) &&\n      (!LegalOperations || TLI.isOperationLegalOrCustom(ISD::FMA, VT));\n\n  // No valid opcode, do not combine.\n  if (!HasFMAD && !HasFMA)\n    return SDValue();\n\n  const SDNodeFlags Flags = N->getFlags();\n  bool CanFuse = Options.UnsafeFPMath || isContractable(N);\n  bool AllowFusionGlobally = (Options.AllowFPOpFusion == FPOpFusion::Fast ||\n                              CanFuse || HasFMAD);\n\n  // If the subtraction is not contractable, do not combine.\n  if (!AllowFusionGlobally && !isContractable(N))\n    return SDValue();\n\n  if (TLI.generateFMAsInMachineCombiner(VT, OptLevel))\n    return SDValue();\n\n  // Always prefer FMAD to FMA for precision.\n  unsigned PreferredFusedOpcode = HasFMAD ? ISD::FMAD : ISD::FMA;\n  bool Aggressive = TLI.enableAggressiveFMAFusion(VT);\n  bool NoSignedZero = Options.NoSignedZerosFPMath || Flags.hasNoSignedZeros();\n\n  // Is the node an FMUL and contractable either due to global flags or\n  // SDNodeFlags.\n  auto isContractableFMUL = [AllowFusionGlobally](SDValue N) {\n    if (N.getOpcode() != ISD::FMUL)\n      return false;\n    return AllowFusionGlobally || isContractable(N.getNode());\n  };\n\n  // fold (fsub (fmul x, y), z) -> (fma x, y, (fneg z))\n  auto tryToFoldXYSubZ = [&](SDValue XY, SDValue Z) {\n    if (isContractableFMUL(XY) && (Aggressive || XY->hasOneUse())) {\n      return DAG.getNode(PreferredFusedOpcode, SL, VT, XY.getOperand(0),\n                         XY.getOperand(1), DAG.getNode(ISD::FNEG, SL, VT, Z));\n    }\n    return SDValue();\n  };\n\n  // fold (fsub x, (fmul y, z)) -> (fma (fneg y), z, x)\n  // Note: Commutes FSUB operands.\n  auto tryToFoldXSubYZ = [&](SDValue X, SDValue YZ) {\n    if (isContractableFMUL(YZ) && (Aggressive || YZ->hasOneUse())) {\n      return DAG.getNode(PreferredFusedOpcode, SL, VT,\n                         DAG.getNode(ISD::FNEG, SL, VT, YZ.getOperand(0)),\n                         YZ.getOperand(1), X);\n    }\n    return SDValue();\n  };\n\n  // If we have two choices trying to fold (fsub (fmul u, v), (fmul x, y)),\n  // prefer to fold the multiply with fewer uses.\n  if (isContractableFMUL(N0) && isContractableFMUL(N1) &&\n      (N0.getNode()->use_size() > N1.getNode()->use_size())) {\n    // fold (fsub (fmul a, b), (fmul c, d)) -> (fma (fneg c), d, (fmul a, b))\n    if (SDValue V = tryToFoldXSubYZ(N0, N1))\n      return V;\n    // fold (fsub (fmul a, b), (fmul c, d)) -> (fma a, b, (fneg (fmul c, d)))\n    if (SDValue V = tryToFoldXYSubZ(N0, N1))\n      return V;\n  } else {\n    // fold (fsub (fmul x, y), z) -> (fma x, y, (fneg z))\n    if (SDValue V = tryToFoldXYSubZ(N0, N1))\n      return V;\n    // fold (fsub x, (fmul y, z)) -> (fma (fneg y), z, x)\n    if (SDValue V = tryToFoldXSubYZ(N0, N1))\n      return V;\n  }\n\n  // fold (fsub (fneg (fmul, x, y)), z) -> (fma (fneg x), y, (fneg z))\n  if (N0.getOpcode() == ISD::FNEG && isContractableFMUL(N0.getOperand(0)) &&\n      (Aggressive || (N0->hasOneUse() && N0.getOperand(0).hasOneUse()))) {\n    SDValue N00 = N0.getOperand(0).getOperand(0);\n    SDValue N01 = N0.getOperand(0).getOperand(1);\n    return DAG.getNode(PreferredFusedOpcode, SL, VT,\n                       DAG.getNode(ISD::FNEG, SL, VT, N00), N01,\n                       DAG.getNode(ISD::FNEG, SL, VT, N1));\n  }\n\n  // Look through FP_EXTEND nodes to do more combining.\n\n  // fold (fsub (fpext (fmul x, y)), z)\n  //   -> (fma (fpext x), (fpext y), (fneg z))\n  if (N0.getOpcode() == ISD::FP_EXTEND) {\n    SDValue N00 = N0.getOperand(0);\n    if (isContractableFMUL(N00) &&\n        TLI.isFPExtFoldable(DAG, PreferredFusedOpcode, VT,\n                            N00.getValueType())) {\n      return DAG.getNode(PreferredFusedOpcode, SL, VT,\n                         DAG.getNode(ISD::FP_EXTEND, SL, VT, N00.getOperand(0)),\n                         DAG.getNode(ISD::FP_EXTEND, SL, VT, N00.getOperand(1)),\n                         DAG.getNode(ISD::FNEG, SL, VT, N1));\n    }\n  }\n\n  // fold (fsub x, (fpext (fmul y, z)))\n  //   -> (fma (fneg (fpext y)), (fpext z), x)\n  // Note: Commutes FSUB operands.\n  if (N1.getOpcode() == ISD::FP_EXTEND) {\n    SDValue N10 = N1.getOperand(0);\n    if (isContractableFMUL(N10) &&\n        TLI.isFPExtFoldable(DAG, PreferredFusedOpcode, VT,\n                            N10.getValueType())) {\n      return DAG.getNode(\n          PreferredFusedOpcode, SL, VT,\n          DAG.getNode(ISD::FNEG, SL, VT,\n                      DAG.getNode(ISD::FP_EXTEND, SL, VT, N10.getOperand(0))),\n          DAG.getNode(ISD::FP_EXTEND, SL, VT, N10.getOperand(1)), N0);\n    }\n  }\n\n  // fold (fsub (fpext (fneg (fmul, x, y))), z)\n  //   -> (fneg (fma (fpext x), (fpext y), z))\n  // Note: This could be removed with appropriate canonicalization of the\n  // input expression into (fneg (fadd (fpext (fmul, x, y)), z). However, the\n  // orthogonal flags -fp-contract=fast and -enable-unsafe-fp-math prevent\n  // from implementing the canonicalization in visitFSUB.\n  if (N0.getOpcode() == ISD::FP_EXTEND) {\n    SDValue N00 = N0.getOperand(0);\n    if (N00.getOpcode() == ISD::FNEG) {\n      SDValue N000 = N00.getOperand(0);\n      if (isContractableFMUL(N000) &&\n          TLI.isFPExtFoldable(DAG, PreferredFusedOpcode, VT,\n                              N00.getValueType())) {\n        return DAG.getNode(\n            ISD::FNEG, SL, VT,\n            DAG.getNode(PreferredFusedOpcode, SL, VT,\n                        DAG.getNode(ISD::FP_EXTEND, SL, VT, N000.getOperand(0)),\n                        DAG.getNode(ISD::FP_EXTEND, SL, VT, N000.getOperand(1)),\n                        N1));\n      }\n    }\n  }\n\n  // fold (fsub (fneg (fpext (fmul, x, y))), z)\n  //   -> (fneg (fma (fpext x)), (fpext y), z)\n  // Note: This could be removed with appropriate canonicalization of the\n  // input expression into (fneg (fadd (fpext (fmul, x, y)), z). However, the\n  // orthogonal flags -fp-contract=fast and -enable-unsafe-fp-math prevent\n  // from implementing the canonicalization in visitFSUB.\n  if (N0.getOpcode() == ISD::FNEG) {\n    SDValue N00 = N0.getOperand(0);\n    if (N00.getOpcode() == ISD::FP_EXTEND) {\n      SDValue N000 = N00.getOperand(0);\n      if (isContractableFMUL(N000) &&\n          TLI.isFPExtFoldable(DAG, PreferredFusedOpcode, VT,\n                              N000.getValueType())) {\n        return DAG.getNode(\n            ISD::FNEG, SL, VT,\n            DAG.getNode(PreferredFusedOpcode, SL, VT,\n                        DAG.getNode(ISD::FP_EXTEND, SL, VT, N000.getOperand(0)),\n                        DAG.getNode(ISD::FP_EXTEND, SL, VT, N000.getOperand(1)),\n                        N1));\n      }\n    }\n  }\n\n  // More folding opportunities when target permits.\n  if (Aggressive) {\n    // fold (fsub (fma x, y, (fmul u, v)), z)\n    //   -> (fma x, y (fma u, v, (fneg z)))\n    if (CanFuse && N0.getOpcode() == PreferredFusedOpcode &&\n        isContractableFMUL(N0.getOperand(2)) && N0->hasOneUse() &&\n        N0.getOperand(2)->hasOneUse()) {\n      return DAG.getNode(PreferredFusedOpcode, SL, VT, N0.getOperand(0),\n                         N0.getOperand(1),\n                         DAG.getNode(PreferredFusedOpcode, SL, VT,\n                                     N0.getOperand(2).getOperand(0),\n                                     N0.getOperand(2).getOperand(1),\n                                     DAG.getNode(ISD::FNEG, SL, VT, N1)));\n    }\n\n    // fold (fsub x, (fma y, z, (fmul u, v)))\n    //   -> (fma (fneg y), z, (fma (fneg u), v, x))\n    if (CanFuse && N1.getOpcode() == PreferredFusedOpcode &&\n        isContractableFMUL(N1.getOperand(2)) &&\n        N1->hasOneUse() && NoSignedZero) {\n      SDValue N20 = N1.getOperand(2).getOperand(0);\n      SDValue N21 = N1.getOperand(2).getOperand(1);\n      return DAG.getNode(\n          PreferredFusedOpcode, SL, VT,\n          DAG.getNode(ISD::FNEG, SL, VT, N1.getOperand(0)), N1.getOperand(1),\n          DAG.getNode(PreferredFusedOpcode, SL, VT,\n                      DAG.getNode(ISD::FNEG, SL, VT, N20), N21, N0));\n    }\n\n\n    // fold (fsub (fma x, y, (fpext (fmul u, v))), z)\n    //   -> (fma x, y (fma (fpext u), (fpext v), (fneg z)))\n    if (N0.getOpcode() == PreferredFusedOpcode &&\n        N0->hasOneUse()) {\n      SDValue N02 = N0.getOperand(2);\n      if (N02.getOpcode() == ISD::FP_EXTEND) {\n        SDValue N020 = N02.getOperand(0);\n        if (isContractableFMUL(N020) &&\n            TLI.isFPExtFoldable(DAG, PreferredFusedOpcode, VT,\n                                N020.getValueType())) {\n          return DAG.getNode(\n              PreferredFusedOpcode, SL, VT, N0.getOperand(0), N0.getOperand(1),\n              DAG.getNode(\n                  PreferredFusedOpcode, SL, VT,\n                  DAG.getNode(ISD::FP_EXTEND, SL, VT, N020.getOperand(0)),\n                  DAG.getNode(ISD::FP_EXTEND, SL, VT, N020.getOperand(1)),\n                  DAG.getNode(ISD::FNEG, SL, VT, N1)));\n        }\n      }\n    }\n\n    // fold (fsub (fpext (fma x, y, (fmul u, v))), z)\n    //   -> (fma (fpext x), (fpext y),\n    //           (fma (fpext u), (fpext v), (fneg z)))\n    // FIXME: This turns two single-precision and one double-precision\n    // operation into two double-precision operations, which might not be\n    // interesting for all targets, especially GPUs.\n    if (N0.getOpcode() == ISD::FP_EXTEND) {\n      SDValue N00 = N0.getOperand(0);\n      if (N00.getOpcode() == PreferredFusedOpcode) {\n        SDValue N002 = N00.getOperand(2);\n        if (isContractableFMUL(N002) &&\n            TLI.isFPExtFoldable(DAG, PreferredFusedOpcode, VT,\n                                N00.getValueType())) {\n          return DAG.getNode(\n              PreferredFusedOpcode, SL, VT,\n              DAG.getNode(ISD::FP_EXTEND, SL, VT, N00.getOperand(0)),\n              DAG.getNode(ISD::FP_EXTEND, SL, VT, N00.getOperand(1)),\n              DAG.getNode(\n                  PreferredFusedOpcode, SL, VT,\n                  DAG.getNode(ISD::FP_EXTEND, SL, VT, N002.getOperand(0)),\n                  DAG.getNode(ISD::FP_EXTEND, SL, VT, N002.getOperand(1)),\n                  DAG.getNode(ISD::FNEG, SL, VT, N1)));\n        }\n      }\n    }\n\n    // fold (fsub x, (fma y, z, (fpext (fmul u, v))))\n    //   -> (fma (fneg y), z, (fma (fneg (fpext u)), (fpext v), x))\n    if (N1.getOpcode() == PreferredFusedOpcode &&\n        N1.getOperand(2).getOpcode() == ISD::FP_EXTEND &&\n        N1->hasOneUse()) {\n      SDValue N120 = N1.getOperand(2).getOperand(0);\n      if (isContractableFMUL(N120) &&\n          TLI.isFPExtFoldable(DAG, PreferredFusedOpcode, VT,\n                              N120.getValueType())) {\n        SDValue N1200 = N120.getOperand(0);\n        SDValue N1201 = N120.getOperand(1);\n        return DAG.getNode(\n            PreferredFusedOpcode, SL, VT,\n            DAG.getNode(ISD::FNEG, SL, VT, N1.getOperand(0)), N1.getOperand(1),\n            DAG.getNode(PreferredFusedOpcode, SL, VT,\n                        DAG.getNode(ISD::FNEG, SL, VT,\n                                    DAG.getNode(ISD::FP_EXTEND, SL, VT, N1200)),\n                        DAG.getNode(ISD::FP_EXTEND, SL, VT, N1201), N0));\n      }\n    }\n\n    // fold (fsub x, (fpext (fma y, z, (fmul u, v))))\n    //   -> (fma (fneg (fpext y)), (fpext z),\n    //           (fma (fneg (fpext u)), (fpext v), x))\n    // FIXME: This turns two single-precision and one double-precision\n    // operation into two double-precision operations, which might not be\n    // interesting for all targets, especially GPUs.\n    if (N1.getOpcode() == ISD::FP_EXTEND &&\n        N1.getOperand(0).getOpcode() == PreferredFusedOpcode) {\n      SDValue CvtSrc = N1.getOperand(0);\n      SDValue N100 = CvtSrc.getOperand(0);\n      SDValue N101 = CvtSrc.getOperand(1);\n      SDValue N102 = CvtSrc.getOperand(2);\n      if (isContractableFMUL(N102) &&\n          TLI.isFPExtFoldable(DAG, PreferredFusedOpcode, VT,\n                              CvtSrc.getValueType())) {\n        SDValue N1020 = N102.getOperand(0);\n        SDValue N1021 = N102.getOperand(1);\n        return DAG.getNode(\n            PreferredFusedOpcode, SL, VT,\n            DAG.getNode(ISD::FNEG, SL, VT,\n                        DAG.getNode(ISD::FP_EXTEND, SL, VT, N100)),\n            DAG.getNode(ISD::FP_EXTEND, SL, VT, N101),\n            DAG.getNode(PreferredFusedOpcode, SL, VT,\n                        DAG.getNode(ISD::FNEG, SL, VT,\n                                    DAG.getNode(ISD::FP_EXTEND, SL, VT, N1020)),\n                        DAG.getNode(ISD::FP_EXTEND, SL, VT, N1021), N0));\n      }\n    }\n  }\n\n  return SDValue();\n}\n\n/// Try to perform FMA combining on a given FMUL node based on the distributive\n/// law x * (y + 1) = x * y + x and variants thereof (commuted versions,\n/// subtraction instead of addition).\nSDValue DAGCombiner::visitFMULForFMADistributiveCombine(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  EVT VT = N->getValueType(0);\n  SDLoc SL(N);\n\n  assert(N->getOpcode() == ISD::FMUL && \"Expected FMUL Operation\");\n\n  const TargetOptions &Options = DAG.getTarget().Options;\n\n  // The transforms below are incorrect when x == 0 and y == inf, because the\n  // intermediate multiplication produces a nan.\n  if (!Options.NoInfsFPMath)\n    return SDValue();\n\n  // Floating-point multiply-add without intermediate rounding.\n  bool HasFMA =\n      (Options.AllowFPOpFusion == FPOpFusion::Fast || Options.UnsafeFPMath) &&\n      TLI.isFMAFasterThanFMulAndFAdd(DAG.getMachineFunction(), VT) &&\n      (!LegalOperations || TLI.isOperationLegalOrCustom(ISD::FMA, VT));\n\n  // Floating-point multiply-add with intermediate rounding. This can result\n  // in a less precise result due to the changed rounding order.\n  bool HasFMAD = Options.UnsafeFPMath &&\n                 (LegalOperations && TLI.isFMADLegal(DAG, N));\n\n  // No valid opcode, do not combine.\n  if (!HasFMAD && !HasFMA)\n    return SDValue();\n\n  // Always prefer FMAD to FMA for precision.\n  unsigned PreferredFusedOpcode = HasFMAD ? ISD::FMAD : ISD::FMA;\n  bool Aggressive = TLI.enableAggressiveFMAFusion(VT);\n\n  // fold (fmul (fadd x0, +1.0), y) -> (fma x0, y, y)\n  // fold (fmul (fadd x0, -1.0), y) -> (fma x0, y, (fneg y))\n  auto FuseFADD = [&](SDValue X, SDValue Y) {\n    if (X.getOpcode() == ISD::FADD && (Aggressive || X->hasOneUse())) {\n      if (auto *C = isConstOrConstSplatFP(X.getOperand(1), true)) {\n        if (C->isExactlyValue(+1.0))\n          return DAG.getNode(PreferredFusedOpcode, SL, VT, X.getOperand(0), Y,\n                             Y);\n        if (C->isExactlyValue(-1.0))\n          return DAG.getNode(PreferredFusedOpcode, SL, VT, X.getOperand(0), Y,\n                             DAG.getNode(ISD::FNEG, SL, VT, Y));\n      }\n    }\n    return SDValue();\n  };\n\n  if (SDValue FMA = FuseFADD(N0, N1))\n    return FMA;\n  if (SDValue FMA = FuseFADD(N1, N0))\n    return FMA;\n\n  // fold (fmul (fsub +1.0, x1), y) -> (fma (fneg x1), y, y)\n  // fold (fmul (fsub -1.0, x1), y) -> (fma (fneg x1), y, (fneg y))\n  // fold (fmul (fsub x0, +1.0), y) -> (fma x0, y, (fneg y))\n  // fold (fmul (fsub x0, -1.0), y) -> (fma x0, y, y)\n  auto FuseFSUB = [&](SDValue X, SDValue Y) {\n    if (X.getOpcode() == ISD::FSUB && (Aggressive || X->hasOneUse())) {\n      if (auto *C0 = isConstOrConstSplatFP(X.getOperand(0), true)) {\n        if (C0->isExactlyValue(+1.0))\n          return DAG.getNode(PreferredFusedOpcode, SL, VT,\n                             DAG.getNode(ISD::FNEG, SL, VT, X.getOperand(1)), Y,\n                             Y);\n        if (C0->isExactlyValue(-1.0))\n          return DAG.getNode(PreferredFusedOpcode, SL, VT,\n                             DAG.getNode(ISD::FNEG, SL, VT, X.getOperand(1)), Y,\n                             DAG.getNode(ISD::FNEG, SL, VT, Y));\n      }\n      if (auto *C1 = isConstOrConstSplatFP(X.getOperand(1), true)) {\n        if (C1->isExactlyValue(+1.0))\n          return DAG.getNode(PreferredFusedOpcode, SL, VT, X.getOperand(0), Y,\n                             DAG.getNode(ISD::FNEG, SL, VT, Y));\n        if (C1->isExactlyValue(-1.0))\n          return DAG.getNode(PreferredFusedOpcode, SL, VT, X.getOperand(0), Y,\n                             Y);\n      }\n    }\n    return SDValue();\n  };\n\n  if (SDValue FMA = FuseFSUB(N0, N1))\n    return FMA;\n  if (SDValue FMA = FuseFSUB(N1, N0))\n    return FMA;\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitFADD(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  bool N0CFP = DAG.isConstantFPBuildVectorOrConstantFP(N0);\n  bool N1CFP = DAG.isConstantFPBuildVectorOrConstantFP(N1);\n  EVT VT = N->getValueType(0);\n  SDLoc DL(N);\n  const TargetOptions &Options = DAG.getTarget().Options;\n  SDNodeFlags Flags = N->getFlags();\n  SelectionDAG::FlagInserter FlagsInserter(DAG, N);\n\n  if (SDValue R = DAG.simplifyFPBinop(N->getOpcode(), N0, N1, Flags))\n    return R;\n\n  // fold vector ops\n  if (VT.isVector())\n    if (SDValue FoldedVOp = SimplifyVBinOp(N))\n      return FoldedVOp;\n\n  // fold (fadd c1, c2) -> c1 + c2\n  if (N0CFP && N1CFP)\n    return DAG.getNode(ISD::FADD, DL, VT, N0, N1);\n\n  // canonicalize constant to RHS\n  if (N0CFP && !N1CFP)\n    return DAG.getNode(ISD::FADD, DL, VT, N1, N0);\n\n  // N0 + -0.0 --> N0 (also allowed with +0.0 and fast-math)\n  ConstantFPSDNode *N1C = isConstOrConstSplatFP(N1, true);\n  if (N1C && N1C->isZero())\n    if (N1C->isNegative() || Options.NoSignedZerosFPMath || Flags.hasNoSignedZeros())\n      return N0;\n\n  if (SDValue NewSel = foldBinOpIntoSelect(N))\n    return NewSel;\n\n  // fold (fadd A, (fneg B)) -> (fsub A, B)\n  if (!LegalOperations || TLI.isOperationLegalOrCustom(ISD::FSUB, VT))\n    if (SDValue NegN1 = TLI.getCheaperNegatedExpression(\n            N1, DAG, LegalOperations, ForCodeSize))\n      return DAG.getNode(ISD::FSUB, DL, VT, N0, NegN1);\n\n  // fold (fadd (fneg A), B) -> (fsub B, A)\n  if (!LegalOperations || TLI.isOperationLegalOrCustom(ISD::FSUB, VT))\n    if (SDValue NegN0 = TLI.getCheaperNegatedExpression(\n            N0, DAG, LegalOperations, ForCodeSize))\n      return DAG.getNode(ISD::FSUB, DL, VT, N1, NegN0);\n\n  auto isFMulNegTwo = [](SDValue FMul) {\n    if (!FMul.hasOneUse() || FMul.getOpcode() != ISD::FMUL)\n      return false;\n    auto *C = isConstOrConstSplatFP(FMul.getOperand(1), true);\n    return C && C->isExactlyValue(-2.0);\n  };\n\n  // fadd (fmul B, -2.0), A --> fsub A, (fadd B, B)\n  if (isFMulNegTwo(N0)) {\n    SDValue B = N0.getOperand(0);\n    SDValue Add = DAG.getNode(ISD::FADD, DL, VT, B, B);\n    return DAG.getNode(ISD::FSUB, DL, VT, N1, Add);\n  }\n  // fadd A, (fmul B, -2.0) --> fsub A, (fadd B, B)\n  if (isFMulNegTwo(N1)) {\n    SDValue B = N1.getOperand(0);\n    SDValue Add = DAG.getNode(ISD::FADD, DL, VT, B, B);\n    return DAG.getNode(ISD::FSUB, DL, VT, N0, Add);\n  }\n\n  // No FP constant should be created after legalization as Instruction\n  // Selection pass has a hard time dealing with FP constants.\n  bool AllowNewConst = (Level < AfterLegalizeDAG);\n\n  // If nnan is enabled, fold lots of things.\n  if ((Options.NoNaNsFPMath || Flags.hasNoNaNs()) && AllowNewConst) {\n    // If allowed, fold (fadd (fneg x), x) -> 0.0\n    if (N0.getOpcode() == ISD::FNEG && N0.getOperand(0) == N1)\n      return DAG.getConstantFP(0.0, DL, VT);\n\n    // If allowed, fold (fadd x, (fneg x)) -> 0.0\n    if (N1.getOpcode() == ISD::FNEG && N1.getOperand(0) == N0)\n      return DAG.getConstantFP(0.0, DL, VT);\n  }\n\n  // If 'unsafe math' or reassoc and nsz, fold lots of things.\n  // TODO: break out portions of the transformations below for which Unsafe is\n  //       considered and which do not require both nsz and reassoc\n  if (((Options.UnsafeFPMath && Options.NoSignedZerosFPMath) ||\n       (Flags.hasAllowReassociation() && Flags.hasNoSignedZeros())) &&\n      AllowNewConst) {\n    // fadd (fadd x, c1), c2 -> fadd x, c1 + c2\n    if (N1CFP && N0.getOpcode() == ISD::FADD &&\n        DAG.isConstantFPBuildVectorOrConstantFP(N0.getOperand(1))) {\n      SDValue NewC = DAG.getNode(ISD::FADD, DL, VT, N0.getOperand(1), N1);\n      return DAG.getNode(ISD::FADD, DL, VT, N0.getOperand(0), NewC);\n    }\n\n    // We can fold chains of FADD's of the same value into multiplications.\n    // This transform is not safe in general because we are reducing the number\n    // of rounding steps.\n    if (TLI.isOperationLegalOrCustom(ISD::FMUL, VT) && !N0CFP && !N1CFP) {\n      if (N0.getOpcode() == ISD::FMUL) {\n        bool CFP00 = DAG.isConstantFPBuildVectorOrConstantFP(N0.getOperand(0));\n        bool CFP01 = DAG.isConstantFPBuildVectorOrConstantFP(N0.getOperand(1));\n\n        // (fadd (fmul x, c), x) -> (fmul x, c+1)\n        if (CFP01 && !CFP00 && N0.getOperand(0) == N1) {\n          SDValue NewCFP = DAG.getNode(ISD::FADD, DL, VT, N0.getOperand(1),\n                                       DAG.getConstantFP(1.0, DL, VT));\n          return DAG.getNode(ISD::FMUL, DL, VT, N1, NewCFP);\n        }\n\n        // (fadd (fmul x, c), (fadd x, x)) -> (fmul x, c+2)\n        if (CFP01 && !CFP00 && N1.getOpcode() == ISD::FADD &&\n            N1.getOperand(0) == N1.getOperand(1) &&\n            N0.getOperand(0) == N1.getOperand(0)) {\n          SDValue NewCFP = DAG.getNode(ISD::FADD, DL, VT, N0.getOperand(1),\n                                       DAG.getConstantFP(2.0, DL, VT));\n          return DAG.getNode(ISD::FMUL, DL, VT, N0.getOperand(0), NewCFP);\n        }\n      }\n\n      if (N1.getOpcode() == ISD::FMUL) {\n        bool CFP10 = DAG.isConstantFPBuildVectorOrConstantFP(N1.getOperand(0));\n        bool CFP11 = DAG.isConstantFPBuildVectorOrConstantFP(N1.getOperand(1));\n\n        // (fadd x, (fmul x, c)) -> (fmul x, c+1)\n        if (CFP11 && !CFP10 && N1.getOperand(0) == N0) {\n          SDValue NewCFP = DAG.getNode(ISD::FADD, DL, VT, N1.getOperand(1),\n                                       DAG.getConstantFP(1.0, DL, VT));\n          return DAG.getNode(ISD::FMUL, DL, VT, N0, NewCFP);\n        }\n\n        // (fadd (fadd x, x), (fmul x, c)) -> (fmul x, c+2)\n        if (CFP11 && !CFP10 && N0.getOpcode() == ISD::FADD &&\n            N0.getOperand(0) == N0.getOperand(1) &&\n            N1.getOperand(0) == N0.getOperand(0)) {\n          SDValue NewCFP = DAG.getNode(ISD::FADD, DL, VT, N1.getOperand(1),\n                                       DAG.getConstantFP(2.0, DL, VT));\n          return DAG.getNode(ISD::FMUL, DL, VT, N1.getOperand(0), NewCFP);\n        }\n      }\n\n      if (N0.getOpcode() == ISD::FADD) {\n        bool CFP00 = DAG.isConstantFPBuildVectorOrConstantFP(N0.getOperand(0));\n        // (fadd (fadd x, x), x) -> (fmul x, 3.0)\n        if (!CFP00 && N0.getOperand(0) == N0.getOperand(1) &&\n            (N0.getOperand(0) == N1)) {\n          return DAG.getNode(ISD::FMUL, DL, VT, N1,\n                             DAG.getConstantFP(3.0, DL, VT));\n        }\n      }\n\n      if (N1.getOpcode() == ISD::FADD) {\n        bool CFP10 = DAG.isConstantFPBuildVectorOrConstantFP(N1.getOperand(0));\n        // (fadd x, (fadd x, x)) -> (fmul x, 3.0)\n        if (!CFP10 && N1.getOperand(0) == N1.getOperand(1) &&\n            N1.getOperand(0) == N0) {\n          return DAG.getNode(ISD::FMUL, DL, VT, N0,\n                             DAG.getConstantFP(3.0, DL, VT));\n        }\n      }\n\n      // (fadd (fadd x, x), (fadd x, x)) -> (fmul x, 4.0)\n      if (N0.getOpcode() == ISD::FADD && N1.getOpcode() == ISD::FADD &&\n          N0.getOperand(0) == N0.getOperand(1) &&\n          N1.getOperand(0) == N1.getOperand(1) &&\n          N0.getOperand(0) == N1.getOperand(0)) {\n        return DAG.getNode(ISD::FMUL, DL, VT, N0.getOperand(0),\n                           DAG.getConstantFP(4.0, DL, VT));\n      }\n    }\n  } // enable-unsafe-fp-math\n\n  // FADD -> FMA combines:\n  if (SDValue Fused = visitFADDForFMACombine(N)) {\n    AddToWorklist(Fused.getNode());\n    return Fused;\n  }\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitSTRICT_FADD(SDNode *N) {\n  SDValue Chain = N->getOperand(0);\n  SDValue N0 = N->getOperand(1);\n  SDValue N1 = N->getOperand(2);\n  EVT VT = N->getValueType(0);\n  EVT ChainVT = N->getValueType(1);\n  SDLoc DL(N);\n  SelectionDAG::FlagInserter FlagsInserter(DAG, N);\n\n  // fold (strict_fadd A, (fneg B)) -> (strict_fsub A, B)\n  if (!LegalOperations || TLI.isOperationLegalOrCustom(ISD::STRICT_FSUB, VT))\n    if (SDValue NegN1 = TLI.getCheaperNegatedExpression(\n            N1, DAG, LegalOperations, ForCodeSize)) {\n      return DAG.getNode(ISD::STRICT_FSUB, DL, DAG.getVTList(VT, ChainVT),\n                         {Chain, N0, NegN1});\n    }\n\n  // fold (strict_fadd (fneg A), B) -> (strict_fsub B, A)\n  if (!LegalOperations || TLI.isOperationLegalOrCustom(ISD::STRICT_FSUB, VT))\n    if (SDValue NegN0 = TLI.getCheaperNegatedExpression(\n            N0, DAG, LegalOperations, ForCodeSize)) {\n      return DAG.getNode(ISD::STRICT_FSUB, DL, DAG.getVTList(VT, ChainVT),\n                         {Chain, N1, NegN0});\n    }\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitFSUB(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  ConstantFPSDNode *N0CFP = isConstOrConstSplatFP(N0, true);\n  ConstantFPSDNode *N1CFP = isConstOrConstSplatFP(N1, true);\n  EVT VT = N->getValueType(0);\n  SDLoc DL(N);\n  const TargetOptions &Options = DAG.getTarget().Options;\n  const SDNodeFlags Flags = N->getFlags();\n  SelectionDAG::FlagInserter FlagsInserter(DAG, N);\n\n  if (SDValue R = DAG.simplifyFPBinop(N->getOpcode(), N0, N1, Flags))\n    return R;\n\n  // fold vector ops\n  if (VT.isVector())\n    if (SDValue FoldedVOp = SimplifyVBinOp(N))\n      return FoldedVOp;\n\n  // fold (fsub c1, c2) -> c1-c2\n  if (N0CFP && N1CFP)\n    return DAG.getNode(ISD::FSUB, DL, VT, N0, N1);\n\n  if (SDValue NewSel = foldBinOpIntoSelect(N))\n    return NewSel;\n\n  // (fsub A, 0) -> A\n  if (N1CFP && N1CFP->isZero()) {\n    if (!N1CFP->isNegative() || Options.NoSignedZerosFPMath ||\n        Flags.hasNoSignedZeros()) {\n      return N0;\n    }\n  }\n\n  if (N0 == N1) {\n    // (fsub x, x) -> 0.0\n    if (Options.NoNaNsFPMath || Flags.hasNoNaNs())\n      return DAG.getConstantFP(0.0f, DL, VT);\n  }\n\n  // (fsub -0.0, N1) -> -N1\n  if (N0CFP && N0CFP->isZero()) {\n    if (N0CFP->isNegative() ||\n        (Options.NoSignedZerosFPMath || Flags.hasNoSignedZeros())) {\n      // We cannot replace an FSUB(+-0.0,X) with FNEG(X) when denormals are\n      // flushed to zero, unless all users treat denorms as zero (DAZ).\n      // FIXME: This transform will change the sign of a NaN and the behavior\n      // of a signaling NaN. It is only valid when a NoNaN flag is present.\n      DenormalMode DenormMode = DAG.getDenormalMode(VT);\n      if (DenormMode == DenormalMode::getIEEE()) {\n        if (SDValue NegN1 =\n                TLI.getNegatedExpression(N1, DAG, LegalOperations, ForCodeSize))\n          return NegN1;\n        if (!LegalOperations || TLI.isOperationLegal(ISD::FNEG, VT))\n          return DAG.getNode(ISD::FNEG, DL, VT, N1);\n      }\n    }\n  }\n\n  if (((Options.UnsafeFPMath && Options.NoSignedZerosFPMath) ||\n       (Flags.hasAllowReassociation() && Flags.hasNoSignedZeros())) &&\n      N1.getOpcode() == ISD::FADD) {\n    // X - (X + Y) -> -Y\n    if (N0 == N1->getOperand(0))\n      return DAG.getNode(ISD::FNEG, DL, VT, N1->getOperand(1));\n    // X - (Y + X) -> -Y\n    if (N0 == N1->getOperand(1))\n      return DAG.getNode(ISD::FNEG, DL, VT, N1->getOperand(0));\n  }\n\n  // fold (fsub A, (fneg B)) -> (fadd A, B)\n  if (SDValue NegN1 =\n          TLI.getNegatedExpression(N1, DAG, LegalOperations, ForCodeSize))\n    return DAG.getNode(ISD::FADD, DL, VT, N0, NegN1);\n\n  // FSUB -> FMA combines:\n  if (SDValue Fused = visitFSUBForFMACombine(N)) {\n    AddToWorklist(Fused.getNode());\n    return Fused;\n  }\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitFMUL(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  ConstantFPSDNode *N0CFP = isConstOrConstSplatFP(N0, true);\n  ConstantFPSDNode *N1CFP = isConstOrConstSplatFP(N1, true);\n  EVT VT = N->getValueType(0);\n  SDLoc DL(N);\n  const TargetOptions &Options = DAG.getTarget().Options;\n  const SDNodeFlags Flags = N->getFlags();\n  SelectionDAG::FlagInserter FlagsInserter(DAG, N);\n\n  if (SDValue R = DAG.simplifyFPBinop(N->getOpcode(), N0, N1, Flags))\n    return R;\n\n  // fold vector ops\n  if (VT.isVector()) {\n    // This just handles C1 * C2 for vectors. Other vector folds are below.\n    if (SDValue FoldedVOp = SimplifyVBinOp(N))\n      return FoldedVOp;\n  }\n\n  // fold (fmul c1, c2) -> c1*c2\n  if (N0CFP && N1CFP)\n    return DAG.getNode(ISD::FMUL, DL, VT, N0, N1);\n\n  // canonicalize constant to RHS\n  if (DAG.isConstantFPBuildVectorOrConstantFP(N0) &&\n     !DAG.isConstantFPBuildVectorOrConstantFP(N1))\n    return DAG.getNode(ISD::FMUL, DL, VT, N1, N0);\n\n  if (SDValue NewSel = foldBinOpIntoSelect(N))\n    return NewSel;\n\n  if (Options.UnsafeFPMath || Flags.hasAllowReassociation()) {\n    // fmul (fmul X, C1), C2 -> fmul X, C1 * C2\n    if (DAG.isConstantFPBuildVectorOrConstantFP(N1) &&\n        N0.getOpcode() == ISD::FMUL) {\n      SDValue N00 = N0.getOperand(0);\n      SDValue N01 = N0.getOperand(1);\n      // Avoid an infinite loop by making sure that N00 is not a constant\n      // (the inner multiply has not been constant folded yet).\n      if (DAG.isConstantFPBuildVectorOrConstantFP(N01) &&\n          !DAG.isConstantFPBuildVectorOrConstantFP(N00)) {\n        SDValue MulConsts = DAG.getNode(ISD::FMUL, DL, VT, N01, N1);\n        return DAG.getNode(ISD::FMUL, DL, VT, N00, MulConsts);\n      }\n    }\n\n    // Match a special-case: we convert X * 2.0 into fadd.\n    // fmul (fadd X, X), C -> fmul X, 2.0 * C\n    if (N0.getOpcode() == ISD::FADD && N0.hasOneUse() &&\n        N0.getOperand(0) == N0.getOperand(1)) {\n      const SDValue Two = DAG.getConstantFP(2.0, DL, VT);\n      SDValue MulConsts = DAG.getNode(ISD::FMUL, DL, VT, Two, N1);\n      return DAG.getNode(ISD::FMUL, DL, VT, N0.getOperand(0), MulConsts);\n    }\n  }\n\n  // fold (fmul X, 2.0) -> (fadd X, X)\n  if (N1CFP && N1CFP->isExactlyValue(+2.0))\n    return DAG.getNode(ISD::FADD, DL, VT, N0, N0);\n\n  // fold (fmul X, -1.0) -> (fneg X)\n  if (N1CFP && N1CFP->isExactlyValue(-1.0))\n    if (!LegalOperations || TLI.isOperationLegal(ISD::FNEG, VT))\n      return DAG.getNode(ISD::FNEG, DL, VT, N0);\n\n  // -N0 * -N1 --> N0 * N1\n  TargetLowering::NegatibleCost CostN0 =\n      TargetLowering::NegatibleCost::Expensive;\n  TargetLowering::NegatibleCost CostN1 =\n      TargetLowering::NegatibleCost::Expensive;\n  SDValue NegN0 =\n      TLI.getNegatedExpression(N0, DAG, LegalOperations, ForCodeSize, CostN0);\n  SDValue NegN1 =\n      TLI.getNegatedExpression(N1, DAG, LegalOperations, ForCodeSize, CostN1);\n  if (NegN0 && NegN1 &&\n      (CostN0 == TargetLowering::NegatibleCost::Cheaper ||\n       CostN1 == TargetLowering::NegatibleCost::Cheaper))\n    return DAG.getNode(ISD::FMUL, DL, VT, NegN0, NegN1);\n\n  // fold (fmul X, (select (fcmp X > 0.0), -1.0, 1.0)) -> (fneg (fabs X))\n  // fold (fmul X, (select (fcmp X > 0.0), 1.0, -1.0)) -> (fabs X)\n  if (Flags.hasNoNaNs() && Flags.hasNoSignedZeros() &&\n      (N0.getOpcode() == ISD::SELECT || N1.getOpcode() == ISD::SELECT) &&\n      TLI.isOperationLegal(ISD::FABS, VT)) {\n    SDValue Select = N0, X = N1;\n    if (Select.getOpcode() != ISD::SELECT)\n      std::swap(Select, X);\n\n    SDValue Cond = Select.getOperand(0);\n    auto TrueOpnd  = dyn_cast<ConstantFPSDNode>(Select.getOperand(1));\n    auto FalseOpnd = dyn_cast<ConstantFPSDNode>(Select.getOperand(2));\n\n    if (TrueOpnd && FalseOpnd &&\n        Cond.getOpcode() == ISD::SETCC && Cond.getOperand(0) == X &&\n        isa<ConstantFPSDNode>(Cond.getOperand(1)) &&\n        cast<ConstantFPSDNode>(Cond.getOperand(1))->isExactlyValue(0.0)) {\n      ISD::CondCode CC = cast<CondCodeSDNode>(Cond.getOperand(2))->get();\n      switch (CC) {\n      default: break;\n      case ISD::SETOLT:\n      case ISD::SETULT:\n      case ISD::SETOLE:\n      case ISD::SETULE:\n      case ISD::SETLT:\n      case ISD::SETLE:\n        std::swap(TrueOpnd, FalseOpnd);\n        LLVM_FALLTHROUGH;\n      case ISD::SETOGT:\n      case ISD::SETUGT:\n      case ISD::SETOGE:\n      case ISD::SETUGE:\n      case ISD::SETGT:\n      case ISD::SETGE:\n        if (TrueOpnd->isExactlyValue(-1.0) && FalseOpnd->isExactlyValue(1.0) &&\n            TLI.isOperationLegal(ISD::FNEG, VT))\n          return DAG.getNode(ISD::FNEG, DL, VT,\n                   DAG.getNode(ISD::FABS, DL, VT, X));\n        if (TrueOpnd->isExactlyValue(1.0) && FalseOpnd->isExactlyValue(-1.0))\n          return DAG.getNode(ISD::FABS, DL, VT, X);\n\n        break;\n      }\n    }\n  }\n\n  // FMUL -> FMA combines:\n  if (SDValue Fused = visitFMULForFMADistributiveCombine(N)) {\n    AddToWorklist(Fused.getNode());\n    return Fused;\n  }\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitFMA(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  SDValue N2 = N->getOperand(2);\n  ConstantFPSDNode *N0CFP = dyn_cast<ConstantFPSDNode>(N0);\n  ConstantFPSDNode *N1CFP = dyn_cast<ConstantFPSDNode>(N1);\n  EVT VT = N->getValueType(0);\n  SDLoc DL(N);\n  const TargetOptions &Options = DAG.getTarget().Options;\n  // FMA nodes have flags that propagate to the created nodes.\n  SelectionDAG::FlagInserter FlagsInserter(DAG, N);\n\n  bool UnsafeFPMath =\n      Options.UnsafeFPMath || N->getFlags().hasAllowReassociation();\n\n  // Constant fold FMA.\n  if (isa<ConstantFPSDNode>(N0) &&\n      isa<ConstantFPSDNode>(N1) &&\n      isa<ConstantFPSDNode>(N2)) {\n    return DAG.getNode(ISD::FMA, DL, VT, N0, N1, N2);\n  }\n\n  // (-N0 * -N1) + N2 --> (N0 * N1) + N2\n  TargetLowering::NegatibleCost CostN0 =\n      TargetLowering::NegatibleCost::Expensive;\n  TargetLowering::NegatibleCost CostN1 =\n      TargetLowering::NegatibleCost::Expensive;\n  SDValue NegN0 =\n      TLI.getNegatedExpression(N0, DAG, LegalOperations, ForCodeSize, CostN0);\n  SDValue NegN1 =\n      TLI.getNegatedExpression(N1, DAG, LegalOperations, ForCodeSize, CostN1);\n  if (NegN0 && NegN1 &&\n      (CostN0 == TargetLowering::NegatibleCost::Cheaper ||\n       CostN1 == TargetLowering::NegatibleCost::Cheaper))\n    return DAG.getNode(ISD::FMA, DL, VT, NegN0, NegN1, N2);\n\n  if (UnsafeFPMath) {\n    if (N0CFP && N0CFP->isZero())\n      return N2;\n    if (N1CFP && N1CFP->isZero())\n      return N2;\n  }\n\n  if (N0CFP && N0CFP->isExactlyValue(1.0))\n    return DAG.getNode(ISD::FADD, SDLoc(N), VT, N1, N2);\n  if (N1CFP && N1CFP->isExactlyValue(1.0))\n    return DAG.getNode(ISD::FADD, SDLoc(N), VT, N0, N2);\n\n  // Canonicalize (fma c, x, y) -> (fma x, c, y)\n  if (DAG.isConstantFPBuildVectorOrConstantFP(N0) &&\n     !DAG.isConstantFPBuildVectorOrConstantFP(N1))\n    return DAG.getNode(ISD::FMA, SDLoc(N), VT, N1, N0, N2);\n\n  if (UnsafeFPMath) {\n    // (fma x, c1, (fmul x, c2)) -> (fmul x, c1+c2)\n    if (N2.getOpcode() == ISD::FMUL && N0 == N2.getOperand(0) &&\n        DAG.isConstantFPBuildVectorOrConstantFP(N1) &&\n        DAG.isConstantFPBuildVectorOrConstantFP(N2.getOperand(1))) {\n      return DAG.getNode(ISD::FMUL, DL, VT, N0,\n                         DAG.getNode(ISD::FADD, DL, VT, N1, N2.getOperand(1)));\n    }\n\n    // (fma (fmul x, c1), c2, y) -> (fma x, c1*c2, y)\n    if (N0.getOpcode() == ISD::FMUL &&\n        DAG.isConstantFPBuildVectorOrConstantFP(N1) &&\n        DAG.isConstantFPBuildVectorOrConstantFP(N0.getOperand(1))) {\n      return DAG.getNode(ISD::FMA, DL, VT, N0.getOperand(0),\n                         DAG.getNode(ISD::FMUL, DL, VT, N1, N0.getOperand(1)),\n                         N2);\n    }\n  }\n\n  // (fma x, -1, y) -> (fadd (fneg x), y)\n  if (N1CFP) {\n    if (N1CFP->isExactlyValue(1.0))\n      return DAG.getNode(ISD::FADD, DL, VT, N0, N2);\n\n    if (N1CFP->isExactlyValue(-1.0) &&\n        (!LegalOperations || TLI.isOperationLegal(ISD::FNEG, VT))) {\n      SDValue RHSNeg = DAG.getNode(ISD::FNEG, DL, VT, N0);\n      AddToWorklist(RHSNeg.getNode());\n      return DAG.getNode(ISD::FADD, DL, VT, N2, RHSNeg);\n    }\n\n    // fma (fneg x), K, y -> fma x -K, y\n    if (N0.getOpcode() == ISD::FNEG &&\n        (TLI.isOperationLegal(ISD::ConstantFP, VT) ||\n         (N1.hasOneUse() && !TLI.isFPImmLegal(N1CFP->getValueAPF(), VT,\n                                              ForCodeSize)))) {\n      return DAG.getNode(ISD::FMA, DL, VT, N0.getOperand(0),\n                         DAG.getNode(ISD::FNEG, DL, VT, N1), N2);\n    }\n  }\n\n  if (UnsafeFPMath) {\n    // (fma x, c, x) -> (fmul x, (c+1))\n    if (N1CFP && N0 == N2) {\n      return DAG.getNode(\n          ISD::FMUL, DL, VT, N0,\n          DAG.getNode(ISD::FADD, DL, VT, N1, DAG.getConstantFP(1.0, DL, VT)));\n    }\n\n    // (fma x, c, (fneg x)) -> (fmul x, (c-1))\n    if (N1CFP && N2.getOpcode() == ISD::FNEG && N2.getOperand(0) == N0) {\n      return DAG.getNode(\n          ISD::FMUL, DL, VT, N0,\n          DAG.getNode(ISD::FADD, DL, VT, N1, DAG.getConstantFP(-1.0, DL, VT)));\n    }\n  }\n\n  // fold ((fma (fneg X), Y, (fneg Z)) -> fneg (fma X, Y, Z))\n  // fold ((fma X, (fneg Y), (fneg Z)) -> fneg (fma X, Y, Z))\n  if (!TLI.isFNegFree(VT))\n    if (SDValue Neg = TLI.getCheaperNegatedExpression(\n            SDValue(N, 0), DAG, LegalOperations, ForCodeSize))\n      return DAG.getNode(ISD::FNEG, DL, VT, Neg);\n  return SDValue();\n}\n\n// Combine multiple FDIVs with the same divisor into multiple FMULs by the\n// reciprocal.\n// E.g., (a / D; b / D;) -> (recip = 1.0 / D; a * recip; b * recip)\n// Notice that this is not always beneficial. One reason is different targets\n// may have different costs for FDIV and FMUL, so sometimes the cost of two\n// FDIVs may be lower than the cost of one FDIV and two FMULs. Another reason\n// is the critical path is increased from \"one FDIV\" to \"one FDIV + one FMUL\".\nSDValue DAGCombiner::combineRepeatedFPDivisors(SDNode *N) {\n  // TODO: Limit this transform based on optsize/minsize - it always creates at\n  //       least 1 extra instruction. But the perf win may be substantial enough\n  //       that only minsize should restrict this.\n  bool UnsafeMath = DAG.getTarget().Options.UnsafeFPMath;\n  const SDNodeFlags Flags = N->getFlags();\n  if (LegalDAG || (!UnsafeMath && !Flags.hasAllowReciprocal()))\n    return SDValue();\n\n  // Skip if current node is a reciprocal/fneg-reciprocal.\n  SDValue N0 = N->getOperand(0), N1 = N->getOperand(1);\n  ConstantFPSDNode *N0CFP = isConstOrConstSplatFP(N0, /* AllowUndefs */ true);\n  if (N0CFP && (N0CFP->isExactlyValue(1.0) || N0CFP->isExactlyValue(-1.0)))\n    return SDValue();\n\n  // Exit early if the target does not want this transform or if there can't\n  // possibly be enough uses of the divisor to make the transform worthwhile.\n  unsigned MinUses = TLI.combineRepeatedFPDivisors();\n\n  // For splat vectors, scale the number of uses by the splat factor. If we can\n  // convert the division into a scalar op, that will likely be much faster.\n  unsigned NumElts = 1;\n  EVT VT = N->getValueType(0);\n  if (VT.isVector() && DAG.isSplatValue(N1))\n    NumElts = VT.getVectorNumElements();\n\n  if (!MinUses || (N1->use_size() * NumElts) < MinUses)\n    return SDValue();\n\n  // Find all FDIV users of the same divisor.\n  // Use a set because duplicates may be present in the user list.\n  SetVector<SDNode *> Users;\n  for (auto *U : N1->uses()) {\n    if (U->getOpcode() == ISD::FDIV && U->getOperand(1) == N1) {\n      // Skip X/sqrt(X) that has not been simplified to sqrt(X) yet.\n      if (U->getOperand(1).getOpcode() == ISD::FSQRT &&\n          U->getOperand(0) == U->getOperand(1).getOperand(0) &&\n          U->getFlags().hasAllowReassociation() &&\n          U->getFlags().hasNoSignedZeros())\n        continue;\n\n      // This division is eligible for optimization only if global unsafe math\n      // is enabled or if this division allows reciprocal formation.\n      if (UnsafeMath || U->getFlags().hasAllowReciprocal())\n        Users.insert(U);\n    }\n  }\n\n  // Now that we have the actual number of divisor uses, make sure it meets\n  // the minimum threshold specified by the target.\n  if ((Users.size() * NumElts) < MinUses)\n    return SDValue();\n\n  SDLoc DL(N);\n  SDValue FPOne = DAG.getConstantFP(1.0, DL, VT);\n  SDValue Reciprocal = DAG.getNode(ISD::FDIV, DL, VT, FPOne, N1, Flags);\n\n  // Dividend / Divisor -> Dividend * Reciprocal\n  for (auto *U : Users) {\n    SDValue Dividend = U->getOperand(0);\n    if (Dividend != FPOne) {\n      SDValue NewNode = DAG.getNode(ISD::FMUL, SDLoc(U), VT, Dividend,\n                                    Reciprocal, Flags);\n      CombineTo(U, NewNode);\n    } else if (U != Reciprocal.getNode()) {\n      // In the absence of fast-math-flags, this user node is always the\n      // same node as Reciprocal, but with FMF they may be different nodes.\n      CombineTo(U, Reciprocal);\n    }\n  }\n  return SDValue(N, 0);  // N was replaced.\n}\n\nSDValue DAGCombiner::visitFDIV(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  ConstantFPSDNode *N0CFP = dyn_cast<ConstantFPSDNode>(N0);\n  ConstantFPSDNode *N1CFP = dyn_cast<ConstantFPSDNode>(N1);\n  EVT VT = N->getValueType(0);\n  SDLoc DL(N);\n  const TargetOptions &Options = DAG.getTarget().Options;\n  SDNodeFlags Flags = N->getFlags();\n  SelectionDAG::FlagInserter FlagsInserter(DAG, N);\n\n  if (SDValue R = DAG.simplifyFPBinop(N->getOpcode(), N0, N1, Flags))\n    return R;\n\n  // fold vector ops\n  if (VT.isVector())\n    if (SDValue FoldedVOp = SimplifyVBinOp(N))\n      return FoldedVOp;\n\n  // fold (fdiv c1, c2) -> c1/c2\n  if (N0CFP && N1CFP)\n    return DAG.getNode(ISD::FDIV, SDLoc(N), VT, N0, N1);\n\n  if (SDValue NewSel = foldBinOpIntoSelect(N))\n    return NewSel;\n\n  if (SDValue V = combineRepeatedFPDivisors(N))\n    return V;\n\n  if (Options.UnsafeFPMath || Flags.hasAllowReciprocal()) {\n    // fold (fdiv X, c2) -> fmul X, 1/c2 if losing precision is acceptable.\n    if (N1CFP) {\n      // Compute the reciprocal 1.0 / c2.\n      const APFloat &N1APF = N1CFP->getValueAPF();\n      APFloat Recip(N1APF.getSemantics(), 1); // 1.0\n      APFloat::opStatus st = Recip.divide(N1APF, APFloat::rmNearestTiesToEven);\n      // Only do the transform if the reciprocal is a legal fp immediate that\n      // isn't too nasty (eg NaN, denormal, ...).\n      if ((st == APFloat::opOK || st == APFloat::opInexact) && // Not too nasty\n          (!LegalOperations ||\n           // FIXME: custom lowering of ConstantFP might fail (see e.g. ARM\n           // backend)... we should handle this gracefully after Legalize.\n           // TLI.isOperationLegalOrCustom(ISD::ConstantFP, VT) ||\n           TLI.isOperationLegal(ISD::ConstantFP, VT) ||\n           TLI.isFPImmLegal(Recip, VT, ForCodeSize)))\n        return DAG.getNode(ISD::FMUL, DL, VT, N0,\n                           DAG.getConstantFP(Recip, DL, VT));\n    }\n\n    // If this FDIV is part of a reciprocal square root, it may be folded\n    // into a target-specific square root estimate instruction.\n    if (N1.getOpcode() == ISD::FSQRT) {\n      if (SDValue RV = buildRsqrtEstimate(N1.getOperand(0), Flags))\n        return DAG.getNode(ISD::FMUL, DL, VT, N0, RV);\n    } else if (N1.getOpcode() == ISD::FP_EXTEND &&\n               N1.getOperand(0).getOpcode() == ISD::FSQRT) {\n      if (SDValue RV =\n              buildRsqrtEstimate(N1.getOperand(0).getOperand(0), Flags)) {\n        RV = DAG.getNode(ISD::FP_EXTEND, SDLoc(N1), VT, RV);\n        AddToWorklist(RV.getNode());\n        return DAG.getNode(ISD::FMUL, DL, VT, N0, RV);\n      }\n    } else if (N1.getOpcode() == ISD::FP_ROUND &&\n               N1.getOperand(0).getOpcode() == ISD::FSQRT) {\n      if (SDValue RV =\n              buildRsqrtEstimate(N1.getOperand(0).getOperand(0), Flags)) {\n        RV = DAG.getNode(ISD::FP_ROUND, SDLoc(N1), VT, RV, N1.getOperand(1));\n        AddToWorklist(RV.getNode());\n        return DAG.getNode(ISD::FMUL, DL, VT, N0, RV);\n      }\n    } else if (N1.getOpcode() == ISD::FMUL) {\n      // Look through an FMUL. Even though this won't remove the FDIV directly,\n      // it's still worthwhile to get rid of the FSQRT if possible.\n      SDValue Sqrt, Y;\n      if (N1.getOperand(0).getOpcode() == ISD::FSQRT) {\n        Sqrt = N1.getOperand(0);\n        Y = N1.getOperand(1);\n      } else if (N1.getOperand(1).getOpcode() == ISD::FSQRT) {\n        Sqrt = N1.getOperand(1);\n        Y = N1.getOperand(0);\n      }\n      if (Sqrt.getNode()) {\n        // If the other multiply operand is known positive, pull it into the\n        // sqrt. That will eliminate the division if we convert to an estimate.\n        if (Flags.hasAllowReassociation() && N1.hasOneUse() &&\n            N1->getFlags().hasAllowReassociation() && Sqrt.hasOneUse()) {\n          SDValue A;\n          if (Y.getOpcode() == ISD::FABS && Y.hasOneUse())\n            A = Y.getOperand(0);\n          else if (Y == Sqrt.getOperand(0))\n            A = Y;\n          if (A) {\n            // X / (fabs(A) * sqrt(Z)) --> X / sqrt(A*A*Z) --> X * rsqrt(A*A*Z)\n            // X / (A * sqrt(A))       --> X / sqrt(A*A*A) --> X * rsqrt(A*A*A)\n            SDValue AA = DAG.getNode(ISD::FMUL, DL, VT, A, A);\n            SDValue AAZ =\n                DAG.getNode(ISD::FMUL, DL, VT, AA, Sqrt.getOperand(0));\n            if (SDValue Rsqrt = buildRsqrtEstimate(AAZ, Flags))\n              return DAG.getNode(ISD::FMUL, DL, VT, N0, Rsqrt);\n\n            // Estimate creation failed. Clean up speculatively created nodes.\n            recursivelyDeleteUnusedNodes(AAZ.getNode());\n          }\n        }\n\n        // We found a FSQRT, so try to make this fold:\n        // X / (Y * sqrt(Z)) -> X * (rsqrt(Z) / Y)\n        if (SDValue Rsqrt = buildRsqrtEstimate(Sqrt.getOperand(0), Flags)) {\n          SDValue Div = DAG.getNode(ISD::FDIV, SDLoc(N1), VT, Rsqrt, Y);\n          AddToWorklist(Div.getNode());\n          return DAG.getNode(ISD::FMUL, DL, VT, N0, Div);\n        }\n      }\n    }\n\n    // Fold into a reciprocal estimate and multiply instead of a real divide.\n    if (Options.NoInfsFPMath || Flags.hasNoInfs())\n      if (SDValue RV = BuildDivEstimate(N0, N1, Flags))\n        return RV;\n  }\n\n  // Fold X/Sqrt(X) -> Sqrt(X)\n  if ((Options.NoSignedZerosFPMath || Flags.hasNoSignedZeros()) &&\n      (Options.UnsafeFPMath || Flags.hasAllowReassociation()))\n    if (N1.getOpcode() == ISD::FSQRT && N0 == N1.getOperand(0))\n      return N1;\n\n  // (fdiv (fneg X), (fneg Y)) -> (fdiv X, Y)\n  TargetLowering::NegatibleCost CostN0 =\n      TargetLowering::NegatibleCost::Expensive;\n  TargetLowering::NegatibleCost CostN1 =\n      TargetLowering::NegatibleCost::Expensive;\n  SDValue NegN0 =\n      TLI.getNegatedExpression(N0, DAG, LegalOperations, ForCodeSize, CostN0);\n  SDValue NegN1 =\n      TLI.getNegatedExpression(N1, DAG, LegalOperations, ForCodeSize, CostN1);\n  if (NegN0 && NegN1 &&\n      (CostN0 == TargetLowering::NegatibleCost::Cheaper ||\n       CostN1 == TargetLowering::NegatibleCost::Cheaper))\n    return DAG.getNode(ISD::FDIV, SDLoc(N), VT, NegN0, NegN1);\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitFREM(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  ConstantFPSDNode *N0CFP = dyn_cast<ConstantFPSDNode>(N0);\n  ConstantFPSDNode *N1CFP = dyn_cast<ConstantFPSDNode>(N1);\n  EVT VT = N->getValueType(0);\n  SDNodeFlags Flags = N->getFlags();\n  SelectionDAG::FlagInserter FlagsInserter(DAG, N);\n\n  if (SDValue R = DAG.simplifyFPBinop(N->getOpcode(), N0, N1, Flags))\n    return R;\n\n  // fold (frem c1, c2) -> fmod(c1,c2)\n  if (N0CFP && N1CFP)\n    return DAG.getNode(ISD::FREM, SDLoc(N), VT, N0, N1);\n\n  if (SDValue NewSel = foldBinOpIntoSelect(N))\n    return NewSel;\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitFSQRT(SDNode *N) {\n  SDNodeFlags Flags = N->getFlags();\n  const TargetOptions &Options = DAG.getTarget().Options;\n\n  // Require 'ninf' flag since sqrt(+Inf) = +Inf, but the estimation goes as:\n  // sqrt(+Inf) == rsqrt(+Inf) * +Inf = 0 * +Inf = NaN\n  if (!Flags.hasApproximateFuncs() ||\n      (!Options.NoInfsFPMath && !Flags.hasNoInfs()))\n    return SDValue();\n\n  SDValue N0 = N->getOperand(0);\n  if (TLI.isFsqrtCheap(N0, DAG))\n    return SDValue();\n\n  // FSQRT nodes have flags that propagate to the created nodes.\n  // TODO: If this is N0/sqrt(N0), and we reach this node before trying to\n  //       transform the fdiv, we may produce a sub-optimal estimate sequence\n  //       because the reciprocal calculation may not have to filter out a\n  //       0.0 input.\n  return buildSqrtEstimate(N0, Flags);\n}\n\n/// copysign(x, fp_extend(y)) -> copysign(x, y)\n/// copysign(x, fp_round(y)) -> copysign(x, y)\nstatic inline bool CanCombineFCOPYSIGN_EXTEND_ROUND(SDNode *N) {\n  SDValue N1 = N->getOperand(1);\n  if ((N1.getOpcode() == ISD::FP_EXTEND ||\n       N1.getOpcode() == ISD::FP_ROUND)) {\n    EVT N1VT = N1->getValueType(0);\n    EVT N1Op0VT = N1->getOperand(0).getValueType();\n\n    // Always fold no-op FP casts.\n    if (N1VT == N1Op0VT)\n      return true;\n\n    // Do not optimize out type conversion of f128 type yet.\n    // For some targets like x86_64, configuration is changed to keep one f128\n    // value in one SSE register, but instruction selection cannot handle\n    // FCOPYSIGN on SSE registers yet.\n    if (N1Op0VT == MVT::f128)\n      return false;\n\n    // Avoid mismatched vector operand types, for better instruction selection.\n    if (N1Op0VT.isVector())\n      return false;\n\n    return true;\n  }\n  return false;\n}\n\nSDValue DAGCombiner::visitFCOPYSIGN(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  bool N0CFP = DAG.isConstantFPBuildVectorOrConstantFP(N0);\n  bool N1CFP = DAG.isConstantFPBuildVectorOrConstantFP(N1);\n  EVT VT = N->getValueType(0);\n\n  if (N0CFP && N1CFP) // Constant fold\n    return DAG.getNode(ISD::FCOPYSIGN, SDLoc(N), VT, N0, N1);\n\n  if (ConstantFPSDNode *N1C = isConstOrConstSplatFP(N->getOperand(1))) {\n    const APFloat &V = N1C->getValueAPF();\n    // copysign(x, c1) -> fabs(x)       iff ispos(c1)\n    // copysign(x, c1) -> fneg(fabs(x)) iff isneg(c1)\n    if (!V.isNegative()) {\n      if (!LegalOperations || TLI.isOperationLegal(ISD::FABS, VT))\n        return DAG.getNode(ISD::FABS, SDLoc(N), VT, N0);\n    } else {\n      if (!LegalOperations || TLI.isOperationLegal(ISD::FNEG, VT))\n        return DAG.getNode(ISD::FNEG, SDLoc(N), VT,\n                           DAG.getNode(ISD::FABS, SDLoc(N0), VT, N0));\n    }\n  }\n\n  // copysign(fabs(x), y) -> copysign(x, y)\n  // copysign(fneg(x), y) -> copysign(x, y)\n  // copysign(copysign(x,z), y) -> copysign(x, y)\n  if (N0.getOpcode() == ISD::FABS || N0.getOpcode() == ISD::FNEG ||\n      N0.getOpcode() == ISD::FCOPYSIGN)\n    return DAG.getNode(ISD::FCOPYSIGN, SDLoc(N), VT, N0.getOperand(0), N1);\n\n  // copysign(x, abs(y)) -> abs(x)\n  if (N1.getOpcode() == ISD::FABS)\n    return DAG.getNode(ISD::FABS, SDLoc(N), VT, N0);\n\n  // copysign(x, copysign(y,z)) -> copysign(x, z)\n  if (N1.getOpcode() == ISD::FCOPYSIGN)\n    return DAG.getNode(ISD::FCOPYSIGN, SDLoc(N), VT, N0, N1.getOperand(1));\n\n  // copysign(x, fp_extend(y)) -> copysign(x, y)\n  // copysign(x, fp_round(y)) -> copysign(x, y)\n  if (CanCombineFCOPYSIGN_EXTEND_ROUND(N))\n    return DAG.getNode(ISD::FCOPYSIGN, SDLoc(N), VT, N0, N1.getOperand(0));\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitFPOW(SDNode *N) {\n  ConstantFPSDNode *ExponentC = isConstOrConstSplatFP(N->getOperand(1));\n  if (!ExponentC)\n    return SDValue();\n  SelectionDAG::FlagInserter FlagsInserter(DAG, N);\n\n  // Try to convert x ** (1/3) into cube root.\n  // TODO: Handle the various flavors of long double.\n  // TODO: Since we're approximating, we don't need an exact 1/3 exponent.\n  //       Some range near 1/3 should be fine.\n  EVT VT = N->getValueType(0);\n  if ((VT == MVT::f32 && ExponentC->getValueAPF().isExactlyValue(1.0f/3.0f)) ||\n      (VT == MVT::f64 && ExponentC->getValueAPF().isExactlyValue(1.0/3.0))) {\n    // pow(-0.0, 1/3) = +0.0; cbrt(-0.0) = -0.0.\n    // pow(-inf, 1/3) = +inf; cbrt(-inf) = -inf.\n    // pow(-val, 1/3) =  nan; cbrt(-val) = -num.\n    // For regular numbers, rounding may cause the results to differ.\n    // Therefore, we require { nsz ninf nnan afn } for this transform.\n    // TODO: We could select out the special cases if we don't have nsz/ninf.\n    SDNodeFlags Flags = N->getFlags();\n    if (!Flags.hasNoSignedZeros() || !Flags.hasNoInfs() || !Flags.hasNoNaNs() ||\n        !Flags.hasApproximateFuncs())\n      return SDValue();\n\n    // Do not create a cbrt() libcall if the target does not have it, and do not\n    // turn a pow that has lowering support into a cbrt() libcall.\n    if (!DAG.getLibInfo().has(LibFunc_cbrt) ||\n        (!DAG.getTargetLoweringInfo().isOperationExpand(ISD::FPOW, VT) &&\n         DAG.getTargetLoweringInfo().isOperationExpand(ISD::FCBRT, VT)))\n      return SDValue();\n\n    return DAG.getNode(ISD::FCBRT, SDLoc(N), VT, N->getOperand(0));\n  }\n\n  // Try to convert x ** (1/4) and x ** (3/4) into square roots.\n  // x ** (1/2) is canonicalized to sqrt, so we do not bother with that case.\n  // TODO: This could be extended (using a target hook) to handle smaller\n  // power-of-2 fractional exponents.\n  bool ExponentIs025 = ExponentC->getValueAPF().isExactlyValue(0.25);\n  bool ExponentIs075 = ExponentC->getValueAPF().isExactlyValue(0.75);\n  if (ExponentIs025 || ExponentIs075) {\n    // pow(-0.0, 0.25) = +0.0; sqrt(sqrt(-0.0)) = -0.0.\n    // pow(-inf, 0.25) = +inf; sqrt(sqrt(-inf)) =  NaN.\n    // pow(-0.0, 0.75) = +0.0; sqrt(-0.0) * sqrt(sqrt(-0.0)) = +0.0.\n    // pow(-inf, 0.75) = +inf; sqrt(-inf) * sqrt(sqrt(-inf)) =  NaN.\n    // For regular numbers, rounding may cause the results to differ.\n    // Therefore, we require { nsz ninf afn } for this transform.\n    // TODO: We could select out the special cases if we don't have nsz/ninf.\n    SDNodeFlags Flags = N->getFlags();\n\n    // We only need no signed zeros for the 0.25 case.\n    if ((!Flags.hasNoSignedZeros() && ExponentIs025) || !Flags.hasNoInfs() ||\n        !Flags.hasApproximateFuncs())\n      return SDValue();\n\n    // Don't double the number of libcalls. We are trying to inline fast code.\n    if (!DAG.getTargetLoweringInfo().isOperationLegalOrCustom(ISD::FSQRT, VT))\n      return SDValue();\n\n    // Assume that libcalls are the smallest code.\n    // TODO: This restriction should probably be lifted for vectors.\n    if (ForCodeSize)\n      return SDValue();\n\n    // pow(X, 0.25) --> sqrt(sqrt(X))\n    SDLoc DL(N);\n    SDValue Sqrt = DAG.getNode(ISD::FSQRT, DL, VT, N->getOperand(0));\n    SDValue SqrtSqrt = DAG.getNode(ISD::FSQRT, DL, VT, Sqrt);\n    if (ExponentIs025)\n      return SqrtSqrt;\n    // pow(X, 0.75) --> sqrt(X) * sqrt(sqrt(X))\n    return DAG.getNode(ISD::FMUL, DL, VT, Sqrt, SqrtSqrt);\n  }\n\n  return SDValue();\n}\n\nstatic SDValue foldFPToIntToFP(SDNode *N, SelectionDAG &DAG,\n                               const TargetLowering &TLI) {\n  // This optimization is guarded by a function attribute because it may produce\n  // unexpected results. Ie, programs may be relying on the platform-specific\n  // undefined behavior when the float-to-int conversion overflows.\n  const Function &F = DAG.getMachineFunction().getFunction();\n  Attribute StrictOverflow = F.getFnAttribute(\"strict-float-cast-overflow\");\n  if (StrictOverflow.getValueAsString().equals(\"false\"))\n    return SDValue();\n\n  // We only do this if the target has legal ftrunc. Otherwise, we'd likely be\n  // replacing casts with a libcall. We also must be allowed to ignore -0.0\n  // because FTRUNC will return -0.0 for (-1.0, -0.0), but using integer\n  // conversions would return +0.0.\n  // FIXME: We should be able to use node-level FMF here.\n  // TODO: If strict math, should we use FABS (+ range check for signed cast)?\n  EVT VT = N->getValueType(0);\n  if (!TLI.isOperationLegal(ISD::FTRUNC, VT) ||\n      !DAG.getTarget().Options.NoSignedZerosFPMath)\n    return SDValue();\n\n  // fptosi/fptoui round towards zero, so converting from FP to integer and\n  // back is the same as an 'ftrunc': [us]itofp (fpto[us]i X) --> ftrunc X\n  SDValue N0 = N->getOperand(0);\n  if (N->getOpcode() == ISD::SINT_TO_FP && N0.getOpcode() == ISD::FP_TO_SINT &&\n      N0.getOperand(0).getValueType() == VT)\n    return DAG.getNode(ISD::FTRUNC, SDLoc(N), VT, N0.getOperand(0));\n\n  if (N->getOpcode() == ISD::UINT_TO_FP && N0.getOpcode() == ISD::FP_TO_UINT &&\n      N0.getOperand(0).getValueType() == VT)\n    return DAG.getNode(ISD::FTRUNC, SDLoc(N), VT, N0.getOperand(0));\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitSINT_TO_FP(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  EVT VT = N->getValueType(0);\n  EVT OpVT = N0.getValueType();\n\n  // [us]itofp(undef) = 0, because the result value is bounded.\n  if (N0.isUndef())\n    return DAG.getConstantFP(0.0, SDLoc(N), VT);\n\n  // fold (sint_to_fp c1) -> c1fp\n  if (DAG.isConstantIntBuildVectorOrConstantInt(N0) &&\n      // ...but only if the target supports immediate floating-point values\n      (!LegalOperations ||\n       TLI.isOperationLegalOrCustom(ISD::ConstantFP, VT)))\n    return DAG.getNode(ISD::SINT_TO_FP, SDLoc(N), VT, N0);\n\n  // If the input is a legal type, and SINT_TO_FP is not legal on this target,\n  // but UINT_TO_FP is legal on this target, try to convert.\n  if (!hasOperation(ISD::SINT_TO_FP, OpVT) &&\n      hasOperation(ISD::UINT_TO_FP, OpVT)) {\n    // If the sign bit is known to be zero, we can change this to UINT_TO_FP.\n    if (DAG.SignBitIsZero(N0))\n      return DAG.getNode(ISD::UINT_TO_FP, SDLoc(N), VT, N0);\n  }\n\n  // The next optimizations are desirable only if SELECT_CC can be lowered.\n  // fold (sint_to_fp (setcc x, y, cc)) -> (select (setcc x, y, cc), -1.0, 0.0)\n  if (N0.getOpcode() == ISD::SETCC && N0.getValueType() == MVT::i1 &&\n      !VT.isVector() &&\n      (!LegalOperations || TLI.isOperationLegalOrCustom(ISD::ConstantFP, VT))) {\n    SDLoc DL(N);\n    return DAG.getSelect(DL, VT, N0, DAG.getConstantFP(-1.0, DL, VT),\n                         DAG.getConstantFP(0.0, DL, VT));\n  }\n\n  // fold (sint_to_fp (zext (setcc x, y, cc))) ->\n  //      (select (setcc x, y, cc), 1.0, 0.0)\n  if (N0.getOpcode() == ISD::ZERO_EXTEND &&\n      N0.getOperand(0).getOpcode() == ISD::SETCC && !VT.isVector() &&\n      (!LegalOperations || TLI.isOperationLegalOrCustom(ISD::ConstantFP, VT))) {\n    SDLoc DL(N);\n    return DAG.getSelect(DL, VT, N0.getOperand(0),\n                         DAG.getConstantFP(1.0, DL, VT),\n                         DAG.getConstantFP(0.0, DL, VT));\n  }\n\n  if (SDValue FTrunc = foldFPToIntToFP(N, DAG, TLI))\n    return FTrunc;\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitUINT_TO_FP(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  EVT VT = N->getValueType(0);\n  EVT OpVT = N0.getValueType();\n\n  // [us]itofp(undef) = 0, because the result value is bounded.\n  if (N0.isUndef())\n    return DAG.getConstantFP(0.0, SDLoc(N), VT);\n\n  // fold (uint_to_fp c1) -> c1fp\n  if (DAG.isConstantIntBuildVectorOrConstantInt(N0) &&\n      // ...but only if the target supports immediate floating-point values\n      (!LegalOperations ||\n       TLI.isOperationLegalOrCustom(ISD::ConstantFP, VT)))\n    return DAG.getNode(ISD::UINT_TO_FP, SDLoc(N), VT, N0);\n\n  // If the input is a legal type, and UINT_TO_FP is not legal on this target,\n  // but SINT_TO_FP is legal on this target, try to convert.\n  if (!hasOperation(ISD::UINT_TO_FP, OpVT) &&\n      hasOperation(ISD::SINT_TO_FP, OpVT)) {\n    // If the sign bit is known to be zero, we can change this to SINT_TO_FP.\n    if (DAG.SignBitIsZero(N0))\n      return DAG.getNode(ISD::SINT_TO_FP, SDLoc(N), VT, N0);\n  }\n\n  // fold (uint_to_fp (setcc x, y, cc)) -> (select (setcc x, y, cc), 1.0, 0.0)\n  if (N0.getOpcode() == ISD::SETCC && !VT.isVector() &&\n      (!LegalOperations || TLI.isOperationLegalOrCustom(ISD::ConstantFP, VT))) {\n    SDLoc DL(N);\n    return DAG.getSelect(DL, VT, N0, DAG.getConstantFP(1.0, DL, VT),\n                         DAG.getConstantFP(0.0, DL, VT));\n  }\n\n  if (SDValue FTrunc = foldFPToIntToFP(N, DAG, TLI))\n    return FTrunc;\n\n  return SDValue();\n}\n\n// Fold (fp_to_{s/u}int ({s/u}int_to_fpx)) -> zext x, sext x, trunc x, or x\nstatic SDValue FoldIntToFPToInt(SDNode *N, SelectionDAG &DAG) {\n  SDValue N0 = N->getOperand(0);\n  EVT VT = N->getValueType(0);\n\n  if (N0.getOpcode() != ISD::UINT_TO_FP && N0.getOpcode() != ISD::SINT_TO_FP)\n    return SDValue();\n\n  SDValue Src = N0.getOperand(0);\n  EVT SrcVT = Src.getValueType();\n  bool IsInputSigned = N0.getOpcode() == ISD::SINT_TO_FP;\n  bool IsOutputSigned = N->getOpcode() == ISD::FP_TO_SINT;\n\n  // We can safely assume the conversion won't overflow the output range,\n  // because (for example) (uint8_t)18293.f is undefined behavior.\n\n  // Since we can assume the conversion won't overflow, our decision as to\n  // whether the input will fit in the float should depend on the minimum\n  // of the input range and output range.\n\n  // This means this is also safe for a signed input and unsigned output, since\n  // a negative input would lead to undefined behavior.\n  unsigned InputSize = (int)SrcVT.getScalarSizeInBits() - IsInputSigned;\n  unsigned OutputSize = (int)VT.getScalarSizeInBits() - IsOutputSigned;\n  unsigned ActualSize = std::min(InputSize, OutputSize);\n  const fltSemantics &sem = DAG.EVTToAPFloatSemantics(N0.getValueType());\n\n  // We can only fold away the float conversion if the input range can be\n  // represented exactly in the float range.\n  if (APFloat::semanticsPrecision(sem) >= ActualSize) {\n    if (VT.getScalarSizeInBits() > SrcVT.getScalarSizeInBits()) {\n      unsigned ExtOp = IsInputSigned && IsOutputSigned ? ISD::SIGN_EXTEND\n                                                       : ISD::ZERO_EXTEND;\n      return DAG.getNode(ExtOp, SDLoc(N), VT, Src);\n    }\n    if (VT.getScalarSizeInBits() < SrcVT.getScalarSizeInBits())\n      return DAG.getNode(ISD::TRUNCATE, SDLoc(N), VT, Src);\n    return DAG.getBitcast(VT, Src);\n  }\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitFP_TO_SINT(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  EVT VT = N->getValueType(0);\n\n  // fold (fp_to_sint undef) -> undef\n  if (N0.isUndef())\n    return DAG.getUNDEF(VT);\n\n  // fold (fp_to_sint c1fp) -> c1\n  if (DAG.isConstantFPBuildVectorOrConstantFP(N0))\n    return DAG.getNode(ISD::FP_TO_SINT, SDLoc(N), VT, N0);\n\n  return FoldIntToFPToInt(N, DAG);\n}\n\nSDValue DAGCombiner::visitFP_TO_UINT(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  EVT VT = N->getValueType(0);\n\n  // fold (fp_to_uint undef) -> undef\n  if (N0.isUndef())\n    return DAG.getUNDEF(VT);\n\n  // fold (fp_to_uint c1fp) -> c1\n  if (DAG.isConstantFPBuildVectorOrConstantFP(N0))\n    return DAG.getNode(ISD::FP_TO_UINT, SDLoc(N), VT, N0);\n\n  return FoldIntToFPToInt(N, DAG);\n}\n\nSDValue DAGCombiner::visitFP_ROUND(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  ConstantFPSDNode *N0CFP = dyn_cast<ConstantFPSDNode>(N0);\n  EVT VT = N->getValueType(0);\n\n  // fold (fp_round c1fp) -> c1fp\n  if (N0CFP)\n    return DAG.getNode(ISD::FP_ROUND, SDLoc(N), VT, N0, N1);\n\n  // fold (fp_round (fp_extend x)) -> x\n  if (N0.getOpcode() == ISD::FP_EXTEND && VT == N0.getOperand(0).getValueType())\n    return N0.getOperand(0);\n\n  // fold (fp_round (fp_round x)) -> (fp_round x)\n  if (N0.getOpcode() == ISD::FP_ROUND) {\n    const bool NIsTrunc = N->getConstantOperandVal(1) == 1;\n    const bool N0IsTrunc = N0.getConstantOperandVal(1) == 1;\n\n    // Skip this folding if it results in an fp_round from f80 to f16.\n    //\n    // f80 to f16 always generates an expensive (and as yet, unimplemented)\n    // libcall to __truncxfhf2 instead of selecting native f16 conversion\n    // instructions from f32 or f64.  Moreover, the first (value-preserving)\n    // fp_round from f80 to either f32 or f64 may become a NOP in platforms like\n    // x86.\n    if (N0.getOperand(0).getValueType() == MVT::f80 && VT == MVT::f16)\n      return SDValue();\n\n    // If the first fp_round isn't a value preserving truncation, it might\n    // introduce a tie in the second fp_round, that wouldn't occur in the\n    // single-step fp_round we want to fold to.\n    // In other words, double rounding isn't the same as rounding.\n    // Also, this is a value preserving truncation iff both fp_round's are.\n    if (DAG.getTarget().Options.UnsafeFPMath || N0IsTrunc) {\n      SDLoc DL(N);\n      return DAG.getNode(ISD::FP_ROUND, DL, VT, N0.getOperand(0),\n                         DAG.getIntPtrConstant(NIsTrunc && N0IsTrunc, DL));\n    }\n  }\n\n  // fold (fp_round (copysign X, Y)) -> (copysign (fp_round X), Y)\n  if (N0.getOpcode() == ISD::FCOPYSIGN && N0.getNode()->hasOneUse()) {\n    SDValue Tmp = DAG.getNode(ISD::FP_ROUND, SDLoc(N0), VT,\n                              N0.getOperand(0), N1);\n    AddToWorklist(Tmp.getNode());\n    return DAG.getNode(ISD::FCOPYSIGN, SDLoc(N), VT,\n                       Tmp, N0.getOperand(1));\n  }\n\n  if (SDValue NewVSel = matchVSelectOpSizesWithSetCC(N))\n    return NewVSel;\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitFP_EXTEND(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  EVT VT = N->getValueType(0);\n\n  // If this is fp_round(fpextend), don't fold it, allow ourselves to be folded.\n  if (N->hasOneUse() &&\n      N->use_begin()->getOpcode() == ISD::FP_ROUND)\n    return SDValue();\n\n  // fold (fp_extend c1fp) -> c1fp\n  if (DAG.isConstantFPBuildVectorOrConstantFP(N0))\n    return DAG.getNode(ISD::FP_EXTEND, SDLoc(N), VT, N0);\n\n  // fold (fp_extend (fp16_to_fp op)) -> (fp16_to_fp op)\n  if (N0.getOpcode() == ISD::FP16_TO_FP &&\n      TLI.getOperationAction(ISD::FP16_TO_FP, VT) == TargetLowering::Legal)\n    return DAG.getNode(ISD::FP16_TO_FP, SDLoc(N), VT, N0.getOperand(0));\n\n  // Turn fp_extend(fp_round(X, 1)) -> x since the fp_round doesn't affect the\n  // value of X.\n  if (N0.getOpcode() == ISD::FP_ROUND\n      && N0.getConstantOperandVal(1) == 1) {\n    SDValue In = N0.getOperand(0);\n    if (In.getValueType() == VT) return In;\n    if (VT.bitsLT(In.getValueType()))\n      return DAG.getNode(ISD::FP_ROUND, SDLoc(N), VT,\n                         In, N0.getOperand(1));\n    return DAG.getNode(ISD::FP_EXTEND, SDLoc(N), VT, In);\n  }\n\n  // fold (fpext (load x)) -> (fpext (fptrunc (extload x)))\n  if (ISD::isNormalLoad(N0.getNode()) && N0.hasOneUse() &&\n       TLI.isLoadExtLegal(ISD::EXTLOAD, VT, N0.getValueType())) {\n    LoadSDNode *LN0 = cast<LoadSDNode>(N0);\n    SDValue ExtLoad = DAG.getExtLoad(ISD::EXTLOAD, SDLoc(N), VT,\n                                     LN0->getChain(),\n                                     LN0->getBasePtr(), N0.getValueType(),\n                                     LN0->getMemOperand());\n    CombineTo(N, ExtLoad);\n    CombineTo(N0.getNode(),\n              DAG.getNode(ISD::FP_ROUND, SDLoc(N0),\n                          N0.getValueType(), ExtLoad,\n                          DAG.getIntPtrConstant(1, SDLoc(N0))),\n              ExtLoad.getValue(1));\n    return SDValue(N, 0);   // Return N so it doesn't get rechecked!\n  }\n\n  if (SDValue NewVSel = matchVSelectOpSizesWithSetCC(N))\n    return NewVSel;\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitFCEIL(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  EVT VT = N->getValueType(0);\n\n  // fold (fceil c1) -> fceil(c1)\n  if (DAG.isConstantFPBuildVectorOrConstantFP(N0))\n    return DAG.getNode(ISD::FCEIL, SDLoc(N), VT, N0);\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitFTRUNC(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  EVT VT = N->getValueType(0);\n\n  // fold (ftrunc c1) -> ftrunc(c1)\n  if (DAG.isConstantFPBuildVectorOrConstantFP(N0))\n    return DAG.getNode(ISD::FTRUNC, SDLoc(N), VT, N0);\n\n  // fold ftrunc (known rounded int x) -> x\n  // ftrunc is a part of fptosi/fptoui expansion on some targets, so this is\n  // likely to be generated to extract integer from a rounded floating value.\n  switch (N0.getOpcode()) {\n  default: break;\n  case ISD::FRINT:\n  case ISD::FTRUNC:\n  case ISD::FNEARBYINT:\n  case ISD::FFLOOR:\n  case ISD::FCEIL:\n    return N0;\n  }\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitFFLOOR(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  EVT VT = N->getValueType(0);\n\n  // fold (ffloor c1) -> ffloor(c1)\n  if (DAG.isConstantFPBuildVectorOrConstantFP(N0))\n    return DAG.getNode(ISD::FFLOOR, SDLoc(N), VT, N0);\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitFNEG(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  EVT VT = N->getValueType(0);\n  SelectionDAG::FlagInserter FlagsInserter(DAG, N);\n\n  // Constant fold FNEG.\n  if (DAG.isConstantFPBuildVectorOrConstantFP(N0))\n    return DAG.getNode(ISD::FNEG, SDLoc(N), VT, N0);\n\n  if (SDValue NegN0 =\n          TLI.getNegatedExpression(N0, DAG, LegalOperations, ForCodeSize))\n    return NegN0;\n\n  // -(X-Y) -> (Y-X) is unsafe because when X==Y, -0.0 != +0.0\n  // FIXME: This is duplicated in getNegatibleCost, but getNegatibleCost doesn't\n  // know it was called from a context with a nsz flag if the input fsub does\n  // not.\n  if (N0.getOpcode() == ISD::FSUB &&\n      (DAG.getTarget().Options.NoSignedZerosFPMath ||\n       N->getFlags().hasNoSignedZeros()) && N0.hasOneUse()) {\n    return DAG.getNode(ISD::FSUB, SDLoc(N), VT, N0.getOperand(1),\n                       N0.getOperand(0));\n  }\n\n  if (SDValue Cast = foldSignChangeInBitcast(N))\n    return Cast;\n\n  return SDValue();\n}\n\nstatic SDValue visitFMinMax(SelectionDAG &DAG, SDNode *N,\n                            APFloat (*Op)(const APFloat &, const APFloat &)) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  EVT VT = N->getValueType(0);\n  const ConstantFPSDNode *N0CFP = isConstOrConstSplatFP(N0);\n  const ConstantFPSDNode *N1CFP = isConstOrConstSplatFP(N1);\n  const SDNodeFlags Flags = N->getFlags();\n  unsigned Opc = N->getOpcode();\n  bool PropagatesNaN = Opc == ISD::FMINIMUM || Opc == ISD::FMAXIMUM;\n  bool IsMin = Opc == ISD::FMINNUM || Opc == ISD::FMINIMUM;\n  SelectionDAG::FlagInserter FlagsInserter(DAG, N);\n\n  if (N0CFP && N1CFP) {\n    const APFloat &C0 = N0CFP->getValueAPF();\n    const APFloat &C1 = N1CFP->getValueAPF();\n    return DAG.getConstantFP(Op(C0, C1), SDLoc(N), VT);\n  }\n\n  // Canonicalize to constant on RHS.\n  if (DAG.isConstantFPBuildVectorOrConstantFP(N0) &&\n      !DAG.isConstantFPBuildVectorOrConstantFP(N1))\n    return DAG.getNode(N->getOpcode(), SDLoc(N), VT, N1, N0);\n\n  if (N1CFP) {\n    const APFloat &AF = N1CFP->getValueAPF();\n\n    // minnum(X, nan) -> X\n    // maxnum(X, nan) -> X\n    // minimum(X, nan) -> nan\n    // maximum(X, nan) -> nan\n    if (AF.isNaN())\n      return PropagatesNaN ? N->getOperand(1) : N->getOperand(0);\n\n    // In the following folds, inf can be replaced with the largest finite\n    // float, if the ninf flag is set.\n    if (AF.isInfinity() || (Flags.hasNoInfs() && AF.isLargest())) {\n      // minnum(X, -inf) -> -inf\n      // maxnum(X, +inf) -> +inf\n      // minimum(X, -inf) -> -inf if nnan\n      // maximum(X, +inf) -> +inf if nnan\n      if (IsMin == AF.isNegative() && (!PropagatesNaN || Flags.hasNoNaNs()))\n        return N->getOperand(1);\n\n      // minnum(X, +inf) -> X if nnan\n      // maxnum(X, -inf) -> X if nnan\n      // minimum(X, +inf) -> X\n      // maximum(X, -inf) -> X\n      if (IsMin != AF.isNegative() && (PropagatesNaN || Flags.hasNoNaNs()))\n        return N->getOperand(0);\n    }\n  }\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitFMINNUM(SDNode *N) {\n  return visitFMinMax(DAG, N, minnum);\n}\n\nSDValue DAGCombiner::visitFMAXNUM(SDNode *N) {\n  return visitFMinMax(DAG, N, maxnum);\n}\n\nSDValue DAGCombiner::visitFMINIMUM(SDNode *N) {\n  return visitFMinMax(DAG, N, minimum);\n}\n\nSDValue DAGCombiner::visitFMAXIMUM(SDNode *N) {\n  return visitFMinMax(DAG, N, maximum);\n}\n\nSDValue DAGCombiner::visitFABS(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  EVT VT = N->getValueType(0);\n\n  // fold (fabs c1) -> fabs(c1)\n  if (DAG.isConstantFPBuildVectorOrConstantFP(N0))\n    return DAG.getNode(ISD::FABS, SDLoc(N), VT, N0);\n\n  // fold (fabs (fabs x)) -> (fabs x)\n  if (N0.getOpcode() == ISD::FABS)\n    return N->getOperand(0);\n\n  // fold (fabs (fneg x)) -> (fabs x)\n  // fold (fabs (fcopysign x, y)) -> (fabs x)\n  if (N0.getOpcode() == ISD::FNEG || N0.getOpcode() == ISD::FCOPYSIGN)\n    return DAG.getNode(ISD::FABS, SDLoc(N), VT, N0.getOperand(0));\n\n  if (SDValue Cast = foldSignChangeInBitcast(N))\n    return Cast;\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitBRCOND(SDNode *N) {\n  SDValue Chain = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  SDValue N2 = N->getOperand(2);\n\n  // BRCOND(FREEZE(cond)) is equivalent to BRCOND(cond) (both are\n  // nondeterministic jumps).\n  if (N1->getOpcode() == ISD::FREEZE && N1.hasOneUse()) {\n    return DAG.getNode(ISD::BRCOND, SDLoc(N), MVT::Other, Chain,\n                       N1->getOperand(0), N2);\n  }\n\n  // If N is a constant we could fold this into a fallthrough or unconditional\n  // branch. However that doesn't happen very often in normal code, because\n  // Instcombine/SimplifyCFG should have handled the available opportunities.\n  // If we did this folding here, it would be necessary to update the\n  // MachineBasicBlock CFG, which is awkward.\n\n  // fold a brcond with a setcc condition into a BR_CC node if BR_CC is legal\n  // on the target.\n  if (N1.getOpcode() == ISD::SETCC &&\n      TLI.isOperationLegalOrCustom(ISD::BR_CC,\n                                   N1.getOperand(0).getValueType())) {\n    return DAG.getNode(ISD::BR_CC, SDLoc(N), MVT::Other,\n                       Chain, N1.getOperand(2),\n                       N1.getOperand(0), N1.getOperand(1), N2);\n  }\n\n  if (N1.hasOneUse()) {\n    // rebuildSetCC calls visitXor which may change the Chain when there is a\n    // STRICT_FSETCC/STRICT_FSETCCS involved. Use a handle to track changes.\n    HandleSDNode ChainHandle(Chain);\n    if (SDValue NewN1 = rebuildSetCC(N1))\n      return DAG.getNode(ISD::BRCOND, SDLoc(N), MVT::Other,\n                         ChainHandle.getValue(), NewN1, N2);\n  }\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::rebuildSetCC(SDValue N) {\n  if (N.getOpcode() == ISD::SRL ||\n      (N.getOpcode() == ISD::TRUNCATE &&\n       (N.getOperand(0).hasOneUse() &&\n        N.getOperand(0).getOpcode() == ISD::SRL))) {\n    // Look pass the truncate.\n    if (N.getOpcode() == ISD::TRUNCATE)\n      N = N.getOperand(0);\n\n    // Match this pattern so that we can generate simpler code:\n    //\n    //   %a = ...\n    //   %b = and i32 %a, 2\n    //   %c = srl i32 %b, 1\n    //   brcond i32 %c ...\n    //\n    // into\n    //\n    //   %a = ...\n    //   %b = and i32 %a, 2\n    //   %c = setcc eq %b, 0\n    //   brcond %c ...\n    //\n    // This applies only when the AND constant value has one bit set and the\n    // SRL constant is equal to the log2 of the AND constant. The back-end is\n    // smart enough to convert the result into a TEST/JMP sequence.\n    SDValue Op0 = N.getOperand(0);\n    SDValue Op1 = N.getOperand(1);\n\n    if (Op0.getOpcode() == ISD::AND && Op1.getOpcode() == ISD::Constant) {\n      SDValue AndOp1 = Op0.getOperand(1);\n\n      if (AndOp1.getOpcode() == ISD::Constant) {\n        const APInt &AndConst = cast<ConstantSDNode>(AndOp1)->getAPIntValue();\n\n        if (AndConst.isPowerOf2() &&\n            cast<ConstantSDNode>(Op1)->getAPIntValue() == AndConst.logBase2()) {\n          SDLoc DL(N);\n          return DAG.getSetCC(DL, getSetCCResultType(Op0.getValueType()),\n                              Op0, DAG.getConstant(0, DL, Op0.getValueType()),\n                              ISD::SETNE);\n        }\n      }\n    }\n  }\n\n  // Transform (brcond (xor x, y)) -> (brcond (setcc, x, y, ne))\n  // Transform (brcond (xor (xor x, y), -1)) -> (brcond (setcc, x, y, eq))\n  if (N.getOpcode() == ISD::XOR) {\n    // Because we may call this on a speculatively constructed\n    // SimplifiedSetCC Node, we need to simplify this node first.\n    // Ideally this should be folded into SimplifySetCC and not\n    // here. For now, grab a handle to N so we don't lose it from\n    // replacements interal to the visit.\n    HandleSDNode XORHandle(N);\n    while (N.getOpcode() == ISD::XOR) {\n      SDValue Tmp = visitXOR(N.getNode());\n      // No simplification done.\n      if (!Tmp.getNode())\n        break;\n      // Returning N is form in-visit replacement that may invalidated\n      // N. Grab value from Handle.\n      if (Tmp.getNode() == N.getNode())\n        N = XORHandle.getValue();\n      else // Node simplified. Try simplifying again.\n        N = Tmp;\n    }\n\n    if (N.getOpcode() != ISD::XOR)\n      return N;\n\n    SDValue Op0 = N->getOperand(0);\n    SDValue Op1 = N->getOperand(1);\n\n    if (Op0.getOpcode() != ISD::SETCC && Op1.getOpcode() != ISD::SETCC) {\n      bool Equal = false;\n      // (brcond (xor (xor x, y), -1)) -> (brcond (setcc x, y, eq))\n      if (isBitwiseNot(N) && Op0.hasOneUse() && Op0.getOpcode() == ISD::XOR &&\n          Op0.getValueType() == MVT::i1) {\n        N = Op0;\n        Op0 = N->getOperand(0);\n        Op1 = N->getOperand(1);\n        Equal = true;\n      }\n\n      EVT SetCCVT = N.getValueType();\n      if (LegalTypes)\n        SetCCVT = getSetCCResultType(SetCCVT);\n      // Replace the uses of XOR with SETCC\n      return DAG.getSetCC(SDLoc(N), SetCCVT, Op0, Op1,\n                          Equal ? ISD::SETEQ : ISD::SETNE);\n    }\n  }\n\n  return SDValue();\n}\n\n// Operand List for BR_CC: Chain, CondCC, CondLHS, CondRHS, DestBB.\n//\nSDValue DAGCombiner::visitBR_CC(SDNode *N) {\n  CondCodeSDNode *CC = cast<CondCodeSDNode>(N->getOperand(1));\n  SDValue CondLHS = N->getOperand(2), CondRHS = N->getOperand(3);\n\n  // If N is a constant we could fold this into a fallthrough or unconditional\n  // branch. However that doesn't happen very often in normal code, because\n  // Instcombine/SimplifyCFG should have handled the available opportunities.\n  // If we did this folding here, it would be necessary to update the\n  // MachineBasicBlock CFG, which is awkward.\n\n  // Use SimplifySetCC to simplify SETCC's.\n  SDValue Simp = SimplifySetCC(getSetCCResultType(CondLHS.getValueType()),\n                               CondLHS, CondRHS, CC->get(), SDLoc(N),\n                               false);\n  if (Simp.getNode()) AddToWorklist(Simp.getNode());\n\n  // fold to a simpler setcc\n  if (Simp.getNode() && Simp.getOpcode() == ISD::SETCC)\n    return DAG.getNode(ISD::BR_CC, SDLoc(N), MVT::Other,\n                       N->getOperand(0), Simp.getOperand(2),\n                       Simp.getOperand(0), Simp.getOperand(1),\n                       N->getOperand(4));\n\n  return SDValue();\n}\n\nstatic bool getCombineLoadStoreParts(SDNode *N, unsigned Inc, unsigned Dec,\n                                     bool &IsLoad, bool &IsMasked, SDValue &Ptr,\n                                     const TargetLowering &TLI) {\n  if (LoadSDNode *LD = dyn_cast<LoadSDNode>(N)) {\n    if (LD->isIndexed())\n      return false;\n    EVT VT = LD->getMemoryVT();\n    if (!TLI.isIndexedLoadLegal(Inc, VT) && !TLI.isIndexedLoadLegal(Dec, VT))\n      return false;\n    Ptr = LD->getBasePtr();\n  } else if (StoreSDNode *ST = dyn_cast<StoreSDNode>(N)) {\n    if (ST->isIndexed())\n      return false;\n    EVT VT = ST->getMemoryVT();\n    if (!TLI.isIndexedStoreLegal(Inc, VT) && !TLI.isIndexedStoreLegal(Dec, VT))\n      return false;\n    Ptr = ST->getBasePtr();\n    IsLoad = false;\n  } else if (MaskedLoadSDNode *LD = dyn_cast<MaskedLoadSDNode>(N)) {\n    if (LD->isIndexed())\n      return false;\n    EVT VT = LD->getMemoryVT();\n    if (!TLI.isIndexedMaskedLoadLegal(Inc, VT) &&\n        !TLI.isIndexedMaskedLoadLegal(Dec, VT))\n      return false;\n    Ptr = LD->getBasePtr();\n    IsMasked = true;\n  } else if (MaskedStoreSDNode *ST = dyn_cast<MaskedStoreSDNode>(N)) {\n    if (ST->isIndexed())\n      return false;\n    EVT VT = ST->getMemoryVT();\n    if (!TLI.isIndexedMaskedStoreLegal(Inc, VT) &&\n        !TLI.isIndexedMaskedStoreLegal(Dec, VT))\n      return false;\n    Ptr = ST->getBasePtr();\n    IsLoad = false;\n    IsMasked = true;\n  } else {\n    return false;\n  }\n  return true;\n}\n\n/// Try turning a load/store into a pre-indexed load/store when the base\n/// pointer is an add or subtract and it has other uses besides the load/store.\n/// After the transformation, the new indexed load/store has effectively folded\n/// the add/subtract in and all of its other uses are redirected to the\n/// new load/store.\nbool DAGCombiner::CombineToPreIndexedLoadStore(SDNode *N) {\n  if (Level < AfterLegalizeDAG)\n    return false;\n\n  bool IsLoad = true;\n  bool IsMasked = false;\n  SDValue Ptr;\n  if (!getCombineLoadStoreParts(N, ISD::PRE_INC, ISD::PRE_DEC, IsLoad, IsMasked,\n                                Ptr, TLI))\n    return false;\n\n  // If the pointer is not an add/sub, or if it doesn't have multiple uses, bail\n  // out.  There is no reason to make this a preinc/predec.\n  if ((Ptr.getOpcode() != ISD::ADD && Ptr.getOpcode() != ISD::SUB) ||\n      Ptr.getNode()->hasOneUse())\n    return false;\n\n  // Ask the target to do addressing mode selection.\n  SDValue BasePtr;\n  SDValue Offset;\n  ISD::MemIndexedMode AM = ISD::UNINDEXED;\n  if (!TLI.getPreIndexedAddressParts(N, BasePtr, Offset, AM, DAG))\n    return false;\n\n  // Backends without true r+i pre-indexed forms may need to pass a\n  // constant base with a variable offset so that constant coercion\n  // will work with the patterns in canonical form.\n  bool Swapped = false;\n  if (isa<ConstantSDNode>(BasePtr)) {\n    std::swap(BasePtr, Offset);\n    Swapped = true;\n  }\n\n  // Don't create a indexed load / store with zero offset.\n  if (isNullConstant(Offset))\n    return false;\n\n  // Try turning it into a pre-indexed load / store except when:\n  // 1) The new base ptr is a frame index.\n  // 2) If N is a store and the new base ptr is either the same as or is a\n  //    predecessor of the value being stored.\n  // 3) Another use of old base ptr is a predecessor of N. If ptr is folded\n  //    that would create a cycle.\n  // 4) All uses are load / store ops that use it as old base ptr.\n\n  // Check #1.  Preinc'ing a frame index would require copying the stack pointer\n  // (plus the implicit offset) to a register to preinc anyway.\n  if (isa<FrameIndexSDNode>(BasePtr) || isa<RegisterSDNode>(BasePtr))\n    return false;\n\n  // Check #2.\n  if (!IsLoad) {\n    SDValue Val = IsMasked ? cast<MaskedStoreSDNode>(N)->getValue()\n                           : cast<StoreSDNode>(N)->getValue();\n\n    // Would require a copy.\n    if (Val == BasePtr)\n      return false;\n\n    // Would create a cycle.\n    if (Val == Ptr || Ptr->isPredecessorOf(Val.getNode()))\n      return false;\n  }\n\n  // Caches for hasPredecessorHelper.\n  SmallPtrSet<const SDNode *, 32> Visited;\n  SmallVector<const SDNode *, 16> Worklist;\n  Worklist.push_back(N);\n\n  // If the offset is a constant, there may be other adds of constants that\n  // can be folded with this one. We should do this to avoid having to keep\n  // a copy of the original base pointer.\n  SmallVector<SDNode *, 16> OtherUses;\n  if (isa<ConstantSDNode>(Offset))\n    for (SDNode::use_iterator UI = BasePtr.getNode()->use_begin(),\n                              UE = BasePtr.getNode()->use_end();\n         UI != UE; ++UI) {\n      SDUse &Use = UI.getUse();\n      // Skip the use that is Ptr and uses of other results from BasePtr's\n      // node (important for nodes that return multiple results).\n      if (Use.getUser() == Ptr.getNode() || Use != BasePtr)\n        continue;\n\n      if (SDNode::hasPredecessorHelper(Use.getUser(), Visited, Worklist))\n        continue;\n\n      if (Use.getUser()->getOpcode() != ISD::ADD &&\n          Use.getUser()->getOpcode() != ISD::SUB) {\n        OtherUses.clear();\n        break;\n      }\n\n      SDValue Op1 = Use.getUser()->getOperand((UI.getOperandNo() + 1) & 1);\n      if (!isa<ConstantSDNode>(Op1)) {\n        OtherUses.clear();\n        break;\n      }\n\n      // FIXME: In some cases, we can be smarter about this.\n      if (Op1.getValueType() != Offset.getValueType()) {\n        OtherUses.clear();\n        break;\n      }\n\n      OtherUses.push_back(Use.getUser());\n    }\n\n  if (Swapped)\n    std::swap(BasePtr, Offset);\n\n  // Now check for #3 and #4.\n  bool RealUse = false;\n\n  for (SDNode *Use : Ptr.getNode()->uses()) {\n    if (Use == N)\n      continue;\n    if (SDNode::hasPredecessorHelper(Use, Visited, Worklist))\n      return false;\n\n    // If Ptr may be folded in addressing mode of other use, then it's\n    // not profitable to do this transformation.\n    if (!canFoldInAddressingMode(Ptr.getNode(), Use, DAG, TLI))\n      RealUse = true;\n  }\n\n  if (!RealUse)\n    return false;\n\n  SDValue Result;\n  if (!IsMasked) {\n    if (IsLoad)\n      Result = DAG.getIndexedLoad(SDValue(N, 0), SDLoc(N), BasePtr, Offset, AM);\n    else\n      Result =\n          DAG.getIndexedStore(SDValue(N, 0), SDLoc(N), BasePtr, Offset, AM);\n  } else {\n    if (IsLoad)\n      Result = DAG.getIndexedMaskedLoad(SDValue(N, 0), SDLoc(N), BasePtr,\n                                        Offset, AM);\n    else\n      Result = DAG.getIndexedMaskedStore(SDValue(N, 0), SDLoc(N), BasePtr,\n                                         Offset, AM);\n  }\n  ++PreIndexedNodes;\n  ++NodesCombined;\n  LLVM_DEBUG(dbgs() << \"\\nReplacing.4 \"; N->dump(&DAG); dbgs() << \"\\nWith: \";\n             Result.getNode()->dump(&DAG); dbgs() << '\\n');\n  WorklistRemover DeadNodes(*this);\n  if (IsLoad) {\n    DAG.ReplaceAllUsesOfValueWith(SDValue(N, 0), Result.getValue(0));\n    DAG.ReplaceAllUsesOfValueWith(SDValue(N, 1), Result.getValue(2));\n  } else {\n    DAG.ReplaceAllUsesOfValueWith(SDValue(N, 0), Result.getValue(1));\n  }\n\n  // Finally, since the node is now dead, remove it from the graph.\n  deleteAndRecombine(N);\n\n  if (Swapped)\n    std::swap(BasePtr, Offset);\n\n  // Replace other uses of BasePtr that can be updated to use Ptr\n  for (unsigned i = 0, e = OtherUses.size(); i != e; ++i) {\n    unsigned OffsetIdx = 1;\n    if (OtherUses[i]->getOperand(OffsetIdx).getNode() == BasePtr.getNode())\n      OffsetIdx = 0;\n    assert(OtherUses[i]->getOperand(!OffsetIdx).getNode() ==\n           BasePtr.getNode() && \"Expected BasePtr operand\");\n\n    // We need to replace ptr0 in the following expression:\n    //   x0 * offset0 + y0 * ptr0 = t0\n    // knowing that\n    //   x1 * offset1 + y1 * ptr0 = t1 (the indexed load/store)\n    //\n    // where x0, x1, y0 and y1 in {-1, 1} are given by the types of the\n    // indexed load/store and the expression that needs to be re-written.\n    //\n    // Therefore, we have:\n    //   t0 = (x0 * offset0 - x1 * y0 * y1 *offset1) + (y0 * y1) * t1\n\n    auto *CN = cast<ConstantSDNode>(OtherUses[i]->getOperand(OffsetIdx));\n    const APInt &Offset0 = CN->getAPIntValue();\n    const APInt &Offset1 = cast<ConstantSDNode>(Offset)->getAPIntValue();\n    int X0 = (OtherUses[i]->getOpcode() == ISD::SUB && OffsetIdx == 1) ? -1 : 1;\n    int Y0 = (OtherUses[i]->getOpcode() == ISD::SUB && OffsetIdx == 0) ? -1 : 1;\n    int X1 = (AM == ISD::PRE_DEC && !Swapped) ? -1 : 1;\n    int Y1 = (AM == ISD::PRE_DEC && Swapped) ? -1 : 1;\n\n    unsigned Opcode = (Y0 * Y1 < 0) ? ISD::SUB : ISD::ADD;\n\n    APInt CNV = Offset0;\n    if (X0 < 0) CNV = -CNV;\n    if (X1 * Y0 * Y1 < 0) CNV = CNV + Offset1;\n    else CNV = CNV - Offset1;\n\n    SDLoc DL(OtherUses[i]);\n\n    // We can now generate the new expression.\n    SDValue NewOp1 = DAG.getConstant(CNV, DL, CN->getValueType(0));\n    SDValue NewOp2 = Result.getValue(IsLoad ? 1 : 0);\n\n    SDValue NewUse = DAG.getNode(Opcode,\n                                 DL,\n                                 OtherUses[i]->getValueType(0), NewOp1, NewOp2);\n    DAG.ReplaceAllUsesOfValueWith(SDValue(OtherUses[i], 0), NewUse);\n    deleteAndRecombine(OtherUses[i]);\n  }\n\n  // Replace the uses of Ptr with uses of the updated base value.\n  DAG.ReplaceAllUsesOfValueWith(Ptr, Result.getValue(IsLoad ? 1 : 0));\n  deleteAndRecombine(Ptr.getNode());\n  AddToWorklist(Result.getNode());\n\n  return true;\n}\n\nstatic bool shouldCombineToPostInc(SDNode *N, SDValue Ptr, SDNode *PtrUse,\n                                   SDValue &BasePtr, SDValue &Offset,\n                                   ISD::MemIndexedMode &AM,\n                                   SelectionDAG &DAG,\n                                   const TargetLowering &TLI) {\n  if (PtrUse == N ||\n      (PtrUse->getOpcode() != ISD::ADD && PtrUse->getOpcode() != ISD::SUB))\n    return false;\n\n  if (!TLI.getPostIndexedAddressParts(N, PtrUse, BasePtr, Offset, AM, DAG))\n    return false;\n\n  // Don't create a indexed load / store with zero offset.\n  if (isNullConstant(Offset))\n    return false;\n\n  if (isa<FrameIndexSDNode>(BasePtr) || isa<RegisterSDNode>(BasePtr))\n    return false;\n\n  SmallPtrSet<const SDNode *, 32> Visited;\n  for (SDNode *Use : BasePtr.getNode()->uses()) {\n    if (Use == Ptr.getNode())\n      continue;\n\n    // No if there's a later user which could perform the index instead.\n    if (isa<MemSDNode>(Use)) {\n      bool IsLoad = true;\n      bool IsMasked = false;\n      SDValue OtherPtr;\n      if (getCombineLoadStoreParts(Use, ISD::POST_INC, ISD::POST_DEC, IsLoad,\n                                   IsMasked, OtherPtr, TLI)) {\n        SmallVector<const SDNode *, 2> Worklist;\n        Worklist.push_back(Use);\n        if (SDNode::hasPredecessorHelper(N, Visited, Worklist))\n          return false;\n      }\n    }\n\n    // If all the uses are load / store addresses, then don't do the\n    // transformation.\n    if (Use->getOpcode() == ISD::ADD || Use->getOpcode() == ISD::SUB) {\n      for (SDNode *UseUse : Use->uses())\n        if (canFoldInAddressingMode(Use, UseUse, DAG, TLI))\n          return false;\n    }\n  }\n  return true;\n}\n\nstatic SDNode *getPostIndexedLoadStoreOp(SDNode *N, bool &IsLoad,\n                                         bool &IsMasked, SDValue &Ptr,\n                                         SDValue &BasePtr, SDValue &Offset,\n                                         ISD::MemIndexedMode &AM,\n                                         SelectionDAG &DAG,\n                                         const TargetLowering &TLI) {\n  if (!getCombineLoadStoreParts(N, ISD::POST_INC, ISD::POST_DEC, IsLoad,\n                                IsMasked, Ptr, TLI) ||\n      Ptr.getNode()->hasOneUse())\n    return nullptr;\n\n  // Try turning it into a post-indexed load / store except when\n  // 1) All uses are load / store ops that use it as base ptr (and\n  //    it may be folded as addressing mmode).\n  // 2) Op must be independent of N, i.e. Op is neither a predecessor\n  //    nor a successor of N. Otherwise, if Op is folded that would\n  //    create a cycle.\n  for (SDNode *Op : Ptr->uses()) {\n    // Check for #1.\n    if (!shouldCombineToPostInc(N, Ptr, Op, BasePtr, Offset, AM, DAG, TLI))\n      continue;\n\n    // Check for #2.\n    SmallPtrSet<const SDNode *, 32> Visited;\n    SmallVector<const SDNode *, 8> Worklist;\n    // Ptr is predecessor to both N and Op.\n    Visited.insert(Ptr.getNode());\n    Worklist.push_back(N);\n    Worklist.push_back(Op);\n    if (!SDNode::hasPredecessorHelper(N, Visited, Worklist) &&\n        !SDNode::hasPredecessorHelper(Op, Visited, Worklist))\n      return Op;\n  }\n  return nullptr;\n}\n\n/// Try to combine a load/store with a add/sub of the base pointer node into a\n/// post-indexed load/store. The transformation folded the add/subtract into the\n/// new indexed load/store effectively and all of its uses are redirected to the\n/// new load/store.\nbool DAGCombiner::CombineToPostIndexedLoadStore(SDNode *N) {\n  if (Level < AfterLegalizeDAG)\n    return false;\n\n  bool IsLoad = true;\n  bool IsMasked = false;\n  SDValue Ptr;\n  SDValue BasePtr;\n  SDValue Offset;\n  ISD::MemIndexedMode AM = ISD::UNINDEXED;\n  SDNode *Op = getPostIndexedLoadStoreOp(N, IsLoad, IsMasked, Ptr, BasePtr,\n                                         Offset, AM, DAG, TLI);\n  if (!Op)\n    return false;\n\n  SDValue Result;\n  if (!IsMasked)\n    Result = IsLoad ? DAG.getIndexedLoad(SDValue(N, 0), SDLoc(N), BasePtr,\n                                         Offset, AM)\n                    : DAG.getIndexedStore(SDValue(N, 0), SDLoc(N),\n                                          BasePtr, Offset, AM);\n  else\n    Result = IsLoad ? DAG.getIndexedMaskedLoad(SDValue(N, 0), SDLoc(N),\n                                               BasePtr, Offset, AM)\n                    : DAG.getIndexedMaskedStore(SDValue(N, 0), SDLoc(N),\n                                                BasePtr, Offset, AM);\n  ++PostIndexedNodes;\n  ++NodesCombined;\n  LLVM_DEBUG(dbgs() << \"\\nReplacing.5 \"; N->dump(&DAG);\n             dbgs() << \"\\nWith: \"; Result.getNode()->dump(&DAG);\n             dbgs() << '\\n');\n  WorklistRemover DeadNodes(*this);\n  if (IsLoad) {\n    DAG.ReplaceAllUsesOfValueWith(SDValue(N, 0), Result.getValue(0));\n    DAG.ReplaceAllUsesOfValueWith(SDValue(N, 1), Result.getValue(2));\n  } else {\n    DAG.ReplaceAllUsesOfValueWith(SDValue(N, 0), Result.getValue(1));\n  }\n\n  // Finally, since the node is now dead, remove it from the graph.\n  deleteAndRecombine(N);\n\n  // Replace the uses of Use with uses of the updated base value.\n  DAG.ReplaceAllUsesOfValueWith(SDValue(Op, 0),\n                                Result.getValue(IsLoad ? 1 : 0));\n  deleteAndRecombine(Op);\n  return true;\n}\n\n/// Return the base-pointer arithmetic from an indexed \\p LD.\nSDValue DAGCombiner::SplitIndexingFromLoad(LoadSDNode *LD) {\n  ISD::MemIndexedMode AM = LD->getAddressingMode();\n  assert(AM != ISD::UNINDEXED);\n  SDValue BP = LD->getOperand(1);\n  SDValue Inc = LD->getOperand(2);\n\n  // Some backends use TargetConstants for load offsets, but don't expect\n  // TargetConstants in general ADD nodes. We can convert these constants into\n  // regular Constants (if the constant is not opaque).\n  assert((Inc.getOpcode() != ISD::TargetConstant ||\n          !cast<ConstantSDNode>(Inc)->isOpaque()) &&\n         \"Cannot split out indexing using opaque target constants\");\n  if (Inc.getOpcode() == ISD::TargetConstant) {\n    ConstantSDNode *ConstInc = cast<ConstantSDNode>(Inc);\n    Inc = DAG.getConstant(*ConstInc->getConstantIntValue(), SDLoc(Inc),\n                          ConstInc->getValueType(0));\n  }\n\n  unsigned Opc =\n      (AM == ISD::PRE_INC || AM == ISD::POST_INC ? ISD::ADD : ISD::SUB);\n  return DAG.getNode(Opc, SDLoc(LD), BP.getSimpleValueType(), BP, Inc);\n}\n\nstatic inline ElementCount numVectorEltsOrZero(EVT T) {\n  return T.isVector() ? T.getVectorElementCount() : ElementCount::getFixed(0);\n}\n\nbool DAGCombiner::getTruncatedStoreValue(StoreSDNode *ST, SDValue &Val) {\n  Val = ST->getValue();\n  EVT STType = Val.getValueType();\n  EVT STMemType = ST->getMemoryVT();\n  if (STType == STMemType)\n    return true;\n  if (isTypeLegal(STMemType))\n    return false; // fail.\n  if (STType.isFloatingPoint() && STMemType.isFloatingPoint() &&\n      TLI.isOperationLegal(ISD::FTRUNC, STMemType)) {\n    Val = DAG.getNode(ISD::FTRUNC, SDLoc(ST), STMemType, Val);\n    return true;\n  }\n  if (numVectorEltsOrZero(STType) == numVectorEltsOrZero(STMemType) &&\n      STType.isInteger() && STMemType.isInteger()) {\n    Val = DAG.getNode(ISD::TRUNCATE, SDLoc(ST), STMemType, Val);\n    return true;\n  }\n  if (STType.getSizeInBits() == STMemType.getSizeInBits()) {\n    Val = DAG.getBitcast(STMemType, Val);\n    return true;\n  }\n  return false; // fail.\n}\n\nbool DAGCombiner::extendLoadedValueToExtension(LoadSDNode *LD, SDValue &Val) {\n  EVT LDMemType = LD->getMemoryVT();\n  EVT LDType = LD->getValueType(0);\n  assert(Val.getValueType() == LDMemType &&\n         \"Attempting to extend value of non-matching type\");\n  if (LDType == LDMemType)\n    return true;\n  if (LDMemType.isInteger() && LDType.isInteger()) {\n    switch (LD->getExtensionType()) {\n    case ISD::NON_EXTLOAD:\n      Val = DAG.getBitcast(LDType, Val);\n      return true;\n    case ISD::EXTLOAD:\n      Val = DAG.getNode(ISD::ANY_EXTEND, SDLoc(LD), LDType, Val);\n      return true;\n    case ISD::SEXTLOAD:\n      Val = DAG.getNode(ISD::SIGN_EXTEND, SDLoc(LD), LDType, Val);\n      return true;\n    case ISD::ZEXTLOAD:\n      Val = DAG.getNode(ISD::ZERO_EXTEND, SDLoc(LD), LDType, Val);\n      return true;\n    }\n  }\n  return false;\n}\n\nSDValue DAGCombiner::ForwardStoreValueToDirectLoad(LoadSDNode *LD) {\n  if (OptLevel == CodeGenOpt::None || !LD->isSimple())\n    return SDValue();\n  SDValue Chain = LD->getOperand(0);\n  StoreSDNode *ST = dyn_cast<StoreSDNode>(Chain.getNode());\n  // TODO: Relax this restriction for unordered atomics (see D66309)\n  if (!ST || !ST->isSimple())\n    return SDValue();\n\n  EVT LDType = LD->getValueType(0);\n  EVT LDMemType = LD->getMemoryVT();\n  EVT STMemType = ST->getMemoryVT();\n  EVT STType = ST->getValue().getValueType();\n\n  // There are two cases to consider here:\n  //  1. The store is fixed width and the load is scalable. In this case we\n  //     don't know at compile time if the store completely envelops the load\n  //     so we abandon the optimisation.\n  //  2. The store is scalable and the load is fixed width. We could\n  //     potentially support a limited number of cases here, but there has been\n  //     no cost-benefit analysis to prove it's worth it.\n  bool LdStScalable = LDMemType.isScalableVector();\n  if (LdStScalable != STMemType.isScalableVector())\n    return SDValue();\n\n  // If we are dealing with scalable vectors on a big endian platform the\n  // calculation of offsets below becomes trickier, since we do not know at\n  // compile time the absolute size of the vector. Until we've done more\n  // analysis on big-endian platforms it seems better to bail out for now.\n  if (LdStScalable && DAG.getDataLayout().isBigEndian())\n    return SDValue();\n\n  BaseIndexOffset BasePtrLD = BaseIndexOffset::match(LD, DAG);\n  BaseIndexOffset BasePtrST = BaseIndexOffset::match(ST, DAG);\n  int64_t Offset;\n  if (!BasePtrST.equalBaseIndex(BasePtrLD, DAG, Offset))\n    return SDValue();\n\n  // Normalize for Endianness. After this Offset=0 will denote that the least\n  // significant bit in the loaded value maps to the least significant bit in\n  // the stored value). With Offset=n (for n > 0) the loaded value starts at the\n  // n:th least significant byte of the stored value.\n  if (DAG.getDataLayout().isBigEndian())\n    Offset = ((int64_t)STMemType.getStoreSizeInBits().getFixedSize() -\n              (int64_t)LDMemType.getStoreSizeInBits().getFixedSize()) /\n                 8 -\n             Offset;\n\n  // Check that the stored value cover all bits that are loaded.\n  bool STCoversLD;\n\n  TypeSize LdMemSize = LDMemType.getSizeInBits();\n  TypeSize StMemSize = STMemType.getSizeInBits();\n  if (LdStScalable)\n    STCoversLD = (Offset == 0) && LdMemSize == StMemSize;\n  else\n    STCoversLD = (Offset >= 0) && (Offset * 8 + LdMemSize.getFixedSize() <=\n                                   StMemSize.getFixedSize());\n\n  auto ReplaceLd = [&](LoadSDNode *LD, SDValue Val, SDValue Chain) -> SDValue {\n    if (LD->isIndexed()) {\n      // Cannot handle opaque target constants and we must respect the user's\n      // request not to split indexes from loads.\n      if (!canSplitIdx(LD))\n        return SDValue();\n      SDValue Idx = SplitIndexingFromLoad(LD);\n      SDValue Ops[] = {Val, Idx, Chain};\n      return CombineTo(LD, Ops, 3);\n    }\n    return CombineTo(LD, Val, Chain);\n  };\n\n  if (!STCoversLD)\n    return SDValue();\n\n  // Memory as copy space (potentially masked).\n  if (Offset == 0 && LDType == STType && STMemType == LDMemType) {\n    // Simple case: Direct non-truncating forwarding\n    if (LDType.getSizeInBits() == LdMemSize)\n      return ReplaceLd(LD, ST->getValue(), Chain);\n    // Can we model the truncate and extension with an and mask?\n    if (STType.isInteger() && LDMemType.isInteger() && !STType.isVector() &&\n        !LDMemType.isVector() && LD->getExtensionType() != ISD::SEXTLOAD) {\n      // Mask to size of LDMemType\n      auto Mask =\n          DAG.getConstant(APInt::getLowBitsSet(STType.getFixedSizeInBits(),\n                                               StMemSize.getFixedSize()),\n                          SDLoc(ST), STType);\n      auto Val = DAG.getNode(ISD::AND, SDLoc(LD), LDType, ST->getValue(), Mask);\n      return ReplaceLd(LD, Val, Chain);\n    }\n  }\n\n  // TODO: Deal with nonzero offset.\n  if (LD->getBasePtr().isUndef() || Offset != 0)\n    return SDValue();\n  // Model necessary truncations / extenstions.\n  SDValue Val;\n  // Truncate Value To Stored Memory Size.\n  do {\n    if (!getTruncatedStoreValue(ST, Val))\n      continue;\n    if (!isTypeLegal(LDMemType))\n      continue;\n    if (STMemType != LDMemType) {\n      // TODO: Support vectors? This requires extract_subvector/bitcast.\n      if (!STMemType.isVector() && !LDMemType.isVector() &&\n          STMemType.isInteger() && LDMemType.isInteger())\n        Val = DAG.getNode(ISD::TRUNCATE, SDLoc(LD), LDMemType, Val);\n      else\n        continue;\n    }\n    if (!extendLoadedValueToExtension(LD, Val))\n      continue;\n    return ReplaceLd(LD, Val, Chain);\n  } while (false);\n\n  // On failure, cleanup dead nodes we may have created.\n  if (Val->use_empty())\n    deleteAndRecombine(Val.getNode());\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitLOAD(SDNode *N) {\n  LoadSDNode *LD  = cast<LoadSDNode>(N);\n  SDValue Chain = LD->getChain();\n  SDValue Ptr   = LD->getBasePtr();\n\n  // If load is not volatile and there are no uses of the loaded value (and\n  // the updated indexed value in case of indexed loads), change uses of the\n  // chain value into uses of the chain input (i.e. delete the dead load).\n  // TODO: Allow this for unordered atomics (see D66309)\n  if (LD->isSimple()) {\n    if (N->getValueType(1) == MVT::Other) {\n      // Unindexed loads.\n      if (!N->hasAnyUseOfValue(0)) {\n        // It's not safe to use the two value CombineTo variant here. e.g.\n        // v1, chain2 = load chain1, loc\n        // v2, chain3 = load chain2, loc\n        // v3         = add v2, c\n        // Now we replace use of chain2 with chain1.  This makes the second load\n        // isomorphic to the one we are deleting, and thus makes this load live.\n        LLVM_DEBUG(dbgs() << \"\\nReplacing.6 \"; N->dump(&DAG);\n                   dbgs() << \"\\nWith chain: \"; Chain.getNode()->dump(&DAG);\n                   dbgs() << \"\\n\");\n        WorklistRemover DeadNodes(*this);\n        DAG.ReplaceAllUsesOfValueWith(SDValue(N, 1), Chain);\n        AddUsersToWorklist(Chain.getNode());\n        if (N->use_empty())\n          deleteAndRecombine(N);\n\n        return SDValue(N, 0);   // Return N so it doesn't get rechecked!\n      }\n    } else {\n      // Indexed loads.\n      assert(N->getValueType(2) == MVT::Other && \"Malformed indexed loads?\");\n\n      // If this load has an opaque TargetConstant offset, then we cannot split\n      // the indexing into an add/sub directly (that TargetConstant may not be\n      // valid for a different type of node, and we cannot convert an opaque\n      // target constant into a regular constant).\n      bool CanSplitIdx = canSplitIdx(LD);\n\n      if (!N->hasAnyUseOfValue(0) && (CanSplitIdx || !N->hasAnyUseOfValue(1))) {\n        SDValue Undef = DAG.getUNDEF(N->getValueType(0));\n        SDValue Index;\n        if (N->hasAnyUseOfValue(1) && CanSplitIdx) {\n          Index = SplitIndexingFromLoad(LD);\n          // Try to fold the base pointer arithmetic into subsequent loads and\n          // stores.\n          AddUsersToWorklist(N);\n        } else\n          Index = DAG.getUNDEF(N->getValueType(1));\n        LLVM_DEBUG(dbgs() << \"\\nReplacing.7 \"; N->dump(&DAG);\n                   dbgs() << \"\\nWith: \"; Undef.getNode()->dump(&DAG);\n                   dbgs() << \" and 2 other values\\n\");\n        WorklistRemover DeadNodes(*this);\n        DAG.ReplaceAllUsesOfValueWith(SDValue(N, 0), Undef);\n        DAG.ReplaceAllUsesOfValueWith(SDValue(N, 1), Index);\n        DAG.ReplaceAllUsesOfValueWith(SDValue(N, 2), Chain);\n        deleteAndRecombine(N);\n        return SDValue(N, 0);   // Return N so it doesn't get rechecked!\n      }\n    }\n  }\n\n  // If this load is directly stored, replace the load value with the stored\n  // value.\n  if (auto V = ForwardStoreValueToDirectLoad(LD))\n    return V;\n\n  // Try to infer better alignment information than the load already has.\n  if (OptLevel != CodeGenOpt::None && LD->isUnindexed() && !LD->isAtomic()) {\n    if (MaybeAlign Alignment = DAG.InferPtrAlign(Ptr)) {\n      if (*Alignment > LD->getAlign() &&\n          isAligned(*Alignment, LD->getSrcValueOffset())) {\n        SDValue NewLoad = DAG.getExtLoad(\n            LD->getExtensionType(), SDLoc(N), LD->getValueType(0), Chain, Ptr,\n            LD->getPointerInfo(), LD->getMemoryVT(), *Alignment,\n            LD->getMemOperand()->getFlags(), LD->getAAInfo());\n        // NewLoad will always be N as we are only refining the alignment\n        assert(NewLoad.getNode() == N);\n        (void)NewLoad;\n      }\n    }\n  }\n\n  if (LD->isUnindexed()) {\n    // Walk up chain skipping non-aliasing memory nodes.\n    SDValue BetterChain = FindBetterChain(LD, Chain);\n\n    // If there is a better chain.\n    if (Chain != BetterChain) {\n      SDValue ReplLoad;\n\n      // Replace the chain to void dependency.\n      if (LD->getExtensionType() == ISD::NON_EXTLOAD) {\n        ReplLoad = DAG.getLoad(N->getValueType(0), SDLoc(LD),\n                               BetterChain, Ptr, LD->getMemOperand());\n      } else {\n        ReplLoad = DAG.getExtLoad(LD->getExtensionType(), SDLoc(LD),\n                                  LD->getValueType(0),\n                                  BetterChain, Ptr, LD->getMemoryVT(),\n                                  LD->getMemOperand());\n      }\n\n      // Create token factor to keep old chain connected.\n      SDValue Token = DAG.getNode(ISD::TokenFactor, SDLoc(N),\n                                  MVT::Other, Chain, ReplLoad.getValue(1));\n\n      // Replace uses with load result and token factor\n      return CombineTo(N, ReplLoad.getValue(0), Token);\n    }\n  }\n\n  // Try transforming N to an indexed load.\n  if (CombineToPreIndexedLoadStore(N) || CombineToPostIndexedLoadStore(N))\n    return SDValue(N, 0);\n\n  // Try to slice up N to more direct loads if the slices are mapped to\n  // different register banks or pairing can take place.\n  if (SliceUpLoad(N))\n    return SDValue(N, 0);\n\n  return SDValue();\n}\n\nnamespace {\n\n/// Helper structure used to slice a load in smaller loads.\n/// Basically a slice is obtained from the following sequence:\n/// Origin = load Ty1, Base\n/// Shift = srl Ty1 Origin, CstTy Amount\n/// Inst = trunc Shift to Ty2\n///\n/// Then, it will be rewritten into:\n/// Slice = load SliceTy, Base + SliceOffset\n/// [Inst = zext Slice to Ty2], only if SliceTy <> Ty2\n///\n/// SliceTy is deduced from the number of bits that are actually used to\n/// build Inst.\nstruct LoadedSlice {\n  /// Helper structure used to compute the cost of a slice.\n  struct Cost {\n    /// Are we optimizing for code size.\n    bool ForCodeSize = false;\n\n    /// Various cost.\n    unsigned Loads = 0;\n    unsigned Truncates = 0;\n    unsigned CrossRegisterBanksCopies = 0;\n    unsigned ZExts = 0;\n    unsigned Shift = 0;\n\n    explicit Cost(bool ForCodeSize) : ForCodeSize(ForCodeSize) {}\n\n    /// Get the cost of one isolated slice.\n    Cost(const LoadedSlice &LS, bool ForCodeSize)\n        : ForCodeSize(ForCodeSize), Loads(1) {\n      EVT TruncType = LS.Inst->getValueType(0);\n      EVT LoadedType = LS.getLoadedType();\n      if (TruncType != LoadedType &&\n          !LS.DAG->getTargetLoweringInfo().isZExtFree(LoadedType, TruncType))\n        ZExts = 1;\n    }\n\n    /// Account for slicing gain in the current cost.\n    /// Slicing provide a few gains like removing a shift or a\n    /// truncate. This method allows to grow the cost of the original\n    /// load with the gain from this slice.\n    void addSliceGain(const LoadedSlice &LS) {\n      // Each slice saves a truncate.\n      const TargetLowering &TLI = LS.DAG->getTargetLoweringInfo();\n      if (!TLI.isTruncateFree(LS.Inst->getOperand(0).getValueType(),\n                              LS.Inst->getValueType(0)))\n        ++Truncates;\n      // If there is a shift amount, this slice gets rid of it.\n      if (LS.Shift)\n        ++Shift;\n      // If this slice can merge a cross register bank copy, account for it.\n      if (LS.canMergeExpensiveCrossRegisterBankCopy())\n        ++CrossRegisterBanksCopies;\n    }\n\n    Cost &operator+=(const Cost &RHS) {\n      Loads += RHS.Loads;\n      Truncates += RHS.Truncates;\n      CrossRegisterBanksCopies += RHS.CrossRegisterBanksCopies;\n      ZExts += RHS.ZExts;\n      Shift += RHS.Shift;\n      return *this;\n    }\n\n    bool operator==(const Cost &RHS) const {\n      return Loads == RHS.Loads && Truncates == RHS.Truncates &&\n             CrossRegisterBanksCopies == RHS.CrossRegisterBanksCopies &&\n             ZExts == RHS.ZExts && Shift == RHS.Shift;\n    }\n\n    bool operator!=(const Cost &RHS) const { return !(*this == RHS); }\n\n    bool operator<(const Cost &RHS) const {\n      // Assume cross register banks copies are as expensive as loads.\n      // FIXME: Do we want some more target hooks?\n      unsigned ExpensiveOpsLHS = Loads + CrossRegisterBanksCopies;\n      unsigned ExpensiveOpsRHS = RHS.Loads + RHS.CrossRegisterBanksCopies;\n      // Unless we are optimizing for code size, consider the\n      // expensive operation first.\n      if (!ForCodeSize && ExpensiveOpsLHS != ExpensiveOpsRHS)\n        return ExpensiveOpsLHS < ExpensiveOpsRHS;\n      return (Truncates + ZExts + Shift + ExpensiveOpsLHS) <\n             (RHS.Truncates + RHS.ZExts + RHS.Shift + ExpensiveOpsRHS);\n    }\n\n    bool operator>(const Cost &RHS) const { return RHS < *this; }\n\n    bool operator<=(const Cost &RHS) const { return !(RHS < *this); }\n\n    bool operator>=(const Cost &RHS) const { return !(*this < RHS); }\n  };\n\n  // The last instruction that represent the slice. This should be a\n  // truncate instruction.\n  SDNode *Inst;\n\n  // The original load instruction.\n  LoadSDNode *Origin;\n\n  // The right shift amount in bits from the original load.\n  unsigned Shift;\n\n  // The DAG from which Origin came from.\n  // This is used to get some contextual information about legal types, etc.\n  SelectionDAG *DAG;\n\n  LoadedSlice(SDNode *Inst = nullptr, LoadSDNode *Origin = nullptr,\n              unsigned Shift = 0, SelectionDAG *DAG = nullptr)\n      : Inst(Inst), Origin(Origin), Shift(Shift), DAG(DAG) {}\n\n  /// Get the bits used in a chunk of bits \\p BitWidth large.\n  /// \\return Result is \\p BitWidth and has used bits set to 1 and\n  ///         not used bits set to 0.\n  APInt getUsedBits() const {\n    // Reproduce the trunc(lshr) sequence:\n    // - Start from the truncated value.\n    // - Zero extend to the desired bit width.\n    // - Shift left.\n    assert(Origin && \"No original load to compare against.\");\n    unsigned BitWidth = Origin->getValueSizeInBits(0);\n    assert(Inst && \"This slice is not bound to an instruction\");\n    assert(Inst->getValueSizeInBits(0) <= BitWidth &&\n           \"Extracted slice is bigger than the whole type!\");\n    APInt UsedBits(Inst->getValueSizeInBits(0), 0);\n    UsedBits.setAllBits();\n    UsedBits = UsedBits.zext(BitWidth);\n    UsedBits <<= Shift;\n    return UsedBits;\n  }\n\n  /// Get the size of the slice to be loaded in bytes.\n  unsigned getLoadedSize() const {\n    unsigned SliceSize = getUsedBits().countPopulation();\n    assert(!(SliceSize & 0x7) && \"Size is not a multiple of a byte.\");\n    return SliceSize / 8;\n  }\n\n  /// Get the type that will be loaded for this slice.\n  /// Note: This may not be the final type for the slice.\n  EVT getLoadedType() const {\n    assert(DAG && \"Missing context\");\n    LLVMContext &Ctxt = *DAG->getContext();\n    return EVT::getIntegerVT(Ctxt, getLoadedSize() * 8);\n  }\n\n  /// Get the alignment of the load used for this slice.\n  Align getAlign() const {\n    Align Alignment = Origin->getAlign();\n    uint64_t Offset = getOffsetFromBase();\n    if (Offset != 0)\n      Alignment = commonAlignment(Alignment, Alignment.value() + Offset);\n    return Alignment;\n  }\n\n  /// Check if this slice can be rewritten with legal operations.\n  bool isLegal() const {\n    // An invalid slice is not legal.\n    if (!Origin || !Inst || !DAG)\n      return false;\n\n    // Offsets are for indexed load only, we do not handle that.\n    if (!Origin->getOffset().isUndef())\n      return false;\n\n    const TargetLowering &TLI = DAG->getTargetLoweringInfo();\n\n    // Check that the type is legal.\n    EVT SliceType = getLoadedType();\n    if (!TLI.isTypeLegal(SliceType))\n      return false;\n\n    // Check that the load is legal for this type.\n    if (!TLI.isOperationLegal(ISD::LOAD, SliceType))\n      return false;\n\n    // Check that the offset can be computed.\n    // 1. Check its type.\n    EVT PtrType = Origin->getBasePtr().getValueType();\n    if (PtrType == MVT::Untyped || PtrType.isExtended())\n      return false;\n\n    // 2. Check that it fits in the immediate.\n    if (!TLI.isLegalAddImmediate(getOffsetFromBase()))\n      return false;\n\n    // 3. Check that the computation is legal.\n    if (!TLI.isOperationLegal(ISD::ADD, PtrType))\n      return false;\n\n    // Check that the zext is legal if it needs one.\n    EVT TruncateType = Inst->getValueType(0);\n    if (TruncateType != SliceType &&\n        !TLI.isOperationLegal(ISD::ZERO_EXTEND, TruncateType))\n      return false;\n\n    return true;\n  }\n\n  /// Get the offset in bytes of this slice in the original chunk of\n  /// bits.\n  /// \\pre DAG != nullptr.\n  uint64_t getOffsetFromBase() const {\n    assert(DAG && \"Missing context.\");\n    bool IsBigEndian = DAG->getDataLayout().isBigEndian();\n    assert(!(Shift & 0x7) && \"Shifts not aligned on Bytes are not supported.\");\n    uint64_t Offset = Shift / 8;\n    unsigned TySizeInBytes = Origin->getValueSizeInBits(0) / 8;\n    assert(!(Origin->getValueSizeInBits(0) & 0x7) &&\n           \"The size of the original loaded type is not a multiple of a\"\n           \" byte.\");\n    // If Offset is bigger than TySizeInBytes, it means we are loading all\n    // zeros. This should have been optimized before in the process.\n    assert(TySizeInBytes > Offset &&\n           \"Invalid shift amount for given loaded size\");\n    if (IsBigEndian)\n      Offset = TySizeInBytes - Offset - getLoadedSize();\n    return Offset;\n  }\n\n  /// Generate the sequence of instructions to load the slice\n  /// represented by this object and redirect the uses of this slice to\n  /// this new sequence of instructions.\n  /// \\pre this->Inst && this->Origin are valid Instructions and this\n  /// object passed the legal check: LoadedSlice::isLegal returned true.\n  /// \\return The last instruction of the sequence used to load the slice.\n  SDValue loadSlice() const {\n    assert(Inst && Origin && \"Unable to replace a non-existing slice.\");\n    const SDValue &OldBaseAddr = Origin->getBasePtr();\n    SDValue BaseAddr = OldBaseAddr;\n    // Get the offset in that chunk of bytes w.r.t. the endianness.\n    int64_t Offset = static_cast<int64_t>(getOffsetFromBase());\n    assert(Offset >= 0 && \"Offset too big to fit in int64_t!\");\n    if (Offset) {\n      // BaseAddr = BaseAddr + Offset.\n      EVT ArithType = BaseAddr.getValueType();\n      SDLoc DL(Origin);\n      BaseAddr = DAG->getNode(ISD::ADD, DL, ArithType, BaseAddr,\n                              DAG->getConstant(Offset, DL, ArithType));\n    }\n\n    // Create the type of the loaded slice according to its size.\n    EVT SliceType = getLoadedType();\n\n    // Create the load for the slice.\n    SDValue LastInst =\n        DAG->getLoad(SliceType, SDLoc(Origin), Origin->getChain(), BaseAddr,\n                     Origin->getPointerInfo().getWithOffset(Offset), getAlign(),\n                     Origin->getMemOperand()->getFlags());\n    // If the final type is not the same as the loaded type, this means that\n    // we have to pad with zero. Create a zero extend for that.\n    EVT FinalType = Inst->getValueType(0);\n    if (SliceType != FinalType)\n      LastInst =\n          DAG->getNode(ISD::ZERO_EXTEND, SDLoc(LastInst), FinalType, LastInst);\n    return LastInst;\n  }\n\n  /// Check if this slice can be merged with an expensive cross register\n  /// bank copy. E.g.,\n  /// i = load i32\n  /// f = bitcast i32 i to float\n  bool canMergeExpensiveCrossRegisterBankCopy() const {\n    if (!Inst || !Inst->hasOneUse())\n      return false;\n    SDNode *Use = *Inst->use_begin();\n    if (Use->getOpcode() != ISD::BITCAST)\n      return false;\n    assert(DAG && \"Missing context\");\n    const TargetLowering &TLI = DAG->getTargetLoweringInfo();\n    EVT ResVT = Use->getValueType(0);\n    const TargetRegisterClass *ResRC =\n        TLI.getRegClassFor(ResVT.getSimpleVT(), Use->isDivergent());\n    const TargetRegisterClass *ArgRC =\n        TLI.getRegClassFor(Use->getOperand(0).getValueType().getSimpleVT(),\n                           Use->getOperand(0)->isDivergent());\n    if (ArgRC == ResRC || !TLI.isOperationLegal(ISD::LOAD, ResVT))\n      return false;\n\n    // At this point, we know that we perform a cross-register-bank copy.\n    // Check if it is expensive.\n    const TargetRegisterInfo *TRI = DAG->getSubtarget().getRegisterInfo();\n    // Assume bitcasts are cheap, unless both register classes do not\n    // explicitly share a common sub class.\n    if (!TRI || TRI->getCommonSubClass(ArgRC, ResRC))\n      return false;\n\n    // Check if it will be merged with the load.\n    // 1. Check the alignment constraint.\n    Align RequiredAlignment = DAG->getDataLayout().getABITypeAlign(\n        ResVT.getTypeForEVT(*DAG->getContext()));\n\n    if (RequiredAlignment > getAlign())\n      return false;\n\n    // 2. Check that the load is a legal operation for that type.\n    if (!TLI.isOperationLegal(ISD::LOAD, ResVT))\n      return false;\n\n    // 3. Check that we do not have a zext in the way.\n    if (Inst->getValueType(0) != getLoadedType())\n      return false;\n\n    return true;\n  }\n};\n\n} // end anonymous namespace\n\n/// Check that all bits set in \\p UsedBits form a dense region, i.e.,\n/// \\p UsedBits looks like 0..0 1..1 0..0.\nstatic bool areUsedBitsDense(const APInt &UsedBits) {\n  // If all the bits are one, this is dense!\n  if (UsedBits.isAllOnesValue())\n    return true;\n\n  // Get rid of the unused bits on the right.\n  APInt NarrowedUsedBits = UsedBits.lshr(UsedBits.countTrailingZeros());\n  // Get rid of the unused bits on the left.\n  if (NarrowedUsedBits.countLeadingZeros())\n    NarrowedUsedBits = NarrowedUsedBits.trunc(NarrowedUsedBits.getActiveBits());\n  // Check that the chunk of bits is completely used.\n  return NarrowedUsedBits.isAllOnesValue();\n}\n\n/// Check whether or not \\p First and \\p Second are next to each other\n/// in memory. This means that there is no hole between the bits loaded\n/// by \\p First and the bits loaded by \\p Second.\nstatic bool areSlicesNextToEachOther(const LoadedSlice &First,\n                                     const LoadedSlice &Second) {\n  assert(First.Origin == Second.Origin && First.Origin &&\n         \"Unable to match different memory origins.\");\n  APInt UsedBits = First.getUsedBits();\n  assert((UsedBits & Second.getUsedBits()) == 0 &&\n         \"Slices are not supposed to overlap.\");\n  UsedBits |= Second.getUsedBits();\n  return areUsedBitsDense(UsedBits);\n}\n\n/// Adjust the \\p GlobalLSCost according to the target\n/// paring capabilities and the layout of the slices.\n/// \\pre \\p GlobalLSCost should account for at least as many loads as\n/// there is in the slices in \\p LoadedSlices.\nstatic void adjustCostForPairing(SmallVectorImpl<LoadedSlice> &LoadedSlices,\n                                 LoadedSlice::Cost &GlobalLSCost) {\n  unsigned NumberOfSlices = LoadedSlices.size();\n  // If there is less than 2 elements, no pairing is possible.\n  if (NumberOfSlices < 2)\n    return;\n\n  // Sort the slices so that elements that are likely to be next to each\n  // other in memory are next to each other in the list.\n  llvm::sort(LoadedSlices, [](const LoadedSlice &LHS, const LoadedSlice &RHS) {\n    assert(LHS.Origin == RHS.Origin && \"Different bases not implemented.\");\n    return LHS.getOffsetFromBase() < RHS.getOffsetFromBase();\n  });\n  const TargetLowering &TLI = LoadedSlices[0].DAG->getTargetLoweringInfo();\n  // First (resp. Second) is the first (resp. Second) potentially candidate\n  // to be placed in a paired load.\n  const LoadedSlice *First = nullptr;\n  const LoadedSlice *Second = nullptr;\n  for (unsigned CurrSlice = 0; CurrSlice < NumberOfSlices; ++CurrSlice,\n                // Set the beginning of the pair.\n                                                           First = Second) {\n    Second = &LoadedSlices[CurrSlice];\n\n    // If First is NULL, it means we start a new pair.\n    // Get to the next slice.\n    if (!First)\n      continue;\n\n    EVT LoadedType = First->getLoadedType();\n\n    // If the types of the slices are different, we cannot pair them.\n    if (LoadedType != Second->getLoadedType())\n      continue;\n\n    // Check if the target supplies paired loads for this type.\n    Align RequiredAlignment;\n    if (!TLI.hasPairedLoad(LoadedType, RequiredAlignment)) {\n      // move to the next pair, this type is hopeless.\n      Second = nullptr;\n      continue;\n    }\n    // Check if we meet the alignment requirement.\n    if (First->getAlign() < RequiredAlignment)\n      continue;\n\n    // Check that both loads are next to each other in memory.\n    if (!areSlicesNextToEachOther(*First, *Second))\n      continue;\n\n    assert(GlobalLSCost.Loads > 0 && \"We save more loads than we created!\");\n    --GlobalLSCost.Loads;\n    // Move to the next pair.\n    Second = nullptr;\n  }\n}\n\n/// Check the profitability of all involved LoadedSlice.\n/// Currently, it is considered profitable if there is exactly two\n/// involved slices (1) which are (2) next to each other in memory, and\n/// whose cost (\\see LoadedSlice::Cost) is smaller than the original load (3).\n///\n/// Note: The order of the elements in \\p LoadedSlices may be modified, but not\n/// the elements themselves.\n///\n/// FIXME: When the cost model will be mature enough, we can relax\n/// constraints (1) and (2).\nstatic bool isSlicingProfitable(SmallVectorImpl<LoadedSlice> &LoadedSlices,\n                                const APInt &UsedBits, bool ForCodeSize) {\n  unsigned NumberOfSlices = LoadedSlices.size();\n  if (StressLoadSlicing)\n    return NumberOfSlices > 1;\n\n  // Check (1).\n  if (NumberOfSlices != 2)\n    return false;\n\n  // Check (2).\n  if (!areUsedBitsDense(UsedBits))\n    return false;\n\n  // Check (3).\n  LoadedSlice::Cost OrigCost(ForCodeSize), GlobalSlicingCost(ForCodeSize);\n  // The original code has one big load.\n  OrigCost.Loads = 1;\n  for (unsigned CurrSlice = 0; CurrSlice < NumberOfSlices; ++CurrSlice) {\n    const LoadedSlice &LS = LoadedSlices[CurrSlice];\n    // Accumulate the cost of all the slices.\n    LoadedSlice::Cost SliceCost(LS, ForCodeSize);\n    GlobalSlicingCost += SliceCost;\n\n    // Account as cost in the original configuration the gain obtained\n    // with the current slices.\n    OrigCost.addSliceGain(LS);\n  }\n\n  // If the target supports paired load, adjust the cost accordingly.\n  adjustCostForPairing(LoadedSlices, GlobalSlicingCost);\n  return OrigCost > GlobalSlicingCost;\n}\n\n/// If the given load, \\p LI, is used only by trunc or trunc(lshr)\n/// operations, split it in the various pieces being extracted.\n///\n/// This sort of thing is introduced by SROA.\n/// This slicing takes care not to insert overlapping loads.\n/// \\pre LI is a simple load (i.e., not an atomic or volatile load).\nbool DAGCombiner::SliceUpLoad(SDNode *N) {\n  if (Level < AfterLegalizeDAG)\n    return false;\n\n  LoadSDNode *LD = cast<LoadSDNode>(N);\n  if (!LD->isSimple() || !ISD::isNormalLoad(LD) ||\n      !LD->getValueType(0).isInteger())\n    return false;\n\n  // The algorithm to split up a load of a scalable vector into individual\n  // elements currently requires knowing the length of the loaded type,\n  // so will need adjusting to work on scalable vectors.\n  if (LD->getValueType(0).isScalableVector())\n    return false;\n\n  // Keep track of already used bits to detect overlapping values.\n  // In that case, we will just abort the transformation.\n  APInt UsedBits(LD->getValueSizeInBits(0), 0);\n\n  SmallVector<LoadedSlice, 4> LoadedSlices;\n\n  // Check if this load is used as several smaller chunks of bits.\n  // Basically, look for uses in trunc or trunc(lshr) and record a new chain\n  // of computation for each trunc.\n  for (SDNode::use_iterator UI = LD->use_begin(), UIEnd = LD->use_end();\n       UI != UIEnd; ++UI) {\n    // Skip the uses of the chain.\n    if (UI.getUse().getResNo() != 0)\n      continue;\n\n    SDNode *User = *UI;\n    unsigned Shift = 0;\n\n    // Check if this is a trunc(lshr).\n    if (User->getOpcode() == ISD::SRL && User->hasOneUse() &&\n        isa<ConstantSDNode>(User->getOperand(1))) {\n      Shift = User->getConstantOperandVal(1);\n      User = *User->use_begin();\n    }\n\n    // At this point, User is a Truncate, iff we encountered, trunc or\n    // trunc(lshr).\n    if (User->getOpcode() != ISD::TRUNCATE)\n      return false;\n\n    // The width of the type must be a power of 2 and greater than 8-bits.\n    // Otherwise the load cannot be represented in LLVM IR.\n    // Moreover, if we shifted with a non-8-bits multiple, the slice\n    // will be across several bytes. We do not support that.\n    unsigned Width = User->getValueSizeInBits(0);\n    if (Width < 8 || !isPowerOf2_32(Width) || (Shift & 0x7))\n      return false;\n\n    // Build the slice for this chain of computations.\n    LoadedSlice LS(User, LD, Shift, &DAG);\n    APInt CurrentUsedBits = LS.getUsedBits();\n\n    // Check if this slice overlaps with another.\n    if ((CurrentUsedBits & UsedBits) != 0)\n      return false;\n    // Update the bits used globally.\n    UsedBits |= CurrentUsedBits;\n\n    // Check if the new slice would be legal.\n    if (!LS.isLegal())\n      return false;\n\n    // Record the slice.\n    LoadedSlices.push_back(LS);\n  }\n\n  // Abort slicing if it does not seem to be profitable.\n  if (!isSlicingProfitable(LoadedSlices, UsedBits, ForCodeSize))\n    return false;\n\n  ++SlicedLoads;\n\n  // Rewrite each chain to use an independent load.\n  // By construction, each chain can be represented by a unique load.\n\n  // Prepare the argument for the new token factor for all the slices.\n  SmallVector<SDValue, 8> ArgChains;\n  for (const LoadedSlice &LS : LoadedSlices) {\n    SDValue SliceInst = LS.loadSlice();\n    CombineTo(LS.Inst, SliceInst, true);\n    if (SliceInst.getOpcode() != ISD::LOAD)\n      SliceInst = SliceInst.getOperand(0);\n    assert(SliceInst->getOpcode() == ISD::LOAD &&\n           \"It takes more than a zext to get to the loaded slice!!\");\n    ArgChains.push_back(SliceInst.getValue(1));\n  }\n\n  SDValue Chain = DAG.getNode(ISD::TokenFactor, SDLoc(LD), MVT::Other,\n                              ArgChains);\n  DAG.ReplaceAllUsesOfValueWith(SDValue(N, 1), Chain);\n  AddToWorklist(Chain.getNode());\n  return true;\n}\n\n/// Check to see if V is (and load (ptr), imm), where the load is having\n/// specific bytes cleared out.  If so, return the byte size being masked out\n/// and the shift amount.\nstatic std::pair<unsigned, unsigned>\nCheckForMaskedLoad(SDValue V, SDValue Ptr, SDValue Chain) {\n  std::pair<unsigned, unsigned> Result(0, 0);\n\n  // Check for the structure we're looking for.\n  if (V->getOpcode() != ISD::AND ||\n      !isa<ConstantSDNode>(V->getOperand(1)) ||\n      !ISD::isNormalLoad(V->getOperand(0).getNode()))\n    return Result;\n\n  // Check the chain and pointer.\n  LoadSDNode *LD = cast<LoadSDNode>(V->getOperand(0));\n  if (LD->getBasePtr() != Ptr) return Result;  // Not from same pointer.\n\n  // This only handles simple types.\n  if (V.getValueType() != MVT::i16 &&\n      V.getValueType() != MVT::i32 &&\n      V.getValueType() != MVT::i64)\n    return Result;\n\n  // Check the constant mask.  Invert it so that the bits being masked out are\n  // 0 and the bits being kept are 1.  Use getSExtValue so that leading bits\n  // follow the sign bit for uniformity.\n  uint64_t NotMask = ~cast<ConstantSDNode>(V->getOperand(1))->getSExtValue();\n  unsigned NotMaskLZ = countLeadingZeros(NotMask);\n  if (NotMaskLZ & 7) return Result;  // Must be multiple of a byte.\n  unsigned NotMaskTZ = countTrailingZeros(NotMask);\n  if (NotMaskTZ & 7) return Result;  // Must be multiple of a byte.\n  if (NotMaskLZ == 64) return Result;  // All zero mask.\n\n  // See if we have a continuous run of bits.  If so, we have 0*1+0*\n  if (countTrailingOnes(NotMask >> NotMaskTZ) + NotMaskTZ + NotMaskLZ != 64)\n    return Result;\n\n  // Adjust NotMaskLZ down to be from the actual size of the int instead of i64.\n  if (V.getValueType() != MVT::i64 && NotMaskLZ)\n    NotMaskLZ -= 64-V.getValueSizeInBits();\n\n  unsigned MaskedBytes = (V.getValueSizeInBits()-NotMaskLZ-NotMaskTZ)/8;\n  switch (MaskedBytes) {\n  case 1:\n  case 2:\n  case 4: break;\n  default: return Result; // All one mask, or 5-byte mask.\n  }\n\n  // Verify that the first bit starts at a multiple of mask so that the access\n  // is aligned the same as the access width.\n  if (NotMaskTZ && NotMaskTZ/8 % MaskedBytes) return Result;\n\n  // For narrowing to be valid, it must be the case that the load the\n  // immediately preceding memory operation before the store.\n  if (LD == Chain.getNode())\n    ; // ok.\n  else if (Chain->getOpcode() == ISD::TokenFactor &&\n           SDValue(LD, 1).hasOneUse()) {\n    // LD has only 1 chain use so they are no indirect dependencies.\n    if (!LD->isOperandOf(Chain.getNode()))\n      return Result;\n  } else\n    return Result; // Fail.\n\n  Result.first = MaskedBytes;\n  Result.second = NotMaskTZ/8;\n  return Result;\n}\n\n/// Check to see if IVal is something that provides a value as specified by\n/// MaskInfo. If so, replace the specified store with a narrower store of\n/// truncated IVal.\nstatic SDValue\nShrinkLoadReplaceStoreWithStore(const std::pair<unsigned, unsigned> &MaskInfo,\n                                SDValue IVal, StoreSDNode *St,\n                                DAGCombiner *DC) {\n  unsigned NumBytes = MaskInfo.first;\n  unsigned ByteShift = MaskInfo.second;\n  SelectionDAG &DAG = DC->getDAG();\n\n  // Check to see if IVal is all zeros in the part being masked in by the 'or'\n  // that uses this.  If not, this is not a replacement.\n  APInt Mask = ~APInt::getBitsSet(IVal.getValueSizeInBits(),\n                                  ByteShift*8, (ByteShift+NumBytes)*8);\n  if (!DAG.MaskedValueIsZero(IVal, Mask)) return SDValue();\n\n  // Check that it is legal on the target to do this.  It is legal if the new\n  // VT we're shrinking to (i8/i16/i32) is legal or we're still before type\n  // legalization (and the target doesn't explicitly think this is a bad idea).\n  MVT VT = MVT::getIntegerVT(NumBytes * 8);\n  const TargetLowering &TLI = DAG.getTargetLoweringInfo();\n  if (!DC->isTypeLegal(VT))\n    return SDValue();\n  if (St->getMemOperand() &&\n      !TLI.allowsMemoryAccess(*DAG.getContext(), DAG.getDataLayout(), VT,\n                              *St->getMemOperand()))\n    return SDValue();\n\n  // Okay, we can do this!  Replace the 'St' store with a store of IVal that is\n  // shifted by ByteShift and truncated down to NumBytes.\n  if (ByteShift) {\n    SDLoc DL(IVal);\n    IVal = DAG.getNode(ISD::SRL, DL, IVal.getValueType(), IVal,\n                       DAG.getConstant(ByteShift*8, DL,\n                                    DC->getShiftAmountTy(IVal.getValueType())));\n  }\n\n  // Figure out the offset for the store and the alignment of the access.\n  unsigned StOffset;\n  if (DAG.getDataLayout().isLittleEndian())\n    StOffset = ByteShift;\n  else\n    StOffset = IVal.getValueType().getStoreSize() - ByteShift - NumBytes;\n\n  SDValue Ptr = St->getBasePtr();\n  if (StOffset) {\n    SDLoc DL(IVal);\n    Ptr = DAG.getMemBasePlusOffset(Ptr, TypeSize::Fixed(StOffset), DL);\n  }\n\n  // Truncate down to the new size.\n  IVal = DAG.getNode(ISD::TRUNCATE, SDLoc(IVal), VT, IVal);\n\n  ++OpsNarrowed;\n  return DAG\n      .getStore(St->getChain(), SDLoc(St), IVal, Ptr,\n                St->getPointerInfo().getWithOffset(StOffset),\n                St->getOriginalAlign());\n}\n\n/// Look for sequence of load / op / store where op is one of 'or', 'xor', and\n/// 'and' of immediates. If 'op' is only touching some of the loaded bits, try\n/// narrowing the load and store if it would end up being a win for performance\n/// or code size.\nSDValue DAGCombiner::ReduceLoadOpStoreWidth(SDNode *N) {\n  StoreSDNode *ST  = cast<StoreSDNode>(N);\n  if (!ST->isSimple())\n    return SDValue();\n\n  SDValue Chain = ST->getChain();\n  SDValue Value = ST->getValue();\n  SDValue Ptr   = ST->getBasePtr();\n  EVT VT = Value.getValueType();\n\n  if (ST->isTruncatingStore() || VT.isVector() || !Value.hasOneUse())\n    return SDValue();\n\n  unsigned Opc = Value.getOpcode();\n\n  // If this is \"store (or X, Y), P\" and X is \"(and (load P), cst)\", where cst\n  // is a byte mask indicating a consecutive number of bytes, check to see if\n  // Y is known to provide just those bytes.  If so, we try to replace the\n  // load + replace + store sequence with a single (narrower) store, which makes\n  // the load dead.\n  if (Opc == ISD::OR && EnableShrinkLoadReplaceStoreWithStore) {\n    std::pair<unsigned, unsigned> MaskedLoad;\n    MaskedLoad = CheckForMaskedLoad(Value.getOperand(0), Ptr, Chain);\n    if (MaskedLoad.first)\n      if (SDValue NewST = ShrinkLoadReplaceStoreWithStore(MaskedLoad,\n                                                  Value.getOperand(1), ST,this))\n        return NewST;\n\n    // Or is commutative, so try swapping X and Y.\n    MaskedLoad = CheckForMaskedLoad(Value.getOperand(1), Ptr, Chain);\n    if (MaskedLoad.first)\n      if (SDValue NewST = ShrinkLoadReplaceStoreWithStore(MaskedLoad,\n                                                  Value.getOperand(0), ST,this))\n        return NewST;\n  }\n\n  if (!EnableReduceLoadOpStoreWidth)\n    return SDValue();\n\n  if ((Opc != ISD::OR && Opc != ISD::XOR && Opc != ISD::AND) ||\n      Value.getOperand(1).getOpcode() != ISD::Constant)\n    return SDValue();\n\n  SDValue N0 = Value.getOperand(0);\n  if (ISD::isNormalLoad(N0.getNode()) && N0.hasOneUse() &&\n      Chain == SDValue(N0.getNode(), 1)) {\n    LoadSDNode *LD = cast<LoadSDNode>(N0);\n    if (LD->getBasePtr() != Ptr ||\n        LD->getPointerInfo().getAddrSpace() !=\n        ST->getPointerInfo().getAddrSpace())\n      return SDValue();\n\n    // Find the type to narrow it the load / op / store to.\n    SDValue N1 = Value.getOperand(1);\n    unsigned BitWidth = N1.getValueSizeInBits();\n    APInt Imm = cast<ConstantSDNode>(N1)->getAPIntValue();\n    if (Opc == ISD::AND)\n      Imm ^= APInt::getAllOnesValue(BitWidth);\n    if (Imm == 0 || Imm.isAllOnesValue())\n      return SDValue();\n    unsigned ShAmt = Imm.countTrailingZeros();\n    unsigned MSB = BitWidth - Imm.countLeadingZeros() - 1;\n    unsigned NewBW = NextPowerOf2(MSB - ShAmt);\n    EVT NewVT = EVT::getIntegerVT(*DAG.getContext(), NewBW);\n    // The narrowing should be profitable, the load/store operation should be\n    // legal (or custom) and the store size should be equal to the NewVT width.\n    while (NewBW < BitWidth &&\n           (NewVT.getStoreSizeInBits() != NewBW ||\n            !TLI.isOperationLegalOrCustom(Opc, NewVT) ||\n            !TLI.isNarrowingProfitable(VT, NewVT))) {\n      NewBW = NextPowerOf2(NewBW);\n      NewVT = EVT::getIntegerVT(*DAG.getContext(), NewBW);\n    }\n    if (NewBW >= BitWidth)\n      return SDValue();\n\n    // If the lsb changed does not start at the type bitwidth boundary,\n    // start at the previous one.\n    if (ShAmt % NewBW)\n      ShAmt = (((ShAmt + NewBW - 1) / NewBW) * NewBW) - NewBW;\n    APInt Mask = APInt::getBitsSet(BitWidth, ShAmt,\n                                   std::min(BitWidth, ShAmt + NewBW));\n    if ((Imm & Mask) == Imm) {\n      APInt NewImm = (Imm & Mask).lshr(ShAmt).trunc(NewBW);\n      if (Opc == ISD::AND)\n        NewImm ^= APInt::getAllOnesValue(NewBW);\n      uint64_t PtrOff = ShAmt / 8;\n      // For big endian targets, we need to adjust the offset to the pointer to\n      // load the correct bytes.\n      if (DAG.getDataLayout().isBigEndian())\n        PtrOff = (BitWidth + 7 - NewBW) / 8 - PtrOff;\n\n      Align NewAlign = commonAlignment(LD->getAlign(), PtrOff);\n      Type *NewVTTy = NewVT.getTypeForEVT(*DAG.getContext());\n      if (NewAlign < DAG.getDataLayout().getABITypeAlign(NewVTTy))\n        return SDValue();\n\n      SDValue NewPtr =\n          DAG.getMemBasePlusOffset(Ptr, TypeSize::Fixed(PtrOff), SDLoc(LD));\n      SDValue NewLD =\n          DAG.getLoad(NewVT, SDLoc(N0), LD->getChain(), NewPtr,\n                      LD->getPointerInfo().getWithOffset(PtrOff), NewAlign,\n                      LD->getMemOperand()->getFlags(), LD->getAAInfo());\n      SDValue NewVal = DAG.getNode(Opc, SDLoc(Value), NewVT, NewLD,\n                                   DAG.getConstant(NewImm, SDLoc(Value),\n                                                   NewVT));\n      SDValue NewST =\n          DAG.getStore(Chain, SDLoc(N), NewVal, NewPtr,\n                       ST->getPointerInfo().getWithOffset(PtrOff), NewAlign);\n\n      AddToWorklist(NewPtr.getNode());\n      AddToWorklist(NewLD.getNode());\n      AddToWorklist(NewVal.getNode());\n      WorklistRemover DeadNodes(*this);\n      DAG.ReplaceAllUsesOfValueWith(N0.getValue(1), NewLD.getValue(1));\n      ++OpsNarrowed;\n      return NewST;\n    }\n  }\n\n  return SDValue();\n}\n\n/// For a given floating point load / store pair, if the load value isn't used\n/// by any other operations, then consider transforming the pair to integer\n/// load / store operations if the target deems the transformation profitable.\nSDValue DAGCombiner::TransformFPLoadStorePair(SDNode *N) {\n  StoreSDNode *ST  = cast<StoreSDNode>(N);\n  SDValue Value = ST->getValue();\n  if (ISD::isNormalStore(ST) && ISD::isNormalLoad(Value.getNode()) &&\n      Value.hasOneUse()) {\n    LoadSDNode *LD = cast<LoadSDNode>(Value);\n    EVT VT = LD->getMemoryVT();\n    if (!VT.isFloatingPoint() ||\n        VT != ST->getMemoryVT() ||\n        LD->isNonTemporal() ||\n        ST->isNonTemporal() ||\n        LD->getPointerInfo().getAddrSpace() != 0 ||\n        ST->getPointerInfo().getAddrSpace() != 0)\n      return SDValue();\n\n    TypeSize VTSize = VT.getSizeInBits();\n\n    // We don't know the size of scalable types at compile time so we cannot\n    // create an integer of the equivalent size.\n    if (VTSize.isScalable())\n      return SDValue();\n\n    EVT IntVT = EVT::getIntegerVT(*DAG.getContext(), VTSize.getFixedSize());\n    if (!TLI.isOperationLegal(ISD::LOAD, IntVT) ||\n        !TLI.isOperationLegal(ISD::STORE, IntVT) ||\n        !TLI.isDesirableToTransformToIntegerOp(ISD::LOAD, VT) ||\n        !TLI.isDesirableToTransformToIntegerOp(ISD::STORE, VT))\n      return SDValue();\n\n    Align LDAlign = LD->getAlign();\n    Align STAlign = ST->getAlign();\n    Type *IntVTTy = IntVT.getTypeForEVT(*DAG.getContext());\n    Align ABIAlign = DAG.getDataLayout().getABITypeAlign(IntVTTy);\n    if (LDAlign < ABIAlign || STAlign < ABIAlign)\n      return SDValue();\n\n    SDValue NewLD =\n        DAG.getLoad(IntVT, SDLoc(Value), LD->getChain(), LD->getBasePtr(),\n                    LD->getPointerInfo(), LDAlign);\n\n    SDValue NewST =\n        DAG.getStore(ST->getChain(), SDLoc(N), NewLD, ST->getBasePtr(),\n                     ST->getPointerInfo(), STAlign);\n\n    AddToWorklist(NewLD.getNode());\n    AddToWorklist(NewST.getNode());\n    WorklistRemover DeadNodes(*this);\n    DAG.ReplaceAllUsesOfValueWith(Value.getValue(1), NewLD.getValue(1));\n    ++LdStFP2Int;\n    return NewST;\n  }\n\n  return SDValue();\n}\n\n// This is a helper function for visitMUL to check the profitability\n// of folding (mul (add x, c1), c2) -> (add (mul x, c2), c1*c2).\n// MulNode is the original multiply, AddNode is (add x, c1),\n// and ConstNode is c2.\n//\n// If the (add x, c1) has multiple uses, we could increase\n// the number of adds if we make this transformation.\n// It would only be worth doing this if we can remove a\n// multiply in the process. Check for that here.\n// To illustrate:\n//     (A + c1) * c3\n//     (A + c2) * c3\n// We're checking for cases where we have common \"c3 * A\" expressions.\nbool DAGCombiner::isMulAddWithConstProfitable(SDNode *MulNode,\n                                              SDValue &AddNode,\n                                              SDValue &ConstNode) {\n  APInt Val;\n\n  // If the add only has one use, this would be OK to do.\n  if (AddNode.getNode()->hasOneUse())\n    return true;\n\n  // Walk all the users of the constant with which we're multiplying.\n  for (SDNode *Use : ConstNode->uses()) {\n    if (Use == MulNode) // This use is the one we're on right now. Skip it.\n      continue;\n\n    if (Use->getOpcode() == ISD::MUL) { // We have another multiply use.\n      SDNode *OtherOp;\n      SDNode *MulVar = AddNode.getOperand(0).getNode();\n\n      // OtherOp is what we're multiplying against the constant.\n      if (Use->getOperand(0) == ConstNode)\n        OtherOp = Use->getOperand(1).getNode();\n      else\n        OtherOp = Use->getOperand(0).getNode();\n\n      // Check to see if multiply is with the same operand of our \"add\".\n      //\n      //     ConstNode  = CONST\n      //     Use = ConstNode * A  <-- visiting Use. OtherOp is A.\n      //     ...\n      //     AddNode  = (A + c1)  <-- MulVar is A.\n      //         = AddNode * ConstNode   <-- current visiting instruction.\n      //\n      // If we make this transformation, we will have a common\n      // multiply (ConstNode * A) that we can save.\n      if (OtherOp == MulVar)\n        return true;\n\n      // Now check to see if a future expansion will give us a common\n      // multiply.\n      //\n      //     ConstNode  = CONST\n      //     AddNode    = (A + c1)\n      //     ...   = AddNode * ConstNode <-- current visiting instruction.\n      //     ...\n      //     OtherOp = (A + c2)\n      //     Use     = OtherOp * ConstNode <-- visiting Use.\n      //\n      // If we make this transformation, we will have a common\n      // multiply (CONST * A) after we also do the same transformation\n      // to the \"t2\" instruction.\n      if (OtherOp->getOpcode() == ISD::ADD &&\n          DAG.isConstantIntBuildVectorOrConstantInt(OtherOp->getOperand(1)) &&\n          OtherOp->getOperand(0).getNode() == MulVar)\n        return true;\n    }\n  }\n\n  // Didn't find a case where this would be profitable.\n  return false;\n}\n\nSDValue DAGCombiner::getMergeStoreChains(SmallVectorImpl<MemOpLink> &StoreNodes,\n                                         unsigned NumStores) {\n  SmallVector<SDValue, 8> Chains;\n  SmallPtrSet<const SDNode *, 8> Visited;\n  SDLoc StoreDL(StoreNodes[0].MemNode);\n\n  for (unsigned i = 0; i < NumStores; ++i) {\n    Visited.insert(StoreNodes[i].MemNode);\n  }\n\n  // don't include nodes that are children or repeated nodes.\n  for (unsigned i = 0; i < NumStores; ++i) {\n    if (Visited.insert(StoreNodes[i].MemNode->getChain().getNode()).second)\n      Chains.push_back(StoreNodes[i].MemNode->getChain());\n  }\n\n  assert(Chains.size() > 0 && \"Chain should have generated a chain\");\n  return DAG.getTokenFactor(StoreDL, Chains);\n}\n\nbool DAGCombiner::mergeStoresOfConstantsOrVecElts(\n    SmallVectorImpl<MemOpLink> &StoreNodes, EVT MemVT, unsigned NumStores,\n    bool IsConstantSrc, bool UseVector, bool UseTrunc) {\n  // Make sure we have something to merge.\n  if (NumStores < 2)\n    return false;\n\n  // The latest Node in the DAG.\n  SDLoc DL(StoreNodes[0].MemNode);\n\n  TypeSize ElementSizeBits = MemVT.getStoreSizeInBits();\n  unsigned SizeInBits = NumStores * ElementSizeBits;\n  unsigned NumMemElts = MemVT.isVector() ? MemVT.getVectorNumElements() : 1;\n\n  EVT StoreTy;\n  if (UseVector) {\n    unsigned Elts = NumStores * NumMemElts;\n    // Get the type for the merged vector store.\n    StoreTy = EVT::getVectorVT(*DAG.getContext(), MemVT.getScalarType(), Elts);\n  } else\n    StoreTy = EVT::getIntegerVT(*DAG.getContext(), SizeInBits);\n\n  SDValue StoredVal;\n  if (UseVector) {\n    if (IsConstantSrc) {\n      SmallVector<SDValue, 8> BuildVector;\n      for (unsigned I = 0; I != NumStores; ++I) {\n        StoreSDNode *St = cast<StoreSDNode>(StoreNodes[I].MemNode);\n        SDValue Val = St->getValue();\n        // If constant is of the wrong type, convert it now.\n        if (MemVT != Val.getValueType()) {\n          Val = peekThroughBitcasts(Val);\n          // Deal with constants of wrong size.\n          if (ElementSizeBits != Val.getValueSizeInBits()) {\n            EVT IntMemVT =\n                EVT::getIntegerVT(*DAG.getContext(), MemVT.getSizeInBits());\n            if (isa<ConstantFPSDNode>(Val)) {\n              // Not clear how to truncate FP values.\n              return false;\n            } else if (auto *C = dyn_cast<ConstantSDNode>(Val))\n              Val = DAG.getConstant(C->getAPIntValue()\n                                        .zextOrTrunc(Val.getValueSizeInBits())\n                                        .zextOrTrunc(ElementSizeBits),\n                                    SDLoc(C), IntMemVT);\n          }\n          // Make sure correctly size type is the correct type.\n          Val = DAG.getBitcast(MemVT, Val);\n        }\n        BuildVector.push_back(Val);\n      }\n      StoredVal = DAG.getNode(MemVT.isVector() ? ISD::CONCAT_VECTORS\n                                               : ISD::BUILD_VECTOR,\n                              DL, StoreTy, BuildVector);\n    } else {\n      SmallVector<SDValue, 8> Ops;\n      for (unsigned i = 0; i < NumStores; ++i) {\n        StoreSDNode *St = cast<StoreSDNode>(StoreNodes[i].MemNode);\n        SDValue Val = peekThroughBitcasts(St->getValue());\n        // All operands of BUILD_VECTOR / CONCAT_VECTOR must be of\n        // type MemVT. If the underlying value is not the correct\n        // type, but it is an extraction of an appropriate vector we\n        // can recast Val to be of the correct type. This may require\n        // converting between EXTRACT_VECTOR_ELT and\n        // EXTRACT_SUBVECTOR.\n        if ((MemVT != Val.getValueType()) &&\n            (Val.getOpcode() == ISD::EXTRACT_VECTOR_ELT ||\n             Val.getOpcode() == ISD::EXTRACT_SUBVECTOR)) {\n          EVT MemVTScalarTy = MemVT.getScalarType();\n          // We may need to add a bitcast here to get types to line up.\n          if (MemVTScalarTy != Val.getValueType().getScalarType()) {\n            Val = DAG.getBitcast(MemVT, Val);\n          } else {\n            unsigned OpC = MemVT.isVector() ? ISD::EXTRACT_SUBVECTOR\n                                            : ISD::EXTRACT_VECTOR_ELT;\n            SDValue Vec = Val.getOperand(0);\n            SDValue Idx = Val.getOperand(1);\n            Val = DAG.getNode(OpC, SDLoc(Val), MemVT, Vec, Idx);\n          }\n        }\n        Ops.push_back(Val);\n      }\n\n      // Build the extracted vector elements back into a vector.\n      StoredVal = DAG.getNode(MemVT.isVector() ? ISD::CONCAT_VECTORS\n                                               : ISD::BUILD_VECTOR,\n                              DL, StoreTy, Ops);\n    }\n  } else {\n    // We should always use a vector store when merging extracted vector\n    // elements, so this path implies a store of constants.\n    assert(IsConstantSrc && \"Merged vector elements should use vector store\");\n\n    APInt StoreInt(SizeInBits, 0);\n\n    // Construct a single integer constant which is made of the smaller\n    // constant inputs.\n    bool IsLE = DAG.getDataLayout().isLittleEndian();\n    for (unsigned i = 0; i < NumStores; ++i) {\n      unsigned Idx = IsLE ? (NumStores - 1 - i) : i;\n      StoreSDNode *St  = cast<StoreSDNode>(StoreNodes[Idx].MemNode);\n\n      SDValue Val = St->getValue();\n      Val = peekThroughBitcasts(Val);\n      StoreInt <<= ElementSizeBits;\n      if (ConstantSDNode *C = dyn_cast<ConstantSDNode>(Val)) {\n        StoreInt |= C->getAPIntValue()\n                        .zextOrTrunc(ElementSizeBits)\n                        .zextOrTrunc(SizeInBits);\n      } else if (ConstantFPSDNode *C = dyn_cast<ConstantFPSDNode>(Val)) {\n        StoreInt |= C->getValueAPF()\n                        .bitcastToAPInt()\n                        .zextOrTrunc(ElementSizeBits)\n                        .zextOrTrunc(SizeInBits);\n        // If fp truncation is necessary give up for now.\n        if (MemVT.getSizeInBits() != ElementSizeBits)\n          return false;\n      } else {\n        llvm_unreachable(\"Invalid constant element type\");\n      }\n    }\n\n    // Create the new Load and Store operations.\n    StoredVal = DAG.getConstant(StoreInt, DL, StoreTy);\n  }\n\n  LSBaseSDNode *FirstInChain = StoreNodes[0].MemNode;\n  SDValue NewChain = getMergeStoreChains(StoreNodes, NumStores);\n\n  // make sure we use trunc store if it's necessary to be legal.\n  SDValue NewStore;\n  if (!UseTrunc) {\n    NewStore =\n        DAG.getStore(NewChain, DL, StoredVal, FirstInChain->getBasePtr(),\n                     FirstInChain->getPointerInfo(), FirstInChain->getAlign());\n  } else { // Must be realized as a trunc store\n    EVT LegalizedStoredValTy =\n        TLI.getTypeToTransformTo(*DAG.getContext(), StoredVal.getValueType());\n    unsigned LegalizedStoreSize = LegalizedStoredValTy.getSizeInBits();\n    ConstantSDNode *C = cast<ConstantSDNode>(StoredVal);\n    SDValue ExtendedStoreVal =\n        DAG.getConstant(C->getAPIntValue().zextOrTrunc(LegalizedStoreSize), DL,\n                        LegalizedStoredValTy);\n    NewStore = DAG.getTruncStore(\n        NewChain, DL, ExtendedStoreVal, FirstInChain->getBasePtr(),\n        FirstInChain->getPointerInfo(), StoredVal.getValueType() /*TVT*/,\n        FirstInChain->getAlign(), FirstInChain->getMemOperand()->getFlags());\n  }\n\n  // Replace all merged stores with the new store.\n  for (unsigned i = 0; i < NumStores; ++i)\n    CombineTo(StoreNodes[i].MemNode, NewStore);\n\n  AddToWorklist(NewChain.getNode());\n  return true;\n}\n\nvoid DAGCombiner::getStoreMergeCandidates(\n    StoreSDNode *St, SmallVectorImpl<MemOpLink> &StoreNodes,\n    SDNode *&RootNode) {\n  // This holds the base pointer, index, and the offset in bytes from the base\n  // pointer. We must have a base and an offset. Do not handle stores to undef\n  // base pointers.\n  BaseIndexOffset BasePtr = BaseIndexOffset::match(St, DAG);\n  if (!BasePtr.getBase().getNode() || BasePtr.getBase().isUndef())\n    return;\n\n  SDValue Val = peekThroughBitcasts(St->getValue());\n  StoreSource StoreSrc = getStoreSource(Val);\n  assert(StoreSrc != StoreSource::Unknown && \"Expected known source for store\");\n\n  // Match on loadbaseptr if relevant.\n  EVT MemVT = St->getMemoryVT();\n  BaseIndexOffset LBasePtr;\n  EVT LoadVT;\n  if (StoreSrc == StoreSource::Load) {\n    auto *Ld = cast<LoadSDNode>(Val);\n    LBasePtr = BaseIndexOffset::match(Ld, DAG);\n    LoadVT = Ld->getMemoryVT();\n    // Load and store should be the same type.\n    if (MemVT != LoadVT)\n      return;\n    // Loads must only have one use.\n    if (!Ld->hasNUsesOfValue(1, 0))\n      return;\n    // The memory operands must not be volatile/indexed/atomic.\n    // TODO: May be able to relax for unordered atomics (see D66309)\n    if (!Ld->isSimple() || Ld->isIndexed())\n      return;\n  }\n  auto CandidateMatch = [&](StoreSDNode *Other, BaseIndexOffset &Ptr,\n                            int64_t &Offset) -> bool {\n    // The memory operands must not be volatile/indexed/atomic.\n    // TODO: May be able to relax for unordered atomics (see D66309)\n    if (!Other->isSimple() || Other->isIndexed())\n      return false;\n    // Don't mix temporal stores with non-temporal stores.\n    if (St->isNonTemporal() != Other->isNonTemporal())\n      return false;\n    SDValue OtherBC = peekThroughBitcasts(Other->getValue());\n    // Allow merging constants of different types as integers.\n    bool NoTypeMatch = (MemVT.isInteger()) ? !MemVT.bitsEq(Other->getMemoryVT())\n                                           : Other->getMemoryVT() != MemVT;\n    switch (StoreSrc) {\n    case StoreSource::Load: {\n      if (NoTypeMatch)\n        return false;\n      // The Load's Base Ptr must also match.\n      auto *OtherLd = dyn_cast<LoadSDNode>(OtherBC);\n      if (!OtherLd)\n        return false;\n      BaseIndexOffset LPtr = BaseIndexOffset::match(OtherLd, DAG);\n      if (LoadVT != OtherLd->getMemoryVT())\n        return false;\n      // Loads must only have one use.\n      if (!OtherLd->hasNUsesOfValue(1, 0))\n        return false;\n      // The memory operands must not be volatile/indexed/atomic.\n      // TODO: May be able to relax for unordered atomics (see D66309)\n      if (!OtherLd->isSimple() || OtherLd->isIndexed())\n        return false;\n      // Don't mix temporal loads with non-temporal loads.\n      if (cast<LoadSDNode>(Val)->isNonTemporal() != OtherLd->isNonTemporal())\n        return false;\n      if (!(LBasePtr.equalBaseIndex(LPtr, DAG)))\n        return false;\n      break;\n    }\n    case StoreSource::Constant:\n      if (NoTypeMatch)\n        return false;\n      if (!(isa<ConstantSDNode>(OtherBC) || isa<ConstantFPSDNode>(OtherBC)))\n        return false;\n      break;\n    case StoreSource::Extract:\n      // Do not merge truncated stores here.\n      if (Other->isTruncatingStore())\n        return false;\n      if (!MemVT.bitsEq(OtherBC.getValueType()))\n        return false;\n      if (OtherBC.getOpcode() != ISD::EXTRACT_VECTOR_ELT &&\n          OtherBC.getOpcode() != ISD::EXTRACT_SUBVECTOR)\n        return false;\n      break;\n    default:\n      llvm_unreachable(\"Unhandled store source for merging\");\n    }\n    Ptr = BaseIndexOffset::match(Other, DAG);\n    return (BasePtr.equalBaseIndex(Ptr, DAG, Offset));\n  };\n\n  // Check if the pair of StoreNode and the RootNode already bail out many\n  // times which is over the limit in dependence check.\n  auto OverLimitInDependenceCheck = [&](SDNode *StoreNode,\n                                        SDNode *RootNode) -> bool {\n    auto RootCount = StoreRootCountMap.find(StoreNode);\n    return RootCount != StoreRootCountMap.end() &&\n           RootCount->second.first == RootNode &&\n           RootCount->second.second > StoreMergeDependenceLimit;\n  };\n\n  auto TryToAddCandidate = [&](SDNode::use_iterator UseIter) {\n    // This must be a chain use.\n    if (UseIter.getOperandNo() != 0)\n      return;\n    if (auto *OtherStore = dyn_cast<StoreSDNode>(*UseIter)) {\n      BaseIndexOffset Ptr;\n      int64_t PtrDiff;\n      if (CandidateMatch(OtherStore, Ptr, PtrDiff) &&\n          !OverLimitInDependenceCheck(OtherStore, RootNode))\n        StoreNodes.push_back(MemOpLink(OtherStore, PtrDiff));\n    }\n  };\n\n  // We looking for a root node which is an ancestor to all mergable\n  // stores. We search up through a load, to our root and then down\n  // through all children. For instance we will find Store{1,2,3} if\n  // St is Store1, Store2. or Store3 where the root is not a load\n  // which always true for nonvolatile ops. TODO: Expand\n  // the search to find all valid candidates through multiple layers of loads.\n  //\n  // Root\n  // |-------|-------|\n  // Load    Load    Store3\n  // |       |\n  // Store1   Store2\n  //\n  // FIXME: We should be able to climb and\n  // descend TokenFactors to find candidates as well.\n\n  RootNode = St->getChain().getNode();\n\n  unsigned NumNodesExplored = 0;\n  const unsigned MaxSearchNodes = 1024;\n  if (auto *Ldn = dyn_cast<LoadSDNode>(RootNode)) {\n    RootNode = Ldn->getChain().getNode();\n    for (auto I = RootNode->use_begin(), E = RootNode->use_end();\n         I != E && NumNodesExplored < MaxSearchNodes; ++I, ++NumNodesExplored) {\n      if (I.getOperandNo() == 0 && isa<LoadSDNode>(*I)) { // walk down chain\n        for (auto I2 = (*I)->use_begin(), E2 = (*I)->use_end(); I2 != E2; ++I2)\n          TryToAddCandidate(I2);\n      }\n    }\n  } else {\n    for (auto I = RootNode->use_begin(), E = RootNode->use_end();\n         I != E && NumNodesExplored < MaxSearchNodes; ++I, ++NumNodesExplored)\n      TryToAddCandidate(I);\n  }\n}\n\n// We need to check that merging these stores does not cause a loop in\n// the DAG. Any store candidate may depend on another candidate\n// indirectly through its operand (we already consider dependencies\n// through the chain). Check in parallel by searching up from\n// non-chain operands of candidates.\nbool DAGCombiner::checkMergeStoreCandidatesForDependencies(\n    SmallVectorImpl<MemOpLink> &StoreNodes, unsigned NumStores,\n    SDNode *RootNode) {\n  // FIXME: We should be able to truncate a full search of\n  // predecessors by doing a BFS and keeping tabs the originating\n  // stores from which worklist nodes come from in a similar way to\n  // TokenFactor simplfication.\n\n  SmallPtrSet<const SDNode *, 32> Visited;\n  SmallVector<const SDNode *, 8> Worklist;\n\n  // RootNode is a predecessor to all candidates so we need not search\n  // past it. Add RootNode (peeking through TokenFactors). Do not count\n  // these towards size check.\n\n  Worklist.push_back(RootNode);\n  while (!Worklist.empty()) {\n    auto N = Worklist.pop_back_val();\n    if (!Visited.insert(N).second)\n      continue; // Already present in Visited.\n    if (N->getOpcode() == ISD::TokenFactor) {\n      for (SDValue Op : N->ops())\n        Worklist.push_back(Op.getNode());\n    }\n  }\n\n  // Don't count pruning nodes towards max.\n  unsigned int Max = 1024 + Visited.size();\n  // Search Ops of store candidates.\n  for (unsigned i = 0; i < NumStores; ++i) {\n    SDNode *N = StoreNodes[i].MemNode;\n    // Of the 4 Store Operands:\n    //   * Chain (Op 0) -> We have already considered these\n    //                    in candidate selection and can be\n    //                    safely ignored\n    //   * Value (Op 1) -> Cycles may happen (e.g. through load chains)\n    //   * Address (Op 2) -> Merged addresses may only vary by a fixed constant,\n    //                       but aren't necessarily fromt the same base node, so\n    //                       cycles possible (e.g. via indexed store).\n    //   * (Op 3) -> Represents the pre or post-indexing offset (or undef for\n    //               non-indexed stores). Not constant on all targets (e.g. ARM)\n    //               and so can participate in a cycle.\n    for (unsigned j = 1; j < N->getNumOperands(); ++j)\n      Worklist.push_back(N->getOperand(j).getNode());\n  }\n  // Search through DAG. We can stop early if we find a store node.\n  for (unsigned i = 0; i < NumStores; ++i)\n    if (SDNode::hasPredecessorHelper(StoreNodes[i].MemNode, Visited, Worklist,\n                                     Max)) {\n      // If the searching bail out, record the StoreNode and RootNode in the\n      // StoreRootCountMap. If we have seen the pair many times over a limit,\n      // we won't add the StoreNode into StoreNodes set again.\n      if (Visited.size() >= Max) {\n        auto &RootCount = StoreRootCountMap[StoreNodes[i].MemNode];\n        if (RootCount.first == RootNode)\n          RootCount.second++;\n        else\n          RootCount = {RootNode, 1};\n      }\n      return false;\n    }\n  return true;\n}\n\nunsigned\nDAGCombiner::getConsecutiveStores(SmallVectorImpl<MemOpLink> &StoreNodes,\n                                  int64_t ElementSizeBytes) const {\n  while (true) {\n    // Find a store past the width of the first store.\n    size_t StartIdx = 0;\n    while ((StartIdx + 1 < StoreNodes.size()) &&\n           StoreNodes[StartIdx].OffsetFromBase + ElementSizeBytes !=\n              StoreNodes[StartIdx + 1].OffsetFromBase)\n      ++StartIdx;\n\n    // Bail if we don't have enough candidates to merge.\n    if (StartIdx + 1 >= StoreNodes.size())\n      return 0;\n\n    // Trim stores that overlapped with the first store.\n    if (StartIdx)\n      StoreNodes.erase(StoreNodes.begin(), StoreNodes.begin() + StartIdx);\n\n    // Scan the memory operations on the chain and find the first\n    // non-consecutive store memory address.\n    unsigned NumConsecutiveStores = 1;\n    int64_t StartAddress = StoreNodes[0].OffsetFromBase;\n    // Check that the addresses are consecutive starting from the second\n    // element in the list of stores.\n    for (unsigned i = 1, e = StoreNodes.size(); i < e; ++i) {\n      int64_t CurrAddress = StoreNodes[i].OffsetFromBase;\n      if (CurrAddress - StartAddress != (ElementSizeBytes * i))\n        break;\n      NumConsecutiveStores = i + 1;\n    }\n    if (NumConsecutiveStores > 1)\n      return NumConsecutiveStores;\n\n    // There are no consecutive stores at the start of the list.\n    // Remove the first store and try again.\n    StoreNodes.erase(StoreNodes.begin(), StoreNodes.begin() + 1);\n  }\n}\n\nbool DAGCombiner::tryStoreMergeOfConstants(\n    SmallVectorImpl<MemOpLink> &StoreNodes, unsigned NumConsecutiveStores,\n    EVT MemVT, SDNode *RootNode, bool AllowVectors) {\n  LLVMContext &Context = *DAG.getContext();\n  const DataLayout &DL = DAG.getDataLayout();\n  int64_t ElementSizeBytes = MemVT.getStoreSize();\n  unsigned NumMemElts = MemVT.isVector() ? MemVT.getVectorNumElements() : 1;\n  bool MadeChange = false;\n\n  // Store the constants into memory as one consecutive store.\n  while (NumConsecutiveStores >= 2) {\n    LSBaseSDNode *FirstInChain = StoreNodes[0].MemNode;\n    unsigned FirstStoreAS = FirstInChain->getAddressSpace();\n    unsigned FirstStoreAlign = FirstInChain->getAlignment();\n    unsigned LastLegalType = 1;\n    unsigned LastLegalVectorType = 1;\n    bool LastIntegerTrunc = false;\n    bool NonZero = false;\n    unsigned FirstZeroAfterNonZero = NumConsecutiveStores;\n    for (unsigned i = 0; i < NumConsecutiveStores; ++i) {\n      StoreSDNode *ST = cast<StoreSDNode>(StoreNodes[i].MemNode);\n      SDValue StoredVal = ST->getValue();\n      bool IsElementZero = false;\n      if (ConstantSDNode *C = dyn_cast<ConstantSDNode>(StoredVal))\n        IsElementZero = C->isNullValue();\n      else if (ConstantFPSDNode *C = dyn_cast<ConstantFPSDNode>(StoredVal))\n        IsElementZero = C->getConstantFPValue()->isNullValue();\n      if (IsElementZero) {\n        if (NonZero && FirstZeroAfterNonZero == NumConsecutiveStores)\n          FirstZeroAfterNonZero = i;\n      }\n      NonZero |= !IsElementZero;\n\n      // Find a legal type for the constant store.\n      unsigned SizeInBits = (i + 1) * ElementSizeBytes * 8;\n      EVT StoreTy = EVT::getIntegerVT(Context, SizeInBits);\n      bool IsFast = false;\n\n      // Break early when size is too large to be legal.\n      if (StoreTy.getSizeInBits() > MaximumLegalStoreInBits)\n        break;\n\n      if (TLI.isTypeLegal(StoreTy) &&\n          TLI.canMergeStoresTo(FirstStoreAS, StoreTy, DAG) &&\n          TLI.allowsMemoryAccess(Context, DL, StoreTy,\n                                 *FirstInChain->getMemOperand(), &IsFast) &&\n          IsFast) {\n        LastIntegerTrunc = false;\n        LastLegalType = i + 1;\n        // Or check whether a truncstore is legal.\n      } else if (TLI.getTypeAction(Context, StoreTy) ==\n                 TargetLowering::TypePromoteInteger) {\n        EVT LegalizedStoredValTy =\n            TLI.getTypeToTransformTo(Context, StoredVal.getValueType());\n        if (TLI.isTruncStoreLegal(LegalizedStoredValTy, StoreTy) &&\n            TLI.canMergeStoresTo(FirstStoreAS, LegalizedStoredValTy, DAG) &&\n            TLI.allowsMemoryAccess(Context, DL, StoreTy,\n                                   *FirstInChain->getMemOperand(), &IsFast) &&\n            IsFast) {\n          LastIntegerTrunc = true;\n          LastLegalType = i + 1;\n        }\n      }\n\n      // We only use vectors if the constant is known to be zero or the\n      // target allows it and the function is not marked with the\n      // noimplicitfloat attribute.\n      if ((!NonZero ||\n           TLI.storeOfVectorConstantIsCheap(MemVT, i + 1, FirstStoreAS)) &&\n          AllowVectors) {\n        // Find a legal type for the vector store.\n        unsigned Elts = (i + 1) * NumMemElts;\n        EVT Ty = EVT::getVectorVT(Context, MemVT.getScalarType(), Elts);\n        if (TLI.isTypeLegal(Ty) && TLI.isTypeLegal(MemVT) &&\n            TLI.canMergeStoresTo(FirstStoreAS, Ty, DAG) &&\n            TLI.allowsMemoryAccess(Context, DL, Ty,\n                                   *FirstInChain->getMemOperand(), &IsFast) &&\n            IsFast)\n          LastLegalVectorType = i + 1;\n      }\n    }\n\n    bool UseVector = (LastLegalVectorType > LastLegalType) && AllowVectors;\n    unsigned NumElem = (UseVector) ? LastLegalVectorType : LastLegalType;\n\n    // Check if we found a legal integer type that creates a meaningful\n    // merge.\n    if (NumElem < 2) {\n      // We know that candidate stores are in order and of correct\n      // shape. While there is no mergeable sequence from the\n      // beginning one may start later in the sequence. The only\n      // reason a merge of size N could have failed where another of\n      // the same size would not have, is if the alignment has\n      // improved or we've dropped a non-zero value. Drop as many\n      // candidates as we can here.\n      unsigned NumSkip = 1;\n      while ((NumSkip < NumConsecutiveStores) &&\n             (NumSkip < FirstZeroAfterNonZero) &&\n             (StoreNodes[NumSkip].MemNode->getAlignment() <= FirstStoreAlign))\n        NumSkip++;\n\n      StoreNodes.erase(StoreNodes.begin(), StoreNodes.begin() + NumSkip);\n      NumConsecutiveStores -= NumSkip;\n      continue;\n    }\n\n    // Check that we can merge these candidates without causing a cycle.\n    if (!checkMergeStoreCandidatesForDependencies(StoreNodes, NumElem,\n                                                  RootNode)) {\n      StoreNodes.erase(StoreNodes.begin(), StoreNodes.begin() + NumElem);\n      NumConsecutiveStores -= NumElem;\n      continue;\n    }\n\n    MadeChange |= mergeStoresOfConstantsOrVecElts(\n        StoreNodes, MemVT, NumElem, true, UseVector, LastIntegerTrunc);\n\n    // Remove merged stores for next iteration.\n    StoreNodes.erase(StoreNodes.begin(), StoreNodes.begin() + NumElem);\n    NumConsecutiveStores -= NumElem;\n  }\n  return MadeChange;\n}\n\nbool DAGCombiner::tryStoreMergeOfExtracts(\n    SmallVectorImpl<MemOpLink> &StoreNodes, unsigned NumConsecutiveStores,\n    EVT MemVT, SDNode *RootNode) {\n  LLVMContext &Context = *DAG.getContext();\n  const DataLayout &DL = DAG.getDataLayout();\n  unsigned NumMemElts = MemVT.isVector() ? MemVT.getVectorNumElements() : 1;\n  bool MadeChange = false;\n\n  // Loop on Consecutive Stores on success.\n  while (NumConsecutiveStores >= 2) {\n    LSBaseSDNode *FirstInChain = StoreNodes[0].MemNode;\n    unsigned FirstStoreAS = FirstInChain->getAddressSpace();\n    unsigned FirstStoreAlign = FirstInChain->getAlignment();\n    unsigned NumStoresToMerge = 1;\n    for (unsigned i = 0; i < NumConsecutiveStores; ++i) {\n      // Find a legal type for the vector store.\n      unsigned Elts = (i + 1) * NumMemElts;\n      EVT Ty = EVT::getVectorVT(*DAG.getContext(), MemVT.getScalarType(), Elts);\n      bool IsFast = false;\n\n      // Break early when size is too large to be legal.\n      if (Ty.getSizeInBits() > MaximumLegalStoreInBits)\n        break;\n\n      if (TLI.isTypeLegal(Ty) && TLI.canMergeStoresTo(FirstStoreAS, Ty, DAG) &&\n          TLI.allowsMemoryAccess(Context, DL, Ty,\n                                 *FirstInChain->getMemOperand(), &IsFast) &&\n          IsFast)\n        NumStoresToMerge = i + 1;\n    }\n\n    // Check if we found a legal integer type creating a meaningful\n    // merge.\n    if (NumStoresToMerge < 2) {\n      // We know that candidate stores are in order and of correct\n      // shape. While there is no mergeable sequence from the\n      // beginning one may start later in the sequence. The only\n      // reason a merge of size N could have failed where another of\n      // the same size would not have, is if the alignment has\n      // improved. Drop as many candidates as we can here.\n      unsigned NumSkip = 1;\n      while ((NumSkip < NumConsecutiveStores) &&\n             (StoreNodes[NumSkip].MemNode->getAlignment() <= FirstStoreAlign))\n        NumSkip++;\n\n      StoreNodes.erase(StoreNodes.begin(), StoreNodes.begin() + NumSkip);\n      NumConsecutiveStores -= NumSkip;\n      continue;\n    }\n\n    // Check that we can merge these candidates without causing a cycle.\n    if (!checkMergeStoreCandidatesForDependencies(StoreNodes, NumStoresToMerge,\n                                                  RootNode)) {\n      StoreNodes.erase(StoreNodes.begin(),\n                       StoreNodes.begin() + NumStoresToMerge);\n      NumConsecutiveStores -= NumStoresToMerge;\n      continue;\n    }\n\n    MadeChange |= mergeStoresOfConstantsOrVecElts(\n        StoreNodes, MemVT, NumStoresToMerge, false, true, false);\n\n    StoreNodes.erase(StoreNodes.begin(), StoreNodes.begin() + NumStoresToMerge);\n    NumConsecutiveStores -= NumStoresToMerge;\n  }\n  return MadeChange;\n}\n\nbool DAGCombiner::tryStoreMergeOfLoads(SmallVectorImpl<MemOpLink> &StoreNodes,\n                                       unsigned NumConsecutiveStores, EVT MemVT,\n                                       SDNode *RootNode, bool AllowVectors,\n                                       bool IsNonTemporalStore,\n                                       bool IsNonTemporalLoad) {\n  LLVMContext &Context = *DAG.getContext();\n  const DataLayout &DL = DAG.getDataLayout();\n  int64_t ElementSizeBytes = MemVT.getStoreSize();\n  unsigned NumMemElts = MemVT.isVector() ? MemVT.getVectorNumElements() : 1;\n  bool MadeChange = false;\n\n  // Look for load nodes which are used by the stored values.\n  SmallVector<MemOpLink, 8> LoadNodes;\n\n  // Find acceptable loads. Loads need to have the same chain (token factor),\n  // must not be zext, volatile, indexed, and they must be consecutive.\n  BaseIndexOffset LdBasePtr;\n\n  for (unsigned i = 0; i < NumConsecutiveStores; ++i) {\n    StoreSDNode *St = cast<StoreSDNode>(StoreNodes[i].MemNode);\n    SDValue Val = peekThroughBitcasts(St->getValue());\n    LoadSDNode *Ld = cast<LoadSDNode>(Val);\n\n    BaseIndexOffset LdPtr = BaseIndexOffset::match(Ld, DAG);\n    // If this is not the first ptr that we check.\n    int64_t LdOffset = 0;\n    if (LdBasePtr.getBase().getNode()) {\n      // The base ptr must be the same.\n      if (!LdBasePtr.equalBaseIndex(LdPtr, DAG, LdOffset))\n        break;\n    } else {\n      // Check that all other base pointers are the same as this one.\n      LdBasePtr = LdPtr;\n    }\n\n    // We found a potential memory operand to merge.\n    LoadNodes.push_back(MemOpLink(Ld, LdOffset));\n  }\n\n  while (NumConsecutiveStores >= 2 && LoadNodes.size() >= 2) {\n    Align RequiredAlignment;\n    bool NeedRotate = false;\n    if (LoadNodes.size() == 2) {\n      // If we have load/store pair instructions and we only have two values,\n      // don't bother merging.\n      if (TLI.hasPairedLoad(MemVT, RequiredAlignment) &&\n          StoreNodes[0].MemNode->getAlign() >= RequiredAlignment) {\n        StoreNodes.erase(StoreNodes.begin(), StoreNodes.begin() + 2);\n        LoadNodes.erase(LoadNodes.begin(), LoadNodes.begin() + 2);\n        break;\n      }\n      // If the loads are reversed, see if we can rotate the halves into place.\n      int64_t Offset0 = LoadNodes[0].OffsetFromBase;\n      int64_t Offset1 = LoadNodes[1].OffsetFromBase;\n      EVT PairVT = EVT::getIntegerVT(Context, ElementSizeBytes * 8 * 2);\n      if (Offset0 - Offset1 == ElementSizeBytes &&\n          (hasOperation(ISD::ROTL, PairVT) ||\n           hasOperation(ISD::ROTR, PairVT))) {\n        std::swap(LoadNodes[0], LoadNodes[1]);\n        NeedRotate = true;\n      }\n    }\n    LSBaseSDNode *FirstInChain = StoreNodes[0].MemNode;\n    unsigned FirstStoreAS = FirstInChain->getAddressSpace();\n    Align FirstStoreAlign = FirstInChain->getAlign();\n    LoadSDNode *FirstLoad = cast<LoadSDNode>(LoadNodes[0].MemNode);\n\n    // Scan the memory operations on the chain and find the first\n    // non-consecutive load memory address. These variables hold the index in\n    // the store node array.\n\n    unsigned LastConsecutiveLoad = 1;\n\n    // This variable refers to the size and not index in the array.\n    unsigned LastLegalVectorType = 1;\n    unsigned LastLegalIntegerType = 1;\n    bool isDereferenceable = true;\n    bool DoIntegerTruncate = false;\n    int64_t StartAddress = LoadNodes[0].OffsetFromBase;\n    SDValue LoadChain = FirstLoad->getChain();\n    for (unsigned i = 1; i < LoadNodes.size(); ++i) {\n      // All loads must share the same chain.\n      if (LoadNodes[i].MemNode->getChain() != LoadChain)\n        break;\n\n      int64_t CurrAddress = LoadNodes[i].OffsetFromBase;\n      if (CurrAddress - StartAddress != (ElementSizeBytes * i))\n        break;\n      LastConsecutiveLoad = i;\n\n      if (isDereferenceable && !LoadNodes[i].MemNode->isDereferenceable())\n        isDereferenceable = false;\n\n      // Find a legal type for the vector store.\n      unsigned Elts = (i + 1) * NumMemElts;\n      EVT StoreTy = EVT::getVectorVT(Context, MemVT.getScalarType(), Elts);\n\n      // Break early when size is too large to be legal.\n      if (StoreTy.getSizeInBits() > MaximumLegalStoreInBits)\n        break;\n\n      bool IsFastSt = false;\n      bool IsFastLd = false;\n      if (TLI.isTypeLegal(StoreTy) &&\n          TLI.canMergeStoresTo(FirstStoreAS, StoreTy, DAG) &&\n          TLI.allowsMemoryAccess(Context, DL, StoreTy,\n                                 *FirstInChain->getMemOperand(), &IsFastSt) &&\n          IsFastSt &&\n          TLI.allowsMemoryAccess(Context, DL, StoreTy,\n                                 *FirstLoad->getMemOperand(), &IsFastLd) &&\n          IsFastLd) {\n        LastLegalVectorType = i + 1;\n      }\n\n      // Find a legal type for the integer store.\n      unsigned SizeInBits = (i + 1) * ElementSizeBytes * 8;\n      StoreTy = EVT::getIntegerVT(Context, SizeInBits);\n      if (TLI.isTypeLegal(StoreTy) &&\n          TLI.canMergeStoresTo(FirstStoreAS, StoreTy, DAG) &&\n          TLI.allowsMemoryAccess(Context, DL, StoreTy,\n                                 *FirstInChain->getMemOperand(), &IsFastSt) &&\n          IsFastSt &&\n          TLI.allowsMemoryAccess(Context, DL, StoreTy,\n                                 *FirstLoad->getMemOperand(), &IsFastLd) &&\n          IsFastLd) {\n        LastLegalIntegerType = i + 1;\n        DoIntegerTruncate = false;\n        // Or check whether a truncstore and extload is legal.\n      } else if (TLI.getTypeAction(Context, StoreTy) ==\n                 TargetLowering::TypePromoteInteger) {\n        EVT LegalizedStoredValTy = TLI.getTypeToTransformTo(Context, StoreTy);\n        if (TLI.isTruncStoreLegal(LegalizedStoredValTy, StoreTy) &&\n            TLI.canMergeStoresTo(FirstStoreAS, LegalizedStoredValTy, DAG) &&\n            TLI.isLoadExtLegal(ISD::ZEXTLOAD, LegalizedStoredValTy, StoreTy) &&\n            TLI.isLoadExtLegal(ISD::SEXTLOAD, LegalizedStoredValTy, StoreTy) &&\n            TLI.isLoadExtLegal(ISD::EXTLOAD, LegalizedStoredValTy, StoreTy) &&\n            TLI.allowsMemoryAccess(Context, DL, StoreTy,\n                                   *FirstInChain->getMemOperand(), &IsFastSt) &&\n            IsFastSt &&\n            TLI.allowsMemoryAccess(Context, DL, StoreTy,\n                                   *FirstLoad->getMemOperand(), &IsFastLd) &&\n            IsFastLd) {\n          LastLegalIntegerType = i + 1;\n          DoIntegerTruncate = true;\n        }\n      }\n    }\n\n    // Only use vector types if the vector type is larger than the integer\n    // type. If they are the same, use integers.\n    bool UseVectorTy =\n        LastLegalVectorType > LastLegalIntegerType && AllowVectors;\n    unsigned LastLegalType =\n        std::max(LastLegalVectorType, LastLegalIntegerType);\n\n    // We add +1 here because the LastXXX variables refer to location while\n    // the NumElem refers to array/index size.\n    unsigned NumElem = std::min(NumConsecutiveStores, LastConsecutiveLoad + 1);\n    NumElem = std::min(LastLegalType, NumElem);\n    Align FirstLoadAlign = FirstLoad->getAlign();\n\n    if (NumElem < 2) {\n      // We know that candidate stores are in order and of correct\n      // shape. While there is no mergeable sequence from the\n      // beginning one may start later in the sequence. The only\n      // reason a merge of size N could have failed where another of\n      // the same size would not have is if the alignment or either\n      // the load or store has improved. Drop as many candidates as we\n      // can here.\n      unsigned NumSkip = 1;\n      while ((NumSkip < LoadNodes.size()) &&\n             (LoadNodes[NumSkip].MemNode->getAlign() <= FirstLoadAlign) &&\n             (StoreNodes[NumSkip].MemNode->getAlign() <= FirstStoreAlign))\n        NumSkip++;\n      StoreNodes.erase(StoreNodes.begin(), StoreNodes.begin() + NumSkip);\n      LoadNodes.erase(LoadNodes.begin(), LoadNodes.begin() + NumSkip);\n      NumConsecutiveStores -= NumSkip;\n      continue;\n    }\n\n    // Check that we can merge these candidates without causing a cycle.\n    if (!checkMergeStoreCandidatesForDependencies(StoreNodes, NumElem,\n                                                  RootNode)) {\n      StoreNodes.erase(StoreNodes.begin(), StoreNodes.begin() + NumElem);\n      LoadNodes.erase(LoadNodes.begin(), LoadNodes.begin() + NumElem);\n      NumConsecutiveStores -= NumElem;\n      continue;\n    }\n\n    // Find if it is better to use vectors or integers to load and store\n    // to memory.\n    EVT JointMemOpVT;\n    if (UseVectorTy) {\n      // Find a legal type for the vector store.\n      unsigned Elts = NumElem * NumMemElts;\n      JointMemOpVT = EVT::getVectorVT(Context, MemVT.getScalarType(), Elts);\n    } else {\n      unsigned SizeInBits = NumElem * ElementSizeBytes * 8;\n      JointMemOpVT = EVT::getIntegerVT(Context, SizeInBits);\n    }\n\n    SDLoc LoadDL(LoadNodes[0].MemNode);\n    SDLoc StoreDL(StoreNodes[0].MemNode);\n\n    // The merged loads are required to have the same incoming chain, so\n    // using the first's chain is acceptable.\n\n    SDValue NewStoreChain = getMergeStoreChains(StoreNodes, NumElem);\n    AddToWorklist(NewStoreChain.getNode());\n\n    MachineMemOperand::Flags LdMMOFlags =\n        isDereferenceable ? MachineMemOperand::MODereferenceable\n                          : MachineMemOperand::MONone;\n    if (IsNonTemporalLoad)\n      LdMMOFlags |= MachineMemOperand::MONonTemporal;\n\n    MachineMemOperand::Flags StMMOFlags = IsNonTemporalStore\n                                              ? MachineMemOperand::MONonTemporal\n                                              : MachineMemOperand::MONone;\n\n    SDValue NewLoad, NewStore;\n    if (UseVectorTy || !DoIntegerTruncate) {\n      NewLoad = DAG.getLoad(\n          JointMemOpVT, LoadDL, FirstLoad->getChain(), FirstLoad->getBasePtr(),\n          FirstLoad->getPointerInfo(), FirstLoadAlign, LdMMOFlags);\n      SDValue StoreOp = NewLoad;\n      if (NeedRotate) {\n        unsigned LoadWidth = ElementSizeBytes * 8 * 2;\n        assert(JointMemOpVT == EVT::getIntegerVT(Context, LoadWidth) &&\n               \"Unexpected type for rotate-able load pair\");\n        SDValue RotAmt =\n            DAG.getShiftAmountConstant(LoadWidth / 2, JointMemOpVT, LoadDL);\n        // Target can convert to the identical ROTR if it does not have ROTL.\n        StoreOp = DAG.getNode(ISD::ROTL, LoadDL, JointMemOpVT, NewLoad, RotAmt);\n      }\n      NewStore = DAG.getStore(\n          NewStoreChain, StoreDL, StoreOp, FirstInChain->getBasePtr(),\n          FirstInChain->getPointerInfo(), FirstStoreAlign, StMMOFlags);\n    } else { // This must be the truncstore/extload case\n      EVT ExtendedTy =\n          TLI.getTypeToTransformTo(*DAG.getContext(), JointMemOpVT);\n      NewLoad = DAG.getExtLoad(ISD::EXTLOAD, LoadDL, ExtendedTy,\n                               FirstLoad->getChain(), FirstLoad->getBasePtr(),\n                               FirstLoad->getPointerInfo(), JointMemOpVT,\n                               FirstLoadAlign, LdMMOFlags);\n      NewStore = DAG.getTruncStore(\n          NewStoreChain, StoreDL, NewLoad, FirstInChain->getBasePtr(),\n          FirstInChain->getPointerInfo(), JointMemOpVT,\n          FirstInChain->getAlign(), FirstInChain->getMemOperand()->getFlags());\n    }\n\n    // Transfer chain users from old loads to the new load.\n    for (unsigned i = 0; i < NumElem; ++i) {\n      LoadSDNode *Ld = cast<LoadSDNode>(LoadNodes[i].MemNode);\n      DAG.ReplaceAllUsesOfValueWith(SDValue(Ld, 1),\n                                    SDValue(NewLoad.getNode(), 1));\n    }\n\n    // Replace all stores with the new store. Recursively remove corresponding\n    // values if they are no longer used.\n    for (unsigned i = 0; i < NumElem; ++i) {\n      SDValue Val = StoreNodes[i].MemNode->getOperand(1);\n      CombineTo(StoreNodes[i].MemNode, NewStore);\n      if (Val.getNode()->use_empty())\n        recursivelyDeleteUnusedNodes(Val.getNode());\n    }\n\n    MadeChange = true;\n    StoreNodes.erase(StoreNodes.begin(), StoreNodes.begin() + NumElem);\n    LoadNodes.erase(LoadNodes.begin(), LoadNodes.begin() + NumElem);\n    NumConsecutiveStores -= NumElem;\n  }\n  return MadeChange;\n}\n\nbool DAGCombiner::mergeConsecutiveStores(StoreSDNode *St) {\n  if (OptLevel == CodeGenOpt::None || !EnableStoreMerging)\n    return false;\n\n  // TODO: Extend this function to merge stores of scalable vectors.\n  // (i.e. two <vscale x 8 x i8> stores can be merged to one <vscale x 16 x i8>\n  // store since we know <vscale x 16 x i8> is exactly twice as large as\n  // <vscale x 8 x i8>). Until then, bail out for scalable vectors.\n  EVT MemVT = St->getMemoryVT();\n  if (MemVT.isScalableVector())\n    return false;\n  if (!MemVT.isSimple() || MemVT.getSizeInBits() * 2 > MaximumLegalStoreInBits)\n    return false;\n\n  // This function cannot currently deal with non-byte-sized memory sizes.\n  int64_t ElementSizeBytes = MemVT.getStoreSize();\n  if (ElementSizeBytes * 8 != (int64_t)MemVT.getSizeInBits())\n    return false;\n\n  // Do not bother looking at stored values that are not constants, loads, or\n  // extracted vector elements.\n  SDValue StoredVal = peekThroughBitcasts(St->getValue());\n  const StoreSource StoreSrc = getStoreSource(StoredVal);\n  if (StoreSrc == StoreSource::Unknown)\n    return false;\n\n  SmallVector<MemOpLink, 8> StoreNodes;\n  SDNode *RootNode;\n  // Find potential store merge candidates by searching through chain sub-DAG\n  getStoreMergeCandidates(St, StoreNodes, RootNode);\n\n  // Check if there is anything to merge.\n  if (StoreNodes.size() < 2)\n    return false;\n\n  // Sort the memory operands according to their distance from the\n  // base pointer.\n  llvm::sort(StoreNodes, [](MemOpLink LHS, MemOpLink RHS) {\n    return LHS.OffsetFromBase < RHS.OffsetFromBase;\n  });\n\n  bool AllowVectors = !DAG.getMachineFunction().getFunction().hasFnAttribute(\n      Attribute::NoImplicitFloat);\n  bool IsNonTemporalStore = St->isNonTemporal();\n  bool IsNonTemporalLoad = StoreSrc == StoreSource::Load &&\n                           cast<LoadSDNode>(StoredVal)->isNonTemporal();\n\n  // Store Merge attempts to merge the lowest stores. This generally\n  // works out as if successful, as the remaining stores are checked\n  // after the first collection of stores is merged. However, in the\n  // case that a non-mergeable store is found first, e.g., {p[-2],\n  // p[0], p[1], p[2], p[3]}, we would fail and miss the subsequent\n  // mergeable cases. To prevent this, we prune such stores from the\n  // front of StoreNodes here.\n  bool MadeChange = false;\n  while (StoreNodes.size() > 1) {\n    unsigned NumConsecutiveStores =\n        getConsecutiveStores(StoreNodes, ElementSizeBytes);\n    // There are no more stores in the list to examine.\n    if (NumConsecutiveStores == 0)\n      return MadeChange;\n\n    // We have at least 2 consecutive stores. Try to merge them.\n    assert(NumConsecutiveStores >= 2 && \"Expected at least 2 stores\");\n    switch (StoreSrc) {\n    case StoreSource::Constant:\n      MadeChange |= tryStoreMergeOfConstants(StoreNodes, NumConsecutiveStores,\n                                             MemVT, RootNode, AllowVectors);\n      break;\n\n    case StoreSource::Extract:\n      MadeChange |= tryStoreMergeOfExtracts(StoreNodes, NumConsecutiveStores,\n                                            MemVT, RootNode);\n      break;\n\n    case StoreSource::Load:\n      MadeChange |= tryStoreMergeOfLoads(StoreNodes, NumConsecutiveStores,\n                                         MemVT, RootNode, AllowVectors,\n                                         IsNonTemporalStore, IsNonTemporalLoad);\n      break;\n\n    default:\n      llvm_unreachable(\"Unhandled store source type\");\n    }\n  }\n  return MadeChange;\n}\n\nSDValue DAGCombiner::replaceStoreChain(StoreSDNode *ST, SDValue BetterChain) {\n  SDLoc SL(ST);\n  SDValue ReplStore;\n\n  // Replace the chain to avoid dependency.\n  if (ST->isTruncatingStore()) {\n    ReplStore = DAG.getTruncStore(BetterChain, SL, ST->getValue(),\n                                  ST->getBasePtr(), ST->getMemoryVT(),\n                                  ST->getMemOperand());\n  } else {\n    ReplStore = DAG.getStore(BetterChain, SL, ST->getValue(), ST->getBasePtr(),\n                             ST->getMemOperand());\n  }\n\n  // Create token to keep both nodes around.\n  SDValue Token = DAG.getNode(ISD::TokenFactor, SL,\n                              MVT::Other, ST->getChain(), ReplStore);\n\n  // Make sure the new and old chains are cleaned up.\n  AddToWorklist(Token.getNode());\n\n  // Don't add users to work list.\n  return CombineTo(ST, Token, false);\n}\n\nSDValue DAGCombiner::replaceStoreOfFPConstant(StoreSDNode *ST) {\n  SDValue Value = ST->getValue();\n  if (Value.getOpcode() == ISD::TargetConstantFP)\n    return SDValue();\n\n  if (!ISD::isNormalStore(ST))\n    return SDValue();\n\n  SDLoc DL(ST);\n\n  SDValue Chain = ST->getChain();\n  SDValue Ptr = ST->getBasePtr();\n\n  const ConstantFPSDNode *CFP = cast<ConstantFPSDNode>(Value);\n\n  // NOTE: If the original store is volatile, this transform must not increase\n  // the number of stores.  For example, on x86-32 an f64 can be stored in one\n  // processor operation but an i64 (which is not legal) requires two.  So the\n  // transform should not be done in this case.\n\n  SDValue Tmp;\n  switch (CFP->getSimpleValueType(0).SimpleTy) {\n  default:\n    llvm_unreachable(\"Unknown FP type\");\n  case MVT::f16:    // We don't do this for these yet.\n  case MVT::f80:\n  case MVT::f128:\n  case MVT::ppcf128:\n    return SDValue();\n  case MVT::f32:\n    if ((isTypeLegal(MVT::i32) && !LegalOperations && ST->isSimple()) ||\n        TLI.isOperationLegalOrCustom(ISD::STORE, MVT::i32)) {\n      ;\n      Tmp = DAG.getConstant((uint32_t)CFP->getValueAPF().\n                            bitcastToAPInt().getZExtValue(), SDLoc(CFP),\n                            MVT::i32);\n      return DAG.getStore(Chain, DL, Tmp, Ptr, ST->getMemOperand());\n    }\n\n    return SDValue();\n  case MVT::f64:\n    if ((TLI.isTypeLegal(MVT::i64) && !LegalOperations &&\n         ST->isSimple()) ||\n        TLI.isOperationLegalOrCustom(ISD::STORE, MVT::i64)) {\n      ;\n      Tmp = DAG.getConstant(CFP->getValueAPF().bitcastToAPInt().\n                            getZExtValue(), SDLoc(CFP), MVT::i64);\n      return DAG.getStore(Chain, DL, Tmp,\n                          Ptr, ST->getMemOperand());\n    }\n\n    if (ST->isSimple() &&\n        TLI.isOperationLegalOrCustom(ISD::STORE, MVT::i32)) {\n      // Many FP stores are not made apparent until after legalize, e.g. for\n      // argument passing.  Since this is so common, custom legalize the\n      // 64-bit integer store into two 32-bit stores.\n      uint64_t Val = CFP->getValueAPF().bitcastToAPInt().getZExtValue();\n      SDValue Lo = DAG.getConstant(Val & 0xFFFFFFFF, SDLoc(CFP), MVT::i32);\n      SDValue Hi = DAG.getConstant(Val >> 32, SDLoc(CFP), MVT::i32);\n      if (DAG.getDataLayout().isBigEndian())\n        std::swap(Lo, Hi);\n\n      MachineMemOperand::Flags MMOFlags = ST->getMemOperand()->getFlags();\n      AAMDNodes AAInfo = ST->getAAInfo();\n\n      SDValue St0 = DAG.getStore(Chain, DL, Lo, Ptr, ST->getPointerInfo(),\n                                 ST->getOriginalAlign(), MMOFlags, AAInfo);\n      Ptr = DAG.getMemBasePlusOffset(Ptr, TypeSize::Fixed(4), DL);\n      SDValue St1 = DAG.getStore(Chain, DL, Hi, Ptr,\n                                 ST->getPointerInfo().getWithOffset(4),\n                                 ST->getOriginalAlign(), MMOFlags, AAInfo);\n      return DAG.getNode(ISD::TokenFactor, DL, MVT::Other,\n                         St0, St1);\n    }\n\n    return SDValue();\n  }\n}\n\nSDValue DAGCombiner::visitSTORE(SDNode *N) {\n  StoreSDNode *ST  = cast<StoreSDNode>(N);\n  SDValue Chain = ST->getChain();\n  SDValue Value = ST->getValue();\n  SDValue Ptr   = ST->getBasePtr();\n\n  // If this is a store of a bit convert, store the input value if the\n  // resultant store does not need a higher alignment than the original.\n  if (Value.getOpcode() == ISD::BITCAST && !ST->isTruncatingStore() &&\n      ST->isUnindexed()) {\n    EVT SVT = Value.getOperand(0).getValueType();\n    // If the store is volatile, we only want to change the store type if the\n    // resulting store is legal. Otherwise we might increase the number of\n    // memory accesses. We don't care if the original type was legal or not\n    // as we assume software couldn't rely on the number of accesses of an\n    // illegal type.\n    // TODO: May be able to relax for unordered atomics (see D66309)\n    if (((!LegalOperations && ST->isSimple()) ||\n         TLI.isOperationLegal(ISD::STORE, SVT)) &&\n        TLI.isStoreBitCastBeneficial(Value.getValueType(), SVT,\n                                     DAG, *ST->getMemOperand())) {\n      return DAG.getStore(Chain, SDLoc(N), Value.getOperand(0), Ptr,\n                          ST->getMemOperand());\n    }\n  }\n\n  // Turn 'store undef, Ptr' -> nothing.\n  if (Value.isUndef() && ST->isUnindexed())\n    return Chain;\n\n  // Try to infer better alignment information than the store already has.\n  if (OptLevel != CodeGenOpt::None && ST->isUnindexed() && !ST->isAtomic()) {\n    if (MaybeAlign Alignment = DAG.InferPtrAlign(Ptr)) {\n      if (*Alignment > ST->getAlign() &&\n          isAligned(*Alignment, ST->getSrcValueOffset())) {\n        SDValue NewStore =\n            DAG.getTruncStore(Chain, SDLoc(N), Value, Ptr, ST->getPointerInfo(),\n                              ST->getMemoryVT(), *Alignment,\n                              ST->getMemOperand()->getFlags(), ST->getAAInfo());\n        // NewStore will always be N as we are only refining the alignment\n        assert(NewStore.getNode() == N);\n        (void)NewStore;\n      }\n    }\n  }\n\n  // Try transforming a pair floating point load / store ops to integer\n  // load / store ops.\n  if (SDValue NewST = TransformFPLoadStorePair(N))\n    return NewST;\n\n  // Try transforming several stores into STORE (BSWAP).\n  if (SDValue Store = mergeTruncStores(ST))\n    return Store;\n\n  if (ST->isUnindexed()) {\n    // Walk up chain skipping non-aliasing memory nodes, on this store and any\n    // adjacent stores.\n    if (findBetterNeighborChains(ST)) {\n      // replaceStoreChain uses CombineTo, which handled all of the worklist\n      // manipulation. Return the original node to not do anything else.\n      return SDValue(ST, 0);\n    }\n    Chain = ST->getChain();\n  }\n\n  // FIXME: is there such a thing as a truncating indexed store?\n  if (ST->isTruncatingStore() && ST->isUnindexed() &&\n      Value.getValueType().isInteger() &&\n      (!isa<ConstantSDNode>(Value) ||\n       !cast<ConstantSDNode>(Value)->isOpaque())) {\n    APInt TruncDemandedBits =\n        APInt::getLowBitsSet(Value.getScalarValueSizeInBits(),\n                             ST->getMemoryVT().getScalarSizeInBits());\n\n    // See if we can simplify the input to this truncstore with knowledge that\n    // only the low bits are being used.  For example:\n    // \"truncstore (or (shl x, 8), y), i8\"  -> \"truncstore y, i8\"\n    AddToWorklist(Value.getNode());\n    if (SDValue Shorter = DAG.GetDemandedBits(Value, TruncDemandedBits))\n      return DAG.getTruncStore(Chain, SDLoc(N), Shorter, Ptr, ST->getMemoryVT(),\n                               ST->getMemOperand());\n\n    // Otherwise, see if we can simplify the operation with\n    // SimplifyDemandedBits, which only works if the value has a single use.\n    if (SimplifyDemandedBits(Value, TruncDemandedBits)) {\n      // Re-visit the store if anything changed and the store hasn't been merged\n      // with another node (N is deleted) SimplifyDemandedBits will add Value's\n      // node back to the worklist if necessary, but we also need to re-visit\n      // the Store node itself.\n      if (N->getOpcode() != ISD::DELETED_NODE)\n        AddToWorklist(N);\n      return SDValue(N, 0);\n    }\n  }\n\n  // If this is a load followed by a store to the same location, then the store\n  // is dead/noop.\n  // TODO: Can relax for unordered atomics (see D66309)\n  if (LoadSDNode *Ld = dyn_cast<LoadSDNode>(Value)) {\n    if (Ld->getBasePtr() == Ptr && ST->getMemoryVT() == Ld->getMemoryVT() &&\n        ST->isUnindexed() && ST->isSimple() &&\n        // There can't be any side effects between the load and store, such as\n        // a call or store.\n        Chain.reachesChainWithoutSideEffects(SDValue(Ld, 1))) {\n      // The store is dead, remove it.\n      return Chain;\n    }\n  }\n\n  // TODO: Can relax for unordered atomics (see D66309)\n  if (StoreSDNode *ST1 = dyn_cast<StoreSDNode>(Chain)) {\n    if (ST->isUnindexed() && ST->isSimple() &&\n        ST1->isUnindexed() && ST1->isSimple()) {\n      if (ST1->getBasePtr() == Ptr && ST1->getValue() == Value &&\n          ST->getMemoryVT() == ST1->getMemoryVT()) {\n        // If this is a store followed by a store with the same value to the\n        // same location, then the store is dead/noop.\n        return Chain;\n      }\n\n      if (OptLevel != CodeGenOpt::None && ST1->hasOneUse() &&\n          !ST1->getBasePtr().isUndef() &&\n          // BaseIndexOffset and the code below requires knowing the size\n          // of a vector, so bail out if MemoryVT is scalable.\n          !ST->getMemoryVT().isScalableVector() &&\n          !ST1->getMemoryVT().isScalableVector()) {\n        const BaseIndexOffset STBase = BaseIndexOffset::match(ST, DAG);\n        const BaseIndexOffset ChainBase = BaseIndexOffset::match(ST1, DAG);\n        unsigned STBitSize = ST->getMemoryVT().getFixedSizeInBits();\n        unsigned ChainBitSize = ST1->getMemoryVT().getFixedSizeInBits();\n        // If this is a store who's preceding store to a subset of the current\n        // location and no one other node is chained to that store we can\n        // effectively drop the store. Do not remove stores to undef as they may\n        // be used as data sinks.\n        if (STBase.contains(DAG, STBitSize, ChainBase, ChainBitSize)) {\n          CombineTo(ST1, ST1->getChain());\n          return SDValue();\n        }\n      }\n    }\n  }\n\n  // If this is an FP_ROUND or TRUNC followed by a store, fold this into a\n  // truncating store.  We can do this even if this is already a truncstore.\n  if ((Value.getOpcode() == ISD::FP_ROUND || Value.getOpcode() == ISD::TRUNCATE)\n      && Value.getNode()->hasOneUse() && ST->isUnindexed() &&\n      TLI.isTruncStoreLegal(Value.getOperand(0).getValueType(),\n                            ST->getMemoryVT())) {\n    return DAG.getTruncStore(Chain, SDLoc(N), Value.getOperand(0),\n                             Ptr, ST->getMemoryVT(), ST->getMemOperand());\n  }\n\n  // Always perform this optimization before types are legal. If the target\n  // prefers, also try this after legalization to catch stores that were created\n  // by intrinsics or other nodes.\n  if (!LegalTypes || (TLI.mergeStoresAfterLegalization(ST->getMemoryVT()))) {\n    while (true) {\n      // There can be multiple store sequences on the same chain.\n      // Keep trying to merge store sequences until we are unable to do so\n      // or until we merge the last store on the chain.\n      bool Changed = mergeConsecutiveStores(ST);\n      if (!Changed) break;\n      // Return N as merge only uses CombineTo and no worklist clean\n      // up is necessary.\n      if (N->getOpcode() == ISD::DELETED_NODE || !isa<StoreSDNode>(N))\n        return SDValue(N, 0);\n    }\n  }\n\n  // Try transforming N to an indexed store.\n  if (CombineToPreIndexedLoadStore(N) || CombineToPostIndexedLoadStore(N))\n    return SDValue(N, 0);\n\n  // Turn 'store float 1.0, Ptr' -> 'store int 0x12345678, Ptr'\n  //\n  // Make sure to do this only after attempting to merge stores in order to\n  //  avoid changing the types of some subset of stores due to visit order,\n  //  preventing their merging.\n  if (isa<ConstantFPSDNode>(ST->getValue())) {\n    if (SDValue NewSt = replaceStoreOfFPConstant(ST))\n      return NewSt;\n  }\n\n  if (SDValue NewSt = splitMergedValStore(ST))\n    return NewSt;\n\n  return ReduceLoadOpStoreWidth(N);\n}\n\nSDValue DAGCombiner::visitLIFETIME_END(SDNode *N) {\n  const auto *LifetimeEnd = cast<LifetimeSDNode>(N);\n  if (!LifetimeEnd->hasOffset())\n    return SDValue();\n\n  const BaseIndexOffset LifetimeEndBase(N->getOperand(1), SDValue(),\n                                        LifetimeEnd->getOffset(), false);\n\n  // We walk up the chains to find stores.\n  SmallVector<SDValue, 8> Chains = {N->getOperand(0)};\n  while (!Chains.empty()) {\n    SDValue Chain = Chains.pop_back_val();\n    if (!Chain.hasOneUse())\n      continue;\n    switch (Chain.getOpcode()) {\n    case ISD::TokenFactor:\n      for (unsigned Nops = Chain.getNumOperands(); Nops;)\n        Chains.push_back(Chain.getOperand(--Nops));\n      break;\n    case ISD::LIFETIME_START:\n    case ISD::LIFETIME_END:\n      // We can forward past any lifetime start/end that can be proven not to\n      // alias the node.\n      if (!isAlias(Chain.getNode(), N))\n        Chains.push_back(Chain.getOperand(0));\n      break;\n    case ISD::STORE: {\n      StoreSDNode *ST = dyn_cast<StoreSDNode>(Chain);\n      // TODO: Can relax for unordered atomics (see D66309)\n      if (!ST->isSimple() || ST->isIndexed())\n        continue;\n      const TypeSize StoreSize = ST->getMemoryVT().getStoreSize();\n      // The bounds of a scalable store are not known until runtime, so this\n      // store cannot be elided.\n      if (StoreSize.isScalable())\n        continue;\n      const BaseIndexOffset StoreBase = BaseIndexOffset::match(ST, DAG);\n      // If we store purely within object bounds just before its lifetime ends,\n      // we can remove the store.\n      if (LifetimeEndBase.contains(DAG, LifetimeEnd->getSize() * 8, StoreBase,\n                                   StoreSize.getFixedSize() * 8)) {\n        LLVM_DEBUG(dbgs() << \"\\nRemoving store:\"; StoreBase.dump();\n                   dbgs() << \"\\nwithin LIFETIME_END of : \";\n                   LifetimeEndBase.dump(); dbgs() << \"\\n\");\n        CombineTo(ST, ST->getChain());\n        return SDValue(N, 0);\n      }\n    }\n    }\n  }\n  return SDValue();\n}\n\n/// For the instruction sequence of store below, F and I values\n/// are bundled together as an i64 value before being stored into memory.\n/// Sometimes it is more efficent to generate separate stores for F and I,\n/// which can remove the bitwise instructions or sink them to colder places.\n///\n///   (store (or (zext (bitcast F to i32) to i64),\n///              (shl (zext I to i64), 32)), addr)  -->\n///   (store F, addr) and (store I, addr+4)\n///\n/// Similarly, splitting for other merged store can also be beneficial, like:\n/// For pair of {i32, i32}, i64 store --> two i32 stores.\n/// For pair of {i32, i16}, i64 store --> two i32 stores.\n/// For pair of {i16, i16}, i32 store --> two i16 stores.\n/// For pair of {i16, i8},  i32 store --> two i16 stores.\n/// For pair of {i8, i8},   i16 store --> two i8 stores.\n///\n/// We allow each target to determine specifically which kind of splitting is\n/// supported.\n///\n/// The store patterns are commonly seen from the simple code snippet below\n/// if only std::make_pair(...) is sroa transformed before inlined into hoo.\n///   void goo(const std::pair<int, float> &);\n///   hoo() {\n///     ...\n///     goo(std::make_pair(tmp, ftmp));\n///     ...\n///   }\n///\nSDValue DAGCombiner::splitMergedValStore(StoreSDNode *ST) {\n  if (OptLevel == CodeGenOpt::None)\n    return SDValue();\n\n  // Can't change the number of memory accesses for a volatile store or break\n  // atomicity for an atomic one.\n  if (!ST->isSimple())\n    return SDValue();\n\n  SDValue Val = ST->getValue();\n  SDLoc DL(ST);\n\n  // Match OR operand.\n  if (!Val.getValueType().isScalarInteger() || Val.getOpcode() != ISD::OR)\n    return SDValue();\n\n  // Match SHL operand and get Lower and Higher parts of Val.\n  SDValue Op1 = Val.getOperand(0);\n  SDValue Op2 = Val.getOperand(1);\n  SDValue Lo, Hi;\n  if (Op1.getOpcode() != ISD::SHL) {\n    std::swap(Op1, Op2);\n    if (Op1.getOpcode() != ISD::SHL)\n      return SDValue();\n  }\n  Lo = Op2;\n  Hi = Op1.getOperand(0);\n  if (!Op1.hasOneUse())\n    return SDValue();\n\n  // Match shift amount to HalfValBitSize.\n  unsigned HalfValBitSize = Val.getValueSizeInBits() / 2;\n  ConstantSDNode *ShAmt = dyn_cast<ConstantSDNode>(Op1.getOperand(1));\n  if (!ShAmt || ShAmt->getAPIntValue() != HalfValBitSize)\n    return SDValue();\n\n  // Lo and Hi are zero-extended from int with size less equal than 32\n  // to i64.\n  if (Lo.getOpcode() != ISD::ZERO_EXTEND || !Lo.hasOneUse() ||\n      !Lo.getOperand(0).getValueType().isScalarInteger() ||\n      Lo.getOperand(0).getValueSizeInBits() > HalfValBitSize ||\n      Hi.getOpcode() != ISD::ZERO_EXTEND || !Hi.hasOneUse() ||\n      !Hi.getOperand(0).getValueType().isScalarInteger() ||\n      Hi.getOperand(0).getValueSizeInBits() > HalfValBitSize)\n    return SDValue();\n\n  // Use the EVT of low and high parts before bitcast as the input\n  // of target query.\n  EVT LowTy = (Lo.getOperand(0).getOpcode() == ISD::BITCAST)\n                  ? Lo.getOperand(0).getValueType()\n                  : Lo.getValueType();\n  EVT HighTy = (Hi.getOperand(0).getOpcode() == ISD::BITCAST)\n                   ? Hi.getOperand(0).getValueType()\n                   : Hi.getValueType();\n  if (!TLI.isMultiStoresCheaperThanBitsMerge(LowTy, HighTy))\n    return SDValue();\n\n  // Start to split store.\n  MachineMemOperand::Flags MMOFlags = ST->getMemOperand()->getFlags();\n  AAMDNodes AAInfo = ST->getAAInfo();\n\n  // Change the sizes of Lo and Hi's value types to HalfValBitSize.\n  EVT VT = EVT::getIntegerVT(*DAG.getContext(), HalfValBitSize);\n  Lo = DAG.getNode(ISD::ZERO_EXTEND, DL, VT, Lo.getOperand(0));\n  Hi = DAG.getNode(ISD::ZERO_EXTEND, DL, VT, Hi.getOperand(0));\n\n  SDValue Chain = ST->getChain();\n  SDValue Ptr = ST->getBasePtr();\n  // Lower value store.\n  SDValue St0 = DAG.getStore(Chain, DL, Lo, Ptr, ST->getPointerInfo(),\n                             ST->getOriginalAlign(), MMOFlags, AAInfo);\n  Ptr = DAG.getMemBasePlusOffset(Ptr, TypeSize::Fixed(HalfValBitSize / 8), DL);\n  // Higher value store.\n  SDValue St1 = DAG.getStore(\n      St0, DL, Hi, Ptr, ST->getPointerInfo().getWithOffset(HalfValBitSize / 8),\n      ST->getOriginalAlign(), MMOFlags, AAInfo);\n  return St1;\n}\n\n/// Convert a disguised subvector insertion into a shuffle:\nSDValue DAGCombiner::combineInsertEltToShuffle(SDNode *N, unsigned InsIndex) {\n  assert(N->getOpcode() == ISD::INSERT_VECTOR_ELT &&\n         \"Expected extract_vector_elt\");\n  SDValue InsertVal = N->getOperand(1);\n  SDValue Vec = N->getOperand(0);\n\n  // (insert_vector_elt (vector_shuffle X, Y), (extract_vector_elt X, N),\n  // InsIndex)\n  //   --> (vector_shuffle X, Y) and variations where shuffle operands may be\n  //   CONCAT_VECTORS.\n  if (Vec.getOpcode() == ISD::VECTOR_SHUFFLE && Vec.hasOneUse() &&\n      InsertVal.getOpcode() == ISD::EXTRACT_VECTOR_ELT &&\n      isa<ConstantSDNode>(InsertVal.getOperand(1))) {\n    ShuffleVectorSDNode *SVN = cast<ShuffleVectorSDNode>(Vec.getNode());\n    ArrayRef<int> Mask = SVN->getMask();\n\n    SDValue X = Vec.getOperand(0);\n    SDValue Y = Vec.getOperand(1);\n\n    // Vec's operand 0 is using indices from 0 to N-1 and\n    // operand 1 from N to 2N - 1, where N is the number of\n    // elements in the vectors.\n    SDValue InsertVal0 = InsertVal.getOperand(0);\n    int ElementOffset = -1;\n\n    // We explore the inputs of the shuffle in order to see if we find the\n    // source of the extract_vector_elt. If so, we can use it to modify the\n    // shuffle rather than perform an insert_vector_elt.\n    SmallVector<std::pair<int, SDValue>, 8> ArgWorkList;\n    ArgWorkList.emplace_back(Mask.size(), Y);\n    ArgWorkList.emplace_back(0, X);\n\n    while (!ArgWorkList.empty()) {\n      int ArgOffset;\n      SDValue ArgVal;\n      std::tie(ArgOffset, ArgVal) = ArgWorkList.pop_back_val();\n\n      if (ArgVal == InsertVal0) {\n        ElementOffset = ArgOffset;\n        break;\n      }\n\n      // Peek through concat_vector.\n      if (ArgVal.getOpcode() == ISD::CONCAT_VECTORS) {\n        int CurrentArgOffset =\n            ArgOffset + ArgVal.getValueType().getVectorNumElements();\n        int Step = ArgVal.getOperand(0).getValueType().getVectorNumElements();\n        for (SDValue Op : reverse(ArgVal->ops())) {\n          CurrentArgOffset -= Step;\n          ArgWorkList.emplace_back(CurrentArgOffset, Op);\n        }\n\n        // Make sure we went through all the elements and did not screw up index\n        // computation.\n        assert(CurrentArgOffset == ArgOffset);\n      }\n    }\n\n    if (ElementOffset != -1) {\n      SmallVector<int, 16> NewMask(Mask.begin(), Mask.end());\n\n      auto *ExtrIndex = cast<ConstantSDNode>(InsertVal.getOperand(1));\n      NewMask[InsIndex] = ElementOffset + ExtrIndex->getZExtValue();\n      assert(NewMask[InsIndex] <\n                 (int)(2 * Vec.getValueType().getVectorNumElements()) &&\n             NewMask[InsIndex] >= 0 && \"NewMask[InsIndex] is out of bound\");\n\n      SDValue LegalShuffle =\n              TLI.buildLegalVectorShuffle(Vec.getValueType(), SDLoc(N), X,\n                                          Y, NewMask, DAG);\n      if (LegalShuffle)\n        return LegalShuffle;\n    }\n  }\n\n  // insert_vector_elt V, (bitcast X from vector type), IdxC -->\n  // bitcast(shuffle (bitcast V), (extended X), Mask)\n  // Note: We do not use an insert_subvector node because that requires a\n  // legal subvector type.\n  if (InsertVal.getOpcode() != ISD::BITCAST || !InsertVal.hasOneUse() ||\n      !InsertVal.getOperand(0).getValueType().isVector())\n    return SDValue();\n\n  SDValue SubVec = InsertVal.getOperand(0);\n  SDValue DestVec = N->getOperand(0);\n  EVT SubVecVT = SubVec.getValueType();\n  EVT VT = DestVec.getValueType();\n  unsigned NumSrcElts = SubVecVT.getVectorNumElements();\n  // If the source only has a single vector element, the cost of creating adding\n  // it to a vector is likely to exceed the cost of a insert_vector_elt.\n  if (NumSrcElts == 1)\n    return SDValue();\n  unsigned ExtendRatio = VT.getSizeInBits() / SubVecVT.getSizeInBits();\n  unsigned NumMaskVals = ExtendRatio * NumSrcElts;\n\n  // Step 1: Create a shuffle mask that implements this insert operation. The\n  // vector that we are inserting into will be operand 0 of the shuffle, so\n  // those elements are just 'i'. The inserted subvector is in the first\n  // positions of operand 1 of the shuffle. Example:\n  // insert v4i32 V, (v2i16 X), 2 --> shuffle v8i16 V', X', {0,1,2,3,8,9,6,7}\n  SmallVector<int, 16> Mask(NumMaskVals);\n  for (unsigned i = 0; i != NumMaskVals; ++i) {\n    if (i / NumSrcElts == InsIndex)\n      Mask[i] = (i % NumSrcElts) + NumMaskVals;\n    else\n      Mask[i] = i;\n  }\n\n  // Bail out if the target can not handle the shuffle we want to create.\n  EVT SubVecEltVT = SubVecVT.getVectorElementType();\n  EVT ShufVT = EVT::getVectorVT(*DAG.getContext(), SubVecEltVT, NumMaskVals);\n  if (!TLI.isShuffleMaskLegal(Mask, ShufVT))\n    return SDValue();\n\n  // Step 2: Create a wide vector from the inserted source vector by appending\n  // undefined elements. This is the same size as our destination vector.\n  SDLoc DL(N);\n  SmallVector<SDValue, 8> ConcatOps(ExtendRatio, DAG.getUNDEF(SubVecVT));\n  ConcatOps[0] = SubVec;\n  SDValue PaddedSubV = DAG.getNode(ISD::CONCAT_VECTORS, DL, ShufVT, ConcatOps);\n\n  // Step 3: Shuffle in the padded subvector.\n  SDValue DestVecBC = DAG.getBitcast(ShufVT, DestVec);\n  SDValue Shuf = DAG.getVectorShuffle(ShufVT, DL, DestVecBC, PaddedSubV, Mask);\n  AddToWorklist(PaddedSubV.getNode());\n  AddToWorklist(DestVecBC.getNode());\n  AddToWorklist(Shuf.getNode());\n  return DAG.getBitcast(VT, Shuf);\n}\n\nSDValue DAGCombiner::visitINSERT_VECTOR_ELT(SDNode *N) {\n  SDValue InVec = N->getOperand(0);\n  SDValue InVal = N->getOperand(1);\n  SDValue EltNo = N->getOperand(2);\n  SDLoc DL(N);\n\n  EVT VT = InVec.getValueType();\n  auto *IndexC = dyn_cast<ConstantSDNode>(EltNo);\n\n  // Insert into out-of-bounds element is undefined.\n  if (IndexC && VT.isFixedLengthVector() &&\n      IndexC->getZExtValue() >= VT.getVectorNumElements())\n    return DAG.getUNDEF(VT);\n\n  // Remove redundant insertions:\n  // (insert_vector_elt x (extract_vector_elt x idx) idx) -> x\n  if (InVal.getOpcode() == ISD::EXTRACT_VECTOR_ELT &&\n      InVec == InVal.getOperand(0) && EltNo == InVal.getOperand(1))\n    return InVec;\n\n  if (!IndexC) {\n    // If this is variable insert to undef vector, it might be better to splat:\n    // inselt undef, InVal, EltNo --> build_vector < InVal, InVal, ... >\n    if (InVec.isUndef() && TLI.shouldSplatInsEltVarIndex(VT)) {\n      if (VT.isScalableVector())\n        return DAG.getSplatVector(VT, DL, InVal);\n      else {\n        SmallVector<SDValue, 8> Ops(VT.getVectorNumElements(), InVal);\n        return DAG.getBuildVector(VT, DL, Ops);\n      }\n    }\n    return SDValue();\n  }\n\n  if (VT.isScalableVector())\n    return SDValue();\n\n  unsigned NumElts = VT.getVectorNumElements();\n\n  // We must know which element is being inserted for folds below here.\n  unsigned Elt = IndexC->getZExtValue();\n  if (SDValue Shuf = combineInsertEltToShuffle(N, Elt))\n    return Shuf;\n\n  // Canonicalize insert_vector_elt dag nodes.\n  // Example:\n  // (insert_vector_elt (insert_vector_elt A, Idx0), Idx1)\n  // -> (insert_vector_elt (insert_vector_elt A, Idx1), Idx0)\n  //\n  // Do this only if the child insert_vector node has one use; also\n  // do this only if indices are both constants and Idx1 < Idx0.\n  if (InVec.getOpcode() == ISD::INSERT_VECTOR_ELT && InVec.hasOneUse()\n      && isa<ConstantSDNode>(InVec.getOperand(2))) {\n    unsigned OtherElt = InVec.getConstantOperandVal(2);\n    if (Elt < OtherElt) {\n      // Swap nodes.\n      SDValue NewOp = DAG.getNode(ISD::INSERT_VECTOR_ELT, DL, VT,\n                                  InVec.getOperand(0), InVal, EltNo);\n      AddToWorklist(NewOp.getNode());\n      return DAG.getNode(ISD::INSERT_VECTOR_ELT, SDLoc(InVec.getNode()),\n                         VT, NewOp, InVec.getOperand(1), InVec.getOperand(2));\n    }\n  }\n\n  // If we can't generate a legal BUILD_VECTOR, exit\n  if (LegalOperations && !TLI.isOperationLegal(ISD::BUILD_VECTOR, VT))\n    return SDValue();\n\n  // Check that the operand is a BUILD_VECTOR (or UNDEF, which can essentially\n  // be converted to a BUILD_VECTOR).  Fill in the Ops vector with the\n  // vector elements.\n  SmallVector<SDValue, 8> Ops;\n  // Do not combine these two vectors if the output vector will not replace\n  // the input vector.\n  if (InVec.getOpcode() == ISD::BUILD_VECTOR && InVec.hasOneUse()) {\n    Ops.append(InVec.getNode()->op_begin(),\n               InVec.getNode()->op_end());\n  } else if (InVec.isUndef()) {\n    Ops.append(NumElts, DAG.getUNDEF(InVal.getValueType()));\n  } else {\n    return SDValue();\n  }\n  assert(Ops.size() == NumElts && \"Unexpected vector size\");\n\n  // Insert the element\n  if (Elt < Ops.size()) {\n    // All the operands of BUILD_VECTOR must have the same type;\n    // we enforce that here.\n    EVT OpVT = Ops[0].getValueType();\n    Ops[Elt] = OpVT.isInteger() ? DAG.getAnyExtOrTrunc(InVal, DL, OpVT) : InVal;\n  }\n\n  // Return the new vector\n  return DAG.getBuildVector(VT, DL, Ops);\n}\n\nSDValue DAGCombiner::scalarizeExtractedVectorLoad(SDNode *EVE, EVT InVecVT,\n                                                  SDValue EltNo,\n                                                  LoadSDNode *OriginalLoad) {\n  assert(OriginalLoad->isSimple());\n\n  EVT ResultVT = EVE->getValueType(0);\n  EVT VecEltVT = InVecVT.getVectorElementType();\n\n  // If the vector element type is not a multiple of a byte then we are unable\n  // to correctly compute an address to load only the extracted element as a\n  // scalar.\n  if (!VecEltVT.isByteSized())\n    return SDValue();\n\n  Align Alignment = OriginalLoad->getAlign();\n  Align NewAlign = DAG.getDataLayout().getABITypeAlign(\n      VecEltVT.getTypeForEVT(*DAG.getContext()));\n\n  if (NewAlign > Alignment ||\n      !TLI.isOperationLegalOrCustom(ISD::LOAD, VecEltVT))\n    return SDValue();\n\n  ISD::LoadExtType ExtTy = ResultVT.bitsGT(VecEltVT) ?\n    ISD::NON_EXTLOAD : ISD::EXTLOAD;\n  if (!TLI.shouldReduceLoadWidth(OriginalLoad, ExtTy, VecEltVT))\n    return SDValue();\n\n  Alignment = NewAlign;\n\n  SDValue NewPtr = OriginalLoad->getBasePtr();\n  SDValue Offset;\n  EVT PtrType = NewPtr.getValueType();\n  MachinePointerInfo MPI;\n  SDLoc DL(EVE);\n  if (auto *ConstEltNo = dyn_cast<ConstantSDNode>(EltNo)) {\n    int Elt = ConstEltNo->getZExtValue();\n    unsigned PtrOff = VecEltVT.getSizeInBits() * Elt / 8;\n    Offset = DAG.getConstant(PtrOff, DL, PtrType);\n    MPI = OriginalLoad->getPointerInfo().getWithOffset(PtrOff);\n  } else {\n    Offset = DAG.getZExtOrTrunc(EltNo, DL, PtrType);\n    Offset = DAG.getNode(\n        ISD::MUL, DL, PtrType, Offset,\n        DAG.getConstant(VecEltVT.getStoreSize(), DL, PtrType));\n    // Discard the pointer info except the address space because the memory\n    // operand can't represent this new access since the offset is variable.\n    MPI = MachinePointerInfo(OriginalLoad->getPointerInfo().getAddrSpace());\n  }\n  NewPtr = DAG.getMemBasePlusOffset(NewPtr, Offset, DL);\n\n  // The replacement we need to do here is a little tricky: we need to\n  // replace an extractelement of a load with a load.\n  // Use ReplaceAllUsesOfValuesWith to do the replacement.\n  // Note that this replacement assumes that the extractvalue is the only\n  // use of the load; that's okay because we don't want to perform this\n  // transformation in other cases anyway.\n  SDValue Load;\n  SDValue Chain;\n  if (ResultVT.bitsGT(VecEltVT)) {\n    // If the result type of vextract is wider than the load, then issue an\n    // extending load instead.\n    ISD::LoadExtType ExtType = TLI.isLoadExtLegal(ISD::ZEXTLOAD, ResultVT,\n                                                  VecEltVT)\n                                   ? ISD::ZEXTLOAD\n                                   : ISD::EXTLOAD;\n    Load = DAG.getExtLoad(ExtType, SDLoc(EVE), ResultVT,\n                          OriginalLoad->getChain(), NewPtr, MPI, VecEltVT,\n                          Alignment, OriginalLoad->getMemOperand()->getFlags(),\n                          OriginalLoad->getAAInfo());\n    Chain = Load.getValue(1);\n  } else {\n    Load = DAG.getLoad(\n        VecEltVT, SDLoc(EVE), OriginalLoad->getChain(), NewPtr, MPI, Alignment,\n        OriginalLoad->getMemOperand()->getFlags(), OriginalLoad->getAAInfo());\n    Chain = Load.getValue(1);\n    if (ResultVT.bitsLT(VecEltVT))\n      Load = DAG.getNode(ISD::TRUNCATE, SDLoc(EVE), ResultVT, Load);\n    else\n      Load = DAG.getBitcast(ResultVT, Load);\n  }\n  WorklistRemover DeadNodes(*this);\n  SDValue From[] = { SDValue(EVE, 0), SDValue(OriginalLoad, 1) };\n  SDValue To[] = { Load, Chain };\n  DAG.ReplaceAllUsesOfValuesWith(From, To, 2);\n  // Make sure to revisit this node to clean it up; it will usually be dead.\n  AddToWorklist(EVE);\n  // Since we're explicitly calling ReplaceAllUses, add the new node to the\n  // worklist explicitly as well.\n  AddToWorklistWithUsers(Load.getNode());\n  ++OpsNarrowed;\n  return SDValue(EVE, 0);\n}\n\n/// Transform a vector binary operation into a scalar binary operation by moving\n/// the math/logic after an extract element of a vector.\nstatic SDValue scalarizeExtractedBinop(SDNode *ExtElt, SelectionDAG &DAG,\n                                       bool LegalOperations) {\n  const TargetLowering &TLI = DAG.getTargetLoweringInfo();\n  SDValue Vec = ExtElt->getOperand(0);\n  SDValue Index = ExtElt->getOperand(1);\n  auto *IndexC = dyn_cast<ConstantSDNode>(Index);\n  if (!IndexC || !TLI.isBinOp(Vec.getOpcode()) || !Vec.hasOneUse() ||\n      Vec.getNode()->getNumValues() != 1)\n    return SDValue();\n\n  // Targets may want to avoid this to prevent an expensive register transfer.\n  if (!TLI.shouldScalarizeBinop(Vec))\n    return SDValue();\n\n  // Extracting an element of a vector constant is constant-folded, so this\n  // transform is just replacing a vector op with a scalar op while moving the\n  // extract.\n  SDValue Op0 = Vec.getOperand(0);\n  SDValue Op1 = Vec.getOperand(1);\n  if (isAnyConstantBuildVector(Op0, true) ||\n      isAnyConstantBuildVector(Op1, true)) {\n    // extractelt (binop X, C), IndexC --> binop (extractelt X, IndexC), C'\n    // extractelt (binop C, X), IndexC --> binop C', (extractelt X, IndexC)\n    SDLoc DL(ExtElt);\n    EVT VT = ExtElt->getValueType(0);\n    SDValue Ext0 = DAG.getNode(ISD::EXTRACT_VECTOR_ELT, DL, VT, Op0, Index);\n    SDValue Ext1 = DAG.getNode(ISD::EXTRACT_VECTOR_ELT, DL, VT, Op1, Index);\n    return DAG.getNode(Vec.getOpcode(), DL, VT, Ext0, Ext1);\n  }\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitEXTRACT_VECTOR_ELT(SDNode *N) {\n  SDValue VecOp = N->getOperand(0);\n  SDValue Index = N->getOperand(1);\n  EVT ScalarVT = N->getValueType(0);\n  EVT VecVT = VecOp.getValueType();\n  if (VecOp.isUndef())\n    return DAG.getUNDEF(ScalarVT);\n\n  // extract_vector_elt (insert_vector_elt vec, val, idx), idx) -> val\n  //\n  // This only really matters if the index is non-constant since other combines\n  // on the constant elements already work.\n  SDLoc DL(N);\n  if (VecOp.getOpcode() == ISD::INSERT_VECTOR_ELT &&\n      Index == VecOp.getOperand(2)) {\n    SDValue Elt = VecOp.getOperand(1);\n    return VecVT.isInteger() ? DAG.getAnyExtOrTrunc(Elt, DL, ScalarVT) : Elt;\n  }\n\n  // (vextract (scalar_to_vector val, 0) -> val\n  if (VecOp.getOpcode() == ISD::SCALAR_TO_VECTOR) {\n    // Only 0'th element of SCALAR_TO_VECTOR is defined.\n    if (DAG.isKnownNeverZero(Index))\n      return DAG.getUNDEF(ScalarVT);\n\n    // Check if the result type doesn't match the inserted element type. A\n    // SCALAR_TO_VECTOR may truncate the inserted element and the\n    // EXTRACT_VECTOR_ELT may widen the extracted vector.\n    SDValue InOp = VecOp.getOperand(0);\n    if (InOp.getValueType() != ScalarVT) {\n      assert(InOp.getValueType().isInteger() && ScalarVT.isInteger());\n      return DAG.getSExtOrTrunc(InOp, DL, ScalarVT);\n    }\n    return InOp;\n  }\n\n  // extract_vector_elt of out-of-bounds element -> UNDEF\n  auto *IndexC = dyn_cast<ConstantSDNode>(Index);\n  if (IndexC && VecVT.isFixedLengthVector() &&\n      IndexC->getAPIntValue().uge(VecVT.getVectorNumElements()))\n    return DAG.getUNDEF(ScalarVT);\n\n  // extract_vector_elt (build_vector x, y), 1 -> y\n  if (((IndexC && VecOp.getOpcode() == ISD::BUILD_VECTOR) ||\n       VecOp.getOpcode() == ISD::SPLAT_VECTOR) &&\n      TLI.isTypeLegal(VecVT) &&\n      (VecOp.hasOneUse() || TLI.aggressivelyPreferBuildVectorSources(VecVT))) {\n    assert((VecOp.getOpcode() != ISD::BUILD_VECTOR ||\n            VecVT.isFixedLengthVector()) &&\n           \"BUILD_VECTOR used for scalable vectors\");\n    unsigned IndexVal =\n        VecOp.getOpcode() == ISD::BUILD_VECTOR ? IndexC->getZExtValue() : 0;\n    SDValue Elt = VecOp.getOperand(IndexVal);\n    EVT InEltVT = Elt.getValueType();\n\n    // Sometimes build_vector's scalar input types do not match result type.\n    if (ScalarVT == InEltVT)\n      return Elt;\n\n    // TODO: It may be useful to truncate if free if the build_vector implicitly\n    // converts.\n  }\n\n  if (VecVT.isScalableVector())\n    return SDValue();\n\n  // All the code from this point onwards assumes fixed width vectors, but it's\n  // possible that some of the combinations could be made to work for scalable\n  // vectors too.\n  unsigned NumElts = VecVT.getVectorNumElements();\n  unsigned VecEltBitWidth = VecVT.getScalarSizeInBits();\n\n  // TODO: These transforms should not require the 'hasOneUse' restriction, but\n  // there are regressions on multiple targets without it. We can end up with a\n  // mess of scalar and vector code if we reduce only part of the DAG to scalar.\n  if (IndexC && VecOp.getOpcode() == ISD::BITCAST && VecVT.isInteger() &&\n      VecOp.hasOneUse()) {\n    // The vector index of the LSBs of the source depend on the endian-ness.\n    bool IsLE = DAG.getDataLayout().isLittleEndian();\n    unsigned ExtractIndex = IndexC->getZExtValue();\n    // extract_elt (v2i32 (bitcast i64:x)), BCTruncElt -> i32 (trunc i64:x)\n    unsigned BCTruncElt = IsLE ? 0 : NumElts - 1;\n    SDValue BCSrc = VecOp.getOperand(0);\n    if (ExtractIndex == BCTruncElt && BCSrc.getValueType().isScalarInteger())\n      return DAG.getNode(ISD::TRUNCATE, DL, ScalarVT, BCSrc);\n\n    if (LegalTypes && BCSrc.getValueType().isInteger() &&\n        BCSrc.getOpcode() == ISD::SCALAR_TO_VECTOR) {\n      // ext_elt (bitcast (scalar_to_vec i64 X to v2i64) to v4i32), TruncElt -->\n      // trunc i64 X to i32\n      SDValue X = BCSrc.getOperand(0);\n      assert(X.getValueType().isScalarInteger() && ScalarVT.isScalarInteger() &&\n             \"Extract element and scalar to vector can't change element type \"\n             \"from FP to integer.\");\n      unsigned XBitWidth = X.getValueSizeInBits();\n      BCTruncElt = IsLE ? 0 : XBitWidth / VecEltBitWidth - 1;\n\n      // An extract element return value type can be wider than its vector\n      // operand element type. In that case, the high bits are undefined, so\n      // it's possible that we may need to extend rather than truncate.\n      if (ExtractIndex == BCTruncElt && XBitWidth > VecEltBitWidth) {\n        assert(XBitWidth % VecEltBitWidth == 0 &&\n               \"Scalar bitwidth must be a multiple of vector element bitwidth\");\n        return DAG.getAnyExtOrTrunc(X, DL, ScalarVT);\n      }\n    }\n  }\n\n  if (SDValue BO = scalarizeExtractedBinop(N, DAG, LegalOperations))\n    return BO;\n\n  // Transform: (EXTRACT_VECTOR_ELT( VECTOR_SHUFFLE )) -> EXTRACT_VECTOR_ELT.\n  // We only perform this optimization before the op legalization phase because\n  // we may introduce new vector instructions which are not backed by TD\n  // patterns. For example on AVX, extracting elements from a wide vector\n  // without using extract_subvector. However, if we can find an underlying\n  // scalar value, then we can always use that.\n  if (IndexC && VecOp.getOpcode() == ISD::VECTOR_SHUFFLE) {\n    auto *Shuf = cast<ShuffleVectorSDNode>(VecOp);\n    // Find the new index to extract from.\n    int OrigElt = Shuf->getMaskElt(IndexC->getZExtValue());\n\n    // Extracting an undef index is undef.\n    if (OrigElt == -1)\n      return DAG.getUNDEF(ScalarVT);\n\n    // Select the right vector half to extract from.\n    SDValue SVInVec;\n    if (OrigElt < (int)NumElts) {\n      SVInVec = VecOp.getOperand(0);\n    } else {\n      SVInVec = VecOp.getOperand(1);\n      OrigElt -= NumElts;\n    }\n\n    if (SVInVec.getOpcode() == ISD::BUILD_VECTOR) {\n      SDValue InOp = SVInVec.getOperand(OrigElt);\n      if (InOp.getValueType() != ScalarVT) {\n        assert(InOp.getValueType().isInteger() && ScalarVT.isInteger());\n        InOp = DAG.getSExtOrTrunc(InOp, DL, ScalarVT);\n      }\n\n      return InOp;\n    }\n\n    // FIXME: We should handle recursing on other vector shuffles and\n    // scalar_to_vector here as well.\n\n    if (!LegalOperations ||\n        // FIXME: Should really be just isOperationLegalOrCustom.\n        TLI.isOperationLegal(ISD::EXTRACT_VECTOR_ELT, VecVT) ||\n        TLI.isOperationExpand(ISD::VECTOR_SHUFFLE, VecVT)) {\n      return DAG.getNode(ISD::EXTRACT_VECTOR_ELT, DL, ScalarVT, SVInVec,\n                         DAG.getVectorIdxConstant(OrigElt, DL));\n    }\n  }\n\n  // If only EXTRACT_VECTOR_ELT nodes use the source vector we can\n  // simplify it based on the (valid) extraction indices.\n  if (llvm::all_of(VecOp->uses(), [&](SDNode *Use) {\n        return Use->getOpcode() == ISD::EXTRACT_VECTOR_ELT &&\n               Use->getOperand(0) == VecOp &&\n               isa<ConstantSDNode>(Use->getOperand(1));\n      })) {\n    APInt DemandedElts = APInt::getNullValue(NumElts);\n    for (SDNode *Use : VecOp->uses()) {\n      auto *CstElt = cast<ConstantSDNode>(Use->getOperand(1));\n      if (CstElt->getAPIntValue().ult(NumElts))\n        DemandedElts.setBit(CstElt->getZExtValue());\n    }\n    if (SimplifyDemandedVectorElts(VecOp, DemandedElts, true)) {\n      // We simplified the vector operand of this extract element. If this\n      // extract is not dead, visit it again so it is folded properly.\n      if (N->getOpcode() != ISD::DELETED_NODE)\n        AddToWorklist(N);\n      return SDValue(N, 0);\n    }\n    APInt DemandedBits = APInt::getAllOnesValue(VecEltBitWidth);\n    if (SimplifyDemandedBits(VecOp, DemandedBits, DemandedElts, true)) {\n      // We simplified the vector operand of this extract element. If this\n      // extract is not dead, visit it again so it is folded properly.\n      if (N->getOpcode() != ISD::DELETED_NODE)\n        AddToWorklist(N);\n      return SDValue(N, 0);\n    }\n  }\n\n  // Everything under here is trying to match an extract of a loaded value.\n  // If the result of load has to be truncated, then it's not necessarily\n  // profitable.\n  bool BCNumEltsChanged = false;\n  EVT ExtVT = VecVT.getVectorElementType();\n  EVT LVT = ExtVT;\n  if (ScalarVT.bitsLT(LVT) && !TLI.isTruncateFree(LVT, ScalarVT))\n    return SDValue();\n\n  if (VecOp.getOpcode() == ISD::BITCAST) {\n    // Don't duplicate a load with other uses.\n    if (!VecOp.hasOneUse())\n      return SDValue();\n\n    EVT BCVT = VecOp.getOperand(0).getValueType();\n    if (!BCVT.isVector() || ExtVT.bitsGT(BCVT.getVectorElementType()))\n      return SDValue();\n    if (NumElts != BCVT.getVectorNumElements())\n      BCNumEltsChanged = true;\n    VecOp = VecOp.getOperand(0);\n    ExtVT = BCVT.getVectorElementType();\n  }\n\n  // extract (vector load $addr), i --> load $addr + i * size\n  if (!LegalOperations && !IndexC && VecOp.hasOneUse() &&\n      ISD::isNormalLoad(VecOp.getNode()) &&\n      !Index->hasPredecessor(VecOp.getNode())) {\n    auto *VecLoad = dyn_cast<LoadSDNode>(VecOp);\n    if (VecLoad && VecLoad->isSimple())\n      return scalarizeExtractedVectorLoad(N, VecVT, Index, VecLoad);\n  }\n\n  // Perform only after legalization to ensure build_vector / vector_shuffle\n  // optimizations have already been done.\n  if (!LegalOperations || !IndexC)\n    return SDValue();\n\n  // (vextract (v4f32 load $addr), c) -> (f32 load $addr+c*size)\n  // (vextract (v4f32 s2v (f32 load $addr)), c) -> (f32 load $addr+c*size)\n  // (vextract (v4f32 shuffle (load $addr), <1,u,u,u>), 0) -> (f32 load $addr)\n  int Elt = IndexC->getZExtValue();\n  LoadSDNode *LN0 = nullptr;\n  if (ISD::isNormalLoad(VecOp.getNode())) {\n    LN0 = cast<LoadSDNode>(VecOp);\n  } else if (VecOp.getOpcode() == ISD::SCALAR_TO_VECTOR &&\n             VecOp.getOperand(0).getValueType() == ExtVT &&\n             ISD::isNormalLoad(VecOp.getOperand(0).getNode())) {\n    // Don't duplicate a load with other uses.\n    if (!VecOp.hasOneUse())\n      return SDValue();\n\n    LN0 = cast<LoadSDNode>(VecOp.getOperand(0));\n  }\n  if (auto *Shuf = dyn_cast<ShuffleVectorSDNode>(VecOp)) {\n    // (vextract (vector_shuffle (load $addr), v2, <1, u, u, u>), 1)\n    // =>\n    // (load $addr+1*size)\n\n    // Don't duplicate a load with other uses.\n    if (!VecOp.hasOneUse())\n      return SDValue();\n\n    // If the bit convert changed the number of elements, it is unsafe\n    // to examine the mask.\n    if (BCNumEltsChanged)\n      return SDValue();\n\n    // Select the input vector, guarding against out of range extract vector.\n    int Idx = (Elt > (int)NumElts) ? -1 : Shuf->getMaskElt(Elt);\n    VecOp = (Idx < (int)NumElts) ? VecOp.getOperand(0) : VecOp.getOperand(1);\n\n    if (VecOp.getOpcode() == ISD::BITCAST) {\n      // Don't duplicate a load with other uses.\n      if (!VecOp.hasOneUse())\n        return SDValue();\n\n      VecOp = VecOp.getOperand(0);\n    }\n    if (ISD::isNormalLoad(VecOp.getNode())) {\n      LN0 = cast<LoadSDNode>(VecOp);\n      Elt = (Idx < (int)NumElts) ? Idx : Idx - (int)NumElts;\n      Index = DAG.getConstant(Elt, DL, Index.getValueType());\n    }\n  } else if (VecOp.getOpcode() == ISD::CONCAT_VECTORS && !BCNumEltsChanged &&\n             VecVT.getVectorElementType() == ScalarVT &&\n             (!LegalTypes ||\n              TLI.isTypeLegal(\n                  VecOp.getOperand(0).getValueType().getVectorElementType()))) {\n    // extract_vector_elt (concat_vectors v2i16:a, v2i16:b), 0\n    //      -> extract_vector_elt a, 0\n    // extract_vector_elt (concat_vectors v2i16:a, v2i16:b), 1\n    //      -> extract_vector_elt a, 1\n    // extract_vector_elt (concat_vectors v2i16:a, v2i16:b), 2\n    //      -> extract_vector_elt b, 0\n    // extract_vector_elt (concat_vectors v2i16:a, v2i16:b), 3\n    //      -> extract_vector_elt b, 1\n    SDLoc SL(N);\n    EVT ConcatVT = VecOp.getOperand(0).getValueType();\n    unsigned ConcatNumElts = ConcatVT.getVectorNumElements();\n    SDValue NewIdx = DAG.getConstant(Elt % ConcatNumElts, SL,\n                                     Index.getValueType());\n\n    SDValue ConcatOp = VecOp.getOperand(Elt / ConcatNumElts);\n    SDValue Elt = DAG.getNode(ISD::EXTRACT_VECTOR_ELT, SL,\n                              ConcatVT.getVectorElementType(),\n                              ConcatOp, NewIdx);\n    return DAG.getNode(ISD::BITCAST, SL, ScalarVT, Elt);\n  }\n\n  // Make sure we found a non-volatile load and the extractelement is\n  // the only use.\n  if (!LN0 || !LN0->hasNUsesOfValue(1,0) || !LN0->isSimple())\n    return SDValue();\n\n  // If Idx was -1 above, Elt is going to be -1, so just return undef.\n  if (Elt == -1)\n    return DAG.getUNDEF(LVT);\n\n  return scalarizeExtractedVectorLoad(N, VecVT, Index, LN0);\n}\n\n// Simplify (build_vec (ext )) to (bitcast (build_vec ))\nSDValue DAGCombiner::reduceBuildVecExtToExtBuildVec(SDNode *N) {\n  // We perform this optimization post type-legalization because\n  // the type-legalizer often scalarizes integer-promoted vectors.\n  // Performing this optimization before may create bit-casts which\n  // will be type-legalized to complex code sequences.\n  // We perform this optimization only before the operation legalizer because we\n  // may introduce illegal operations.\n  if (Level != AfterLegalizeVectorOps && Level != AfterLegalizeTypes)\n    return SDValue();\n\n  unsigned NumInScalars = N->getNumOperands();\n  SDLoc DL(N);\n  EVT VT = N->getValueType(0);\n\n  // Check to see if this is a BUILD_VECTOR of a bunch of values\n  // which come from any_extend or zero_extend nodes. If so, we can create\n  // a new BUILD_VECTOR using bit-casts which may enable other BUILD_VECTOR\n  // optimizations. We do not handle sign-extend because we can't fill the sign\n  // using shuffles.\n  EVT SourceType = MVT::Other;\n  bool AllAnyExt = true;\n\n  for (unsigned i = 0; i != NumInScalars; ++i) {\n    SDValue In = N->getOperand(i);\n    // Ignore undef inputs.\n    if (In.isUndef()) continue;\n\n    bool AnyExt  = In.getOpcode() == ISD::ANY_EXTEND;\n    bool ZeroExt = In.getOpcode() == ISD::ZERO_EXTEND;\n\n    // Abort if the element is not an extension.\n    if (!ZeroExt && !AnyExt) {\n      SourceType = MVT::Other;\n      break;\n    }\n\n    // The input is a ZeroExt or AnyExt. Check the original type.\n    EVT InTy = In.getOperand(0).getValueType();\n\n    // Check that all of the widened source types are the same.\n    if (SourceType == MVT::Other)\n      // First time.\n      SourceType = InTy;\n    else if (InTy != SourceType) {\n      // Multiple income types. Abort.\n      SourceType = MVT::Other;\n      break;\n    }\n\n    // Check if all of the extends are ANY_EXTENDs.\n    AllAnyExt &= AnyExt;\n  }\n\n  // In order to have valid types, all of the inputs must be extended from the\n  // same source type and all of the inputs must be any or zero extend.\n  // Scalar sizes must be a power of two.\n  EVT OutScalarTy = VT.getScalarType();\n  bool ValidTypes = SourceType != MVT::Other &&\n                 isPowerOf2_32(OutScalarTy.getSizeInBits()) &&\n                 isPowerOf2_32(SourceType.getSizeInBits());\n\n  // Create a new simpler BUILD_VECTOR sequence which other optimizations can\n  // turn into a single shuffle instruction.\n  if (!ValidTypes)\n    return SDValue();\n\n  // If we already have a splat buildvector, then don't fold it if it means\n  // introducing zeros.\n  if (!AllAnyExt && DAG.isSplatValue(SDValue(N, 0), /*AllowUndefs*/ true))\n    return SDValue();\n\n  bool isLE = DAG.getDataLayout().isLittleEndian();\n  unsigned ElemRatio = OutScalarTy.getSizeInBits()/SourceType.getSizeInBits();\n  assert(ElemRatio > 1 && \"Invalid element size ratio\");\n  SDValue Filler = AllAnyExt ? DAG.getUNDEF(SourceType):\n                               DAG.getConstant(0, DL, SourceType);\n\n  unsigned NewBVElems = ElemRatio * VT.getVectorNumElements();\n  SmallVector<SDValue, 8> Ops(NewBVElems, Filler);\n\n  // Populate the new build_vector\n  for (unsigned i = 0, e = N->getNumOperands(); i != e; ++i) {\n    SDValue Cast = N->getOperand(i);\n    assert((Cast.getOpcode() == ISD::ANY_EXTEND ||\n            Cast.getOpcode() == ISD::ZERO_EXTEND ||\n            Cast.isUndef()) && \"Invalid cast opcode\");\n    SDValue In;\n    if (Cast.isUndef())\n      In = DAG.getUNDEF(SourceType);\n    else\n      In = Cast->getOperand(0);\n    unsigned Index = isLE ? (i * ElemRatio) :\n                            (i * ElemRatio + (ElemRatio - 1));\n\n    assert(Index < Ops.size() && \"Invalid index\");\n    Ops[Index] = In;\n  }\n\n  // The type of the new BUILD_VECTOR node.\n  EVT VecVT = EVT::getVectorVT(*DAG.getContext(), SourceType, NewBVElems);\n  assert(VecVT.getSizeInBits() == VT.getSizeInBits() &&\n         \"Invalid vector size\");\n  // Check if the new vector type is legal.\n  if (!isTypeLegal(VecVT) ||\n      (!TLI.isOperationLegal(ISD::BUILD_VECTOR, VecVT) &&\n       TLI.isOperationLegal(ISD::BUILD_VECTOR, VT)))\n    return SDValue();\n\n  // Make the new BUILD_VECTOR.\n  SDValue BV = DAG.getBuildVector(VecVT, DL, Ops);\n\n  // The new BUILD_VECTOR node has the potential to be further optimized.\n  AddToWorklist(BV.getNode());\n  // Bitcast to the desired type.\n  return DAG.getBitcast(VT, BV);\n}\n\n// Simplify (build_vec (trunc $1)\n//                     (trunc (srl $1 half-width))\n//                     (trunc (srl $1 (2 * half-width))) \u2026)\n// to (bitcast $1)\nSDValue DAGCombiner::reduceBuildVecTruncToBitCast(SDNode *N) {\n  assert(N->getOpcode() == ISD::BUILD_VECTOR && \"Expected build vector\");\n\n  // Only for little endian\n  if (!DAG.getDataLayout().isLittleEndian())\n    return SDValue();\n\n  SDLoc DL(N);\n  EVT VT = N->getValueType(0);\n  EVT OutScalarTy = VT.getScalarType();\n  uint64_t ScalarTypeBitsize = OutScalarTy.getSizeInBits();\n\n  // Only for power of two types to be sure that bitcast works well\n  if (!isPowerOf2_64(ScalarTypeBitsize))\n    return SDValue();\n\n  unsigned NumInScalars = N->getNumOperands();\n\n  // Look through bitcasts\n  auto PeekThroughBitcast = [](SDValue Op) {\n    if (Op.getOpcode() == ISD::BITCAST)\n      return Op.getOperand(0);\n    return Op;\n  };\n\n  // The source value where all the parts are extracted.\n  SDValue Src;\n  for (unsigned i = 0; i != NumInScalars; ++i) {\n    SDValue In = PeekThroughBitcast(N->getOperand(i));\n    // Ignore undef inputs.\n    if (In.isUndef()) continue;\n\n    if (In.getOpcode() != ISD::TRUNCATE)\n      return SDValue();\n\n    In = PeekThroughBitcast(In.getOperand(0));\n\n    if (In.getOpcode() != ISD::SRL) {\n      // For now only build_vec without shuffling, handle shifts here in the\n      // future.\n      if (i != 0)\n        return SDValue();\n\n      Src = In;\n    } else {\n      // In is SRL\n      SDValue part = PeekThroughBitcast(In.getOperand(0));\n\n      if (!Src) {\n        Src = part;\n      } else if (Src != part) {\n        // Vector parts do not stem from the same variable\n        return SDValue();\n      }\n\n      SDValue ShiftAmtVal = In.getOperand(1);\n      if (!isa<ConstantSDNode>(ShiftAmtVal))\n        return SDValue();\n\n      uint64_t ShiftAmt = In.getNode()->getConstantOperandVal(1);\n\n      // The extracted value is not extracted at the right position\n      if (ShiftAmt != i * ScalarTypeBitsize)\n        return SDValue();\n    }\n  }\n\n  // Only cast if the size is the same\n  if (Src.getValueType().getSizeInBits() != VT.getSizeInBits())\n    return SDValue();\n\n  return DAG.getBitcast(VT, Src);\n}\n\nSDValue DAGCombiner::createBuildVecShuffle(const SDLoc &DL, SDNode *N,\n                                           ArrayRef<int> VectorMask,\n                                           SDValue VecIn1, SDValue VecIn2,\n                                           unsigned LeftIdx, bool DidSplitVec) {\n  SDValue ZeroIdx = DAG.getVectorIdxConstant(0, DL);\n\n  EVT VT = N->getValueType(0);\n  EVT InVT1 = VecIn1.getValueType();\n  EVT InVT2 = VecIn2.getNode() ? VecIn2.getValueType() : InVT1;\n\n  unsigned NumElems = VT.getVectorNumElements();\n  unsigned ShuffleNumElems = NumElems;\n\n  // If we artificially split a vector in two already, then the offsets in the\n  // operands will all be based off of VecIn1, even those in VecIn2.\n  unsigned Vec2Offset = DidSplitVec ? 0 : InVT1.getVectorNumElements();\n\n  uint64_t VTSize = VT.getFixedSizeInBits();\n  uint64_t InVT1Size = InVT1.getFixedSizeInBits();\n  uint64_t InVT2Size = InVT2.getFixedSizeInBits();\n\n  // We can't generate a shuffle node with mismatched input and output types.\n  // Try to make the types match the type of the output.\n  if (InVT1 != VT || InVT2 != VT) {\n    if ((VTSize % InVT1Size == 0) && InVT1 == InVT2) {\n      // If the output vector length is a multiple of both input lengths,\n      // we can concatenate them and pad the rest with undefs.\n      unsigned NumConcats = VTSize / InVT1Size;\n      assert(NumConcats >= 2 && \"Concat needs at least two inputs!\");\n      SmallVector<SDValue, 2> ConcatOps(NumConcats, DAG.getUNDEF(InVT1));\n      ConcatOps[0] = VecIn1;\n      ConcatOps[1] = VecIn2 ? VecIn2 : DAG.getUNDEF(InVT1);\n      VecIn1 = DAG.getNode(ISD::CONCAT_VECTORS, DL, VT, ConcatOps);\n      VecIn2 = SDValue();\n    } else if (InVT1Size == VTSize * 2) {\n      if (!TLI.isExtractSubvectorCheap(VT, InVT1, NumElems))\n        return SDValue();\n\n      if (!VecIn2.getNode()) {\n        // If we only have one input vector, and it's twice the size of the\n        // output, split it in two.\n        VecIn2 = DAG.getNode(ISD::EXTRACT_SUBVECTOR, DL, VT, VecIn1,\n                             DAG.getVectorIdxConstant(NumElems, DL));\n        VecIn1 = DAG.getNode(ISD::EXTRACT_SUBVECTOR, DL, VT, VecIn1, ZeroIdx);\n        // Since we now have shorter input vectors, adjust the offset of the\n        // second vector's start.\n        Vec2Offset = NumElems;\n      } else if (InVT2Size <= InVT1Size) {\n        // VecIn1 is wider than the output, and we have another, possibly\n        // smaller input. Pad the smaller input with undefs, shuffle at the\n        // input vector width, and extract the output.\n        // The shuffle type is different than VT, so check legality again.\n        if (LegalOperations &&\n            !TLI.isOperationLegal(ISD::VECTOR_SHUFFLE, InVT1))\n          return SDValue();\n\n        // Legalizing INSERT_SUBVECTOR is tricky - you basically have to\n        // lower it back into a BUILD_VECTOR. So if the inserted type is\n        // illegal, don't even try.\n        if (InVT1 != InVT2) {\n          if (!TLI.isTypeLegal(InVT2))\n            return SDValue();\n          VecIn2 = DAG.getNode(ISD::INSERT_SUBVECTOR, DL, InVT1,\n                               DAG.getUNDEF(InVT1), VecIn2, ZeroIdx);\n        }\n        ShuffleNumElems = NumElems * 2;\n      } else {\n        // Both VecIn1 and VecIn2 are wider than the output, and VecIn2 is wider\n        // than VecIn1. We can't handle this for now - this case will disappear\n        // when we start sorting the vectors by type.\n        return SDValue();\n      }\n    } else if (InVT2Size * 2 == VTSize && InVT1Size == VTSize) {\n      SmallVector<SDValue, 2> ConcatOps(2, DAG.getUNDEF(InVT2));\n      ConcatOps[0] = VecIn2;\n      VecIn2 = DAG.getNode(ISD::CONCAT_VECTORS, DL, VT, ConcatOps);\n    } else {\n      // TODO: Support cases where the length mismatch isn't exactly by a\n      // factor of 2.\n      // TODO: Move this check upwards, so that if we have bad type\n      // mismatches, we don't create any DAG nodes.\n      return SDValue();\n    }\n  }\n\n  // Initialize mask to undef.\n  SmallVector<int, 8> Mask(ShuffleNumElems, -1);\n\n  // Only need to run up to the number of elements actually used, not the\n  // total number of elements in the shuffle - if we are shuffling a wider\n  // vector, the high lanes should be set to undef.\n  for (unsigned i = 0; i != NumElems; ++i) {\n    if (VectorMask[i] <= 0)\n      continue;\n\n    unsigned ExtIndex = N->getOperand(i).getConstantOperandVal(1);\n    if (VectorMask[i] == (int)LeftIdx) {\n      Mask[i] = ExtIndex;\n    } else if (VectorMask[i] == (int)LeftIdx + 1) {\n      Mask[i] = Vec2Offset + ExtIndex;\n    }\n  }\n\n  // The type the input vectors may have changed above.\n  InVT1 = VecIn1.getValueType();\n\n  // If we already have a VecIn2, it should have the same type as VecIn1.\n  // If we don't, get an undef/zero vector of the appropriate type.\n  VecIn2 = VecIn2.getNode() ? VecIn2 : DAG.getUNDEF(InVT1);\n  assert(InVT1 == VecIn2.getValueType() && \"Unexpected second input type.\");\n\n  SDValue Shuffle = DAG.getVectorShuffle(InVT1, DL, VecIn1, VecIn2, Mask);\n  if (ShuffleNumElems > NumElems)\n    Shuffle = DAG.getNode(ISD::EXTRACT_SUBVECTOR, DL, VT, Shuffle, ZeroIdx);\n\n  return Shuffle;\n}\n\nstatic SDValue reduceBuildVecToShuffleWithZero(SDNode *BV, SelectionDAG &DAG) {\n  assert(BV->getOpcode() == ISD::BUILD_VECTOR && \"Expected build vector\");\n\n  // First, determine where the build vector is not undef.\n  // TODO: We could extend this to handle zero elements as well as undefs.\n  int NumBVOps = BV->getNumOperands();\n  int ZextElt = -1;\n  for (int i = 0; i != NumBVOps; ++i) {\n    SDValue Op = BV->getOperand(i);\n    if (Op.isUndef())\n      continue;\n    if (ZextElt == -1)\n      ZextElt = i;\n    else\n      return SDValue();\n  }\n  // Bail out if there's no non-undef element.\n  if (ZextElt == -1)\n    return SDValue();\n\n  // The build vector contains some number of undef elements and exactly\n  // one other element. That other element must be a zero-extended scalar\n  // extracted from a vector at a constant index to turn this into a shuffle.\n  // Also, require that the build vector does not implicitly truncate/extend\n  // its elements.\n  // TODO: This could be enhanced to allow ANY_EXTEND as well as ZERO_EXTEND.\n  EVT VT = BV->getValueType(0);\n  SDValue Zext = BV->getOperand(ZextElt);\n  if (Zext.getOpcode() != ISD::ZERO_EXTEND || !Zext.hasOneUse() ||\n      Zext.getOperand(0).getOpcode() != ISD::EXTRACT_VECTOR_ELT ||\n      !isa<ConstantSDNode>(Zext.getOperand(0).getOperand(1)) ||\n      Zext.getValueSizeInBits() != VT.getScalarSizeInBits())\n    return SDValue();\n\n  // The zero-extend must be a multiple of the source size, and we must be\n  // building a vector of the same size as the source of the extract element.\n  SDValue Extract = Zext.getOperand(0);\n  unsigned DestSize = Zext.getValueSizeInBits();\n  unsigned SrcSize = Extract.getValueSizeInBits();\n  if (DestSize % SrcSize != 0 ||\n      Extract.getOperand(0).getValueSizeInBits() != VT.getSizeInBits())\n    return SDValue();\n\n  // Create a shuffle mask that will combine the extracted element with zeros\n  // and undefs.\n  int ZextRatio = DestSize / SrcSize;\n  int NumMaskElts = NumBVOps * ZextRatio;\n  SmallVector<int, 32> ShufMask(NumMaskElts, -1);\n  for (int i = 0; i != NumMaskElts; ++i) {\n    if (i / ZextRatio == ZextElt) {\n      // The low bits of the (potentially translated) extracted element map to\n      // the source vector. The high bits map to zero. We will use a zero vector\n      // as the 2nd source operand of the shuffle, so use the 1st element of\n      // that vector (mask value is number-of-elements) for the high bits.\n      if (i % ZextRatio == 0)\n        ShufMask[i] = Extract.getConstantOperandVal(1);\n      else\n        ShufMask[i] = NumMaskElts;\n    }\n\n    // Undef elements of the build vector remain undef because we initialize\n    // the shuffle mask with -1.\n  }\n\n  // buildvec undef, ..., (zext (extractelt V, IndexC)), undef... -->\n  // bitcast (shuffle V, ZeroVec, VectorMask)\n  SDLoc DL(BV);\n  EVT VecVT = Extract.getOperand(0).getValueType();\n  SDValue ZeroVec = DAG.getConstant(0, DL, VecVT);\n  const TargetLowering &TLI = DAG.getTargetLoweringInfo();\n  SDValue Shuf = TLI.buildLegalVectorShuffle(VecVT, DL, Extract.getOperand(0),\n                                             ZeroVec, ShufMask, DAG);\n  if (!Shuf)\n    return SDValue();\n  return DAG.getBitcast(VT, Shuf);\n}\n\n// Check to see if this is a BUILD_VECTOR of a bunch of EXTRACT_VECTOR_ELT\n// operations. If the types of the vectors we're extracting from allow it,\n// turn this into a vector_shuffle node.\nSDValue DAGCombiner::reduceBuildVecToShuffle(SDNode *N) {\n  SDLoc DL(N);\n  EVT VT = N->getValueType(0);\n\n  // Only type-legal BUILD_VECTOR nodes are converted to shuffle nodes.\n  if (!isTypeLegal(VT))\n    return SDValue();\n\n  if (SDValue V = reduceBuildVecToShuffleWithZero(N, DAG))\n    return V;\n\n  // May only combine to shuffle after legalize if shuffle is legal.\n  if (LegalOperations && !TLI.isOperationLegal(ISD::VECTOR_SHUFFLE, VT))\n    return SDValue();\n\n  bool UsesZeroVector = false;\n  unsigned NumElems = N->getNumOperands();\n\n  // Record, for each element of the newly built vector, which input vector\n  // that element comes from. -1 stands for undef, 0 for the zero vector,\n  // and positive values for the input vectors.\n  // VectorMask maps each element to its vector number, and VecIn maps vector\n  // numbers to their initial SDValues.\n\n  SmallVector<int, 8> VectorMask(NumElems, -1);\n  SmallVector<SDValue, 8> VecIn;\n  VecIn.push_back(SDValue());\n\n  for (unsigned i = 0; i != NumElems; ++i) {\n    SDValue Op = N->getOperand(i);\n\n    if (Op.isUndef())\n      continue;\n\n    // See if we can use a blend with a zero vector.\n    // TODO: Should we generalize this to a blend with an arbitrary constant\n    // vector?\n    if (isNullConstant(Op) || isNullFPConstant(Op)) {\n      UsesZeroVector = true;\n      VectorMask[i] = 0;\n      continue;\n    }\n\n    // Not an undef or zero. If the input is something other than an\n    // EXTRACT_VECTOR_ELT with an in-range constant index, bail out.\n    if (Op.getOpcode() != ISD::EXTRACT_VECTOR_ELT ||\n        !isa<ConstantSDNode>(Op.getOperand(1)))\n      return SDValue();\n    SDValue ExtractedFromVec = Op.getOperand(0);\n\n    if (ExtractedFromVec.getValueType().isScalableVector())\n      return SDValue();\n\n    const APInt &ExtractIdx = Op.getConstantOperandAPInt(1);\n    if (ExtractIdx.uge(ExtractedFromVec.getValueType().getVectorNumElements()))\n      return SDValue();\n\n    // All inputs must have the same element type as the output.\n    if (VT.getVectorElementType() !=\n        ExtractedFromVec.getValueType().getVectorElementType())\n      return SDValue();\n\n    // Have we seen this input vector before?\n    // The vectors are expected to be tiny (usually 1 or 2 elements), so using\n    // a map back from SDValues to numbers isn't worth it.\n    unsigned Idx = std::distance(VecIn.begin(), find(VecIn, ExtractedFromVec));\n    if (Idx == VecIn.size())\n      VecIn.push_back(ExtractedFromVec);\n\n    VectorMask[i] = Idx;\n  }\n\n  // If we didn't find at least one input vector, bail out.\n  if (VecIn.size() < 2)\n    return SDValue();\n\n  // If all the Operands of BUILD_VECTOR extract from same\n  // vector, then split the vector efficiently based on the maximum\n  // vector access index and adjust the VectorMask and\n  // VecIn accordingly.\n  bool DidSplitVec = false;\n  if (VecIn.size() == 2) {\n    unsigned MaxIndex = 0;\n    unsigned NearestPow2 = 0;\n    SDValue Vec = VecIn.back();\n    EVT InVT = Vec.getValueType();\n    SmallVector<unsigned, 8> IndexVec(NumElems, 0);\n\n    for (unsigned i = 0; i < NumElems; i++) {\n      if (VectorMask[i] <= 0)\n        continue;\n      unsigned Index = N->getOperand(i).getConstantOperandVal(1);\n      IndexVec[i] = Index;\n      MaxIndex = std::max(MaxIndex, Index);\n    }\n\n    NearestPow2 = PowerOf2Ceil(MaxIndex);\n    if (InVT.isSimple() && NearestPow2 > 2 && MaxIndex < NearestPow2 &&\n        NumElems * 2 < NearestPow2) {\n      unsigned SplitSize = NearestPow2 / 2;\n      EVT SplitVT = EVT::getVectorVT(*DAG.getContext(),\n                                     InVT.getVectorElementType(), SplitSize);\n      if (TLI.isTypeLegal(SplitVT)) {\n        SDValue VecIn2 = DAG.getNode(ISD::EXTRACT_SUBVECTOR, DL, SplitVT, Vec,\n                                     DAG.getVectorIdxConstant(SplitSize, DL));\n        SDValue VecIn1 = DAG.getNode(ISD::EXTRACT_SUBVECTOR, DL, SplitVT, Vec,\n                                     DAG.getVectorIdxConstant(0, DL));\n        VecIn.pop_back();\n        VecIn.push_back(VecIn1);\n        VecIn.push_back(VecIn2);\n        DidSplitVec = true;\n\n        for (unsigned i = 0; i < NumElems; i++) {\n          if (VectorMask[i] <= 0)\n            continue;\n          VectorMask[i] = (IndexVec[i] < SplitSize) ? 1 : 2;\n        }\n      }\n    }\n  }\n\n  // TODO: We want to sort the vectors by descending length, so that adjacent\n  // pairs have similar length, and the longer vector is always first in the\n  // pair.\n\n  // TODO: Should this fire if some of the input vectors has illegal type (like\n  // it does now), or should we let legalization run its course first?\n\n  // Shuffle phase:\n  // Take pairs of vectors, and shuffle them so that the result has elements\n  // from these vectors in the correct places.\n  // For example, given:\n  // t10: i32 = extract_vector_elt t1, Constant:i64<0>\n  // t11: i32 = extract_vector_elt t2, Constant:i64<0>\n  // t12: i32 = extract_vector_elt t3, Constant:i64<0>\n  // t13: i32 = extract_vector_elt t1, Constant:i64<1>\n  // t14: v4i32 = BUILD_VECTOR t10, t11, t12, t13\n  // We will generate:\n  // t20: v4i32 = vector_shuffle<0,4,u,1> t1, t2\n  // t21: v4i32 = vector_shuffle<u,u,0,u> t3, undef\n  SmallVector<SDValue, 4> Shuffles;\n  for (unsigned In = 0, Len = (VecIn.size() / 2); In < Len; ++In) {\n    unsigned LeftIdx = 2 * In + 1;\n    SDValue VecLeft = VecIn[LeftIdx];\n    SDValue VecRight =\n        (LeftIdx + 1) < VecIn.size() ? VecIn[LeftIdx + 1] : SDValue();\n\n    if (SDValue Shuffle = createBuildVecShuffle(DL, N, VectorMask, VecLeft,\n                                                VecRight, LeftIdx, DidSplitVec))\n      Shuffles.push_back(Shuffle);\n    else\n      return SDValue();\n  }\n\n  // If we need the zero vector as an \"ingredient\" in the blend tree, add it\n  // to the list of shuffles.\n  if (UsesZeroVector)\n    Shuffles.push_back(VT.isInteger() ? DAG.getConstant(0, DL, VT)\n                                      : DAG.getConstantFP(0.0, DL, VT));\n\n  // If we only have one shuffle, we're done.\n  if (Shuffles.size() == 1)\n    return Shuffles[0];\n\n  // Update the vector mask to point to the post-shuffle vectors.\n  for (int &Vec : VectorMask)\n    if (Vec == 0)\n      Vec = Shuffles.size() - 1;\n    else\n      Vec = (Vec - 1) / 2;\n\n  // More than one shuffle. Generate a binary tree of blends, e.g. if from\n  // the previous step we got the set of shuffles t10, t11, t12, t13, we will\n  // generate:\n  // t10: v8i32 = vector_shuffle<0,8,u,u,u,u,u,u> t1, t2\n  // t11: v8i32 = vector_shuffle<u,u,0,8,u,u,u,u> t3, t4\n  // t12: v8i32 = vector_shuffle<u,u,u,u,0,8,u,u> t5, t6\n  // t13: v8i32 = vector_shuffle<u,u,u,u,u,u,0,8> t7, t8\n  // t20: v8i32 = vector_shuffle<0,1,10,11,u,u,u,u> t10, t11\n  // t21: v8i32 = vector_shuffle<u,u,u,u,4,5,14,15> t12, t13\n  // t30: v8i32 = vector_shuffle<0,1,2,3,12,13,14,15> t20, t21\n\n  // Make sure the initial size of the shuffle list is even.\n  if (Shuffles.size() % 2)\n    Shuffles.push_back(DAG.getUNDEF(VT));\n\n  for (unsigned CurSize = Shuffles.size(); CurSize > 1; CurSize /= 2) {\n    if (CurSize % 2) {\n      Shuffles[CurSize] = DAG.getUNDEF(VT);\n      CurSize++;\n    }\n    for (unsigned In = 0, Len = CurSize / 2; In < Len; ++In) {\n      int Left = 2 * In;\n      int Right = 2 * In + 1;\n      SmallVector<int, 8> Mask(NumElems, -1);\n      for (unsigned i = 0; i != NumElems; ++i) {\n        if (VectorMask[i] == Left) {\n          Mask[i] = i;\n          VectorMask[i] = In;\n        } else if (VectorMask[i] == Right) {\n          Mask[i] = i + NumElems;\n          VectorMask[i] = In;\n        }\n      }\n\n      Shuffles[In] =\n          DAG.getVectorShuffle(VT, DL, Shuffles[Left], Shuffles[Right], Mask);\n    }\n  }\n  return Shuffles[0];\n}\n\n// Try to turn a build vector of zero extends of extract vector elts into a\n// a vector zero extend and possibly an extract subvector.\n// TODO: Support sign extend?\n// TODO: Allow undef elements?\nSDValue DAGCombiner::convertBuildVecZextToZext(SDNode *N) {\n  if (LegalOperations)\n    return SDValue();\n\n  EVT VT = N->getValueType(0);\n\n  bool FoundZeroExtend = false;\n  SDValue Op0 = N->getOperand(0);\n  auto checkElem = [&](SDValue Op) -> int64_t {\n    unsigned Opc = Op.getOpcode();\n    FoundZeroExtend |= (Opc == ISD::ZERO_EXTEND);\n    if ((Opc == ISD::ZERO_EXTEND || Opc == ISD::ANY_EXTEND) &&\n        Op.getOperand(0).getOpcode() == ISD::EXTRACT_VECTOR_ELT &&\n        Op0.getOperand(0).getOperand(0) == Op.getOperand(0).getOperand(0))\n      if (auto *C = dyn_cast<ConstantSDNode>(Op.getOperand(0).getOperand(1)))\n        return C->getZExtValue();\n    return -1;\n  };\n\n  // Make sure the first element matches\n  // (zext (extract_vector_elt X, C))\n  int64_t Offset = checkElem(Op0);\n  if (Offset < 0)\n    return SDValue();\n\n  unsigned NumElems = N->getNumOperands();\n  SDValue In = Op0.getOperand(0).getOperand(0);\n  EVT InSVT = In.getValueType().getScalarType();\n  EVT InVT = EVT::getVectorVT(*DAG.getContext(), InSVT, NumElems);\n\n  // Don't create an illegal input type after type legalization.\n  if (LegalTypes && !TLI.isTypeLegal(InVT))\n    return SDValue();\n\n  // Ensure all the elements come from the same vector and are adjacent.\n  for (unsigned i = 1; i != NumElems; ++i) {\n    if ((Offset + i) != checkElem(N->getOperand(i)))\n      return SDValue();\n  }\n\n  SDLoc DL(N);\n  In = DAG.getNode(ISD::EXTRACT_SUBVECTOR, DL, InVT, In,\n                   Op0.getOperand(0).getOperand(1));\n  return DAG.getNode(FoundZeroExtend ? ISD::ZERO_EXTEND : ISD::ANY_EXTEND, DL,\n                     VT, In);\n}\n\nSDValue DAGCombiner::visitBUILD_VECTOR(SDNode *N) {\n  EVT VT = N->getValueType(0);\n\n  // A vector built entirely of undefs is undef.\n  if (ISD::allOperandsUndef(N))\n    return DAG.getUNDEF(VT);\n\n  // If this is a splat of a bitcast from another vector, change to a\n  // concat_vector.\n  // For example:\n  //   (build_vector (i64 (bitcast (v2i32 X))), (i64 (bitcast (v2i32 X)))) ->\n  //     (v2i64 (bitcast (concat_vectors (v2i32 X), (v2i32 X))))\n  //\n  // If X is a build_vector itself, the concat can become a larger build_vector.\n  // TODO: Maybe this is useful for non-splat too?\n  if (!LegalOperations) {\n    if (SDValue Splat = cast<BuildVectorSDNode>(N)->getSplatValue()) {\n      Splat = peekThroughBitcasts(Splat);\n      EVT SrcVT = Splat.getValueType();\n      if (SrcVT.isVector()) {\n        unsigned NumElts = N->getNumOperands() * SrcVT.getVectorNumElements();\n        EVT NewVT = EVT::getVectorVT(*DAG.getContext(),\n                                     SrcVT.getVectorElementType(), NumElts);\n        if (!LegalTypes || TLI.isTypeLegal(NewVT)) {\n          SmallVector<SDValue, 8> Ops(N->getNumOperands(), Splat);\n          SDValue Concat = DAG.getNode(ISD::CONCAT_VECTORS, SDLoc(N),\n                                       NewVT, Ops);\n          return DAG.getBitcast(VT, Concat);\n        }\n      }\n    }\n  }\n\n  // A splat of a single element is a SPLAT_VECTOR if supported on the target.\n  if (TLI.getOperationAction(ISD::SPLAT_VECTOR, VT) != TargetLowering::Expand)\n    if (SDValue V = cast<BuildVectorSDNode>(N)->getSplatValue()) {\n      assert(!V.isUndef() && \"Splat of undef should have been handled earlier\");\n      return DAG.getNode(ISD::SPLAT_VECTOR, SDLoc(N), VT, V);\n    }\n\n  // Check if we can express BUILD VECTOR via subvector extract.\n  if (!LegalTypes && (N->getNumOperands() > 1)) {\n    SDValue Op0 = N->getOperand(0);\n    auto checkElem = [&](SDValue Op) -> uint64_t {\n      if ((Op.getOpcode() == ISD::EXTRACT_VECTOR_ELT) &&\n          (Op0.getOperand(0) == Op.getOperand(0)))\n        if (auto CNode = dyn_cast<ConstantSDNode>(Op.getOperand(1)))\n          return CNode->getZExtValue();\n      return -1;\n    };\n\n    int Offset = checkElem(Op0);\n    for (unsigned i = 0; i < N->getNumOperands(); ++i) {\n      if (Offset + i != checkElem(N->getOperand(i))) {\n        Offset = -1;\n        break;\n      }\n    }\n\n    if ((Offset == 0) &&\n        (Op0.getOperand(0).getValueType() == N->getValueType(0)))\n      return Op0.getOperand(0);\n    if ((Offset != -1) &&\n        ((Offset % N->getValueType(0).getVectorNumElements()) ==\n         0)) // IDX must be multiple of output size.\n      return DAG.getNode(ISD::EXTRACT_SUBVECTOR, SDLoc(N), N->getValueType(0),\n                         Op0.getOperand(0), Op0.getOperand(1));\n  }\n\n  if (SDValue V = convertBuildVecZextToZext(N))\n    return V;\n\n  if (SDValue V = reduceBuildVecExtToExtBuildVec(N))\n    return V;\n\n  if (SDValue V = reduceBuildVecTruncToBitCast(N))\n    return V;\n\n  if (SDValue V = reduceBuildVecToShuffle(N))\n    return V;\n\n  return SDValue();\n}\n\nstatic SDValue combineConcatVectorOfScalars(SDNode *N, SelectionDAG &DAG) {\n  const TargetLowering &TLI = DAG.getTargetLoweringInfo();\n  EVT OpVT = N->getOperand(0).getValueType();\n\n  // If the operands are legal vectors, leave them alone.\n  if (TLI.isTypeLegal(OpVT))\n    return SDValue();\n\n  SDLoc DL(N);\n  EVT VT = N->getValueType(0);\n  SmallVector<SDValue, 8> Ops;\n\n  EVT SVT = EVT::getIntegerVT(*DAG.getContext(), OpVT.getSizeInBits());\n  SDValue ScalarUndef = DAG.getNode(ISD::UNDEF, DL, SVT);\n\n  // Keep track of what we encounter.\n  bool AnyInteger = false;\n  bool AnyFP = false;\n  for (const SDValue &Op : N->ops()) {\n    if (ISD::BITCAST == Op.getOpcode() &&\n        !Op.getOperand(0).getValueType().isVector())\n      Ops.push_back(Op.getOperand(0));\n    else if (ISD::UNDEF == Op.getOpcode())\n      Ops.push_back(ScalarUndef);\n    else\n      return SDValue();\n\n    // Note whether we encounter an integer or floating point scalar.\n    // If it's neither, bail out, it could be something weird like x86mmx.\n    EVT LastOpVT = Ops.back().getValueType();\n    if (LastOpVT.isFloatingPoint())\n      AnyFP = true;\n    else if (LastOpVT.isInteger())\n      AnyInteger = true;\n    else\n      return SDValue();\n  }\n\n  // If any of the operands is a floating point scalar bitcast to a vector,\n  // use floating point types throughout, and bitcast everything.\n  // Replace UNDEFs by another scalar UNDEF node, of the final desired type.\n  if (AnyFP) {\n    SVT = EVT::getFloatingPointVT(OpVT.getSizeInBits());\n    ScalarUndef = DAG.getNode(ISD::UNDEF, DL, SVT);\n    if (AnyInteger) {\n      for (SDValue &Op : Ops) {\n        if (Op.getValueType() == SVT)\n          continue;\n        if (Op.isUndef())\n          Op = ScalarUndef;\n        else\n          Op = DAG.getBitcast(SVT, Op);\n      }\n    }\n  }\n\n  EVT VecVT = EVT::getVectorVT(*DAG.getContext(), SVT,\n                               VT.getSizeInBits() / SVT.getSizeInBits());\n  return DAG.getBitcast(VT, DAG.getBuildVector(VecVT, DL, Ops));\n}\n\n// Check to see if this is a CONCAT_VECTORS of a bunch of EXTRACT_SUBVECTOR\n// operations. If so, and if the EXTRACT_SUBVECTOR vector inputs come from at\n// most two distinct vectors the same size as the result, attempt to turn this\n// into a legal shuffle.\nstatic SDValue combineConcatVectorOfExtracts(SDNode *N, SelectionDAG &DAG) {\n  EVT VT = N->getValueType(0);\n  EVT OpVT = N->getOperand(0).getValueType();\n\n  // We currently can't generate an appropriate shuffle for a scalable vector.\n  if (VT.isScalableVector())\n    return SDValue();\n\n  int NumElts = VT.getVectorNumElements();\n  int NumOpElts = OpVT.getVectorNumElements();\n\n  SDValue SV0 = DAG.getUNDEF(VT), SV1 = DAG.getUNDEF(VT);\n  SmallVector<int, 8> Mask;\n\n  for (SDValue Op : N->ops()) {\n    Op = peekThroughBitcasts(Op);\n\n    // UNDEF nodes convert to UNDEF shuffle mask values.\n    if (Op.isUndef()) {\n      Mask.append((unsigned)NumOpElts, -1);\n      continue;\n    }\n\n    if (Op.getOpcode() != ISD::EXTRACT_SUBVECTOR)\n      return SDValue();\n\n    // What vector are we extracting the subvector from and at what index?\n    SDValue ExtVec = Op.getOperand(0);\n    int ExtIdx = Op.getConstantOperandVal(1);\n\n    // We want the EVT of the original extraction to correctly scale the\n    // extraction index.\n    EVT ExtVT = ExtVec.getValueType();\n    ExtVec = peekThroughBitcasts(ExtVec);\n\n    // UNDEF nodes convert to UNDEF shuffle mask values.\n    if (ExtVec.isUndef()) {\n      Mask.append((unsigned)NumOpElts, -1);\n      continue;\n    }\n\n    // Ensure that we are extracting a subvector from a vector the same\n    // size as the result.\n    if (ExtVT.getSizeInBits() != VT.getSizeInBits())\n      return SDValue();\n\n    // Scale the subvector index to account for any bitcast.\n    int NumExtElts = ExtVT.getVectorNumElements();\n    if (0 == (NumExtElts % NumElts))\n      ExtIdx /= (NumExtElts / NumElts);\n    else if (0 == (NumElts % NumExtElts))\n      ExtIdx *= (NumElts / NumExtElts);\n    else\n      return SDValue();\n\n    // At most we can reference 2 inputs in the final shuffle.\n    if (SV0.isUndef() || SV0 == ExtVec) {\n      SV0 = ExtVec;\n      for (int i = 0; i != NumOpElts; ++i)\n        Mask.push_back(i + ExtIdx);\n    } else if (SV1.isUndef() || SV1 == ExtVec) {\n      SV1 = ExtVec;\n      for (int i = 0; i != NumOpElts; ++i)\n        Mask.push_back(i + ExtIdx + NumElts);\n    } else {\n      return SDValue();\n    }\n  }\n\n  const TargetLowering &TLI = DAG.getTargetLoweringInfo();\n  return TLI.buildLegalVectorShuffle(VT, SDLoc(N), DAG.getBitcast(VT, SV0),\n                                     DAG.getBitcast(VT, SV1), Mask, DAG);\n}\n\nstatic SDValue combineConcatVectorOfCasts(SDNode *N, SelectionDAG &DAG) {\n  unsigned CastOpcode = N->getOperand(0).getOpcode();\n  switch (CastOpcode) {\n  case ISD::SINT_TO_FP:\n  case ISD::UINT_TO_FP:\n  case ISD::FP_TO_SINT:\n  case ISD::FP_TO_UINT:\n    // TODO: Allow more opcodes?\n    //  case ISD::BITCAST:\n    //  case ISD::TRUNCATE:\n    //  case ISD::ZERO_EXTEND:\n    //  case ISD::SIGN_EXTEND:\n    //  case ISD::FP_EXTEND:\n    break;\n  default:\n    return SDValue();\n  }\n\n  EVT SrcVT = N->getOperand(0).getOperand(0).getValueType();\n  if (!SrcVT.isVector())\n    return SDValue();\n\n  // All operands of the concat must be the same kind of cast from the same\n  // source type.\n  SmallVector<SDValue, 4> SrcOps;\n  for (SDValue Op : N->ops()) {\n    if (Op.getOpcode() != CastOpcode || !Op.hasOneUse() ||\n        Op.getOperand(0).getValueType() != SrcVT)\n      return SDValue();\n    SrcOps.push_back(Op.getOperand(0));\n  }\n\n  // The wider cast must be supported by the target. This is unusual because\n  // the operation support type parameter depends on the opcode. In addition,\n  // check the other type in the cast to make sure this is really legal.\n  EVT VT = N->getValueType(0);\n  EVT SrcEltVT = SrcVT.getVectorElementType();\n  ElementCount NumElts = SrcVT.getVectorElementCount() * N->getNumOperands();\n  EVT ConcatSrcVT = EVT::getVectorVT(*DAG.getContext(), SrcEltVT, NumElts);\n  const TargetLowering &TLI = DAG.getTargetLoweringInfo();\n  switch (CastOpcode) {\n  case ISD::SINT_TO_FP:\n  case ISD::UINT_TO_FP:\n    if (!TLI.isOperationLegalOrCustom(CastOpcode, ConcatSrcVT) ||\n        !TLI.isTypeLegal(VT))\n      return SDValue();\n    break;\n  case ISD::FP_TO_SINT:\n  case ISD::FP_TO_UINT:\n    if (!TLI.isOperationLegalOrCustom(CastOpcode, VT) ||\n        !TLI.isTypeLegal(ConcatSrcVT))\n      return SDValue();\n    break;\n  default:\n    llvm_unreachable(\"Unexpected cast opcode\");\n  }\n\n  // concat (cast X), (cast Y)... -> cast (concat X, Y...)\n  SDLoc DL(N);\n  SDValue NewConcat = DAG.getNode(ISD::CONCAT_VECTORS, DL, ConcatSrcVT, SrcOps);\n  return DAG.getNode(CastOpcode, DL, VT, NewConcat);\n}\n\nSDValue DAGCombiner::visitCONCAT_VECTORS(SDNode *N) {\n  // If we only have one input vector, we don't need to do any concatenation.\n  if (N->getNumOperands() == 1)\n    return N->getOperand(0);\n\n  // Check if all of the operands are undefs.\n  EVT VT = N->getValueType(0);\n  if (ISD::allOperandsUndef(N))\n    return DAG.getUNDEF(VT);\n\n  // Optimize concat_vectors where all but the first of the vectors are undef.\n  if (all_of(drop_begin(N->ops()),\n             [](const SDValue &Op) { return Op.isUndef(); })) {\n    SDValue In = N->getOperand(0);\n    assert(In.getValueType().isVector() && \"Must concat vectors\");\n\n    // If the input is a concat_vectors, just make a larger concat by padding\n    // with smaller undefs.\n    if (In.getOpcode() == ISD::CONCAT_VECTORS && In.hasOneUse()) {\n      unsigned NumOps = N->getNumOperands() * In.getNumOperands();\n      SmallVector<SDValue, 4> Ops(In->op_begin(), In->op_end());\n      Ops.resize(NumOps, DAG.getUNDEF(Ops[0].getValueType()));\n      return DAG.getNode(ISD::CONCAT_VECTORS, SDLoc(N), VT, Ops);\n    }\n\n    SDValue Scalar = peekThroughOneUseBitcasts(In);\n\n    // concat_vectors(scalar_to_vector(scalar), undef) ->\n    //     scalar_to_vector(scalar)\n    if (!LegalOperations && Scalar.getOpcode() == ISD::SCALAR_TO_VECTOR &&\n         Scalar.hasOneUse()) {\n      EVT SVT = Scalar.getValueType().getVectorElementType();\n      if (SVT == Scalar.getOperand(0).getValueType())\n        Scalar = Scalar.getOperand(0);\n    }\n\n    // concat_vectors(scalar, undef) -> scalar_to_vector(scalar)\n    if (!Scalar.getValueType().isVector()) {\n      // If the bitcast type isn't legal, it might be a trunc of a legal type;\n      // look through the trunc so we can still do the transform:\n      //   concat_vectors(trunc(scalar), undef) -> scalar_to_vector(scalar)\n      if (Scalar->getOpcode() == ISD::TRUNCATE &&\n          !TLI.isTypeLegal(Scalar.getValueType()) &&\n          TLI.isTypeLegal(Scalar->getOperand(0).getValueType()))\n        Scalar = Scalar->getOperand(0);\n\n      EVT SclTy = Scalar.getValueType();\n\n      if (!SclTy.isFloatingPoint() && !SclTy.isInteger())\n        return SDValue();\n\n      // Bail out if the vector size is not a multiple of the scalar size.\n      if (VT.getSizeInBits() % SclTy.getSizeInBits())\n        return SDValue();\n\n      unsigned VNTNumElms = VT.getSizeInBits() / SclTy.getSizeInBits();\n      if (VNTNumElms < 2)\n        return SDValue();\n\n      EVT NVT = EVT::getVectorVT(*DAG.getContext(), SclTy, VNTNumElms);\n      if (!TLI.isTypeLegal(NVT) || !TLI.isTypeLegal(Scalar.getValueType()))\n        return SDValue();\n\n      SDValue Res = DAG.getNode(ISD::SCALAR_TO_VECTOR, SDLoc(N), NVT, Scalar);\n      return DAG.getBitcast(VT, Res);\n    }\n  }\n\n  // Fold any combination of BUILD_VECTOR or UNDEF nodes into one BUILD_VECTOR.\n  // We have already tested above for an UNDEF only concatenation.\n  // fold (concat_vectors (BUILD_VECTOR A, B, ...), (BUILD_VECTOR C, D, ...))\n  // -> (BUILD_VECTOR A, B, ..., C, D, ...)\n  auto IsBuildVectorOrUndef = [](const SDValue &Op) {\n    return ISD::UNDEF == Op.getOpcode() || ISD::BUILD_VECTOR == Op.getOpcode();\n  };\n  if (llvm::all_of(N->ops(), IsBuildVectorOrUndef)) {\n    SmallVector<SDValue, 8> Opnds;\n    EVT SVT = VT.getScalarType();\n\n    EVT MinVT = SVT;\n    if (!SVT.isFloatingPoint()) {\n      // If BUILD_VECTOR are from built from integer, they may have different\n      // operand types. Get the smallest type and truncate all operands to it.\n      bool FoundMinVT = false;\n      for (const SDValue &Op : N->ops())\n        if (ISD::BUILD_VECTOR == Op.getOpcode()) {\n          EVT OpSVT = Op.getOperand(0).getValueType();\n          MinVT = (!FoundMinVT || OpSVT.bitsLE(MinVT)) ? OpSVT : MinVT;\n          FoundMinVT = true;\n        }\n      assert(FoundMinVT && \"Concat vector type mismatch\");\n    }\n\n    for (const SDValue &Op : N->ops()) {\n      EVT OpVT = Op.getValueType();\n      unsigned NumElts = OpVT.getVectorNumElements();\n\n      if (ISD::UNDEF == Op.getOpcode())\n        Opnds.append(NumElts, DAG.getUNDEF(MinVT));\n\n      if (ISD::BUILD_VECTOR == Op.getOpcode()) {\n        if (SVT.isFloatingPoint()) {\n          assert(SVT == OpVT.getScalarType() && \"Concat vector type mismatch\");\n          Opnds.append(Op->op_begin(), Op->op_begin() + NumElts);\n        } else {\n          for (unsigned i = 0; i != NumElts; ++i)\n            Opnds.push_back(\n                DAG.getNode(ISD::TRUNCATE, SDLoc(N), MinVT, Op.getOperand(i)));\n        }\n      }\n    }\n\n    assert(VT.getVectorNumElements() == Opnds.size() &&\n           \"Concat vector type mismatch\");\n    return DAG.getBuildVector(VT, SDLoc(N), Opnds);\n  }\n\n  // Fold CONCAT_VECTORS of only bitcast scalars (or undef) to BUILD_VECTOR.\n  if (SDValue V = combineConcatVectorOfScalars(N, DAG))\n    return V;\n\n  // Fold CONCAT_VECTORS of EXTRACT_SUBVECTOR (or undef) to VECTOR_SHUFFLE.\n  if (Level < AfterLegalizeVectorOps && TLI.isTypeLegal(VT))\n    if (SDValue V = combineConcatVectorOfExtracts(N, DAG))\n      return V;\n\n  if (SDValue V = combineConcatVectorOfCasts(N, DAG))\n    return V;\n\n  // Type legalization of vectors and DAG canonicalization of SHUFFLE_VECTOR\n  // nodes often generate nop CONCAT_VECTOR nodes. Scan the CONCAT_VECTOR\n  // operands and look for a CONCAT operations that place the incoming vectors\n  // at the exact same location.\n  //\n  // For scalable vectors, EXTRACT_SUBVECTOR indexes are implicitly scaled.\n  SDValue SingleSource = SDValue();\n  unsigned PartNumElem =\n      N->getOperand(0).getValueType().getVectorMinNumElements();\n\n  for (unsigned i = 0, e = N->getNumOperands(); i != e; ++i) {\n    SDValue Op = N->getOperand(i);\n\n    if (Op.isUndef())\n      continue;\n\n    // Check if this is the identity extract:\n    if (Op.getOpcode() != ISD::EXTRACT_SUBVECTOR)\n      return SDValue();\n\n    // Find the single incoming vector for the extract_subvector.\n    if (SingleSource.getNode()) {\n      if (Op.getOperand(0) != SingleSource)\n        return SDValue();\n    } else {\n      SingleSource = Op.getOperand(0);\n\n      // Check the source type is the same as the type of the result.\n      // If not, this concat may extend the vector, so we can not\n      // optimize it away.\n      if (SingleSource.getValueType() != N->getValueType(0))\n        return SDValue();\n    }\n\n    // Check that we are reading from the identity index.\n    unsigned IdentityIndex = i * PartNumElem;\n    if (Op.getConstantOperandAPInt(1) != IdentityIndex)\n      return SDValue();\n  }\n\n  if (SingleSource.getNode())\n    return SingleSource;\n\n  return SDValue();\n}\n\n// Helper that peeks through INSERT_SUBVECTOR/CONCAT_VECTORS to find\n// if the subvector can be sourced for free.\nstatic SDValue getSubVectorSrc(SDValue V, SDValue Index, EVT SubVT) {\n  if (V.getOpcode() == ISD::INSERT_SUBVECTOR &&\n      V.getOperand(1).getValueType() == SubVT && V.getOperand(2) == Index) {\n    return V.getOperand(1);\n  }\n  auto *IndexC = dyn_cast<ConstantSDNode>(Index);\n  if (IndexC && V.getOpcode() == ISD::CONCAT_VECTORS &&\n      V.getOperand(0).getValueType() == SubVT &&\n      (IndexC->getZExtValue() % SubVT.getVectorMinNumElements()) == 0) {\n    uint64_t SubIdx = IndexC->getZExtValue() / SubVT.getVectorMinNumElements();\n    return V.getOperand(SubIdx);\n  }\n  return SDValue();\n}\n\nstatic SDValue narrowInsertExtractVectorBinOp(SDNode *Extract,\n                                              SelectionDAG &DAG,\n                                              bool LegalOperations) {\n  const TargetLowering &TLI = DAG.getTargetLoweringInfo();\n  SDValue BinOp = Extract->getOperand(0);\n  unsigned BinOpcode = BinOp.getOpcode();\n  if (!TLI.isBinOp(BinOpcode) || BinOp.getNode()->getNumValues() != 1)\n    return SDValue();\n\n  EVT VecVT = BinOp.getValueType();\n  SDValue Bop0 = BinOp.getOperand(0), Bop1 = BinOp.getOperand(1);\n  if (VecVT != Bop0.getValueType() || VecVT != Bop1.getValueType())\n    return SDValue();\n\n  SDValue Index = Extract->getOperand(1);\n  EVT SubVT = Extract->getValueType(0);\n  if (!TLI.isOperationLegalOrCustom(BinOpcode, SubVT, LegalOperations))\n    return SDValue();\n\n  SDValue Sub0 = getSubVectorSrc(Bop0, Index, SubVT);\n  SDValue Sub1 = getSubVectorSrc(Bop1, Index, SubVT);\n\n  // TODO: We could handle the case where only 1 operand is being inserted by\n  //       creating an extract of the other operand, but that requires checking\n  //       number of uses and/or costs.\n  if (!Sub0 || !Sub1)\n    return SDValue();\n\n  // We are inserting both operands of the wide binop only to extract back\n  // to the narrow vector size. Eliminate all of the insert/extract:\n  // ext (binop (ins ?, X, Index), (ins ?, Y, Index)), Index --> binop X, Y\n  return DAG.getNode(BinOpcode, SDLoc(Extract), SubVT, Sub0, Sub1,\n                     BinOp->getFlags());\n}\n\n/// If we are extracting a subvector produced by a wide binary operator try\n/// to use a narrow binary operator and/or avoid concatenation and extraction.\nstatic SDValue narrowExtractedVectorBinOp(SDNode *Extract, SelectionDAG &DAG,\n                                          bool LegalOperations) {\n  // TODO: Refactor with the caller (visitEXTRACT_SUBVECTOR), so we can share\n  // some of these bailouts with other transforms.\n\n  if (SDValue V = narrowInsertExtractVectorBinOp(Extract, DAG, LegalOperations))\n    return V;\n\n  // The extract index must be a constant, so we can map it to a concat operand.\n  auto *ExtractIndexC = dyn_cast<ConstantSDNode>(Extract->getOperand(1));\n  if (!ExtractIndexC)\n    return SDValue();\n\n  // We are looking for an optionally bitcasted wide vector binary operator\n  // feeding an extract subvector.\n  const TargetLowering &TLI = DAG.getTargetLoweringInfo();\n  SDValue BinOp = peekThroughBitcasts(Extract->getOperand(0));\n  unsigned BOpcode = BinOp.getOpcode();\n  if (!TLI.isBinOp(BOpcode) || BinOp.getNode()->getNumValues() != 1)\n    return SDValue();\n\n  // Exclude the fake form of fneg (fsub -0.0, x) because that is likely to be\n  // reduced to the unary fneg when it is visited, and we probably want to deal\n  // with fneg in a target-specific way.\n  if (BOpcode == ISD::FSUB) {\n    auto *C = isConstOrConstSplatFP(BinOp.getOperand(0), /*AllowUndefs*/ true);\n    if (C && C->getValueAPF().isNegZero())\n      return SDValue();\n  }\n\n  // The binop must be a vector type, so we can extract some fraction of it.\n  EVT WideBVT = BinOp.getValueType();\n  // The optimisations below currently assume we are dealing with fixed length\n  // vectors. It is possible to add support for scalable vectors, but at the\n  // moment we've done no analysis to prove whether they are profitable or not.\n  if (!WideBVT.isFixedLengthVector())\n    return SDValue();\n\n  EVT VT = Extract->getValueType(0);\n  unsigned ExtractIndex = ExtractIndexC->getZExtValue();\n  assert(ExtractIndex % VT.getVectorNumElements() == 0 &&\n         \"Extract index is not a multiple of the vector length.\");\n\n  // Bail out if this is not a proper multiple width extraction.\n  unsigned WideWidth = WideBVT.getSizeInBits();\n  unsigned NarrowWidth = VT.getSizeInBits();\n  if (WideWidth % NarrowWidth != 0)\n    return SDValue();\n\n  // Bail out if we are extracting a fraction of a single operation. This can\n  // occur because we potentially looked through a bitcast of the binop.\n  unsigned NarrowingRatio = WideWidth / NarrowWidth;\n  unsigned WideNumElts = WideBVT.getVectorNumElements();\n  if (WideNumElts % NarrowingRatio != 0)\n    return SDValue();\n\n  // Bail out if the target does not support a narrower version of the binop.\n  EVT NarrowBVT = EVT::getVectorVT(*DAG.getContext(), WideBVT.getScalarType(),\n                                   WideNumElts / NarrowingRatio);\n  if (!TLI.isOperationLegalOrCustomOrPromote(BOpcode, NarrowBVT))\n    return SDValue();\n\n  // If extraction is cheap, we don't need to look at the binop operands\n  // for concat ops. The narrow binop alone makes this transform profitable.\n  // We can't just reuse the original extract index operand because we may have\n  // bitcasted.\n  unsigned ConcatOpNum = ExtractIndex / VT.getVectorNumElements();\n  unsigned ExtBOIdx = ConcatOpNum * NarrowBVT.getVectorNumElements();\n  if (TLI.isExtractSubvectorCheap(NarrowBVT, WideBVT, ExtBOIdx) &&\n      BinOp.hasOneUse() && Extract->getOperand(0)->hasOneUse()) {\n    // extract (binop B0, B1), N --> binop (extract B0, N), (extract B1, N)\n    SDLoc DL(Extract);\n    SDValue NewExtIndex = DAG.getVectorIdxConstant(ExtBOIdx, DL);\n    SDValue X = DAG.getNode(ISD::EXTRACT_SUBVECTOR, DL, NarrowBVT,\n                            BinOp.getOperand(0), NewExtIndex);\n    SDValue Y = DAG.getNode(ISD::EXTRACT_SUBVECTOR, DL, NarrowBVT,\n                            BinOp.getOperand(1), NewExtIndex);\n    SDValue NarrowBinOp = DAG.getNode(BOpcode, DL, NarrowBVT, X, Y,\n                                      BinOp.getNode()->getFlags());\n    return DAG.getBitcast(VT, NarrowBinOp);\n  }\n\n  // Only handle the case where we are doubling and then halving. A larger ratio\n  // may require more than two narrow binops to replace the wide binop.\n  if (NarrowingRatio != 2)\n    return SDValue();\n\n  // TODO: The motivating case for this transform is an x86 AVX1 target. That\n  // target has temptingly almost legal versions of bitwise logic ops in 256-bit\n  // flavors, but no other 256-bit integer support. This could be extended to\n  // handle any binop, but that may require fixing/adding other folds to avoid\n  // codegen regressions.\n  if (BOpcode != ISD::AND && BOpcode != ISD::OR && BOpcode != ISD::XOR)\n    return SDValue();\n\n  // We need at least one concatenation operation of a binop operand to make\n  // this transform worthwhile. The concat must double the input vector sizes.\n  auto GetSubVector = [ConcatOpNum](SDValue V) -> SDValue {\n    if (V.getOpcode() == ISD::CONCAT_VECTORS && V.getNumOperands() == 2)\n      return V.getOperand(ConcatOpNum);\n    return SDValue();\n  };\n  SDValue SubVecL = GetSubVector(peekThroughBitcasts(BinOp.getOperand(0)));\n  SDValue SubVecR = GetSubVector(peekThroughBitcasts(BinOp.getOperand(1)));\n\n  if (SubVecL || SubVecR) {\n    // If a binop operand was not the result of a concat, we must extract a\n    // half-sized operand for our new narrow binop:\n    // extract (binop (concat X1, X2), (concat Y1, Y2)), N --> binop XN, YN\n    // extract (binop (concat X1, X2), Y), N --> binop XN, (extract Y, IndexC)\n    // extract (binop X, (concat Y1, Y2)), N --> binop (extract X, IndexC), YN\n    SDLoc DL(Extract);\n    SDValue IndexC = DAG.getVectorIdxConstant(ExtBOIdx, DL);\n    SDValue X = SubVecL ? DAG.getBitcast(NarrowBVT, SubVecL)\n                        : DAG.getNode(ISD::EXTRACT_SUBVECTOR, DL, NarrowBVT,\n                                      BinOp.getOperand(0), IndexC);\n\n    SDValue Y = SubVecR ? DAG.getBitcast(NarrowBVT, SubVecR)\n                        : DAG.getNode(ISD::EXTRACT_SUBVECTOR, DL, NarrowBVT,\n                                      BinOp.getOperand(1), IndexC);\n\n    SDValue NarrowBinOp = DAG.getNode(BOpcode, DL, NarrowBVT, X, Y);\n    return DAG.getBitcast(VT, NarrowBinOp);\n  }\n\n  return SDValue();\n}\n\n/// If we are extracting a subvector from a wide vector load, convert to a\n/// narrow load to eliminate the extraction:\n/// (extract_subvector (load wide vector)) --> (load narrow vector)\nstatic SDValue narrowExtractedVectorLoad(SDNode *Extract, SelectionDAG &DAG) {\n  // TODO: Add support for big-endian. The offset calculation must be adjusted.\n  if (DAG.getDataLayout().isBigEndian())\n    return SDValue();\n\n  auto *Ld = dyn_cast<LoadSDNode>(Extract->getOperand(0));\n  auto *ExtIdx = dyn_cast<ConstantSDNode>(Extract->getOperand(1));\n  if (!Ld || Ld->getExtensionType() || !Ld->isSimple() ||\n      !ExtIdx)\n    return SDValue();\n\n  // Allow targets to opt-out.\n  EVT VT = Extract->getValueType(0);\n\n  // We can only create byte sized loads.\n  if (!VT.isByteSized())\n    return SDValue();\n\n  unsigned Index = ExtIdx->getZExtValue();\n  unsigned NumElts = VT.getVectorMinNumElements();\n\n  // The definition of EXTRACT_SUBVECTOR states that the index must be a\n  // multiple of the minimum number of elements in the result type.\n  assert(Index % NumElts == 0 && \"The extract subvector index is not a \"\n                                 \"multiple of the result's element count\");\n\n  // It's fine to use TypeSize here as we know the offset will not be negative.\n  TypeSize Offset = VT.getStoreSize() * (Index / NumElts);\n\n  const TargetLowering &TLI = DAG.getTargetLoweringInfo();\n  if (!TLI.shouldReduceLoadWidth(Ld, Ld->getExtensionType(), VT))\n    return SDValue();\n\n  // The narrow load will be offset from the base address of the old load if\n  // we are extracting from something besides index 0 (little-endian).\n  SDLoc DL(Extract);\n\n  // TODO: Use \"BaseIndexOffset\" to make this more effective.\n  SDValue NewAddr = DAG.getMemBasePlusOffset(Ld->getBasePtr(), Offset, DL);\n\n  uint64_t StoreSize = MemoryLocation::getSizeOrUnknown(VT.getStoreSize());\n  MachineFunction &MF = DAG.getMachineFunction();\n  MachineMemOperand *MMO;\n  if (Offset.isScalable()) {\n    MachinePointerInfo MPI =\n        MachinePointerInfo(Ld->getPointerInfo().getAddrSpace());\n    MMO = MF.getMachineMemOperand(Ld->getMemOperand(), MPI, StoreSize);\n  } else\n    MMO = MF.getMachineMemOperand(Ld->getMemOperand(), Offset.getFixedSize(),\n                                  StoreSize);\n\n  SDValue NewLd = DAG.getLoad(VT, DL, Ld->getChain(), NewAddr, MMO);\n  DAG.makeEquivalentMemoryOrdering(Ld, NewLd);\n  return NewLd;\n}\n\nSDValue DAGCombiner::visitEXTRACT_SUBVECTOR(SDNode *N) {\n  EVT NVT = N->getValueType(0);\n  SDValue V = N->getOperand(0);\n  uint64_t ExtIdx = N->getConstantOperandVal(1);\n\n  // Extract from UNDEF is UNDEF.\n  if (V.isUndef())\n    return DAG.getUNDEF(NVT);\n\n  if (TLI.isOperationLegalOrCustomOrPromote(ISD::LOAD, NVT))\n    if (SDValue NarrowLoad = narrowExtractedVectorLoad(N, DAG))\n      return NarrowLoad;\n\n  // Combine an extract of an extract into a single extract_subvector.\n  // ext (ext X, C), 0 --> ext X, C\n  if (ExtIdx == 0 && V.getOpcode() == ISD::EXTRACT_SUBVECTOR && V.hasOneUse()) {\n    if (TLI.isExtractSubvectorCheap(NVT, V.getOperand(0).getValueType(),\n                                    V.getConstantOperandVal(1)) &&\n        TLI.isOperationLegalOrCustom(ISD::EXTRACT_SUBVECTOR, NVT)) {\n      return DAG.getNode(ISD::EXTRACT_SUBVECTOR, SDLoc(N), NVT, V.getOperand(0),\n                         V.getOperand(1));\n    }\n  }\n\n  // Try to move vector bitcast after extract_subv by scaling extraction index:\n  // extract_subv (bitcast X), Index --> bitcast (extract_subv X, Index')\n  if (V.getOpcode() == ISD::BITCAST &&\n      V.getOperand(0).getValueType().isVector()) {\n    SDValue SrcOp = V.getOperand(0);\n    EVT SrcVT = SrcOp.getValueType();\n    unsigned SrcNumElts = SrcVT.getVectorMinNumElements();\n    unsigned DestNumElts = V.getValueType().getVectorMinNumElements();\n    if ((SrcNumElts % DestNumElts) == 0) {\n      unsigned SrcDestRatio = SrcNumElts / DestNumElts;\n      ElementCount NewExtEC = NVT.getVectorElementCount() * SrcDestRatio;\n      EVT NewExtVT = EVT::getVectorVT(*DAG.getContext(), SrcVT.getScalarType(),\n                                      NewExtEC);\n      if (TLI.isOperationLegalOrCustom(ISD::EXTRACT_SUBVECTOR, NewExtVT)) {\n        SDLoc DL(N);\n        SDValue NewIndex = DAG.getVectorIdxConstant(ExtIdx * SrcDestRatio, DL);\n        SDValue NewExtract = DAG.getNode(ISD::EXTRACT_SUBVECTOR, DL, NewExtVT,\n                                         V.getOperand(0), NewIndex);\n        return DAG.getBitcast(NVT, NewExtract);\n      }\n    }\n    if ((DestNumElts % SrcNumElts) == 0) {\n      unsigned DestSrcRatio = DestNumElts / SrcNumElts;\n      if (NVT.getVectorElementCount().isKnownMultipleOf(DestSrcRatio)) {\n        ElementCount NewExtEC =\n            NVT.getVectorElementCount().divideCoefficientBy(DestSrcRatio);\n        EVT ScalarVT = SrcVT.getScalarType();\n        if ((ExtIdx % DestSrcRatio) == 0) {\n          SDLoc DL(N);\n          unsigned IndexValScaled = ExtIdx / DestSrcRatio;\n          EVT NewExtVT =\n              EVT::getVectorVT(*DAG.getContext(), ScalarVT, NewExtEC);\n          if (TLI.isOperationLegalOrCustom(ISD::EXTRACT_SUBVECTOR, NewExtVT)) {\n            SDValue NewIndex = DAG.getVectorIdxConstant(IndexValScaled, DL);\n            SDValue NewExtract =\n                DAG.getNode(ISD::EXTRACT_SUBVECTOR, DL, NewExtVT,\n                            V.getOperand(0), NewIndex);\n            return DAG.getBitcast(NVT, NewExtract);\n          }\n          if (NewExtEC.isScalar() &&\n              TLI.isOperationLegalOrCustom(ISD::EXTRACT_VECTOR_ELT, ScalarVT)) {\n            SDValue NewIndex = DAG.getVectorIdxConstant(IndexValScaled, DL);\n            SDValue NewExtract =\n                DAG.getNode(ISD::EXTRACT_VECTOR_ELT, DL, ScalarVT,\n                            V.getOperand(0), NewIndex);\n            return DAG.getBitcast(NVT, NewExtract);\n          }\n        }\n      }\n    }\n  }\n\n  if (V.getOpcode() == ISD::CONCAT_VECTORS) {\n    unsigned ExtNumElts = NVT.getVectorMinNumElements();\n    EVT ConcatSrcVT = V.getOperand(0).getValueType();\n    assert(ConcatSrcVT.getVectorElementType() == NVT.getVectorElementType() &&\n           \"Concat and extract subvector do not change element type\");\n    assert((ExtIdx % ExtNumElts) == 0 &&\n           \"Extract index is not a multiple of the input vector length.\");\n\n    unsigned ConcatSrcNumElts = ConcatSrcVT.getVectorMinNumElements();\n    unsigned ConcatOpIdx = ExtIdx / ConcatSrcNumElts;\n\n    // If the concatenated source types match this extract, it's a direct\n    // simplification:\n    // extract_subvec (concat V1, V2, ...), i --> Vi\n    if (ConcatSrcNumElts == ExtNumElts)\n      return V.getOperand(ConcatOpIdx);\n\n    // If the concatenated source vectors are a multiple length of this extract,\n    // then extract a fraction of one of those source vectors directly from a\n    // concat operand. Example:\n    //   v2i8 extract_subvec (v16i8 concat (v8i8 X), (v8i8 Y), 14 -->\n    //   v2i8 extract_subvec v8i8 Y, 6\n    if (NVT.isFixedLengthVector() && ConcatSrcNumElts % ExtNumElts == 0) {\n      SDLoc DL(N);\n      unsigned NewExtIdx = ExtIdx - ConcatOpIdx * ConcatSrcNumElts;\n      assert(NewExtIdx + ExtNumElts <= ConcatSrcNumElts &&\n             \"Trying to extract from >1 concat operand?\");\n      assert(NewExtIdx % ExtNumElts == 0 &&\n             \"Extract index is not a multiple of the input vector length.\");\n      SDValue NewIndexC = DAG.getVectorIdxConstant(NewExtIdx, DL);\n      return DAG.getNode(ISD::EXTRACT_SUBVECTOR, DL, NVT,\n                         V.getOperand(ConcatOpIdx), NewIndexC);\n    }\n  }\n\n  V = peekThroughBitcasts(V);\n\n  // If the input is a build vector. Try to make a smaller build vector.\n  if (V.getOpcode() == ISD::BUILD_VECTOR) {\n    EVT InVT = V.getValueType();\n    unsigned ExtractSize = NVT.getSizeInBits();\n    unsigned EltSize = InVT.getScalarSizeInBits();\n    // Only do this if we won't split any elements.\n    if (ExtractSize % EltSize == 0) {\n      unsigned NumElems = ExtractSize / EltSize;\n      EVT EltVT = InVT.getVectorElementType();\n      EVT ExtractVT =\n          NumElems == 1 ? EltVT\n                        : EVT::getVectorVT(*DAG.getContext(), EltVT, NumElems);\n      if ((Level < AfterLegalizeDAG ||\n           (NumElems == 1 ||\n            TLI.isOperationLegal(ISD::BUILD_VECTOR, ExtractVT))) &&\n          (!LegalTypes || TLI.isTypeLegal(ExtractVT))) {\n        unsigned IdxVal = (ExtIdx * NVT.getScalarSizeInBits()) / EltSize;\n\n        if (NumElems == 1) {\n          SDValue Src = V->getOperand(IdxVal);\n          if (EltVT != Src.getValueType())\n            Src = DAG.getNode(ISD::TRUNCATE, SDLoc(N), InVT, Src);\n          return DAG.getBitcast(NVT, Src);\n        }\n\n        // Extract the pieces from the original build_vector.\n        SDValue BuildVec = DAG.getBuildVector(ExtractVT, SDLoc(N),\n                                              V->ops().slice(IdxVal, NumElems));\n        return DAG.getBitcast(NVT, BuildVec);\n      }\n    }\n  }\n\n  if (V.getOpcode() == ISD::INSERT_SUBVECTOR) {\n    // Handle only simple case where vector being inserted and vector\n    // being extracted are of same size.\n    EVT SmallVT = V.getOperand(1).getValueType();\n    if (!NVT.bitsEq(SmallVT))\n      return SDValue();\n\n    // Combine:\n    //    (extract_subvec (insert_subvec V1, V2, InsIdx), ExtIdx)\n    // Into:\n    //    indices are equal or bit offsets are equal => V1\n    //    otherwise => (extract_subvec V1, ExtIdx)\n    uint64_t InsIdx = V.getConstantOperandVal(2);\n    if (InsIdx * SmallVT.getScalarSizeInBits() ==\n        ExtIdx * NVT.getScalarSizeInBits())\n      return DAG.getBitcast(NVT, V.getOperand(1));\n    return DAG.getNode(\n        ISD::EXTRACT_SUBVECTOR, SDLoc(N), NVT,\n        DAG.getBitcast(N->getOperand(0).getValueType(), V.getOperand(0)),\n        N->getOperand(1));\n  }\n\n  if (SDValue NarrowBOp = narrowExtractedVectorBinOp(N, DAG, LegalOperations))\n    return NarrowBOp;\n\n  if (SimplifyDemandedVectorElts(SDValue(N, 0)))\n    return SDValue(N, 0);\n\n  return SDValue();\n}\n\n/// Try to convert a wide shuffle of concatenated vectors into 2 narrow shuffles\n/// followed by concatenation. Narrow vector ops may have better performance\n/// than wide ops, and this can unlock further narrowing of other vector ops.\n/// Targets can invert this transform later if it is not profitable.\nstatic SDValue foldShuffleOfConcatUndefs(ShuffleVectorSDNode *Shuf,\n                                         SelectionDAG &DAG) {\n  SDValue N0 = Shuf->getOperand(0), N1 = Shuf->getOperand(1);\n  if (N0.getOpcode() != ISD::CONCAT_VECTORS || N0.getNumOperands() != 2 ||\n      N1.getOpcode() != ISD::CONCAT_VECTORS || N1.getNumOperands() != 2 ||\n      !N0.getOperand(1).isUndef() || !N1.getOperand(1).isUndef())\n    return SDValue();\n\n  // Split the wide shuffle mask into halves. Any mask element that is accessing\n  // operand 1 is offset down to account for narrowing of the vectors.\n  ArrayRef<int> Mask = Shuf->getMask();\n  EVT VT = Shuf->getValueType(0);\n  unsigned NumElts = VT.getVectorNumElements();\n  unsigned HalfNumElts = NumElts / 2;\n  SmallVector<int, 16> Mask0(HalfNumElts, -1);\n  SmallVector<int, 16> Mask1(HalfNumElts, -1);\n  for (unsigned i = 0; i != NumElts; ++i) {\n    if (Mask[i] == -1)\n      continue;\n    int M = Mask[i] < (int)NumElts ? Mask[i] : Mask[i] - (int)HalfNumElts;\n    if (i < HalfNumElts)\n      Mask0[i] = M;\n    else\n      Mask1[i - HalfNumElts] = M;\n  }\n\n  // Ask the target if this is a valid transform.\n  const TargetLowering &TLI = DAG.getTargetLoweringInfo();\n  EVT HalfVT = EVT::getVectorVT(*DAG.getContext(), VT.getScalarType(),\n                                HalfNumElts);\n  if (!TLI.isShuffleMaskLegal(Mask0, HalfVT) ||\n      !TLI.isShuffleMaskLegal(Mask1, HalfVT))\n    return SDValue();\n\n  // shuffle (concat X, undef), (concat Y, undef), Mask -->\n  // concat (shuffle X, Y, Mask0), (shuffle X, Y, Mask1)\n  SDValue X = N0.getOperand(0), Y = N1.getOperand(0);\n  SDLoc DL(Shuf);\n  SDValue Shuf0 = DAG.getVectorShuffle(HalfVT, DL, X, Y, Mask0);\n  SDValue Shuf1 = DAG.getVectorShuffle(HalfVT, DL, X, Y, Mask1);\n  return DAG.getNode(ISD::CONCAT_VECTORS, DL, VT, Shuf0, Shuf1);\n}\n\n// Tries to turn a shuffle of two CONCAT_VECTORS into a single concat,\n// or turn a shuffle of a single concat into simpler shuffle then concat.\nstatic SDValue partitionShuffleOfConcats(SDNode *N, SelectionDAG &DAG) {\n  EVT VT = N->getValueType(0);\n  unsigned NumElts = VT.getVectorNumElements();\n\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  ShuffleVectorSDNode *SVN = cast<ShuffleVectorSDNode>(N);\n  ArrayRef<int> Mask = SVN->getMask();\n\n  SmallVector<SDValue, 4> Ops;\n  EVT ConcatVT = N0.getOperand(0).getValueType();\n  unsigned NumElemsPerConcat = ConcatVT.getVectorNumElements();\n  unsigned NumConcats = NumElts / NumElemsPerConcat;\n\n  auto IsUndefMaskElt = [](int i) { return i == -1; };\n\n  // Special case: shuffle(concat(A,B)) can be more efficiently represented\n  // as concat(shuffle(A,B),UNDEF) if the shuffle doesn't set any of the high\n  // half vector elements.\n  if (NumElemsPerConcat * 2 == NumElts && N1.isUndef() &&\n      llvm::all_of(Mask.slice(NumElemsPerConcat, NumElemsPerConcat),\n                   IsUndefMaskElt)) {\n    N0 = DAG.getVectorShuffle(ConcatVT, SDLoc(N), N0.getOperand(0),\n                              N0.getOperand(1),\n                              Mask.slice(0, NumElemsPerConcat));\n    N1 = DAG.getUNDEF(ConcatVT);\n    return DAG.getNode(ISD::CONCAT_VECTORS, SDLoc(N), VT, N0, N1);\n  }\n\n  // Look at every vector that's inserted. We're looking for exact\n  // subvector-sized copies from a concatenated vector\n  for (unsigned I = 0; I != NumConcats; ++I) {\n    unsigned Begin = I * NumElemsPerConcat;\n    ArrayRef<int> SubMask = Mask.slice(Begin, NumElemsPerConcat);\n\n    // Make sure we're dealing with a copy.\n    if (llvm::all_of(SubMask, IsUndefMaskElt)) {\n      Ops.push_back(DAG.getUNDEF(ConcatVT));\n      continue;\n    }\n\n    int OpIdx = -1;\n    for (int i = 0; i != (int)NumElemsPerConcat; ++i) {\n      if (IsUndefMaskElt(SubMask[i]))\n        continue;\n      if ((SubMask[i] % (int)NumElemsPerConcat) != i)\n        return SDValue();\n      int EltOpIdx = SubMask[i] / NumElemsPerConcat;\n      if (0 <= OpIdx && EltOpIdx != OpIdx)\n        return SDValue();\n      OpIdx = EltOpIdx;\n    }\n    assert(0 <= OpIdx && \"Unknown concat_vectors op\");\n\n    if (OpIdx < (int)N0.getNumOperands())\n      Ops.push_back(N0.getOperand(OpIdx));\n    else\n      Ops.push_back(N1.getOperand(OpIdx - N0.getNumOperands()));\n  }\n\n  return DAG.getNode(ISD::CONCAT_VECTORS, SDLoc(N), VT, Ops);\n}\n\n// Attempt to combine a shuffle of 2 inputs of 'scalar sources' -\n// BUILD_VECTOR or SCALAR_TO_VECTOR into a single BUILD_VECTOR.\n//\n// SHUFFLE(BUILD_VECTOR(), BUILD_VECTOR()) -> BUILD_VECTOR() is always\n// a simplification in some sense, but it isn't appropriate in general: some\n// BUILD_VECTORs are substantially cheaper than others. The general case\n// of a BUILD_VECTOR requires inserting each element individually (or\n// performing the equivalent in a temporary stack variable). A BUILD_VECTOR of\n// all constants is a single constant pool load.  A BUILD_VECTOR where each\n// element is identical is a splat.  A BUILD_VECTOR where most of the operands\n// are undef lowers to a small number of element insertions.\n//\n// To deal with this, we currently use a bunch of mostly arbitrary heuristics.\n// We don't fold shuffles where one side is a non-zero constant, and we don't\n// fold shuffles if the resulting (non-splat) BUILD_VECTOR would have duplicate\n// non-constant operands. This seems to work out reasonably well in practice.\nstatic SDValue combineShuffleOfScalars(ShuffleVectorSDNode *SVN,\n                                       SelectionDAG &DAG,\n                                       const TargetLowering &TLI) {\n  EVT VT = SVN->getValueType(0);\n  unsigned NumElts = VT.getVectorNumElements();\n  SDValue N0 = SVN->getOperand(0);\n  SDValue N1 = SVN->getOperand(1);\n\n  if (!N0->hasOneUse())\n    return SDValue();\n\n  // If only one of N1,N2 is constant, bail out if it is not ALL_ZEROS as\n  // discussed above.\n  if (!N1.isUndef()) {\n    if (!N1->hasOneUse())\n      return SDValue();\n\n    bool N0AnyConst = isAnyConstantBuildVector(N0);\n    bool N1AnyConst = isAnyConstantBuildVector(N1);\n    if (N0AnyConst && !N1AnyConst && !ISD::isBuildVectorAllZeros(N0.getNode()))\n      return SDValue();\n    if (!N0AnyConst && N1AnyConst && !ISD::isBuildVectorAllZeros(N1.getNode()))\n      return SDValue();\n  }\n\n  // If both inputs are splats of the same value then we can safely merge this\n  // to a single BUILD_VECTOR with undef elements based on the shuffle mask.\n  bool IsSplat = false;\n  auto *BV0 = dyn_cast<BuildVectorSDNode>(N0);\n  auto *BV1 = dyn_cast<BuildVectorSDNode>(N1);\n  if (BV0 && BV1)\n    if (SDValue Splat0 = BV0->getSplatValue())\n      IsSplat = (Splat0 == BV1->getSplatValue());\n\n  SmallVector<SDValue, 8> Ops;\n  SmallSet<SDValue, 16> DuplicateOps;\n  for (int M : SVN->getMask()) {\n    SDValue Op = DAG.getUNDEF(VT.getScalarType());\n    if (M >= 0) {\n      int Idx = M < (int)NumElts ? M : M - NumElts;\n      SDValue &S = (M < (int)NumElts ? N0 : N1);\n      if (S.getOpcode() == ISD::BUILD_VECTOR) {\n        Op = S.getOperand(Idx);\n      } else if (S.getOpcode() == ISD::SCALAR_TO_VECTOR) {\n        SDValue Op0 = S.getOperand(0);\n        Op = Idx == 0 ? Op0 : DAG.getUNDEF(Op0.getValueType());\n      } else {\n        // Operand can't be combined - bail out.\n        return SDValue();\n      }\n    }\n\n    // Don't duplicate a non-constant BUILD_VECTOR operand unless we're\n    // generating a splat; semantically, this is fine, but it's likely to\n    // generate low-quality code if the target can't reconstruct an appropriate\n    // shuffle.\n    if (!Op.isUndef() && !isa<ConstantSDNode>(Op) && !isa<ConstantFPSDNode>(Op))\n      if (!IsSplat && !DuplicateOps.insert(Op).second)\n        return SDValue();\n\n    Ops.push_back(Op);\n  }\n\n  // BUILD_VECTOR requires all inputs to be of the same type, find the\n  // maximum type and extend them all.\n  EVT SVT = VT.getScalarType();\n  if (SVT.isInteger())\n    for (SDValue &Op : Ops)\n      SVT = (SVT.bitsLT(Op.getValueType()) ? Op.getValueType() : SVT);\n  if (SVT != VT.getScalarType())\n    for (SDValue &Op : Ops)\n      Op = TLI.isZExtFree(Op.getValueType(), SVT)\n               ? DAG.getZExtOrTrunc(Op, SDLoc(SVN), SVT)\n               : DAG.getSExtOrTrunc(Op, SDLoc(SVN), SVT);\n  return DAG.getBuildVector(VT, SDLoc(SVN), Ops);\n}\n\n// Match shuffles that can be converted to any_vector_extend_in_reg.\n// This is often generated during legalization.\n// e.g. v4i32 <0,u,1,u> -> (v2i64 any_vector_extend_in_reg(v4i32 src))\n// TODO Add support for ZERO_EXTEND_VECTOR_INREG when we have a test case.\nstatic SDValue combineShuffleToVectorExtend(ShuffleVectorSDNode *SVN,\n                                            SelectionDAG &DAG,\n                                            const TargetLowering &TLI,\n                                            bool LegalOperations) {\n  EVT VT = SVN->getValueType(0);\n  bool IsBigEndian = DAG.getDataLayout().isBigEndian();\n\n  // TODO Add support for big-endian when we have a test case.\n  if (!VT.isInteger() || IsBigEndian)\n    return SDValue();\n\n  unsigned NumElts = VT.getVectorNumElements();\n  unsigned EltSizeInBits = VT.getScalarSizeInBits();\n  ArrayRef<int> Mask = SVN->getMask();\n  SDValue N0 = SVN->getOperand(0);\n\n  // shuffle<0,-1,1,-1> == (v2i64 anyextend_vector_inreg(v4i32))\n  auto isAnyExtend = [&Mask, &NumElts](unsigned Scale) {\n    for (unsigned i = 0; i != NumElts; ++i) {\n      if (Mask[i] < 0)\n        continue;\n      if ((i % Scale) == 0 && Mask[i] == (int)(i / Scale))\n        continue;\n      return false;\n    }\n    return true;\n  };\n\n  // Attempt to match a '*_extend_vector_inreg' shuffle, we just search for\n  // power-of-2 extensions as they are the most likely.\n  for (unsigned Scale = 2; Scale < NumElts; Scale *= 2) {\n    // Check for non power of 2 vector sizes\n    if (NumElts % Scale != 0)\n      continue;\n    if (!isAnyExtend(Scale))\n      continue;\n\n    EVT OutSVT = EVT::getIntegerVT(*DAG.getContext(), EltSizeInBits * Scale);\n    EVT OutVT = EVT::getVectorVT(*DAG.getContext(), OutSVT, NumElts / Scale);\n    // Never create an illegal type. Only create unsupported operations if we\n    // are pre-legalization.\n    if (TLI.isTypeLegal(OutVT))\n      if (!LegalOperations ||\n          TLI.isOperationLegalOrCustom(ISD::ANY_EXTEND_VECTOR_INREG, OutVT))\n        return DAG.getBitcast(VT,\n                              DAG.getNode(ISD::ANY_EXTEND_VECTOR_INREG,\n                                          SDLoc(SVN), OutVT, N0));\n  }\n\n  return SDValue();\n}\n\n// Detect 'truncate_vector_inreg' style shuffles that pack the lower parts of\n// each source element of a large type into the lowest elements of a smaller\n// destination type. This is often generated during legalization.\n// If the source node itself was a '*_extend_vector_inreg' node then we should\n// then be able to remove it.\nstatic SDValue combineTruncationShuffle(ShuffleVectorSDNode *SVN,\n                                        SelectionDAG &DAG) {\n  EVT VT = SVN->getValueType(0);\n  bool IsBigEndian = DAG.getDataLayout().isBigEndian();\n\n  // TODO Add support for big-endian when we have a test case.\n  if (!VT.isInteger() || IsBigEndian)\n    return SDValue();\n\n  SDValue N0 = peekThroughBitcasts(SVN->getOperand(0));\n\n  unsigned Opcode = N0.getOpcode();\n  if (Opcode != ISD::ANY_EXTEND_VECTOR_INREG &&\n      Opcode != ISD::SIGN_EXTEND_VECTOR_INREG &&\n      Opcode != ISD::ZERO_EXTEND_VECTOR_INREG)\n    return SDValue();\n\n  SDValue N00 = N0.getOperand(0);\n  ArrayRef<int> Mask = SVN->getMask();\n  unsigned NumElts = VT.getVectorNumElements();\n  unsigned EltSizeInBits = VT.getScalarSizeInBits();\n  unsigned ExtSrcSizeInBits = N00.getScalarValueSizeInBits();\n  unsigned ExtDstSizeInBits = N0.getScalarValueSizeInBits();\n\n  if (ExtDstSizeInBits % ExtSrcSizeInBits != 0)\n    return SDValue();\n  unsigned ExtScale = ExtDstSizeInBits / ExtSrcSizeInBits;\n\n  // (v4i32 truncate_vector_inreg(v2i64)) == shuffle<0,2-1,-1>\n  // (v8i16 truncate_vector_inreg(v4i32)) == shuffle<0,2,4,6,-1,-1,-1,-1>\n  // (v8i16 truncate_vector_inreg(v2i64)) == shuffle<0,4,-1,-1,-1,-1,-1,-1>\n  auto isTruncate = [&Mask, &NumElts](unsigned Scale) {\n    for (unsigned i = 0; i != NumElts; ++i) {\n      if (Mask[i] < 0)\n        continue;\n      if ((i * Scale) < NumElts && Mask[i] == (int)(i * Scale))\n        continue;\n      return false;\n    }\n    return true;\n  };\n\n  // At the moment we just handle the case where we've truncated back to the\n  // same size as before the extension.\n  // TODO: handle more extension/truncation cases as cases arise.\n  if (EltSizeInBits != ExtSrcSizeInBits)\n    return SDValue();\n\n  // We can remove *extend_vector_inreg only if the truncation happens at\n  // the same scale as the extension.\n  if (isTruncate(ExtScale))\n    return DAG.getBitcast(VT, N00);\n\n  return SDValue();\n}\n\n// Combine shuffles of splat-shuffles of the form:\n// shuffle (shuffle V, undef, splat-mask), undef, M\n// If splat-mask contains undef elements, we need to be careful about\n// introducing undef's in the folded mask which are not the result of composing\n// the masks of the shuffles.\nstatic SDValue combineShuffleOfSplatVal(ShuffleVectorSDNode *Shuf,\n                                        SelectionDAG &DAG) {\n  if (!Shuf->getOperand(1).isUndef())\n    return SDValue();\n  auto *Splat = dyn_cast<ShuffleVectorSDNode>(Shuf->getOperand(0));\n  if (!Splat || !Splat->isSplat())\n    return SDValue();\n\n  ArrayRef<int> ShufMask = Shuf->getMask();\n  ArrayRef<int> SplatMask = Splat->getMask();\n  assert(ShufMask.size() == SplatMask.size() && \"Mask length mismatch\");\n\n  // Prefer simplifying to the splat-shuffle, if possible. This is legal if\n  // every undef mask element in the splat-shuffle has a corresponding undef\n  // element in the user-shuffle's mask or if the composition of mask elements\n  // would result in undef.\n  // Examples for (shuffle (shuffle v, undef, SplatMask), undef, UserMask):\n  // * UserMask=[0,2,u,u], SplatMask=[2,u,2,u] -> [2,2,u,u]\n  //   In this case it is not legal to simplify to the splat-shuffle because we\n  //   may be exposing the users of the shuffle an undef element at index 1\n  //   which was not there before the combine.\n  // * UserMask=[0,u,2,u], SplatMask=[2,u,2,u] -> [2,u,2,u]\n  //   In this case the composition of masks yields SplatMask, so it's ok to\n  //   simplify to the splat-shuffle.\n  // * UserMask=[3,u,2,u], SplatMask=[2,u,2,u] -> [u,u,2,u]\n  //   In this case the composed mask includes all undef elements of SplatMask\n  //   and in addition sets element zero to undef. It is safe to simplify to\n  //   the splat-shuffle.\n  auto CanSimplifyToExistingSplat = [](ArrayRef<int> UserMask,\n                                       ArrayRef<int> SplatMask) {\n    for (unsigned i = 0, e = UserMask.size(); i != e; ++i)\n      if (UserMask[i] != -1 && SplatMask[i] == -1 &&\n          SplatMask[UserMask[i]] != -1)\n        return false;\n    return true;\n  };\n  if (CanSimplifyToExistingSplat(ShufMask, SplatMask))\n    return Shuf->getOperand(0);\n\n  // Create a new shuffle with a mask that is composed of the two shuffles'\n  // masks.\n  SmallVector<int, 32> NewMask;\n  for (int Idx : ShufMask)\n    NewMask.push_back(Idx == -1 ? -1 : SplatMask[Idx]);\n\n  return DAG.getVectorShuffle(Splat->getValueType(0), SDLoc(Splat),\n                              Splat->getOperand(0), Splat->getOperand(1),\n                              NewMask);\n}\n\n/// Combine shuffle of shuffle of the form:\n/// shuf (shuf X, undef, InnerMask), undef, OuterMask --> splat X\nstatic SDValue formSplatFromShuffles(ShuffleVectorSDNode *OuterShuf,\n                                     SelectionDAG &DAG) {\n  if (!OuterShuf->getOperand(1).isUndef())\n    return SDValue();\n  auto *InnerShuf = dyn_cast<ShuffleVectorSDNode>(OuterShuf->getOperand(0));\n  if (!InnerShuf || !InnerShuf->getOperand(1).isUndef())\n    return SDValue();\n\n  ArrayRef<int> OuterMask = OuterShuf->getMask();\n  ArrayRef<int> InnerMask = InnerShuf->getMask();\n  unsigned NumElts = OuterMask.size();\n  assert(NumElts == InnerMask.size() && \"Mask length mismatch\");\n  SmallVector<int, 32> CombinedMask(NumElts, -1);\n  int SplatIndex = -1;\n  for (unsigned i = 0; i != NumElts; ++i) {\n    // Undef lanes remain undef.\n    int OuterMaskElt = OuterMask[i];\n    if (OuterMaskElt == -1)\n      continue;\n\n    // Peek through the shuffle masks to get the underlying source element.\n    int InnerMaskElt = InnerMask[OuterMaskElt];\n    if (InnerMaskElt == -1)\n      continue;\n\n    // Initialize the splatted element.\n    if (SplatIndex == -1)\n      SplatIndex = InnerMaskElt;\n\n    // Non-matching index - this is not a splat.\n    if (SplatIndex != InnerMaskElt)\n      return SDValue();\n\n    CombinedMask[i] = InnerMaskElt;\n  }\n  assert((all_of(CombinedMask, [](int M) { return M == -1; }) ||\n          getSplatIndex(CombinedMask) != -1) &&\n         \"Expected a splat mask\");\n\n  // TODO: The transform may be a win even if the mask is not legal.\n  EVT VT = OuterShuf->getValueType(0);\n  assert(VT == InnerShuf->getValueType(0) && \"Expected matching shuffle types\");\n  if (!DAG.getTargetLoweringInfo().isShuffleMaskLegal(CombinedMask, VT))\n    return SDValue();\n\n  return DAG.getVectorShuffle(VT, SDLoc(OuterShuf), InnerShuf->getOperand(0),\n                              InnerShuf->getOperand(1), CombinedMask);\n}\n\n/// If the shuffle mask is taking exactly one element from the first vector\n/// operand and passing through all other elements from the second vector\n/// operand, return the index of the mask element that is choosing an element\n/// from the first operand. Otherwise, return -1.\nstatic int getShuffleMaskIndexOfOneElementFromOp0IntoOp1(ArrayRef<int> Mask) {\n  int MaskSize = Mask.size();\n  int EltFromOp0 = -1;\n  // TODO: This does not match if there are undef elements in the shuffle mask.\n  // Should we ignore undefs in the shuffle mask instead? The trade-off is\n  // removing an instruction (a shuffle), but losing the knowledge that some\n  // vector lanes are not needed.\n  for (int i = 0; i != MaskSize; ++i) {\n    if (Mask[i] >= 0 && Mask[i] < MaskSize) {\n      // We're looking for a shuffle of exactly one element from operand 0.\n      if (EltFromOp0 != -1)\n        return -1;\n      EltFromOp0 = i;\n    } else if (Mask[i] != i + MaskSize) {\n      // Nothing from operand 1 can change lanes.\n      return -1;\n    }\n  }\n  return EltFromOp0;\n}\n\n/// If a shuffle inserts exactly one element from a source vector operand into\n/// another vector operand and we can access the specified element as a scalar,\n/// then we can eliminate the shuffle.\nstatic SDValue replaceShuffleOfInsert(ShuffleVectorSDNode *Shuf,\n                                      SelectionDAG &DAG) {\n  // First, check if we are taking one element of a vector and shuffling that\n  // element into another vector.\n  ArrayRef<int> Mask = Shuf->getMask();\n  SmallVector<int, 16> CommutedMask(Mask.begin(), Mask.end());\n  SDValue Op0 = Shuf->getOperand(0);\n  SDValue Op1 = Shuf->getOperand(1);\n  int ShufOp0Index = getShuffleMaskIndexOfOneElementFromOp0IntoOp1(Mask);\n  if (ShufOp0Index == -1) {\n    // Commute mask and check again.\n    ShuffleVectorSDNode::commuteMask(CommutedMask);\n    ShufOp0Index = getShuffleMaskIndexOfOneElementFromOp0IntoOp1(CommutedMask);\n    if (ShufOp0Index == -1)\n      return SDValue();\n    // Commute operands to match the commuted shuffle mask.\n    std::swap(Op0, Op1);\n    Mask = CommutedMask;\n  }\n\n  // The shuffle inserts exactly one element from operand 0 into operand 1.\n  // Now see if we can access that element as a scalar via a real insert element\n  // instruction.\n  // TODO: We can try harder to locate the element as a scalar. Examples: it\n  // could be an operand of SCALAR_TO_VECTOR, BUILD_VECTOR, or a constant.\n  assert(Mask[ShufOp0Index] >= 0 && Mask[ShufOp0Index] < (int)Mask.size() &&\n         \"Shuffle mask value must be from operand 0\");\n  if (Op0.getOpcode() != ISD::INSERT_VECTOR_ELT)\n    return SDValue();\n\n  auto *InsIndexC = dyn_cast<ConstantSDNode>(Op0.getOperand(2));\n  if (!InsIndexC || InsIndexC->getSExtValue() != Mask[ShufOp0Index])\n    return SDValue();\n\n  // There's an existing insertelement with constant insertion index, so we\n  // don't need to check the legality/profitability of a replacement operation\n  // that differs at most in the constant value. The target should be able to\n  // lower any of those in a similar way. If not, legalization will expand this\n  // to a scalar-to-vector plus shuffle.\n  //\n  // Note that the shuffle may move the scalar from the position that the insert\n  // element used. Therefore, our new insert element occurs at the shuffle's\n  // mask index value, not the insert's index value.\n  // shuffle (insertelt v1, x, C), v2, mask --> insertelt v2, x, C'\n  SDValue NewInsIndex = DAG.getVectorIdxConstant(ShufOp0Index, SDLoc(Shuf));\n  return DAG.getNode(ISD::INSERT_VECTOR_ELT, SDLoc(Shuf), Op0.getValueType(),\n                     Op1, Op0.getOperand(1), NewInsIndex);\n}\n\n/// If we have a unary shuffle of a shuffle, see if it can be folded away\n/// completely. This has the potential to lose undef knowledge because the first\n/// shuffle may not have an undef mask element where the second one does. So\n/// only call this after doing simplifications based on demanded elements.\nstatic SDValue simplifyShuffleOfShuffle(ShuffleVectorSDNode *Shuf) {\n  // shuf (shuf0 X, Y, Mask0), undef, Mask\n  auto *Shuf0 = dyn_cast<ShuffleVectorSDNode>(Shuf->getOperand(0));\n  if (!Shuf0 || !Shuf->getOperand(1).isUndef())\n    return SDValue();\n\n  ArrayRef<int> Mask = Shuf->getMask();\n  ArrayRef<int> Mask0 = Shuf0->getMask();\n  for (int i = 0, e = (int)Mask.size(); i != e; ++i) {\n    // Ignore undef elements.\n    if (Mask[i] == -1)\n      continue;\n    assert(Mask[i] >= 0 && Mask[i] < e && \"Unexpected shuffle mask value\");\n\n    // Is the element of the shuffle operand chosen by this shuffle the same as\n    // the element chosen by the shuffle operand itself?\n    if (Mask0[Mask[i]] != Mask0[i])\n      return SDValue();\n  }\n  // Every element of this shuffle is identical to the result of the previous\n  // shuffle, so we can replace this value.\n  return Shuf->getOperand(0);\n}\n\nSDValue DAGCombiner::visitVECTOR_SHUFFLE(SDNode *N) {\n  EVT VT = N->getValueType(0);\n  unsigned NumElts = VT.getVectorNumElements();\n\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n\n  assert(N0.getValueType() == VT && \"Vector shuffle must be normalized in DAG\");\n\n  // Canonicalize shuffle undef, undef -> undef\n  if (N0.isUndef() && N1.isUndef())\n    return DAG.getUNDEF(VT);\n\n  ShuffleVectorSDNode *SVN = cast<ShuffleVectorSDNode>(N);\n\n  // Canonicalize shuffle v, v -> v, undef\n  if (N0 == N1) {\n    SmallVector<int, 8> NewMask;\n    for (unsigned i = 0; i != NumElts; ++i) {\n      int Idx = SVN->getMaskElt(i);\n      if (Idx >= (int)NumElts) Idx -= NumElts;\n      NewMask.push_back(Idx);\n    }\n    return DAG.getVectorShuffle(VT, SDLoc(N), N0, DAG.getUNDEF(VT), NewMask);\n  }\n\n  // Canonicalize shuffle undef, v -> v, undef.  Commute the shuffle mask.\n  if (N0.isUndef())\n    return DAG.getCommutedVectorShuffle(*SVN);\n\n  // Remove references to rhs if it is undef\n  if (N1.isUndef()) {\n    bool Changed = false;\n    SmallVector<int, 8> NewMask;\n    for (unsigned i = 0; i != NumElts; ++i) {\n      int Idx = SVN->getMaskElt(i);\n      if (Idx >= (int)NumElts) {\n        Idx = -1;\n        Changed = true;\n      }\n      NewMask.push_back(Idx);\n    }\n    if (Changed)\n      return DAG.getVectorShuffle(VT, SDLoc(N), N0, N1, NewMask);\n  }\n\n  if (SDValue InsElt = replaceShuffleOfInsert(SVN, DAG))\n    return InsElt;\n\n  // A shuffle of a single vector that is a splatted value can always be folded.\n  if (SDValue V = combineShuffleOfSplatVal(SVN, DAG))\n    return V;\n\n  if (SDValue V = formSplatFromShuffles(SVN, DAG))\n    return V;\n\n  // If it is a splat, check if the argument vector is another splat or a\n  // build_vector.\n  if (SVN->isSplat() && SVN->getSplatIndex() < (int)NumElts) {\n    int SplatIndex = SVN->getSplatIndex();\n    if (N0.hasOneUse() && TLI.isExtractVecEltCheap(VT, SplatIndex) &&\n        TLI.isBinOp(N0.getOpcode()) && N0.getNode()->getNumValues() == 1) {\n      // splat (vector_bo L, R), Index -->\n      // splat (scalar_bo (extelt L, Index), (extelt R, Index))\n      SDValue L = N0.getOperand(0), R = N0.getOperand(1);\n      SDLoc DL(N);\n      EVT EltVT = VT.getScalarType();\n      SDValue Index = DAG.getVectorIdxConstant(SplatIndex, DL);\n      SDValue ExtL = DAG.getNode(ISD::EXTRACT_VECTOR_ELT, DL, EltVT, L, Index);\n      SDValue ExtR = DAG.getNode(ISD::EXTRACT_VECTOR_ELT, DL, EltVT, R, Index);\n      SDValue NewBO = DAG.getNode(N0.getOpcode(), DL, EltVT, ExtL, ExtR,\n                                  N0.getNode()->getFlags());\n      SDValue Insert = DAG.getNode(ISD::SCALAR_TO_VECTOR, DL, VT, NewBO);\n      SmallVector<int, 16> ZeroMask(VT.getVectorNumElements(), 0);\n      return DAG.getVectorShuffle(VT, DL, Insert, DAG.getUNDEF(VT), ZeroMask);\n    }\n\n    // If this is a bit convert that changes the element type of the vector but\n    // not the number of vector elements, look through it.  Be careful not to\n    // look though conversions that change things like v4f32 to v2f64.\n    SDNode *V = N0.getNode();\n    if (V->getOpcode() == ISD::BITCAST) {\n      SDValue ConvInput = V->getOperand(0);\n      if (ConvInput.getValueType().isVector() &&\n          ConvInput.getValueType().getVectorNumElements() == NumElts)\n        V = ConvInput.getNode();\n    }\n\n    if (V->getOpcode() == ISD::BUILD_VECTOR) {\n      assert(V->getNumOperands() == NumElts &&\n             \"BUILD_VECTOR has wrong number of operands\");\n      SDValue Base;\n      bool AllSame = true;\n      for (unsigned i = 0; i != NumElts; ++i) {\n        if (!V->getOperand(i).isUndef()) {\n          Base = V->getOperand(i);\n          break;\n        }\n      }\n      // Splat of <u, u, u, u>, return <u, u, u, u>\n      if (!Base.getNode())\n        return N0;\n      for (unsigned i = 0; i != NumElts; ++i) {\n        if (V->getOperand(i) != Base) {\n          AllSame = false;\n          break;\n        }\n      }\n      // Splat of <x, x, x, x>, return <x, x, x, x>\n      if (AllSame)\n        return N0;\n\n      // Canonicalize any other splat as a build_vector.\n      SDValue Splatted = V->getOperand(SplatIndex);\n      SmallVector<SDValue, 8> Ops(NumElts, Splatted);\n      SDValue NewBV = DAG.getBuildVector(V->getValueType(0), SDLoc(N), Ops);\n\n      // We may have jumped through bitcasts, so the type of the\n      // BUILD_VECTOR may not match the type of the shuffle.\n      if (V->getValueType(0) != VT)\n        NewBV = DAG.getBitcast(VT, NewBV);\n      return NewBV;\n    }\n  }\n\n  // Simplify source operands based on shuffle mask.\n  if (SimplifyDemandedVectorElts(SDValue(N, 0)))\n    return SDValue(N, 0);\n\n  // This is intentionally placed after demanded elements simplification because\n  // it could eliminate knowledge of undef elements created by this shuffle.\n  if (SDValue ShufOp = simplifyShuffleOfShuffle(SVN))\n    return ShufOp;\n\n  // Match shuffles that can be converted to any_vector_extend_in_reg.\n  if (SDValue V = combineShuffleToVectorExtend(SVN, DAG, TLI, LegalOperations))\n    return V;\n\n  // Combine \"truncate_vector_in_reg\" style shuffles.\n  if (SDValue V = combineTruncationShuffle(SVN, DAG))\n    return V;\n\n  if (N0.getOpcode() == ISD::CONCAT_VECTORS &&\n      Level < AfterLegalizeVectorOps &&\n      (N1.isUndef() ||\n      (N1.getOpcode() == ISD::CONCAT_VECTORS &&\n       N0.getOperand(0).getValueType() == N1.getOperand(0).getValueType()))) {\n    if (SDValue V = partitionShuffleOfConcats(N, DAG))\n      return V;\n  }\n\n  // A shuffle of a concat of the same narrow vector can be reduced to use\n  // only low-half elements of a concat with undef:\n  // shuf (concat X, X), undef, Mask --> shuf (concat X, undef), undef, Mask'\n  if (N0.getOpcode() == ISD::CONCAT_VECTORS && N1.isUndef() &&\n      N0.getNumOperands() == 2 &&\n      N0.getOperand(0) == N0.getOperand(1)) {\n    int HalfNumElts = (int)NumElts / 2;\n    SmallVector<int, 8> NewMask;\n    for (unsigned i = 0; i != NumElts; ++i) {\n      int Idx = SVN->getMaskElt(i);\n      if (Idx >= HalfNumElts) {\n        assert(Idx < (int)NumElts && \"Shuffle mask chooses undef op\");\n        Idx -= HalfNumElts;\n      }\n      NewMask.push_back(Idx);\n    }\n    if (TLI.isShuffleMaskLegal(NewMask, VT)) {\n      SDValue UndefVec = DAG.getUNDEF(N0.getOperand(0).getValueType());\n      SDValue NewCat = DAG.getNode(ISD::CONCAT_VECTORS, SDLoc(N), VT,\n                                   N0.getOperand(0), UndefVec);\n      return DAG.getVectorShuffle(VT, SDLoc(N), NewCat, N1, NewMask);\n    }\n  }\n\n  // Attempt to combine a shuffle of 2 inputs of 'scalar sources' -\n  // BUILD_VECTOR or SCALAR_TO_VECTOR into a single BUILD_VECTOR.\n  if (Level < AfterLegalizeDAG && TLI.isTypeLegal(VT))\n    if (SDValue Res = combineShuffleOfScalars(SVN, DAG, TLI))\n      return Res;\n\n  // If this shuffle only has a single input that is a bitcasted shuffle,\n  // attempt to merge the 2 shuffles and suitably bitcast the inputs/output\n  // back to their original types.\n  if (N0.getOpcode() == ISD::BITCAST && N0.hasOneUse() &&\n      N1.isUndef() && Level < AfterLegalizeVectorOps &&\n      TLI.isTypeLegal(VT)) {\n\n    SDValue BC0 = peekThroughOneUseBitcasts(N0);\n    if (BC0.getOpcode() == ISD::VECTOR_SHUFFLE && BC0.hasOneUse()) {\n      EVT SVT = VT.getScalarType();\n      EVT InnerVT = BC0->getValueType(0);\n      EVT InnerSVT = InnerVT.getScalarType();\n\n      // Determine which shuffle works with the smaller scalar type.\n      EVT ScaleVT = SVT.bitsLT(InnerSVT) ? VT : InnerVT;\n      EVT ScaleSVT = ScaleVT.getScalarType();\n\n      if (TLI.isTypeLegal(ScaleVT) &&\n          0 == (InnerSVT.getSizeInBits() % ScaleSVT.getSizeInBits()) &&\n          0 == (SVT.getSizeInBits() % ScaleSVT.getSizeInBits())) {\n        int InnerScale = InnerSVT.getSizeInBits() / ScaleSVT.getSizeInBits();\n        int OuterScale = SVT.getSizeInBits() / ScaleSVT.getSizeInBits();\n\n        // Scale the shuffle masks to the smaller scalar type.\n        ShuffleVectorSDNode *InnerSVN = cast<ShuffleVectorSDNode>(BC0);\n        SmallVector<int, 8> InnerMask;\n        SmallVector<int, 8> OuterMask;\n        narrowShuffleMaskElts(InnerScale, InnerSVN->getMask(), InnerMask);\n        narrowShuffleMaskElts(OuterScale, SVN->getMask(), OuterMask);\n\n        // Merge the shuffle masks.\n        SmallVector<int, 8> NewMask;\n        for (int M : OuterMask)\n          NewMask.push_back(M < 0 ? -1 : InnerMask[M]);\n\n        // Test for shuffle mask legality over both commutations.\n        SDValue SV0 = BC0->getOperand(0);\n        SDValue SV1 = BC0->getOperand(1);\n        bool LegalMask = TLI.isShuffleMaskLegal(NewMask, ScaleVT);\n        if (!LegalMask) {\n          std::swap(SV0, SV1);\n          ShuffleVectorSDNode::commuteMask(NewMask);\n          LegalMask = TLI.isShuffleMaskLegal(NewMask, ScaleVT);\n        }\n\n        if (LegalMask) {\n          SV0 = DAG.getBitcast(ScaleVT, SV0);\n          SV1 = DAG.getBitcast(ScaleVT, SV1);\n          return DAG.getBitcast(\n              VT, DAG.getVectorShuffle(ScaleVT, SDLoc(N), SV0, SV1, NewMask));\n        }\n      }\n    }\n  }\n\n  // Compute the combined shuffle mask for a shuffle with SV0 as the first\n  // operand, and SV1 as the second operand.\n  // i.e. Merge SVN(OtherSVN, N1) -> shuffle(SV0, SV1, Mask) iff Commute = false\n  //      Merge SVN(N1, OtherSVN) -> shuffle(SV0, SV1, Mask') iff Commute = true\n  auto MergeInnerShuffle =\n      [NumElts, &VT](bool Commute, ShuffleVectorSDNode *SVN,\n                     ShuffleVectorSDNode *OtherSVN, SDValue N1,\n                     const TargetLowering &TLI, SDValue &SV0, SDValue &SV1,\n                     SmallVectorImpl<int> &Mask) -> bool {\n    // Don't try to fold splats; they're likely to simplify somehow, or they\n    // might be free.\n    if (OtherSVN->isSplat())\n      return false;\n\n    SV0 = SV1 = SDValue();\n    Mask.clear();\n\n    for (unsigned i = 0; i != NumElts; ++i) {\n      int Idx = SVN->getMaskElt(i);\n      if (Idx < 0) {\n        // Propagate Undef.\n        Mask.push_back(Idx);\n        continue;\n      }\n\n      if (Commute)\n        Idx = (Idx < (int)NumElts) ? (Idx + NumElts) : (Idx - NumElts);\n\n      SDValue CurrentVec;\n      if (Idx < (int)NumElts) {\n        // This shuffle index refers to the inner shuffle N0. Lookup the inner\n        // shuffle mask to identify which vector is actually referenced.\n        Idx = OtherSVN->getMaskElt(Idx);\n        if (Idx < 0) {\n          // Propagate Undef.\n          Mask.push_back(Idx);\n          continue;\n        }\n        CurrentVec = (Idx < (int)NumElts) ? OtherSVN->getOperand(0)\n                                          : OtherSVN->getOperand(1);\n      } else {\n        // This shuffle index references an element within N1.\n        CurrentVec = N1;\n      }\n\n      // Simple case where 'CurrentVec' is UNDEF.\n      if (CurrentVec.isUndef()) {\n        Mask.push_back(-1);\n        continue;\n      }\n\n      // Canonicalize the shuffle index. We don't know yet if CurrentVec\n      // will be the first or second operand of the combined shuffle.\n      Idx = Idx % NumElts;\n      if (!SV0.getNode() || SV0 == CurrentVec) {\n        // Ok. CurrentVec is the left hand side.\n        // Update the mask accordingly.\n        SV0 = CurrentVec;\n        Mask.push_back(Idx);\n        continue;\n      }\n      if (!SV1.getNode() || SV1 == CurrentVec) {\n        // Ok. CurrentVec is the right hand side.\n        // Update the mask accordingly.\n        SV1 = CurrentVec;\n        Mask.push_back(Idx + NumElts);\n        continue;\n      }\n\n      // Last chance - see if the vector is another shuffle and if it\n      // uses one of the existing candidate shuffle ops.\n      if (auto *CurrentSVN = dyn_cast<ShuffleVectorSDNode>(CurrentVec)) {\n        int InnerIdx = CurrentSVN->getMaskElt(Idx);\n        if (InnerIdx < 0) {\n          Mask.push_back(-1);\n          continue;\n        }\n        SDValue InnerVec = (InnerIdx < (int)NumElts)\n                               ? CurrentSVN->getOperand(0)\n                               : CurrentSVN->getOperand(1);\n        if (InnerVec.isUndef()) {\n          Mask.push_back(-1);\n          continue;\n        }\n        InnerIdx %= NumElts;\n        if (InnerVec == SV0) {\n          Mask.push_back(InnerIdx);\n          continue;\n        }\n        if (InnerVec == SV1) {\n          Mask.push_back(InnerIdx + NumElts);\n          continue;\n        }\n      }\n\n      // Bail out if we cannot convert the shuffle pair into a single shuffle.\n      return false;\n    }\n\n    if (llvm::all_of(Mask, [](int M) { return M < 0; }))\n      return true;\n\n    // Avoid introducing shuffles with illegal mask.\n    //   shuffle(shuffle(A, B, M0), C, M1) -> shuffle(A, B, M2)\n    //   shuffle(shuffle(A, B, M0), C, M1) -> shuffle(A, C, M2)\n    //   shuffle(shuffle(A, B, M0), C, M1) -> shuffle(B, C, M2)\n    //   shuffle(shuffle(A, B, M0), C, M1) -> shuffle(B, A, M2)\n    //   shuffle(shuffle(A, B, M0), C, M1) -> shuffle(C, A, M2)\n    //   shuffle(shuffle(A, B, M0), C, M1) -> shuffle(C, B, M2)\n    if (TLI.isShuffleMaskLegal(Mask, VT))\n      return true;\n\n    std::swap(SV0, SV1);\n    ShuffleVectorSDNode::commuteMask(Mask);\n    return TLI.isShuffleMaskLegal(Mask, VT);\n  };\n\n  if (Level < AfterLegalizeDAG && TLI.isTypeLegal(VT)) {\n    // Canonicalize shuffles according to rules:\n    //  shuffle(A, shuffle(A, B)) -> shuffle(shuffle(A,B), A)\n    //  shuffle(B, shuffle(A, B)) -> shuffle(shuffle(A,B), B)\n    //  shuffle(B, shuffle(A, Undef)) -> shuffle(shuffle(A, Undef), B)\n    if (N1.getOpcode() == ISD::VECTOR_SHUFFLE &&\n        N0.getOpcode() != ISD::VECTOR_SHUFFLE) {\n      // The incoming shuffle must be of the same type as the result of the\n      // current shuffle.\n      assert(N1->getOperand(0).getValueType() == VT &&\n             \"Shuffle types don't match\");\n\n      SDValue SV0 = N1->getOperand(0);\n      SDValue SV1 = N1->getOperand(1);\n      bool HasSameOp0 = N0 == SV0;\n      bool IsSV1Undef = SV1.isUndef();\n      if (HasSameOp0 || IsSV1Undef || N0 == SV1)\n        // Commute the operands of this shuffle so merging below will trigger.\n        return DAG.getCommutedVectorShuffle(*SVN);\n    }\n\n    // Canonicalize splat shuffles to the RHS to improve merging below.\n    //  shuffle(splat(A,u), shuffle(C,D)) -> shuffle'(shuffle(C,D), splat(A,u))\n    if (N0.getOpcode() == ISD::VECTOR_SHUFFLE &&\n        N1.getOpcode() == ISD::VECTOR_SHUFFLE &&\n        cast<ShuffleVectorSDNode>(N0)->isSplat() &&\n        !cast<ShuffleVectorSDNode>(N1)->isSplat()) {\n      return DAG.getCommutedVectorShuffle(*SVN);\n    }\n\n    // Try to fold according to rules:\n    //   shuffle(shuffle(A, B, M0), C, M1) -> shuffle(A, B, M2)\n    //   shuffle(shuffle(A, B, M0), C, M1) -> shuffle(A, C, M2)\n    //   shuffle(shuffle(A, B, M0), C, M1) -> shuffle(B, C, M2)\n    // Don't try to fold shuffles with illegal type.\n    // Only fold if this shuffle is the only user of the other shuffle.\n    // Try matching shuffle(C,shuffle(A,B)) commutted patterns as well.\n    for (int i = 0; i != 2; ++i) {\n      if (N->getOperand(i).getOpcode() == ISD::VECTOR_SHUFFLE &&\n          N->isOnlyUserOf(N->getOperand(i).getNode())) {\n        // The incoming shuffle must be of the same type as the result of the\n        // current shuffle.\n        auto *OtherSV = cast<ShuffleVectorSDNode>(N->getOperand(i));\n        assert(OtherSV->getOperand(0).getValueType() == VT &&\n               \"Shuffle types don't match\");\n\n        SDValue SV0, SV1;\n        SmallVector<int, 4> Mask;\n        if (MergeInnerShuffle(i != 0, SVN, OtherSV, N->getOperand(1 - i), TLI,\n                              SV0, SV1, Mask)) {\n          // Check if all indices in Mask are Undef. In case, propagate Undef.\n          if (llvm::all_of(Mask, [](int M) { return M < 0; }))\n            return DAG.getUNDEF(VT);\n\n          return DAG.getVectorShuffle(VT, SDLoc(N),\n                                      SV0 ? SV0 : DAG.getUNDEF(VT),\n                                      SV1 ? SV1 : DAG.getUNDEF(VT), Mask);\n        }\n      }\n    }\n\n    // Merge shuffles through binops if we are able to merge it with at least\n    // one other shuffles.\n    // shuffle(bop(shuffle(x,y),shuffle(z,w)),undef)\n    // shuffle(bop(shuffle(x,y),shuffle(z,w)),bop(shuffle(a,b),shuffle(c,d)))\n    unsigned SrcOpcode = N0.getOpcode();\n    if (TLI.isBinOp(SrcOpcode) && N->isOnlyUserOf(N0.getNode()) &&\n        (N1.isUndef() ||\n         (SrcOpcode == N1.getOpcode() && N->isOnlyUserOf(N1.getNode())))) {\n      // Get binop source ops, or just pass on the undef.\n      SDValue Op00 = N0.getOperand(0);\n      SDValue Op01 = N0.getOperand(1);\n      SDValue Op10 = N1.isUndef() ? N1 : N1.getOperand(0);\n      SDValue Op11 = N1.isUndef() ? N1 : N1.getOperand(1);\n      // TODO: We might be able to relax the VT check but we don't currently\n      // have any isBinOp() that has different result/ops VTs so play safe until\n      // we have test coverage.\n      if (Op00.getValueType() == VT && Op10.getValueType() == VT &&\n          Op01.getValueType() == VT && Op11.getValueType() == VT &&\n          (Op00.getOpcode() == ISD::VECTOR_SHUFFLE ||\n           Op10.getOpcode() == ISD::VECTOR_SHUFFLE ||\n           Op01.getOpcode() == ISD::VECTOR_SHUFFLE ||\n           Op11.getOpcode() == ISD::VECTOR_SHUFFLE)) {\n        auto CanMergeInnerShuffle = [&](SDValue &SV0, SDValue &SV1,\n                                        SmallVectorImpl<int> &Mask, bool LeftOp,\n                                        bool Commute) {\n          SDValue InnerN = Commute ? N1 : N0;\n          SDValue Op0 = LeftOp ? Op00 : Op01;\n          SDValue Op1 = LeftOp ? Op10 : Op11;\n          if (Commute)\n            std::swap(Op0, Op1);\n          return Op0.getOpcode() == ISD::VECTOR_SHUFFLE &&\n                 InnerN->isOnlyUserOf(Op0.getNode()) &&\n                 MergeInnerShuffle(Commute, SVN, cast<ShuffleVectorSDNode>(Op0),\n                                   Op1, TLI, SV0, SV1, Mask) &&\n                 llvm::none_of(Mask, [](int M) { return M < 0; });\n        };\n\n        // Ensure we don't increase the number of shuffles - we must merge a\n        // shuffle from at least one of the LHS and RHS ops.\n        bool MergedLeft = false;\n        SDValue LeftSV0, LeftSV1;\n        SmallVector<int, 4> LeftMask;\n        if (CanMergeInnerShuffle(LeftSV0, LeftSV1, LeftMask, true, false) ||\n            CanMergeInnerShuffle(LeftSV0, LeftSV1, LeftMask, true, true)) {\n          MergedLeft = true;\n        } else {\n          LeftMask.assign(SVN->getMask().begin(), SVN->getMask().end());\n          LeftSV0 = Op00, LeftSV1 = Op10;\n        }\n\n        bool MergedRight = false;\n        SDValue RightSV0, RightSV1;\n        SmallVector<int, 4> RightMask;\n        if (CanMergeInnerShuffle(RightSV0, RightSV1, RightMask, false, false) ||\n            CanMergeInnerShuffle(RightSV0, RightSV1, RightMask, false, true)) {\n          MergedRight = true;\n        } else {\n          RightMask.assign(SVN->getMask().begin(), SVN->getMask().end());\n          RightSV0 = Op01, RightSV1 = Op11;\n        }\n\n        if (MergedLeft || MergedRight) {\n          SDLoc DL(N);\n          SDValue LHS = DAG.getVectorShuffle(\n              VT, DL, LeftSV0 ? LeftSV0 : DAG.getUNDEF(VT),\n              LeftSV1 ? LeftSV1 : DAG.getUNDEF(VT), LeftMask);\n          SDValue RHS = DAG.getVectorShuffle(\n              VT, DL, RightSV0 ? RightSV0 : DAG.getUNDEF(VT),\n              RightSV1 ? RightSV1 : DAG.getUNDEF(VT), RightMask);\n          return DAG.getNode(SrcOpcode, DL, VT, LHS, RHS);\n        }\n      }\n    }\n  }\n\n  if (SDValue V = foldShuffleOfConcatUndefs(SVN, DAG))\n    return V;\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitSCALAR_TO_VECTOR(SDNode *N) {\n  SDValue InVal = N->getOperand(0);\n  EVT VT = N->getValueType(0);\n\n  // Replace a SCALAR_TO_VECTOR(EXTRACT_VECTOR_ELT(V,C0)) pattern\n  // with a VECTOR_SHUFFLE and possible truncate.\n  if (InVal.getOpcode() == ISD::EXTRACT_VECTOR_ELT &&\n      VT.isFixedLengthVector() &&\n      InVal->getOperand(0).getValueType().isFixedLengthVector()) {\n    SDValue InVec = InVal->getOperand(0);\n    SDValue EltNo = InVal->getOperand(1);\n    auto InVecT = InVec.getValueType();\n    if (ConstantSDNode *C0 = dyn_cast<ConstantSDNode>(EltNo)) {\n      SmallVector<int, 8> NewMask(InVecT.getVectorNumElements(), -1);\n      int Elt = C0->getZExtValue();\n      NewMask[0] = Elt;\n      // If we have an implict truncate do truncate here as long as it's legal.\n      // if it's not legal, this should\n      if (VT.getScalarType() != InVal.getValueType() &&\n          InVal.getValueType().isScalarInteger() &&\n          isTypeLegal(VT.getScalarType())) {\n        SDValue Val =\n            DAG.getNode(ISD::TRUNCATE, SDLoc(InVal), VT.getScalarType(), InVal);\n        return DAG.getNode(ISD::SCALAR_TO_VECTOR, SDLoc(N), VT, Val);\n      }\n      if (VT.getScalarType() == InVecT.getScalarType() &&\n          VT.getVectorNumElements() <= InVecT.getVectorNumElements()) {\n        SDValue LegalShuffle =\n          TLI.buildLegalVectorShuffle(InVecT, SDLoc(N), InVec,\n                                      DAG.getUNDEF(InVecT), NewMask, DAG);\n        if (LegalShuffle) {\n          // If the initial vector is the correct size this shuffle is a\n          // valid result.\n          if (VT == InVecT)\n            return LegalShuffle;\n          // If not we must truncate the vector.\n          if (VT.getVectorNumElements() != InVecT.getVectorNumElements()) {\n            SDValue ZeroIdx = DAG.getVectorIdxConstant(0, SDLoc(N));\n            EVT SubVT = EVT::getVectorVT(*DAG.getContext(),\n                                         InVecT.getVectorElementType(),\n                                         VT.getVectorNumElements());\n            return DAG.getNode(ISD::EXTRACT_SUBVECTOR, SDLoc(N), SubVT,\n                               LegalShuffle, ZeroIdx);\n          }\n        }\n      }\n    }\n  }\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitINSERT_SUBVECTOR(SDNode *N) {\n  EVT VT = N->getValueType(0);\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  SDValue N2 = N->getOperand(2);\n  uint64_t InsIdx = N->getConstantOperandVal(2);\n\n  // If inserting an UNDEF, just return the original vector.\n  if (N1.isUndef())\n    return N0;\n\n  // If this is an insert of an extracted vector into an undef vector, we can\n  // just use the input to the extract.\n  if (N0.isUndef() && N1.getOpcode() == ISD::EXTRACT_SUBVECTOR &&\n      N1.getOperand(1) == N2 && N1.getOperand(0).getValueType() == VT)\n    return N1.getOperand(0);\n\n  // If we are inserting a bitcast value into an undef, with the same\n  // number of elements, just use the bitcast input of the extract.\n  // i.e. INSERT_SUBVECTOR UNDEF (BITCAST N1) N2 ->\n  //        BITCAST (INSERT_SUBVECTOR UNDEF N1 N2)\n  if (N0.isUndef() && N1.getOpcode() == ISD::BITCAST &&\n      N1.getOperand(0).getOpcode() == ISD::EXTRACT_SUBVECTOR &&\n      N1.getOperand(0).getOperand(1) == N2 &&\n      N1.getOperand(0).getOperand(0).getValueType().getVectorElementCount() ==\n          VT.getVectorElementCount() &&\n      N1.getOperand(0).getOperand(0).getValueType().getSizeInBits() ==\n          VT.getSizeInBits()) {\n    return DAG.getBitcast(VT, N1.getOperand(0).getOperand(0));\n  }\n\n  // If both N1 and N2 are bitcast values on which insert_subvector\n  // would makes sense, pull the bitcast through.\n  // i.e. INSERT_SUBVECTOR (BITCAST N0) (BITCAST N1) N2 ->\n  //        BITCAST (INSERT_SUBVECTOR N0 N1 N2)\n  if (N0.getOpcode() == ISD::BITCAST && N1.getOpcode() == ISD::BITCAST) {\n    SDValue CN0 = N0.getOperand(0);\n    SDValue CN1 = N1.getOperand(0);\n    EVT CN0VT = CN0.getValueType();\n    EVT CN1VT = CN1.getValueType();\n    if (CN0VT.isVector() && CN1VT.isVector() &&\n        CN0VT.getVectorElementType() == CN1VT.getVectorElementType() &&\n        CN0VT.getVectorElementCount() == VT.getVectorElementCount()) {\n      SDValue NewINSERT = DAG.getNode(ISD::INSERT_SUBVECTOR, SDLoc(N),\n                                      CN0.getValueType(), CN0, CN1, N2);\n      return DAG.getBitcast(VT, NewINSERT);\n    }\n  }\n\n  // Combine INSERT_SUBVECTORs where we are inserting to the same index.\n  // INSERT_SUBVECTOR( INSERT_SUBVECTOR( Vec, SubOld, Idx ), SubNew, Idx )\n  // --> INSERT_SUBVECTOR( Vec, SubNew, Idx )\n  if (N0.getOpcode() == ISD::INSERT_SUBVECTOR &&\n      N0.getOperand(1).getValueType() == N1.getValueType() &&\n      N0.getOperand(2) == N2)\n    return DAG.getNode(ISD::INSERT_SUBVECTOR, SDLoc(N), VT, N0.getOperand(0),\n                       N1, N2);\n\n  // Eliminate an intermediate insert into an undef vector:\n  // insert_subvector undef, (insert_subvector undef, X, 0), N2 -->\n  // insert_subvector undef, X, N2\n  if (N0.isUndef() && N1.getOpcode() == ISD::INSERT_SUBVECTOR &&\n      N1.getOperand(0).isUndef() && isNullConstant(N1.getOperand(2)))\n    return DAG.getNode(ISD::INSERT_SUBVECTOR, SDLoc(N), VT, N0,\n                       N1.getOperand(1), N2);\n\n  // Push subvector bitcasts to the output, adjusting the index as we go.\n  // insert_subvector(bitcast(v), bitcast(s), c1)\n  // -> bitcast(insert_subvector(v, s, c2))\n  if ((N0.isUndef() || N0.getOpcode() == ISD::BITCAST) &&\n      N1.getOpcode() == ISD::BITCAST) {\n    SDValue N0Src = peekThroughBitcasts(N0);\n    SDValue N1Src = peekThroughBitcasts(N1);\n    EVT N0SrcSVT = N0Src.getValueType().getScalarType();\n    EVT N1SrcSVT = N1Src.getValueType().getScalarType();\n    if ((N0.isUndef() || N0SrcSVT == N1SrcSVT) &&\n        N0Src.getValueType().isVector() && N1Src.getValueType().isVector()) {\n      EVT NewVT;\n      SDLoc DL(N);\n      SDValue NewIdx;\n      LLVMContext &Ctx = *DAG.getContext();\n      ElementCount NumElts = VT.getVectorElementCount();\n      unsigned EltSizeInBits = VT.getScalarSizeInBits();\n      if ((EltSizeInBits % N1SrcSVT.getSizeInBits()) == 0) {\n        unsigned Scale = EltSizeInBits / N1SrcSVT.getSizeInBits();\n        NewVT = EVT::getVectorVT(Ctx, N1SrcSVT, NumElts * Scale);\n        NewIdx = DAG.getVectorIdxConstant(InsIdx * Scale, DL);\n      } else if ((N1SrcSVT.getSizeInBits() % EltSizeInBits) == 0) {\n        unsigned Scale = N1SrcSVT.getSizeInBits() / EltSizeInBits;\n        if (NumElts.isKnownMultipleOf(Scale) && (InsIdx % Scale) == 0) {\n          NewVT = EVT::getVectorVT(Ctx, N1SrcSVT,\n                                   NumElts.divideCoefficientBy(Scale));\n          NewIdx = DAG.getVectorIdxConstant(InsIdx / Scale, DL);\n        }\n      }\n      if (NewIdx && hasOperation(ISD::INSERT_SUBVECTOR, NewVT)) {\n        SDValue Res = DAG.getBitcast(NewVT, N0Src);\n        Res = DAG.getNode(ISD::INSERT_SUBVECTOR, DL, NewVT, Res, N1Src, NewIdx);\n        return DAG.getBitcast(VT, Res);\n      }\n    }\n  }\n\n  // Canonicalize insert_subvector dag nodes.\n  // Example:\n  // (insert_subvector (insert_subvector A, Idx0), Idx1)\n  // -> (insert_subvector (insert_subvector A, Idx1), Idx0)\n  if (N0.getOpcode() == ISD::INSERT_SUBVECTOR && N0.hasOneUse() &&\n      N1.getValueType() == N0.getOperand(1).getValueType()) {\n    unsigned OtherIdx = N0.getConstantOperandVal(2);\n    if (InsIdx < OtherIdx) {\n      // Swap nodes.\n      SDValue NewOp = DAG.getNode(ISD::INSERT_SUBVECTOR, SDLoc(N), VT,\n                                  N0.getOperand(0), N1, N2);\n      AddToWorklist(NewOp.getNode());\n      return DAG.getNode(ISD::INSERT_SUBVECTOR, SDLoc(N0.getNode()),\n                         VT, NewOp, N0.getOperand(1), N0.getOperand(2));\n    }\n  }\n\n  // If the input vector is a concatenation, and the insert replaces\n  // one of the pieces, we can optimize into a single concat_vectors.\n  if (N0.getOpcode() == ISD::CONCAT_VECTORS && N0.hasOneUse() &&\n      N0.getOperand(0).getValueType() == N1.getValueType() &&\n      N0.getOperand(0).getValueType().isScalableVector() ==\n          N1.getValueType().isScalableVector()) {\n    unsigned Factor = N1.getValueType().getVectorMinNumElements();\n    SmallVector<SDValue, 8> Ops(N0->op_begin(), N0->op_end());\n    Ops[InsIdx / Factor] = N1;\n    return DAG.getNode(ISD::CONCAT_VECTORS, SDLoc(N), VT, Ops);\n  }\n\n  // Simplify source operands based on insertion.\n  if (SimplifyDemandedVectorElts(SDValue(N, 0)))\n    return SDValue(N, 0);\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitFP_TO_FP16(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n\n  // fold (fp_to_fp16 (fp16_to_fp op)) -> op\n  if (N0->getOpcode() == ISD::FP16_TO_FP)\n    return N0->getOperand(0);\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitFP16_TO_FP(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n\n  // fold fp16_to_fp(op & 0xffff) -> fp16_to_fp(op)\n  if (!TLI.shouldKeepZExtForFP16Conv() && N0->getOpcode() == ISD::AND) {\n    ConstantSDNode *AndConst = getAsNonOpaqueConstant(N0.getOperand(1));\n    if (AndConst && AndConst->getAPIntValue() == 0xffff) {\n      return DAG.getNode(ISD::FP16_TO_FP, SDLoc(N), N->getValueType(0),\n                         N0.getOperand(0));\n    }\n  }\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::visitVECREDUCE(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  EVT VT = N0.getValueType();\n  unsigned Opcode = N->getOpcode();\n\n  // VECREDUCE over 1-element vector is just an extract.\n  if (VT.getVectorElementCount().isScalar()) {\n    SDLoc dl(N);\n    SDValue Res =\n        DAG.getNode(ISD::EXTRACT_VECTOR_ELT, dl, VT.getVectorElementType(), N0,\n                    DAG.getVectorIdxConstant(0, dl));\n    if (Res.getValueType() != N->getValueType(0))\n      Res = DAG.getNode(ISD::ANY_EXTEND, dl, N->getValueType(0), Res);\n    return Res;\n  }\n\n  // On an boolean vector an and/or reduction is the same as a umin/umax\n  // reduction. Convert them if the latter is legal while the former isn't.\n  if (Opcode == ISD::VECREDUCE_AND || Opcode == ISD::VECREDUCE_OR) {\n    unsigned NewOpcode = Opcode == ISD::VECREDUCE_AND\n        ? ISD::VECREDUCE_UMIN : ISD::VECREDUCE_UMAX;\n    if (!TLI.isOperationLegalOrCustom(Opcode, VT) &&\n        TLI.isOperationLegalOrCustom(NewOpcode, VT) &&\n        DAG.ComputeNumSignBits(N0) == VT.getScalarSizeInBits())\n      return DAG.getNode(NewOpcode, SDLoc(N), N->getValueType(0), N0);\n  }\n\n  return SDValue();\n}\n\n/// Returns a vector_shuffle if it able to transform an AND to a vector_shuffle\n/// with the destination vector and a zero vector.\n/// e.g. AND V, <0xffffffff, 0, 0xffffffff, 0>. ==>\n///      vector_shuffle V, Zero, <0, 4, 2, 4>\nSDValue DAGCombiner::XformToShuffleWithZero(SDNode *N) {\n  assert(N->getOpcode() == ISD::AND && \"Unexpected opcode!\");\n\n  EVT VT = N->getValueType(0);\n  SDValue LHS = N->getOperand(0);\n  SDValue RHS = peekThroughBitcasts(N->getOperand(1));\n  SDLoc DL(N);\n\n  // Make sure we're not running after operation legalization where it\n  // may have custom lowered the vector shuffles.\n  if (LegalOperations)\n    return SDValue();\n\n  if (RHS.getOpcode() != ISD::BUILD_VECTOR)\n    return SDValue();\n\n  EVT RVT = RHS.getValueType();\n  unsigned NumElts = RHS.getNumOperands();\n\n  // Attempt to create a valid clear mask, splitting the mask into\n  // sub elements and checking to see if each is\n  // all zeros or all ones - suitable for shuffle masking.\n  auto BuildClearMask = [&](int Split) {\n    int NumSubElts = NumElts * Split;\n    int NumSubBits = RVT.getScalarSizeInBits() / Split;\n\n    SmallVector<int, 8> Indices;\n    for (int i = 0; i != NumSubElts; ++i) {\n      int EltIdx = i / Split;\n      int SubIdx = i % Split;\n      SDValue Elt = RHS.getOperand(EltIdx);\n      // X & undef --> 0 (not undef). So this lane must be converted to choose\n      // from the zero constant vector (same as if the element had all 0-bits).\n      if (Elt.isUndef()) {\n        Indices.push_back(i + NumSubElts);\n        continue;\n      }\n\n      APInt Bits;\n      if (isa<ConstantSDNode>(Elt))\n        Bits = cast<ConstantSDNode>(Elt)->getAPIntValue();\n      else if (isa<ConstantFPSDNode>(Elt))\n        Bits = cast<ConstantFPSDNode>(Elt)->getValueAPF().bitcastToAPInt();\n      else\n        return SDValue();\n\n      // Extract the sub element from the constant bit mask.\n      if (DAG.getDataLayout().isBigEndian())\n        Bits = Bits.extractBits(NumSubBits, (Split - SubIdx - 1) * NumSubBits);\n      else\n        Bits = Bits.extractBits(NumSubBits, SubIdx * NumSubBits);\n\n      if (Bits.isAllOnesValue())\n        Indices.push_back(i);\n      else if (Bits == 0)\n        Indices.push_back(i + NumSubElts);\n      else\n        return SDValue();\n    }\n\n    // Let's see if the target supports this vector_shuffle.\n    EVT ClearSVT = EVT::getIntegerVT(*DAG.getContext(), NumSubBits);\n    EVT ClearVT = EVT::getVectorVT(*DAG.getContext(), ClearSVT, NumSubElts);\n    if (!TLI.isVectorClearMaskLegal(Indices, ClearVT))\n      return SDValue();\n\n    SDValue Zero = DAG.getConstant(0, DL, ClearVT);\n    return DAG.getBitcast(VT, DAG.getVectorShuffle(ClearVT, DL,\n                                                   DAG.getBitcast(ClearVT, LHS),\n                                                   Zero, Indices));\n  };\n\n  // Determine maximum split level (byte level masking).\n  int MaxSplit = 1;\n  if (RVT.getScalarSizeInBits() % 8 == 0)\n    MaxSplit = RVT.getScalarSizeInBits() / 8;\n\n  for (int Split = 1; Split <= MaxSplit; ++Split)\n    if (RVT.getScalarSizeInBits() % Split == 0)\n      if (SDValue S = BuildClearMask(Split))\n        return S;\n\n  return SDValue();\n}\n\n/// If a vector binop is performed on splat values, it may be profitable to\n/// extract, scalarize, and insert/splat.\nstatic SDValue scalarizeBinOpOfSplats(SDNode *N, SelectionDAG &DAG) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  unsigned Opcode = N->getOpcode();\n  EVT VT = N->getValueType(0);\n  EVT EltVT = VT.getVectorElementType();\n  const TargetLowering &TLI = DAG.getTargetLoweringInfo();\n\n  // TODO: Remove/replace the extract cost check? If the elements are available\n  //       as scalars, then there may be no extract cost. Should we ask if\n  //       inserting a scalar back into a vector is cheap instead?\n  int Index0, Index1;\n  SDValue Src0 = DAG.getSplatSourceVector(N0, Index0);\n  SDValue Src1 = DAG.getSplatSourceVector(N1, Index1);\n  if (!Src0 || !Src1 || Index0 != Index1 ||\n      Src0.getValueType().getVectorElementType() != EltVT ||\n      Src1.getValueType().getVectorElementType() != EltVT ||\n      !TLI.isExtractVecEltCheap(VT, Index0) ||\n      !TLI.isOperationLegalOrCustom(Opcode, EltVT))\n    return SDValue();\n\n  SDLoc DL(N);\n  SDValue IndexC = DAG.getVectorIdxConstant(Index0, DL);\n  SDValue X = DAG.getNode(ISD::EXTRACT_VECTOR_ELT, DL, EltVT, Src0, IndexC);\n  SDValue Y = DAG.getNode(ISD::EXTRACT_VECTOR_ELT, DL, EltVT, Src1, IndexC);\n  SDValue ScalarBO = DAG.getNode(Opcode, DL, EltVT, X, Y, N->getFlags());\n\n  // If all lanes but 1 are undefined, no need to splat the scalar result.\n  // TODO: Keep track of undefs and use that info in the general case.\n  if (N0.getOpcode() == ISD::BUILD_VECTOR && N0.getOpcode() == N1.getOpcode() &&\n      count_if(N0->ops(), [](SDValue V) { return !V.isUndef(); }) == 1 &&\n      count_if(N1->ops(), [](SDValue V) { return !V.isUndef(); }) == 1) {\n    // bo (build_vec ..undef, X, undef...), (build_vec ..undef, Y, undef...) -->\n    // build_vec ..undef, (bo X, Y), undef...\n    SmallVector<SDValue, 8> Ops(VT.getVectorNumElements(), DAG.getUNDEF(EltVT));\n    Ops[Index0] = ScalarBO;\n    return DAG.getBuildVector(VT, DL, Ops);\n  }\n\n  // bo (splat X, Index), (splat Y, Index) --> splat (bo X, Y), Index\n  SmallVector<SDValue, 8> Ops(VT.getVectorNumElements(), ScalarBO);\n  return DAG.getBuildVector(VT, DL, Ops);\n}\n\n/// Visit a binary vector operation, like ADD.\nSDValue DAGCombiner::SimplifyVBinOp(SDNode *N) {\n  assert(N->getValueType(0).isVector() &&\n         \"SimplifyVBinOp only works on vectors!\");\n\n  SDValue LHS = N->getOperand(0);\n  SDValue RHS = N->getOperand(1);\n  SDValue Ops[] = {LHS, RHS};\n  EVT VT = N->getValueType(0);\n  unsigned Opcode = N->getOpcode();\n  SDNodeFlags Flags = N->getFlags();\n\n  // See if we can constant fold the vector operation.\n  if (SDValue Fold = DAG.FoldConstantVectorArithmetic(\n          Opcode, SDLoc(LHS), LHS.getValueType(), Ops, N->getFlags()))\n    return Fold;\n\n  // Move unary shuffles with identical masks after a vector binop:\n  // VBinOp (shuffle A, Undef, Mask), (shuffle B, Undef, Mask))\n  //   --> shuffle (VBinOp A, B), Undef, Mask\n  // This does not require type legality checks because we are creating the\n  // same types of operations that are in the original sequence. We do have to\n  // restrict ops like integer div that have immediate UB (eg, div-by-zero)\n  // though. This code is adapted from the identical transform in instcombine.\n  if (Opcode != ISD::UDIV && Opcode != ISD::SDIV &&\n      Opcode != ISD::UREM && Opcode != ISD::SREM &&\n      Opcode != ISD::UDIVREM && Opcode != ISD::SDIVREM) {\n    auto *Shuf0 = dyn_cast<ShuffleVectorSDNode>(LHS);\n    auto *Shuf1 = dyn_cast<ShuffleVectorSDNode>(RHS);\n    if (Shuf0 && Shuf1 && Shuf0->getMask().equals(Shuf1->getMask()) &&\n        LHS.getOperand(1).isUndef() && RHS.getOperand(1).isUndef() &&\n        (LHS.hasOneUse() || RHS.hasOneUse() || LHS == RHS)) {\n      SDLoc DL(N);\n      SDValue NewBinOp = DAG.getNode(Opcode, DL, VT, LHS.getOperand(0),\n                                     RHS.getOperand(0), Flags);\n      SDValue UndefV = LHS.getOperand(1);\n      return DAG.getVectorShuffle(VT, DL, NewBinOp, UndefV, Shuf0->getMask());\n    }\n\n    // Try to sink a splat shuffle after a binop with a uniform constant.\n    // This is limited to cases where neither the shuffle nor the constant have\n    // undefined elements because that could be poison-unsafe or inhibit\n    // demanded elements analysis. It is further limited to not change a splat\n    // of an inserted scalar because that may be optimized better by\n    // load-folding or other target-specific behaviors.\n    if (isConstOrConstSplat(RHS) && Shuf0 && is_splat(Shuf0->getMask()) &&\n        Shuf0->hasOneUse() && Shuf0->getOperand(1).isUndef() &&\n        Shuf0->getOperand(0).getOpcode() != ISD::INSERT_VECTOR_ELT) {\n      // binop (splat X), (splat C) --> splat (binop X, C)\n      SDLoc DL(N);\n      SDValue X = Shuf0->getOperand(0);\n      SDValue NewBinOp = DAG.getNode(Opcode, DL, VT, X, RHS, Flags);\n      return DAG.getVectorShuffle(VT, DL, NewBinOp, DAG.getUNDEF(VT),\n                                  Shuf0->getMask());\n    }\n    if (isConstOrConstSplat(LHS) && Shuf1 && is_splat(Shuf1->getMask()) &&\n        Shuf1->hasOneUse() && Shuf1->getOperand(1).isUndef() &&\n        Shuf1->getOperand(0).getOpcode() != ISD::INSERT_VECTOR_ELT) {\n      // binop (splat C), (splat X) --> splat (binop C, X)\n      SDLoc DL(N);\n      SDValue X = Shuf1->getOperand(0);\n      SDValue NewBinOp = DAG.getNode(Opcode, DL, VT, LHS, X, Flags);\n      return DAG.getVectorShuffle(VT, DL, NewBinOp, DAG.getUNDEF(VT),\n                                  Shuf1->getMask());\n    }\n  }\n\n  // The following pattern is likely to emerge with vector reduction ops. Moving\n  // the binary operation ahead of insertion may allow using a narrower vector\n  // instruction that has better performance than the wide version of the op:\n  // VBinOp (ins undef, X, Z), (ins undef, Y, Z) --> ins VecC, (VBinOp X, Y), Z\n  if (LHS.getOpcode() == ISD::INSERT_SUBVECTOR && LHS.getOperand(0).isUndef() &&\n      RHS.getOpcode() == ISD::INSERT_SUBVECTOR && RHS.getOperand(0).isUndef() &&\n      LHS.getOperand(2) == RHS.getOperand(2) &&\n      (LHS.hasOneUse() || RHS.hasOneUse())) {\n    SDValue X = LHS.getOperand(1);\n    SDValue Y = RHS.getOperand(1);\n    SDValue Z = LHS.getOperand(2);\n    EVT NarrowVT = X.getValueType();\n    if (NarrowVT == Y.getValueType() &&\n        TLI.isOperationLegalOrCustomOrPromote(Opcode, NarrowVT,\n                                              LegalOperations)) {\n      // (binop undef, undef) may not return undef, so compute that result.\n      SDLoc DL(N);\n      SDValue VecC =\n          DAG.getNode(Opcode, DL, VT, DAG.getUNDEF(VT), DAG.getUNDEF(VT));\n      SDValue NarrowBO = DAG.getNode(Opcode, DL, NarrowVT, X, Y);\n      return DAG.getNode(ISD::INSERT_SUBVECTOR, DL, VT, VecC, NarrowBO, Z);\n    }\n  }\n\n  // Make sure all but the first op are undef or constant.\n  auto ConcatWithConstantOrUndef = [](SDValue Concat) {\n    return Concat.getOpcode() == ISD::CONCAT_VECTORS &&\n           all_of(drop_begin(Concat->ops()), [](const SDValue &Op) {\n             return Op.isUndef() ||\n                    ISD::isBuildVectorOfConstantSDNodes(Op.getNode());\n           });\n  };\n\n  // The following pattern is likely to emerge with vector reduction ops. Moving\n  // the binary operation ahead of the concat may allow using a narrower vector\n  // instruction that has better performance than the wide version of the op:\n  // VBinOp (concat X, undef/constant), (concat Y, undef/constant) -->\n  //   concat (VBinOp X, Y), VecC\n  if (ConcatWithConstantOrUndef(LHS) && ConcatWithConstantOrUndef(RHS) &&\n      (LHS.hasOneUse() || RHS.hasOneUse())) {\n    EVT NarrowVT = LHS.getOperand(0).getValueType();\n    if (NarrowVT == RHS.getOperand(0).getValueType() &&\n        TLI.isOperationLegalOrCustomOrPromote(Opcode, NarrowVT)) {\n      SDLoc DL(N);\n      unsigned NumOperands = LHS.getNumOperands();\n      SmallVector<SDValue, 4> ConcatOps;\n      for (unsigned i = 0; i != NumOperands; ++i) {\n        // This constant fold for operands 1 and up.\n        ConcatOps.push_back(DAG.getNode(Opcode, DL, NarrowVT, LHS.getOperand(i),\n                                        RHS.getOperand(i)));\n      }\n\n      return DAG.getNode(ISD::CONCAT_VECTORS, DL, VT, ConcatOps);\n    }\n  }\n\n  if (SDValue V = scalarizeBinOpOfSplats(N, DAG))\n    return V;\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::SimplifySelect(const SDLoc &DL, SDValue N0, SDValue N1,\n                                    SDValue N2) {\n  assert(N0.getOpcode() ==ISD::SETCC && \"First argument must be a SetCC node!\");\n\n  SDValue SCC = SimplifySelectCC(DL, N0.getOperand(0), N0.getOperand(1), N1, N2,\n                                 cast<CondCodeSDNode>(N0.getOperand(2))->get());\n\n  // If we got a simplified select_cc node back from SimplifySelectCC, then\n  // break it down into a new SETCC node, and a new SELECT node, and then return\n  // the SELECT node, since we were called with a SELECT node.\n  if (SCC.getNode()) {\n    // Check to see if we got a select_cc back (to turn into setcc/select).\n    // Otherwise, just return whatever node we got back, like fabs.\n    if (SCC.getOpcode() == ISD::SELECT_CC) {\n      const SDNodeFlags Flags = N0.getNode()->getFlags();\n      SDValue SETCC = DAG.getNode(ISD::SETCC, SDLoc(N0),\n                                  N0.getValueType(),\n                                  SCC.getOperand(0), SCC.getOperand(1),\n                                  SCC.getOperand(4), Flags);\n      AddToWorklist(SETCC.getNode());\n      SDValue SelectNode = DAG.getSelect(SDLoc(SCC), SCC.getValueType(), SETCC,\n                                         SCC.getOperand(2), SCC.getOperand(3));\n      SelectNode->setFlags(Flags);\n      return SelectNode;\n    }\n\n    return SCC;\n  }\n  return SDValue();\n}\n\n/// Given a SELECT or a SELECT_CC node, where LHS and RHS are the two values\n/// being selected between, see if we can simplify the select.  Callers of this\n/// should assume that TheSelect is deleted if this returns true.  As such, they\n/// should return the appropriate thing (e.g. the node) back to the top-level of\n/// the DAG combiner loop to avoid it being looked at.\nbool DAGCombiner::SimplifySelectOps(SDNode *TheSelect, SDValue LHS,\n                                    SDValue RHS) {\n  // fold (select (setcc x, [+-]0.0, *lt), NaN, (fsqrt x))\n  // The select + setcc is redundant, because fsqrt returns NaN for X < 0.\n  if (const ConstantFPSDNode *NaN = isConstOrConstSplatFP(LHS)) {\n    if (NaN->isNaN() && RHS.getOpcode() == ISD::FSQRT) {\n      // We have: (select (setcc ?, ?, ?), NaN, (fsqrt ?))\n      SDValue Sqrt = RHS;\n      ISD::CondCode CC;\n      SDValue CmpLHS;\n      const ConstantFPSDNode *Zero = nullptr;\n\n      if (TheSelect->getOpcode() == ISD::SELECT_CC) {\n        CC = cast<CondCodeSDNode>(TheSelect->getOperand(4))->get();\n        CmpLHS = TheSelect->getOperand(0);\n        Zero = isConstOrConstSplatFP(TheSelect->getOperand(1));\n      } else {\n        // SELECT or VSELECT\n        SDValue Cmp = TheSelect->getOperand(0);\n        if (Cmp.getOpcode() == ISD::SETCC) {\n          CC = cast<CondCodeSDNode>(Cmp.getOperand(2))->get();\n          CmpLHS = Cmp.getOperand(0);\n          Zero = isConstOrConstSplatFP(Cmp.getOperand(1));\n        }\n      }\n      if (Zero && Zero->isZero() &&\n          Sqrt.getOperand(0) == CmpLHS && (CC == ISD::SETOLT ||\n          CC == ISD::SETULT || CC == ISD::SETLT)) {\n        // We have: (select (setcc x, [+-]0.0, *lt), NaN, (fsqrt x))\n        CombineTo(TheSelect, Sqrt);\n        return true;\n      }\n    }\n  }\n  // Cannot simplify select with vector condition\n  if (TheSelect->getOperand(0).getValueType().isVector()) return false;\n\n  // If this is a select from two identical things, try to pull the operation\n  // through the select.\n  if (LHS.getOpcode() != RHS.getOpcode() ||\n      !LHS.hasOneUse() || !RHS.hasOneUse())\n    return false;\n\n  // If this is a load and the token chain is identical, replace the select\n  // of two loads with a load through a select of the address to load from.\n  // This triggers in things like \"select bool X, 10.0, 123.0\" after the FP\n  // constants have been dropped into the constant pool.\n  if (LHS.getOpcode() == ISD::LOAD) {\n    LoadSDNode *LLD = cast<LoadSDNode>(LHS);\n    LoadSDNode *RLD = cast<LoadSDNode>(RHS);\n\n    // Token chains must be identical.\n    if (LHS.getOperand(0) != RHS.getOperand(0) ||\n        // Do not let this transformation reduce the number of volatile loads.\n        // Be conservative for atomics for the moment\n        // TODO: This does appear to be legal for unordered atomics (see D66309)\n        !LLD->isSimple() || !RLD->isSimple() ||\n        // FIXME: If either is a pre/post inc/dec load,\n        // we'd need to split out the address adjustment.\n        LLD->isIndexed() || RLD->isIndexed() ||\n        // If this is an EXTLOAD, the VT's must match.\n        LLD->getMemoryVT() != RLD->getMemoryVT() ||\n        // If this is an EXTLOAD, the kind of extension must match.\n        (LLD->getExtensionType() != RLD->getExtensionType() &&\n         // The only exception is if one of the extensions is anyext.\n         LLD->getExtensionType() != ISD::EXTLOAD &&\n         RLD->getExtensionType() != ISD::EXTLOAD) ||\n        // FIXME: this discards src value information.  This is\n        // over-conservative. It would be beneficial to be able to remember\n        // both potential memory locations.  Since we are discarding\n        // src value info, don't do the transformation if the memory\n        // locations are not in the default address space.\n        LLD->getPointerInfo().getAddrSpace() != 0 ||\n        RLD->getPointerInfo().getAddrSpace() != 0 ||\n        // We can't produce a CMOV of a TargetFrameIndex since we won't\n        // generate the address generation required.\n        LLD->getBasePtr().getOpcode() == ISD::TargetFrameIndex ||\n        RLD->getBasePtr().getOpcode() == ISD::TargetFrameIndex ||\n        !TLI.isOperationLegalOrCustom(TheSelect->getOpcode(),\n                                      LLD->getBasePtr().getValueType()))\n      return false;\n\n    // The loads must not depend on one another.\n    if (LLD->isPredecessorOf(RLD) || RLD->isPredecessorOf(LLD))\n      return false;\n\n    // Check that the select condition doesn't reach either load.  If so,\n    // folding this will induce a cycle into the DAG.  If not, this is safe to\n    // xform, so create a select of the addresses.\n\n    SmallPtrSet<const SDNode *, 32> Visited;\n    SmallVector<const SDNode *, 16> Worklist;\n\n    // Always fail if LLD and RLD are not independent. TheSelect is a\n    // predecessor to all Nodes in question so we need not search past it.\n\n    Visited.insert(TheSelect);\n    Worklist.push_back(LLD);\n    Worklist.push_back(RLD);\n\n    if (SDNode::hasPredecessorHelper(LLD, Visited, Worklist) ||\n        SDNode::hasPredecessorHelper(RLD, Visited, Worklist))\n      return false;\n\n    SDValue Addr;\n    if (TheSelect->getOpcode() == ISD::SELECT) {\n      // We cannot do this optimization if any pair of {RLD, LLD} is a\n      // predecessor to {RLD, LLD, CondNode}. As we've already compared the\n      // Loads, we only need to check if CondNode is a successor to one of the\n      // loads. We can further avoid this if there's no use of their chain\n      // value.\n      SDNode *CondNode = TheSelect->getOperand(0).getNode();\n      Worklist.push_back(CondNode);\n\n      if ((LLD->hasAnyUseOfValue(1) &&\n           SDNode::hasPredecessorHelper(LLD, Visited, Worklist)) ||\n          (RLD->hasAnyUseOfValue(1) &&\n           SDNode::hasPredecessorHelper(RLD, Visited, Worklist)))\n        return false;\n\n      Addr = DAG.getSelect(SDLoc(TheSelect),\n                           LLD->getBasePtr().getValueType(),\n                           TheSelect->getOperand(0), LLD->getBasePtr(),\n                           RLD->getBasePtr());\n    } else {  // Otherwise SELECT_CC\n      // We cannot do this optimization if any pair of {RLD, LLD} is a\n      // predecessor to {RLD, LLD, CondLHS, CondRHS}. As we've already compared\n      // the Loads, we only need to check if CondLHS/CondRHS is a successor to\n      // one of the loads. We can further avoid this if there's no use of their\n      // chain value.\n\n      SDNode *CondLHS = TheSelect->getOperand(0).getNode();\n      SDNode *CondRHS = TheSelect->getOperand(1).getNode();\n      Worklist.push_back(CondLHS);\n      Worklist.push_back(CondRHS);\n\n      if ((LLD->hasAnyUseOfValue(1) &&\n           SDNode::hasPredecessorHelper(LLD, Visited, Worklist)) ||\n          (RLD->hasAnyUseOfValue(1) &&\n           SDNode::hasPredecessorHelper(RLD, Visited, Worklist)))\n        return false;\n\n      Addr = DAG.getNode(ISD::SELECT_CC, SDLoc(TheSelect),\n                         LLD->getBasePtr().getValueType(),\n                         TheSelect->getOperand(0),\n                         TheSelect->getOperand(1),\n                         LLD->getBasePtr(), RLD->getBasePtr(),\n                         TheSelect->getOperand(4));\n    }\n\n    SDValue Load;\n    // It is safe to replace the two loads if they have different alignments,\n    // but the new load must be the minimum (most restrictive) alignment of the\n    // inputs.\n    Align Alignment = std::min(LLD->getAlign(), RLD->getAlign());\n    MachineMemOperand::Flags MMOFlags = LLD->getMemOperand()->getFlags();\n    if (!RLD->isInvariant())\n      MMOFlags &= ~MachineMemOperand::MOInvariant;\n    if (!RLD->isDereferenceable())\n      MMOFlags &= ~MachineMemOperand::MODereferenceable;\n    if (LLD->getExtensionType() == ISD::NON_EXTLOAD) {\n      // FIXME: Discards pointer and AA info.\n      Load = DAG.getLoad(TheSelect->getValueType(0), SDLoc(TheSelect),\n                         LLD->getChain(), Addr, MachinePointerInfo(), Alignment,\n                         MMOFlags);\n    } else {\n      // FIXME: Discards pointer and AA info.\n      Load = DAG.getExtLoad(\n          LLD->getExtensionType() == ISD::EXTLOAD ? RLD->getExtensionType()\n                                                  : LLD->getExtensionType(),\n          SDLoc(TheSelect), TheSelect->getValueType(0), LLD->getChain(), Addr,\n          MachinePointerInfo(), LLD->getMemoryVT(), Alignment, MMOFlags);\n    }\n\n    // Users of the select now use the result of the load.\n    CombineTo(TheSelect, Load);\n\n    // Users of the old loads now use the new load's chain.  We know the\n    // old-load value is dead now.\n    CombineTo(LHS.getNode(), Load.getValue(0), Load.getValue(1));\n    CombineTo(RHS.getNode(), Load.getValue(0), Load.getValue(1));\n    return true;\n  }\n\n  return false;\n}\n\n/// Try to fold an expression of the form (N0 cond N1) ? N2 : N3 to a shift and\n/// bitwise 'and'.\nSDValue DAGCombiner::foldSelectCCToShiftAnd(const SDLoc &DL, SDValue N0,\n                                            SDValue N1, SDValue N2, SDValue N3,\n                                            ISD::CondCode CC) {\n  // If this is a select where the false operand is zero and the compare is a\n  // check of the sign bit, see if we can perform the \"gzip trick\":\n  // select_cc setlt X, 0, A, 0 -> and (sra X, size(X)-1), A\n  // select_cc setgt X, 0, A, 0 -> and (not (sra X, size(X)-1)), A\n  EVT XType = N0.getValueType();\n  EVT AType = N2.getValueType();\n  if (!isNullConstant(N3) || !XType.bitsGE(AType))\n    return SDValue();\n\n  // If the comparison is testing for a positive value, we have to invert\n  // the sign bit mask, so only do that transform if the target has a bitwise\n  // 'and not' instruction (the invert is free).\n  if (CC == ISD::SETGT && TLI.hasAndNot(N2)) {\n    // (X > -1) ? A : 0\n    // (X >  0) ? X : 0 <-- This is canonical signed max.\n    if (!(isAllOnesConstant(N1) || (isNullConstant(N1) && N0 == N2)))\n      return SDValue();\n  } else if (CC == ISD::SETLT) {\n    // (X <  0) ? A : 0\n    // (X <  1) ? X : 0 <-- This is un-canonicalized signed min.\n    if (!(isNullConstant(N1) || (isOneConstant(N1) && N0 == N2)))\n      return SDValue();\n  } else {\n    return SDValue();\n  }\n\n  // and (sra X, size(X)-1), A -> \"and (srl X, C2), A\" iff A is a single-bit\n  // constant.\n  EVT ShiftAmtTy = getShiftAmountTy(N0.getValueType());\n  auto *N2C = dyn_cast<ConstantSDNode>(N2.getNode());\n  if (N2C && ((N2C->getAPIntValue() & (N2C->getAPIntValue() - 1)) == 0)) {\n    unsigned ShCt = XType.getSizeInBits() - N2C->getAPIntValue().logBase2() - 1;\n    if (!TLI.shouldAvoidTransformToShift(XType, ShCt)) {\n      SDValue ShiftAmt = DAG.getConstant(ShCt, DL, ShiftAmtTy);\n      SDValue Shift = DAG.getNode(ISD::SRL, DL, XType, N0, ShiftAmt);\n      AddToWorklist(Shift.getNode());\n\n      if (XType.bitsGT(AType)) {\n        Shift = DAG.getNode(ISD::TRUNCATE, DL, AType, Shift);\n        AddToWorklist(Shift.getNode());\n      }\n\n      if (CC == ISD::SETGT)\n        Shift = DAG.getNOT(DL, Shift, AType);\n\n      return DAG.getNode(ISD::AND, DL, AType, Shift, N2);\n    }\n  }\n\n  unsigned ShCt = XType.getSizeInBits() - 1;\n  if (TLI.shouldAvoidTransformToShift(XType, ShCt))\n    return SDValue();\n\n  SDValue ShiftAmt = DAG.getConstant(ShCt, DL, ShiftAmtTy);\n  SDValue Shift = DAG.getNode(ISD::SRA, DL, XType, N0, ShiftAmt);\n  AddToWorklist(Shift.getNode());\n\n  if (XType.bitsGT(AType)) {\n    Shift = DAG.getNode(ISD::TRUNCATE, DL, AType, Shift);\n    AddToWorklist(Shift.getNode());\n  }\n\n  if (CC == ISD::SETGT)\n    Shift = DAG.getNOT(DL, Shift, AType);\n\n  return DAG.getNode(ISD::AND, DL, AType, Shift, N2);\n}\n\n// Transform (fneg/fabs (bitconvert x)) to avoid loading constant pool values.\nSDValue DAGCombiner::foldSignChangeInBitcast(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n  EVT VT = N->getValueType(0);\n  bool IsFabs = N->getOpcode() == ISD::FABS;\n  bool IsFree = IsFabs ? TLI.isFAbsFree(VT) : TLI.isFNegFree(VT);\n\n  if (IsFree || N0.getOpcode() != ISD::BITCAST || !N0.hasOneUse())\n    return SDValue();\n\n  SDValue Int = N0.getOperand(0);\n  EVT IntVT = Int.getValueType();\n\n  // The operand to cast should be integer.\n  if (!IntVT.isInteger() || IntVT.isVector())\n    return SDValue();\n\n  // (fneg (bitconvert x)) -> (bitconvert (xor x sign))\n  // (fabs (bitconvert x)) -> (bitconvert (and x ~sign))\n  APInt SignMask;\n  if (N0.getValueType().isVector()) {\n    // For vector, create a sign mask (0x80...) or its inverse (for fabs,\n    // 0x7f...) per element and splat it.\n    SignMask = APInt::getSignMask(N0.getScalarValueSizeInBits());\n    if (IsFabs)\n      SignMask = ~SignMask;\n    SignMask = APInt::getSplat(IntVT.getSizeInBits(), SignMask);\n  } else {\n    // For scalar, just use the sign mask (0x80... or the inverse, 0x7f...)\n    SignMask = APInt::getSignMask(IntVT.getSizeInBits());\n    if (IsFabs)\n      SignMask = ~SignMask;\n  }\n  SDLoc DL(N0);\n  Int = DAG.getNode(IsFabs ? ISD::AND : ISD::XOR, DL, IntVT, Int,\n                    DAG.getConstant(SignMask, DL, IntVT));\n  AddToWorklist(Int.getNode());\n  return DAG.getBitcast(VT, Int);\n}\n\n/// Turn \"(a cond b) ? 1.0f : 2.0f\" into \"load (tmp + ((a cond b) ? 0 : 4)\"\n/// where \"tmp\" is a constant pool entry containing an array with 1.0 and 2.0\n/// in it. This may be a win when the constant is not otherwise available\n/// because it replaces two constant pool loads with one.\nSDValue DAGCombiner::convertSelectOfFPConstantsToLoadOffset(\n    const SDLoc &DL, SDValue N0, SDValue N1, SDValue N2, SDValue N3,\n    ISD::CondCode CC) {\n  if (!TLI.reduceSelectOfFPConstantLoads(N0.getValueType()))\n    return SDValue();\n\n  // If we are before legalize types, we want the other legalization to happen\n  // first (for example, to avoid messing with soft float).\n  auto *TV = dyn_cast<ConstantFPSDNode>(N2);\n  auto *FV = dyn_cast<ConstantFPSDNode>(N3);\n  EVT VT = N2.getValueType();\n  if (!TV || !FV || !TLI.isTypeLegal(VT))\n    return SDValue();\n\n  // If a constant can be materialized without loads, this does not make sense.\n  if (TLI.getOperationAction(ISD::ConstantFP, VT) == TargetLowering::Legal ||\n      TLI.isFPImmLegal(TV->getValueAPF(), TV->getValueType(0), ForCodeSize) ||\n      TLI.isFPImmLegal(FV->getValueAPF(), FV->getValueType(0), ForCodeSize))\n    return SDValue();\n\n  // If both constants have multiple uses, then we won't need to do an extra\n  // load. The values are likely around in registers for other users.\n  if (!TV->hasOneUse() && !FV->hasOneUse())\n    return SDValue();\n\n  Constant *Elts[] = { const_cast<ConstantFP*>(FV->getConstantFPValue()),\n                       const_cast<ConstantFP*>(TV->getConstantFPValue()) };\n  Type *FPTy = Elts[0]->getType();\n  const DataLayout &TD = DAG.getDataLayout();\n\n  // Create a ConstantArray of the two constants.\n  Constant *CA = ConstantArray::get(ArrayType::get(FPTy, 2), Elts);\n  SDValue CPIdx = DAG.getConstantPool(CA, TLI.getPointerTy(DAG.getDataLayout()),\n                                      TD.getPrefTypeAlign(FPTy));\n  Align Alignment = cast<ConstantPoolSDNode>(CPIdx)->getAlign();\n\n  // Get offsets to the 0 and 1 elements of the array, so we can select between\n  // them.\n  SDValue Zero = DAG.getIntPtrConstant(0, DL);\n  unsigned EltSize = (unsigned)TD.getTypeAllocSize(Elts[0]->getType());\n  SDValue One = DAG.getIntPtrConstant(EltSize, SDLoc(FV));\n  SDValue Cond =\n      DAG.getSetCC(DL, getSetCCResultType(N0.getValueType()), N0, N1, CC);\n  AddToWorklist(Cond.getNode());\n  SDValue CstOffset = DAG.getSelect(DL, Zero.getValueType(), Cond, One, Zero);\n  AddToWorklist(CstOffset.getNode());\n  CPIdx = DAG.getNode(ISD::ADD, DL, CPIdx.getValueType(), CPIdx, CstOffset);\n  AddToWorklist(CPIdx.getNode());\n  return DAG.getLoad(TV->getValueType(0), DL, DAG.getEntryNode(), CPIdx,\n                     MachinePointerInfo::getConstantPool(\n                         DAG.getMachineFunction()), Alignment);\n}\n\n/// Simplify an expression of the form (N0 cond N1) ? N2 : N3\n/// where 'cond' is the comparison specified by CC.\nSDValue DAGCombiner::SimplifySelectCC(const SDLoc &DL, SDValue N0, SDValue N1,\n                                      SDValue N2, SDValue N3, ISD::CondCode CC,\n                                      bool NotExtCompare) {\n  // (x ? y : y) -> y.\n  if (N2 == N3) return N2;\n\n  EVT CmpOpVT = N0.getValueType();\n  EVT CmpResVT = getSetCCResultType(CmpOpVT);\n  EVT VT = N2.getValueType();\n  auto *N1C = dyn_cast<ConstantSDNode>(N1.getNode());\n  auto *N2C = dyn_cast<ConstantSDNode>(N2.getNode());\n  auto *N3C = dyn_cast<ConstantSDNode>(N3.getNode());\n\n  // Determine if the condition we're dealing with is constant.\n  if (SDValue SCC = DAG.FoldSetCC(CmpResVT, N0, N1, CC, DL)) {\n    AddToWorklist(SCC.getNode());\n    if (auto *SCCC = dyn_cast<ConstantSDNode>(SCC)) {\n      // fold select_cc true, x, y -> x\n      // fold select_cc false, x, y -> y\n      return !(SCCC->isNullValue()) ? N2 : N3;\n    }\n  }\n\n  if (SDValue V =\n          convertSelectOfFPConstantsToLoadOffset(DL, N0, N1, N2, N3, CC))\n    return V;\n\n  if (SDValue V = foldSelectCCToShiftAnd(DL, N0, N1, N2, N3, CC))\n    return V;\n\n  // fold (select_cc seteq (and x, y), 0, 0, A) -> (and (shr (shl x)) A)\n  // where y is has a single bit set.\n  // A plaintext description would be, we can turn the SELECT_CC into an AND\n  // when the condition can be materialized as an all-ones register.  Any\n  // single bit-test can be materialized as an all-ones register with\n  // shift-left and shift-right-arith.\n  if (CC == ISD::SETEQ && N0->getOpcode() == ISD::AND &&\n      N0->getValueType(0) == VT && isNullConstant(N1) && isNullConstant(N2)) {\n    SDValue AndLHS = N0->getOperand(0);\n    auto *ConstAndRHS = dyn_cast<ConstantSDNode>(N0->getOperand(1));\n    if (ConstAndRHS && ConstAndRHS->getAPIntValue().countPopulation() == 1) {\n      // Shift the tested bit over the sign bit.\n      const APInt &AndMask = ConstAndRHS->getAPIntValue();\n      unsigned ShCt = AndMask.getBitWidth() - 1;\n      if (!TLI.shouldAvoidTransformToShift(VT, ShCt)) {\n        SDValue ShlAmt =\n          DAG.getConstant(AndMask.countLeadingZeros(), SDLoc(AndLHS),\n                          getShiftAmountTy(AndLHS.getValueType()));\n        SDValue Shl = DAG.getNode(ISD::SHL, SDLoc(N0), VT, AndLHS, ShlAmt);\n\n        // Now arithmetic right shift it all the way over, so the result is\n        // either all-ones, or zero.\n        SDValue ShrAmt =\n          DAG.getConstant(ShCt, SDLoc(Shl),\n                          getShiftAmountTy(Shl.getValueType()));\n        SDValue Shr = DAG.getNode(ISD::SRA, SDLoc(N0), VT, Shl, ShrAmt);\n\n        return DAG.getNode(ISD::AND, DL, VT, Shr, N3);\n      }\n    }\n  }\n\n  // fold select C, 16, 0 -> shl C, 4\n  bool Fold = N2C && isNullConstant(N3) && N2C->getAPIntValue().isPowerOf2();\n  bool Swap = N3C && isNullConstant(N2) && N3C->getAPIntValue().isPowerOf2();\n\n  if ((Fold || Swap) &&\n      TLI.getBooleanContents(CmpOpVT) ==\n          TargetLowering::ZeroOrOneBooleanContent &&\n      (!LegalOperations || TLI.isOperationLegal(ISD::SETCC, CmpOpVT))) {\n\n    if (Swap) {\n      CC = ISD::getSetCCInverse(CC, CmpOpVT);\n      std::swap(N2C, N3C);\n    }\n\n    // If the caller doesn't want us to simplify this into a zext of a compare,\n    // don't do it.\n    if (NotExtCompare && N2C->isOne())\n      return SDValue();\n\n    SDValue Temp, SCC;\n    // zext (setcc n0, n1)\n    if (LegalTypes) {\n      SCC = DAG.getSetCC(DL, CmpResVT, N0, N1, CC);\n      if (VT.bitsLT(SCC.getValueType()))\n        Temp = DAG.getZeroExtendInReg(SCC, SDLoc(N2), VT);\n      else\n        Temp = DAG.getNode(ISD::ZERO_EXTEND, SDLoc(N2), VT, SCC);\n    } else {\n      SCC = DAG.getSetCC(SDLoc(N0), MVT::i1, N0, N1, CC);\n      Temp = DAG.getNode(ISD::ZERO_EXTEND, SDLoc(N2), VT, SCC);\n    }\n\n    AddToWorklist(SCC.getNode());\n    AddToWorklist(Temp.getNode());\n\n    if (N2C->isOne())\n      return Temp;\n\n    unsigned ShCt = N2C->getAPIntValue().logBase2();\n    if (TLI.shouldAvoidTransformToShift(VT, ShCt))\n      return SDValue();\n\n    // shl setcc result by log2 n2c\n    return DAG.getNode(ISD::SHL, DL, N2.getValueType(), Temp,\n                       DAG.getConstant(ShCt, SDLoc(Temp),\n                                       getShiftAmountTy(Temp.getValueType())));\n  }\n\n  // select_cc seteq X, 0, sizeof(X), ctlz(X) -> ctlz(X)\n  // select_cc seteq X, 0, sizeof(X), ctlz_zero_undef(X) -> ctlz(X)\n  // select_cc seteq X, 0, sizeof(X), cttz(X) -> cttz(X)\n  // select_cc seteq X, 0, sizeof(X), cttz_zero_undef(X) -> cttz(X)\n  // select_cc setne X, 0, ctlz(X), sizeof(X) -> ctlz(X)\n  // select_cc setne X, 0, ctlz_zero_undef(X), sizeof(X) -> ctlz(X)\n  // select_cc setne X, 0, cttz(X), sizeof(X) -> cttz(X)\n  // select_cc setne X, 0, cttz_zero_undef(X), sizeof(X) -> cttz(X)\n  if (N1C && N1C->isNullValue() && (CC == ISD::SETEQ || CC == ISD::SETNE)) {\n    SDValue ValueOnZero = N2;\n    SDValue Count = N3;\n    // If the condition is NE instead of E, swap the operands.\n    if (CC == ISD::SETNE)\n      std::swap(ValueOnZero, Count);\n    // Check if the value on zero is a constant equal to the bits in the type.\n    if (auto *ValueOnZeroC = dyn_cast<ConstantSDNode>(ValueOnZero)) {\n      if (ValueOnZeroC->getAPIntValue() == VT.getSizeInBits()) {\n        // If the other operand is cttz/cttz_zero_undef of N0, and cttz is\n        // legal, combine to just cttz.\n        if ((Count.getOpcode() == ISD::CTTZ ||\n             Count.getOpcode() == ISD::CTTZ_ZERO_UNDEF) &&\n            N0 == Count.getOperand(0) &&\n            (!LegalOperations || TLI.isOperationLegal(ISD::CTTZ, VT)))\n          return DAG.getNode(ISD::CTTZ, DL, VT, N0);\n        // If the other operand is ctlz/ctlz_zero_undef of N0, and ctlz is\n        // legal, combine to just ctlz.\n        if ((Count.getOpcode() == ISD::CTLZ ||\n             Count.getOpcode() == ISD::CTLZ_ZERO_UNDEF) &&\n            N0 == Count.getOperand(0) &&\n            (!LegalOperations || TLI.isOperationLegal(ISD::CTLZ, VT)))\n          return DAG.getNode(ISD::CTLZ, DL, VT, N0);\n      }\n    }\n  }\n\n  return SDValue();\n}\n\n/// This is a stub for TargetLowering::SimplifySetCC.\nSDValue DAGCombiner::SimplifySetCC(EVT VT, SDValue N0, SDValue N1,\n                                   ISD::CondCode Cond, const SDLoc &DL,\n                                   bool foldBooleans) {\n  TargetLowering::DAGCombinerInfo\n    DagCombineInfo(DAG, Level, false, this);\n  return TLI.SimplifySetCC(VT, N0, N1, Cond, foldBooleans, DagCombineInfo, DL);\n}\n\n/// Given an ISD::SDIV node expressing a divide by constant, return\n/// a DAG expression to select that will generate the same value by multiplying\n/// by a magic number.\n/// Ref: \"Hacker's Delight\" or \"The PowerPC Compiler Writer's Guide\".\nSDValue DAGCombiner::BuildSDIV(SDNode *N) {\n  // when optimising for minimum size, we don't want to expand a div to a mul\n  // and a shift.\n  if (DAG.getMachineFunction().getFunction().hasMinSize())\n    return SDValue();\n\n  SmallVector<SDNode *, 8> Built;\n  if (SDValue S = TLI.BuildSDIV(N, DAG, LegalOperations, Built)) {\n    for (SDNode *N : Built)\n      AddToWorklist(N);\n    return S;\n  }\n\n  return SDValue();\n}\n\n/// Given an ISD::SDIV node expressing a divide by constant power of 2, return a\n/// DAG expression that will generate the same value by right shifting.\nSDValue DAGCombiner::BuildSDIVPow2(SDNode *N) {\n  ConstantSDNode *C = isConstOrConstSplat(N->getOperand(1));\n  if (!C)\n    return SDValue();\n\n  // Avoid division by zero.\n  if (C->isNullValue())\n    return SDValue();\n\n  SmallVector<SDNode *, 8> Built;\n  if (SDValue S = TLI.BuildSDIVPow2(N, C->getAPIntValue(), DAG, Built)) {\n    for (SDNode *N : Built)\n      AddToWorklist(N);\n    return S;\n  }\n\n  return SDValue();\n}\n\n/// Given an ISD::UDIV node expressing a divide by constant, return a DAG\n/// expression that will generate the same value by multiplying by a magic\n/// number.\n/// Ref: \"Hacker's Delight\" or \"The PowerPC Compiler Writer's Guide\".\nSDValue DAGCombiner::BuildUDIV(SDNode *N) {\n  // when optimising for minimum size, we don't want to expand a div to a mul\n  // and a shift.\n  if (DAG.getMachineFunction().getFunction().hasMinSize())\n    return SDValue();\n\n  SmallVector<SDNode *, 8> Built;\n  if (SDValue S = TLI.BuildUDIV(N, DAG, LegalOperations, Built)) {\n    for (SDNode *N : Built)\n      AddToWorklist(N);\n    return S;\n  }\n\n  return SDValue();\n}\n\n/// Determines the LogBase2 value for a non-null input value using the\n/// transform: LogBase2(V) = (EltBits - 1) - ctlz(V).\nSDValue DAGCombiner::BuildLogBase2(SDValue V, const SDLoc &DL) {\n  EVT VT = V.getValueType();\n  SDValue Ctlz = DAG.getNode(ISD::CTLZ, DL, VT, V);\n  SDValue Base = DAG.getConstant(VT.getScalarSizeInBits() - 1, DL, VT);\n  SDValue LogBase2 = DAG.getNode(ISD::SUB, DL, VT, Base, Ctlz);\n  return LogBase2;\n}\n\n/// Newton iteration for a function: F(X) is X_{i+1} = X_i - F(X_i)/F'(X_i)\n/// For the reciprocal, we need to find the zero of the function:\n///   F(X) = A X - 1 [which has a zero at X = 1/A]\n///     =>\n///   X_{i+1} = X_i (2 - A X_i) = X_i + X_i (1 - A X_i) [this second form\n///     does not require additional intermediate precision]\n/// For the last iteration, put numerator N into it to gain more precision:\n///   Result = N X_i + X_i (N - N A X_i)\nSDValue DAGCombiner::BuildDivEstimate(SDValue N, SDValue Op,\n                                      SDNodeFlags Flags) {\n  if (LegalDAG)\n    return SDValue();\n\n  // TODO: Handle half and/or extended types?\n  EVT VT = Op.getValueType();\n  if (VT.getScalarType() != MVT::f32 && VT.getScalarType() != MVT::f64)\n    return SDValue();\n\n  // If estimates are explicitly disabled for this function, we're done.\n  MachineFunction &MF = DAG.getMachineFunction();\n  int Enabled = TLI.getRecipEstimateDivEnabled(VT, MF);\n  if (Enabled == TLI.ReciprocalEstimate::Disabled)\n    return SDValue();\n\n  // Estimates may be explicitly enabled for this type with a custom number of\n  // refinement steps.\n  int Iterations = TLI.getDivRefinementSteps(VT, MF);\n  if (SDValue Est = TLI.getRecipEstimate(Op, DAG, Enabled, Iterations)) {\n    AddToWorklist(Est.getNode());\n\n    SDLoc DL(Op);\n    if (Iterations) {\n      SDValue FPOne = DAG.getConstantFP(1.0, DL, VT);\n\n      // Newton iterations: Est = Est + Est (N - Arg * Est)\n      // If this is the last iteration, also multiply by the numerator.\n      for (int i = 0; i < Iterations; ++i) {\n        SDValue MulEst = Est;\n\n        if (i == Iterations - 1) {\n          MulEst = DAG.getNode(ISD::FMUL, DL, VT, N, Est, Flags);\n          AddToWorklist(MulEst.getNode());\n        }\n\n        SDValue NewEst = DAG.getNode(ISD::FMUL, DL, VT, Op, MulEst, Flags);\n        AddToWorklist(NewEst.getNode());\n\n        NewEst = DAG.getNode(ISD::FSUB, DL, VT,\n                             (i == Iterations - 1 ? N : FPOne), NewEst, Flags);\n        AddToWorklist(NewEst.getNode());\n\n        NewEst = DAG.getNode(ISD::FMUL, DL, VT, Est, NewEst, Flags);\n        AddToWorklist(NewEst.getNode());\n\n        Est = DAG.getNode(ISD::FADD, DL, VT, MulEst, NewEst, Flags);\n        AddToWorklist(Est.getNode());\n      }\n    } else {\n      // If no iterations are available, multiply with N.\n      Est = DAG.getNode(ISD::FMUL, DL, VT, Est, N, Flags);\n      AddToWorklist(Est.getNode());\n    }\n\n    return Est;\n  }\n\n  return SDValue();\n}\n\n/// Newton iteration for a function: F(X) is X_{i+1} = X_i - F(X_i)/F'(X_i)\n/// For the reciprocal sqrt, we need to find the zero of the function:\n///   F(X) = 1/X^2 - A [which has a zero at X = 1/sqrt(A)]\n///     =>\n///   X_{i+1} = X_i (1.5 - A X_i^2 / 2)\n/// As a result, we precompute A/2 prior to the iteration loop.\nSDValue DAGCombiner::buildSqrtNROneConst(SDValue Arg, SDValue Est,\n                                         unsigned Iterations,\n                                         SDNodeFlags Flags, bool Reciprocal) {\n  EVT VT = Arg.getValueType();\n  SDLoc DL(Arg);\n  SDValue ThreeHalves = DAG.getConstantFP(1.5, DL, VT);\n\n  // We now need 0.5 * Arg which we can write as (1.5 * Arg - Arg) so that\n  // this entire sequence requires only one FP constant.\n  SDValue HalfArg = DAG.getNode(ISD::FMUL, DL, VT, ThreeHalves, Arg, Flags);\n  HalfArg = DAG.getNode(ISD::FSUB, DL, VT, HalfArg, Arg, Flags);\n\n  // Newton iterations: Est = Est * (1.5 - HalfArg * Est * Est)\n  for (unsigned i = 0; i < Iterations; ++i) {\n    SDValue NewEst = DAG.getNode(ISD::FMUL, DL, VT, Est, Est, Flags);\n    NewEst = DAG.getNode(ISD::FMUL, DL, VT, HalfArg, NewEst, Flags);\n    NewEst = DAG.getNode(ISD::FSUB, DL, VT, ThreeHalves, NewEst, Flags);\n    Est = DAG.getNode(ISD::FMUL, DL, VT, Est, NewEst, Flags);\n  }\n\n  // If non-reciprocal square root is requested, multiply the result by Arg.\n  if (!Reciprocal)\n    Est = DAG.getNode(ISD::FMUL, DL, VT, Est, Arg, Flags);\n\n  return Est;\n}\n\n/// Newton iteration for a function: F(X) is X_{i+1} = X_i - F(X_i)/F'(X_i)\n/// For the reciprocal sqrt, we need to find the zero of the function:\n///   F(X) = 1/X^2 - A [which has a zero at X = 1/sqrt(A)]\n///     =>\n///   X_{i+1} = (-0.5 * X_i) * (A * X_i * X_i + (-3.0))\nSDValue DAGCombiner::buildSqrtNRTwoConst(SDValue Arg, SDValue Est,\n                                         unsigned Iterations,\n                                         SDNodeFlags Flags, bool Reciprocal) {\n  EVT VT = Arg.getValueType();\n  SDLoc DL(Arg);\n  SDValue MinusThree = DAG.getConstantFP(-3.0, DL, VT);\n  SDValue MinusHalf = DAG.getConstantFP(-0.5, DL, VT);\n\n  // This routine must enter the loop below to work correctly\n  // when (Reciprocal == false).\n  assert(Iterations > 0);\n\n  // Newton iterations for reciprocal square root:\n  // E = (E * -0.5) * ((A * E) * E + -3.0)\n  for (unsigned i = 0; i < Iterations; ++i) {\n    SDValue AE = DAG.getNode(ISD::FMUL, DL, VT, Arg, Est, Flags);\n    SDValue AEE = DAG.getNode(ISD::FMUL, DL, VT, AE, Est, Flags);\n    SDValue RHS = DAG.getNode(ISD::FADD, DL, VT, AEE, MinusThree, Flags);\n\n    // When calculating a square root at the last iteration build:\n    // S = ((A * E) * -0.5) * ((A * E) * E + -3.0)\n    // (notice a common subexpression)\n    SDValue LHS;\n    if (Reciprocal || (i + 1) < Iterations) {\n      // RSQRT: LHS = (E * -0.5)\n      LHS = DAG.getNode(ISD::FMUL, DL, VT, Est, MinusHalf, Flags);\n    } else {\n      // SQRT: LHS = (A * E) * -0.5\n      LHS = DAG.getNode(ISD::FMUL, DL, VT, AE, MinusHalf, Flags);\n    }\n\n    Est = DAG.getNode(ISD::FMUL, DL, VT, LHS, RHS, Flags);\n  }\n\n  return Est;\n}\n\n/// Build code to calculate either rsqrt(Op) or sqrt(Op). In the latter case\n/// Op*rsqrt(Op) is actually computed, so additional postprocessing is needed if\n/// Op can be zero.\nSDValue DAGCombiner::buildSqrtEstimateImpl(SDValue Op, SDNodeFlags Flags,\n                                           bool Reciprocal) {\n  if (LegalDAG)\n    return SDValue();\n\n  // TODO: Handle half and/or extended types?\n  EVT VT = Op.getValueType();\n  if (VT.getScalarType() != MVT::f32 && VT.getScalarType() != MVT::f64)\n    return SDValue();\n\n  // If estimates are explicitly disabled for this function, we're done.\n  MachineFunction &MF = DAG.getMachineFunction();\n  int Enabled = TLI.getRecipEstimateSqrtEnabled(VT, MF);\n  if (Enabled == TLI.ReciprocalEstimate::Disabled)\n    return SDValue();\n\n  // Estimates may be explicitly enabled for this type with a custom number of\n  // refinement steps.\n  int Iterations = TLI.getSqrtRefinementSteps(VT, MF);\n\n  bool UseOneConstNR = false;\n  if (SDValue Est =\n      TLI.getSqrtEstimate(Op, DAG, Enabled, Iterations, UseOneConstNR,\n                          Reciprocal)) {\n    AddToWorklist(Est.getNode());\n\n    if (Iterations)\n      Est = UseOneConstNR\n            ? buildSqrtNROneConst(Op, Est, Iterations, Flags, Reciprocal)\n            : buildSqrtNRTwoConst(Op, Est, Iterations, Flags, Reciprocal);\n    if (!Reciprocal) {\n      SDLoc DL(Op);\n      // Try the target specific test first.\n      SDValue Test = TLI.getSqrtInputTest(Op, DAG, DAG.getDenormalMode(VT));\n\n      // The estimate is now completely wrong if the input was exactly 0.0 or\n      // possibly a denormal. Force the answer to 0.0 or value provided by\n      // target for those cases.\n      Est = DAG.getNode(\n          Test.getValueType().isVector() ? ISD::VSELECT : ISD::SELECT, DL, VT,\n          Test, TLI.getSqrtResultForDenormInput(Op, DAG), Est);\n    }\n    return Est;\n  }\n\n  return SDValue();\n}\n\nSDValue DAGCombiner::buildRsqrtEstimate(SDValue Op, SDNodeFlags Flags) {\n  return buildSqrtEstimateImpl(Op, Flags, true);\n}\n\nSDValue DAGCombiner::buildSqrtEstimate(SDValue Op, SDNodeFlags Flags) {\n  return buildSqrtEstimateImpl(Op, Flags, false);\n}\n\n/// Return true if there is any possibility that the two addresses overlap.\nbool DAGCombiner::isAlias(SDNode *Op0, SDNode *Op1) const {\n\n  struct MemUseCharacteristics {\n    bool IsVolatile;\n    bool IsAtomic;\n    SDValue BasePtr;\n    int64_t Offset;\n    Optional<int64_t> NumBytes;\n    MachineMemOperand *MMO;\n  };\n\n  auto getCharacteristics = [](SDNode *N) -> MemUseCharacteristics {\n    if (const auto *LSN = dyn_cast<LSBaseSDNode>(N)) {\n      int64_t Offset = 0;\n      if (auto *C = dyn_cast<ConstantSDNode>(LSN->getOffset()))\n        Offset = (LSN->getAddressingMode() == ISD::PRE_INC)\n                     ? C->getSExtValue()\n                     : (LSN->getAddressingMode() == ISD::PRE_DEC)\n                           ? -1 * C->getSExtValue()\n                           : 0;\n      uint64_t Size =\n          MemoryLocation::getSizeOrUnknown(LSN->getMemoryVT().getStoreSize());\n      return {LSN->isVolatile(), LSN->isAtomic(), LSN->getBasePtr(),\n              Offset /*base offset*/,\n              Optional<int64_t>(Size),\n              LSN->getMemOperand()};\n    }\n    if (const auto *LN = cast<LifetimeSDNode>(N))\n      return {false /*isVolatile*/, /*isAtomic*/ false, LN->getOperand(1),\n              (LN->hasOffset()) ? LN->getOffset() : 0,\n              (LN->hasOffset()) ? Optional<int64_t>(LN->getSize())\n                                : Optional<int64_t>(),\n              (MachineMemOperand *)nullptr};\n    // Default.\n    return {false /*isvolatile*/, /*isAtomic*/ false, SDValue(),\n            (int64_t)0 /*offset*/,\n            Optional<int64_t>() /*size*/, (MachineMemOperand *)nullptr};\n  };\n\n  MemUseCharacteristics MUC0 = getCharacteristics(Op0),\n                        MUC1 = getCharacteristics(Op1);\n\n  // If they are to the same address, then they must be aliases.\n  if (MUC0.BasePtr.getNode() && MUC0.BasePtr == MUC1.BasePtr &&\n      MUC0.Offset == MUC1.Offset)\n    return true;\n\n  // If they are both volatile then they cannot be reordered.\n  if (MUC0.IsVolatile && MUC1.IsVolatile)\n    return true;\n\n  // Be conservative about atomics for the moment\n  // TODO: This is way overconservative for unordered atomics (see D66309)\n  if (MUC0.IsAtomic && MUC1.IsAtomic)\n    return true;\n\n  if (MUC0.MMO && MUC1.MMO) {\n    if ((MUC0.MMO->isInvariant() && MUC1.MMO->isStore()) ||\n        (MUC1.MMO->isInvariant() && MUC0.MMO->isStore()))\n      return false;\n  }\n\n  // Try to prove that there is aliasing, or that there is no aliasing. Either\n  // way, we can return now. If nothing can be proved, proceed with more tests.\n  bool IsAlias;\n  if (BaseIndexOffset::computeAliasing(Op0, MUC0.NumBytes, Op1, MUC1.NumBytes,\n                                       DAG, IsAlias))\n    return IsAlias;\n\n  // The following all rely on MMO0 and MMO1 being valid. Fail conservatively if\n  // either are not known.\n  if (!MUC0.MMO || !MUC1.MMO)\n    return true;\n\n  // If one operation reads from invariant memory, and the other may store, they\n  // cannot alias. These should really be checking the equivalent of mayWrite,\n  // but it only matters for memory nodes other than load /store.\n  if ((MUC0.MMO->isInvariant() && MUC1.MMO->isStore()) ||\n      (MUC1.MMO->isInvariant() && MUC0.MMO->isStore()))\n    return false;\n\n  // If we know required SrcValue1 and SrcValue2 have relatively large\n  // alignment compared to the size and offset of the access, we may be able\n  // to prove they do not alias. This check is conservative for now to catch\n  // cases created by splitting vector types, it only works when the offsets are\n  // multiples of the size of the data.\n  int64_t SrcValOffset0 = MUC0.MMO->getOffset();\n  int64_t SrcValOffset1 = MUC1.MMO->getOffset();\n  Align OrigAlignment0 = MUC0.MMO->getBaseAlign();\n  Align OrigAlignment1 = MUC1.MMO->getBaseAlign();\n  auto &Size0 = MUC0.NumBytes;\n  auto &Size1 = MUC1.NumBytes;\n  if (OrigAlignment0 == OrigAlignment1 && SrcValOffset0 != SrcValOffset1 &&\n      Size0.hasValue() && Size1.hasValue() && *Size0 == *Size1 &&\n      OrigAlignment0 > *Size0 && SrcValOffset0 % *Size0 == 0 &&\n      SrcValOffset1 % *Size1 == 0) {\n    int64_t OffAlign0 = SrcValOffset0 % OrigAlignment0.value();\n    int64_t OffAlign1 = SrcValOffset1 % OrigAlignment1.value();\n\n    // There is no overlap between these relatively aligned accesses of\n    // similar size. Return no alias.\n    if ((OffAlign0 + *Size0) <= OffAlign1 || (OffAlign1 + *Size1) <= OffAlign0)\n      return false;\n  }\n\n  bool UseAA = CombinerGlobalAA.getNumOccurrences() > 0\n                   ? CombinerGlobalAA\n                   : DAG.getSubtarget().useAA();\n#ifndef NDEBUG\n  if (CombinerAAOnlyFunc.getNumOccurrences() &&\n      CombinerAAOnlyFunc != DAG.getMachineFunction().getName())\n    UseAA = false;\n#endif\n\n  if (UseAA && AA && MUC0.MMO->getValue() && MUC1.MMO->getValue() &&\n      Size0.hasValue() && Size1.hasValue()) {\n    // Use alias analysis information.\n    int64_t MinOffset = std::min(SrcValOffset0, SrcValOffset1);\n    int64_t Overlap0 = *Size0 + SrcValOffset0 - MinOffset;\n    int64_t Overlap1 = *Size1 + SrcValOffset1 - MinOffset;\n    AliasResult AAResult = AA->alias(\n        MemoryLocation(MUC0.MMO->getValue(), Overlap0,\n                       UseTBAA ? MUC0.MMO->getAAInfo() : AAMDNodes()),\n        MemoryLocation(MUC1.MMO->getValue(), Overlap1,\n                       UseTBAA ? MUC1.MMO->getAAInfo() : AAMDNodes()));\n    if (AAResult == NoAlias)\n      return false;\n  }\n\n  // Otherwise we have to assume they alias.\n  return true;\n}\n\n/// Walk up chain skipping non-aliasing memory nodes,\n/// looking for aliasing nodes and adding them to the Aliases vector.\nvoid DAGCombiner::GatherAllAliases(SDNode *N, SDValue OriginalChain,\n                                   SmallVectorImpl<SDValue> &Aliases) {\n  SmallVector<SDValue, 8> Chains;     // List of chains to visit.\n  SmallPtrSet<SDNode *, 16> Visited;  // Visited node set.\n\n  // Get alias information for node.\n  // TODO: relax aliasing for unordered atomics (see D66309)\n  const bool IsLoad = isa<LoadSDNode>(N) && cast<LoadSDNode>(N)->isSimple();\n\n  // Starting off.\n  Chains.push_back(OriginalChain);\n  unsigned Depth = 0;\n\n  // Attempt to improve chain by a single step\n  std::function<bool(SDValue &)> ImproveChain = [&](SDValue &C) -> bool {\n    switch (C.getOpcode()) {\n    case ISD::EntryToken:\n      // No need to mark EntryToken.\n      C = SDValue();\n      return true;\n    case ISD::LOAD:\n    case ISD::STORE: {\n      // Get alias information for C.\n      // TODO: Relax aliasing for unordered atomics (see D66309)\n      bool IsOpLoad = isa<LoadSDNode>(C.getNode()) &&\n                      cast<LSBaseSDNode>(C.getNode())->isSimple();\n      if ((IsLoad && IsOpLoad) || !isAlias(N, C.getNode())) {\n        // Look further up the chain.\n        C = C.getOperand(0);\n        return true;\n      }\n      // Alias, so stop here.\n      return false;\n    }\n\n    case ISD::CopyFromReg:\n      // Always forward past past CopyFromReg.\n      C = C.getOperand(0);\n      return true;\n\n    case ISD::LIFETIME_START:\n    case ISD::LIFETIME_END: {\n      // We can forward past any lifetime start/end that can be proven not to\n      // alias the memory access.\n      if (!isAlias(N, C.getNode())) {\n        // Look further up the chain.\n        C = C.getOperand(0);\n        return true;\n      }\n      return false;\n    }\n    default:\n      return false;\n    }\n  };\n\n  // Look at each chain and determine if it is an alias.  If so, add it to the\n  // aliases list.  If not, then continue up the chain looking for the next\n  // candidate.\n  while (!Chains.empty()) {\n    SDValue Chain = Chains.pop_back_val();\n\n    // Don't bother if we've seen Chain before.\n    if (!Visited.insert(Chain.getNode()).second)\n      continue;\n\n    // For TokenFactor nodes, look at each operand and only continue up the\n    // chain until we reach the depth limit.\n    //\n    // FIXME: The depth check could be made to return the last non-aliasing\n    // chain we found before we hit a tokenfactor rather than the original\n    // chain.\n    if (Depth > TLI.getGatherAllAliasesMaxDepth()) {\n      Aliases.clear();\n      Aliases.push_back(OriginalChain);\n      return;\n    }\n\n    if (Chain.getOpcode() == ISD::TokenFactor) {\n      // We have to check each of the operands of the token factor for \"small\"\n      // token factors, so we queue them up.  Adding the operands to the queue\n      // (stack) in reverse order maintains the original order and increases the\n      // likelihood that getNode will find a matching token factor (CSE.)\n      if (Chain.getNumOperands() > 16) {\n        Aliases.push_back(Chain);\n        continue;\n      }\n      for (unsigned n = Chain.getNumOperands(); n;)\n        Chains.push_back(Chain.getOperand(--n));\n      ++Depth;\n      continue;\n    }\n    // Everything else\n    if (ImproveChain(Chain)) {\n      // Updated Chain Found, Consider new chain if one exists.\n      if (Chain.getNode())\n        Chains.push_back(Chain);\n      ++Depth;\n      continue;\n    }\n    // No Improved Chain Possible, treat as Alias.\n    Aliases.push_back(Chain);\n  }\n}\n\n/// Walk up chain skipping non-aliasing memory nodes, looking for a better chain\n/// (aliasing node.)\nSDValue DAGCombiner::FindBetterChain(SDNode *N, SDValue OldChain) {\n  if (OptLevel == CodeGenOpt::None)\n    return OldChain;\n\n  // Ops for replacing token factor.\n  SmallVector<SDValue, 8> Aliases;\n\n  // Accumulate all the aliases to this node.\n  GatherAllAliases(N, OldChain, Aliases);\n\n  // If no operands then chain to entry token.\n  if (Aliases.size() == 0)\n    return DAG.getEntryNode();\n\n  // If a single operand then chain to it.  We don't need to revisit it.\n  if (Aliases.size() == 1)\n    return Aliases[0];\n\n  // Construct a custom tailored token factor.\n  return DAG.getTokenFactor(SDLoc(N), Aliases);\n}\n\nnamespace {\n// TODO: Replace with with std::monostate when we move to C++17.\nstruct UnitT { } Unit;\nbool operator==(const UnitT &, const UnitT &) { return true; }\nbool operator!=(const UnitT &, const UnitT &) { return false; }\n} // namespace\n\n// This function tries to collect a bunch of potentially interesting\n// nodes to improve the chains of, all at once. This might seem\n// redundant, as this function gets called when visiting every store\n// node, so why not let the work be done on each store as it's visited?\n//\n// I believe this is mainly important because mergeConsecutiveStores\n// is unable to deal with merging stores of different sizes, so unless\n// we improve the chains of all the potential candidates up-front\n// before running mergeConsecutiveStores, it might only see some of\n// the nodes that will eventually be candidates, and then not be able\n// to go from a partially-merged state to the desired final\n// fully-merged state.\n\nbool DAGCombiner::parallelizeChainedStores(StoreSDNode *St) {\n  SmallVector<StoreSDNode *, 8> ChainedStores;\n  StoreSDNode *STChain = St;\n  // Intervals records which offsets from BaseIndex have been covered. In\n  // the common case, every store writes to the immediately previous address\n  // space and thus merged with the previous interval at insertion time.\n\n  using IMap =\n      llvm::IntervalMap<int64_t, UnitT, 8, IntervalMapHalfOpenInfo<int64_t>>;\n  IMap::Allocator A;\n  IMap Intervals(A);\n\n  // This holds the base pointer, index, and the offset in bytes from the base\n  // pointer.\n  const BaseIndexOffset BasePtr = BaseIndexOffset::match(St, DAG);\n\n  // We must have a base and an offset.\n  if (!BasePtr.getBase().getNode())\n    return false;\n\n  // Do not handle stores to undef base pointers.\n  if (BasePtr.getBase().isUndef())\n    return false;\n\n  // BaseIndexOffset assumes that offsets are fixed-size, which\n  // is not valid for scalable vectors where the offsets are\n  // scaled by `vscale`, so bail out early.\n  if (St->getMemoryVT().isScalableVector())\n    return false;\n\n  // Add ST's interval.\n  Intervals.insert(0, (St->getMemoryVT().getSizeInBits() + 7) / 8, Unit);\n\n  while (StoreSDNode *Chain = dyn_cast<StoreSDNode>(STChain->getChain())) {\n    // If the chain has more than one use, then we can't reorder the mem ops.\n    if (!SDValue(Chain, 0)->hasOneUse())\n      break;\n    // TODO: Relax for unordered atomics (see D66309)\n    if (!Chain->isSimple() || Chain->isIndexed())\n      break;\n\n    // Find the base pointer and offset for this memory node.\n    const BaseIndexOffset Ptr = BaseIndexOffset::match(Chain, DAG);\n    // Check that the base pointer is the same as the original one.\n    int64_t Offset;\n    if (!BasePtr.equalBaseIndex(Ptr, DAG, Offset))\n      break;\n    int64_t Length = (Chain->getMemoryVT().getSizeInBits() + 7) / 8;\n    // Make sure we don't overlap with other intervals by checking the ones to\n    // the left or right before inserting.\n    auto I = Intervals.find(Offset);\n    // If there's a next interval, we should end before it.\n    if (I != Intervals.end() && I.start() < (Offset + Length))\n      break;\n    // If there's a previous interval, we should start after it.\n    if (I != Intervals.begin() && (--I).stop() <= Offset)\n      break;\n    Intervals.insert(Offset, Offset + Length, Unit);\n\n    ChainedStores.push_back(Chain);\n    STChain = Chain;\n  }\n\n  // If we didn't find a chained store, exit.\n  if (ChainedStores.size() == 0)\n    return false;\n\n  // Improve all chained stores (St and ChainedStores members) starting from\n  // where the store chain ended and return single TokenFactor.\n  SDValue NewChain = STChain->getChain();\n  SmallVector<SDValue, 8> TFOps;\n  for (unsigned I = ChainedStores.size(); I;) {\n    StoreSDNode *S = ChainedStores[--I];\n    SDValue BetterChain = FindBetterChain(S, NewChain);\n    S = cast<StoreSDNode>(DAG.UpdateNodeOperands(\n        S, BetterChain, S->getOperand(1), S->getOperand(2), S->getOperand(3)));\n    TFOps.push_back(SDValue(S, 0));\n    ChainedStores[I] = S;\n  }\n\n  // Improve St's chain. Use a new node to avoid creating a loop from CombineTo.\n  SDValue BetterChain = FindBetterChain(St, NewChain);\n  SDValue NewST;\n  if (St->isTruncatingStore())\n    NewST = DAG.getTruncStore(BetterChain, SDLoc(St), St->getValue(),\n                              St->getBasePtr(), St->getMemoryVT(),\n                              St->getMemOperand());\n  else\n    NewST = DAG.getStore(BetterChain, SDLoc(St), St->getValue(),\n                         St->getBasePtr(), St->getMemOperand());\n\n  TFOps.push_back(NewST);\n\n  // If we improved every element of TFOps, then we've lost the dependence on\n  // NewChain to successors of St and we need to add it back to TFOps. Do so at\n  // the beginning to keep relative order consistent with FindBetterChains.\n  auto hasImprovedChain = [&](SDValue ST) -> bool {\n    return ST->getOperand(0) != NewChain;\n  };\n  bool AddNewChain = llvm::all_of(TFOps, hasImprovedChain);\n  if (AddNewChain)\n    TFOps.insert(TFOps.begin(), NewChain);\n\n  SDValue TF = DAG.getTokenFactor(SDLoc(STChain), TFOps);\n  CombineTo(St, TF);\n\n  // Add TF and its operands to the worklist.\n  AddToWorklist(TF.getNode());\n  for (const SDValue &Op : TF->ops())\n    AddToWorklist(Op.getNode());\n  AddToWorklist(STChain);\n  return true;\n}\n\nbool DAGCombiner::findBetterNeighborChains(StoreSDNode *St) {\n  if (OptLevel == CodeGenOpt::None)\n    return false;\n\n  const BaseIndexOffset BasePtr = BaseIndexOffset::match(St, DAG);\n\n  // We must have a base and an offset.\n  if (!BasePtr.getBase().getNode())\n    return false;\n\n  // Do not handle stores to undef base pointers.\n  if (BasePtr.getBase().isUndef())\n    return false;\n\n  // Directly improve a chain of disjoint stores starting at St.\n  if (parallelizeChainedStores(St))\n    return true;\n\n  // Improve St's Chain..\n  SDValue BetterChain = FindBetterChain(St, St->getChain());\n  if (St->getChain() != BetterChain) {\n    replaceStoreChain(St, BetterChain);\n    return true;\n  }\n  return false;\n}\n\n/// This is the entry point for the file.\nvoid SelectionDAG::Combine(CombineLevel Level, AliasAnalysis *AA,\n                           CodeGenOpt::Level OptLevel) {\n  /// This is the main entry point to this class.\n  DAGCombiner(*this, AA, OptLevel).Run(Level);\n}\n"}}, "reports": [{"events": [{"location": {"col": 8, "file": 77, "line": 7046}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp", "reportHash": "7cb5761cb2b4813736454523580fa61a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 77, "line": 15790}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp", "reportHash": "fc5f975739629c6e278c2eac9d922ae1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 77, "line": 15796}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp", "reportHash": "353ce5d5473153077cc9e8fec3d5d5ae", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 77, "line": 15798}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp", "reportHash": "e9e9ca364575d3a77549a2531c6fd9f8", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 77, "line": 15811}, "message": "'operator>' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp", "reportHash": "371838f003b4a8a519c022235b937eff", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 77, "line": 15813}, "message": "'operator<=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp", "reportHash": "d0599feab668c48d6c5202950e1bba05", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 77, "line": 15815}, "message": "'operator>=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp", "reportHash": "efc9658930b6dbe9816358557f92b6b3", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 77, "line": 22941}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 77, "line": 22941}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp", "reportHash": "ccfc5393f45dc158f7969dad247f6576", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 77, "line": 22942}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 77, "line": 22942}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp", "reportHash": "3e75b6412a405d6539f44d653ae95f98", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
