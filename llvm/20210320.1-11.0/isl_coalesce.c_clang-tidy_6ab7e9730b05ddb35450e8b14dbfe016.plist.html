<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "content": "/*\n * Copyright 2008-2009 Katholieke Universiteit Leuven\n * Copyright 2010      INRIA Saclay\n * Copyright 2012-2013 Ecole Normale Superieure\n * Copyright 2014      INRIA Rocquencourt\n * Copyright 2016      INRIA Paris\n * Copyright 2020      Cerebras Systems\n *\n * Use of this software is governed by the MIT license\n *\n * Written by Sven Verdoolaege, K.U.Leuven, Departement\n * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium\n * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,\n * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France \n * and Ecole Normale Superieure, 45 rue d\u2019Ulm, 75230 Paris, France\n * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,\n * B.P. 105 - 78153 Le Chesnay, France\n * and Centre de Recherche Inria de Paris, 2 rue Simone Iff - Voie DQ12,\n * CS 42112, 75589 Paris Cedex 12, France\n * and Cerebras Systems, 175 S San Antonio Rd, Los Altos, CA, USA\n */\n\n#include <isl_ctx_private.h>\n#include \"isl_map_private.h\"\n#include <isl_seq.h>\n#include <isl/options.h>\n#include \"isl_tab.h\"\n#include <isl_mat_private.h>\n#include <isl_local_space_private.h>\n#include <isl_val_private.h>\n#include <isl_vec_private.h>\n#include <isl_aff_private.h>\n#include <isl_equalities.h>\n#include <isl_constraint_private.h>\n\n#include <set_to_map.c>\n#include <set_from_map.c>\n\n#define STATUS_ERROR\t\t-1\n#define STATUS_REDUNDANT\t 1\n#define STATUS_VALID\t \t 2\n#define STATUS_SEPARATE\t \t 3\n#define STATUS_CUT\t \t 4\n#define STATUS_ADJ_EQ\t \t 5\n#define STATUS_ADJ_INEQ\t \t 6\n\nstatic int status_in(isl_int *ineq, struct isl_tab *tab)\n{\n\tenum isl_ineq_type type = isl_tab_ineq_type(tab, ineq);\n\tswitch (type) {\n\tdefault:\n\tcase isl_ineq_error:\t\treturn STATUS_ERROR;\n\tcase isl_ineq_redundant:\treturn STATUS_VALID;\n\tcase isl_ineq_separate:\t\treturn STATUS_SEPARATE;\n\tcase isl_ineq_cut:\t\treturn STATUS_CUT;\n\tcase isl_ineq_adj_eq:\t\treturn STATUS_ADJ_EQ;\n\tcase isl_ineq_adj_ineq:\t\treturn STATUS_ADJ_INEQ;\n\t}\n}\n\n/* Compute the position of the equalities of basic map \"bmap_i\"\n * with respect to the basic map represented by \"tab_j\".\n * The resulting array has twice as many entries as the number\n * of equalities corresponding to the two inequalities to which\n * each equality corresponds.\n */\nstatic int *eq_status_in(__isl_keep isl_basic_map *bmap_i,\n\tstruct isl_tab *tab_j)\n{\n\tint k, l;\n\tint *eq;\n\tisl_size dim;\n\n\tdim = isl_basic_map_dim(bmap_i, isl_dim_all);\n\tif (dim < 0)\n\t\treturn NULL;\n\n\teq = isl_calloc_array(bmap_i->ctx, int, 2 * bmap_i->n_eq);\n\tif (!eq)\n\t\treturn NULL;\n\n\tfor (k = 0; k < bmap_i->n_eq; ++k) {\n\t\tfor (l = 0; l < 2; ++l) {\n\t\t\tisl_seq_neg(bmap_i->eq[k], bmap_i->eq[k], 1+dim);\n\t\t\teq[2 * k + l] = status_in(bmap_i->eq[k], tab_j);\n\t\t\tif (eq[2 * k + l] == STATUS_ERROR)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn eq;\nerror:\n\tfree(eq);\n\treturn NULL;\n}\n\n/* Compute the position of the inequalities of basic map \"bmap_i\"\n * (also represented by \"tab_i\", if not NULL) with respect to the basic map\n * represented by \"tab_j\".\n */\nstatic int *ineq_status_in(__isl_keep isl_basic_map *bmap_i,\n\tstruct isl_tab *tab_i, struct isl_tab *tab_j)\n{\n\tint k;\n\tunsigned n_eq = bmap_i->n_eq;\n\tint *ineq = isl_calloc_array(bmap_i->ctx, int, bmap_i->n_ineq);\n\n\tif (!ineq)\n\t\treturn NULL;\n\n\tfor (k = 0; k < bmap_i->n_ineq; ++k) {\n\t\tif (tab_i && isl_tab_is_redundant(tab_i, n_eq + k)) {\n\t\t\tineq[k] = STATUS_REDUNDANT;\n\t\t\tcontinue;\n\t\t}\n\t\tineq[k] = status_in(bmap_i->ineq[k], tab_j);\n\t\tif (ineq[k] == STATUS_ERROR)\n\t\t\tgoto error;\n\t\tif (ineq[k] == STATUS_SEPARATE)\n\t\t\tbreak;\n\t}\n\n\treturn ineq;\nerror:\n\tfree(ineq);\n\treturn NULL;\n}\n\nstatic int any(int *con, unsigned len, int status)\n{\n\tint i;\n\n\tfor (i = 0; i < len ; ++i)\n\t\tif (con[i] == status)\n\t\t\treturn 1;\n\treturn 0;\n}\n\n/* Return the first position of \"status\" in the list \"con\" of length \"len\".\n * Return -1 if there is no such entry.\n */\nstatic int find(int *con, unsigned len, int status)\n{\n\tint i;\n\n\tfor (i = 0; i < len ; ++i)\n\t\tif (con[i] == status)\n\t\t\treturn i;\n\treturn -1;\n}\n\nstatic int count(int *con, unsigned len, int status)\n{\n\tint i;\n\tint c = 0;\n\n\tfor (i = 0; i < len ; ++i)\n\t\tif (con[i] == status)\n\t\t\tc++;\n\treturn c;\n}\n\nstatic int all(int *con, unsigned len, int status)\n{\n\tint i;\n\n\tfor (i = 0; i < len ; ++i) {\n\t\tif (con[i] == STATUS_REDUNDANT)\n\t\t\tcontinue;\n\t\tif (con[i] != status)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/* Internal information associated to a basic map in a map\n * that is to be coalesced by isl_map_coalesce.\n *\n * \"bmap\" is the basic map itself (or NULL if \"removed\" is set)\n * \"tab\" is the corresponding tableau (or NULL if \"removed\" is set)\n * \"hull_hash\" identifies the affine space in which \"bmap\" lives.\n * \"modified\" is set if this basic map may not be identical\n * to any of the basic maps in the input.\n * \"removed\" is set if this basic map has been removed from the map\n * \"simplify\" is set if this basic map may have some unknown integer\n * divisions that were not present in the input basic maps.  The basic\n * map should then be simplified such that we may be able to find\n * a definition among the constraints.\n *\n * \"eq\" and \"ineq\" are only set if we are currently trying to coalesce\n * this basic map with another basic map, in which case they represent\n * the position of the inequalities of this basic map with respect to\n * the other basic map.  The number of elements in the \"eq\" array\n * is twice the number of equalities in the \"bmap\", corresponding\n * to the two inequalities that make up each equality.\n */\nstruct isl_coalesce_info {\n\tisl_basic_map *bmap;\n\tstruct isl_tab *tab;\n\tuint32_t hull_hash;\n\tint modified;\n\tint removed;\n\tint simplify;\n\tint *eq;\n\tint *ineq;\n};\n\n/* Is there any (half of an) equality constraint in the description\n * of the basic map represented by \"info\" that\n * has position \"status\" with respect to the other basic map?\n */\nstatic int any_eq(struct isl_coalesce_info *info, int status)\n{\n\tisl_size n_eq;\n\n\tn_eq = isl_basic_map_n_equality(info->bmap);\n\treturn any(info->eq, 2 * n_eq, status);\n}\n\n/* Is there any inequality constraint in the description\n * of the basic map represented by \"info\" that\n * has position \"status\" with respect to the other basic map?\n */\nstatic int any_ineq(struct isl_coalesce_info *info, int status)\n{\n\tisl_size n_ineq;\n\n\tn_ineq = isl_basic_map_n_inequality(info->bmap);\n\treturn any(info->ineq, n_ineq, status);\n}\n\n/* Return the position of the first half on an equality constraint\n * in the description of the basic map represented by \"info\" that\n * has position \"status\" with respect to the other basic map.\n * The returned value is twice the position of the equality constraint\n * plus zero for the negative half and plus one for the positive half.\n * Return -1 if there is no such entry.\n */\nstatic int find_eq(struct isl_coalesce_info *info, int status)\n{\n\tisl_size n_eq;\n\n\tn_eq = isl_basic_map_n_equality(info->bmap);\n\treturn find(info->eq, 2 * n_eq, status);\n}\n\n/* Return the position of the first inequality constraint in the description\n * of the basic map represented by \"info\" that\n * has position \"status\" with respect to the other basic map.\n * Return -1 if there is no such entry.\n */\nstatic int find_ineq(struct isl_coalesce_info *info, int status)\n{\n\tisl_size n_ineq;\n\n\tn_ineq = isl_basic_map_n_inequality(info->bmap);\n\treturn find(info->ineq, n_ineq, status);\n}\n\n/* Return the number of (halves of) equality constraints in the description\n * of the basic map represented by \"info\" that\n * have position \"status\" with respect to the other basic map.\n */\nstatic int count_eq(struct isl_coalesce_info *info, int status)\n{\n\tisl_size n_eq;\n\n\tn_eq = isl_basic_map_n_equality(info->bmap);\n\treturn count(info->eq, 2 * n_eq, status);\n}\n\n/* Return the number of inequality constraints in the description\n * of the basic map represented by \"info\" that\n * have position \"status\" with respect to the other basic map.\n */\nstatic int count_ineq(struct isl_coalesce_info *info, int status)\n{\n\tisl_size n_ineq;\n\n\tn_ineq = isl_basic_map_n_inequality(info->bmap);\n\treturn count(info->ineq, n_ineq, status);\n}\n\n/* Are all non-redundant constraints of the basic map represented by \"info\"\n * either valid or cut constraints with respect to the other basic map?\n */\nstatic int all_valid_or_cut(struct isl_coalesce_info *info)\n{\n\tint i;\n\n\tfor (i = 0; i < 2 * info->bmap->n_eq; ++i) {\n\t\tif (info->eq[i] == STATUS_REDUNDANT)\n\t\t\tcontinue;\n\t\tif (info->eq[i] == STATUS_VALID)\n\t\t\tcontinue;\n\t\tif (info->eq[i] == STATUS_CUT)\n\t\t\tcontinue;\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < info->bmap->n_ineq; ++i) {\n\t\tif (info->ineq[i] == STATUS_REDUNDANT)\n\t\t\tcontinue;\n\t\tif (info->ineq[i] == STATUS_VALID)\n\t\t\tcontinue;\n\t\tif (info->ineq[i] == STATUS_CUT)\n\t\t\tcontinue;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n/* Compute the hash of the (apparent) affine hull of info->bmap (with\n * the existentially quantified variables removed) and store it\n * in info->hash.\n */\nstatic int coalesce_info_set_hull_hash(struct isl_coalesce_info *info)\n{\n\tisl_basic_map *hull;\n\tisl_size n_div;\n\n\thull = isl_basic_map_copy(info->bmap);\n\thull = isl_basic_map_plain_affine_hull(hull);\n\tn_div = isl_basic_map_dim(hull, isl_dim_div);\n\tif (n_div < 0)\n\t\thull = isl_basic_map_free(hull);\n\thull = isl_basic_map_drop_constraints_involving_dims(hull,\n\t\t\t\t\t\t\tisl_dim_div, 0, n_div);\n\tinfo->hull_hash = isl_basic_map_get_hash(hull);\n\tisl_basic_map_free(hull);\n\n\treturn hull ? 0 : -1;\n}\n\n/* Free all the allocated memory in an array\n * of \"n\" isl_coalesce_info elements.\n */\nstatic void clear_coalesce_info(int n, struct isl_coalesce_info *info)\n{\n\tint i;\n\n\tif (!info)\n\t\treturn;\n\n\tfor (i = 0; i < n; ++i) {\n\t\tisl_basic_map_free(info[i].bmap);\n\t\tisl_tab_free(info[i].tab);\n\t}\n\n\tfree(info);\n}\n\n/* Clear the memory associated to \"info\".\n */\nstatic void clear(struct isl_coalesce_info *info)\n{\n\tinfo->bmap = isl_basic_map_free(info->bmap);\n\tisl_tab_free(info->tab);\n\tinfo->tab = NULL;\n}\n\n/* Drop the basic map represented by \"info\".\n * That is, clear the memory associated to the entry and\n * mark it as having been removed.\n */\nstatic void drop(struct isl_coalesce_info *info)\n{\n\tclear(info);\n\tinfo->removed = 1;\n}\n\n/* Exchange the information in \"info1\" with that in \"info2\".\n */\nstatic void exchange(struct isl_coalesce_info *info1,\n\tstruct isl_coalesce_info *info2)\n{\n\tstruct isl_coalesce_info info;\n\n\tinfo = *info1;\n\t*info1 = *info2;\n\t*info2 = info;\n}\n\n/* This type represents the kind of change that has been performed\n * while trying to coalesce two basic maps.\n *\n * isl_change_none: nothing was changed\n * isl_change_drop_first: the first basic map was removed\n * isl_change_drop_second: the second basic map was removed\n * isl_change_fuse: the two basic maps were replaced by a new basic map.\n */\nenum isl_change {\n\tisl_change_error = -1,\n\tisl_change_none = 0,\n\tisl_change_drop_first,\n\tisl_change_drop_second,\n\tisl_change_fuse,\n};\n\n/* Update \"change\" based on an interchange of the first and the second\n * basic map.  That is, interchange isl_change_drop_first and\n * isl_change_drop_second.\n */\nstatic enum isl_change invert_change(enum isl_change change)\n{\n\tswitch (change) {\n\tcase isl_change_error:\n\t\treturn isl_change_error;\n\tcase isl_change_none:\n\t\treturn isl_change_none;\n\tcase isl_change_drop_first:\n\t\treturn isl_change_drop_second;\n\tcase isl_change_drop_second:\n\t\treturn isl_change_drop_first;\n\tcase isl_change_fuse:\n\t\treturn isl_change_fuse;\n\t}\n\n\treturn isl_change_error;\n}\n\n/* Add the valid constraints of the basic map represented by \"info\"\n * to \"bmap\".  \"len\" is the size of the constraints.\n * If only one of the pair of inequalities that make up an equality\n * is valid, then add that inequality.\n */\nstatic __isl_give isl_basic_map *add_valid_constraints(\n\t__isl_take isl_basic_map *bmap, struct isl_coalesce_info *info,\n\tunsigned len)\n{\n\tint k, l;\n\n\tif (!bmap)\n\t\treturn NULL;\n\n\tfor (k = 0; k < info->bmap->n_eq; ++k) {\n\t\tif (info->eq[2 * k] == STATUS_VALID &&\n\t\t    info->eq[2 * k + 1] == STATUS_VALID) {\n\t\t\tl = isl_basic_map_alloc_equality(bmap);\n\t\t\tif (l < 0)\n\t\t\t\treturn isl_basic_map_free(bmap);\n\t\t\tisl_seq_cpy(bmap->eq[l], info->bmap->eq[k], len);\n\t\t} else if (info->eq[2 * k] == STATUS_VALID) {\n\t\t\tl = isl_basic_map_alloc_inequality(bmap);\n\t\t\tif (l < 0)\n\t\t\t\treturn isl_basic_map_free(bmap);\n\t\t\tisl_seq_neg(bmap->ineq[l], info->bmap->eq[k], len);\n\t\t} else if (info->eq[2 * k + 1] == STATUS_VALID) {\n\t\t\tl = isl_basic_map_alloc_inequality(bmap);\n\t\t\tif (l < 0)\n\t\t\t\treturn isl_basic_map_free(bmap);\n\t\t\tisl_seq_cpy(bmap->ineq[l], info->bmap->eq[k], len);\n\t\t}\n\t}\n\n\tfor (k = 0; k < info->bmap->n_ineq; ++k) {\n\t\tif (info->ineq[k] != STATUS_VALID)\n\t\t\tcontinue;\n\t\tl = isl_basic_map_alloc_inequality(bmap);\n\t\tif (l < 0)\n\t\t\treturn isl_basic_map_free(bmap);\n\t\tisl_seq_cpy(bmap->ineq[l], info->bmap->ineq[k], len);\n\t}\n\n\treturn bmap;\n}\n\n/* Is \"bmap\" defined by a number of (non-redundant) constraints that\n * is greater than the number of constraints of basic maps i and j combined?\n * Equalities are counted as two inequalities.\n */\nstatic int number_of_constraints_increases(int i, int j,\n\tstruct isl_coalesce_info *info,\n\t__isl_keep isl_basic_map *bmap, struct isl_tab *tab)\n{\n\tint k, n_old, n_new;\n\n\tn_old = 2 * info[i].bmap->n_eq + info[i].bmap->n_ineq;\n\tn_old += 2 * info[j].bmap->n_eq + info[j].bmap->n_ineq;\n\n\tn_new = 2 * bmap->n_eq;\n\tfor (k = 0; k < bmap->n_ineq; ++k)\n\t\tif (!isl_tab_is_redundant(tab, bmap->n_eq + k))\n\t\t\t++n_new;\n\n\treturn n_new > n_old;\n}\n\n/* Replace the pair of basic maps i and j by the basic map bounded\n * by the valid constraints in both basic maps and the constraints\n * in extra (if not NULL).\n * Place the fused basic map in the position that is the smallest of i and j.\n *\n * If \"detect_equalities\" is set, then look for equalities encoded\n * as pairs of inequalities.\n * If \"check_number\" is set, then the original basic maps are only\n * replaced if the total number of constraints does not increase.\n * While the number of integer divisions in the two basic maps\n * is assumed to be the same, the actual definitions may be different.\n * We only copy the definition from one of the basic map if it is\n * the same as that of the other basic map.  Otherwise, we mark\n * the integer division as unknown and simplify the basic map\n * in an attempt to recover the integer division definition.\n * If any extra constraints get introduced, then these may\n * involve integer divisions with a unit coefficient.\n * Eliminate those that do not appear with any other coefficient\n * in other constraints, to ensure they get eliminated completely,\n * improving the chances of further coalescing.\n */\nstatic enum isl_change fuse(int i, int j, struct isl_coalesce_info *info,\n\t__isl_keep isl_mat *extra, int detect_equalities, int check_number)\n{\n\tint k, l;\n\tstruct isl_basic_map *fused = NULL;\n\tstruct isl_tab *fused_tab = NULL;\n\tisl_size total = isl_basic_map_dim(info[i].bmap, isl_dim_all);\n\tunsigned extra_rows = extra ? extra->n_row : 0;\n\tunsigned n_eq, n_ineq;\n\tint simplify = 0;\n\n\tif (total < 0)\n\t\treturn isl_change_error;\n\tif (j < i)\n\t\treturn fuse(j, i, info, extra, detect_equalities, check_number);\n\n\tn_eq = info[i].bmap->n_eq + info[j].bmap->n_eq;\n\tn_ineq = info[i].bmap->n_ineq + info[j].bmap->n_ineq;\n\tfused = isl_basic_map_alloc_space(isl_space_copy(info[i].bmap->dim),\n\t\t    info[i].bmap->n_div, n_eq, n_eq + n_ineq + extra_rows);\n\tfused = add_valid_constraints(fused, &info[i], 1 + total);\n\tfused = add_valid_constraints(fused, &info[j], 1 + total);\n\tif (!fused)\n\t\tgoto error;\n\tif (ISL_F_ISSET(info[i].bmap, ISL_BASIC_MAP_RATIONAL) &&\n\t    ISL_F_ISSET(info[j].bmap, ISL_BASIC_MAP_RATIONAL))\n\t\tISL_F_SET(fused, ISL_BASIC_MAP_RATIONAL);\n\n\tfor (k = 0; k < info[i].bmap->n_div; ++k) {\n\t\tint l = isl_basic_map_alloc_div(fused);\n\t\tif (l < 0)\n\t\t\tgoto error;\n\t\tif (isl_seq_eq(info[i].bmap->div[k], info[j].bmap->div[k],\n\t\t\t\t1 + 1 + total)) {\n\t\t\tisl_seq_cpy(fused->div[l], info[i].bmap->div[k],\n\t\t\t\t1 + 1 + total);\n\t\t} else {\n\t\t\tisl_int_set_si(fused->div[l][0], 0);\n\t\t\tsimplify = 1;\n\t\t}\n\t}\n\n\tfor (k = 0; k < extra_rows; ++k) {\n\t\tl = isl_basic_map_alloc_inequality(fused);\n\t\tif (l < 0)\n\t\t\tgoto error;\n\t\tisl_seq_cpy(fused->ineq[l], extra->row[k], 1 + total);\n\t}\n\n\tif (detect_equalities)\n\t\tfused = isl_basic_map_detect_inequality_pairs(fused, NULL);\n\tfused = isl_basic_map_gauss(fused, NULL);\n\tif (simplify || info[j].simplify) {\n\t\tfused = isl_basic_map_simplify(fused);\n\t\tinfo[i].simplify = 0;\n\t} else if (extra_rows > 0) {\n\t\tfused = isl_basic_map_eliminate_pure_unit_divs(fused);\n\t}\n\tfused = isl_basic_map_finalize(fused);\n\n\tfused_tab = isl_tab_from_basic_map(fused, 0);\n\tif (isl_tab_detect_redundant(fused_tab) < 0)\n\t\tgoto error;\n\n\tif (check_number &&\n\t    number_of_constraints_increases(i, j, info, fused, fused_tab)) {\n\t\tisl_tab_free(fused_tab);\n\t\tisl_basic_map_free(fused);\n\t\treturn isl_change_none;\n\t}\n\n\tclear(&info[i]);\n\tinfo[i].bmap = fused;\n\tinfo[i].tab = fused_tab;\n\tinfo[i].modified = 1;\n\tdrop(&info[j]);\n\n\treturn isl_change_fuse;\nerror:\n\tisl_tab_free(fused_tab);\n\tisl_basic_map_free(fused);\n\treturn isl_change_error;\n}\n\n/* Given a pair of basic maps i and j such that all constraints are either\n * \"valid\" or \"cut\", check if the facets corresponding to the \"cut\"\n * constraints of i lie entirely within basic map j.\n * If so, replace the pair by the basic map consisting of the valid\n * constraints in both basic maps.\n * Checking whether the facet lies entirely within basic map j\n * is performed by checking whether the constraints of basic map j\n * are valid for the facet.  These tests are performed on a rational\n * tableau to avoid the theoretical possibility that a constraint\n * that was considered to be a cut constraint for the entire basic map i\n * happens to be considered to be a valid constraint for the facet,\n * even though it cuts off the same rational points.\n *\n * To see that we are not introducing any extra points, call the\n * two basic maps A and B and the resulting map U and let x\n * be an element of U \\setminus ( A \\cup B ).\n * A line connecting x with an element of A \\cup B meets a facet F\n * of either A or B.  Assume it is a facet of B and let c_1 be\n * the corresponding facet constraint.  We have c_1(x) < 0 and\n * so c_1 is a cut constraint.  This implies that there is some\n * (possibly rational) point x' satisfying the constraints of A\n * and the opposite of c_1 as otherwise c_1 would have been marked\n * valid for A.  The line connecting x and x' meets a facet of A\n * in a (possibly rational) point that also violates c_1, but this\n * is impossible since all cut constraints of B are valid for all\n * cut facets of A.\n * In case F is a facet of A rather than B, then we can apply the\n * above reasoning to find a facet of B separating x from A \\cup B first.\n */\nstatic enum isl_change check_facets(int i, int j,\n\tstruct isl_coalesce_info *info)\n{\n\tint k, l;\n\tstruct isl_tab_undo *snap, *snap2;\n\tunsigned n_eq = info[i].bmap->n_eq;\n\n\tsnap = isl_tab_snap(info[i].tab);\n\tif (isl_tab_mark_rational(info[i].tab) < 0)\n\t\treturn isl_change_error;\n\tsnap2 = isl_tab_snap(info[i].tab);\n\n\tfor (k = 0; k < info[i].bmap->n_ineq; ++k) {\n\t\tif (info[i].ineq[k] != STATUS_CUT)\n\t\t\tcontinue;\n\t\tif (isl_tab_select_facet(info[i].tab, n_eq + k) < 0)\n\t\t\treturn isl_change_error;\n\t\tfor (l = 0; l < info[j].bmap->n_ineq; ++l) {\n\t\t\tint stat;\n\t\t\tif (info[j].ineq[l] != STATUS_CUT)\n\t\t\t\tcontinue;\n\t\t\tstat = status_in(info[j].bmap->ineq[l], info[i].tab);\n\t\t\tif (stat < 0)\n\t\t\t\treturn isl_change_error;\n\t\t\tif (stat != STATUS_VALID)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (isl_tab_rollback(info[i].tab, snap2) < 0)\n\t\t\treturn isl_change_error;\n\t\tif (l < info[j].bmap->n_ineq)\n\t\t\tbreak;\n\t}\n\n\tif (k < info[i].bmap->n_ineq) {\n\t\tif (isl_tab_rollback(info[i].tab, snap) < 0)\n\t\t\treturn isl_change_error;\n\t\treturn isl_change_none;\n\t}\n\treturn fuse(i, j, info, NULL, 0, 0);\n}\n\n/* Check if info->bmap contains the basic map represented\n * by the tableau \"tab\".\n * For each equality, we check both the constraint itself\n * (as an inequality) and its negation.  Make sure the\n * equality is returned to its original state before returning.\n */\nstatic isl_bool contains(struct isl_coalesce_info *info, struct isl_tab *tab)\n{\n\tint k;\n\tisl_size dim;\n\tisl_basic_map *bmap = info->bmap;\n\n\tdim = isl_basic_map_dim(bmap, isl_dim_all);\n\tif (dim < 0)\n\t\treturn isl_bool_error;\n\tfor (k = 0; k < bmap->n_eq; ++k) {\n\t\tint stat;\n\t\tisl_seq_neg(bmap->eq[k], bmap->eq[k], 1 + dim);\n\t\tstat = status_in(bmap->eq[k], tab);\n\t\tisl_seq_neg(bmap->eq[k], bmap->eq[k], 1 + dim);\n\t\tif (stat < 0)\n\t\t\treturn isl_bool_error;\n\t\tif (stat != STATUS_VALID)\n\t\t\treturn isl_bool_false;\n\t\tstat = status_in(bmap->eq[k], tab);\n\t\tif (stat < 0)\n\t\t\treturn isl_bool_error;\n\t\tif (stat != STATUS_VALID)\n\t\t\treturn isl_bool_false;\n\t}\n\n\tfor (k = 0; k < bmap->n_ineq; ++k) {\n\t\tint stat;\n\t\tif (info->ineq[k] == STATUS_REDUNDANT)\n\t\t\tcontinue;\n\t\tstat = status_in(bmap->ineq[k], tab);\n\t\tif (stat < 0)\n\t\t\treturn isl_bool_error;\n\t\tif (stat != STATUS_VALID)\n\t\t\treturn isl_bool_false;\n\t}\n\treturn isl_bool_true;\n}\n\n/* Basic map \"i\" has an inequality \"k\" that is adjacent\n * to some inequality of basic map \"j\".  All the other inequalities\n * are valid for \"j\".\n * If not NULL, then \"extra\" contains extra wrapping constraints that are valid\n * for both \"i\" and \"j\".\n * Check if basic map \"j\" forms an extension of basic map \"i\",\n * taking into account the extra constraints, if any.\n *\n * Note that this function is only called if some of the equalities or\n * inequalities of basic map \"j\" do cut basic map \"i\".  The function is\n * correct even if there are no such cut constraints, but in that case\n * the additional checks performed by this function are overkill.\n *\n * In particular, we replace constraint k, say f >= 0, by constraint\n * f <= -1, add the inequalities of \"j\" that are valid for \"i\",\n * as well as the \"extra\" constraints, if any,\n * and check if the result is a subset of basic map \"j\".\n * To improve the chances of the subset relation being detected,\n * any variable that only attains a single integer value\n * in the tableau of \"i\" is first fixed to that value.\n * If the result is a subset, then we know that this result is exactly equal\n * to basic map \"j\" since all its constraints are valid for basic map \"j\".\n * By combining the valid constraints of \"i\" (all equalities and all\n * inequalities except \"k\"), the valid constraints of \"j\" and\n * the \"extra\" constraints, if any, we therefore\n * obtain a basic map that is equal to their union.\n * In this case, there is no need to perform a rollback of the tableau\n * since it is going to be destroyed in fuse().\n *\n *\n *\t|\\__\t\t\t|\\__\n *\t|   \\__\t\t\t|   \\__\n *\t|      \\_\t=>\t|      \\__\n *\t|_______| _\t\t|_________\\\n *\n *\n *\t|\\\t\t\t|\\\n *\t| \\\t\t\t| \\\n *\t|  \\\t\t\t|  \\\n *\t|  |\t\t\t|   \\\n *\t|  ||\\\t\t=>      |    \\\n *\t|  || \\\t\t\t|     \\\n *\t|  ||  |\t\t|      |\n *\t|__||_/\t\t\t|_____/\n *\n *\n *\t_______\t\t\t _______\n *     |       | __\t\t|       \\__\n *     |       ||__|\t=>\t|        __|\n *     |_______|\t\t|_______/\n */\nstatic enum isl_change is_adj_ineq_extension_with_wraps(int i, int j, int k,\n\tstruct isl_coalesce_info *info, __isl_keep isl_mat *extra)\n{\n\tstruct isl_tab_undo *snap;\n\tisl_size n_eq_i, n_ineq_j, n_extra;\n\tisl_size total = isl_basic_map_dim(info[i].bmap, isl_dim_all);\n\tisl_stat r;\n\tisl_bool super;\n\n\tif (total < 0)\n\t\treturn isl_change_error;\n\n\tn_eq_i = isl_basic_map_n_equality(info[i].bmap);\n\tn_ineq_j = isl_basic_map_n_inequality(info[j].bmap);\n\tn_extra = isl_mat_rows(extra);\n\tif (n_eq_i < 0 || n_ineq_j < 0 || n_extra < 0)\n\t\treturn isl_change_error;\n\n\tif (isl_tab_extend_cons(info[i].tab, 1 + n_ineq_j + n_extra) < 0)\n\t\treturn isl_change_error;\n\n\tsnap = isl_tab_snap(info[i].tab);\n\n\tif (isl_tab_unrestrict(info[i].tab, n_eq_i + k) < 0)\n\t\treturn isl_change_error;\n\n\tisl_seq_neg(info[i].bmap->ineq[k], info[i].bmap->ineq[k], 1 + total);\n\tisl_int_sub_ui(info[i].bmap->ineq[k][0], info[i].bmap->ineq[k][0], 1);\n\tr = isl_tab_add_ineq(info[i].tab, info[i].bmap->ineq[k]);\n\tisl_seq_neg(info[i].bmap->ineq[k], info[i].bmap->ineq[k], 1 + total);\n\tisl_int_sub_ui(info[i].bmap->ineq[k][0], info[i].bmap->ineq[k][0], 1);\n\tif (r < 0)\n\t\treturn isl_change_error;\n\n\tfor (k = 0; k < n_ineq_j; ++k) {\n\t\tif (info[j].ineq[k] != STATUS_VALID)\n\t\t\tcontinue;\n\t\tif (isl_tab_add_ineq(info[i].tab, info[j].bmap->ineq[k]) < 0)\n\t\t\treturn isl_change_error;\n\t}\n\tfor (k = 0; k < n_extra; ++k) {\n\t\tif (isl_tab_add_ineq(info[i].tab, extra->row[k]) < 0)\n\t\t\treturn isl_change_error;\n\t}\n\tif (isl_tab_detect_constants(info[i].tab) < 0)\n\t\treturn isl_change_error;\n\n\tsuper = contains(&info[j], info[i].tab);\n\tif (super < 0)\n\t\treturn isl_change_error;\n\tif (super)\n\t\treturn fuse(i, j, info, extra, 0, 0);\n\n\tif (isl_tab_rollback(info[i].tab, snap) < 0)\n\t\treturn isl_change_error;\n\n\treturn isl_change_none;\n}\n\n/* Given an affine transformation matrix \"T\", does row \"row\" represent\n * anything other than a unit vector (possibly shifted by a constant)\n * that is not involved in any of the other rows?\n *\n * That is, if a constraint involves the variable corresponding to\n * the row, then could its preimage by \"T\" have any coefficients\n * that are different from those in the original constraint?\n */\nstatic int not_unique_unit_row(__isl_keep isl_mat *T, int row)\n{\n\tint i, j;\n\tint len = T->n_col - 1;\n\n\ti = isl_seq_first_non_zero(T->row[row] + 1, len);\n\tif (i < 0)\n\t\treturn 1;\n\tif (!isl_int_is_one(T->row[row][1 + i]) &&\n\t    !isl_int_is_negone(T->row[row][1 + i]))\n\t\treturn 1;\n\n\tj = isl_seq_first_non_zero(T->row[row] + 1 + i + 1, len - (i + 1));\n\tif (j >= 0)\n\t\treturn 1;\n\n\tfor (j = 1; j < T->n_row; ++j) {\n\t\tif (j == row)\n\t\t\tcontinue;\n\t\tif (!isl_int_is_zero(T->row[j][1 + i]))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n/* Does inequality constraint \"ineq\" of \"bmap\" involve any of\n * the variables marked in \"affected\"?\n * \"total\" is the total number of variables, i.e., the number\n * of entries in \"affected\".\n */\nstatic isl_bool is_affected(__isl_keep isl_basic_map *bmap, int ineq,\n\tint *affected, int total)\n{\n\tint i;\n\n\tfor (i = 0; i < total; ++i) {\n\t\tif (!affected[i])\n\t\t\tcontinue;\n\t\tif (!isl_int_is_zero(bmap->ineq[ineq][1 + i]))\n\t\t\treturn isl_bool_true;\n\t}\n\n\treturn isl_bool_false;\n}\n\n/* Given the compressed version of inequality constraint \"ineq\"\n * of info->bmap in \"v\", check if the constraint can be tightened,\n * where the compression is based on an equality constraint valid\n * for info->tab.\n * If so, add the tightened version of the inequality constraint\n * to info->tab.  \"v\" may be modified by this function.\n *\n * That is, if the compressed constraint is of the form\n *\n *\tm f() + c >= 0\n *\n * with 0 < c < m, then it is equivalent to\n *\n *\tf() >= 0\n *\n * This means that c can also be subtracted from the original,\n * uncompressed constraint without affecting the integer points\n * in info->tab.  Add this tightened constraint as an extra row\n * to info->tab to make this information explicitly available.\n */\nstatic __isl_give isl_vec *try_tightening(struct isl_coalesce_info *info,\n\tint ineq, __isl_take isl_vec *v)\n{\n\tisl_ctx *ctx;\n\tisl_stat r;\n\n\tif (!v)\n\t\treturn NULL;\n\n\tctx = isl_vec_get_ctx(v);\n\tisl_seq_gcd(v->el + 1, v->size - 1, &ctx->normalize_gcd);\n\tif (isl_int_is_zero(ctx->normalize_gcd) ||\n\t    isl_int_is_one(ctx->normalize_gcd)) {\n\t\treturn v;\n\t}\n\n\tv = isl_vec_cow(v);\n\tif (!v)\n\t\treturn NULL;\n\n\tisl_int_fdiv_r(v->el[0], v->el[0], ctx->normalize_gcd);\n\tif (isl_int_is_zero(v->el[0]))\n\t\treturn v;\n\n\tif (isl_tab_extend_cons(info->tab, 1) < 0)\n\t\treturn isl_vec_free(v);\n\n\tisl_int_sub(info->bmap->ineq[ineq][0],\n\t\t    info->bmap->ineq[ineq][0], v->el[0]);\n\tr = isl_tab_add_ineq(info->tab, info->bmap->ineq[ineq]);\n\tisl_int_add(info->bmap->ineq[ineq][0],\n\t\t    info->bmap->ineq[ineq][0], v->el[0]);\n\n\tif (r < 0)\n\t\treturn isl_vec_free(v);\n\n\treturn v;\n}\n\n/* Tighten the (non-redundant) constraints on the facet represented\n * by info->tab.\n * In particular, on input, info->tab represents the result\n * of relaxing the \"n\" inequality constraints of info->bmap in \"relaxed\"\n * by one, i.e., replacing f_i >= 0 by f_i + 1 >= 0, and then\n * replacing the one at index \"l\" by the corresponding equality,\n * i.e., f_k + 1 = 0, with k = relaxed[l].\n *\n * Compute a variable compression from the equality constraint f_k + 1 = 0\n * and use it to tighten the other constraints of info->bmap\n * (that is, all constraints that have not been relaxed),\n * updating info->tab (and leaving info->bmap untouched).\n * The compression handles essentially two cases, one where a variable\n * is assigned a fixed value and can therefore be eliminated, and one\n * where one variable is a shifted multiple of some other variable and\n * can therefore be replaced by that multiple.\n * Gaussian elimination would also work for the first case, but for\n * the second case, the effectiveness would depend on the order\n * of the variables.\n * After compression, some of the constraints may have coefficients\n * with a common divisor.  If this divisor does not divide the constant\n * term, then the constraint can be tightened.\n * The tightening is performed on the tableau info->tab by introducing\n * extra (temporary) constraints.\n *\n * Only constraints that are possibly affected by the compression are\n * considered.  In particular, if the constraint only involves variables\n * that are directly mapped to a distinct set of other variables, then\n * no common divisor can be introduced and no tightening can occur.\n *\n * It is important to only consider the non-redundant constraints\n * since the facet constraint has been relaxed prior to the call\n * to this function, meaning that the constraints that were redundant\n * prior to the relaxation may no longer be redundant.\n * These constraints will be ignored in the fused result, so\n * the fusion detection should not exploit them.\n */\nstatic isl_stat tighten_on_relaxed_facet(struct isl_coalesce_info *info,\n\tint n, int *relaxed, int l)\n{\n\tisl_size total;\n\tisl_ctx *ctx;\n\tisl_vec *v = NULL;\n\tisl_mat *T;\n\tint i;\n\tint k;\n\tint *affected;\n\n\tk = relaxed[l];\n\tctx = isl_basic_map_get_ctx(info->bmap);\n\ttotal = isl_basic_map_dim(info->bmap, isl_dim_all);\n\tif (total < 0)\n\t\treturn isl_stat_error;\n\tisl_int_add_ui(info->bmap->ineq[k][0], info->bmap->ineq[k][0], 1);\n\tT = isl_mat_sub_alloc6(ctx, info->bmap->ineq, k, 1, 0, 1 + total);\n\tT = isl_mat_variable_compression(T, NULL);\n\tisl_int_sub_ui(info->bmap->ineq[k][0], info->bmap->ineq[k][0], 1);\n\tif (!T)\n\t\treturn isl_stat_error;\n\tif (T->n_col == 0) {\n\t\tisl_mat_free(T);\n\t\treturn isl_stat_ok;\n\t}\n\n\taffected = isl_alloc_array(ctx, int, total);\n\tif (!affected)\n\t\tgoto error;\n\n\tfor (i = 0; i < total; ++i)\n\t\taffected[i] = not_unique_unit_row(T, 1 + i);\n\n\tfor (i = 0; i < info->bmap->n_ineq; ++i) {\n\t\tisl_bool handle;\n\t\tif (any(relaxed, n, i))\n\t\t\tcontinue;\n\t\tif (info->ineq[i] == STATUS_REDUNDANT)\n\t\t\tcontinue;\n\t\thandle = is_affected(info->bmap, i, affected, total);\n\t\tif (handle < 0)\n\t\t\tgoto error;\n\t\tif (!handle)\n\t\t\tcontinue;\n\t\tv = isl_vec_alloc(ctx, 1 + total);\n\t\tif (!v)\n\t\t\tgoto error;\n\t\tisl_seq_cpy(v->el, info->bmap->ineq[i], 1 + total);\n\t\tv = isl_vec_mat_product(v, isl_mat_copy(T));\n\t\tv = try_tightening(info, i, v);\n\t\tisl_vec_free(v);\n\t\tif (!v)\n\t\t\tgoto error;\n\t}\n\n\tisl_mat_free(T);\n\tfree(affected);\n\treturn isl_stat_ok;\nerror:\n\tisl_mat_free(T);\n\tfree(affected);\n\treturn isl_stat_error;\n}\n\n/* Replace the basic maps \"i\" and \"j\" by an extension of \"i\"\n * along the \"n\" inequality constraints in \"relax\" by one.\n * The tableau info[i].tab has already been extended.\n * Extend info[i].bmap accordingly by relaxing all constraints in \"relax\"\n * by one.\n * Each integer division that does not have exactly the same\n * definition in \"i\" and \"j\" is marked unknown and the basic map\n * is scheduled to be simplified in an attempt to recover\n * the integer division definition.\n * Place the extension in the position that is the smallest of i and j.\n */\nstatic enum isl_change extend(int i, int j, int n, int *relax,\n\tstruct isl_coalesce_info *info)\n{\n\tint l;\n\tisl_size total;\n\n\tinfo[i].bmap = isl_basic_map_cow(info[i].bmap);\n\ttotal = isl_basic_map_dim(info[i].bmap, isl_dim_all);\n\tif (total < 0)\n\t\treturn isl_change_error;\n\tfor (l = 0; l < info[i].bmap->n_div; ++l)\n\t\tif (!isl_seq_eq(info[i].bmap->div[l],\n\t\t\t\tinfo[j].bmap->div[l], 1 + 1 + total)) {\n\t\t\tisl_int_set_si(info[i].bmap->div[l][0], 0);\n\t\t\tinfo[i].simplify = 1;\n\t\t}\n\tfor (l = 0; l < n; ++l)\n\t\tisl_int_add_ui(info[i].bmap->ineq[relax[l]][0],\n\t\t\t\tinfo[i].bmap->ineq[relax[l]][0], 1);\n\tISL_F_CLR(info[i].bmap, ISL_BASIC_MAP_NO_REDUNDANT);\n\tISL_F_SET(info[i].bmap, ISL_BASIC_MAP_FINAL);\n\tdrop(&info[j]);\n\tinfo[i].modified = 1;\n\tif (j < i)\n\t\texchange(&info[i], &info[j]);\n\treturn isl_change_fuse;\n}\n\n/* Basic map \"i\" has \"n\" inequality constraints (collected in \"relax\")\n * that are such that they include basic map \"j\" if they are relaxed\n * by one.  All the other inequalities are valid for \"j\".\n * Check if basic map \"j\" forms an extension of basic map \"i\".\n *\n * In particular, relax the constraints in \"relax\", compute the corresponding\n * facets one by one and check whether each of these is included\n * in the other basic map.\n * Before testing for inclusion, the constraints on each facet\n * are tightened to increase the chance of an inclusion being detected.\n * (Adding the valid constraints of \"j\" to the tableau of \"i\", as is done\n * in is_adj_ineq_extension, may further increase those chances, but this\n * is not currently done.)\n * If each facet is included, we know that relaxing the constraints extends\n * the basic map with exactly the other basic map (we already know that this\n * other basic map is included in the extension, because all other\n * inequality constraints are valid of \"j\") and we can replace the\n * two basic maps by this extension.\n *\n * If any of the relaxed constraints turn out to be redundant, then bail out.\n * isl_tab_select_facet refuses to handle such constraints.  It may be\n * possible to handle them anyway by making a distinction between\n * redundant constraints with a corresponding facet that still intersects\n * the set (allowing isl_tab_select_facet to handle them) and\n * those where the facet does not intersect the set (which can be ignored\n * because the empty facet is trivially included in the other disjunct).\n * However, relaxed constraints that turn out to be redundant should\n * be fairly rare and no such instance has been reported where\n * coalescing would be successful.\n *        ____\t\t\t  _____\n *       /    || \t\t /     |\n *      /     ||  \t\t/      |\n *      \\     ||   \t=>\t\\      |\n *       \\    ||\t\t \\     |\n *        \\___||\t\t  \\____|\n *\n *\n *\t \\\t\t\t|\\\n *\t|\\\\\t\t\t| \\\n *\t| \\\\\t\t\t|  \\\n *\t|  |\t\t=>\t|  /\n *\t| /\t\t\t| /\n *\t|/\t\t\t|/\n */\nstatic enum isl_change is_relaxed_extension(int i, int j, int n, int *relax,\n\tstruct isl_coalesce_info *info)\n{\n\tint l;\n\tisl_bool super;\n\tstruct isl_tab_undo *snap, *snap2;\n\tunsigned n_eq = info[i].bmap->n_eq;\n\n\tfor (l = 0; l < n; ++l)\n\t\tif (isl_tab_is_equality(info[i].tab, n_eq + relax[l]))\n\t\t\treturn isl_change_none;\n\n\tsnap = isl_tab_snap(info[i].tab);\n\tfor (l = 0; l < n; ++l)\n\t\tif (isl_tab_relax(info[i].tab, n_eq + relax[l]) < 0)\n\t\t\treturn isl_change_error;\n\tfor (l = 0; l < n; ++l) {\n\t\tif (!isl_tab_is_redundant(info[i].tab, n_eq + relax[l]))\n\t\t\tcontinue;\n\t\tif (isl_tab_rollback(info[i].tab, snap) < 0)\n\t\t\treturn isl_change_error;\n\t\treturn isl_change_none;\n\t}\n\tsnap2 = isl_tab_snap(info[i].tab);\n\tfor (l = 0; l < n; ++l) {\n\t\tif (isl_tab_rollback(info[i].tab, snap2) < 0)\n\t\t\treturn isl_change_error;\n\t\tif (isl_tab_select_facet(info[i].tab, n_eq + relax[l]) < 0)\n\t\t\treturn isl_change_error;\n\t\tif (tighten_on_relaxed_facet(&info[i], n, relax, l) < 0)\n\t\t\treturn isl_change_error;\n\t\tsuper = contains(&info[j], info[i].tab);\n\t\tif (super < 0)\n\t\t\treturn isl_change_error;\n\t\tif (super)\n\t\t\tcontinue;\n\t\tif (isl_tab_rollback(info[i].tab, snap) < 0)\n\t\t\treturn isl_change_error;\n\t\treturn isl_change_none;\n\t}\n\n\tif (isl_tab_rollback(info[i].tab, snap2) < 0)\n\t\treturn isl_change_error;\n\treturn extend(i, j, n, relax, info);\n}\n\n/* Data structure that keeps track of the wrapping constraints\n * and of information to bound the coefficients of those constraints.\n *\n * \"failed\" is set if wrapping has failed.\n * bound is set if we want to apply a bound on the coefficients\n * mat contains the wrapping constraints\n * max is the bound on the coefficients (if bound is set)\n */\nstruct isl_wraps {\n\tint failed;\n\tint bound;\n\tisl_mat *mat;\n\tisl_int max;\n};\n\n/* Update wraps->max to be greater than or equal to the coefficients\n * in the equalities and inequalities of info->bmap that can be removed\n * if we end up applying wrapping.\n */\nstatic isl_stat wraps_update_max(struct isl_wraps *wraps,\n\tstruct isl_coalesce_info *info)\n{\n\tint k;\n\tisl_int max_k;\n\tisl_size total = isl_basic_map_dim(info->bmap, isl_dim_all);\n\n\tif (total < 0)\n\t\treturn isl_stat_error;\n\tisl_int_init(max_k);\n\n\tfor (k = 0; k < info->bmap->n_eq; ++k) {\n\t\tif (info->eq[2 * k] == STATUS_VALID &&\n\t\t    info->eq[2 * k + 1] == STATUS_VALID)\n\t\t\tcontinue;\n\t\tisl_seq_abs_max(info->bmap->eq[k] + 1, total, &max_k);\n\t\tif (isl_int_abs_gt(max_k, wraps->max))\n\t\t\tisl_int_set(wraps->max, max_k);\n\t}\n\n\tfor (k = 0; k < info->bmap->n_ineq; ++k) {\n\t\tif (info->ineq[k] == STATUS_VALID ||\n\t\t    info->ineq[k] == STATUS_REDUNDANT)\n\t\t\tcontinue;\n\t\tisl_seq_abs_max(info->bmap->ineq[k] + 1, total, &max_k);\n\t\tif (isl_int_abs_gt(max_k, wraps->max))\n\t\t\tisl_int_set(wraps->max, max_k);\n\t}\n\n\tisl_int_clear(max_k);\n\n\treturn isl_stat_ok;\n}\n\n/* Initialize the isl_wraps data structure.\n * If we want to bound the coefficients of the wrapping constraints,\n * we set wraps->max to the largest coefficient\n * in the equalities and inequalities that can be removed if we end up\n * applying wrapping.\n */\nstatic isl_stat wraps_init(struct isl_wraps *wraps, __isl_take isl_mat *mat,\n\tstruct isl_coalesce_info *info, int i, int j)\n{\n\tisl_ctx *ctx;\n\n\twraps->failed = 0;\n\twraps->bound = 0;\n\twraps->mat = mat;\n\tif (!mat)\n\t\treturn isl_stat_error;\n\twraps->mat->n_row = 0;\n\tctx = isl_mat_get_ctx(mat);\n\twraps->bound = isl_options_get_coalesce_bounded_wrapping(ctx);\n\tif (!wraps->bound)\n\t\treturn isl_stat_ok;\n\tisl_int_init(wraps->max);\n\tisl_int_set_si(wraps->max, 0);\n\tif (wraps_update_max(wraps, &info[i]) < 0)\n\t\treturn isl_stat_error;\n\tif (wraps_update_max(wraps, &info[j]) < 0)\n\t\treturn isl_stat_error;\n\n\treturn isl_stat_ok;\n}\n\n/* Free the contents of the isl_wraps data structure.\n */\nstatic void wraps_free(struct isl_wraps *wraps)\n{\n\tisl_mat_free(wraps->mat);\n\tif (wraps->bound)\n\t\tisl_int_clear(wraps->max);\n}\n\n/* Mark the wrapping as failed.\n */\nstatic isl_stat wraps_mark_failed(struct isl_wraps *wraps)\n{\n\twraps->failed = 1;\n\treturn isl_stat_ok;\n}\n\n/* Is the wrapping constraint in row \"row\" allowed?\n *\n * If wraps->bound is set, we check that none of the coefficients\n * is greater than wraps->max.\n */\nstatic int allow_wrap(struct isl_wraps *wraps, int row)\n{\n\tint i;\n\n\tif (!wraps->bound)\n\t\treturn 1;\n\n\tfor (i = 1; i < wraps->mat->n_col; ++i)\n\t\tif (isl_int_abs_gt(wraps->mat->row[row][i], wraps->max))\n\t\t\treturn 0;\n\n\treturn 1;\n}\n\n/* Wrap \"ineq\" (or its opposite if \"negate\" is set) around \"bound\"\n * to include \"set\" and add the result in position \"w\" of \"wraps\".\n * \"len\" is the total number of coefficients in \"bound\" and \"ineq\".\n * Return 1 on success, 0 on failure and -1 on error.\n * Wrapping can fail if the result of wrapping is equal to \"bound\"\n * or if we want to bound the sizes of the coefficients and\n * the wrapped constraint does not satisfy this bound.\n */\nstatic int add_wrap(struct isl_wraps *wraps, int w, isl_int *bound,\n\tisl_int *ineq, unsigned len, __isl_keep isl_set *set, int negate)\n{\n\tisl_seq_cpy(wraps->mat->row[w], bound, len);\n\tif (negate) {\n\t\tisl_seq_neg(wraps->mat->row[w + 1], ineq, len);\n\t\tineq = wraps->mat->row[w + 1];\n\t}\n\tif (!isl_set_wrap_facet(set, wraps->mat->row[w], ineq))\n\t\treturn -1;\n\tif (isl_seq_eq(wraps->mat->row[w], bound, len))\n\t\treturn 0;\n\tif (!allow_wrap(wraps, w))\n\t\treturn 0;\n\treturn 1;\n}\n\n/* This function has two modes of operations.\n *\n * If \"add_valid\" is set, then all the constraints of info->bmap\n * (except the opposite of \"bound\") are valid for the other basic map.\n * In this case, attempts are made to wrap some of these valid constraints\n * to more tightly fit around \"set\".  Only successful wrappings are recorded\n * and failed wrappings are ignored.\n *\n * If \"add_valid\" is not set, then some of the constraints of info->bmap\n * are not valid for the other basic map, and only those are considered\n * for wrapping.  In this case all attempted wrappings need to succeed.\n * Otherwise \"wraps\" is marked as failed.\n * Note that the constraints that are valid for the other basic map\n * will be added to the combined basic map by default, so there is\n * no need to wrap them.\n * The caller wrap_in_facets even relies on this function not wrapping\n * any constraints that are already valid.\n *\n * Only consider constraints that are not redundant (as determined\n * by info->tab) and that are valid or invalid depending on \"add_valid\".\n * Wrap each constraint around \"bound\" such that it includes the whole\n * set \"set\" and append the resulting constraint to \"wraps\".\n * \"wraps\" is assumed to have been pre-allocated to the appropriate size.\n * wraps->n_row is the number of actual wrapped constraints that have\n * been added.\n * If any of the wrapping problems results in a constraint that is\n * identical to \"bound\", then this means that \"set\" is unbounded in such\n * a way that no wrapping is possible.\n * Similarly, if we want to bound the coefficients of the wrapping\n * constraints and a newly added wrapping constraint does not\n * satisfy the bound, then the wrapping is considered to have failed.\n * Note though that \"wraps\" is only marked failed if \"add_valid\" is not set.\n */\nstatic isl_stat add_selected_wraps(struct isl_wraps *wraps,\n\tstruct isl_coalesce_info *info, isl_int *bound, __isl_keep isl_set *set,\n\tint add_valid)\n{\n\tint l, m;\n\tint w;\n\tint added;\n\tisl_basic_map *bmap = info->bmap;\n\tisl_size total = isl_basic_map_dim(bmap, isl_dim_all);\n\tunsigned len = 1 + total;\n\n\tif (total < 0)\n\t\treturn isl_stat_error;\n\n\tw = wraps->mat->n_row;\n\n\tfor (l = 0; l < bmap->n_ineq; ++l) {\n\t\tint is_valid = info->ineq[l] == STATUS_VALID;\n\t\tif ((!add_valid && is_valid) ||\n\t\t    info->ineq[l] == STATUS_REDUNDANT)\n\t\t\tcontinue;\n\t\tif (isl_seq_is_neg(bound, bmap->ineq[l], len))\n\t\t\tcontinue;\n\t\tif (isl_seq_eq(bound, bmap->ineq[l], len))\n\t\t\tcontinue;\n\t\tif (isl_tab_is_redundant(info->tab, bmap->n_eq + l))\n\t\t\tcontinue;\n\n\t\tadded = add_wrap(wraps, w, bound, bmap->ineq[l], len, set, 0);\n\t\tif (added < 0)\n\t\t\treturn isl_stat_error;\n\t\tif (!added && !is_valid)\n\t\t\tgoto unbounded;\n\t\tif (added)\n\t\t\t++w;\n\t}\n\tfor (l = 0; l < bmap->n_eq; ++l) {\n\t\tif (isl_seq_is_neg(bound, bmap->eq[l], len))\n\t\t\tcontinue;\n\t\tif (isl_seq_eq(bound, bmap->eq[l], len))\n\t\t\tcontinue;\n\n\t\tfor (m = 0; m < 2; ++m) {\n\t\t\tif (info->eq[2 * l + m] == STATUS_VALID)\n\t\t\t\tcontinue;\n\t\t\tadded = add_wrap(wraps, w, bound, bmap->eq[l], len,\n\t\t\t\t\tset, !m);\n\t\t\tif (added < 0)\n\t\t\t\treturn isl_stat_error;\n\t\t\tif (!added)\n\t\t\t\tgoto unbounded;\n\t\t\t++w;\n\t\t}\n\t}\n\n\twraps->mat->n_row = w;\n\treturn isl_stat_ok;\nunbounded:\n\treturn wraps_mark_failed(wraps);\n}\n\n/* For each constraint in info->bmap that is not redundant (as determined\n * by info->tab) and that is not a valid constraint for the other basic map,\n * wrap the constraint around \"bound\" such that it includes the whole\n * set \"set\" and append the resulting constraint to \"wraps\".\n * Note that the constraints that are valid for the other basic map\n * will be added to the combined basic map by default, so there is\n * no need to wrap them.\n * The caller wrap_in_facets even relies on this function not wrapping\n * any constraints that are already valid.\n * \"wraps\" is assumed to have been pre-allocated to the appropriate size.\n * wraps->n_row is the number of actual wrapped constraints that have\n * been added.\n * If any of the wrapping problems results in a constraint that is\n * identical to \"bound\", then this means that \"set\" is unbounded in such\n * a way that no wrapping is possible.  If this happens then \"wraps\"\n * is marked as failed.\n * Similarly, if we want to bound the coefficients of the wrapping\n * constraints and a newly added wrapping constraint does not\n * satisfy the bound, then \"wraps\" is also marked as failed.\n */\nstatic isl_stat add_wraps(struct isl_wraps *wraps,\n\tstruct isl_coalesce_info *info, isl_int *bound, __isl_keep isl_set *set)\n{\n\treturn add_selected_wraps(wraps, info, bound, set, 0);\n}\n\n/* Check if the constraints in \"wraps\" from \"first\" until the last\n * are all valid for the basic set represented by \"tab\",\n * dropping the invalid constraints if \"keep\" is set and\n * marking the wrapping as failed if \"keep\" is not set and\n * any constraint turns out to be invalid.\n */\nstatic isl_stat check_wraps(struct isl_wraps *wraps, int first,\n\tstruct isl_tab *tab, int keep)\n{\n\tint i;\n\n\tfor (i = wraps->mat->n_row - 1; i >= first; --i) {\n\t\tenum isl_ineq_type type;\n\t\ttype = isl_tab_ineq_type(tab, wraps->mat->row[i]);\n\t\tif (type == isl_ineq_error)\n\t\t\treturn isl_stat_error;\n\t\tif (type == isl_ineq_redundant)\n\t\t\tcontinue;\n\t\tif (!keep)\n\t\t\treturn wraps_mark_failed(wraps);\n\t\twraps->mat = isl_mat_drop_rows(wraps->mat, i, 1);\n\t\tif (!wraps->mat)\n\t\t\treturn isl_stat_error;\n\t}\n\n\treturn isl_stat_ok;\n}\n\n/* Return a set that corresponds to the non-redundant constraints\n * (as recorded in tab) of bmap.\n *\n * It's important to remove the redundant constraints as some\n * of the other constraints may have been modified after the\n * constraints were marked redundant.\n * In particular, a constraint may have been relaxed.\n * Redundant constraints are ignored when a constraint is relaxed\n * and should therefore continue to be ignored ever after.\n * Otherwise, the relaxation might be thwarted by some of\n * these constraints.\n *\n * Update the underlying set to ensure that the dimension doesn't change.\n * Otherwise the integer divisions could get dropped if the tab\n * turns out to be empty.\n */\nstatic __isl_give isl_set *set_from_updated_bmap(__isl_keep isl_basic_map *bmap,\n\tstruct isl_tab *tab)\n{\n\tisl_basic_set *bset;\n\n\tbmap = isl_basic_map_copy(bmap);\n\tbset = isl_basic_map_underlying_set(bmap);\n\tbset = isl_basic_set_cow(bset);\n\tbset = isl_basic_set_update_from_tab(bset, tab);\n\treturn isl_set_from_basic_set(bset);\n}\n\n/* Does \"info\" have any cut constraints that are redundant?\n */\nstatic isl_bool has_redundant_cuts(struct isl_coalesce_info *info)\n{\n\tint l;\n\tisl_size n_eq, n_ineq;\n\n\tn_eq = isl_basic_map_n_equality(info->bmap);\n\tn_ineq = isl_basic_map_n_inequality(info->bmap);\n\tif (n_eq < 0 || n_ineq < 0)\n\t\treturn isl_bool_error;\n\tfor (l = 0; l < n_ineq; ++l) {\n\t\tint red;\n\n\t\tif (info->ineq[l] != STATUS_CUT)\n\t\t\tcontinue;\n\t\tred = isl_tab_is_redundant(info->tab, n_eq + l);\n\t\tif (red < 0)\n\t\t\treturn isl_bool_error;\n\t\tif (red)\n\t\t\treturn isl_bool_true;\n\t}\n\n\treturn isl_bool_false;\n}\n\n/* Wrap some constraints of info->bmap that bound the facet defined\n * by inequality \"k\" around (the opposite of) this inequality to\n * include \"set\".  \"bound\" may be used to store the negated inequality.\n *\n * If \"add_valid\" is set, then all ridges are already valid and\n * the purpose is to wrap \"set\" more tightly.  In this case,\n * wrapping doesn't fail, although it is possible that no constraint\n * gets wrapped.\n *\n * If \"add_valid\" is not set, then some of the ridges are cut constraints\n * and only those are wrapped around \"set\".\n *\n * Since the wrapped constraints are not guaranteed to contain the whole\n * of info->bmap, we check them in check_wraps.\n * If any of the wrapped constraints turn out to be invalid, then\n * check_wraps will mark \"wraps\" as failed if \"add_valid\" is not set.\n * If \"add_valid\" is set, then the offending constraints are\n * simply removed.\n *\n * If any of the cut constraints of info->bmap turn out\n * to be redundant with respect to other constraints\n * then these will neither be wrapped nor added directly to the result.\n * The result may therefore not be correct.\n * Skip wrapping and mark \"wraps\" as failed in this case.\n */\nstatic isl_stat add_selected_wraps_around_facet(struct isl_wraps *wraps,\n\tstruct isl_coalesce_info *info, int k, isl_int *bound,\n\t__isl_keep isl_set *set, int add_valid)\n{\n\tisl_bool nowrap;\n\tstruct isl_tab_undo *snap;\n\tint n;\n\tisl_size total = isl_basic_map_dim(info->bmap, isl_dim_all);\n\n\tif (total < 0)\n\t\treturn isl_stat_error;\n\n\tsnap = isl_tab_snap(info->tab);\n\n\tif (isl_tab_select_facet(info->tab, info->bmap->n_eq + k) < 0)\n\t\treturn isl_stat_error;\n\tif (isl_tab_detect_redundant(info->tab) < 0)\n\t\treturn isl_stat_error;\n\tnowrap = has_redundant_cuts(info);\n\tif (nowrap < 0)\n\t\treturn isl_stat_error;\n\n\tn = wraps->mat->n_row;\n\tif (!nowrap) {\n\t\tisl_seq_neg(bound, info->bmap->ineq[k], 1 + total);\n\n\t\tif (add_selected_wraps(wraps, info, bound, set, add_valid) < 0)\n\t\t\treturn isl_stat_error;\n\t}\n\n\tif (isl_tab_rollback(info->tab, snap) < 0)\n\t\treturn isl_stat_error;\n\tif (nowrap)\n\t\treturn wraps_mark_failed(wraps);\n\tif (check_wraps(wraps, n, info->tab, add_valid) < 0)\n\t\treturn isl_stat_error;\n\n\treturn isl_stat_ok;\n}\n\n/* Wrap the constraints of info->bmap that bound the facet defined\n * by inequality \"k\" around (the opposite of) this inequality to\n * include \"set\".  \"bound\" may be used to store the negated inequality.\n * If any of the wrapped constraints turn out to be invalid for info->bmap\n * itself, then mark \"wraps\" as failed.\n */\nstatic isl_stat add_wraps_around_facet(struct isl_wraps *wraps,\n\tstruct isl_coalesce_info *info, int k, isl_int *bound,\n\t__isl_keep isl_set *set)\n{\n\treturn add_selected_wraps_around_facet(wraps, info, k, bound, set, 0);\n}\n\n/* Wrap the (valid) constraints of info->bmap that bound the facet defined\n * by inequality \"k\" around (the opposite of) this inequality to\n * include \"set\" more tightly.\n * \"bound\" may be used to store the negated inequality.\n * Remove any wrapping constraints that turn out to be invalid\n * for info->bmap itself.\n */\nstatic isl_stat add_valid_wraps_around_facet(struct isl_wraps *wraps,\n\tstruct isl_coalesce_info *info, int k, isl_int *bound,\n\t__isl_keep isl_set *set)\n{\n\treturn add_selected_wraps_around_facet(wraps, info, k, bound, set, 1);\n}\n\n/* Basic map \"i\" has an inequality (say \"k\") that is adjacent\n * to some inequality of basic map \"j\".  All the other inequalities\n * are valid for \"j\".\n * Check if basic map \"j\" forms an extension of basic map \"i\".\n *\n * Note that this function is only called if some of the equalities or\n * inequalities of basic map \"j\" do cut basic map \"i\".  The function is\n * correct even if there are no such cut constraints, but in that case\n * the additional checks performed by this function are overkill.\n *\n * First try and wrap the ridges of \"k\" around \"j\".\n * Note that those ridges are already valid for \"j\",\n * but the wrapped versions may wrap \"j\" more tightly,\n * increasing the chances of \"j\" being detected as an extension of \"i\"\n */\nstatic enum isl_change is_adj_ineq_extension(int i, int j,\n\tstruct isl_coalesce_info *info)\n{\n\tint k;\n\tenum isl_change change;\n\tisl_size total;\n\tisl_size n_eq_i, n_ineq_i;\n\tstruct isl_wraps wraps;\n\tisl_ctx *ctx;\n\tisl_mat *mat;\n\tisl_vec *bound;\n\tisl_set *set_j;\n\tisl_stat r;\n\n\tk = find_ineq(&info[i], STATUS_ADJ_INEQ);\n\tif (k < 0)\n\t\tisl_die(isl_basic_map_get_ctx(info[i].bmap), isl_error_internal,\n\t\t\t\"info[i].ineq should have exactly one STATUS_ADJ_INEQ\",\n\t\t\treturn isl_change_error);\n\n\ttotal = isl_basic_map_dim(info[i].bmap, isl_dim_all);\n\tn_eq_i = isl_basic_map_n_equality(info[i].bmap);\n\tn_ineq_i = isl_basic_map_n_inequality(info[i].bmap);\n\tif (total < 0 || n_eq_i < 0 || n_ineq_i < 0)\n\t\treturn isl_change_error;\n\n\tset_j = set_from_updated_bmap(info[j].bmap, info[j].tab);\n\tctx = isl_basic_map_get_ctx(info[i].bmap);\n\tbound = isl_vec_alloc(ctx, 1 + total);\n\tmat = isl_mat_alloc(ctx, 2 * n_eq_i + n_ineq_i, 1 + total);\n\tif (wraps_init(&wraps, mat, info, i, j) < 0)\n\t\tgoto error;\n\tif (!bound || !set_j)\n\t\tgoto error;\n\tr = add_valid_wraps_around_facet(&wraps, &info[i], k, bound->el, set_j);\n\tif (r < 0)\n\t\tgoto error;\n\n\tchange = is_adj_ineq_extension_with_wraps(i, j, k, info, wraps.mat);\n\n\twraps_free(&wraps);\n\tisl_vec_free(bound);\n\tisl_set_free(set_j);\n\n\treturn change;\nerror:\n\twraps_free(&wraps);\n\tisl_vec_free(bound);\n\tisl_set_free(set_j);\n\treturn isl_change_error;\n}\n\n/* Both basic maps have at least one inequality with and adjacent\n * (but opposite) inequality in the other basic map.\n * Check that there are no cut constraints and that there is only\n * a single pair of adjacent inequalities.\n * If so, we can replace the pair by a single basic map described\n * by all but the pair of adjacent inequalities.\n * Any additional points introduced lie strictly between the two\n * adjacent hyperplanes and can therefore be integral.\n *\n *        ____\t\t\t  _____\n *       /    ||\\\t\t /     \\\n *      /     || \\\t\t/       \\\n *      \\     ||  \\\t=>\t\\        \\\n *       \\    ||  /\t\t \\       /\n *        \\___||_/\t\t  \\_____/\n *\n * The test for a single pair of adjacent inequalities is important\n * for avoiding the combination of two basic maps like the following\n *\n *       /|\n *      / |\n *     /__|\n *         _____\n *         |   |\n *         |   |\n *         |___|\n *\n * If there are some cut constraints on one side, then we may\n * still be able to fuse the two basic maps, but we need to perform\n * some additional checks in is_adj_ineq_extension.\n */\nstatic enum isl_change check_adj_ineq(int i, int j,\n\tstruct isl_coalesce_info *info)\n{\n\tint count_i, count_j;\n\tint cut_i, cut_j;\n\n\tcount_i = count_ineq(&info[i], STATUS_ADJ_INEQ);\n\tcount_j = count_ineq(&info[j], STATUS_ADJ_INEQ);\n\n\tif (count_i != 1 && count_j != 1)\n\t\treturn isl_change_none;\n\n\tcut_i = any_eq(&info[i], STATUS_CUT) || any_ineq(&info[i], STATUS_CUT);\n\tcut_j = any_eq(&info[j], STATUS_CUT) || any_ineq(&info[j], STATUS_CUT);\n\n\tif (!cut_i && !cut_j && count_i == 1 && count_j == 1)\n\t\treturn fuse(i, j, info, NULL, 0, 0);\n\n\tif (count_i == 1 && !cut_i)\n\t\treturn is_adj_ineq_extension(i, j, info);\n\n\tif (count_j == 1 && !cut_j)\n\t\treturn is_adj_ineq_extension(j, i, info);\n\n\treturn isl_change_none;\n}\n\n/* Given a basic set i with a constraint k that is adjacent to\n * basic set j, check if we can wrap\n * both the facet corresponding to k (if \"wrap_facet\" is set) and basic map j\n * (always) around their ridges to include the other set.\n * If so, replace the pair of basic sets by their union.\n *\n * All constraints of i (except k) are assumed to be valid or\n * cut constraints for j.\n * Wrapping the cut constraints to include basic map j may result\n * in constraints that are no longer valid of basic map i\n * we have to check that the resulting wrapping constraints are valid for i.\n * If \"wrap_facet\" is not set, then all constraints of i (except k)\n * are assumed to be valid for j.\n *        ____\t\t\t  _____\n *       /    | \t\t /     \\\n *      /     ||  \t\t/      |\n *      \\     ||   \t=>\t\\      |\n *       \\    ||\t\t \\     |\n *        \\___||\t\t  \\____|\n *\n */\nstatic enum isl_change can_wrap_in_facet(int i, int j, int k,\n\tstruct isl_coalesce_info *info, int wrap_facet)\n{\n\tenum isl_change change = isl_change_none;\n\tstruct isl_wraps wraps;\n\tisl_ctx *ctx;\n\tisl_mat *mat;\n\tstruct isl_set *set_i = NULL;\n\tstruct isl_set *set_j = NULL;\n\tstruct isl_vec *bound = NULL;\n\tisl_size total = isl_basic_map_dim(info[i].bmap, isl_dim_all);\n\n\tif (total < 0)\n\t\treturn isl_change_error;\n\tset_i = set_from_updated_bmap(info[i].bmap, info[i].tab);\n\tset_j = set_from_updated_bmap(info[j].bmap, info[j].tab);\n\tctx = isl_basic_map_get_ctx(info[i].bmap);\n\tmat = isl_mat_alloc(ctx, 2 * (info[i].bmap->n_eq + info[j].bmap->n_eq) +\n\t\t\t\t    info[i].bmap->n_ineq + info[j].bmap->n_ineq,\n\t\t\t\t    1 + total);\n\tif (wraps_init(&wraps, mat, info, i, j) < 0)\n\t\tgoto error;\n\tbound = isl_vec_alloc(ctx, 1 + total);\n\tif (!set_i || !set_j || !bound)\n\t\tgoto error;\n\n\tisl_seq_cpy(bound->el, info[i].bmap->ineq[k], 1 + total);\n\tisl_int_add_ui(bound->el[0], bound->el[0], 1);\n\tisl_seq_normalize(ctx, bound->el, 1 + total);\n\n\tisl_seq_cpy(wraps.mat->row[0], bound->el, 1 + total);\n\twraps.mat->n_row = 1;\n\n\tif (add_wraps(&wraps, &info[j], bound->el, set_i) < 0)\n\t\tgoto error;\n\tif (wraps.failed)\n\t\tgoto unbounded;\n\n\tif (wrap_facet) {\n\t\tif (add_wraps_around_facet(&wraps, &info[i], k,\n\t\t\t\t\t    bound->el, set_j) < 0)\n\t\t\tgoto error;\n\t\tif (wraps.failed)\n\t\t\tgoto unbounded;\n\t}\n\n\tchange = fuse(i, j, info, wraps.mat, 0, 0);\n\nunbounded:\n\twraps_free(&wraps);\n\n\tisl_set_free(set_i);\n\tisl_set_free(set_j);\n\n\tisl_vec_free(bound);\n\n\treturn change;\nerror:\n\twraps_free(&wraps);\n\tisl_vec_free(bound);\n\tisl_set_free(set_i);\n\tisl_set_free(set_j);\n\treturn isl_change_error;\n}\n\n/* Given a cut constraint t(x) >= 0 of basic map i, stored in row \"w\"\n * of wrap.mat, replace it by its relaxed version t(x) + 1 >= 0, and\n * add wrapping constraints to wrap.mat for all constraints\n * of basic map j that bound the part of basic map j that sticks out\n * of the cut constraint.\n * \"set_i\" is the underlying set of basic map i.\n * If any wrapping fails, then wraps->mat.n_row is reset to zero.\n *\n * In particular, we first intersect basic map j with t(x) + 1 = 0.\n * If the result is empty, then t(x) >= 0 was actually a valid constraint\n * (with respect to the integer points), so we add t(x) >= 0 instead.\n * Otherwise, we wrap the constraints of basic map j that are not\n * redundant in this intersection and that are not already valid\n * for basic map i over basic map i.\n * Note that it is sufficient to wrap the constraints to include\n * basic map i, because we will only wrap the constraints that do\n * not include basic map i already.  The wrapped constraint will\n * therefore be more relaxed compared to the original constraint.\n * Since the original constraint is valid for basic map j, so is\n * the wrapped constraint.\n */\nstatic isl_stat wrap_in_facet(struct isl_wraps *wraps, int w,\n\tstruct isl_coalesce_info *info_j, __isl_keep isl_set *set_i,\n\tstruct isl_tab_undo *snap)\n{\n\tisl_int_add_ui(wraps->mat->row[w][0], wraps->mat->row[w][0], 1);\n\tif (isl_tab_add_eq(info_j->tab, wraps->mat->row[w]) < 0)\n\t\treturn isl_stat_error;\n\tif (isl_tab_detect_redundant(info_j->tab) < 0)\n\t\treturn isl_stat_error;\n\n\tif (info_j->tab->empty)\n\t\tisl_int_sub_ui(wraps->mat->row[w][0], wraps->mat->row[w][0], 1);\n\telse if (add_wraps(wraps, info_j, wraps->mat->row[w], set_i) < 0)\n\t\treturn isl_stat_error;\n\n\tif (isl_tab_rollback(info_j->tab, snap) < 0)\n\t\treturn isl_stat_error;\n\n\treturn isl_stat_ok;\n}\n\n/* Given a pair of basic maps i and j such that j sticks out\n * of i at n cut constraints, each time by at most one,\n * try to compute wrapping constraints and replace the two\n * basic maps by a single basic map.\n * The other constraints of i are assumed to be valid for j.\n * \"set_i\" is the underlying set of basic map i.\n * \"wraps\" has been initialized to be of the right size.\n *\n * For each cut constraint t(x) >= 0 of i, we add the relaxed version\n * t(x) + 1 >= 0, along with wrapping constraints for all constraints\n * of basic map j that bound the part of basic map j that sticks out\n * of the cut constraint.\n *\n * If any wrapping fails, i.e., if we cannot wrap to touch\n * the union, then we give up.\n * Otherwise, the pair of basic maps is replaced by their union.\n */\nstatic enum isl_change try_wrap_in_facets(int i, int j,\n\tstruct isl_coalesce_info *info, struct isl_wraps *wraps,\n\t__isl_keep isl_set *set_i)\n{\n\tint k, l, w;\n\tisl_size total;\n\tstruct isl_tab_undo *snap;\n\n\ttotal = isl_basic_map_dim(info[i].bmap, isl_dim_all);\n\tif (total < 0)\n\t\treturn isl_change_error;\n\n\tsnap = isl_tab_snap(info[j].tab);\n\n\tfor (k = 0; k < info[i].bmap->n_eq; ++k) {\n\t\tfor (l = 0; l < 2; ++l) {\n\t\t\tif (info[i].eq[2 * k + l] != STATUS_CUT)\n\t\t\t\tcontinue;\n\t\t\tw = wraps->mat->n_row++;\n\t\t\tif (l == 0)\n\t\t\t\tisl_seq_neg(wraps->mat->row[w],\n\t\t\t\t\t    info[i].bmap->eq[k], 1 + total);\n\t\t\telse\n\t\t\t\tisl_seq_cpy(wraps->mat->row[w],\n\t\t\t\t\t    info[i].bmap->eq[k], 1 + total);\n\t\t\tif (wrap_in_facet(wraps, w, &info[j], set_i, snap) < 0)\n\t\t\t\treturn isl_change_error;\n\n\t\t\tif (wraps->failed)\n\t\t\t\treturn isl_change_none;\n\t\t}\n\t}\n\n\tfor (k = 0; k < info[i].bmap->n_ineq; ++k) {\n\t\tif (info[i].ineq[k] != STATUS_CUT)\n\t\t\tcontinue;\n\t\tw = wraps->mat->n_row++;\n\t\tisl_seq_cpy(wraps->mat->row[w],\n\t\t\t    info[i].bmap->ineq[k], 1 + total);\n\t\tif (wrap_in_facet(wraps, w, &info[j], set_i, snap) < 0)\n\t\t\treturn isl_change_error;\n\n\t\tif (wraps->failed)\n\t\t\treturn isl_change_none;\n\t}\n\n\treturn fuse(i, j, info, wraps->mat, 0, 1);\n}\n\n/* Given a pair of basic maps i and j such that j sticks out\n * of i at n cut constraints, each time by at most one,\n * try to compute wrapping constraints and replace the two\n * basic maps by a single basic map.\n * The other constraints of i are assumed to be valid for j.\n *\n * The core computation is performed by try_wrap_in_facets.\n * This function simply extracts an underlying set representation\n * of basic map i and initializes the data structure for keeping\n * track of wrapping constraints.\n */\nstatic enum isl_change wrap_in_facets(int i, int j, int n,\n\tstruct isl_coalesce_info *info)\n{\n\tenum isl_change change = isl_change_none;\n\tstruct isl_wraps wraps;\n\tisl_ctx *ctx;\n\tisl_mat *mat;\n\tisl_set *set_i = NULL;\n\tisl_size total = isl_basic_map_dim(info[i].bmap, isl_dim_all);\n\tint max_wrap;\n\n\tif (total < 0)\n\t\treturn isl_change_error;\n\tif (isl_tab_extend_cons(info[j].tab, 1) < 0)\n\t\treturn isl_change_error;\n\n\tmax_wrap = 1 + 2 * info[j].bmap->n_eq + info[j].bmap->n_ineq;\n\tmax_wrap *= n;\n\n\tset_i = set_from_updated_bmap(info[i].bmap, info[i].tab);\n\tctx = isl_basic_map_get_ctx(info[i].bmap);\n\tmat = isl_mat_alloc(ctx, max_wrap, 1 + total);\n\tif (wraps_init(&wraps, mat, info, i, j) < 0)\n\t\tgoto error;\n\tif (!set_i)\n\t\tgoto error;\n\n\tchange = try_wrap_in_facets(i, j, info, &wraps, set_i);\n\n\twraps_free(&wraps);\n\tisl_set_free(set_i);\n\n\treturn change;\nerror:\n\twraps_free(&wraps);\n\tisl_set_free(set_i);\n\treturn isl_change_error;\n}\n\n/* Return the effect of inequality \"ineq\" on the tableau \"tab\",\n * after relaxing the constant term of \"ineq\" by one.\n */\nstatic enum isl_ineq_type type_of_relaxed(struct isl_tab *tab, isl_int *ineq)\n{\n\tenum isl_ineq_type type;\n\n\tisl_int_add_ui(ineq[0], ineq[0], 1);\n\ttype = isl_tab_ineq_type(tab, ineq);\n\tisl_int_sub_ui(ineq[0], ineq[0], 1);\n\n\treturn type;\n}\n\n/* Given two basic sets i and j,\n * check if relaxing all the cut constraints of i by one turns\n * them into valid constraint for j and check if we can wrap in\n * the bits that are sticking out.\n * If so, replace the pair by their union.\n *\n * We first check if all relaxed cut inequalities of i are valid for j\n * and then try to wrap in the intersections of the relaxed cut inequalities\n * with j.\n *\n * During this wrapping, we consider the points of j that lie at a distance\n * of exactly 1 from i.  In particular, we ignore the points that lie in\n * between this lower-dimensional space and the basic map i.\n * We can therefore only apply this to integer maps.\n *        ____\t\t\t  _____\n *       / ___|_\t\t /     \\\n *      / |    |  \t\t/      |\n *      \\ |    |   \t=>\t\\      |\n *       \\|____|\t\t \\     |\n *        \\___| \t\t  \\____/\n *\n *\t _____\t\t\t ______\n *\t| ____|_\t\t|      \\\n *\t| |     |\t\t|       |\n *\t| |\t|\t=>\t|       |\n *\t|_|     |\t\t|       |\n *\t  |_____|\t\t \\______|\n *\n *\t _______\n *\t|       |\n *\t|  |\\   |\n *\t|  | \\  |\n *\t|  |  \\ |\n *\t|  |   \\|\n *\t|  |    \\\n *\t|  |_____\\\n *\t|       |\n *\t|_______|\n *\n * Wrapping can fail if the result of wrapping one of the facets\n * around its edges does not produce any new facet constraint.\n * In particular, this happens when we try to wrap in unbounded sets.\n *\n *\t _______________________________________________________________________\n *\t|\n *\t|  ___\n *\t| |   |\n *\t|_|   |_________________________________________________________________\n *\t  |___|\n *\n * The following is not an acceptable result of coalescing the above two\n * sets as it includes extra integer points.\n *\t _______________________________________________________________________\n *\t|\n *\t|     \n *\t|      \n *\t|\n *\t \\______________________________________________________________________\n */\nstatic enum isl_change can_wrap_in_set(int i, int j,\n\tstruct isl_coalesce_info *info)\n{\n\tint k, l;\n\tint n;\n\tisl_size total;\n\n\tif (ISL_F_ISSET(info[i].bmap, ISL_BASIC_MAP_RATIONAL) ||\n\t    ISL_F_ISSET(info[j].bmap, ISL_BASIC_MAP_RATIONAL))\n\t\treturn isl_change_none;\n\n\tn = count_eq(&info[i], STATUS_CUT) + count_ineq(&info[i], STATUS_CUT);\n\tif (n == 0)\n\t\treturn isl_change_none;\n\n\ttotal = isl_basic_map_dim(info[i].bmap, isl_dim_all);\n\tif (total < 0)\n\t\treturn isl_change_error;\n\tfor (k = 0; k < info[i].bmap->n_eq; ++k) {\n\t\tfor (l = 0; l < 2; ++l) {\n\t\t\tenum isl_ineq_type type;\n\n\t\t\tif (info[i].eq[2 * k + l] != STATUS_CUT)\n\t\t\t\tcontinue;\n\n\t\t\tif (l == 0)\n\t\t\t\tisl_seq_neg(info[i].bmap->eq[k],\n\t\t\t\t\t    info[i].bmap->eq[k], 1 + total);\n\t\t\ttype = type_of_relaxed(info[j].tab,\n\t\t\t\t\t    info[i].bmap->eq[k]);\n\t\t\tif (l == 0)\n\t\t\t\tisl_seq_neg(info[i].bmap->eq[k],\n\t\t\t\t\t    info[i].bmap->eq[k], 1 + total);\n\t\t\tif (type == isl_ineq_error)\n\t\t\t\treturn isl_change_error;\n\t\t\tif (type != isl_ineq_redundant)\n\t\t\t\treturn isl_change_none;\n\t\t}\n\t}\n\n\tfor (k = 0; k < info[i].bmap->n_ineq; ++k) {\n\t\tenum isl_ineq_type type;\n\n\t\tif (info[i].ineq[k] != STATUS_CUT)\n\t\t\tcontinue;\n\n\t\ttype = type_of_relaxed(info[j].tab, info[i].bmap->ineq[k]);\n\t\tif (type == isl_ineq_error)\n\t\t\treturn isl_change_error;\n\t\tif (type != isl_ineq_redundant)\n\t\t\treturn isl_change_none;\n\t}\n\n\treturn wrap_in_facets(i, j, n, info);\n}\n\n/* Check if either i or j has only cut constraints that can\n * be used to wrap in (a facet of) the other basic set.\n * if so, replace the pair by their union.\n */\nstatic enum isl_change check_wrap(int i, int j, struct isl_coalesce_info *info)\n{\n\tenum isl_change change = isl_change_none;\n\n\tchange = can_wrap_in_set(i, j, info);\n\tif (change != isl_change_none)\n\t\treturn change;\n\n\tchange = can_wrap_in_set(j, i, info);\n\treturn change;\n}\n\n/* Check if all inequality constraints of \"i\" that cut \"j\" cease\n * to be cut constraints if they are relaxed by one.\n * If so, collect the cut constraints in \"list\".\n * The caller is responsible for allocating \"list\".\n */\nstatic isl_bool all_cut_by_one(int i, int j, struct isl_coalesce_info *info,\n\tint *list)\n{\n\tint l, n;\n\n\tn = 0;\n\tfor (l = 0; l < info[i].bmap->n_ineq; ++l) {\n\t\tenum isl_ineq_type type;\n\n\t\tif (info[i].ineq[l] != STATUS_CUT)\n\t\t\tcontinue;\n\t\ttype = type_of_relaxed(info[j].tab, info[i].bmap->ineq[l]);\n\t\tif (type == isl_ineq_error)\n\t\t\treturn isl_bool_error;\n\t\tif (type != isl_ineq_redundant)\n\t\t\treturn isl_bool_false;\n\t\tlist[n++] = l;\n\t}\n\n\treturn isl_bool_true;\n}\n\n/* Given two basic maps such that \"j\" has at least one equality constraint\n * that is adjacent to an inequality constraint of \"i\" and such that \"i\" has\n * exactly one inequality constraint that is adjacent to an equality\n * constraint of \"j\", check whether \"i\" can be extended to include \"j\" or\n * whether \"j\" can be wrapped into \"i\".\n * All remaining constraints of \"i\" and \"j\" are assumed to be valid\n * or cut constraints of the other basic map.\n * However, none of the equality constraints of \"i\" are cut constraints.\n *\n * If \"i\" has any \"cut\" inequality constraints, then check if relaxing\n * each of them by one is sufficient for them to become valid.\n * If so, check if the inequality constraint adjacent to an equality\n * constraint of \"j\" along with all these cut constraints\n * can be relaxed by one to contain exactly \"j\".\n * Otherwise, or if this fails, check if \"j\" can be wrapped into \"i\".\n */\nstatic enum isl_change check_single_adj_eq(int i, int j,\n\tstruct isl_coalesce_info *info)\n{\n\tenum isl_change change = isl_change_none;\n\tint k;\n\tint n_cut;\n\tint *relax;\n\tisl_ctx *ctx;\n\tisl_bool try_relax;\n\n\tn_cut = count_ineq(&info[i], STATUS_CUT);\n\n\tk = find_ineq(&info[i], STATUS_ADJ_EQ);\n\n\tif (n_cut > 0) {\n\t\tctx = isl_basic_map_get_ctx(info[i].bmap);\n\t\trelax = isl_calloc_array(ctx, int, 1 + n_cut);\n\t\tif (!relax)\n\t\t\treturn isl_change_error;\n\t\trelax[0] = k;\n\t\ttry_relax = all_cut_by_one(i, j, info, relax + 1);\n\t\tif (try_relax < 0)\n\t\t\tchange = isl_change_error;\n\t} else {\n\t\ttry_relax = isl_bool_true;\n\t\trelax = &k;\n\t}\n\tif (try_relax && change == isl_change_none)\n\t\tchange = is_relaxed_extension(i, j, 1 + n_cut, relax, info);\n\tif (n_cut > 0)\n\t\tfree(relax);\n\tif (change != isl_change_none)\n\t\treturn change;\n\n\tchange = can_wrap_in_facet(i, j, k, info, n_cut > 0);\n\n\treturn change;\n}\n\n/* At least one of the basic maps has an equality that is adjacent\n * to an inequality.  Make sure that only one of the basic maps has\n * such an equality and that the other basic map has exactly one\n * inequality adjacent to an equality.\n * If the other basic map does not have such an inequality, then\n * check if all its constraints are either valid or cut constraints\n * and, if so, try wrapping in the first map into the second.\n * Otherwise, try to extend one basic map with the other or\n * wrap one basic map in the other.\n */\nstatic enum isl_change check_adj_eq(int i, int j,\n\tstruct isl_coalesce_info *info)\n{\n\tif (any_eq(&info[i], STATUS_ADJ_INEQ) &&\n\t    any_eq(&info[j], STATUS_ADJ_INEQ))\n\t\t/* ADJ EQ TOO MANY */\n\t\treturn isl_change_none;\n\n\tif (any_eq(&info[i], STATUS_ADJ_INEQ))\n\t\treturn check_adj_eq(j, i, info);\n\n\t/* j has an equality adjacent to an inequality in i */\n\n\tif (count_ineq(&info[i], STATUS_ADJ_EQ) != 1) {\n\t\tif (all_valid_or_cut(&info[i]))\n\t\t\treturn can_wrap_in_set(i, j, info);\n\t\treturn isl_change_none;\n\t}\n\tif (any_eq(&info[i], STATUS_CUT))\n\t\treturn isl_change_none;\n\tif (any_ineq(&info[j], STATUS_ADJ_EQ) ||\n\t    any_ineq(&info[i], STATUS_ADJ_INEQ) ||\n\t    any_ineq(&info[j], STATUS_ADJ_INEQ))\n\t\t/* ADJ EQ TOO MANY */\n\t\treturn isl_change_none;\n\n\treturn check_single_adj_eq(i, j, info);\n}\n\n/* Disjunct \"j\" lies on a hyperplane that is adjacent to disjunct \"i\".\n * In particular, disjunct \"i\" has an inequality constraint that is adjacent\n * to a (combination of) equality constraint(s) of disjunct \"j\",\n * but disjunct \"j\" has no explicit equality constraint adjacent\n * to an inequality constraint of disjunct \"i\".\n *\n * Disjunct \"i\" is already known not to have any equality constraints\n * that are adjacent to an equality or inequality constraint.\n * Check that, other than the inequality constraint mentioned above,\n * all other constraints of disjunct \"i\" are valid for disjunct \"j\".\n * If so, try and wrap in disjunct \"j\".\n */\nstatic enum isl_change check_ineq_adj_eq(int i, int j,\n\tstruct isl_coalesce_info *info)\n{\n\tint k;\n\n\tif (any_eq(&info[i], STATUS_CUT))\n\t\treturn isl_change_none;\n\tif (any_ineq(&info[i], STATUS_CUT))\n\t\treturn isl_change_none;\n\tif (any_ineq(&info[i], STATUS_ADJ_INEQ))\n\t\treturn isl_change_none;\n\tif (count_ineq(&info[i], STATUS_ADJ_EQ) != 1)\n\t\treturn isl_change_none;\n\n\tk = find_ineq(&info[i], STATUS_ADJ_EQ);\n\n\treturn can_wrap_in_facet(i, j, k, info, 0);\n}\n\n/* The two basic maps lie on adjacent hyperplanes.  In particular,\n * basic map \"i\" has an equality that lies parallel to basic map \"j\".\n * Check if we can wrap the facets around the parallel hyperplanes\n * to include the other set.\n *\n * We perform basically the same operations as can_wrap_in_facet,\n * except that we don't need to select a facet of one of the sets.\n *\t\t\t\t_\n *\t\\\\\t\t\t\\\\\n *\t \\\\\t\t=>\t \\\\\n *\t  \\\t\t\t  \\|\n *\n * If there is more than one equality of \"i\" adjacent to an equality of \"j\",\n * then the result will satisfy one or more equalities that are a linear\n * combination of these equalities.  These will be encoded as pairs\n * of inequalities in the wrapping constraints and need to be made\n * explicit.\n */\nstatic enum isl_change check_eq_adj_eq(int i, int j,\n\tstruct isl_coalesce_info *info)\n{\n\tint k;\n\tenum isl_change change = isl_change_none;\n\tint detect_equalities = 0;\n\tstruct isl_wraps wraps;\n\tisl_ctx *ctx;\n\tisl_mat *mat;\n\tstruct isl_set *set_i = NULL;\n\tstruct isl_set *set_j = NULL;\n\tstruct isl_vec *bound = NULL;\n\tisl_size total = isl_basic_map_dim(info[i].bmap, isl_dim_all);\n\n\tif (total < 0)\n\t\treturn isl_change_error;\n\tif (count_eq(&info[i], STATUS_ADJ_EQ) != 1)\n\t\tdetect_equalities = 1;\n\n\tk = find_eq(&info[i], STATUS_ADJ_EQ);\n\n\tset_i = set_from_updated_bmap(info[i].bmap, info[i].tab);\n\tset_j = set_from_updated_bmap(info[j].bmap, info[j].tab);\n\tctx = isl_basic_map_get_ctx(info[i].bmap);\n\tmat = isl_mat_alloc(ctx, 2 * (info[i].bmap->n_eq + info[j].bmap->n_eq) +\n\t\t\t\t    info[i].bmap->n_ineq + info[j].bmap->n_ineq,\n\t\t\t\t    1 + total);\n\tif (wraps_init(&wraps, mat, info, i, j) < 0)\n\t\tgoto error;\n\tbound = isl_vec_alloc(ctx, 1 + total);\n\tif (!set_i || !set_j || !bound)\n\t\tgoto error;\n\n\tif (k % 2 == 0)\n\t\tisl_seq_neg(bound->el, info[i].bmap->eq[k / 2], 1 + total);\n\telse\n\t\tisl_seq_cpy(bound->el, info[i].bmap->eq[k / 2], 1 + total);\n\tisl_int_add_ui(bound->el[0], bound->el[0], 1);\n\n\tisl_seq_cpy(wraps.mat->row[0], bound->el, 1 + total);\n\twraps.mat->n_row = 1;\n\n\tif (add_wraps(&wraps, &info[j], bound->el, set_i) < 0)\n\t\tgoto error;\n\tif (wraps.failed)\n\t\tgoto unbounded;\n\n\tisl_int_sub_ui(bound->el[0], bound->el[0], 1);\n\tisl_seq_neg(bound->el, bound->el, 1 + total);\n\n\tisl_seq_cpy(wraps.mat->row[wraps.mat->n_row], bound->el, 1 + total);\n\twraps.mat->n_row++;\n\n\tif (add_wraps(&wraps, &info[i], bound->el, set_j) < 0)\n\t\tgoto error;\n\tif (wraps.failed)\n\t\tgoto unbounded;\n\n\tchange = fuse(i, j, info, wraps.mat, detect_equalities, 0);\n\n\tif (0) {\nerror:\t\tchange = isl_change_error;\n\t}\nunbounded:\n\n\twraps_free(&wraps);\n\tisl_set_free(set_i);\n\tisl_set_free(set_j);\n\tisl_vec_free(bound);\n\n\treturn change;\n}\n\n/* Initialize the \"eq\" and \"ineq\" fields of \"info\".\n */\nstatic void init_status(struct isl_coalesce_info *info)\n{\n\tinfo->eq = info->ineq = NULL;\n}\n\n/* Set info->eq to the positions of the equalities of info->bmap\n * with respect to the basic map represented by \"tab\".\n * If info->eq has already been computed, then do not compute it again.\n */\nstatic void set_eq_status_in(struct isl_coalesce_info *info,\n\tstruct isl_tab *tab)\n{\n\tif (info->eq)\n\t\treturn;\n\tinfo->eq = eq_status_in(info->bmap, tab);\n}\n\n/* Set info->ineq to the positions of the inequalities of info->bmap\n * with respect to the basic map represented by \"tab\".\n * If info->ineq has already been computed, then do not compute it again.\n */\nstatic void set_ineq_status_in(struct isl_coalesce_info *info,\n\tstruct isl_tab *tab)\n{\n\tif (info->ineq)\n\t\treturn;\n\tinfo->ineq = ineq_status_in(info->bmap, info->tab, tab);\n}\n\n/* Free the memory allocated by the \"eq\" and \"ineq\" fields of \"info\".\n * This function assumes that init_status has been called on \"info\" first,\n * after which the \"eq\" and \"ineq\" fields may or may not have been\n * assigned a newly allocated array.\n */\nstatic void clear_status(struct isl_coalesce_info *info)\n{\n\tfree(info->eq);\n\tfree(info->ineq);\n}\n\n/* Are all inequality constraints of the basic map represented by \"info\"\n * valid for the other basic map, except for a single constraint\n * that is adjacent to an inequality constraint of the other basic map?\n */\nstatic int all_ineq_valid_or_single_adj_ineq(struct isl_coalesce_info *info)\n{\n\tint i;\n\tint k = -1;\n\n\tfor (i = 0; i < info->bmap->n_ineq; ++i) {\n\t\tif (info->ineq[i] == STATUS_REDUNDANT)\n\t\t\tcontinue;\n\t\tif (info->ineq[i] == STATUS_VALID)\n\t\t\tcontinue;\n\t\tif (info->ineq[i] != STATUS_ADJ_INEQ)\n\t\t\treturn 0;\n\t\tif (k != -1)\n\t\t\treturn 0;\n\t\tk = i;\n\t}\n\n\treturn k != -1;\n}\n\n/* Basic map \"i\" has one or more equality constraints that separate it\n * from basic map \"j\".  Check if it happens to be an extension\n * of basic map \"j\".\n * In particular, check that all constraints of \"j\" are valid for \"i\",\n * except for one inequality constraint that is adjacent\n * to an inequality constraints of \"i\".\n * If so, check for \"i\" being an extension of \"j\" by calling\n * is_adj_ineq_extension.\n *\n * Clean up the memory allocated for keeping track of the status\n * of the constraints before returning.\n */\nstatic enum isl_change separating_equality(int i, int j,\n\tstruct isl_coalesce_info *info)\n{\n\tenum isl_change change = isl_change_none;\n\n\tif (all(info[j].eq, 2 * info[j].bmap->n_eq, STATUS_VALID) &&\n\t    all_ineq_valid_or_single_adj_ineq(&info[j]))\n\t\tchange = is_adj_ineq_extension(j, i, info);\n\n\tclear_status(&info[i]);\n\tclear_status(&info[j]);\n\treturn change;\n}\n\n/* Check if the union of the given pair of basic maps\n * can be represented by a single basic map.\n * If so, replace the pair by the single basic map and return\n * isl_change_drop_first, isl_change_drop_second or isl_change_fuse.\n * Otherwise, return isl_change_none.\n * The two basic maps are assumed to live in the same local space.\n * The \"eq\" and \"ineq\" fields of info[i] and info[j] are assumed\n * to have been initialized by the caller, either to NULL or\n * to valid information.\n *\n * We first check the effect of each constraint of one basic map\n * on the other basic map.\n * The constraint may be\n *\tredundant\tthe constraint is redundant in its own\n *\t\t\tbasic map and should be ignore and removed\n *\t\t\tin the end\n *\tvalid\t\tall (integer) points of the other basic map\n *\t\t\tsatisfy the constraint\n *\tseparate\tno (integer) point of the other basic map\n *\t\t\tsatisfies the constraint\n *\tcut\t\tsome but not all points of the other basic map\n *\t\t\tsatisfy the constraint\n *\tadj_eq\t\tthe given constraint is adjacent (on the outside)\n *\t\t\tto an equality of the other basic map\n *\tadj_ineq\tthe given constraint is adjacent (on the outside)\n *\t\t\tto an inequality of the other basic map\n *\n * We consider seven cases in which we can replace the pair by a single\n * basic map.  We ignore all \"redundant\" constraints.\n *\n *\t1. all constraints of one basic map are valid\n *\t\t=> the other basic map is a subset and can be removed\n *\n *\t2. all constraints of both basic maps are either \"valid\" or \"cut\"\n *\t   and the facets corresponding to the \"cut\" constraints\n *\t   of one of the basic maps lies entirely inside the other basic map\n *\t\t=> the pair can be replaced by a basic map consisting\n *\t\t   of the valid constraints in both basic maps\n *\n *\t3. there is a single pair of adjacent inequalities\n *\t   (all other constraints are \"valid\")\n *\t\t=> the pair can be replaced by a basic map consisting\n *\t\t   of the valid constraints in both basic maps\n *\n *\t4. one basic map has a single adjacent inequality, while the other\n *\t   constraints are \"valid\".  The other basic map has some\n *\t   \"cut\" constraints, but replacing the adjacent inequality by\n *\t   its opposite and adding the valid constraints of the other\n *\t   basic map results in a subset of the other basic map\n *\t\t=> the pair can be replaced by a basic map consisting\n *\t\t   of the valid constraints in both basic maps\n *\n *\t5. there is a single adjacent pair of an inequality and an equality,\n *\t   the other constraints of the basic map containing the inequality are\n *\t   \"valid\".  Moreover, if the inequality the basic map is relaxed\n *\t   and then turned into an equality, then resulting facet lies\n *\t   entirely inside the other basic map\n *\t\t=> the pair can be replaced by the basic map containing\n *\t\t   the inequality, with the inequality relaxed.\n *\n *\t6. there is a single inequality adjacent to an equality,\n *\t   the other constraints of the basic map containing the inequality are\n *\t   \"valid\".  Moreover, the facets corresponding to both\n *\t   the inequality and the equality can be wrapped around their\n *\t   ridges to include the other basic map\n *\t\t=> the pair can be replaced by a basic map consisting\n *\t\t   of the valid constraints in both basic maps together\n *\t\t   with all wrapping constraints\n *\n *\t7. one of the basic maps extends beyond the other by at most one.\n *\t   Moreover, the facets corresponding to the cut constraints and\n *\t   the pieces of the other basic map at offset one from these cut\n *\t   constraints can be wrapped around their ridges to include\n *\t   the union of the two basic maps\n *\t\t=> the pair can be replaced by a basic map consisting\n *\t\t   of the valid constraints in both basic maps together\n *\t\t   with all wrapping constraints\n *\n *\t8. the two basic maps live in adjacent hyperplanes.  In principle\n *\t   such sets can always be combined through wrapping, but we impose\n *\t   that there is only one such pair, to avoid overeager coalescing.\n *\n * Throughout the computation, we maintain a collection of tableaus\n * corresponding to the basic maps.  When the basic maps are dropped\n * or combined, the tableaus are modified accordingly.\n */\nstatic enum isl_change coalesce_local_pair_reuse(int i, int j,\n\tstruct isl_coalesce_info *info)\n{\n\tenum isl_change change = isl_change_none;\n\n\tset_ineq_status_in(&info[i], info[j].tab);\n\tif (info[i].bmap->n_ineq && !info[i].ineq)\n\t\tgoto error;\n\tif (any_ineq(&info[i], STATUS_ERROR))\n\t\tgoto error;\n\tif (any_ineq(&info[i], STATUS_SEPARATE))\n\t\tgoto done;\n\n\tset_ineq_status_in(&info[j], info[i].tab);\n\tif (info[j].bmap->n_ineq && !info[j].ineq)\n\t\tgoto error;\n\tif (any_ineq(&info[j], STATUS_ERROR))\n\t\tgoto error;\n\tif (any_ineq(&info[j], STATUS_SEPARATE))\n\t\tgoto done;\n\n\tset_eq_status_in(&info[i], info[j].tab);\n\tif (info[i].bmap->n_eq && !info[i].eq)\n\t\tgoto error;\n\tif (any_eq(&info[i], STATUS_ERROR))\n\t\tgoto error;\n\n\tset_eq_status_in(&info[j], info[i].tab);\n\tif (info[j].bmap->n_eq && !info[j].eq)\n\t\tgoto error;\n\tif (any_eq(&info[j], STATUS_ERROR))\n\t\tgoto error;\n\n\tif (any_eq(&info[i], STATUS_SEPARATE))\n\t\treturn separating_equality(i, j, info);\n\tif (any_eq(&info[j], STATUS_SEPARATE))\n\t\treturn separating_equality(j, i, info);\n\n\tif (all(info[i].eq, 2 * info[i].bmap->n_eq, STATUS_VALID) &&\n\t    all(info[i].ineq, info[i].bmap->n_ineq, STATUS_VALID)) {\n\t\tdrop(&info[j]);\n\t\tchange = isl_change_drop_second;\n\t} else if (all(info[j].eq, 2 * info[j].bmap->n_eq, STATUS_VALID) &&\n\t\t   all(info[j].ineq, info[j].bmap->n_ineq, STATUS_VALID)) {\n\t\tdrop(&info[i]);\n\t\tchange = isl_change_drop_first;\n\t} else if (any_eq(&info[i], STATUS_ADJ_EQ)) {\n\t\tchange = check_eq_adj_eq(i, j, info);\n\t} else if (any_eq(&info[j], STATUS_ADJ_EQ)) {\n\t\tchange = check_eq_adj_eq(j, i, info);\n\t} else if (any_eq(&info[i], STATUS_ADJ_INEQ) ||\n\t\t   any_eq(&info[j], STATUS_ADJ_INEQ)) {\n\t\tchange = check_adj_eq(i, j, info);\n\t} else if (any_ineq(&info[i], STATUS_ADJ_EQ)) {\n\t\tchange = check_ineq_adj_eq(i, j, info);\n\t} else if (any_ineq(&info[j], STATUS_ADJ_EQ)) {\n\t\tchange = check_ineq_adj_eq(j, i, info);\n\t} else if (any_ineq(&info[i], STATUS_ADJ_INEQ) ||\n\t\t   any_ineq(&info[j], STATUS_ADJ_INEQ)) {\n\t\tchange = check_adj_ineq(i, j, info);\n\t} else {\n\t\tif (!any_eq(&info[i], STATUS_CUT) &&\n\t\t    !any_eq(&info[j], STATUS_CUT))\n\t\t\tchange = check_facets(i, j, info);\n\t\tif (change == isl_change_none)\n\t\t\tchange = check_wrap(i, j, info);\n\t}\n\ndone:\n\tclear_status(&info[i]);\n\tclear_status(&info[j]);\n\treturn change;\nerror:\n\tclear_status(&info[i]);\n\tclear_status(&info[j]);\n\treturn isl_change_error;\n}\n\n/* Check if the union of the given pair of basic maps\n * can be represented by a single basic map.\n * If so, replace the pair by the single basic map and return\n * isl_change_drop_first, isl_change_drop_second or isl_change_fuse.\n * Otherwise, return isl_change_none.\n * The two basic maps are assumed to live in the same local space.\n */\nstatic enum isl_change coalesce_local_pair(int i, int j,\n\tstruct isl_coalesce_info *info)\n{\n\tinit_status(&info[i]);\n\tinit_status(&info[j]);\n\treturn coalesce_local_pair_reuse(i, j, info);\n}\n\n/* Shift the integer division at position \"div\" of the basic map\n * represented by \"info\" by \"shift\".\n *\n * That is, if the integer division has the form\n *\n *\tfloor(f(x)/d)\n *\n * then replace it by\n *\n *\tfloor((f(x) + shift * d)/d) - shift\n */\nstatic isl_stat shift_div(struct isl_coalesce_info *info, int div,\n\tisl_int shift)\n{\n\tisl_size total, n_div;\n\n\tinfo->bmap = isl_basic_map_shift_div(info->bmap, div, 0, shift);\n\tif (!info->bmap)\n\t\treturn isl_stat_error;\n\n\ttotal = isl_basic_map_dim(info->bmap, isl_dim_all);\n\tn_div = isl_basic_map_dim(info->bmap, isl_dim_div);\n\tif (total < 0 || n_div < 0)\n\t\treturn isl_stat_error;\n\ttotal -= n_div;\n\tif (isl_tab_shift_var(info->tab, total + div, shift) < 0)\n\t\treturn isl_stat_error;\n\n\treturn isl_stat_ok;\n}\n\n/* If the integer division at position \"div\" is defined by an equality,\n * i.e., a stride constraint, then change the integer division expression\n * to have a constant term equal to zero.\n *\n * Let the equality constraint be\n *\n *\tc + f + m a = 0\n *\n * The integer division expression is then typically of the form\n *\n *\ta = floor((-f - c')/m)\n *\n * The integer division is first shifted by t = floor(c/m),\n * turning the equality constraint into\n *\n *\tc - m floor(c/m) + f + m a' = 0\n *\n * i.e.,\n *\n *\t(c mod m) + f + m a' = 0\n *\n * That is,\n *\n *\ta' = (-f - (c mod m))/m = floor((-f)/m)\n *\n * because a' is an integer and 0 <= (c mod m) < m.\n * The constant term of a' can therefore be zeroed out,\n * but only if the integer division expression is of the expected form.\n */\nstatic isl_stat normalize_stride_div(struct isl_coalesce_info *info, int div)\n{\n\tisl_bool defined, valid;\n\tisl_stat r;\n\tisl_constraint *c;\n\tisl_int shift, stride;\n\n\tdefined = isl_basic_map_has_defining_equality(info->bmap, isl_dim_div,\n\t\t\t\t\t\t\tdiv, &c);\n\tif (defined < 0)\n\t\treturn isl_stat_error;\n\tif (!defined)\n\t\treturn isl_stat_ok;\n\tif (!c)\n\t\treturn isl_stat_error;\n\tvalid = isl_constraint_is_div_equality(c, div);\n\tisl_int_init(shift);\n\tisl_int_init(stride);\n\tisl_constraint_get_constant(c, &shift);\n\tisl_constraint_get_coefficient(c, isl_dim_div, div, &stride);\n\tisl_int_fdiv_q(shift, shift, stride);\n\tr = shift_div(info, div, shift);\n\tisl_int_clear(stride);\n\tisl_int_clear(shift);\n\tisl_constraint_free(c);\n\tif (r < 0 || valid < 0)\n\t\treturn isl_stat_error;\n\tif (!valid)\n\t\treturn isl_stat_ok;\n\tinfo->bmap = isl_basic_map_set_div_expr_constant_num_si_inplace(\n\t\t\t\t\t\t\t    info->bmap, div, 0);\n\tif (!info->bmap)\n\t\treturn isl_stat_error;\n\treturn isl_stat_ok;\n}\n\n/* The basic maps represented by \"info1\" and \"info2\" are known\n * to have the same number of integer divisions.\n * Check if pairs of integer divisions are equal to each other\n * despite the fact that they differ by a rational constant.\n *\n * In particular, look for any pair of integer divisions that\n * only differ in their constant terms.\n * If either of these integer divisions is defined\n * by stride constraints, then modify it to have a zero constant term.\n * If both are defined by stride constraints then in the end they will have\n * the same (zero) constant term.\n */\nstatic isl_stat harmonize_stride_divs(struct isl_coalesce_info *info1,\n\tstruct isl_coalesce_info *info2)\n{\n\tint i;\n\tisl_size n;\n\n\tn = isl_basic_map_dim(info1->bmap, isl_dim_div);\n\tif (n < 0)\n\t\treturn isl_stat_error;\n\tfor (i = 0; i < n; ++i) {\n\t\tisl_bool known, harmonize;\n\n\t\tknown = isl_basic_map_div_is_known(info1->bmap, i);\n\t\tif (known >= 0 && known)\n\t\t\tknown = isl_basic_map_div_is_known(info2->bmap, i);\n\t\tif (known < 0)\n\t\t\treturn isl_stat_error;\n\t\tif (!known)\n\t\t\tcontinue;\n\t\tharmonize = isl_basic_map_equal_div_expr_except_constant(\n\t\t\t\t\t    info1->bmap, i, info2->bmap, i);\n\t\tif (harmonize < 0)\n\t\t\treturn isl_stat_error;\n\t\tif (!harmonize)\n\t\t\tcontinue;\n\t\tif (normalize_stride_div(info1, i) < 0)\n\t\t\treturn isl_stat_error;\n\t\tif (normalize_stride_div(info2, i) < 0)\n\t\t\treturn isl_stat_error;\n\t}\n\n\treturn isl_stat_ok;\n}\n\n/* If \"shift\" is an integer constant, then shift the integer division\n * at position \"div\" of the basic map represented by \"info\" by \"shift\".\n * If \"shift\" is not an integer constant, then do nothing.\n * If \"shift\" is equal to zero, then no shift needs to be performed either.\n *\n * That is, if the integer division has the form\n *\n *\tfloor(f(x)/d)\n *\n * then replace it by\n *\n *\tfloor((f(x) + shift * d)/d) - shift\n */\nstatic isl_stat shift_if_cst_int(struct isl_coalesce_info *info, int div,\n\t__isl_keep isl_aff *shift)\n{\n\tisl_bool cst;\n\tisl_stat r;\n\tisl_int d;\n\tisl_val *c;\n\n\tcst = isl_aff_is_cst(shift);\n\tif (cst < 0 || !cst)\n\t\treturn cst < 0 ? isl_stat_error : isl_stat_ok;\n\n\tc = isl_aff_get_constant_val(shift);\n\tcst = isl_val_is_int(c);\n\tif (cst >= 0 && cst)\n\t\tcst = isl_bool_not(isl_val_is_zero(c));\n\tif (cst < 0 || !cst) {\n\t\tisl_val_free(c);\n\t\treturn cst < 0 ? isl_stat_error : isl_stat_ok;\n\t}\n\n\tisl_int_init(d);\n\tr = isl_val_get_num_isl_int(c, &d);\n\tif (r >= 0)\n\t\tr = shift_div(info, div, d);\n\tisl_int_clear(d);\n\n\tisl_val_free(c);\n\n\treturn r;\n}\n\n/* Check if some of the divs in the basic map represented by \"info1\"\n * are shifts of the corresponding divs in the basic map represented\n * by \"info2\", taking into account the equality constraints \"eq1\" of \"info1\"\n * and \"eq2\" of \"info2\".  If so, align them with those of \"info2\".\n * \"info1\" and \"info2\" are assumed to have the same number\n * of integer divisions.\n *\n * An integer division is considered to be a shift of another integer\n * division if, after simplification with respect to the equality\n * constraints of the other basic map, one is equal to the other\n * plus a constant.\n *\n * In particular, for each pair of integer divisions, if both are known,\n * have the same denominator and are not already equal to each other,\n * simplify each with respect to the equality constraints\n * of the other basic map.  If the difference is an integer constant,\n * then move this difference outside.\n * That is, if, after simplification, one integer division is of the form\n *\n *\tfloor((f(x) + c_1)/d)\n *\n * while the other is of the form\n *\n *\tfloor((f(x) + c_2)/d)\n *\n * and n = (c_2 - c_1)/d is an integer, then replace the first\n * integer division by\n *\n *\tfloor((f_1(x) + c_1 + n * d)/d) - n,\n *\n * where floor((f_1(x) + c_1 + n * d)/d) = floor((f2(x) + c_2)/d)\n * after simplification with respect to the equality constraints.\n */\nstatic isl_stat harmonize_divs_with_hulls(struct isl_coalesce_info *info1,\n\tstruct isl_coalesce_info *info2, __isl_keep isl_basic_set *eq1,\n\t__isl_keep isl_basic_set *eq2)\n{\n\tint i;\n\tisl_size total;\n\tisl_local_space *ls1, *ls2;\n\n\ttotal = isl_basic_map_dim(info1->bmap, isl_dim_all);\n\tif (total < 0)\n\t\treturn isl_stat_error;\n\tls1 = isl_local_space_wrap(isl_basic_map_get_local_space(info1->bmap));\n\tls2 = isl_local_space_wrap(isl_basic_map_get_local_space(info2->bmap));\n\tfor (i = 0; i < info1->bmap->n_div; ++i) {\n\t\tisl_stat r;\n\t\tisl_aff *div1, *div2;\n\n\t\tif (!isl_local_space_div_is_known(ls1, i) ||\n\t\t    !isl_local_space_div_is_known(ls2, i))\n\t\t\tcontinue;\n\t\tif (isl_int_ne(info1->bmap->div[i][0], info2->bmap->div[i][0]))\n\t\t\tcontinue;\n\t\tif (isl_seq_eq(info1->bmap->div[i] + 1,\n\t\t\t\tinfo2->bmap->div[i] + 1, 1 + total))\n\t\t\tcontinue;\n\t\tdiv1 = isl_local_space_get_div(ls1, i);\n\t\tdiv2 = isl_local_space_get_div(ls2, i);\n\t\tdiv1 = isl_aff_substitute_equalities(div1,\n\t\t\t\t\t\t    isl_basic_set_copy(eq2));\n\t\tdiv2 = isl_aff_substitute_equalities(div2,\n\t\t\t\t\t\t    isl_basic_set_copy(eq1));\n\t\tdiv2 = isl_aff_sub(div2, div1);\n\t\tr = shift_if_cst_int(info1, i, div2);\n\t\tisl_aff_free(div2);\n\t\tif (r < 0)\n\t\t\tbreak;\n\t}\n\tisl_local_space_free(ls1);\n\tisl_local_space_free(ls2);\n\n\tif (i < info1->bmap->n_div)\n\t\treturn isl_stat_error;\n\treturn isl_stat_ok;\n}\n\n/* Check if some of the divs in the basic map represented by \"info1\"\n * are shifts of the corresponding divs in the basic map represented\n * by \"info2\".  If so, align them with those of \"info2\".\n * Only do this if \"info1\" and \"info2\" have the same number\n * of integer divisions.\n *\n * An integer division is considered to be a shift of another integer\n * division if, after simplification with respect to the equality\n * constraints of the other basic map, one is equal to the other\n * plus a constant.\n *\n * First check if pairs of integer divisions are equal to each other\n * despite the fact that they differ by a rational constant.\n * If so, try and arrange for them to have the same constant term.\n *\n * Then, extract the equality constraints and continue with\n * harmonize_divs_with_hulls.\n *\n * If the equality constraints of both basic maps are the same,\n * then there is no need to perform any shifting since\n * the coefficients of the integer divisions should have been\n * reduced in the same way.\n */\nstatic isl_stat harmonize_divs(struct isl_coalesce_info *info1,\n\tstruct isl_coalesce_info *info2)\n{\n\tisl_bool equal;\n\tisl_basic_map *bmap1, *bmap2;\n\tisl_basic_set *eq1, *eq2;\n\tisl_stat r;\n\n\tif (!info1->bmap || !info2->bmap)\n\t\treturn isl_stat_error;\n\n\tif (info1->bmap->n_div != info2->bmap->n_div)\n\t\treturn isl_stat_ok;\n\tif (info1->bmap->n_div == 0)\n\t\treturn isl_stat_ok;\n\n\tif (harmonize_stride_divs(info1, info2) < 0)\n\t\treturn isl_stat_error;\n\n\tbmap1 = isl_basic_map_copy(info1->bmap);\n\tbmap2 = isl_basic_map_copy(info2->bmap);\n\teq1 = isl_basic_map_wrap(isl_basic_map_plain_affine_hull(bmap1));\n\teq2 = isl_basic_map_wrap(isl_basic_map_plain_affine_hull(bmap2));\n\tequal = isl_basic_set_plain_is_equal(eq1, eq2);\n\tif (equal < 0)\n\t\tr = isl_stat_error;\n\telse if (equal)\n\t\tr = isl_stat_ok;\n\telse\n\t\tr = harmonize_divs_with_hulls(info1, info2, eq1, eq2);\n\tisl_basic_set_free(eq1);\n\tisl_basic_set_free(eq2);\n\n\treturn r;\n}\n\n/* Do the two basic maps live in the same local space, i.e.,\n * do they have the same (known) divs?\n * If either basic map has any unknown divs, then we can only assume\n * that they do not live in the same local space.\n */\nstatic isl_bool same_divs(__isl_keep isl_basic_map *bmap1,\n\t__isl_keep isl_basic_map *bmap2)\n{\n\tint i;\n\tisl_bool known;\n\tisl_size total;\n\n\tif (!bmap1 || !bmap2)\n\t\treturn isl_bool_error;\n\tif (bmap1->n_div != bmap2->n_div)\n\t\treturn isl_bool_false;\n\n\tif (bmap1->n_div == 0)\n\t\treturn isl_bool_true;\n\n\tknown = isl_basic_map_divs_known(bmap1);\n\tif (known < 0 || !known)\n\t\treturn known;\n\tknown = isl_basic_map_divs_known(bmap2);\n\tif (known < 0 || !known)\n\t\treturn known;\n\n\ttotal = isl_basic_map_dim(bmap1, isl_dim_all);\n\tif (total < 0)\n\t\treturn isl_bool_error;\n\tfor (i = 0; i < bmap1->n_div; ++i)\n\t\tif (!isl_seq_eq(bmap1->div[i], bmap2->div[i], 2 + total))\n\t\t\treturn isl_bool_false;\n\n\treturn isl_bool_true;\n}\n\n/* Assuming that \"tab\" contains the equality constraints and\n * the initial inequality constraints of \"bmap\", copy the remaining\n * inequality constraints of \"bmap\" to \"Tab\".\n */\nstatic isl_stat copy_ineq(struct isl_tab *tab, __isl_keep isl_basic_map *bmap)\n{\n\tint i, n_ineq;\n\n\tif (!bmap)\n\t\treturn isl_stat_error;\n\n\tn_ineq = tab->n_con - tab->n_eq;\n\tfor (i = n_ineq; i < bmap->n_ineq; ++i)\n\t\tif (isl_tab_add_ineq(tab, bmap->ineq[i]) < 0)\n\t\t\treturn isl_stat_error;\n\n\treturn isl_stat_ok;\n}\n\n/* Description of an integer division that is added\n * during an expansion.\n * \"pos\" is the position of the corresponding variable.\n * \"cst\" indicates whether this integer division has a fixed value.\n * \"val\" contains the fixed value, if the value is fixed.\n */\nstruct isl_expanded {\n\tint pos;\n\tisl_bool cst;\n\tisl_int val;\n};\n\n/* For each of the \"n\" integer division variables \"expanded\",\n * if the variable has a fixed value, then add two inequality\n * constraints expressing the fixed value.\n * Otherwise, add the corresponding div constraints.\n * The caller is responsible for removing the div constraints\n * that it added for all these \"n\" integer divisions.\n *\n * The div constraints and the pair of inequality constraints\n * forcing the fixed value cannot both be added for a given variable\n * as the combination may render some of the original constraints redundant.\n * These would then be ignored during the coalescing detection,\n * while they could remain in the fused result.\n *\n * The two added inequality constraints are\n *\n *\t-a + v >= 0\n *\ta - v >= 0\n *\n * with \"a\" the variable and \"v\" its fixed value.\n * The facet corresponding to one of these two constraints is selected\n * in the tableau to ensure that the pair of inequality constraints\n * is treated as an equality constraint.\n *\n * The information in info->ineq is thrown away because it was\n * computed in terms of div constraints, while some of those\n * have now been replaced by these pairs of inequality constraints.\n */\nstatic isl_stat fix_constant_divs(struct isl_coalesce_info *info,\n\tint n, struct isl_expanded *expanded)\n{\n\tunsigned o_div;\n\tint i;\n\tisl_vec *ineq;\n\n\to_div = isl_basic_map_offset(info->bmap, isl_dim_div) - 1;\n\tineq = isl_vec_alloc(isl_tab_get_ctx(info->tab), 1 + info->tab->n_var);\n\tif (!ineq)\n\t\treturn isl_stat_error;\n\tisl_seq_clr(ineq->el + 1, info->tab->n_var);\n\n\tfor (i = 0; i < n; ++i) {\n\t\tif (!expanded[i].cst) {\n\t\t\tinfo->bmap = isl_basic_map_extend_constraints(\n\t\t\t\t\t\tinfo->bmap, 0, 2);\n\t\t\tinfo->bmap = isl_basic_map_add_div_constraints(\n\t\t\t\t\tinfo->bmap, expanded[i].pos - o_div);\n\t\t} else {\n\t\t\tisl_int_set_si(ineq->el[1 + expanded[i].pos], -1);\n\t\t\tisl_int_set(ineq->el[0], expanded[i].val);\n\t\t\tinfo->bmap = isl_basic_map_add_ineq(info->bmap,\n\t\t\t\t\t\t\t\tineq->el);\n\t\t\tisl_int_set_si(ineq->el[1 + expanded[i].pos], 1);\n\t\t\tisl_int_neg(ineq->el[0], expanded[i].val);\n\t\t\tinfo->bmap = isl_basic_map_add_ineq(info->bmap,\n\t\t\t\t\t\t\t\tineq->el);\n\t\t\tisl_int_set_si(ineq->el[1 + expanded[i].pos], 0);\n\t\t}\n\t\tif (copy_ineq(info->tab, info->bmap) < 0)\n\t\t\tbreak;\n\t\tif (expanded[i].cst &&\n\t\t    isl_tab_select_facet(info->tab, info->tab->n_con - 1) < 0)\n\t\t\tbreak;\n\t}\n\n\tisl_vec_free(ineq);\n\n\tclear_status(info);\n\tinit_status(info);\n\n\treturn i < n ? isl_stat_error : isl_stat_ok;\n}\n\n/* Insert the \"n\" integer division variables \"expanded\"\n * into info->tab and info->bmap and\n * update info->ineq with respect to the redundant constraints\n * in the resulting tableau.\n * \"bmap\" contains the result of this insertion in info->bmap,\n * while info->bmap is the original version\n * of \"bmap\", i.e., the one that corresponds to the current\n * state of info->tab.  The number of constraints in info->bmap\n * is assumed to be the same as the number of constraints\n * in info->tab.  This is required to be able to detect\n * the extra constraints in \"bmap\".\n *\n * In particular, introduce extra variables corresponding\n * to the extra integer divisions and add the div constraints\n * that were added to \"bmap\" after info->tab was created\n * from info->bmap.\n * Furthermore, check if these extra integer divisions happen\n * to attain a fixed integer value in info->tab.\n * If so, replace the corresponding div constraints by pairs\n * of inequality constraints that fix these\n * integer divisions to their single integer values.\n * Replace info->bmap by \"bmap\" to match the changes to info->tab.\n * info->ineq was computed without a tableau and therefore\n * does not take into account the redundant constraints\n * in the tableau.  Mark them here.\n * There is no need to check the newly added div constraints\n * since they cannot be redundant.\n * The redundancy check is not performed when constants have been discovered\n * since info->ineq is completely thrown away in this case.\n */\nstatic isl_stat tab_insert_divs(struct isl_coalesce_info *info,\n\tint n, struct isl_expanded *expanded, __isl_take isl_basic_map *bmap)\n{\n\tint i, n_ineq;\n\tunsigned n_eq;\n\tstruct isl_tab_undo *snap;\n\tint any;\n\n\tif (!bmap)\n\t\treturn isl_stat_error;\n\tif (info->bmap->n_eq + info->bmap->n_ineq != info->tab->n_con)\n\t\tisl_die(isl_basic_map_get_ctx(bmap), isl_error_internal,\n\t\t\t\"original tableau does not correspond \"\n\t\t\t\"to original basic map\", goto error);\n\n\tif (isl_tab_extend_vars(info->tab, n) < 0)\n\t\tgoto error;\n\tif (isl_tab_extend_cons(info->tab, 2 * n) < 0)\n\t\tgoto error;\n\n\tfor (i = 0; i < n; ++i) {\n\t\tif (isl_tab_insert_var(info->tab, expanded[i].pos) < 0)\n\t\t\tgoto error;\n\t}\n\n\tsnap = isl_tab_snap(info->tab);\n\n\tn_ineq = info->tab->n_con - info->tab->n_eq;\n\tif (copy_ineq(info->tab, bmap) < 0)\n\t\tgoto error;\n\n\tisl_basic_map_free(info->bmap);\n\tinfo->bmap = bmap;\n\n\tany = 0;\n\tfor (i = 0; i < n; ++i) {\n\t\texpanded[i].cst = isl_tab_is_constant(info->tab,\n\t\t\t\t\t    expanded[i].pos, &expanded[i].val);\n\t\tif (expanded[i].cst < 0)\n\t\t\treturn isl_stat_error;\n\t\tif (expanded[i].cst)\n\t\t\tany = 1;\n\t}\n\n\tif (any) {\n\t\tif (isl_tab_rollback(info->tab, snap) < 0)\n\t\t\treturn isl_stat_error;\n\t\tinfo->bmap = isl_basic_map_cow(info->bmap);\n\t\tinfo->bmap = isl_basic_map_free_inequality(info->bmap, 2 * n);\n\t\tif (info->bmap < 0)\n\t\t\treturn isl_stat_error;\n\n\t\treturn fix_constant_divs(info, n, expanded);\n\t}\n\n\tn_eq = info->bmap->n_eq;\n\tfor (i = 0; i < n_ineq; ++i) {\n\t\tif (isl_tab_is_redundant(info->tab, n_eq + i))\n\t\t\tinfo->ineq[i] = STATUS_REDUNDANT;\n\t}\n\n\treturn isl_stat_ok;\nerror:\n\tisl_basic_map_free(bmap);\n\treturn isl_stat_error;\n}\n\n/* Expand info->tab and info->bmap in the same way \"bmap\" was expanded\n * in isl_basic_map_expand_divs using the expansion \"exp\" and\n * update info->ineq with respect to the redundant constraints\n * in the resulting tableau. info->bmap is the original version\n * of \"bmap\", i.e., the one that corresponds to the current\n * state of info->tab.  The number of constraints in info->bmap\n * is assumed to be the same as the number of constraints\n * in info->tab.  This is required to be able to detect\n * the extra constraints in \"bmap\".\n *\n * Extract the positions where extra local variables are introduced\n * from \"exp\" and call tab_insert_divs.\n */\nstatic isl_stat expand_tab(struct isl_coalesce_info *info, int *exp,\n\t__isl_take isl_basic_map *bmap)\n{\n\tisl_ctx *ctx;\n\tstruct isl_expanded *expanded;\n\tint i, j, k, n;\n\tint extra_var;\n\tisl_size total, n_div;\n\tunsigned pos;\n\tisl_stat r;\n\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tn_div = isl_basic_map_dim(bmap, isl_dim_div);\n\tif (total < 0 || n_div < 0)\n\t\treturn isl_stat_error;\n\tpos = total - n_div;\n\textra_var = total - info->tab->n_var;\n\tn = n_div - extra_var;\n\n\tctx = isl_basic_map_get_ctx(bmap);\n\texpanded = isl_calloc_array(ctx, struct isl_expanded, extra_var);\n\tif (extra_var && !expanded)\n\t\tgoto error;\n\n\ti = 0;\n\tk = 0;\n\tfor (j = 0; j < n_div; ++j) {\n\t\tif (i < n && exp[i] == j) {\n\t\t\t++i;\n\t\t\tcontinue;\n\t\t}\n\t\texpanded[k++].pos = pos + j;\n\t}\n\n\tfor (k = 0; k < extra_var; ++k)\n\t\tisl_int_init(expanded[k].val);\n\n\tr = tab_insert_divs(info, extra_var, expanded, bmap);\n\n\tfor (k = 0; k < extra_var; ++k)\n\t\tisl_int_clear(expanded[k].val);\n\tfree(expanded);\n\n\treturn r;\nerror:\n\tisl_basic_map_free(bmap);\n\treturn isl_stat_error;\n}\n\n/* Check if the union of the basic maps represented by info[i] and info[j]\n * can be represented by a single basic map,\n * after expanding the divs of info[i] to match those of info[j].\n * If so, replace the pair by the single basic map and return\n * isl_change_drop_first, isl_change_drop_second or isl_change_fuse.\n * Otherwise, return isl_change_none.\n *\n * The caller has already checked for info[j] being a subset of info[i].\n * If some of the divs of info[j] are unknown, then the expanded info[i]\n * will not have the corresponding div constraints.  The other patterns\n * therefore cannot apply.  Skip the computation in this case.\n *\n * The expansion is performed using the divs \"div\" and expansion \"exp\"\n * computed by the caller.\n * info[i].bmap has already been expanded and the result is passed in\n * as \"bmap\".\n * The \"eq\" and \"ineq\" fields of info[i] reflect the status of\n * the constraints of the expanded \"bmap\" with respect to info[j].tab.\n * However, inequality constraints that are redundant in info[i].tab\n * have not yet been marked as such because no tableau was available.\n *\n * Replace info[i].bmap by \"bmap\" and expand info[i].tab as well,\n * updating info[i].ineq with respect to the redundant constraints.\n * Then try and coalesce the expanded info[i] with info[j],\n * reusing the information in info[i].eq and info[i].ineq.\n * If this does not result in any coalescing or if it results in info[j]\n * getting dropped (which should not happen in practice, since the case\n * of info[j] being a subset of info[i] has already been checked by\n * the caller), then revert info[i] to its original state.\n */\nstatic enum isl_change coalesce_expand_tab_divs(__isl_take isl_basic_map *bmap,\n\tint i, int j, struct isl_coalesce_info *info, __isl_keep isl_mat *div,\n\tint *exp)\n{\n\tisl_bool known;\n\tisl_basic_map *bmap_i;\n\tstruct isl_tab_undo *snap;\n\tenum isl_change change = isl_change_none;\n\n\tknown = isl_basic_map_divs_known(info[j].bmap);\n\tif (known < 0 || !known) {\n\t\tclear_status(&info[i]);\n\t\tisl_basic_map_free(bmap);\n\t\treturn known < 0 ? isl_change_error : isl_change_none;\n\t}\n\n\tbmap_i = isl_basic_map_copy(info[i].bmap);\n\tsnap = isl_tab_snap(info[i].tab);\n\tif (expand_tab(&info[i], exp, bmap) < 0)\n\t\tchange = isl_change_error;\n\n\tinit_status(&info[j]);\n\tif (change == isl_change_none)\n\t\tchange = coalesce_local_pair_reuse(i, j, info);\n\telse\n\t\tclear_status(&info[i]);\n\tif (change != isl_change_none && change != isl_change_drop_second) {\n\t\tisl_basic_map_free(bmap_i);\n\t} else {\n\t\tisl_basic_map_free(info[i].bmap);\n\t\tinfo[i].bmap = bmap_i;\n\n\t\tif (isl_tab_rollback(info[i].tab, snap) < 0)\n\t\t\tchange = isl_change_error;\n\t}\n\n\treturn change;\n}\n\n/* Check if the union of \"bmap\" and the basic map represented by info[j]\n * can be represented by a single basic map,\n * after expanding the divs of \"bmap\" to match those of info[j].\n * If so, replace the pair by the single basic map and return\n * isl_change_drop_first, isl_change_drop_second or isl_change_fuse.\n * Otherwise, return isl_change_none.\n *\n * In particular, check if the expanded \"bmap\" contains the basic map\n * represented by the tableau info[j].tab.\n * The expansion is performed using the divs \"div\" and expansion \"exp\"\n * computed by the caller.\n * Then we check if all constraints of the expanded \"bmap\" are valid for\n * info[j].tab.\n *\n * If \"i\" is not equal to -1, then \"bmap\" is equal to info[i].bmap.\n * In this case, the positions of the constraints of info[i].bmap\n * with respect to the basic map represented by info[j] are stored\n * in info[i].\n *\n * If the expanded \"bmap\" does not contain the basic map\n * represented by the tableau info[j].tab and if \"i\" is not -1,\n * i.e., if the original \"bmap\" is info[i].bmap, then expand info[i].tab\n * as well and check if that results in coalescing.\n */\nstatic enum isl_change coalesce_with_expanded_divs(\n\t__isl_keep isl_basic_map *bmap, int i, int j,\n\tstruct isl_coalesce_info *info, __isl_keep isl_mat *div, int *exp)\n{\n\tenum isl_change change = isl_change_none;\n\tstruct isl_coalesce_info info_local, *info_i;\n\n\tinfo_i = i >= 0 ? &info[i] : &info_local;\n\tinit_status(info_i);\n\tbmap = isl_basic_map_copy(bmap);\n\tbmap = isl_basic_map_expand_divs(bmap, isl_mat_copy(div), exp);\n\tbmap = isl_basic_map_mark_final(bmap);\n\n\tif (!bmap)\n\t\tgoto error;\n\n\tinfo_local.bmap = bmap;\n\tinfo_i->eq = eq_status_in(bmap, info[j].tab);\n\tif (bmap->n_eq && !info_i->eq)\n\t\tgoto error;\n\tif (any_eq(info_i, STATUS_ERROR))\n\t\tgoto error;\n\tif (any_eq(info_i, STATUS_SEPARATE))\n\t\tgoto done;\n\n\tinfo_i->ineq = ineq_status_in(bmap, NULL, info[j].tab);\n\tif (bmap->n_ineq && !info_i->ineq)\n\t\tgoto error;\n\tif (any_ineq(info_i, STATUS_ERROR))\n\t\tgoto error;\n\tif (any_ineq(info_i, STATUS_SEPARATE))\n\t\tgoto done;\n\n\tif (all(info_i->eq, 2 * bmap->n_eq, STATUS_VALID) &&\n\t    all(info_i->ineq, bmap->n_ineq, STATUS_VALID)) {\n\t\tdrop(&info[j]);\n\t\tchange = isl_change_drop_second;\n\t}\n\n\tif (change == isl_change_none && i != -1)\n\t\treturn coalesce_expand_tab_divs(bmap, i, j, info, div, exp);\n\ndone:\n\tisl_basic_map_free(bmap);\n\tclear_status(info_i);\n\treturn change;\nerror:\n\tisl_basic_map_free(bmap);\n\tclear_status(info_i);\n\treturn isl_change_error;\n}\n\n/* Check if the union of \"bmap_i\" and the basic map represented by info[j]\n * can be represented by a single basic map,\n * after aligning the divs of \"bmap_i\" to match those of info[j].\n * If so, replace the pair by the single basic map and return\n * isl_change_drop_first, isl_change_drop_second or isl_change_fuse.\n * Otherwise, return isl_change_none.\n *\n * In particular, check if \"bmap_i\" contains the basic map represented by\n * info[j] after aligning the divs of \"bmap_i\" to those of info[j].\n * Note that this can only succeed if the number of divs of \"bmap_i\"\n * is smaller than (or equal to) the number of divs of info[j].\n *\n * We first check if the divs of \"bmap_i\" are all known and form a subset\n * of those of info[j].bmap.  If so, we pass control over to\n * coalesce_with_expanded_divs.\n *\n * If \"i\" is not equal to -1, then \"bmap\" is equal to info[i].bmap.\n */\nstatic enum isl_change coalesce_after_aligning_divs(\n\t__isl_keep isl_basic_map *bmap_i, int i, int j,\n\tstruct isl_coalesce_info *info)\n{\n\tisl_bool known;\n\tisl_mat *div_i, *div_j, *div;\n\tint *exp1 = NULL;\n\tint *exp2 = NULL;\n\tisl_ctx *ctx;\n\tenum isl_change change;\n\n\tknown = isl_basic_map_divs_known(bmap_i);\n\tif (known < 0)\n\t\treturn isl_change_error;\n\tif (!known)\n\t\treturn isl_change_none;\n\n\tctx = isl_basic_map_get_ctx(bmap_i);\n\n\tdiv_i = isl_basic_map_get_divs(bmap_i);\n\tdiv_j = isl_basic_map_get_divs(info[j].bmap);\n\n\tif (!div_i || !div_j)\n\t\tgoto error;\n\n\texp1 = isl_alloc_array(ctx, int, div_i->n_row);\n\texp2 = isl_alloc_array(ctx, int, div_j->n_row);\n\tif ((div_i->n_row && !exp1) || (div_j->n_row && !exp2))\n\t\tgoto error;\n\n\tdiv = isl_merge_divs(div_i, div_j, exp1, exp2);\n\tif (!div)\n\t\tgoto error;\n\n\tif (div->n_row == div_j->n_row)\n\t\tchange = coalesce_with_expanded_divs(bmap_i,\n\t\t\t\t\t\t\ti, j, info, div, exp1);\n\telse\n\t\tchange = isl_change_none;\n\n\tisl_mat_free(div);\n\n\tisl_mat_free(div_i);\n\tisl_mat_free(div_j);\n\n\tfree(exp2);\n\tfree(exp1);\n\n\treturn change;\nerror:\n\tisl_mat_free(div_i);\n\tisl_mat_free(div_j);\n\tfree(exp1);\n\tfree(exp2);\n\treturn isl_change_error;\n}\n\n/* Check if basic map \"j\" is a subset of basic map \"i\" after\n * exploiting the extra equalities of \"j\" to simplify the divs of \"i\".\n * If so, remove basic map \"j\" and return isl_change_drop_second.\n *\n * If \"j\" does not have any equalities or if they are the same\n * as those of \"i\", then we cannot exploit them to simplify the divs.\n * Similarly, if there are no divs in \"i\", then they cannot be simplified.\n * If, on the other hand, the affine hulls of \"i\" and \"j\" do not intersect,\n * then \"j\" cannot be a subset of \"i\".\n *\n * Otherwise, we intersect \"i\" with the affine hull of \"j\" and then\n * check if \"j\" is a subset of the result after aligning the divs.\n * If so, then \"j\" is definitely a subset of \"i\" and can be removed.\n * Note that if after intersection with the affine hull of \"j\".\n * \"i\" still has more divs than \"j\", then there is no way we can\n * align the divs of \"i\" to those of \"j\".\n */\nstatic enum isl_change coalesce_subset_with_equalities(int i, int j,\n\tstruct isl_coalesce_info *info)\n{\n\tisl_basic_map *hull_i, *hull_j, *bmap_i;\n\tint equal, empty;\n\tenum isl_change change;\n\n\tif (info[j].bmap->n_eq == 0)\n\t\treturn isl_change_none;\n\tif (info[i].bmap->n_div == 0)\n\t\treturn isl_change_none;\n\n\thull_i = isl_basic_map_copy(info[i].bmap);\n\thull_i = isl_basic_map_plain_affine_hull(hull_i);\n\thull_j = isl_basic_map_copy(info[j].bmap);\n\thull_j = isl_basic_map_plain_affine_hull(hull_j);\n\n\thull_j = isl_basic_map_intersect(hull_j, isl_basic_map_copy(hull_i));\n\tequal = isl_basic_map_plain_is_equal(hull_i, hull_j);\n\tempty = isl_basic_map_plain_is_empty(hull_j);\n\tisl_basic_map_free(hull_i);\n\n\tif (equal < 0 || equal || empty < 0 || empty) {\n\t\tisl_basic_map_free(hull_j);\n\t\tif (equal < 0 || empty < 0)\n\t\t\treturn isl_change_error;\n\t\treturn isl_change_none;\n\t}\n\n\tbmap_i = isl_basic_map_copy(info[i].bmap);\n\tbmap_i = isl_basic_map_intersect(bmap_i, hull_j);\n\tif (!bmap_i)\n\t\treturn isl_change_error;\n\n\tif (bmap_i->n_div > info[j].bmap->n_div) {\n\t\tisl_basic_map_free(bmap_i);\n\t\treturn isl_change_none;\n\t}\n\n\tchange = coalesce_after_aligning_divs(bmap_i, -1, j, info);\n\n\tisl_basic_map_free(bmap_i);\n\n\treturn change;\n}\n\n/* Check if the union of and the basic maps represented by info[i] and info[j]\n * can be represented by a single basic map, by aligning or equating\n * their integer divisions.\n * If so, replace the pair by the single basic map and return\n * isl_change_drop_first, isl_change_drop_second or isl_change_fuse.\n * Otherwise, return isl_change_none.\n *\n * Note that we only perform any test if the number of divs is different\n * in the two basic maps.  In case the number of divs is the same,\n * we have already established that the divs are different\n * in the two basic maps.\n * In particular, if the number of divs of basic map i is smaller than\n * the number of divs of basic map j, then we check if j is a subset of i\n * and vice versa.\n */\nstatic enum isl_change coalesce_divs(int i, int j,\n\tstruct isl_coalesce_info *info)\n{\n\tenum isl_change change = isl_change_none;\n\n\tif (info[i].bmap->n_div < info[j].bmap->n_div)\n\t\tchange = coalesce_after_aligning_divs(info[i].bmap, i, j, info);\n\tif (change != isl_change_none)\n\t\treturn change;\n\n\tif (info[j].bmap->n_div < info[i].bmap->n_div)\n\t\tchange = coalesce_after_aligning_divs(info[j].bmap, j, i, info);\n\tif (change != isl_change_none)\n\t\treturn invert_change(change);\n\n\tchange = coalesce_subset_with_equalities(i, j, info);\n\tif (change != isl_change_none)\n\t\treturn change;\n\n\tchange = coalesce_subset_with_equalities(j, i, info);\n\tif (change != isl_change_none)\n\t\treturn invert_change(change);\n\n\treturn isl_change_none;\n}\n\n/* Does \"bmap\" involve any divs that themselves refer to divs?\n */\nstatic isl_bool has_nested_div(__isl_keep isl_basic_map *bmap)\n{\n\tint i;\n\tisl_size total;\n\tisl_size n_div;\n\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tn_div = isl_basic_map_dim(bmap, isl_dim_div);\n\tif (total < 0 || n_div < 0)\n\t\treturn isl_bool_error;\n\ttotal -= n_div;\n\n\tfor (i = 0; i < n_div; ++i)\n\t\tif (isl_seq_first_non_zero(bmap->div[i] + 2 + total,\n\t\t\t\t\t    n_div) != -1)\n\t\t\treturn isl_bool_true;\n\n\treturn isl_bool_false;\n}\n\n/* Return a list of affine expressions, one for each integer division\n * in \"bmap_i\".  For each integer division that also appears in \"bmap_j\",\n * the affine expression is set to NaN.  The number of NaNs in the list\n * is equal to the number of integer divisions in \"bmap_j\".\n * For the other integer divisions of \"bmap_i\", the corresponding\n * element in the list is a purely affine expression equal to the integer\n * division in \"hull\".\n * If no such list can be constructed, then the number of elements\n * in the returned list is smaller than the number of integer divisions\n * in \"bmap_i\".\n */\nstatic __isl_give isl_aff_list *set_up_substitutions(\n\t__isl_keep isl_basic_map *bmap_i, __isl_keep isl_basic_map *bmap_j,\n\t__isl_take isl_basic_map *hull)\n{\n\tisl_size n_div_i, n_div_j, total;\n\tisl_ctx *ctx;\n\tisl_local_space *ls;\n\tisl_basic_set *wrap_hull;\n\tisl_aff *aff_nan;\n\tisl_aff_list *list;\n\tint i, j;\n\n\tn_div_i = isl_basic_map_dim(bmap_i, isl_dim_div);\n\tn_div_j = isl_basic_map_dim(bmap_j, isl_dim_div);\n\ttotal = isl_basic_map_dim(bmap_i, isl_dim_all);\n\tif (!hull || n_div_i < 0 || n_div_j < 0 || total < 0)\n\t\treturn NULL;\n\n\tctx = isl_basic_map_get_ctx(hull);\n\ttotal -= n_div_i;\n\n\tls = isl_basic_map_get_local_space(bmap_i);\n\tls = isl_local_space_wrap(ls);\n\twrap_hull = isl_basic_map_wrap(hull);\n\n\taff_nan = isl_aff_nan_on_domain(isl_local_space_copy(ls));\n\tlist = isl_aff_list_alloc(ctx, n_div_i);\n\n\tj = 0;\n\tfor (i = 0; i < n_div_i; ++i) {\n\t\tisl_aff *aff;\n\t\tisl_size n_div;\n\n\t\tif (j < n_div_j &&\n\t\t    isl_basic_map_equal_div_expr_part(bmap_i, i, bmap_j, j,\n\t\t\t\t\t\t    0, 2 + total)) {\n\t\t\t++j;\n\t\t\tlist = isl_aff_list_add(list, isl_aff_copy(aff_nan));\n\t\t\tcontinue;\n\t\t}\n\t\tif (n_div_i - i <= n_div_j - j)\n\t\t\tbreak;\n\n\t\taff = isl_local_space_get_div(ls, i);\n\t\taff = isl_aff_substitute_equalities(aff,\n\t\t\t\t\t\tisl_basic_set_copy(wrap_hull));\n\t\taff = isl_aff_floor(aff);\n\t\tn_div = isl_aff_dim(aff, isl_dim_div);\n\t\tif (n_div < 0)\n\t\t\tgoto error;\n\t\tif (n_div != 0) {\n\t\t\tisl_aff_free(aff);\n\t\t\tbreak;\n\t\t}\n\n\t\tlist = isl_aff_list_add(list, aff);\n\t}\n\n\tisl_aff_free(aff_nan);\n\tisl_local_space_free(ls);\n\tisl_basic_set_free(wrap_hull);\n\n\treturn list;\nerror:\n\tisl_aff_free(aff_nan);\n\tisl_local_space_free(ls);\n\tisl_basic_set_free(wrap_hull);\n\tisl_aff_list_free(list);\n\treturn NULL;\n}\n\n/* Add variables to info->bmap and info->tab corresponding to the elements\n * in \"list\" that are not set to NaN.\n * \"extra_var\" is the number of these elements.\n * \"dim\" is the offset in the variables of \"tab\" where we should\n * start considering the elements in \"list\".\n * When this function returns, the total number of variables in \"tab\"\n * is equal to \"dim\" plus the number of elements in \"list\".\n *\n * The newly added existentially quantified variables are not given\n * an explicit representation because the corresponding div constraints\n * do not appear in info->bmap.  These constraints are not added\n * to info->bmap because for internal consistency, they would need to\n * be added to info->tab as well, where they could combine with the equality\n * that is added later to result in constraints that do not hold\n * in the original input.\n */\nstatic isl_stat add_sub_vars(struct isl_coalesce_info *info,\n\t__isl_keep isl_aff_list *list, int dim, int extra_var)\n{\n\tint i, j, d;\n\tisl_size n;\n\n\tinfo->bmap = isl_basic_map_cow(info->bmap);\n\tinfo->bmap = isl_basic_map_extend(info->bmap, extra_var, 0, 0);\n\tn = isl_aff_list_n_aff(list);\n\tif (!info->bmap || n < 0)\n\t\treturn isl_stat_error;\n\tfor (i = 0; i < n; ++i) {\n\t\tint is_nan;\n\t\tisl_aff *aff;\n\n\t\taff = isl_aff_list_get_aff(list, i);\n\t\tis_nan = isl_aff_is_nan(aff);\n\t\tisl_aff_free(aff);\n\t\tif (is_nan < 0)\n\t\t\treturn isl_stat_error;\n\t\tif (is_nan)\n\t\t\tcontinue;\n\n\t\tif (isl_tab_insert_var(info->tab, dim + i) < 0)\n\t\t\treturn isl_stat_error;\n\t\td = isl_basic_map_alloc_div(info->bmap);\n\t\tif (d < 0)\n\t\t\treturn isl_stat_error;\n\t\tinfo->bmap = isl_basic_map_mark_div_unknown(info->bmap, d);\n\t\tfor (j = d; j > i; --j)\n\t\t\tinfo->bmap = isl_basic_map_swap_div(info->bmap,\n\t\t\t\t\t\t\t    j - 1, j);\n\t\tif (!info->bmap)\n\t\t\treturn isl_stat_error;\n\t}\n\n\treturn isl_stat_ok;\n}\n\n/* For each element in \"list\" that is not set to NaN, fix the corresponding\n * variable in \"tab\" to the purely affine expression defined by the element.\n * \"dim\" is the offset in the variables of \"tab\" where we should\n * start considering the elements in \"list\".\n *\n * This function assumes that a sufficient number of rows and\n * elements in the constraint array are available in the tableau.\n */\nstatic isl_stat add_sub_equalities(struct isl_tab *tab,\n\t__isl_keep isl_aff_list *list, int dim)\n{\n\tint i;\n\tisl_size n;\n\tisl_ctx *ctx;\n\tisl_vec *sub;\n\tisl_aff *aff;\n\n\tn = isl_aff_list_n_aff(list);\n\tif (n < 0)\n\t\treturn isl_stat_error;\n\n\tctx = isl_tab_get_ctx(tab);\n\tsub = isl_vec_alloc(ctx, 1 + dim + n);\n\tif (!sub)\n\t\treturn isl_stat_error;\n\tisl_seq_clr(sub->el + 1 + dim, n);\n\n\tfor (i = 0; i < n; ++i) {\n\t\taff = isl_aff_list_get_aff(list, i);\n\t\tif (!aff)\n\t\t\tgoto error;\n\t\tif (isl_aff_is_nan(aff)) {\n\t\t\tisl_aff_free(aff);\n\t\t\tcontinue;\n\t\t}\n\t\tisl_seq_cpy(sub->el, aff->v->el + 1, 1 + dim);\n\t\tisl_int_neg(sub->el[1 + dim + i], aff->v->el[0]);\n\t\tif (isl_tab_add_eq(tab, sub->el) < 0)\n\t\t\tgoto error;\n\t\tisl_int_set_si(sub->el[1 + dim + i], 0);\n\t\tisl_aff_free(aff);\n\t}\n\n\tisl_vec_free(sub);\n\treturn isl_stat_ok;\nerror:\n\tisl_aff_free(aff);\n\tisl_vec_free(sub);\n\treturn isl_stat_error;\n}\n\n/* Add variables to info->tab and info->bmap corresponding to the elements\n * in \"list\" that are not set to NaN.  The value of the added variable\n * in info->tab is fixed to the purely affine expression defined by the element.\n * \"dim\" is the offset in the variables of info->tab where we should\n * start considering the elements in \"list\".\n * When this function returns, the total number of variables in info->tab\n * is equal to \"dim\" plus the number of elements in \"list\".\n */\nstatic isl_stat add_subs(struct isl_coalesce_info *info,\n\t__isl_keep isl_aff_list *list, int dim)\n{\n\tint extra_var;\n\tisl_size n;\n\n\tn = isl_aff_list_n_aff(list);\n\tif (n < 0)\n\t\treturn isl_stat_error;\n\n\textra_var = n - (info->tab->n_var - dim);\n\n\tif (isl_tab_extend_vars(info->tab, extra_var) < 0)\n\t\treturn isl_stat_error;\n\tif (isl_tab_extend_cons(info->tab, 2 * extra_var) < 0)\n\t\treturn isl_stat_error;\n\tif (add_sub_vars(info, list, dim, extra_var) < 0)\n\t\treturn isl_stat_error;\n\n\treturn add_sub_equalities(info->tab, list, dim);\n}\n\n/* Coalesce basic map \"j\" into basic map \"i\" after adding the extra integer\n * divisions in \"i\" but not in \"j\" to basic map \"j\", with values\n * specified by \"list\".  The total number of elements in \"list\"\n * is equal to the number of integer divisions in \"i\", while the number\n * of NaN elements in the list is equal to the number of integer divisions\n * in \"j\".\n *\n * If no coalescing can be performed, then we need to revert basic map \"j\"\n * to its original state.  We do the same if basic map \"i\" gets dropped\n * during the coalescing, even though this should not happen in practice\n * since we have already checked for \"j\" being a subset of \"i\"\n * before we reach this stage.\n */\nstatic enum isl_change coalesce_with_subs(int i, int j,\n\tstruct isl_coalesce_info *info, __isl_keep isl_aff_list *list)\n{\n\tisl_basic_map *bmap_j;\n\tstruct isl_tab_undo *snap;\n\tisl_size dim, n_div;\n\tenum isl_change change;\n\n\tbmap_j = isl_basic_map_copy(info[j].bmap);\n\tsnap = isl_tab_snap(info[j].tab);\n\n\tdim = isl_basic_map_dim(bmap_j, isl_dim_all);\n\tn_div = isl_basic_map_dim(bmap_j, isl_dim_div);\n\tif (dim < 0 || n_div < 0)\n\t\tgoto error;\n\tdim -= n_div;\n\tif (add_subs(&info[j], list, dim) < 0)\n\t\tgoto error;\n\n\tchange = coalesce_local_pair(i, j, info);\n\tif (change != isl_change_none && change != isl_change_drop_first) {\n\t\tisl_basic_map_free(bmap_j);\n\t} else {\n\t\tisl_basic_map_free(info[j].bmap);\n\t\tinfo[j].bmap = bmap_j;\n\n\t\tif (isl_tab_rollback(info[j].tab, snap) < 0)\n\t\t\treturn isl_change_error;\n\t}\n\n\treturn change;\nerror:\n\tisl_basic_map_free(bmap_j);\n\treturn isl_change_error;\n}\n\n/* Check if we can coalesce basic map \"j\" into basic map \"i\" after copying\n * those extra integer divisions in \"i\" that can be simplified away\n * using the extra equalities in \"j\".\n * All divs are assumed to be known and not contain any nested divs.\n *\n * We first check if there are any extra equalities in \"j\" that we\n * can exploit.  Then we check if every integer division in \"i\"\n * either already appears in \"j\" or can be simplified using the\n * extra equalities to a purely affine expression.\n * If these tests succeed, then we try to coalesce the two basic maps\n * by introducing extra dimensions in \"j\" corresponding to\n * the extra integer divisions \"i\" fixed to the corresponding\n * purely affine expression.\n */\nstatic enum isl_change check_coalesce_into_eq(int i, int j,\n\tstruct isl_coalesce_info *info)\n{\n\tisl_size n_div_i, n_div_j, n;\n\tisl_basic_map *hull_i, *hull_j;\n\tisl_bool equal, empty;\n\tisl_aff_list *list;\n\tenum isl_change change;\n\n\tn_div_i = isl_basic_map_dim(info[i].bmap, isl_dim_div);\n\tn_div_j = isl_basic_map_dim(info[j].bmap, isl_dim_div);\n\tif (n_div_i < 0 || n_div_j < 0)\n\t\treturn isl_change_error;\n\tif (n_div_i <= n_div_j)\n\t\treturn isl_change_none;\n\tif (info[j].bmap->n_eq == 0)\n\t\treturn isl_change_none;\n\n\thull_i = isl_basic_map_copy(info[i].bmap);\n\thull_i = isl_basic_map_plain_affine_hull(hull_i);\n\thull_j = isl_basic_map_copy(info[j].bmap);\n\thull_j = isl_basic_map_plain_affine_hull(hull_j);\n\n\thull_j = isl_basic_map_intersect(hull_j, isl_basic_map_copy(hull_i));\n\tequal = isl_basic_map_plain_is_equal(hull_i, hull_j);\n\tempty = isl_basic_map_plain_is_empty(hull_j);\n\tisl_basic_map_free(hull_i);\n\n\tif (equal < 0 || empty < 0)\n\t\tgoto error;\n\tif (equal || empty) {\n\t\tisl_basic_map_free(hull_j);\n\t\treturn isl_change_none;\n\t}\n\n\tlist = set_up_substitutions(info[i].bmap, info[j].bmap, hull_j);\n\tif (!list)\n\t\treturn isl_change_error;\n\tn = isl_aff_list_n_aff(list);\n\tif (n < 0)\n\t\tchange = isl_change_error;\n\telse if (n < n_div_i)\n\t\tchange = isl_change_none;\n\telse\n\t\tchange = coalesce_with_subs(i, j, info, list);\n\n\tisl_aff_list_free(list);\n\n\treturn change;\nerror:\n\tisl_basic_map_free(hull_j);\n\treturn isl_change_error;\n}\n\n/* Check if we can coalesce basic maps \"i\" and \"j\" after copying\n * those extra integer divisions in one of the basic maps that can\n * be simplified away using the extra equalities in the other basic map.\n * We require all divs to be known in both basic maps.\n * Furthermore, to simplify the comparison of div expressions,\n * we do not allow any nested integer divisions.\n */\nstatic enum isl_change check_coalesce_eq(int i, int j,\n\tstruct isl_coalesce_info *info)\n{\n\tisl_bool known, nested;\n\tenum isl_change change;\n\n\tknown = isl_basic_map_divs_known(info[i].bmap);\n\tif (known < 0 || !known)\n\t\treturn known < 0 ? isl_change_error : isl_change_none;\n\tknown = isl_basic_map_divs_known(info[j].bmap);\n\tif (known < 0 || !known)\n\t\treturn known < 0 ? isl_change_error : isl_change_none;\n\tnested = has_nested_div(info[i].bmap);\n\tif (nested < 0 || nested)\n\t\treturn nested < 0 ? isl_change_error : isl_change_none;\n\tnested = has_nested_div(info[j].bmap);\n\tif (nested < 0 || nested)\n\t\treturn nested < 0 ? isl_change_error : isl_change_none;\n\n\tchange = check_coalesce_into_eq(i, j, info);\n\tif (change != isl_change_none)\n\t\treturn change;\n\tchange = check_coalesce_into_eq(j, i, info);\n\tif (change != isl_change_none)\n\t\treturn invert_change(change);\n\n\treturn isl_change_none;\n}\n\n/* Check if the union of the given pair of basic maps\n * can be represented by a single basic map.\n * If so, replace the pair by the single basic map and return\n * isl_change_drop_first, isl_change_drop_second or isl_change_fuse.\n * Otherwise, return isl_change_none.\n *\n * We first check if the two basic maps live in the same local space,\n * after aligning the divs that differ by only an integer constant.\n * If so, we do the complete check.  Otherwise, we check if they have\n * the same number of integer divisions and can be coalesced, if one is\n * an obvious subset of the other or if the extra integer divisions\n * of one basic map can be simplified away using the extra equalities\n * of the other basic map.\n *\n * Note that trying to coalesce pairs of disjuncts with the same\n * number, but different local variables may drop the explicit\n * representation of some of these local variables.\n * This operation is therefore not performed when\n * the \"coalesce_preserve_locals\" option is set.\n */\nstatic enum isl_change coalesce_pair(int i, int j,\n\tstruct isl_coalesce_info *info)\n{\n\tint preserve;\n\tisl_bool same;\n\tenum isl_change change;\n\tisl_ctx *ctx;\n\n\tif (harmonize_divs(&info[i], &info[j]) < 0)\n\t\treturn isl_change_error;\n\tsame = same_divs(info[i].bmap, info[j].bmap);\n\tif (same < 0)\n\t\treturn isl_change_error;\n\tif (same)\n\t\treturn coalesce_local_pair(i, j, info);\n\n\tctx = isl_basic_map_get_ctx(info[i].bmap);\n\tpreserve = isl_options_get_coalesce_preserve_locals(ctx);\n\tif (!preserve && info[i].bmap->n_div == info[j].bmap->n_div) {\n\t\tchange = coalesce_local_pair(i, j, info);\n\t\tif (change != isl_change_none)\n\t\t\treturn change;\n\t}\n\n\tchange = coalesce_divs(i, j, info);\n\tif (change != isl_change_none)\n\t\treturn change;\n\n\treturn check_coalesce_eq(i, j, info);\n}\n\n/* Return the maximum of \"a\" and \"b\".\n */\nstatic int isl_max(int a, int b)\n{\n\treturn a > b ? a : b;\n}\n\n/* Pairwise coalesce the basic maps in the range [start1, end1[ of \"info\"\n * with those in the range [start2, end2[, skipping basic maps\n * that have been removed (either before or within this function).\n *\n * For each basic map i in the first range, we check if it can be coalesced\n * with respect to any previously considered basic map j in the second range.\n * If i gets dropped (because it was a subset of some j), then\n * we can move on to the next basic map.\n * If j gets dropped, we need to continue checking against the other\n * previously considered basic maps.\n * If the two basic maps got fused, then we recheck the fused basic map\n * against the previously considered basic maps, starting at i + 1\n * (even if start2 is greater than i + 1).\n */\nstatic int coalesce_range(isl_ctx *ctx, struct isl_coalesce_info *info,\n\tint start1, int end1, int start2, int end2)\n{\n\tint i, j;\n\n\tfor (i = end1 - 1; i >= start1; --i) {\n\t\tif (info[i].removed)\n\t\t\tcontinue;\n\t\tfor (j = isl_max(i + 1, start2); j < end2; ++j) {\n\t\t\tenum isl_change changed;\n\n\t\t\tif (info[j].removed)\n\t\t\t\tcontinue;\n\t\t\tif (info[i].removed)\n\t\t\t\tisl_die(ctx, isl_error_internal,\n\t\t\t\t\t\"basic map unexpectedly removed\",\n\t\t\t\t\treturn -1);\n\t\t\tchanged = coalesce_pair(i, j, info);\n\t\t\tswitch (changed) {\n\t\t\tcase isl_change_error:\n\t\t\t\treturn -1;\n\t\t\tcase isl_change_none:\n\t\t\tcase isl_change_drop_second:\n\t\t\t\tcontinue;\n\t\t\tcase isl_change_drop_first:\n\t\t\t\tj = end2;\n\t\t\t\tbreak;\n\t\t\tcase isl_change_fuse:\n\t\t\t\tj = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* Pairwise coalesce the basic maps described by the \"n\" elements of \"info\".\n *\n * We consider groups of basic maps that live in the same apparent\n * affine hull and we first coalesce within such a group before we\n * coalesce the elements in the group with elements of previously\n * considered groups.  If a fuse happens during the second phase,\n * then we also reconsider the elements within the group.\n */\nstatic int coalesce(isl_ctx *ctx, int n, struct isl_coalesce_info *info)\n{\n\tint start, end;\n\n\tfor (end = n; end > 0; end = start) {\n\t\tstart = end - 1;\n\t\twhile (start >= 1 &&\n\t\t    info[start - 1].hull_hash == info[start].hull_hash)\n\t\t\tstart--;\n\t\tif (coalesce_range(ctx, info, start, end, start, end) < 0)\n\t\t\treturn -1;\n\t\tif (coalesce_range(ctx, info, start, end, end, n) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/* Update the basic maps in \"map\" based on the information in \"info\".\n * In particular, remove the basic maps that have been marked removed and\n * update the others based on the information in the corresponding tableau.\n * Since we detected implicit equalities without calling\n * isl_basic_map_gauss, we need to do it now.\n * Also call isl_basic_map_simplify if we may have lost the definition\n * of one or more integer divisions.\n * If a basic map is still equal to the one from which the corresponding \"info\"\n * entry was created, then redundant constraint and\n * implicit equality constraint detection have been performed\n * on the corresponding tableau and the basic map can be marked as such.\n */\nstatic __isl_give isl_map *update_basic_maps(__isl_take isl_map *map,\n\tint n, struct isl_coalesce_info *info)\n{\n\tint i;\n\n\tif (!map)\n\t\treturn NULL;\n\n\tfor (i = n - 1; i >= 0; --i) {\n\t\tif (info[i].removed) {\n\t\t\tisl_basic_map_free(map->p[i]);\n\t\t\tif (i != map->n - 1)\n\t\t\t\tmap->p[i] = map->p[map->n - 1];\n\t\t\tmap->n--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinfo[i].bmap = isl_basic_map_update_from_tab(info[i].bmap,\n\t\t\t\t\t\t\tinfo[i].tab);\n\t\tinfo[i].bmap = isl_basic_map_gauss(info[i].bmap, NULL);\n\t\tif (info[i].simplify)\n\t\t\tinfo[i].bmap = isl_basic_map_simplify(info[i].bmap);\n\t\tinfo[i].bmap = isl_basic_map_finalize(info[i].bmap);\n\t\tif (!info[i].bmap)\n\t\t\treturn isl_map_free(map);\n\t\tif (!info[i].modified) {\n\t\t\tISL_F_SET(info[i].bmap, ISL_BASIC_MAP_NO_IMPLICIT);\n\t\t\tISL_F_SET(info[i].bmap, ISL_BASIC_MAP_NO_REDUNDANT);\n\t\t}\n\t\tisl_basic_map_free(map->p[i]);\n\t\tmap->p[i] = info[i].bmap;\n\t\tinfo[i].bmap = NULL;\n\t}\n\n\treturn map;\n}\n\n/* For each pair of basic maps in the map, check if the union of the two\n * can be represented by a single basic map.\n * If so, replace the pair by the single basic map and start over.\n *\n * We factor out any (hidden) common factor from the constraint\n * coefficients to improve the detection of adjacent constraints.\n * Note that this function does not call isl_basic_map_gauss,\n * but it does make sure that only a single copy of the basic map\n * is affected.  This means that isl_basic_map_gauss may have\n * to be called at the end of the computation (in update_basic_maps)\n * on this single copy to ensure that\n * the basic maps are not left in an unexpected state.\n *\n * Since we are constructing the tableaus of the basic maps anyway,\n * we exploit them to detect implicit equalities and redundant constraints.\n * This also helps the coalescing as it can ignore the redundant constraints.\n * In order to avoid confusion, we make all implicit equalities explicit\n * in the basic maps.  If the basic map only has a single reference\n * (this happens in particular if it was modified by\n * isl_basic_map_reduce_coefficients), then isl_basic_map_gauss\n * does not get called on the result.  The call to\n * isl_basic_map_gauss in update_basic_maps resolves this as well.\n * For each basic map, we also compute the hash of the apparent affine hull\n * for use in coalesce.\n */\n__isl_give isl_map *isl_map_coalesce(__isl_take isl_map *map)\n{\n\tint i;\n\tunsigned n;\n\tisl_ctx *ctx;\n\tstruct isl_coalesce_info *info = NULL;\n\n\tmap = isl_map_remove_empty_parts(map);\n\tif (!map)\n\t\treturn NULL;\n\n\tif (map->n <= 1)\n\t\treturn map;\n\n\tctx = isl_map_get_ctx(map);\n\tmap = isl_map_sort_divs(map);\n\tmap = isl_map_cow(map);\n\n\tif (!map)\n\t\treturn NULL;\n\n\tn = map->n;\n\n\tinfo = isl_calloc_array(map->ctx, struct isl_coalesce_info, n);\n\tif (!info)\n\t\tgoto error;\n\n\tfor (i = 0; i < map->n; ++i) {\n\t\tmap->p[i] = isl_basic_map_reduce_coefficients(map->p[i]);\n\t\tif (!map->p[i])\n\t\t\tgoto error;\n\t\tinfo[i].bmap = isl_basic_map_copy(map->p[i]);\n\t\tinfo[i].tab = isl_tab_from_basic_map(info[i].bmap, 0);\n\t\tif (!info[i].tab)\n\t\t\tgoto error;\n\t\tif (!ISL_F_ISSET(info[i].bmap, ISL_BASIC_MAP_NO_IMPLICIT))\n\t\t\tif (isl_tab_detect_implicit_equalities(info[i].tab) < 0)\n\t\t\t\tgoto error;\n\t\tinfo[i].bmap = isl_tab_make_equalities_explicit(info[i].tab,\n\t\t\t\t\t\t\t\tinfo[i].bmap);\n\t\tif (!info[i].bmap)\n\t\t\tgoto error;\n\t\tif (!ISL_F_ISSET(info[i].bmap, ISL_BASIC_MAP_NO_REDUNDANT))\n\t\t\tif (isl_tab_detect_redundant(info[i].tab) < 0)\n\t\t\t\tgoto error;\n\t\tif (coalesce_info_set_hull_hash(&info[i]) < 0)\n\t\t\tgoto error;\n\t}\n\tfor (i = map->n - 1; i >= 0; --i)\n\t\tif (info[i].tab->empty)\n\t\t\tdrop(&info[i]);\n\n\tif (coalesce(ctx, n, info) < 0)\n\t\tgoto error;\n\n\tmap = update_basic_maps(map, n, info);\n\n\tclear_coalesce_info(n, info);\n\n\treturn map;\nerror:\n\tclear_coalesce_info(n, info);\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n/* For each pair of basic sets in the set, check if the union of the two\n * can be represented by a single basic set.\n * If so, replace the pair by the single basic set and start over.\n */\n__isl_give isl_set *isl_set_coalesce(__isl_take isl_set *set)\n{\n\treturn set_from_map(isl_map_coalesce(set_to_map(set)));\n}\n"}}, "reports": [{"events": [{"location": {"col": 16, "file": 0, "line": 82}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "b6ce60b0f76e040bf03d302dde5d1656", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 0, "line": 111}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "cf7a79fd08292df8ac3e447daeb9d2ba", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 0, "line": 133}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "4f7ddaca02847aa5d98aeab15625270e", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 0, "line": 146}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "4f7ddaca02847aa5d98aeab15625270e", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 0, "line": 157}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "4f7ddaca02847aa5d98aeab15625270e", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 0, "line": 167}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "26edf75fddb9032592e0776b2f1395b7", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 0, "line": 291}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "5fe57ae42b15e7b471d463fbc44e46ff", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 0, "line": 301}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "453f33ce9558a576ab200621b4a36556", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 0, "line": 437}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "9f9d620552abd10c88ff73cb6ff4715c", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 0, "line": 457}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "54aaba30a28d056c14eb2633a795742f", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 0, "line": 483}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "7c8cffce79959f1a8f0eec8c35fedc45", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 0, "line": 539}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "e405024d9f31dd24877236d023258320", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 0, "line": 553}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "41c0768f48582ababca62a6d54c85640", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 0, "line": 636}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "a74e1fd68d180fb2ea1744f24efc44d9", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 17, "file": 0, "line": 641}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "174bbde399b04ceb71ec7b28f90bfbf5", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 0, "line": 653}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "10a08e09d751e0108cd913157674a46f", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 8, "file": 0, "line": 657}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "7e90e2d7f6798609a4f45e7d83a8a0d6", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 0, "line": 680}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "dd023a6840af5f72cc2f1c3467659c46", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 0, "line": 696}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "9fc3e7f1c32375c5f6172ba05f272564", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 0, "line": 843}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "b1c0c88eef1894f8b447b16f4cf8e2fd", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 0, "line": 1003}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "453f33ce9558a576ab200621b4a36556", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 0, "line": 1055}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "e9546eec0cc576e7430a4d5b1c7b1dbb", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 0, "line": 1193}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "9f9d620552abd10c88ff73cb6ff4715c", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 0, "line": 1202}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "54aaba30a28d056c14eb2633a795742f", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 0, "line": 1276}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "cf106fe1483c138dad95be1aa3ff512c", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 0, "line": 1357}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "a59095aaf4eed2c2708d1582591f9326", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 0, "line": 1377}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "55ea6d7dde8c8377672b6a3ce5a97fb5", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 0, "line": 1886}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "9afc72051977f6009c27fa512c80a01d", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 0, "line": 1905}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "a74e1fd68d180fb2ea1744f24efc44d9", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 0, "line": 2062}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "9afc72051977f6009c27fa512c80a01d", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 0, "line": 2084}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "a74e1fd68d180fb2ea1744f24efc44d9", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 0, "line": 2127}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "86c75289fdc2986818eddb58e752021f", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 0, "line": 2410}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "453f33ce9558a576ab200621b4a36556", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 0, "line": 2863}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "282eb73ca3494feba08760cc760cd704", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 8, "file": 0, "line": 2890}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "7aed99a40b1f6cb174d3a1b4a1d91dcb", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 0, "line": 2984}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "655bd831b9e00873c31758859019eacd", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 21, "file": 0, "line": 3003}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "7364de0ea751a747944e362bc9dcc0c4", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 18, "file": 0, "line": 3173}, "message": "ordered comparison between pointer and zero ('isl_basic_map *' (aka 'struct isl_basic_map *') and 'int') is an extension"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_coalesce.c", "reportHash": "a5518af56c890f237a6af28605e8399c", "checkerName": "clang-diagnostic-pedantic", "reviewStatus": null, "severity": "MEDIUM"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
