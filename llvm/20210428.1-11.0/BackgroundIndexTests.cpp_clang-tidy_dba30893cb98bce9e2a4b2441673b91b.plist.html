<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/home/vsts/work/1/build/include/llvm/Config/abi-breaking.h", "content": "/*===------- llvm/Config/abi-breaking.h - llvm configuration -------*- C -*-===*/\n/*                                                                            */\n/* Part of the LLVM Project, under the Apache License v2.0 with LLVM          */\n/* Exceptions.                                                                */\n/* See https://llvm.org/LICENSE.txt for license information.                  */\n/* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception                    */\n/*                                                                            */\n/*===----------------------------------------------------------------------===*/\n\n/* This file controls the C++ ABI break introduced in LLVM public header. */\n\n#ifndef LLVM_ABI_BREAKING_CHECKS_H\n#define LLVM_ABI_BREAKING_CHECKS_H\n\n/* Define to enable checks that alter the LLVM C++ ABI */\n#define LLVM_ENABLE_ABI_BREAKING_CHECKS 0\n\n/* Define to enable reverse iteration of unordered llvm containers */\n#define LLVM_ENABLE_REVERSE_ITERATION 0\n\n/* Allow selectively disabling link-time mismatch checking so that header-only\n   ADT content from LLVM can be used without linking libSupport. */\n#if !defined(LLVM_DISABLE_ABI_BREAKING_CHECKS_ENFORCING) || !LLVM_DISABLE_ABI_BREAKING_CHECKS_ENFORCING\n\n// ABI_BREAKING_CHECKS protection: provides link-time failure when clients build\n// mismatch with LLVM\n#if defined(_MSC_VER)\n// Use pragma with MSVC\n#define LLVM_XSTR(s) LLVM_STR(s)\n#define LLVM_STR(s) #s\n#pragma detect_mismatch(\"LLVM_ENABLE_ABI_BREAKING_CHECKS\", LLVM_XSTR(LLVM_ENABLE_ABI_BREAKING_CHECKS))\n#undef LLVM_XSTR\n#undef LLVM_STR\n#elif defined(_WIN32) || defined(__CYGWIN__) // Win32 w/o #pragma detect_mismatch\n// FIXME: Implement checks without weak.\n#elif defined(__cplusplus)\n#if !(defined(_AIX) && defined(__GNUC__) && !defined(__clang__))\n#define LLVM_HIDDEN_VISIBILITY __attribute__ ((visibility(\"hidden\")))\n#else\n// GCC on AIX does not support visibility attributes. Symbols are not\n// exported by default on AIX.\n#define LLVM_HIDDEN_VISIBILITY\n#endif\nnamespace llvm {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\nextern int EnableABIBreakingChecks;\nLLVM_HIDDEN_VISIBILITY\n__attribute__((weak)) int *VerifyEnableABIBreakingChecks =\n    &EnableABIBreakingChecks;\n#else\nextern int DisableABIBreakingChecks;\nLLVM_HIDDEN_VISIBILITY\n__attribute__((weak)) int *VerifyDisableABIBreakingChecks =\n    &DisableABIBreakingChecks;\n#endif\n}\n#undef LLVM_HIDDEN_VISIBILITY\n#endif // _MSC_VER\n\n#endif // LLVM_DISABLE_ABI_BREAKING_CHECKS_ENFORCING\n\n#endif\n"}, "1": {"id": 1, "path": "/home/vsts/work/1/build/include/llvm/Config/llvm-config.h", "content": "/*===------- llvm/Config/llvm-config.h - llvm configuration -------*- C -*-===*/\n/*                                                                            */\n/* Part of the LLVM Project, under the Apache License v2.0 with LLVM          */\n/* Exceptions.                                                                */\n/* See https://llvm.org/LICENSE.txt for license information.                  */\n/* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception                    */\n/*                                                                            */\n/*===----------------------------------------------------------------------===*/\n\n/* This file enumerates variables from the LLVM configuration so that they\n   can be in exported headers and won't override package specific directives.\n   This is a C header that can be included in the llvm-c headers. */\n\n#ifndef LLVM_CONFIG_H\n#define LLVM_CONFIG_H\n\n/* Define if LLVM_ENABLE_DUMP is enabled */\n/* #undef LLVM_ENABLE_DUMP */\n\n/* Target triple LLVM will generate code for by default */\n#define LLVM_DEFAULT_TARGET_TRIPLE \"x86_64-unknown-linux-gnu\"\n\n/* Define if threads enabled */\n#define LLVM_ENABLE_THREADS 1\n\n/* Has gcc/MSVC atomic intrinsics */\n#define LLVM_HAS_ATOMICS 1\n\n/* Host triple LLVM will be executed on */\n#define LLVM_HOST_TRIPLE \"x86_64-unknown-linux-gnu\"\n\n/* LLVM architecture name for the native architecture, if available */\n#define LLVM_NATIVE_ARCH X86\n\n/* LLVM name for the native AsmParser init function, if available */\n#define LLVM_NATIVE_ASMPARSER LLVMInitializeX86AsmParser\n\n/* LLVM name for the native AsmPrinter init function, if available */\n#define LLVM_NATIVE_ASMPRINTER LLVMInitializeX86AsmPrinter\n\n/* LLVM name for the native Disassembler init function, if available */\n#define LLVM_NATIVE_DISASSEMBLER LLVMInitializeX86Disassembler\n\n/* LLVM name for the native Target init function, if available */\n#define LLVM_NATIVE_TARGET LLVMInitializeX86Target\n\n/* LLVM name for the native TargetInfo init function, if available */\n#define LLVM_NATIVE_TARGETINFO LLVMInitializeX86TargetInfo\n\n/* LLVM name for the native target MC init function, if available */\n#define LLVM_NATIVE_TARGETMC LLVMInitializeX86TargetMC\n\n/* Define if this is Unixish platform */\n#define LLVM_ON_UNIX 1\n\n/* Define if we have the Intel JIT API runtime support library */\n#define LLVM_USE_INTEL_JITEVENTS 0\n\n/* Define if we have the oprofile JIT-support library */\n#define LLVM_USE_OPROFILE 0\n\n/* Define if we have the perf JIT-support library */\n#define LLVM_USE_PERF 0\n\n/* Major version of the LLVM API */\n#define LLVM_VERSION_MAJOR 13\n\n/* Minor version of the LLVM API */\n#define LLVM_VERSION_MINOR 0\n\n/* Patch version of the LLVM API */\n#define LLVM_VERSION_PATCH 0\n\n/* LLVM version string */\n#define LLVM_VERSION_STRING \"13.0.0git\"\n\n/* Whether LLVM records statistics for use with GetStatistics(),\n * PrintStatistics() or PrintStatisticsJSON()\n */\n#define LLVM_FORCE_ENABLE_STATS 0\n\n/* Define if we have z3 and want to build it */\n/* #undef LLVM_WITH_Z3 */\n\n/* Define if LLVM was built with a dependency to the libtensorflow dynamic library */\n/* #undef LLVM_HAVE_TF_API */\n\n/* Define if LLVM was built with a dependency to the tensorflow compiler */\n/* #undef LLVM_HAVE_TF_AOT */\n\n/* Define to 1 if you have the <sysexits.h> header file. */\n#define HAVE_SYSEXITS_H 1\n\n/* Define to 1 to enable the experimental new pass manager by default */\n#define LLVM_ENABLE_NEW_PASS_MANAGER 1\n\n#endif\n"}, "2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/CollectMacros.h", "content": "//===--- CollectMacros.h -----------------------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_COLLECTEDMACROS_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_COLLECTEDMACROS_H\n\n#include \"AST.h\"\n#include \"Protocol.h\"\n#include \"SourceCode.h\"\n#include \"index/SymbolID.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Lex/PPCallbacks.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include <string>\n\nnamespace clang {\nnamespace clangd {\n\nstruct MacroOccurrence {\n  // Instead of storing SourceLocation, we have to store the token range because\n  // SourceManager from preamble is not available when we build the AST.\n  Range Rng;\n  bool IsDefinition;\n};\n\nstruct MainFileMacros {\n  llvm::StringSet<> Names;\n  llvm::DenseMap<SymbolID, std::vector<MacroOccurrence>> MacroRefs;\n  // Somtimes it is not possible to compute the SymbolID for the Macro, e.g. a\n  // reference to an undefined macro. Store them separately, e.g. for semantic\n  // highlighting.\n  std::vector<MacroOccurrence> UnknownMacros;\n  // Ranges skipped by the preprocessor due to being inactive.\n  std::vector<Range> SkippedRanges;\n};\n\n/// Collects macro references (e.g. definitions, expansions) in the main file.\n/// It is used to:\n///  - collect macros in the preamble section of the main file (in Preamble.cpp)\n///  - collect macros after the preamble of the main file (in ParsedAST.cpp)\nclass CollectMainFileMacros : public PPCallbacks {\npublic:\n  explicit CollectMainFileMacros(const SourceManager &SM, MainFileMacros &Out)\n      : SM(SM), Out(Out) {}\n\n  void FileChanged(SourceLocation Loc, FileChangeReason,\n                   SrcMgr::CharacteristicKind, FileID) override {\n    InMainFile = isInsideMainFile(Loc, SM);\n  }\n\n  void MacroDefined(const Token &MacroName, const MacroDirective *MD) override {\n    add(MacroName, MD->getMacroInfo(), /*IsDefinition=*/true);\n  }\n\n  void MacroExpands(const Token &MacroName, const MacroDefinition &MD,\n                    SourceRange Range, const MacroArgs *Args) override {\n    add(MacroName, MD.getMacroInfo());\n  }\n\n  void MacroUndefined(const clang::Token &MacroName,\n                      const clang::MacroDefinition &MD,\n                      const clang::MacroDirective *Undef) override {\n    add(MacroName, MD.getMacroInfo());\n  }\n\n  void Ifdef(SourceLocation Loc, const Token &MacroName,\n             const MacroDefinition &MD) override {\n    add(MacroName, MD.getMacroInfo());\n  }\n\n  void Ifndef(SourceLocation Loc, const Token &MacroName,\n              const MacroDefinition &MD) override {\n    add(MacroName, MD.getMacroInfo());\n  }\n\n  void Defined(const Token &MacroName, const MacroDefinition &MD,\n               SourceRange Range) override {\n    add(MacroName, MD.getMacroInfo());\n  }\n\n  void SourceRangeSkipped(SourceRange R, SourceLocation EndifLoc) override {\n    if (!InMainFile)\n      return;\n    Position Begin = sourceLocToPosition(SM, R.getBegin());\n    Position End = sourceLocToPosition(SM, R.getEnd());\n    Out.SkippedRanges.push_back(Range{Begin, End});\n  }\n\nprivate:\n  void add(const Token &MacroNameTok, const MacroInfo *MI,\n           bool IsDefinition = false);\n  const SourceManager &SM;\n  bool InMainFile = true;\n  MainFileMacros &Out;\n};\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_COLLECTEDMACROS_H\n"}, "3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/ExpectedTypes.h", "content": "//===--- ExpectedTypes.h - Simplified C++ types -----------------*- C++-*--===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n// A simplified model of C++ types that can be used to check whether they are\n// convertible between each other for the purposes of code completion ranking\n// without looking at the ASTs. Note that we don't aim to fully mimic the C++\n// conversion rules, merely try to have a model that gives useful improvements\n// to the code completion ranking.\n//\n// We define an encoding of AST types as opaque strings, which can be stored in\n// the index. Similar types (such as `int` and `long`) are folded together,\n// forming equivalence classes with the same encoding.\n//===----------------------------------------------------------------------===//\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_EXPECTED_TYPES_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_EXPECTED_TYPES_H\n\n#include \"clang/AST/Type.h\"\n#include \"llvm/ADT/StringRef.h\"\n\nnamespace clang {\nclass CodeCompletionResult;\n\nnamespace clangd {\n/// A representation of a type that can be computed based on clang AST and\n/// compared for equality. The encoding is stable between different ASTs, this\n/// allows the representation to be stored in the index and compared with types\n/// coming from a different AST later.\n/// OpaqueType is a strongly-typedefed std::string, you can get the underlying\n/// string with raw().\nclass OpaqueType {\npublic:\n  /// Create a type from a code completion result.\n  static llvm::Optional<OpaqueType>\n  fromCompletionResult(ASTContext &Ctx, const CodeCompletionResult &R);\n  /// Construct an instance from a clang::QualType. This is usually a\n  /// PreferredType from a clang's completion context.\n  static llvm::Optional<OpaqueType> fromType(ASTContext &Ctx, QualType Type);\n\n  /// Get the raw byte representation of the type. You can only rely on the\n  /// types being equal iff their raw representation is the same. The particular\n  /// details of the used encoding might change over time and one should not\n  /// rely on it.\n  llvm::StringRef raw() const { return Data; }\n\n  friend bool operator==(const OpaqueType &L, const OpaqueType &R) {\n    return L.Data == R.Data;\n  }\n  friend bool operator!=(const OpaqueType &L, const OpaqueType &R) {\n    return !(L == R);\n  }\n\nprivate:\n  static llvm::Optional<OpaqueType> encode(ASTContext &Ctx, QualType Type);\n  explicit OpaqueType(std::string Data);\n\n  std::string Data;\n};\n} // namespace clangd\n} // namespace clang\n#endif\n"}, "4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/HeuristicResolver.h", "content": "//===--- HeuristicResolver.h - Resolution of dependent names -----*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_HEURISTIC_RESOLVER_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_HEURISTIC_RESOLVER_H\n\n#include \"clang/AST/Decl.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include <vector>\n\nnamespace clang {\n\nclass ASTContext;\nclass CallExpr;\nclass CXXDependentScopeMemberExpr;\nclass DeclarationName;\nclass DependentScopeDeclRefExpr;\nclass NamedDecl;\nclass Type;\nclass UnresolvedUsingValueDecl;\n\nnamespace clangd {\n\n// This class heuristic resolution of declarations and types in template code.\n//\n// As a compiler, clang only needs to perform certain types of processing on\n// template code (such as resolving dependent names to declarations, or\n// resolving the type of a dependent expression) after instantiation. Indeed,\n// C++ language features such as template specialization mean such resolution\n// cannot be done accurately before instantiation\n//\n// However, template code is written and read in uninstantiated form, and clangd\n// would like to provide editor features like go-to-definition in template code\n// where possible. To this end, clangd attempts to resolve declarations and\n// types in uninstantiated code by using heuristics, understanding that the\n// results may not be fully accurate but that this is better than nothing.\n//\n// At this time, the heuristic used is a simple but effective one: assume that\n// template instantiations are based on the primary template definition and not\n// not a specialization. More advanced heuristics may be added in the future.\nclass HeuristicResolver {\npublic:\n  HeuristicResolver(ASTContext &Ctx) : Ctx(Ctx) {}\n\n  // Try to heuristically resolve certain types of expressions, declarations, or\n  // types to one or more likely-referenced declarations.\n  std::vector<const NamedDecl *>\n  resolveMemberExpr(const CXXDependentScopeMemberExpr *ME) const;\n  std::vector<const NamedDecl *>\n  resolveDeclRefExpr(const DependentScopeDeclRefExpr *RE) const;\n  std::vector<const NamedDecl *>\n  resolveTypeOfCallExpr(const CallExpr *CE) const;\n  std::vector<const NamedDecl *>\n  resolveUsingValueDecl(const UnresolvedUsingValueDecl *UUVD) const;\n  std::vector<const NamedDecl *>\n  resolveDependentNameType(const DependentNameType *DNT) const;\n  std::vector<const NamedDecl *> resolveTemplateSpecializationType(\n      const DependentTemplateSpecializationType *DTST) const;\n\n  // Try to heuristically resolve a dependent nested name specifier\n  // to the type it likely denotes. Note that *dependent* name specifiers always\n  // denote types, not namespaces.\n  const Type *\n  resolveNestedNameSpecifierToType(const NestedNameSpecifier *NNS) const;\n\nprivate:\n  ASTContext &Ctx;\n\n  // Given a tag-decl type and a member name, heuristically resolve the\n  // name to one or more declarations.\n  // The current heuristic is simply to look up the name in the primary\n  // template. This is a heuristic because the template could potentially\n  // have specializations that declare different members.\n  // Multiple declarations could be returned if the name is overloaded\n  // (e.g. an overloaded method in the primary template).\n  // This heuristic will give the desired answer in many cases, e.g.\n  // for a call to vector<T>::size().\n  std::vector<const NamedDecl *> resolveDependentMember(\n      const Type *T, DeclarationName Name,\n      llvm::function_ref<bool(const NamedDecl *ND)> Filter) const;\n\n  // Try to heuristically resolve the type of a possibly-dependent expression\n  // `E`.\n  const Type *resolveExprToType(const Expr *E) const;\n\n  // Given the type T of a dependent expression that appears of the LHS of a\n  // \"->\", heuristically find a corresponding pointee type in whose scope we\n  // could look up the name appearing on the RHS.\n  const Type *getPointeeType(const Type *T) const;\n};\n\n} // namespace clangd\n} // namespace clang\n\n#endif\n"}, "5": {"id": 5, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/URI.h", "content": "//===--- URI.h - File URIs with schemes --------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_PATHURI_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_PATHURI_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/Registry.h\"\n\nnamespace clang {\nnamespace clangd {\n\n/// A URI describes the location of a source file.\n/// In the simplest case, this is a \"file\" URI that directly encodes the\n/// absolute path to a file. More abstract cases are possible: a shared index\n/// service might expose repo:// URIs that are relative to the source control\n/// root.\n///\n/// Clangd handles URIs of the form <scheme>:[//<authority>]<body>. It doesn't\n/// further split the authority or body into constituent parts (e.g. query\n/// strings is included in the body).\nclass URI {\npublic:\n  URI(llvm::StringRef Scheme, llvm::StringRef Authority, llvm::StringRef Body);\n\n  /// Returns decoded scheme e.g. \"https\"\n  llvm::StringRef scheme() const { return Scheme; }\n  /// Returns decoded authority e.g. \"reviews.lvm.org\"\n  llvm::StringRef authority() const { return Authority; }\n  /// Returns decoded body e.g. \"/D41946\"\n  llvm::StringRef body() const { return Body; }\n\n  /// Returns a string URI with all components percent-encoded.\n  std::string toString() const;\n\n  /// Creates a URI for a file in the given scheme. \\p Scheme must be\n  /// registered. The URI is percent-encoded.\n  static llvm::Expected<URI> create(llvm::StringRef AbsolutePath,\n                                    llvm::StringRef Scheme);\n\n  // Similar to above except this picks a registered scheme that works. If none\n  // works, this falls back to \"file\" scheme.\n  static URI create(llvm::StringRef AbsolutePath);\n\n  /// This creates a file:// URI for \\p AbsolutePath. The path must be absolute.\n  static URI createFile(llvm::StringRef AbsolutePath);\n\n  /// Parse a URI string \"<scheme>:[//<authority>/]<path>\". Percent-encoded\n  /// characters in the URI will be decoded.\n  static llvm::Expected<URI> parse(llvm::StringRef Uri);\n\n  /// Resolves the absolute path of \\p U. If there is no matching scheme, or the\n  /// URI is invalid in the scheme, this returns an error.\n  ///\n  /// \\p HintPath A related path, such as the current file or working directory,\n  /// which can help disambiguate when the same file exists in many workspaces.\n  static llvm::Expected<std::string> resolve(const URI &U,\n                                             llvm::StringRef HintPath = \"\");\n\n  /// Same as above, in addition it parses the \\p FileURI using URI::parse.\n  static llvm::Expected<std::string> resolve(llvm::StringRef FileURI,\n                                             llvm::StringRef HintPath = \"\");\n\n  /// Resolves \\p AbsPath into a canonical path of its URI, by converting\n  /// \\p AbsPath to URI and resolving the URI to get th canonical path.\n  /// This ensures that paths with the same URI are resolved into consistent\n  /// file path.\n  static llvm::Expected<std::string> resolvePath(llvm::StringRef AbsPath,\n                                                 llvm::StringRef HintPath = \"\");\n\n  /// Gets the preferred spelling of this file for #include, if there is one,\n  /// e.g. <system_header.h>, \"path/to/x.h\".\n  ///\n  /// This allows URI schemas to provide their customized include paths.\n  ///\n  /// Returns an empty string if normal include-shortening based on the absolute\n  /// path should be used.\n  /// Fails if the URI is not valid in the schema.\n  static llvm::Expected<std::string> includeSpelling(const URI &U);\n\n  friend bool operator==(const URI &LHS, const URI &RHS) {\n    return std::tie(LHS.Scheme, LHS.Authority, LHS.Body) ==\n           std::tie(RHS.Scheme, RHS.Authority, RHS.Body);\n  }\n\n  friend bool operator<(const URI &LHS, const URI &RHS) {\n    return std::tie(LHS.Scheme, LHS.Authority, LHS.Body) <\n           std::tie(RHS.Scheme, RHS.Authority, RHS.Body);\n  }\n\nprivate:\n  URI() = default;\n\n  std::string Scheme;\n  std::string Authority;\n  std::string Body;\n};\n\n/// URIScheme is an extension point for teaching clangd to recognize a custom\n/// URI scheme. This is expected to be implemented and exposed via the\n/// URISchemeRegistry.\nclass URIScheme {\npublic:\n  virtual ~URIScheme() = default;\n\n  /// Returns the absolute path of the file corresponding to the URI\n  /// authority+body in the file system. See URI::resolve for semantics of\n  /// \\p HintPath.\n  virtual llvm::Expected<std::string>\n  getAbsolutePath(llvm::StringRef Authority, llvm::StringRef Body,\n                  llvm::StringRef HintPath) const = 0;\n\n  virtual llvm::Expected<URI>\n  uriFromAbsolutePath(llvm::StringRef AbsolutePath) const = 0;\n\n  /// Returns the include path of the file (e.g. <path>, \"path\"), which can be\n  /// #included directly. See URI::includeSpelling for details.\n  virtual llvm::Expected<std::string> getIncludeSpelling(const URI &U) const {\n    return \"\"; // no customized include path for this scheme.\n  }\n};\n\n/// By default, a \"file\" scheme is supported where URI paths are always absolute\n/// in the file system.\ntypedef llvm::Registry<URIScheme> URISchemeRegistry;\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_PATHURI_H\n"}, "6": {"id": 6, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/BackgroundRebuild.h", "content": "//===--- BackgroundIndexRebuild.h - when to rebuild the bg index--*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains an implementation detail of the background indexer\n// (Background.h), which is exposed for testing.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_BACKGROUND_INDEX_REBUILD_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_BACKGROUND_INDEX_REBUILD_H\n\n#include \"index/FileIndex.h\"\n#include \"index/Index.h\"\n#include \"llvm/Support/Threading.h\"\n#include <cstddef>\n\nnamespace clang {\nnamespace clangd {\n\n// The BackgroundIndexRebuilder builds the serving data structures periodically\n// in response to events in the background indexer. The goal is to ensure the\n// served data stays fairly fresh, without wasting lots of CPU rebuilding it\n// often.\n//\n// The index is always built after a set of shards are loaded from disk.\n// This happens when clangd discovers a compilation database that we've\n// previously built an index for. It's a fairly fast process that yields lots\n// of data, so we wait to get all of it.\n//\n// The index is built after indexing a few translation units, if it wasn't built\n// already. This ensures quick startup if there's no existing index.\n// Waiting for a few random TUs yields coverage of the most common headers.\n//\n// The index is rebuilt every N TUs, to keep if fresh as files are indexed.\n//\n// The index is rebuilt every time the queue goes idle, if it's stale.\n//\n// All methods are threadsafe. They're called after FileSymbols is updated\n// etc. Without external locking, the rebuilt index may include more updates\n// than intended, which is fine.\n//\n// This class is exposed in the header so it can be tested.\nclass BackgroundIndexRebuilder {\npublic:\n  BackgroundIndexRebuilder(SwapIndex *Target, FileSymbols *Source,\n                           unsigned Threads)\n      : TUsBeforeFirstBuild(Threads), Target(Target), Source(Source) {}\n\n  // Called to indicate a TU has been indexed.\n  // May rebuild, if enough TUs have been indexed.\n  void indexedTU();\n  // Called to indicate that all worker threads are idle.\n  // May reindex, if the index is not up to date.\n  void idle();\n  // Called to indicate we're going to load a batch of shards from disk.\n  // startLoading() and doneLoading() must be paired, but multiple loading\n  // sessions may happen concurrently.\n  void startLoading();\n  // Called to indicate some shards were actually loaded from disk.\n  void loadedShard(size_t ShardCount);\n  // Called to indicate we're finished loading shards from disk.\n  // May rebuild (if any were loaded).\n  void doneLoading();\n\n  // Ensures we won't start any more rebuilds.\n  void shutdown();\n\n  // Thresholds for rebuilding as TUs get indexed. Exposed for testing.\n  const unsigned TUsBeforeFirstBuild; // Typically one per worker thread.\n  const unsigned TUsBeforeRebuild = 100;\n\nprivate:\n  // Run Check under the lock, and rebuild if it returns true.\n  void maybeRebuild(const char *Reason, std::function<bool()> Check);\n  bool enoughTUsToRebuild() const;\n\n  // All transient state is guarded by the mutex.\n  std::mutex Mu;\n  bool ShouldStop = false;\n  // Index builds are versioned. ActiveVersion chases StartedVersion.\n  unsigned StartedVersion = 0;\n  unsigned ActiveVersion = 0;\n  // How many TUs have we indexed so far since startup?\n  unsigned IndexedTUs = 0;\n  unsigned IndexedTUsAtLastRebuild = 0;\n  // Are we loading shards? May be multiple concurrent sessions.\n  unsigned Loading = 0;\n  unsigned LoadedShards; // In the current loading session.\n\n  SwapIndex *Target;\n  FileSymbols *Source;\n};\n\n} // namespace clangd\n} // namespace clang\n\n#endif\n"}, "7": {"id": 7, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/CanonicalIncludes.h", "content": "//===-- CanonicalIncludes.h - remap #include header -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// At indexing time, we decide which file to #included for a symbol.\n// Usually this is the file with the canonical decl, but there are exceptions:\n// - private headers may have pragmas pointing to the matching public header.\n//   (These are \"IWYU\" pragmas, named after the include-what-you-use tool).\n// - the standard library is implemented in many files, without any pragmas.\n//   We have a lookup table for common standard library implementations.\n//   libstdc++ puts char_traits in bits/char_traits.h, but we #include <string>.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_CANONICALINCLUDES_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_CANONICALINCLUDES_H\n\n#include \"clang/Lex/Preprocessor.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Regex.h\"\n#include <mutex>\n#include <string>\n#include <vector>\n\nnamespace clang {\nnamespace clangd {\n\n/// Maps a definition location onto an #include file, based on a set of filename\n/// rules.\n/// Only const methods (i.e. mapHeader) in this class are thread safe.\nclass CanonicalIncludes {\npublic:\n  /// Adds a string-to-string mapping from \\p Path to \\p CanonicalPath.\n  void addMapping(llvm::StringRef Path, llvm::StringRef CanonicalPath);\n\n  /// Returns the overridden include for symbol with \\p QualifiedName, or \"\".\n  llvm::StringRef mapSymbol(llvm::StringRef QualifiedName) const;\n\n  /// Returns the overridden include for for files in \\p Header, or \"\".\n  llvm::StringRef mapHeader(llvm::StringRef Header) const;\n\n  /// Adds mapping for system headers and some special symbols (e.g. STL symbols\n  /// in <iosfwd> need to be mapped individually). Approximately, the following\n  /// system headers are handled:\n  ///   - C++ standard library e.g. bits/basic_string.h$ -> <string>\n  ///   - Posix library e.g. bits/pthreadtypes.h$ -> <pthread.h>\n  ///   - Compiler extensions, e.g. include/avx512bwintrin.h$ -> <immintrin.h>\n  /// The mapping is hardcoded and hand-maintained, so it might not cover all\n  /// headers.\n  void addSystemHeadersMapping(const LangOptions &Language);\n\nprivate:\n  /// A map from full include path to a canonical path.\n  llvm::StringMap<std::string> FullPathMapping;\n  /// A map from a suffix (one or components of a path) to a canonical path.\n  /// Used only for mapping standard headers.\n  const llvm::StringMap<llvm::StringRef> *StdSuffixHeaderMapping = nullptr;\n  /// A map from fully qualified symbol names to header names.\n  /// Used only for mapping standard symbols.\n  const llvm::StringMap<llvm::StringRef> *StdSymbolMapping = nullptr;\n};\n\n/// Returns a CommentHandler that parses pragma comment on include files to\n/// determine when we should include a different header from the header that\n/// directly defines a symbol. Mappinps are registered with \\p Includes.\n///\n/// Currently it only supports IWYU private pragma:\n/// https://github.com/include-what-you-use/include-what-you-use/blob/master/docs/IWYUPragmas.md#iwyu-pragma-private\n///\n/// We ignore other pragmas:\n/// - keep: this is common but irrelevant: we do not currently remove includes\n/// - export: this is common and potentially interesting, there are three cases:\n///    * Points to a public header (common): we can suppress include2 if you\n///      already have include1. Only marginally useful.\n///    * Points to a private header annotated with `private` (somewhat commmon):\n///      Not incrementally useful as we support private.\n///    * Points to a private header without pragmas (rare). This is a reversed\n///      private pragma, and is valuable but too rare to be worthwhile.\n/// - no_include: this is about as common as private, but only affects the\n///   current file, so the value is smaller. We could add support.\n/// - friend: this is less common than private, has implementation difficulties,\n///   and affects behavior in a limited scope.\n/// - associated: extremely rare\nstd::unique_ptr<CommentHandler>\ncollectIWYUHeaderMaps(CanonicalIncludes *Includes);\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_HEADERMAPCOLLECTOR_H\n"}, "8": {"id": 8, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/Serialization.h", "content": "//===--- Serialization.h - Binary serialization of index data ----*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file provides serialization of indexed symbols and other data.\n//\n// It writes sections:\n//  - metadata such as version info\n//  - a string table (which is compressed)\n//  - lists of encoded symbols\n//\n// The format has a simple versioning scheme: the format version number is\n// written in the file and non-current versions are rejected when reading.\n//\n// Human-readable YAML serialization is also supported, and recommended for\n// debugging and experiments only.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_RIFF_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_RIFF_H\n\n#include \"Headers.h\"\n#include \"Index.h\"\n#include \"index/Symbol.h\"\n#include \"clang/Tooling/CompilationDatabase.h\"\n#include \"llvm/Support/Error.h\"\n\nnamespace clang {\nnamespace clangd {\n\nenum class IndexFileFormat {\n  RIFF, // Versioned binary format, suitable for production use.\n  YAML, // Human-readable format, suitable for experiments and debugging.\n};\n\n// Holds the contents of an index file that was read.\nstruct IndexFileIn {\n  llvm::Optional<SymbolSlab> Symbols;\n  llvm::Optional<RefSlab> Refs;\n  llvm::Optional<RelationSlab> Relations;\n  // Keys are URIs of the source files.\n  llvm::Optional<IncludeGraph> Sources;\n  // This contains only the Directory and CommandLine.\n  llvm::Optional<tooling::CompileCommand> Cmd;\n};\n// Parse an index file. The input must be a RIFF or YAML file.\nllvm::Expected<IndexFileIn> readIndexFile(llvm::StringRef);\n\n// Specifies the contents of an index file to be written.\nstruct IndexFileOut {\n  const SymbolSlab *Symbols = nullptr;\n  const RefSlab *Refs = nullptr;\n  const RelationSlab *Relations = nullptr;\n  // Keys are URIs of the source files.\n  const IncludeGraph *Sources = nullptr;\n  // TODO: Support serializing Dex posting lists.\n  IndexFileFormat Format = IndexFileFormat::RIFF;\n  const tooling::CompileCommand *Cmd = nullptr;\n\n  IndexFileOut() = default;\n  IndexFileOut(const IndexFileIn &I)\n      : Symbols(I.Symbols ? I.Symbols.getPointer() : nullptr),\n        Refs(I.Refs ? I.Refs.getPointer() : nullptr),\n        Relations(I.Relations ? I.Relations.getPointer() : nullptr),\n        Sources(I.Sources ? I.Sources.getPointer() : nullptr),\n        Cmd(I.Cmd ? I.Cmd.getPointer() : nullptr) {}\n};\n// Serializes an index file.\nllvm::raw_ostream &operator<<(llvm::raw_ostream &OS, const IndexFileOut &O);\n\n// Convert a single symbol to YAML, a nice debug representation.\nstd::string toYAML(const Symbol &);\nstd::string toYAML(const std::pair<SymbolID, ArrayRef<Ref>> &);\nstd::string toYAML(const Relation &);\nstd::string toYAML(const Ref &);\n\n// Deserialize a single symbol from YAML.\nllvm::Expected<clangd::Symbol> symbolFromYAML(StringRef YAML,\n                                              llvm::UniqueStringSaver *Strings);\nllvm::Expected<clangd::Ref> refFromYAML(StringRef YAML,\n                                        llvm::UniqueStringSaver *Strings);\n\n// Build an in-memory static index from an index file.\n// The size should be relatively small, so data can be managed in memory.\nstd::unique_ptr<SymbolIndex> loadIndex(llvm::StringRef Filename,\n                                       bool UseDex = true);\n\n} // namespace clangd\n} // namespace clang\n\n#endif\n"}, "9": {"id": 9, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolLocation.h", "content": "//===--- SymbolLocation.h ----------------------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOL_LOCATION_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOL_LOCATION_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cstdint>\n\nnamespace clang {\nnamespace clangd {\n\nstruct SymbolLocation {\n  // Specify a position (Line, Column) of symbol. Using Line/Column allows us to\n  // build LSP responses without reading the file content.\n  //\n  // clangd uses the following definitions, which differ slightly from LSP:\n  //  - Line is the number of newline characters (\\n) before the point.\n  //  - Column is (by default) the number of UTF-16 code between the last \\n\n  //    (or start of file) and the point.\n  //    If the `offsetEncoding` protocol extension is used to negotiate UTF-8,\n  //    then it is instead the number of *bytes* since the last \\n.\n  //\n  // Position is encoded into 32 bits to save space.\n  // If Line/Column overflow, the value will be their maximum value.\n  struct Position {\n    Position() : LineColumnPacked(0) {}\n    void setLine(uint32_t Line);\n    uint32_t line() const { return LineColumnPacked >> ColumnBits; }\n    void setColumn(uint32_t Column);\n    uint32_t column() const { return LineColumnPacked & MaxColumn; }\n    uint32_t rep() const { return LineColumnPacked; }\n\n    bool hasOverflow() const {\n      return line() == MaxLine || column() == MaxColumn;\n    }\n\n    static constexpr unsigned ColumnBits = 12;\n    static constexpr uint32_t MaxLine = (1 << (32 - ColumnBits)) - 1;\n    static constexpr uint32_t MaxColumn = (1 << ColumnBits) - 1;\n\n  private:\n    uint32_t LineColumnPacked; // Top 20 bit line, bottom 12 bits column.\n  };\n\n  /// The symbol range, using half-open range [Start, End).\n  Position Start;\n  Position End;\n\n  explicit operator bool() const { return !llvm::StringRef(FileURI).empty(); }\n\n  // The URI of the source file where a symbol occurs.\n  // The string must be null-terminated.\n  //\n  // We avoid using llvm::StringRef here to save memory.\n  // WARNING: unless you know what you are doing, it is recommended to use it\n  // via llvm::StringRef.\n  const char *FileURI = \"\";\n};\n\ninline bool operator==(const SymbolLocation::Position &L,\n                       const SymbolLocation::Position &R) {\n  return std::make_tuple(L.line(), L.column()) ==\n         std::make_tuple(R.line(), R.column());\n}\ninline bool operator<(const SymbolLocation::Position &L,\n                      const SymbolLocation::Position &R) {\n  return std::make_tuple(L.line(), L.column()) <\n         std::make_tuple(R.line(), R.column());\n}\ninline bool operator==(const SymbolLocation &L, const SymbolLocation &R) {\n  assert(L.FileURI && R.FileURI);\n  return !std::strcmp(L.FileURI, R.FileURI) &&\n         std::tie(L.Start, L.End) == std::tie(R.Start, R.End);\n}\ninline bool operator<(const SymbolLocation &L, const SymbolLocation &R) {\n  assert(L.FileURI && R.FileURI);\n  int Cmp = std::strcmp(L.FileURI, R.FileURI);\n  if (Cmp != 0)\n    return Cmp < 0;\n  return std::tie(L.Start, L.End) < std::tie(R.Start, R.End);\n}\n\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const SymbolLocation &);\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOL_LOCATION_H\n"}, "10": {"id": 10, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolOrigin.h", "content": "//===--- SymbolOrigin.h ------------------------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOL_ORIGIN_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOL_ORIGIN_H\n\n#include \"llvm/Support/raw_ostream.h\"\n#include <cstdint>\n\nnamespace clang {\nnamespace clangd {\n\n// Describes the source of information about a symbol.\n// Mainly useful for debugging, e.g. understanding code completion results.\n// This is a bitfield as information can be combined from several sources.\nenum class SymbolOrigin : uint8_t {\n  Unknown = 0,\n  AST = 1 << 0,        // Directly from the AST (indexes should not set this).\n  Dynamic = 1 << 1,    // From the dynamic index of opened files.\n  Static = 1 << 2,     // From the static, externally-built index.\n  Merge = 1 << 3,      // A non-trivial index merge was performed.\n  Identifier = 1 << 4, // Raw identifiers in file.\n  Remote = 1 << 5,     // Remote index.\n  // Remaining bits reserved for index implementations.\n};\n\ninline SymbolOrigin operator|(SymbolOrigin A, SymbolOrigin B) {\n  return static_cast<SymbolOrigin>(static_cast<uint8_t>(A) |\n                                   static_cast<uint8_t>(B));\n}\ninline SymbolOrigin &operator|=(SymbolOrigin &A, SymbolOrigin B) {\n  return A = A | B;\n}\ninline SymbolOrigin operator&(SymbolOrigin A, SymbolOrigin B) {\n  return static_cast<SymbolOrigin>(static_cast<uint8_t>(A) &\n                                   static_cast<uint8_t>(B));\n}\n\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, SymbolOrigin);\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOL_ORIGIN_H\n"}, "11": {"id": 11, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/refactor/Tweak.h", "content": "//===--- Tweak.h -------------------------------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n// Tweaks are small actions that run over the AST and produce edits, messages\n// etc as a result. They are local, i.e. they should take the current editor\n// context, e.g. the cursor position and selection into account.\n// The actions are executed in two stages:\n//   - Stage 1 should check whether the action is available in a current\n//     context. It should be cheap and fast to compute as it is executed for all\n//     available actions on every client request, which happen quite frequently.\n//   - Stage 2 is performed after stage 1 and can be more expensive to compute.\n//     It is performed when the user actually chooses the action.\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_REFACTOR_ACTIONS_TWEAK_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_REFACTOR_ACTIONS_TWEAK_H\n\n#include \"ParsedAST.h\"\n#include \"Protocol.h\"\n#include \"Selection.h\"\n#include \"SourceCode.h\"\n#include \"index/Index.h\"\n#include \"support/Path.h\"\n#include \"clang/Tooling/Core/Replacement.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Error.h\"\n#include <string>\n\nnamespace clang {\nnamespace clangd {\n\nclass FeatureModuleSet;\n\n/// An interface base for small context-sensitive refactoring actions.\n/// To implement a new tweak use the following pattern in a .cpp file:\n///   class MyTweak : public Tweak {\n///   public:\n///     const char* id() const override final; // defined by REGISTER_TWEAK.\n///     // implement other methods here.\n///   };\n///   REGISTER_TWEAK(MyTweak);\nclass Tweak {\npublic:\n  /// Input to prepare and apply tweaks.\n  struct Selection {\n    Selection(const SymbolIndex *Index, ParsedAST &AST, unsigned RangeBegin,\n              unsigned RangeEnd, SelectionTree ASTSelection,\n              llvm::vfs::FileSystem *VFS);\n    /// The text of the active document.\n    llvm::StringRef Code;\n    /// The Index for handling codebase related queries.\n    const SymbolIndex *Index = nullptr;\n    /// The parsed active file. Never null. (Pointer so Selection is movable).\n    ParsedAST *AST;\n    /// A location of the cursor in the editor.\n    // FIXME: Cursor is redundant and should be removed\n    SourceLocation Cursor;\n    /// The begin offset of the selection\n    unsigned SelectionBegin;\n    /// The end offset of the selection\n    unsigned SelectionEnd;\n    /// The AST nodes that were selected.\n    SelectionTree ASTSelection;\n    /// File system used to access source code (for cross-file tweaks).\n    /// This is only populated when applying a tweak, not during prepare.\n    llvm::vfs::FileSystem *FS = nullptr;\n    // FIXME: provide a way to get sources and ASTs for other files.\n  };\n\n  struct Effect {\n    /// A message to be displayed to the user.\n    llvm::Optional<std::string> ShowMessage;\n    FileEdits ApplyEdits;\n\n    static Effect showMessage(StringRef S) {\n      Effect E;\n      E.ShowMessage = std::string(S);\n      return E;\n    }\n\n    /// Path is the absolute, symlink-resolved path for the file pointed by FID\n    /// in SM. Edit is generated from Replacements.\n    /// Fails if cannot figure out absolute path for FID.\n    static llvm::Expected<std::pair<Path, Edit>>\n    fileEdit(const SourceManager &SM, FileID FID,\n             tooling::Replacements Replacements);\n\n    /// Creates an effect with an Edit for the main file.\n    /// Fails if cannot figure out absolute path for main file.\n    static llvm::Expected<Tweak::Effect>\n    mainFileEdit(const SourceManager &SM, tooling::Replacements Replacements);\n  };\n\n  virtual ~Tweak() = default;\n  /// A unique id of the action, it is always equal to the name of the class\n  /// defining the Tweak. Definition is provided automatically by\n  /// REGISTER_TWEAK.\n  virtual const char *id() const = 0;\n  /// Run the first stage of the action. Returns true indicating that the\n  /// action is available and should be shown to the user. Returns false if the\n  /// action is not available.\n  /// This function should be fast, if the action requires non-trivial work it\n  /// should be moved into 'apply'.\n  /// Returns true iff the action is available and apply() can be called on it.\n  virtual bool prepare(const Selection &Sel) = 0;\n  /// Run the second stage of the action that would produce the actual effect.\n  /// EXPECTS: prepare() was called and returned true.\n  virtual Expected<Effect> apply(const Selection &Sel) = 0;\n\n  /// A one-line title of the action that should be shown to the users in the\n  /// UI.\n  /// EXPECTS: prepare() was called and returned true.\n  virtual std::string title() const = 0;\n  /// Describes what kind of action this is.\n  /// EXPECTS: prepare() was called and returned true.\n  virtual llvm::StringLiteral kind() const = 0;\n  /// Is this a 'hidden' tweak, which are off by default.\n  virtual bool hidden() const { return false; }\n};\n\n// All tweaks must be registered in the .cpp file next to their definition.\n#define REGISTER_TWEAK(Subclass)                                               \\\n  ::llvm::Registry<::clang::clangd::Tweak>::Add<Subclass>                      \\\n      TweakRegistrationFor##Subclass(#Subclass, /*Description=*/\"\");           \\\n  const char *Subclass::id() const { return #Subclass; }\n\n/// Calls prepare() on all tweaks that satisfy the filter, returning those that\n/// can run on the selection.\nstd::vector<std::unique_ptr<Tweak>>\nprepareTweaks(const Tweak::Selection &S,\n              llvm::function_ref<bool(const Tweak &)> Filter,\n              const FeatureModuleSet *Modules);\n\n// Calls prepare() on the tweak with a given ID.\n// If prepare() returns false, returns an error.\n// If prepare() returns true, returns the corresponding tweak.\nllvm::Expected<std::unique_ptr<Tweak>>\nprepareTweak(StringRef ID, const Tweak::Selection &S,\n             const FeatureModuleSet *Modules);\n} // namespace clangd\n} // namespace clang\n\n#endif\n"}, "12": {"id": 12, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/SyncAPI.h", "content": "//===--- SyncAPI.h - Sync version of ClangdServer's API ----------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains synchronous versions of ClangdServer's async API. We\n// deliberately don't expose the sync API outside tests to encourage using the\n// async versions in clangd code.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_UNITTESTS_CLANGD_SYNCAPI_H\n#define LLVM_CLANG_TOOLS_EXTRA_UNITTESTS_CLANGD_SYNCAPI_H\n\n#include \"ClangdServer.h\"\n#include \"index/Index.h\"\n\nnamespace clang {\nnamespace clangd {\n\n// Calls addDocument and then blockUntilIdleForTest.\nvoid runAddDocument(ClangdServer &Server, PathRef File, StringRef Contents,\n                    StringRef Version = \"null\",\n                    WantDiagnostics WantDiags = WantDiagnostics::Auto,\n                    bool ForceRebuild = false);\n\nllvm::Expected<CodeCompleteResult>\nrunCodeComplete(ClangdServer &Server, PathRef File, Position Pos,\n                clangd::CodeCompleteOptions Opts);\n\nllvm::Expected<SignatureHelp> runSignatureHelp(ClangdServer &Server,\n                                               PathRef File, Position Pos);\n\nllvm::Expected<std::vector<LocatedSymbol>>\nrunLocateSymbolAt(ClangdServer &Server, PathRef File, Position Pos);\n\nllvm::Expected<std::vector<DocumentHighlight>>\nrunFindDocumentHighlights(ClangdServer &Server, PathRef File, Position Pos);\n\nllvm::Expected<RenameResult> runRename(ClangdServer &Server, PathRef File,\n                                       Position Pos, StringRef NewName,\n                                       const clangd::RenameOptions &RenameOpts);\n\nllvm::Expected<RenameResult>\nrunPrepareRename(ClangdServer &Server, PathRef File, Position Pos,\n                 llvm::Optional<std::string> NewName,\n                 const clangd::RenameOptions &RenameOpts);\n\nllvm::Expected<tooling::Replacements>\nrunFormatFile(ClangdServer &Server, PathRef File, llvm::Optional<Range>);\n\nSymbolSlab runFuzzyFind(const SymbolIndex &Index, StringRef Query);\nSymbolSlab runFuzzyFind(const SymbolIndex &Index, const FuzzyFindRequest &Req);\nRefSlab getRefs(const SymbolIndex &Index, SymbolID ID);\n\nllvm::Expected<std::vector<SelectionRange>>\nrunSemanticRanges(ClangdServer &Server, PathRef File,\n                  const std::vector<Position> &Pos);\n\nllvm::Expected<llvm::Optional<clangd::Path>>\nrunSwitchHeaderSource(ClangdServer &Server, PathRef File);\n\nllvm::Error runCustomAction(ClangdServer &Server, PathRef File,\n                            llvm::function_ref<void(InputsAndAST)>);\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_UNITTESTS_CLANGD_SYNCAPI_H\n"}, "13": {"id": 13, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/TestFS.h", "content": "//===-- TestFS.h ------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Allows setting up fake filesystem environments for tests.\n//\n//===----------------------------------------------------------------------===//\n#ifndef LLVM_CLANG_TOOLS_EXTRA_UNITTESTS_CLANGD_TESTFS_H\n#define LLVM_CLANG_TOOLS_EXTRA_UNITTESTS_CLANGD_TESTFS_H\n#include \"ClangdServer.h\"\n#include \"GlobalCompilationDatabase.h\"\n#include \"support/Path.h\"\n#include \"support/ThreadsafeFS.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/Support/Path.h\"\n#include \"llvm/Support/VirtualFileSystem.h\"\n\nnamespace clang {\nnamespace clangd {\n\n// Builds a VFS that provides access to the provided files, plus temporary\n// directories.\nllvm::IntrusiveRefCntPtr<llvm::vfs::FileSystem>\nbuildTestFS(llvm::StringMap<std::string> const &Files,\n            llvm::StringMap<time_t> const &Timestamps = {});\n\n// A VFS provider that returns TestFSes containing a provided set of files.\nclass MockFS : public ThreadsafeFS {\npublic:\n  IntrusiveRefCntPtr<llvm::vfs::FileSystem> viewImpl() const override {\n    auto MemFS = buildTestFS(Files, Timestamps);\n    if (!OverlayRealFileSystemForModules)\n      return MemFS;\n    llvm::IntrusiveRefCntPtr<llvm::vfs::OverlayFileSystem> OverlayFileSystem =\n        new llvm::vfs::OverlayFileSystem(llvm::vfs::getRealFileSystem());\n    OverlayFileSystem->pushOverlay(MemFS);\n    return OverlayFileSystem;\n  }\n\n  // If relative paths are used, they are resolved with testPath().\n  llvm::StringMap<std::string> Files;\n  llvm::StringMap<time_t> Timestamps;\n  // If true, real file system will be used as fallback for the in-memory one.\n  // This is useful for testing module support.\n  bool OverlayRealFileSystemForModules = false;\n};\n\n// A Compilation database that returns a fixed set of compile flags.\nclass MockCompilationDatabase : public GlobalCompilationDatabase {\npublic:\n  /// If \\p Directory is not empty, use that as the Directory field of the\n  /// CompileCommand, and as project SourceRoot.\n  ///\n  /// If \\p RelPathPrefix is not empty, use that as a prefix in front of the\n  /// source file name, instead of using an absolute path.\n  MockCompilationDatabase(StringRef Directory = StringRef(),\n                          StringRef RelPathPrefix = StringRef());\n\n  llvm::Optional<tooling::CompileCommand>\n  getCompileCommand(PathRef File) const override;\n\n  llvm::Optional<ProjectInfo> getProjectInfo(PathRef File) const override;\n\n  std::vector<std::string> ExtraClangFlags;\n\nprivate:\n  StringRef Directory;\n  StringRef RelPathPrefix;\n};\n\n// Returns an absolute (fake) test directory for this OS.\nconst char *testRoot();\n\n// Returns a suitable absolute path for this OS.\nstd::string testPath(PathRef File,\n                     llvm::sys::path::Style = llvm::sys::path::Style::native);\n\n// unittest: is a scheme that refers to files relative to testRoot()\n// This anchor is used to force the linker to link in the generated object file\n// and thus register unittest: URI scheme plugin.\nextern volatile int UnittestSchemeAnchorSource;\n\n} // namespace clangd\n} // namespace clang\n#endif\n"}, "14": {"id": 14, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/TestIndex.h", "content": "//===-- IndexHelpers.h ------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_UNITTESTS_CLANGD_INDEXTESTCOMMON_H\n#define LLVM_CLANG_TOOLS_EXTRA_UNITTESTS_CLANGD_INDEXTESTCOMMON_H\n\n#include \"index/Index.h\"\n#include \"index/Merge.h\"\n\nnamespace clang {\nnamespace clangd {\n\n// Creates Symbol instance and sets SymbolID to given QualifiedName.\nSymbol symbol(llvm::StringRef QName);\n\n// Helpers to produce fake index symbols with proper SymbolID.\n// USRFormat is a regex replacement string for the unqualified part of the USR.\nSymbol sym(llvm::StringRef QName, index::SymbolKind Kind,\n           llvm::StringRef USRFormat);\n// Creats a function symbol assuming no function arg.\nSymbol func(llvm::StringRef Name);\n// Creates a class symbol.\nSymbol cls(llvm::StringRef Name);\n// Creates a variable symbol.\nSymbol var(llvm::StringRef Name);\n// Creates a namespace symbol.\nSymbol ns(llvm::StringRef Name);\n\n// Create a slab of symbols with the given qualified names as IDs and names.\nSymbolSlab generateSymbols(std::vector<std::string> QualifiedNames);\n\n// Create a slab of symbols with IDs and names [Begin, End].\nSymbolSlab generateNumSymbols(int Begin, int End);\n\n// Returns fully-qualified name out of given symbol.\nstd::string getQualifiedName(const Symbol &Sym);\n\n// Performs fuzzy matching-based symbol lookup given a query and an index.\n// Incomplete is set true if more items than requested can be retrieved, false\n// otherwise.\nstd::vector<std::string> match(const SymbolIndex &I,\n                               const FuzzyFindRequest &Req,\n                               bool *Incomplete = nullptr);\n\n// Returns qualified names of symbols with any of IDs in the index.\nstd::vector<std::string> lookup(const SymbolIndex &I,\n                                llvm::ArrayRef<SymbolID> IDs);\n\n} // namespace clangd\n} // namespace clang\n\n#endif\n"}, "15": {"id": 15, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/TestTU.h", "content": "//===--- TestTU.h - Scratch source files for testing -------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Many tests for indexing, code completion etc are most naturally expressed\n// using code examples.\n// TestTU lets test define these examples in a common way without dealing with\n// the mechanics of VFS and compiler interactions, and then easily grab the\n// AST, particular symbols, etc.\n//\n//===---------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_UNITTESTS_CLANGD_TESTTU_H\n#define LLVM_CLANG_TOOLS_EXTRA_UNITTESTS_CLANGD_TESTTU_H\n\n#include \"../TidyProvider.h\"\n#include \"Compiler.h\"\n#include \"FeatureModule.h\"\n#include \"ParsedAST.h\"\n#include \"TestFS.h\"\n#include \"index/Index.h\"\n#include \"support/Path.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"gtest/gtest.h\"\n#include <memory>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace clang {\nnamespace clangd {\n\nstruct TestTU {\n  static TestTU withCode(llvm::StringRef Code) {\n    TestTU TU;\n    TU.Code = std::string(Code);\n    return TU;\n  }\n\n  static TestTU withHeaderCode(llvm::StringRef HeaderCode) {\n    TestTU TU;\n    TU.HeaderCode = std::string(HeaderCode);\n    return TU;\n  }\n\n  // The code to be compiled.\n  std::string Code;\n  std::string Filename = \"TestTU.cpp\";\n\n  // Define contents of a header which will be implicitly included by Code.\n  std::string HeaderCode;\n  std::string HeaderFilename = \"TestTU.h\";\n\n  // Name and contents of each file.\n  llvm::StringMap<std::string> AdditionalFiles;\n\n  // Extra arguments for the compiler invocation.\n  std::vector<std::string> ExtraArgs;\n\n  TidyProvider ClangTidyProvider = {};\n  // Index to use when building AST.\n  const SymbolIndex *ExternalIndex = nullptr;\n\n  // Simulate a header guard of the header (using an #import directive).\n  bool ImplicitHeaderGuard = true;\n\n  // Whether to use overlay the TestFS over the real filesystem. This is\n  // required for use of implicit modules.where the module file is written to\n  // disk and later read back.\n  // FIXME: Change the way reading/writing modules work to allow us to keep them\n  // in memory across multiple clang invocations, at least in tests, to\n  // eliminate the need for real file system here.\n  // Please avoid using this for things other than implicit modules. The plan is\n  // to eliminate this option some day.\n  bool OverlayRealFileSystemForModules = false;\n\n  FeatureModuleSet *FeatureModules = nullptr;\n\n  // By default, build() will report Error diagnostics as GTest errors.\n  // Suppress this behavior by adding an 'error-ok' comment to the code.\n  // The result will always have getDiagnostics() populated.\n  ParsedAST build() const;\n  std::shared_ptr<const PreambleData>\n  preamble(PreambleParsedCallback PreambleCallback = nullptr) const;\n  ParseInputs inputs(MockFS &FS) const;\n  SymbolSlab headerSymbols() const;\n  RefSlab headerRefs() const;\n  std::unique_ptr<SymbolIndex> index() const;\n};\n\n// Look up an index symbol by qualified name, which must be unique.\nconst Symbol &findSymbol(const SymbolSlab &, llvm::StringRef QName);\n// Look up an AST symbol by qualified name, which must be unique and top-level.\nconst NamedDecl &findDecl(ParsedAST &AST, llvm::StringRef QName);\n// Look up an AST symbol that satisfies \\p Filter.\nconst NamedDecl &findDecl(ParsedAST &AST,\n                          std::function<bool(const NamedDecl &)> Filter);\n// Look up an AST symbol by unqualified name, which must be unique.\nconst NamedDecl &findUnqualifiedDecl(ParsedAST &AST, llvm::StringRef Name);\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_UNITTESTS_CLANGD_TESTTU_H\n"}, "16": {"id": 16, "path": "/home/vsts/work/1/llvm-project/clang/include/clang-c/BuildSystem.h", "content": "/*==-- clang-c/BuildSystem.h - Utilities for use by build systems -*- C -*-===*\\\n|*                                                                            *|\n|* Part of the LLVM Project, under the Apache License v2.0 with LLVM          *|\n|* Exceptions.                                                                *|\n|* See https://llvm.org/LICENSE.txt for license information.                  *|\n|* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception                    *|\n|*                                                                            *|\n|*===----------------------------------------------------------------------===*|\n|*                                                                            *|\n|* This header provides various utilities for use by build systems.           *|\n|*                                                                            *|\n\\*===----------------------------------------------------------------------===*/\n\n#ifndef LLVM_CLANG_C_BUILDSYSTEM_H\n#define LLVM_CLANG_C_BUILDSYSTEM_H\n\n#include \"clang-c/CXErrorCode.h\"\n#include \"clang-c/CXString.h\"\n#include \"clang-c/ExternC.h\"\n#include \"clang-c/Platform.h\"\n\nLLVM_CLANG_C_EXTERN_C_BEGIN\n\n/**\n * \\defgroup BUILD_SYSTEM Build system utilities\n * @{\n */\n\n/**\n * Return the timestamp for use with Clang's\n * \\c -fbuild-session-timestamp= option.\n */\nCINDEX_LINKAGE unsigned long long clang_getBuildSessionTimestamp(void);\n\n/**\n * Object encapsulating information about overlaying virtual\n * file/directories over the real file system.\n */\ntypedef struct CXVirtualFileOverlayImpl *CXVirtualFileOverlay;\n\n/**\n * Create a \\c CXVirtualFileOverlay object.\n * Must be disposed with \\c clang_VirtualFileOverlay_dispose().\n *\n * \\param options is reserved, always pass 0.\n */\nCINDEX_LINKAGE CXVirtualFileOverlay\nclang_VirtualFileOverlay_create(unsigned options);\n\n/**\n * Map an absolute virtual file path to an absolute real one.\n * The virtual path must be canonicalized (not contain \".\"/\"..\").\n * \\returns 0 for success, non-zero to indicate an error.\n */\nCINDEX_LINKAGE enum CXErrorCode\nclang_VirtualFileOverlay_addFileMapping(CXVirtualFileOverlay,\n                                        const char *virtualPath,\n                                        const char *realPath);\n\n/**\n * Set the case sensitivity for the \\c CXVirtualFileOverlay object.\n * The \\c CXVirtualFileOverlay object is case-sensitive by default, this\n * option can be used to override the default.\n * \\returns 0 for success, non-zero to indicate an error.\n */\nCINDEX_LINKAGE enum CXErrorCode\nclang_VirtualFileOverlay_setCaseSensitivity(CXVirtualFileOverlay,\n                                            int caseSensitive);\n\n/**\n * Write out the \\c CXVirtualFileOverlay object to a char buffer.\n *\n * \\param options is reserved, always pass 0.\n * \\param out_buffer_ptr pointer to receive the buffer pointer, which should be\n * disposed using \\c clang_free().\n * \\param out_buffer_size pointer to receive the buffer size.\n * \\returns 0 for success, non-zero to indicate an error.\n */\nCINDEX_LINKAGE enum CXErrorCode\nclang_VirtualFileOverlay_writeToBuffer(CXVirtualFileOverlay, unsigned options,\n                                       char **out_buffer_ptr,\n                                       unsigned *out_buffer_size);\n\n/**\n * free memory allocated by libclang, such as the buffer returned by\n * \\c CXVirtualFileOverlay() or \\c clang_ModuleMapDescriptor_writeToBuffer().\n *\n * \\param buffer memory pointer to free.\n */\nCINDEX_LINKAGE void clang_free(void *buffer);\n\n/**\n * Dispose a \\c CXVirtualFileOverlay object.\n */\nCINDEX_LINKAGE void clang_VirtualFileOverlay_dispose(CXVirtualFileOverlay);\n\n/**\n * Object encapsulating information about a module.map file.\n */\ntypedef struct CXModuleMapDescriptorImpl *CXModuleMapDescriptor;\n\n/**\n * Create a \\c CXModuleMapDescriptor object.\n * Must be disposed with \\c clang_ModuleMapDescriptor_dispose().\n *\n * \\param options is reserved, always pass 0.\n */\nCINDEX_LINKAGE CXModuleMapDescriptor\nclang_ModuleMapDescriptor_create(unsigned options);\n\n/**\n * Sets the framework module name that the module.map describes.\n * \\returns 0 for success, non-zero to indicate an error.\n */\nCINDEX_LINKAGE enum CXErrorCode\nclang_ModuleMapDescriptor_setFrameworkModuleName(CXModuleMapDescriptor,\n                                                 const char *name);\n\n/**\n * Sets the umbrella header name that the module.map describes.\n * \\returns 0 for success, non-zero to indicate an error.\n */\nCINDEX_LINKAGE enum CXErrorCode\nclang_ModuleMapDescriptor_setUmbrellaHeader(CXModuleMapDescriptor,\n                                            const char *name);\n\n/**\n * Write out the \\c CXModuleMapDescriptor object to a char buffer.\n *\n * \\param options is reserved, always pass 0.\n * \\param out_buffer_ptr pointer to receive the buffer pointer, which should be\n * disposed using \\c clang_free().\n * \\param out_buffer_size pointer to receive the buffer size.\n * \\returns 0 for success, non-zero to indicate an error.\n */\nCINDEX_LINKAGE enum CXErrorCode\nclang_ModuleMapDescriptor_writeToBuffer(CXModuleMapDescriptor, unsigned options,\n                                       char **out_buffer_ptr,\n                                       unsigned *out_buffer_size);\n\n/**\n * Dispose a \\c CXModuleMapDescriptor object.\n */\nCINDEX_LINKAGE void clang_ModuleMapDescriptor_dispose(CXModuleMapDescriptor);\n\n/**\n * @}\n */\n\nLLVM_CLANG_C_EXTERN_C_END\n\n#endif /* CLANG_C_BUILD_SYSTEM_H */\n\n"}, "17": {"id": 17, "path": "/home/vsts/work/1/llvm-project/clang/include/clang-c/ExternC.h", "content": "/*===- clang-c/ExternC.h - Wrapper for 'extern \"C\"' ---------------*- C -*-===*\\\n|*                                                                            *|\n|* Part of the LLVM Project, under the Apache License v2.0 with LLVM          *|\n|* Exceptions.                                                                *|\n|* See https://llvm.org/LICENSE.txt for license information.                  *|\n|* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception                    *|\n|*                                                                            *|\n|*===----------------------------------------------------------------------===*|\n|*                                                                            *|\n|* This file defines an 'extern \"C\"' wrapper.                                 *|\n|*                                                                            *|\n\\*===----------------------------------------------------------------------===*/\n\n#ifndef LLVM_CLANG_C_EXTERN_C_H\n#define LLVM_CLANG_C_EXTERN_C_H\n\n#ifdef __clang__\n#define LLVM_CLANG_C_STRICT_PROTOTYPES_BEGIN                                   \\\n  _Pragma(\"clang diagnostic push\")                                             \\\n      _Pragma(\"clang diagnostic error \\\"-Wstrict-prototypes\\\"\")\n#define LLVM_CLANG_C_STRICT_PROTOTYPES_END _Pragma(\"clang diagnostic pop\")\n#else\n#define LLVM_CLANG_C_STRICT_PROTOTYPES_BEGIN\n#define LLVM_CLANG_C_STRICT_PROTOTYPES_END\n#endif\n\n#ifdef __cplusplus\n#define LLVM_CLANG_C_EXTERN_C_BEGIN                                            \\\n  extern \"C\" {                                                                 \\\n  LLVM_CLANG_C_STRICT_PROTOTYPES_BEGIN\n#define LLVM_CLANG_C_EXTERN_C_END                                              \\\n  LLVM_CLANG_C_STRICT_PROTOTYPES_END                                           \\\n  }\n#else\n#define LLVM_CLANG_C_EXTERN_C_BEGIN LLVM_CLANG_C_STRICT_PROTOTYPES_BEGIN\n#define LLVM_CLANG_C_EXTERN_C_END LLVM_CLANG_C_STRICT_PROTOTYPES_END\n#endif\n\n#endif\n"}, "18": {"id": 18, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ComputeDependence.h", "content": "//===--- ComputeDependence.h -------------------------------------- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  Calculate various template dependency flags for the AST.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_COMPUTE_DEPENDENCE_H\n#define LLVM_CLANG_AST_COMPUTE_DEPENDENCE_H\n\n#include \"clang/AST/DependenceFlags.h\"\n#include \"clang/Basic/ExceptionSpecificationType.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n\nnamespace clang {\n\nclass ASTContext;\n\nclass Expr;\nclass FullExpr;\nclass OpaqueValueExpr;\nclass ParenExpr;\nclass UnaryOperator;\nclass UnaryExprOrTypeTraitExpr;\nclass ArraySubscriptExpr;\nclass MatrixSubscriptExpr;\nclass CompoundLiteralExpr;\nclass CastExpr;\nclass BinaryOperator;\nclass ConditionalOperator;\nclass BinaryConditionalOperator;\nclass StmtExpr;\nclass ConvertVectorExpr;\nclass VAArgExpr;\nclass ChooseExpr;\nclass NoInitExpr;\nclass ArrayInitLoopExpr;\nclass ImplicitValueInitExpr;\nclass InitListExpr;\nclass ExtVectorElementExpr;\nclass BlockExpr;\nclass AsTypeExpr;\nclass DeclRefExpr;\nclass RecoveryExpr;\nclass CXXRewrittenBinaryOperator;\nclass CXXStdInitializerListExpr;\nclass CXXTypeidExpr;\nclass MSPropertyRefExpr;\nclass MSPropertySubscriptExpr;\nclass CXXUuidofExpr;\nclass CXXThisExpr;\nclass CXXThrowExpr;\nclass CXXBindTemporaryExpr;\nclass CXXScalarValueInitExpr;\nclass CXXDeleteExpr;\nclass ArrayTypeTraitExpr;\nclass ExpressionTraitExpr;\nclass CXXNoexceptExpr;\nclass PackExpansionExpr;\nclass SubstNonTypeTemplateParmExpr;\nclass CoroutineSuspendExpr;\nclass DependentCoawaitExpr;\nclass CXXNewExpr;\nclass CXXPseudoDestructorExpr;\nclass OverloadExpr;\nclass DependentScopeDeclRefExpr;\nclass CXXConstructExpr;\nclass CXXDefaultInitExpr;\nclass LambdaExpr;\nclass CXXUnresolvedConstructExpr;\nclass CXXDependentScopeMemberExpr;\nclass MaterializeTemporaryExpr;\nclass CXXFoldExpr;\nclass TypeTraitExpr;\nclass ConceptSpecializationExpr;\nclass PredefinedExpr;\nclass CallExpr;\nclass OffsetOfExpr;\nclass MemberExpr;\nclass ShuffleVectorExpr;\nclass GenericSelectionExpr;\nclass DesignatedInitExpr;\nclass ParenListExpr;\nclass PseudoObjectExpr;\nclass AtomicExpr;\nclass OMPArraySectionExpr;\nclass OMPArrayShapingExpr;\nclass OMPIteratorExpr;\nclass ObjCArrayLiteral;\nclass ObjCDictionaryLiteral;\nclass ObjCBoxedExpr;\nclass ObjCEncodeExpr;\nclass ObjCIvarRefExpr;\nclass ObjCPropertyRefExpr;\nclass ObjCSubscriptRefExpr;\nclass ObjCIsaExpr;\nclass ObjCIndirectCopyRestoreExpr;\nclass ObjCMessageExpr;\n\n// The following functions are called from constructors of `Expr`, so they\n// should not access anything beyond basic\nExprDependence computeDependence(FullExpr *E);\nExprDependence computeDependence(OpaqueValueExpr *E);\nExprDependence computeDependence(ParenExpr *E);\nExprDependence computeDependence(UnaryOperator *E, const ASTContext &Ctx);\nExprDependence computeDependence(UnaryExprOrTypeTraitExpr *E);\nExprDependence computeDependence(ArraySubscriptExpr *E);\nExprDependence computeDependence(MatrixSubscriptExpr *E);\nExprDependence computeDependence(CompoundLiteralExpr *E);\nExprDependence computeDependence(CastExpr *E);\nExprDependence computeDependence(BinaryOperator *E);\nExprDependence computeDependence(ConditionalOperator *E);\nExprDependence computeDependence(BinaryConditionalOperator *E);\nExprDependence computeDependence(StmtExpr *E, unsigned TemplateDepth);\nExprDependence computeDependence(ConvertVectorExpr *E);\nExprDependence computeDependence(VAArgExpr *E);\nExprDependence computeDependence(ChooseExpr *E);\nExprDependence computeDependence(NoInitExpr *E);\nExprDependence computeDependence(ArrayInitLoopExpr *E);\nExprDependence computeDependence(ImplicitValueInitExpr *E);\nExprDependence computeDependence(InitListExpr *E);\nExprDependence computeDependence(ExtVectorElementExpr *E);\nExprDependence computeDependence(BlockExpr *E);\nExprDependence computeDependence(AsTypeExpr *E);\nExprDependence computeDependence(DeclRefExpr *E, const ASTContext &Ctx);\nExprDependence computeDependence(RecoveryExpr *E);\nExprDependence computeDependence(CXXRewrittenBinaryOperator *E);\nExprDependence computeDependence(CXXStdInitializerListExpr *E);\nExprDependence computeDependence(CXXTypeidExpr *E);\nExprDependence computeDependence(MSPropertyRefExpr *E);\nExprDependence computeDependence(MSPropertySubscriptExpr *E);\nExprDependence computeDependence(CXXUuidofExpr *E);\nExprDependence computeDependence(CXXThisExpr *E);\nExprDependence computeDependence(CXXThrowExpr *E);\nExprDependence computeDependence(CXXBindTemporaryExpr *E);\nExprDependence computeDependence(CXXScalarValueInitExpr *E);\nExprDependence computeDependence(CXXDeleteExpr *E);\nExprDependence computeDependence(ArrayTypeTraitExpr *E);\nExprDependence computeDependence(ExpressionTraitExpr *E);\nExprDependence computeDependence(CXXNoexceptExpr *E, CanThrowResult CT);\nExprDependence computeDependence(PackExpansionExpr *E);\nExprDependence computeDependence(SubstNonTypeTemplateParmExpr *E);\nExprDependence computeDependence(CoroutineSuspendExpr *E);\nExprDependence computeDependence(DependentCoawaitExpr *E);\nExprDependence computeDependence(CXXNewExpr *E);\nExprDependence computeDependence(CXXPseudoDestructorExpr *E);\nExprDependence computeDependence(OverloadExpr *E, bool KnownDependent,\n                                 bool KnownInstantiationDependent,\n                                 bool KnownContainsUnexpandedParameterPack);\nExprDependence computeDependence(DependentScopeDeclRefExpr *E);\nExprDependence computeDependence(CXXConstructExpr *E);\nExprDependence computeDependence(CXXDefaultInitExpr *E);\nExprDependence computeDependence(LambdaExpr *E,\n                                 bool ContainsUnexpandedParameterPack);\nExprDependence computeDependence(CXXUnresolvedConstructExpr *E);\nExprDependence computeDependence(CXXDependentScopeMemberExpr *E);\nExprDependence computeDependence(MaterializeTemporaryExpr *E);\nExprDependence computeDependence(CXXFoldExpr *E);\nExprDependence computeDependence(TypeTraitExpr *E);\nExprDependence computeDependence(ConceptSpecializationExpr *E,\n                                 bool ValueDependent);\n\nExprDependence computeDependence(PredefinedExpr *E);\nExprDependence computeDependence(CallExpr *E, llvm::ArrayRef<Expr *> PreArgs);\nExprDependence computeDependence(OffsetOfExpr *E);\nExprDependence computeDependence(MemberExpr *E);\nExprDependence computeDependence(ShuffleVectorExpr *E);\nExprDependence computeDependence(GenericSelectionExpr *E,\n                                 bool ContainsUnexpandedPack);\nExprDependence computeDependence(DesignatedInitExpr *E);\nExprDependence computeDependence(ParenListExpr *E);\nExprDependence computeDependence(PseudoObjectExpr *E);\nExprDependence computeDependence(AtomicExpr *E);\n\nExprDependence computeDependence(OMPArraySectionExpr *E);\nExprDependence computeDependence(OMPArrayShapingExpr *E);\nExprDependence computeDependence(OMPIteratorExpr *E);\n\nExprDependence computeDependence(ObjCArrayLiteral *E);\nExprDependence computeDependence(ObjCDictionaryLiteral *E);\nExprDependence computeDependence(ObjCBoxedExpr *E);\nExprDependence computeDependence(ObjCEncodeExpr *E);\nExprDependence computeDependence(ObjCIvarRefExpr *E);\nExprDependence computeDependence(ObjCPropertyRefExpr *E);\nExprDependence computeDependence(ObjCSubscriptRefExpr *E);\nExprDependence computeDependence(ObjCIsaExpr *E);\nExprDependence computeDependence(ObjCIndirectCopyRestoreExpr *E);\nExprDependence computeDependence(ObjCMessageExpr *E);\n\n} // namespace clang\n#endif\n"}, "19": {"id": 19, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclObjCCommon.h", "content": "//===- DeclObjCCommon.h - Classes for representing declarations -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file contains common ObjC enums and classes used in AST and\n//  Sema.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_DECLOBJC_COMMON_H\n#define LLVM_CLANG_AST_DECLOBJC_COMMON_H\n\nnamespace clang {\n\n/// ObjCPropertyAttribute::Kind - list of property attributes.\n/// Keep this list in sync with LLVM's Dwarf.h ApplePropertyAttributes.s\nnamespace ObjCPropertyAttribute {\nenum Kind {\n  kind_noattr = 0x00,\n  kind_readonly = 0x01,\n  kind_getter = 0x02,\n  kind_assign = 0x04,\n  kind_readwrite = 0x08,\n  kind_retain = 0x10,\n  kind_copy = 0x20,\n  kind_nonatomic = 0x40,\n  kind_setter = 0x80,\n  kind_atomic = 0x100,\n  kind_weak = 0x200,\n  kind_strong = 0x400,\n  kind_unsafe_unretained = 0x800,\n  /// Indicates that the nullability of the type was spelled with a\n  /// property attribute rather than a type qualifier.\n  kind_nullability = 0x1000,\n  kind_null_resettable = 0x2000,\n  kind_class = 0x4000,\n  kind_direct = 0x8000,\n  // Adding a property should change NumObjCPropertyAttrsBits\n  // Also, don't forget to update the Clang C API at CXObjCPropertyAttrKind and\n  // clang_Cursor_getObjCPropertyAttributes.\n};\n} // namespace ObjCPropertyAttribute::Kind\n\nenum {\n  /// Number of bits fitting all the property attributes.\n  NumObjCPropertyAttrsBits = 16\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_DECLOBJC_COMMON_H\n"}, "20": {"id": 20, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/BodyFarm.h", "content": "//== BodyFarm.h - Factory for conjuring up fake bodies -------------*- C++ -*-//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// BodyFarm is a factory for creating faux implementations for functions/methods\n// for analysis purposes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LIB_ANALYSIS_BODYFARM_H\n#define LLVM_CLANG_LIB_ANALYSIS_BODYFARM_H\n\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/Optional.h\"\n\nnamespace clang {\n\nclass ASTContext;\nclass FunctionDecl;\nclass ObjCMethodDecl;\nclass ObjCPropertyDecl;\nclass Stmt;\nclass CodeInjector;\n\nclass BodyFarm {\npublic:\n  BodyFarm(ASTContext &C, CodeInjector *injector) : C(C), Injector(injector) {}\n\n  /// Factory method for creating bodies for ordinary functions.\n  Stmt *getBody(const FunctionDecl *D);\n\n  /// Factory method for creating bodies for Objective-C properties.\n  Stmt *getBody(const ObjCMethodDecl *D);\n\n  /// Remove copy constructor to avoid accidental copying.\n  BodyFarm(const BodyFarm &other) = delete;\n\nprivate:\n  typedef llvm::DenseMap<const Decl *, Optional<Stmt *>> BodyMap;\n\n  ASTContext &C;\n  BodyMap Bodies;\n  CodeInjector *Injector;\n};\n} // namespace clang\n\n#endif\n"}, "21": {"id": 21, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/PathDiagnostic.h", "content": "//===- PathDiagnostic.h - Path-Specific Diagnostic Handling -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the PathDiagnostic-related interfaces.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_BUGREPORTER_PATHDIAGNOSTIC_H\n#define LLVM_CLANG_STATICANALYZER_CORE_BUGREPORTER_PATHDIAGNOSTIC_H\n\n#include \"clang/AST/Stmt.h\"\n#include \"clang/Analysis/AnalysisDeclContext.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <cassert>\n#include <deque>\n#include <iterator>\n#include <list>\n#include <map>\n#include <memory>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace clang {\n\nclass AnalysisDeclContext;\nclass BinaryOperator;\nclass CallEnter;\nclass CallExitEnd;\nclass CallExpr;\nclass ConditionalOperator;\nclass Decl;\nclass Expr;\nclass LocationContext;\nclass MemberExpr;\nclass ProgramPoint;\nclass SourceManager;\n\nnamespace ento {\n\n//===----------------------------------------------------------------------===//\n// High-level interface for handlers of path-sensitive diagnostics.\n//===----------------------------------------------------------------------===//\n\nclass PathDiagnostic;\n\n/// These options tweak the behavior of path diangostic consumers.\n/// Most of these options are currently supported by very few consumers.\nstruct PathDiagnosticConsumerOptions {\n  /// Run-line of the tool that produced the diagnostic.\n  /// It can be included with the diagnostic for debugging purposes.\n  std::string ToolInvocation;\n\n  /// Whether to include additional information about macro expansions\n  /// with the diagnostics, because otherwise they can be hard to obtain\n  /// without re-compiling the program under analysis.\n  bool ShouldDisplayMacroExpansions = false;\n\n  /// Whether to include LLVM statistics of the process in the diagnostic.\n  /// Useful for profiling the tool on large real-world codebases.\n  bool ShouldSerializeStats = false;\n\n  /// If the consumer intends to produce multiple output files, should it\n  /// use randomly generated file names for these files (with the tiny risk of\n  /// having random collisions) or deterministic human-readable file names\n  /// (with a larger risk of deterministic collisions or invalid characters\n  /// in the file name). We should not really give this choice to the users\n  /// because deterministic mode is always superior when done right, but\n  /// for some consumers this mode is experimental and needs to be\n  /// off by default.\n  bool ShouldWriteStableReportFilename = false;\n\n  /// Whether the consumer should treat consumed diagnostics as hard errors.\n  /// Useful for breaking your build when issues are found.\n  bool ShouldDisplayWarningsAsErrors = false;\n\n  /// Whether the consumer should attempt to rewrite the source file\n  /// with fix-it hints attached to the diagnostics it consumes.\n  bool ShouldApplyFixIts = false;\n\n  /// Whether the consumer should present the name of the entity that emitted\n  /// the diagnostic (eg., a checker) so that the user knew how to disable it.\n  bool ShouldDisplayDiagnosticName = false;\n};\n\nclass PathDiagnosticConsumer {\npublic:\n  class PDFileEntry : public llvm::FoldingSetNode {\n  public:\n    PDFileEntry(llvm::FoldingSetNodeID &NodeID) : NodeID(NodeID) {}\n\n    using ConsumerFiles = std::vector<std::pair<StringRef, StringRef>>;\n\n    /// A vector of <consumer,file> pairs.\n    ConsumerFiles files;\n\n    /// A precomputed hash tag used for uniquing PDFileEntry objects.\n    const llvm::FoldingSetNodeID NodeID;\n\n    /// Used for profiling in the FoldingSet.\n    void Profile(llvm::FoldingSetNodeID &ID) { ID = NodeID; }\n  };\n\n  class FilesMade {\n    llvm::BumpPtrAllocator Alloc;\n    llvm::FoldingSet<PDFileEntry> Set;\n\n  public:\n    ~FilesMade();\n\n    bool empty() const { return Set.empty(); }\n\n    void addDiagnostic(const PathDiagnostic &PD,\n                       StringRef ConsumerName,\n                       StringRef fileName);\n\n    PDFileEntry::ConsumerFiles *getFiles(const PathDiagnostic &PD);\n  };\n\nprivate:\n  virtual void anchor();\n\npublic:\n  PathDiagnosticConsumer() = default;\n  virtual ~PathDiagnosticConsumer();\n\n  void FlushDiagnostics(FilesMade *FilesMade);\n\n  virtual void FlushDiagnosticsImpl(std::vector<const PathDiagnostic *> &Diags,\n                                    FilesMade *filesMade) = 0;\n\n  virtual StringRef getName() const = 0;\n\n  void HandlePathDiagnostic(std::unique_ptr<PathDiagnostic> D);\n\n  enum PathGenerationScheme {\n    /// Only runs visitors, no output generated.\n    None,\n\n    /// Used for HTML, SARIF, and text output.\n    Minimal,\n\n    /// Used for plist output, used for \"arrows\" generation.\n    Extensive,\n  };\n\n  virtual PathGenerationScheme getGenerationScheme() const { return Minimal; }\n\n  bool shouldGenerateDiagnostics() const {\n    return getGenerationScheme() != None;\n  }\n\n  bool shouldAddPathEdges() const { return getGenerationScheme() == Extensive; }\n\n  virtual bool supportsLogicalOpControlFlow() const { return false; }\n\n  /// Return true if the PathDiagnosticConsumer supports individual\n  /// PathDiagnostics that span multiple files.\n  virtual bool supportsCrossFileDiagnostics() const { return false; }\n\nprotected:\n  bool flushed = false;\n  llvm::FoldingSet<PathDiagnostic> Diags;\n};\n\n//===----------------------------------------------------------------------===//\n// Path-sensitive diagnostics.\n//===----------------------------------------------------------------------===//\n\nclass PathDiagnosticRange : public SourceRange {\npublic:\n  bool isPoint = false;\n\n  PathDiagnosticRange(SourceRange R, bool isP = false)\n      : SourceRange(R), isPoint(isP) {}\n  PathDiagnosticRange() = default;\n};\n\nusing LocationOrAnalysisDeclContext =\n    llvm::PointerUnion<const LocationContext *, AnalysisDeclContext *>;\n\nclass PathDiagnosticLocation {\nprivate:\n  enum Kind { RangeK, SingleLocK, StmtK, DeclK } K = SingleLocK;\n\n  const Stmt *S = nullptr;\n  const Decl *D = nullptr;\n  const SourceManager *SM = nullptr;\n  FullSourceLoc Loc;\n  PathDiagnosticRange Range;\n\n  PathDiagnosticLocation(SourceLocation L, const SourceManager &sm, Kind kind)\n      : K(kind), SM(&sm), Loc(genLocation(L)), Range(genRange()) {}\n\n  FullSourceLoc genLocation(\n      SourceLocation L = SourceLocation(),\n      LocationOrAnalysisDeclContext LAC = (AnalysisDeclContext *)nullptr) const;\n\n  PathDiagnosticRange genRange(\n      LocationOrAnalysisDeclContext LAC = (AnalysisDeclContext *)nullptr) const;\n\npublic:\n  /// Create an invalid location.\n  PathDiagnosticLocation() = default;\n\n  /// Create a location corresponding to the given statement.\n  PathDiagnosticLocation(const Stmt *s, const SourceManager &sm,\n                         LocationOrAnalysisDeclContext lac)\n      : K(s->getBeginLoc().isValid() ? StmtK : SingleLocK),\n        S(K == StmtK ? s : nullptr), SM(&sm),\n        Loc(genLocation(SourceLocation(), lac)), Range(genRange(lac)) {\n    assert(K == SingleLocK || S);\n    assert(K == SingleLocK || Loc.isValid());\n    assert(K == SingleLocK || Range.isValid());\n  }\n\n  /// Create a location corresponding to the given declaration.\n  PathDiagnosticLocation(const Decl *d, const SourceManager &sm)\n      : K(DeclK), D(d), SM(&sm), Loc(genLocation()), Range(genRange()) {\n    assert(D);\n    assert(Loc.isValid());\n    assert(Range.isValid());\n  }\n\n  /// Create a location at an explicit offset in the source.\n  ///\n  /// This should only be used if there are no more appropriate constructors.\n  PathDiagnosticLocation(SourceLocation loc, const SourceManager &sm)\n      : SM(&sm), Loc(loc, sm), Range(genRange()) {\n    assert(Loc.isValid());\n    assert(Range.isValid());\n  }\n\n  /// Create a location corresponding to the given declaration.\n  static PathDiagnosticLocation create(const Decl *D,\n                                       const SourceManager &SM) {\n    return PathDiagnosticLocation(D, SM);\n  }\n\n  /// Create a location for the beginning of the declaration.\n  static PathDiagnosticLocation createBegin(const Decl *D,\n                                            const SourceManager &SM);\n\n  /// Create a location for the beginning of the declaration.\n  /// The third argument is ignored, useful for generic treatment\n  /// of statements and declarations.\n  static PathDiagnosticLocation\n  createBegin(const Decl *D, const SourceManager &SM,\n              const LocationOrAnalysisDeclContext LAC) {\n    return createBegin(D, SM);\n  }\n\n  /// Create a location for the beginning of the statement.\n  static PathDiagnosticLocation createBegin(const Stmt *S,\n                                            const SourceManager &SM,\n                                            const LocationOrAnalysisDeclContext LAC);\n\n  /// Create a location for the end of the statement.\n  ///\n  /// If the statement is a CompoundStatement, the location will point to the\n  /// closing brace instead of following it.\n  static PathDiagnosticLocation createEnd(const Stmt *S,\n                                          const SourceManager &SM,\n                                       const LocationOrAnalysisDeclContext LAC);\n\n  /// Create the location for the operator of the binary expression.\n  /// Assumes the statement has a valid location.\n  static PathDiagnosticLocation createOperatorLoc(const BinaryOperator *BO,\n                                                  const SourceManager &SM);\n  static PathDiagnosticLocation createConditionalColonLoc(\n                                                  const ConditionalOperator *CO,\n                                                  const SourceManager &SM);\n\n  /// For member expressions, return the location of the '.' or '->'.\n  /// Assumes the statement has a valid location.\n  static PathDiagnosticLocation createMemberLoc(const MemberExpr *ME,\n                                                const SourceManager &SM);\n\n  /// Create a location for the beginning of the compound statement.\n  /// Assumes the statement has a valid location.\n  static PathDiagnosticLocation createBeginBrace(const CompoundStmt *CS,\n                                                 const SourceManager &SM);\n\n  /// Create a location for the end of the compound statement.\n  /// Assumes the statement has a valid location.\n  static PathDiagnosticLocation createEndBrace(const CompoundStmt *CS,\n                                               const SourceManager &SM);\n\n  /// Create a location for the beginning of the enclosing declaration body.\n  /// Defaults to the beginning of the first statement in the declaration body.\n  static PathDiagnosticLocation createDeclBegin(const LocationContext *LC,\n                                                const SourceManager &SM);\n\n  /// Constructs a location for the end of the enclosing declaration body.\n  /// Defaults to the end of brace.\n  static PathDiagnosticLocation createDeclEnd(const LocationContext *LC,\n                                                   const SourceManager &SM);\n\n  /// Create a location corresponding to the given valid ProgramPoint.\n  static PathDiagnosticLocation create(const ProgramPoint &P,\n                                       const SourceManager &SMng);\n\n  /// Convert the given location into a single kind location.\n  static PathDiagnosticLocation createSingleLocation(\n                                             const PathDiagnosticLocation &PDL);\n\n  /// Construct a source location that corresponds to either the beginning\n  /// or the end of the given statement, or a nearby valid source location\n  /// if the statement does not have a valid source location of its own.\n  static SourceLocation\n  getValidSourceLocation(const Stmt *S, LocationOrAnalysisDeclContext LAC,\n                         bool UseEndOfStatement = false);\n\n  bool operator==(const PathDiagnosticLocation &X) const {\n    return K == X.K && Loc == X.Loc && Range == X.Range;\n  }\n\n  bool operator!=(const PathDiagnosticLocation &X) const {\n    return !(*this == X);\n  }\n\n  bool isValid() const {\n    return SM != nullptr;\n  }\n\n  FullSourceLoc asLocation() const {\n    return Loc;\n  }\n\n  PathDiagnosticRange asRange() const {\n    return Range;\n  }\n\n  const Stmt *asStmt() const { assert(isValid()); return S; }\n  const Stmt *getStmtOrNull() const {\n    if (!isValid())\n      return nullptr;\n    return asStmt();\n  }\n\n  const Decl *asDecl() const { assert(isValid()); return D; }\n\n  bool hasRange() const { return K == StmtK || K == RangeK || K == DeclK; }\n\n  bool hasValidLocation() const { return asLocation().isValid(); }\n\n  void invalidate() {\n    *this = PathDiagnosticLocation();\n  }\n\n  void flatten();\n\n  const SourceManager& getManager() const { assert(isValid()); return *SM; }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const;\n\n  void dump() const;\n};\n\nclass PathDiagnosticLocationPair {\nprivate:\n  PathDiagnosticLocation Start, End;\n\npublic:\n  PathDiagnosticLocationPair(const PathDiagnosticLocation &start,\n                             const PathDiagnosticLocation &end)\n      : Start(start), End(end) {}\n\n  const PathDiagnosticLocation &getStart() const { return Start; }\n  const PathDiagnosticLocation &getEnd() const { return End; }\n\n  void setStart(const PathDiagnosticLocation &L) { Start = L; }\n  void setEnd(const PathDiagnosticLocation &L) { End = L; }\n\n  void flatten() {\n    Start.flatten();\n    End.flatten();\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    Start.Profile(ID);\n    End.Profile(ID);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Path \"pieces\" for path-sensitive diagnostics.\n//===----------------------------------------------------------------------===//\n\nclass PathDiagnosticPiece: public llvm::FoldingSetNode {\npublic:\n  enum Kind { ControlFlow, Event, Macro, Call, Note, PopUp };\n  enum DisplayHint { Above, Below };\n\nprivate:\n  const std::string str;\n  const Kind kind;\n  const DisplayHint Hint;\n\n  /// In the containing bug report, this piece is the last piece from\n  /// the main source file.\n  bool LastInMainSourceFile = false;\n\n  /// A constant string that can be used to tag the PathDiagnosticPiece,\n  /// typically with the identification of the creator.  The actual pointer\n  /// value is meant to be an identifier; the string itself is useful for\n  /// debugging.\n  StringRef Tag;\n\n  std::vector<SourceRange> ranges;\n  std::vector<FixItHint> fixits;\n\nprotected:\n  PathDiagnosticPiece(StringRef s, Kind k, DisplayHint hint = Below);\n  PathDiagnosticPiece(Kind k, DisplayHint hint = Below);\n\npublic:\n  PathDiagnosticPiece() = delete;\n  PathDiagnosticPiece(const PathDiagnosticPiece &) = delete;\n  PathDiagnosticPiece &operator=(const PathDiagnosticPiece &) = delete;\n  virtual ~PathDiagnosticPiece();\n\n  StringRef getString() const { return str; }\n\n  /// Tag this PathDiagnosticPiece with the given C-string.\n  void setTag(const char *tag) { Tag = tag; }\n\n  /// Return the opaque tag (if any) on the PathDiagnosticPiece.\n  const void *getTag() const { return Tag.data(); }\n\n  /// Return the string representation of the tag.  This is useful\n  /// for debugging.\n  StringRef getTagStr() const { return Tag; }\n\n  /// getDisplayHint - Return a hint indicating where the diagnostic should\n  ///  be displayed by the PathDiagnosticConsumer.\n  DisplayHint getDisplayHint() const { return Hint; }\n\n  virtual PathDiagnosticLocation getLocation() const = 0;\n  virtual void flattenLocations() = 0;\n\n  Kind getKind() const { return kind; }\n\n  void addRange(SourceRange R) {\n    if (!R.isValid())\n      return;\n    ranges.push_back(R);\n  }\n\n  void addRange(SourceLocation B, SourceLocation E) {\n    if (!B.isValid() || !E.isValid())\n      return;\n    ranges.push_back(SourceRange(B,E));\n  }\n\n  void addFixit(FixItHint F) {\n    fixits.push_back(F);\n  }\n\n  /// Return the SourceRanges associated with this PathDiagnosticPiece.\n  ArrayRef<SourceRange> getRanges() const { return ranges; }\n\n  /// Return the fix-it hints associated with this PathDiagnosticPiece.\n  ArrayRef<FixItHint> getFixits() const { return fixits; }\n\n  virtual void Profile(llvm::FoldingSetNodeID &ID) const;\n\n  void setAsLastInMainSourceFile() {\n    LastInMainSourceFile = true;\n  }\n\n  bool isLastInMainSourceFile() const {\n    return LastInMainSourceFile;\n  }\n\n  virtual void dump() const = 0;\n};\n\nusing PathDiagnosticPieceRef = std::shared_ptr<PathDiagnosticPiece>;\n\nclass PathPieces : public std::list<PathDiagnosticPieceRef> {\n  void flattenTo(PathPieces &Primary, PathPieces &Current,\n                 bool ShouldFlattenMacros) const;\n\npublic:\n  PathPieces flatten(bool ShouldFlattenMacros) const {\n    PathPieces Result;\n    flattenTo(Result, Result, ShouldFlattenMacros);\n    return Result;\n  }\n\n  void dump() const;\n};\n\nclass PathDiagnosticSpotPiece : public PathDiagnosticPiece {\nprivate:\n  PathDiagnosticLocation Pos;\n\npublic:\n  PathDiagnosticSpotPiece(const PathDiagnosticLocation &pos,\n                          StringRef s,\n                          PathDiagnosticPiece::Kind k,\n                          bool addPosRange = true)\n      : PathDiagnosticPiece(s, k), Pos(pos) {\n    assert(Pos.isValid() && Pos.hasValidLocation() &&\n           \"PathDiagnosticSpotPiece's must have a valid location.\");\n    if (addPosRange && Pos.hasRange()) addRange(Pos.asRange());\n  }\n\n  PathDiagnosticLocation getLocation() const override { return Pos; }\n  void flattenLocations() override { Pos.flatten(); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == Event || P->getKind() == Macro ||\n           P->getKind() == Note || P->getKind() == PopUp;\n  }\n};\n\nclass PathDiagnosticEventPiece : public PathDiagnosticSpotPiece {\n  Optional<bool> IsPrunable;\n\npublic:\n  PathDiagnosticEventPiece(const PathDiagnosticLocation &pos,\n                           StringRef s, bool addPosRange = true)\n      : PathDiagnosticSpotPiece(pos, s, Event, addPosRange) {}\n  ~PathDiagnosticEventPiece() override;\n\n  /// Mark the diagnostic piece as being potentially prunable.  This\n  /// flag may have been previously set, at which point it will not\n  /// be reset unless one specifies to do so.\n  void setPrunable(bool isPrunable, bool override = false) {\n    if (IsPrunable.hasValue() && !override)\n     return;\n    IsPrunable = isPrunable;\n  }\n\n  /// Return true if the diagnostic piece is prunable.\n  bool isPrunable() const {\n    return IsPrunable.hasValue() ? IsPrunable.getValue() : false;\n  }\n\n  void dump() const override;\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == Event;\n  }\n};\n\nclass PathDiagnosticCallPiece : public PathDiagnosticPiece {\n  const Decl *Caller;\n  const Decl *Callee = nullptr;\n\n  // Flag signifying that this diagnostic has only call enter and no matching\n  // call exit.\n  bool NoExit;\n\n  // Flag signifying that the callee function is an Objective-C autosynthesized\n  // property getter or setter.\n  bool IsCalleeAnAutosynthesizedPropertyAccessor = false;\n\n  // The custom string, which should appear after the call Return Diagnostic.\n  // TODO: Should we allow multiple diagnostics?\n  std::string CallStackMessage;\n\n  PathDiagnosticCallPiece(const Decl *callerD,\n                          const PathDiagnosticLocation &callReturnPos)\n      : PathDiagnosticPiece(Call), Caller(callerD), NoExit(false),\n        callReturn(callReturnPos) {}\n  PathDiagnosticCallPiece(PathPieces &oldPath, const Decl *caller)\n      : PathDiagnosticPiece(Call), Caller(caller), NoExit(true),\n        path(oldPath) {}\n\npublic:\n  PathDiagnosticLocation callEnter;\n  PathDiagnosticLocation callEnterWithin;\n  PathDiagnosticLocation callReturn;\n  PathPieces path;\n\n  ~PathDiagnosticCallPiece() override;\n\n  const Decl *getCaller() const { return Caller; }\n\n  const Decl *getCallee() const { return Callee; }\n  void setCallee(const CallEnter &CE, const SourceManager &SM);\n\n  bool hasCallStackMessage() { return !CallStackMessage.empty(); }\n  void setCallStackMessage(StringRef st) { CallStackMessage = std::string(st); }\n\n  PathDiagnosticLocation getLocation() const override { return callEnter; }\n\n  std::shared_ptr<PathDiagnosticEventPiece> getCallEnterEvent() const;\n  std::shared_ptr<PathDiagnosticEventPiece>\n  getCallEnterWithinCallerEvent() const;\n  std::shared_ptr<PathDiagnosticEventPiece> getCallExitEvent() const;\n\n  void flattenLocations() override {\n    callEnter.flatten();\n    callReturn.flatten();\n    for (const auto &I : path)\n      I->flattenLocations();\n  }\n\n  static std::shared_ptr<PathDiagnosticCallPiece>\n  construct(const CallExitEnd &CE,\n            const SourceManager &SM);\n\n  static PathDiagnosticCallPiece *construct(PathPieces &pieces,\n                                            const Decl *caller);\n\n  void dump() const override;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == Call;\n  }\n};\n\nclass PathDiagnosticControlFlowPiece : public PathDiagnosticPiece {\n  std::vector<PathDiagnosticLocationPair> LPairs;\n\npublic:\n  PathDiagnosticControlFlowPiece(const PathDiagnosticLocation &startPos,\n                                 const PathDiagnosticLocation &endPos,\n                                 StringRef s)\n      : PathDiagnosticPiece(s, ControlFlow) {\n    LPairs.push_back(PathDiagnosticLocationPair(startPos, endPos));\n  }\n\n  PathDiagnosticControlFlowPiece(const PathDiagnosticLocation &startPos,\n                                 const PathDiagnosticLocation &endPos)\n      : PathDiagnosticPiece(ControlFlow) {\n    LPairs.push_back(PathDiagnosticLocationPair(startPos, endPos));\n  }\n\n  ~PathDiagnosticControlFlowPiece() override;\n\n  PathDiagnosticLocation getStartLocation() const {\n    assert(!LPairs.empty() &&\n           \"PathDiagnosticControlFlowPiece needs at least one location.\");\n    return LPairs[0].getStart();\n  }\n\n  PathDiagnosticLocation getEndLocation() const {\n    assert(!LPairs.empty() &&\n           \"PathDiagnosticControlFlowPiece needs at least one location.\");\n    return LPairs[0].getEnd();\n  }\n\n  void setStartLocation(const PathDiagnosticLocation &L) {\n    LPairs[0].setStart(L);\n  }\n\n  void setEndLocation(const PathDiagnosticLocation &L) {\n    LPairs[0].setEnd(L);\n  }\n\n  void push_back(const PathDiagnosticLocationPair &X) { LPairs.push_back(X); }\n\n  PathDiagnosticLocation getLocation() const override {\n    return getStartLocation();\n  }\n\n  using iterator = std::vector<PathDiagnosticLocationPair>::iterator;\n\n  iterator begin() { return LPairs.begin(); }\n  iterator end() { return LPairs.end(); }\n\n  void flattenLocations() override {\n    for (auto &I : *this)\n      I.flatten();\n  }\n\n  using const_iterator =\n      std::vector<PathDiagnosticLocationPair>::const_iterator;\n\n  const_iterator begin() const { return LPairs.begin(); }\n  const_iterator end() const { return LPairs.end(); }\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == ControlFlow;\n  }\n\n  void dump() const override;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n};\n\nclass PathDiagnosticMacroPiece : public PathDiagnosticSpotPiece {\npublic:\n  PathDiagnosticMacroPiece(const PathDiagnosticLocation &pos)\n      : PathDiagnosticSpotPiece(pos, \"\", Macro) {}\n  ~PathDiagnosticMacroPiece() override;\n\n  PathPieces subPieces;\n\n  void flattenLocations() override {\n    PathDiagnosticSpotPiece::flattenLocations();\n    for (const auto &I : subPieces)\n      I->flattenLocations();\n  }\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == Macro;\n  }\n\n  void dump() const override;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n};\n\nclass PathDiagnosticNotePiece: public PathDiagnosticSpotPiece {\npublic:\n  PathDiagnosticNotePiece(const PathDiagnosticLocation &Pos, StringRef S,\n                          bool AddPosRange = true)\n      : PathDiagnosticSpotPiece(Pos, S, Note, AddPosRange) {}\n  ~PathDiagnosticNotePiece() override;\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == Note;\n  }\n\n  void dump() const override;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n};\n\nclass PathDiagnosticPopUpPiece: public PathDiagnosticSpotPiece {\npublic:\n  PathDiagnosticPopUpPiece(const PathDiagnosticLocation &Pos, StringRef S,\n                           bool AddPosRange = true)\n      : PathDiagnosticSpotPiece(Pos, S, PopUp, AddPosRange) {}\n  ~PathDiagnosticPopUpPiece() override;\n\n  static bool classof(const PathDiagnosticPiece *P) {\n    return P->getKind() == PopUp;\n  }\n\n  void dump() const override;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const override;\n};\n\n/// File IDs mapped to sets of line numbers.\nusing FilesToLineNumsMap = std::map<FileID, std::set<unsigned>>;\n\n/// PathDiagnostic - PathDiagnostic objects represent a single path-sensitive\n///  diagnostic.  It represents an ordered-collection of PathDiagnosticPieces,\n///  each which represent the pieces of the path.\nclass PathDiagnostic : public llvm::FoldingSetNode {\n  std::string CheckerName;\n  const Decl *DeclWithIssue;\n  std::string BugType;\n  std::string VerboseDesc;\n  std::string ShortDesc;\n  std::string Category;\n  std::deque<std::string> OtherDesc;\n\n  /// Loc The location of the path diagnostic report.\n  PathDiagnosticLocation Loc;\n\n  PathPieces pathImpl;\n  SmallVector<PathPieces *, 3> pathStack;\n\n  /// Important bug uniqueing location.\n  /// The location info is useful to differentiate between bugs.\n  PathDiagnosticLocation UniqueingLoc;\n  const Decl *UniqueingDecl;\n\n  /// Lines executed in the path.\n  std::unique_ptr<FilesToLineNumsMap> ExecutedLines;\n\npublic:\n  PathDiagnostic() = delete;\n  PathDiagnostic(StringRef CheckerName, const Decl *DeclWithIssue,\n                 StringRef bugtype, StringRef verboseDesc, StringRef shortDesc,\n                 StringRef category, PathDiagnosticLocation LocationToUnique,\n                 const Decl *DeclToUnique,\n                 std::unique_ptr<FilesToLineNumsMap> ExecutedLines);\n  ~PathDiagnostic();\n\n  const PathPieces &path;\n\n  /// Return the path currently used by builders for constructing the\n  /// PathDiagnostic.\n  PathPieces &getActivePath() {\n    if (pathStack.empty())\n      return pathImpl;\n    return *pathStack.back();\n  }\n\n  /// Return a mutable version of 'path'.\n  PathPieces &getMutablePieces() {\n    return pathImpl;\n  }\n\n  /// Return the unrolled size of the path.\n  unsigned full_size();\n\n  void pushActivePath(PathPieces *p) { pathStack.push_back(p); }\n  void popActivePath() { if (!pathStack.empty()) pathStack.pop_back(); }\n\n  bool isWithinCall() const { return !pathStack.empty(); }\n\n  void setEndOfPath(PathDiagnosticPieceRef EndPiece) {\n    assert(!Loc.isValid() && \"End location already set!\");\n    Loc = EndPiece->getLocation();\n    assert(Loc.isValid() && \"Invalid location for end-of-path piece\");\n    getActivePath().push_back(std::move(EndPiece));\n  }\n\n  void appendToDesc(StringRef S) {\n    if (!ShortDesc.empty())\n      ShortDesc += S;\n    VerboseDesc += S;\n  }\n\n  StringRef getVerboseDescription() const { return VerboseDesc; }\n\n  StringRef getShortDescription() const {\n    return ShortDesc.empty() ? VerboseDesc : ShortDesc;\n  }\n\n  StringRef getCheckerName() const { return CheckerName; }\n  StringRef getBugType() const { return BugType; }\n  StringRef getCategory() const { return Category; }\n\n  using meta_iterator = std::deque<std::string>::const_iterator;\n\n  meta_iterator meta_begin() const { return OtherDesc.begin(); }\n  meta_iterator meta_end() const { return OtherDesc.end(); }\n  void addMeta(StringRef s) { OtherDesc.push_back(std::string(s)); }\n\n  const FilesToLineNumsMap &getExecutedLines() const {\n    return *ExecutedLines;\n  }\n\n  FilesToLineNumsMap &getExecutedLines() {\n    return *ExecutedLines;\n  }\n\n  /// Return the semantic context where an issue occurred.  If the\n  /// issue occurs along a path, this represents the \"central\" area\n  /// where the bug manifests.\n  const Decl *getDeclWithIssue() const { return DeclWithIssue; }\n\n  void setDeclWithIssue(const Decl *D) {\n    DeclWithIssue = D;\n  }\n\n  PathDiagnosticLocation getLocation() const {\n    return Loc;\n  }\n\n  void setLocation(PathDiagnosticLocation NewLoc) {\n    Loc = NewLoc;\n  }\n\n  /// Get the location on which the report should be uniqued.\n  PathDiagnosticLocation getUniqueingLoc() const {\n    return UniqueingLoc;\n  }\n\n  /// Get the declaration containing the uniqueing location.\n  const Decl *getUniqueingDecl() const {\n    return UniqueingDecl;\n  }\n\n  void flattenLocations() {\n    Loc.flatten();\n    for (const auto &I : pathImpl)\n      I->flattenLocations();\n  }\n\n  /// Profiles the diagnostic, independent of the path it references.\n  ///\n  /// This can be used to merge diagnostics that refer to the same issue\n  /// along different paths.\n  void Profile(llvm::FoldingSetNodeID &ID) const;\n\n  /// Profiles the diagnostic, including its path.\n  ///\n  /// Two diagnostics with the same issue along different paths will generate\n  /// different profiles.\n  void FullProfile(llvm::FoldingSetNodeID &ID) const;\n};\n\n} // namespace ento\n} // namespace clang\n\n#endif // LLVM_CLANG_STATICANALYZER_CORE_BUGREPORTER_PATHDIAGNOSTIC_H\n"}, "22": {"id": 22, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/AttrSubjectMatchRules.h", "content": "//===-- AttrSubjectMatchRules.h - Attribute subject match rules -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_ATTR_SUBJECT_MATCH_RULES_H\n#define LLVM_CLANG_BASIC_ATTR_SUBJECT_MATCH_RULES_H\n\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/DenseMap.h\"\n\nnamespace clang {\nnamespace attr {\n\n/// A list of all the recognized kinds of attributes.\nenum SubjectMatchRule {\n#define ATTR_MATCH_RULE(X, Spelling, IsAbstract) X,\n#include \"clang/Basic/AttrSubMatchRulesList.inc\"\n};\n\nconst char *getSubjectMatchRuleSpelling(SubjectMatchRule Rule);\n\nusing ParsedSubjectMatchRuleSet = llvm::DenseMap<int, SourceRange>;\n\n} // end namespace attr\n} // end namespace clang\n\n#endif\n"}, "23": {"id": 23, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h", "content": "//===--- DiagnosticIDs.h - Diagnostic IDs Handling --------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Defines the Diagnostic IDs-related interfaces.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_DIAGNOSTICIDS_H\n#define LLVM_CLANG_BASIC_DIAGNOSTICIDS_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <vector>\n\nnamespace clang {\n  class DiagnosticsEngine;\n  class SourceLocation;\n\n  // Import the diagnostic enums themselves.\n  namespace diag {\n    // Size of each of the diagnostic categories.\n    enum {\n      DIAG_SIZE_COMMON        =  300,\n      DIAG_SIZE_DRIVER        =  250,\n      DIAG_SIZE_FRONTEND      =  150,\n      DIAG_SIZE_SERIALIZATION =  120,\n      DIAG_SIZE_LEX           =  400,\n      DIAG_SIZE_PARSE         =  600,\n      DIAG_SIZE_AST           =  250,\n      DIAG_SIZE_COMMENT       =  100,\n      DIAG_SIZE_CROSSTU       =  100,\n      DIAG_SIZE_SEMA          = 4500,\n      DIAG_SIZE_ANALYSIS      =  100,\n      DIAG_SIZE_REFACTORING   = 1000,\n    };\n    // Start position for diagnostics.\n    enum {\n      DIAG_START_COMMON        =                          0,\n      DIAG_START_DRIVER        = DIAG_START_COMMON        + DIAG_SIZE_COMMON,\n      DIAG_START_FRONTEND      = DIAG_START_DRIVER        + DIAG_SIZE_DRIVER,\n      DIAG_START_SERIALIZATION = DIAG_START_FRONTEND      + DIAG_SIZE_FRONTEND,\n      DIAG_START_LEX           = DIAG_START_SERIALIZATION + DIAG_SIZE_SERIALIZATION,\n      DIAG_START_PARSE         = DIAG_START_LEX           + DIAG_SIZE_LEX,\n      DIAG_START_AST           = DIAG_START_PARSE         + DIAG_SIZE_PARSE,\n      DIAG_START_COMMENT       = DIAG_START_AST           + DIAG_SIZE_AST,\n      DIAG_START_CROSSTU       = DIAG_START_COMMENT       + DIAG_SIZE_COMMENT,\n      DIAG_START_SEMA          = DIAG_START_CROSSTU       + DIAG_SIZE_CROSSTU,\n      DIAG_START_ANALYSIS      = DIAG_START_SEMA          + DIAG_SIZE_SEMA,\n      DIAG_START_REFACTORING   = DIAG_START_ANALYSIS      + DIAG_SIZE_ANALYSIS,\n      DIAG_UPPER_LIMIT         = DIAG_START_REFACTORING   + DIAG_SIZE_REFACTORING\n    };\n\n    class CustomDiagInfo;\n\n    /// All of the diagnostics that can be emitted by the frontend.\n    typedef unsigned kind;\n\n    // Get typedefs for common diagnostics.\n    enum {\n#define DIAG(ENUM, FLAGS, DEFAULT_MAPPING, DESC, GROUP, SFINAE, CATEGORY,      \\\n             NOWERROR, SHOWINSYSHEADER, DEFFERABLE)                            \\\n  ENUM,\n#define COMMONSTART\n#include \"clang/Basic/DiagnosticCommonKinds.inc\"\n      NUM_BUILTIN_COMMON_DIAGNOSTICS\n#undef DIAG\n    };\n\n    /// Enum values that allow the client to map NOTEs, WARNINGs, and EXTENSIONs\n    /// to either Ignore (nothing), Remark (emit a remark), Warning\n    /// (emit a warning) or Error (emit as an error).  It allows clients to\n    /// map ERRORs to Error or Fatal (stop emitting diagnostics after this one).\n    enum class Severity {\n      // NOTE: 0 means \"uncomputed\".\n      Ignored = 1, ///< Do not present this diagnostic, ignore it.\n      Remark = 2,  ///< Present this diagnostic as a remark.\n      Warning = 3, ///< Present this diagnostic as a warning.\n      Error = 4,   ///< Present this diagnostic as an error.\n      Fatal = 5    ///< Present this diagnostic as a fatal error.\n    };\n\n    /// Flavors of diagnostics we can emit. Used to filter for a particular\n    /// kind of diagnostic (for instance, for -W/-R flags).\n    enum class Flavor {\n      WarningOrError, ///< A diagnostic that indicates a problem or potential\n                      ///< problem. Can be made fatal by -Werror.\n      Remark          ///< A diagnostic that indicates normal progress through\n                      ///< compilation.\n    };\n  }\n\nclass DiagnosticMapping {\n  unsigned Severity : 3;\n  unsigned IsUser : 1;\n  unsigned IsPragma : 1;\n  unsigned HasNoWarningAsError : 1;\n  unsigned HasNoErrorAsFatal : 1;\n  unsigned WasUpgradedFromWarning : 1;\n\npublic:\n  static DiagnosticMapping Make(diag::Severity Severity, bool IsUser,\n                                bool IsPragma) {\n    DiagnosticMapping Result;\n    Result.Severity = (unsigned)Severity;\n    Result.IsUser = IsUser;\n    Result.IsPragma = IsPragma;\n    Result.HasNoWarningAsError = 0;\n    Result.HasNoErrorAsFatal = 0;\n    Result.WasUpgradedFromWarning = 0;\n    return Result;\n  }\n\n  diag::Severity getSeverity() const { return (diag::Severity)Severity; }\n  void setSeverity(diag::Severity Value) { Severity = (unsigned)Value; }\n\n  bool isUser() const { return IsUser; }\n  bool isPragma() const { return IsPragma; }\n\n  bool isErrorOrFatal() const {\n    return getSeverity() == diag::Severity::Error ||\n           getSeverity() == diag::Severity::Fatal;\n  }\n\n  bool hasNoWarningAsError() const { return HasNoWarningAsError; }\n  void setNoWarningAsError(bool Value) { HasNoWarningAsError = Value; }\n\n  bool hasNoErrorAsFatal() const { return HasNoErrorAsFatal; }\n  void setNoErrorAsFatal(bool Value) { HasNoErrorAsFatal = Value; }\n\n  /// Whether this mapping attempted to map the diagnostic to a warning, but\n  /// was overruled because the diagnostic was already mapped to an error or\n  /// fatal error.\n  bool wasUpgradedFromWarning() const { return WasUpgradedFromWarning; }\n  void setUpgradedFromWarning(bool Value) { WasUpgradedFromWarning = Value; }\n\n  /// Serialize this mapping as a raw integer.\n  unsigned serialize() const {\n    return (IsUser << 7) | (IsPragma << 6) | (HasNoWarningAsError << 5) |\n           (HasNoErrorAsFatal << 4) | (WasUpgradedFromWarning << 3) | Severity;\n  }\n  /// Deserialize a mapping.\n  static DiagnosticMapping deserialize(unsigned Bits) {\n    DiagnosticMapping Result;\n    Result.IsUser = (Bits >> 7) & 1;\n    Result.IsPragma = (Bits >> 6) & 1;\n    Result.HasNoWarningAsError = (Bits >> 5) & 1;\n    Result.HasNoErrorAsFatal = (Bits >> 4) & 1;\n    Result.WasUpgradedFromWarning = (Bits >> 3) & 1;\n    Result.Severity = Bits & 0x7;\n    return Result;\n  }\n};\n\n/// Used for handling and querying diagnostic IDs.\n///\n/// Can be used and shared by multiple Diagnostics for multiple translation units.\nclass DiagnosticIDs : public RefCountedBase<DiagnosticIDs> {\npublic:\n  /// The level of the diagnostic, after it has been through mapping.\n  enum Level {\n    Ignored, Note, Remark, Warning, Error, Fatal\n  };\n\nprivate:\n  /// Information for uniquing and looking up custom diags.\n  std::unique_ptr<diag::CustomDiagInfo> CustomDiagInfo;\n\npublic:\n  DiagnosticIDs();\n  ~DiagnosticIDs();\n\n  /// Return an ID for a diagnostic with the specified format string and\n  /// level.\n  ///\n  /// If this is the first request for this diagnostic, it is registered and\n  /// created, otherwise the existing ID is returned.\n\n  // FIXME: Replace this function with a create-only facilty like\n  // createCustomDiagIDFromFormatString() to enforce safe usage. At the time of\n  // writing, nearly all callers of this function were invalid.\n  unsigned getCustomDiagID(Level L, StringRef FormatString);\n\n  //===--------------------------------------------------------------------===//\n  // Diagnostic classification and reporting interfaces.\n  //\n\n  /// Given a diagnostic ID, return a description of the issue.\n  StringRef getDescription(unsigned DiagID) const;\n\n  /// Return true if the unmapped diagnostic levelof the specified\n  /// diagnostic ID is a Warning or Extension.\n  ///\n  /// This only works on builtin diagnostics, not custom ones, and is not\n  /// legal to call on NOTEs.\n  static bool isBuiltinWarningOrExtension(unsigned DiagID);\n\n  /// Return true if the specified diagnostic is mapped to errors by\n  /// default.\n  static bool isDefaultMappingAsError(unsigned DiagID);\n\n  /// Determine whether the given built-in diagnostic ID is a Note.\n  static bool isBuiltinNote(unsigned DiagID);\n\n  /// Determine whether the given built-in diagnostic ID is for an\n  /// extension of some sort.\n  static bool isBuiltinExtensionDiag(unsigned DiagID) {\n    bool ignored;\n    return isBuiltinExtensionDiag(DiagID, ignored);\n  }\n\n  /// Determine whether the given built-in diagnostic ID is for an\n  /// extension of some sort, and whether it is enabled by default.\n  ///\n  /// This also returns EnabledByDefault, which is set to indicate whether the\n  /// diagnostic is ignored by default (in which case -pedantic enables it) or\n  /// treated as a warning/error by default.\n  ///\n  static bool isBuiltinExtensionDiag(unsigned DiagID, bool &EnabledByDefault);\n\n\n  /// Return the lowest-level warning option that enables the specified\n  /// diagnostic.\n  ///\n  /// If there is no -Wfoo flag that controls the diagnostic, this returns null.\n  static StringRef getWarningOptionForDiag(unsigned DiagID);\n\n  /// Return the category number that a specified \\p DiagID belongs to,\n  /// or 0 if no category.\n  static unsigned getCategoryNumberForDiag(unsigned DiagID);\n\n  /// Return the number of diagnostic categories.\n  static unsigned getNumberOfCategories();\n\n  /// Given a category ID, return the name of the category.\n  static StringRef getCategoryNameFromID(unsigned CategoryID);\n\n  /// Return true if a given diagnostic falls into an ARC diagnostic\n  /// category.\n  static bool isARCDiagnostic(unsigned DiagID);\n\n  /// Enumeration describing how the emission of a diagnostic should\n  /// be treated when it occurs during C++ template argument deduction.\n  enum SFINAEResponse {\n    /// The diagnostic should not be reported, but it should cause\n    /// template argument deduction to fail.\n    ///\n    /// The vast majority of errors that occur during template argument\n    /// deduction fall into this category.\n    SFINAE_SubstitutionFailure,\n\n    /// The diagnostic should be suppressed entirely.\n    ///\n    /// Warnings generally fall into this category.\n    SFINAE_Suppress,\n\n    /// The diagnostic should be reported.\n    ///\n    /// The diagnostic should be reported. Various fatal errors (e.g.,\n    /// template instantiation depth exceeded) fall into this category.\n    SFINAE_Report,\n\n    /// The diagnostic is an access-control diagnostic, which will be\n    /// substitution failures in some contexts and reported in others.\n    SFINAE_AccessControl\n  };\n\n  /// Determines whether the given built-in diagnostic ID is\n  /// for an error that is suppressed if it occurs during C++ template\n  /// argument deduction.\n  ///\n  /// When an error is suppressed due to SFINAE, the template argument\n  /// deduction fails but no diagnostic is emitted. Certain classes of\n  /// errors, such as those errors that involve C++ access control,\n  /// are not SFINAE errors.\n  static SFINAEResponse getDiagnosticSFINAEResponse(unsigned DiagID);\n\n  /// Whether the diagnostic message can be deferred.\n  ///\n  /// For single source offloading languages, a diagnostic message occurred\n  /// in a device host function may be deferred until the function is sure\n  /// to be emitted.\n  static bool isDeferrable(unsigned DiagID);\n\n  /// Get the string of all diagnostic flags.\n  ///\n  /// \\returns A list of all diagnostics flags as they would be written in a\n  /// command line invocation including their `no-` variants. For example:\n  /// `{\"-Wempty-body\", \"-Wno-empty-body\", ...}`\n  static std::vector<std::string> getDiagnosticFlags();\n\n  /// Get the set of all diagnostic IDs in the group with the given name.\n  ///\n  /// \\param[out] Diags - On return, the diagnostics in the group.\n  /// \\returns \\c true if the given group is unknown, \\c false otherwise.\n  bool getDiagnosticsInGroup(diag::Flavor Flavor, StringRef Group,\n                             SmallVectorImpl<diag::kind> &Diags) const;\n\n  /// Get the set of all diagnostic IDs.\n  static void getAllDiagnostics(diag::Flavor Flavor,\n                                std::vector<diag::kind> &Diags);\n\n  /// Get the diagnostic option with the closest edit distance to the\n  /// given group name.\n  static StringRef getNearestOption(diag::Flavor Flavor, StringRef Group);\n\nprivate:\n  /// Classify the specified diagnostic ID into a Level, consumable by\n  /// the DiagnosticClient.\n  ///\n  /// The classification is based on the way the client configured the\n  /// DiagnosticsEngine object.\n  ///\n  /// \\param Loc The source location for which we are interested in finding out\n  /// the diagnostic state. Can be null in order to query the latest state.\n  DiagnosticIDs::Level\n  getDiagnosticLevel(unsigned DiagID, SourceLocation Loc,\n                     const DiagnosticsEngine &Diag) const LLVM_READONLY;\n\n  diag::Severity\n  getDiagnosticSeverity(unsigned DiagID, SourceLocation Loc,\n                        const DiagnosticsEngine &Diag) const LLVM_READONLY;\n\n  /// Used to report a diagnostic that is finally fully formed.\n  ///\n  /// \\returns \\c true if the diagnostic was emitted, \\c false if it was\n  /// suppressed.\n  bool ProcessDiag(DiagnosticsEngine &Diag) const;\n\n  /// Used to emit a diagnostic that is finally fully formed,\n  /// ignoring suppression.\n  void EmitDiag(DiagnosticsEngine &Diag, Level DiagLevel) const;\n\n  /// Whether the diagnostic may leave the AST in a state where some\n  /// invariants can break.\n  bool isUnrecoverable(unsigned DiagID) const;\n\n  friend class DiagnosticsEngine;\n};\n\n}  // end namespace clang\n\n#endif\n"}, "24": {"id": 24, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/PragmaKinds.h", "content": "//===--- PragmaKinds.h - #pragma comment() kinds  ---------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_PRAGMA_KINDS_H\n#define LLVM_CLANG_BASIC_PRAGMA_KINDS_H\n\nnamespace clang {\n\nenum PragmaMSCommentKind {\n  PCK_Unknown,\n  PCK_Linker,   // #pragma comment(linker, ...)\n  PCK_Lib,      // #pragma comment(lib, ...)\n  PCK_Compiler, // #pragma comment(compiler, ...)\n  PCK_ExeStr,   // #pragma comment(exestr, ...)\n  PCK_User      // #pragma comment(user, ...)\n};\n\nenum PragmaMSStructKind {\n  PMSST_OFF, // #pragms ms_struct off\n  PMSST_ON   // #pragms ms_struct on\n};\n\nenum PragmaFloatControlKind {\n  PFC_Unknown,\n  PFC_Precise,   // #pragma float_control(precise, [,on])\n  PFC_NoPrecise, // #pragma float_control(precise, off)\n  PFC_Except,    // #pragma float_control(except [,on])\n  PFC_NoExcept,  // #pragma float_control(except, off)\n  PFC_Push,      // #pragma float_control(push)\n  PFC_Pop        // #pragma float_control(pop)\n};\n}\n\n#endif\n"}, "25": {"id": 25, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/ProfileList.h", "content": "//===--- ProfileList.h - ProfileList filter ---------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// User-provided filters include/exclude profile instrumentation in certain\n// functions.\n//\n//===----------------------------------------------------------------------===//\n#ifndef LLVM_CLANG_BASIC_INSTRPROFLIST_H\n#define LLVM_CLANG_BASIC_INSTRPROFLIST_H\n\n#include \"clang/Basic/CodeGenOptions.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <memory>\n\nnamespace llvm {\nclass SpecialCaseList;\n}\n\nnamespace clang {\n\nclass ProfileSpecialCaseList;\n\nclass ProfileList {\n  std::unique_ptr<ProfileSpecialCaseList> SCL;\n  const bool Empty;\n  const bool Default;\n  SourceManager &SM;\n\npublic:\n  ProfileList(ArrayRef<std::string> Paths, SourceManager &SM);\n  ~ProfileList();\n\n  bool isEmpty() const { return Empty; }\n  bool getDefault() const { return Default; }\n\n  llvm::Optional<bool>\n  isFunctionExcluded(StringRef FunctionName,\n                     CodeGenOptions::ProfileInstrKind Kind) const;\n  llvm::Optional<bool>\n  isLocationExcluded(SourceLocation Loc,\n                     CodeGenOptions::ProfileInstrKind Kind) const;\n  llvm::Optional<bool>\n  isFileExcluded(StringRef FileName,\n                 CodeGenOptions::ProfileInstrKind Kind) const;\n};\n\n} // namespace clang\n\n#endif\n"}, "26": {"id": 26, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/PCHContainerOperations.h", "content": "//===--- Frontend/PCHContainerOperations.h - PCH Containers -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_PCH_CONTAINER_OPERATIONS_H\n#define LLVM_CLANG_PCH_CONTAINER_OPERATIONS_H\n\n#include \"clang/Serialization/PCHContainerOperations.h\"\n\n#endif\n"}, "27": {"id": 27, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/PrecompiledPreamble.h", "content": "//===--- PrecompiledPreamble.h - Build precompiled preambles ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Helper class to build precompiled preamble.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_FRONTEND_PRECOMPILED_PREAMBLE_H\n#define LLVM_CLANG_FRONTEND_PRECOMPILED_PREAMBLE_H\n\n#include \"clang/Lex/Lexer.h\"\n#include \"clang/Lex/Preprocessor.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/MD5.h\"\n#include <cstddef>\n#include <memory>\n#include <system_error>\n#include <type_traits>\n\nnamespace llvm {\nclass MemoryBuffer;\nclass MemoryBufferRef;\nnamespace vfs {\nclass FileSystem;\n}\n} // namespace llvm\n\nnamespace clang {\nclass CompilerInstance;\nclass CompilerInvocation;\nclass Decl;\nclass DeclGroupRef;\nclass PCHContainerOperations;\n\n/// Runs lexer to compute suggested preamble bounds.\nPreambleBounds ComputePreambleBounds(const LangOptions &LangOpts,\n                                     const llvm::MemoryBufferRef &Buffer,\n                                     unsigned MaxLines);\n\nclass PreambleCallbacks;\n\n/// A class holding a PCH and all information to check whether it is valid to\n/// reuse the PCH for the subsequent runs. Use BuildPreamble to create PCH and\n/// CanReusePreamble + AddImplicitPreamble to make use of it.\nclass PrecompiledPreamble {\n  class PCHStorage;\n  struct PreambleFileHash;\n\npublic:\n  /// Try to build PrecompiledPreamble for \\p Invocation. See\n  /// BuildPreambleError for possible error codes.\n  ///\n  /// \\param Invocation Original CompilerInvocation with options to compile the\n  /// file.\n  ///\n  /// \\param MainFileBuffer Buffer with the contents of the main file.\n  ///\n  /// \\param Bounds Bounds of the preamble, result of calling\n  /// ComputePreambleBounds.\n  ///\n  /// \\param Diagnostics Diagnostics engine to be used while building the\n  /// preamble.\n  ///\n  /// \\param VFS An instance of vfs::FileSystem to be used for file\n  /// accesses.\n  ///\n  /// \\param PCHContainerOps An instance of PCHContainerOperations.\n  ///\n  /// \\param StoreInMemory Store PCH in memory. If false, PCH will be stored in\n  /// a temporary file.\n  ///\n  /// \\param Callbacks A set of callbacks to be executed when building\n  /// the preamble.\n  static llvm::ErrorOr<PrecompiledPreamble>\n  Build(const CompilerInvocation &Invocation,\n        const llvm::MemoryBuffer *MainFileBuffer, PreambleBounds Bounds,\n        DiagnosticsEngine &Diagnostics,\n        IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS,\n        std::shared_ptr<PCHContainerOperations> PCHContainerOps,\n        bool StoreInMemory, PreambleCallbacks &Callbacks);\n\n  PrecompiledPreamble(PrecompiledPreamble &&) = default;\n  PrecompiledPreamble &operator=(PrecompiledPreamble &&) = default;\n\n  /// PreambleBounds used to build the preamble.\n  PreambleBounds getBounds() const;\n\n  /// Returns the size, in bytes, that preamble takes on disk or in memory.\n  /// For on-disk preambles returns 0 if filesystem operations fail. Intended to\n  /// be used for logging and debugging purposes only.\n  std::size_t getSize() const;\n\n  /// Returned string is not null-terminated.\n  llvm::StringRef getContents() const {\n    return {PreambleBytes.data(), PreambleBytes.size()};\n  }\n\n  /// Check whether PrecompiledPreamble can be reused for the new contents(\\p\n  /// MainFileBuffer) of the main file.\n  bool CanReuse(const CompilerInvocation &Invocation,\n                const llvm::MemoryBufferRef &MainFileBuffer,\n                PreambleBounds Bounds, llvm::vfs::FileSystem &VFS) const;\n\n  /// Changes options inside \\p CI to use PCH from this preamble. Also remaps\n  /// main file to \\p MainFileBuffer and updates \\p VFS to ensure the preamble\n  /// is accessible.\n  /// Requires that CanReuse() is true.\n  /// For in-memory preambles, PrecompiledPreamble instance continues to own the\n  /// MemoryBuffer with the Preamble after this method returns. The caller is\n  /// responsible for making sure the PrecompiledPreamble instance outlives the\n  /// compiler run and the AST that will be using the PCH.\n  void AddImplicitPreamble(CompilerInvocation &CI,\n                           IntrusiveRefCntPtr<llvm::vfs::FileSystem> &VFS,\n                           llvm::MemoryBuffer *MainFileBuffer) const;\n\n  /// Configure \\p CI to use this preamble.\n  /// Like AddImplicitPreamble, but doesn't assume CanReuse() is true.\n  /// If this preamble does not match the file, it may parse differently.\n  void OverridePreamble(CompilerInvocation &CI,\n                        IntrusiveRefCntPtr<llvm::vfs::FileSystem> &VFS,\n                        llvm::MemoryBuffer *MainFileBuffer) const;\n\nprivate:\n  PrecompiledPreamble(PCHStorage Storage, std::vector<char> PreambleBytes,\n                      bool PreambleEndsAtStartOfLine,\n                      llvm::StringMap<PreambleFileHash> FilesInPreamble,\n                      llvm::StringSet<> MissingFiles);\n\n  /// A temp file that would be deleted on destructor call. If destructor is not\n  /// called for any reason, the file will be deleted at static objects'\n  /// destruction.\n  /// An assertion will fire if two TempPCHFiles are created with the same name,\n  /// so it's not intended to be used outside preamble-handling.\n  class TempPCHFile {\n  public:\n    // A main method used to construct TempPCHFile.\n    static llvm::ErrorOr<TempPCHFile> CreateNewPreamblePCHFile();\n\n  private:\n    TempPCHFile(std::string FilePath);\n\n  public:\n    TempPCHFile(TempPCHFile &&Other);\n    TempPCHFile &operator=(TempPCHFile &&Other);\n\n    TempPCHFile(const TempPCHFile &) = delete;\n    ~TempPCHFile();\n\n    /// A path where temporary file is stored.\n    llvm::StringRef getFilePath() const;\n\n  private:\n    void RemoveFileIfPresent();\n\n  private:\n    llvm::Optional<std::string> FilePath;\n  };\n\n  class InMemoryPreamble {\n  public:\n    std::string Data;\n  };\n\n  class PCHStorage {\n  public:\n    enum class Kind { Empty, InMemory, TempFile };\n\n    PCHStorage() = default;\n    PCHStorage(TempPCHFile File);\n    PCHStorage(InMemoryPreamble Memory);\n\n    PCHStorage(const PCHStorage &) = delete;\n    PCHStorage &operator=(const PCHStorage &) = delete;\n\n    PCHStorage(PCHStorage &&Other);\n    PCHStorage &operator=(PCHStorage &&Other);\n\n    ~PCHStorage();\n\n    Kind getKind() const;\n\n    TempPCHFile &asFile();\n    const TempPCHFile &asFile() const;\n\n    InMemoryPreamble &asMemory();\n    const InMemoryPreamble &asMemory() const;\n\n  private:\n    void destroy();\n    void setEmpty();\n\n  private:\n    Kind StorageKind = Kind::Empty;\n    llvm::AlignedCharArrayUnion<TempPCHFile, InMemoryPreamble> Storage = {};\n  };\n\n  /// Data used to determine if a file used in the preamble has been changed.\n  struct PreambleFileHash {\n    /// All files have size set.\n    off_t Size = 0;\n\n    /// Modification time is set for files that are on disk.  For memory\n    /// buffers it is zero.\n    time_t ModTime = 0;\n\n    /// Memory buffers have MD5 instead of modification time.  We don't\n    /// compute MD5 for on-disk files because we hope that modification time is\n    /// enough to tell if the file was changed.\n    llvm::MD5::MD5Result MD5 = {};\n\n    static PreambleFileHash createForFile(off_t Size, time_t ModTime);\n    static PreambleFileHash\n    createForMemoryBuffer(const llvm::MemoryBufferRef &Buffer);\n\n    friend bool operator==(const PreambleFileHash &LHS,\n                           const PreambleFileHash &RHS) {\n      return LHS.Size == RHS.Size && LHS.ModTime == RHS.ModTime &&\n             LHS.MD5 == RHS.MD5;\n    }\n    friend bool operator!=(const PreambleFileHash &LHS,\n                           const PreambleFileHash &RHS) {\n      return !(LHS == RHS);\n    }\n  };\n\n  /// Helper function to set up PCH for the preamble into \\p CI and \\p VFS to\n  /// with the specified \\p Bounds.\n  void configurePreamble(PreambleBounds Bounds, CompilerInvocation &CI,\n                         IntrusiveRefCntPtr<llvm::vfs::FileSystem> &VFS,\n                         llvm::MemoryBuffer *MainFileBuffer) const;\n\n  /// Sets up the PreprocessorOptions and changes VFS, so that PCH stored in \\p\n  /// Storage is accessible to clang. This method is an implementation detail of\n  /// AddImplicitPreamble.\n  static void\n  setupPreambleStorage(const PCHStorage &Storage,\n                       PreprocessorOptions &PreprocessorOpts,\n                       IntrusiveRefCntPtr<llvm::vfs::FileSystem> &VFS);\n\n  /// Manages the memory buffer or temporary file that stores the PCH.\n  PCHStorage Storage;\n  /// Keeps track of the files that were used when computing the\n  /// preamble, with both their buffer size and their modification time.\n  ///\n  /// If any of the files have changed from one compile to the next,\n  /// the preamble must be thrown away.\n  llvm::StringMap<PreambleFileHash> FilesInPreamble;\n  /// Files that were not found during preamble building. If any of these now\n  /// exist then the preamble should not be reused.\n  ///\n  /// Storing *all* the missing files that could invalidate the preamble would\n  /// make it too expensive to revalidate (when the include path has many\n  /// entries, each #include will miss half of them on average).\n  /// Instead, we track only files that could have satisfied an #include that\n  /// was ultimately not found.\n  llvm::StringSet<> MissingFiles;\n  /// The contents of the file that was used to precompile the preamble. Only\n  /// contains first PreambleBounds::Size bytes. Used to compare if the relevant\n  /// part of the file has not changed, so that preamble can be reused.\n  std::vector<char> PreambleBytes;\n  /// See PreambleBounds::PreambleEndsAtStartOfLine\n  bool PreambleEndsAtStartOfLine;\n};\n\n/// A set of callbacks to gather useful information while building a preamble.\nclass PreambleCallbacks {\npublic:\n  virtual ~PreambleCallbacks() = default;\n\n  /// Called before FrontendAction::BeginSourceFile.\n  /// Can be used to store references to various CompilerInstance fields\n  /// (e.g. SourceManager) that may be interesting to the consumers of other\n  /// callbacks.\n  virtual void BeforeExecute(CompilerInstance &CI);\n  /// Called after FrontendAction::Execute(), but before\n  /// FrontendAction::EndSourceFile(). Can be used to transfer ownership of\n  /// various CompilerInstance fields before they are destroyed.\n  virtual void AfterExecute(CompilerInstance &CI);\n  /// Called after PCH has been emitted. \\p Writer may be used to retrieve\n  /// information about AST, serialized in PCH.\n  virtual void AfterPCHEmitted(ASTWriter &Writer);\n  /// Called for each TopLevelDecl.\n  /// NOTE: To allow more flexibility a custom ASTConsumer could probably be\n  /// used instead, but having only this method allows a simpler API.\n  virtual void HandleTopLevelDecl(DeclGroupRef DG);\n  /// Creates wrapper class for PPCallbacks so we can also process information\n  /// about includes that are inside of a preamble\n  virtual std::unique_ptr<PPCallbacks> createPPCallbacks();\n  /// The returned CommentHandler will be added to the preprocessor if not null.\n  virtual CommentHandler *getCommentHandler();\n  /// Determines which function bodies are parsed, by default skips everything.\n  /// Only used if FrontendOpts::SkipFunctionBodies is true.\n  /// See ASTConsumer::shouldSkipFunctionBody.\n  virtual bool shouldSkipFunctionBody(Decl *D) { return true; }\n};\n\nenum class BuildPreambleError {\n  CouldntCreateTempFile = 1,\n  CouldntCreateTargetInfo,\n  BeginSourceFileFailed,\n  CouldntEmitPCH,\n  BadInputs\n};\n\nclass BuildPreambleErrorCategory final : public std::error_category {\npublic:\n  const char *name() const noexcept override;\n  std::string message(int condition) const override;\n};\n\nstd::error_code make_error_code(BuildPreambleError Error);\n} // namespace clang\n\nnamespace std {\ntemplate <>\nstruct is_error_code_enum<clang::BuildPreambleError> : std::true_type {};\n} // namespace std\n\n#endif\n"}, "28": {"id": 28, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/PreprocessorExcludedConditionalDirectiveSkipMapping.h", "content": "//===- PreprocessorExcludedConditionalDirectiveSkipMapping.h - --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LEX_PREPROCESSOR_EXCLUDED_COND_DIRECTIVE_SKIP_MAPPING_H\n#define LLVM_CLANG_LEX_PREPROCESSOR_EXCLUDED_COND_DIRECTIVE_SKIP_MAPPING_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n\nnamespace clang {\n\n/// A mapping from an offset into a buffer to the number of bytes that can be\n/// skipped by the preprocessor when skipping over excluded conditional\n/// directive ranges.\nusing PreprocessorSkippedRangeMapping = llvm::DenseMap<unsigned, unsigned>;\n\n/// The datastructure that holds the mapping between the active memory buffers\n/// and the individual skip mappings.\nusing ExcludedPreprocessorDirectiveSkipMapping =\n    llvm::DenseMap<const char *, const PreprocessorSkippedRangeMapping *>;\n\n} // end namespace clang\n\n#endif // LLVM_CLANG_LEX_PREPROCESSOR_EXCLUDED_COND_DIRECTIVE_SKIP_MAPPING_H\n"}, "29": {"id": 29, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/ParsedAttr.h", "content": "//======- ParsedAttr.h - Parsed attribute sets ------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the ParsedAttr class, which is used to collect\n// parsed attributes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SEMA_ATTRIBUTELIST_H\n#define LLVM_CLANG_SEMA_ATTRIBUTELIST_H\n\n#include \"clang/Basic/AttrSubjectMatchRules.h\"\n#include \"clang/Basic/AttributeCommonInfo.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Sema/Ownership.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/TinyPtrVector.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/Registry.h\"\n#include \"llvm/Support/VersionTuple.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstring>\n#include <utility>\n\nnamespace clang {\n\nclass ASTContext;\nclass Decl;\nclass Expr;\nclass IdentifierInfo;\nclass LangOptions;\nclass ParsedAttr;\nclass Sema;\nclass Stmt;\nclass TargetInfo;\n\nstruct ParsedAttrInfo {\n  /// Corresponds to the Kind enum.\n  unsigned AttrKind : 16;\n  /// The number of required arguments of this attribute.\n  unsigned NumArgs : 4;\n  /// The number of optional arguments of this attributes.\n  unsigned OptArgs : 4;\n  /// True if the parsing does not match the semantic content.\n  unsigned HasCustomParsing : 1;\n  /// True if this attribute is only available for certain targets.\n  unsigned IsTargetSpecific : 1;\n  /// True if this attribute applies to types.\n  unsigned IsType : 1;\n  /// True if this attribute applies to statements.\n  unsigned IsStmt : 1;\n  /// True if this attribute has any spellings that are known to gcc.\n  unsigned IsKnownToGCC : 1;\n  /// True if this attribute is supported by #pragma clang attribute.\n  unsigned IsSupportedByPragmaAttribute : 1;\n  /// The syntaxes supported by this attribute and how they're spelled.\n  struct Spelling {\n    AttributeCommonInfo::Syntax Syntax;\n    const char *NormalizedFullName;\n  };\n  ArrayRef<Spelling> Spellings;\n\n  ParsedAttrInfo(AttributeCommonInfo::Kind AttrKind =\n                     AttributeCommonInfo::NoSemaHandlerAttribute)\n      : AttrKind(AttrKind), NumArgs(0), OptArgs(0), HasCustomParsing(0),\n        IsTargetSpecific(0), IsType(0), IsStmt(0), IsKnownToGCC(0),\n        IsSupportedByPragmaAttribute(0) {}\n\n  virtual ~ParsedAttrInfo() = default;\n\n  /// Check if this attribute appertains to D, and issue a diagnostic if not.\n  virtual bool diagAppertainsToDecl(Sema &S, const ParsedAttr &Attr,\n                                    const Decl *D) const {\n    return true;\n  }\n  /// Check if this attribute appertains to St, and issue a diagnostic if not.\n  virtual bool diagAppertainsToStmt(Sema &S, const ParsedAttr &Attr,\n                                    const Stmt *St) const {\n    return true;\n  }\n  /// Check if the given attribute is mutually exclusive with other attributes\n  /// already applied to the given declaration.\n  virtual bool diagMutualExclusion(Sema &S, const ParsedAttr &A,\n                                   const Decl *D) const {\n    return true;\n  }\n  /// Check if this attribute is allowed by the language we are compiling, and\n  /// issue a diagnostic if not.\n  virtual bool diagLangOpts(Sema &S, const ParsedAttr &Attr) const {\n    return true;\n  }\n  /// Check if this attribute is allowed when compiling for the given target.\n  virtual bool existsInTarget(const TargetInfo &Target) const {\n    return true;\n  }\n  /// Convert the spelling index of Attr to a semantic spelling enum value.\n  virtual unsigned\n  spellingIndexToSemanticSpelling(const ParsedAttr &Attr) const {\n    return UINT_MAX;\n  }\n  /// Populate Rules with the match rules of this attribute.\n  virtual void getPragmaAttributeMatchRules(\n      llvm::SmallVectorImpl<std::pair<attr::SubjectMatchRule, bool>> &Rules,\n      const LangOptions &LangOpts) const {\n  }\n  enum AttrHandling {\n    NotHandled,\n    AttributeApplied,\n    AttributeNotApplied\n  };\n  /// If this ParsedAttrInfo knows how to handle this ParsedAttr applied to this\n  /// Decl then do so and return either AttributeApplied if it was applied or\n  /// AttributeNotApplied if it wasn't. Otherwise return NotHandled.\n  virtual AttrHandling handleDeclAttribute(Sema &S, Decl *D,\n                                           const ParsedAttr &Attr) const {\n    return NotHandled;\n  }\n\n  static const ParsedAttrInfo &get(const AttributeCommonInfo &A);\n};\n\ntypedef llvm::Registry<ParsedAttrInfo> ParsedAttrInfoRegistry;\n\n/// Represents information about a change in availability for\n/// an entity, which is part of the encoding of the 'availability'\n/// attribute.\nstruct AvailabilityChange {\n  /// The location of the keyword indicating the kind of change.\n  SourceLocation KeywordLoc;\n\n  /// The version number at which the change occurred.\n  VersionTuple Version;\n\n  /// The source range covering the version number.\n  SourceRange VersionRange;\n\n  /// Determine whether this availability change is valid.\n  bool isValid() const { return !Version.empty(); }\n};\n\nnamespace detail {\nenum AvailabilitySlot {\n  IntroducedSlot, DeprecatedSlot, ObsoletedSlot, NumAvailabilitySlots\n};\n\n/// Describes the trailing object for Availability attribute in ParsedAttr.\nstruct AvailabilityData {\n  AvailabilityChange Changes[NumAvailabilitySlots];\n  SourceLocation StrictLoc;\n  const Expr *Replacement;\n\n  AvailabilityData(const AvailabilityChange &Introduced,\n                   const AvailabilityChange &Deprecated,\n                   const AvailabilityChange &Obsoleted,\n                   SourceLocation Strict, const Expr *ReplaceExpr)\n    : StrictLoc(Strict), Replacement(ReplaceExpr) {\n    Changes[IntroducedSlot] = Introduced;\n    Changes[DeprecatedSlot] = Deprecated;\n    Changes[ObsoletedSlot] = Obsoleted;\n  }\n};\n\nstruct TypeTagForDatatypeData {\n  ParsedType MatchingCType;\n  unsigned LayoutCompatible : 1;\n  unsigned MustBeNull : 1;\n};\nstruct PropertyData {\n  IdentifierInfo *GetterId, *SetterId;\n\n  PropertyData(IdentifierInfo *getterId, IdentifierInfo *setterId)\n      : GetterId(getterId), SetterId(setterId) {}\n};\n\n} // namespace\n\n/// Wraps an identifier and optional source location for the identifier.\nstruct IdentifierLoc {\n  SourceLocation Loc;\n  IdentifierInfo *Ident;\n\n  static IdentifierLoc *create(ASTContext &Ctx, SourceLocation Loc,\n                               IdentifierInfo *Ident);\n};\n\n/// A union of the various pointer types that can be passed to an\n/// ParsedAttr as an argument.\nusing ArgsUnion = llvm::PointerUnion<Expr *, IdentifierLoc *>;\nusing ArgsVector = llvm::SmallVector<ArgsUnion, 12U>;\n\n/// ParsedAttr - Represents a syntactic attribute.\n///\n/// For a GNU attribute, there are four forms of this construct:\n///\n/// 1: __attribute__(( const )). ParmName/Args/NumArgs will all be unused.\n/// 2: __attribute__(( mode(byte) )). ParmName used, Args/NumArgs unused.\n/// 3: __attribute__(( format(printf, 1, 2) )). ParmName/Args/NumArgs all used.\n/// 4: __attribute__(( aligned(16) )). ParmName is unused, Args/Num used.\n///\nclass ParsedAttr final\n    : public AttributeCommonInfo,\n      private llvm::TrailingObjects<\n          ParsedAttr, ArgsUnion, detail::AvailabilityData,\n          detail::TypeTagForDatatypeData, ParsedType, detail::PropertyData> {\n  friend TrailingObjects;\n\n  size_t numTrailingObjects(OverloadToken<ArgsUnion>) const { return NumArgs; }\n  size_t numTrailingObjects(OverloadToken<detail::AvailabilityData>) const {\n    return IsAvailability;\n  }\n  size_t\n      numTrailingObjects(OverloadToken<detail::TypeTagForDatatypeData>) const {\n    return IsTypeTagForDatatype;\n  }\n  size_t numTrailingObjects(OverloadToken<ParsedType>) const {\n    return HasParsedType;\n  }\n  size_t numTrailingObjects(OverloadToken<detail::PropertyData>) const {\n    return IsProperty;\n  }\n\nprivate:\n  IdentifierInfo *MacroII = nullptr;\n  SourceLocation MacroExpansionLoc;\n  SourceLocation EllipsisLoc;\n\n  /// The number of expression arguments this attribute has.\n  /// The expressions themselves are stored after the object.\n  unsigned NumArgs : 16;\n\n  /// True if already diagnosed as invalid.\n  mutable unsigned Invalid : 1;\n\n  /// True if this attribute was used as a type attribute.\n  mutable unsigned UsedAsTypeAttr : 1;\n\n  /// True if this has the extra information associated with an\n  /// availability attribute.\n  unsigned IsAvailability : 1;\n\n  /// True if this has extra information associated with a\n  /// type_tag_for_datatype attribute.\n  unsigned IsTypeTagForDatatype : 1;\n\n  /// True if this has extra information associated with a\n  /// Microsoft __delcspec(property) attribute.\n  unsigned IsProperty : 1;\n\n  /// True if this has a ParsedType\n  unsigned HasParsedType : 1;\n\n  /// True if the processing cache is valid.\n  mutable unsigned HasProcessingCache : 1;\n\n  /// A cached value.\n  mutable unsigned ProcessingCache : 8;\n\n  /// True if the attribute is specified using '#pragma clang attribute'.\n  mutable unsigned IsPragmaClangAttribute : 1;\n\n  /// The location of the 'unavailable' keyword in an\n  /// availability attribute.\n  SourceLocation UnavailableLoc;\n\n  const Expr *MessageExpr;\n\n  const ParsedAttrInfo &Info;\n\n  ArgsUnion *getArgsBuffer() { return getTrailingObjects<ArgsUnion>(); }\n  ArgsUnion const *getArgsBuffer() const {\n    return getTrailingObjects<ArgsUnion>();\n  }\n\n  detail::AvailabilityData *getAvailabilityData() {\n    return getTrailingObjects<detail::AvailabilityData>();\n  }\n  const detail::AvailabilityData *getAvailabilityData() const {\n    return getTrailingObjects<detail::AvailabilityData>();\n  }\n\nprivate:\n  friend class AttributeFactory;\n  friend class AttributePool;\n\n  /// Constructor for attributes with expression arguments.\n  ParsedAttr(IdentifierInfo *attrName, SourceRange attrRange,\n             IdentifierInfo *scopeName, SourceLocation scopeLoc,\n             ArgsUnion *args, unsigned numArgs, Syntax syntaxUsed,\n             SourceLocation ellipsisLoc)\n      : AttributeCommonInfo(attrName, scopeName, attrRange, scopeLoc,\n                            syntaxUsed),\n        EllipsisLoc(ellipsisLoc), NumArgs(numArgs), Invalid(false),\n        UsedAsTypeAttr(false), IsAvailability(false),\n        IsTypeTagForDatatype(false), IsProperty(false), HasParsedType(false),\n        HasProcessingCache(false), IsPragmaClangAttribute(false),\n        Info(ParsedAttrInfo::get(*this)) {\n    if (numArgs)\n      memcpy(getArgsBuffer(), args, numArgs * sizeof(ArgsUnion));\n  }\n\n  /// Constructor for availability attributes.\n  ParsedAttr(IdentifierInfo *attrName, SourceRange attrRange,\n             IdentifierInfo *scopeName, SourceLocation scopeLoc,\n             IdentifierLoc *Parm, const AvailabilityChange &introduced,\n             const AvailabilityChange &deprecated,\n             const AvailabilityChange &obsoleted, SourceLocation unavailable,\n             const Expr *messageExpr, Syntax syntaxUsed, SourceLocation strict,\n             const Expr *replacementExpr)\n      : AttributeCommonInfo(attrName, scopeName, attrRange, scopeLoc,\n                            syntaxUsed),\n        NumArgs(1), Invalid(false), UsedAsTypeAttr(false), IsAvailability(true),\n        IsTypeTagForDatatype(false), IsProperty(false), HasParsedType(false),\n        HasProcessingCache(false), IsPragmaClangAttribute(false),\n        UnavailableLoc(unavailable), MessageExpr(messageExpr),\n        Info(ParsedAttrInfo::get(*this)) {\n    ArgsUnion PVal(Parm);\n    memcpy(getArgsBuffer(), &PVal, sizeof(ArgsUnion));\n    new (getAvailabilityData()) detail::AvailabilityData(\n        introduced, deprecated, obsoleted, strict, replacementExpr);\n  }\n\n  /// Constructor for objc_bridge_related attributes.\n  ParsedAttr(IdentifierInfo *attrName, SourceRange attrRange,\n             IdentifierInfo *scopeName, SourceLocation scopeLoc,\n             IdentifierLoc *Parm1, IdentifierLoc *Parm2, IdentifierLoc *Parm3,\n             Syntax syntaxUsed)\n      : AttributeCommonInfo(attrName, scopeName, attrRange, scopeLoc,\n                            syntaxUsed),\n        NumArgs(3), Invalid(false), UsedAsTypeAttr(false),\n        IsAvailability(false), IsTypeTagForDatatype(false), IsProperty(false),\n        HasParsedType(false), HasProcessingCache(false),\n        IsPragmaClangAttribute(false), Info(ParsedAttrInfo::get(*this)) {\n    ArgsUnion *Args = getArgsBuffer();\n    Args[0] = Parm1;\n    Args[1] = Parm2;\n    Args[2] = Parm3;\n  }\n\n  /// Constructor for type_tag_for_datatype attribute.\n  ParsedAttr(IdentifierInfo *attrName, SourceRange attrRange,\n             IdentifierInfo *scopeName, SourceLocation scopeLoc,\n             IdentifierLoc *ArgKind, ParsedType matchingCType,\n             bool layoutCompatible, bool mustBeNull, Syntax syntaxUsed)\n      : AttributeCommonInfo(attrName, scopeName, attrRange, scopeLoc,\n                            syntaxUsed),\n        NumArgs(1), Invalid(false), UsedAsTypeAttr(false),\n        IsAvailability(false), IsTypeTagForDatatype(true), IsProperty(false),\n        HasParsedType(false), HasProcessingCache(false),\n        IsPragmaClangAttribute(false), Info(ParsedAttrInfo::get(*this)) {\n    ArgsUnion PVal(ArgKind);\n    memcpy(getArgsBuffer(), &PVal, sizeof(ArgsUnion));\n    detail::TypeTagForDatatypeData &ExtraData = getTypeTagForDatatypeDataSlot();\n    new (&ExtraData.MatchingCType) ParsedType(matchingCType);\n    ExtraData.LayoutCompatible = layoutCompatible;\n    ExtraData.MustBeNull = mustBeNull;\n  }\n\n  /// Constructor for attributes with a single type argument.\n  ParsedAttr(IdentifierInfo *attrName, SourceRange attrRange,\n             IdentifierInfo *scopeName, SourceLocation scopeLoc,\n             ParsedType typeArg, Syntax syntaxUsed)\n      : AttributeCommonInfo(attrName, scopeName, attrRange, scopeLoc,\n                            syntaxUsed),\n        NumArgs(0), Invalid(false), UsedAsTypeAttr(false),\n        IsAvailability(false), IsTypeTagForDatatype(false), IsProperty(false),\n        HasParsedType(true), HasProcessingCache(false),\n        IsPragmaClangAttribute(false), Info(ParsedAttrInfo::get(*this)) {\n    new (&getTypeBuffer()) ParsedType(typeArg);\n  }\n\n  /// Constructor for microsoft __declspec(property) attribute.\n  ParsedAttr(IdentifierInfo *attrName, SourceRange attrRange,\n             IdentifierInfo *scopeName, SourceLocation scopeLoc,\n             IdentifierInfo *getterId, IdentifierInfo *setterId,\n             Syntax syntaxUsed)\n      : AttributeCommonInfo(attrName, scopeName, attrRange, scopeLoc,\n                            syntaxUsed),\n        NumArgs(0), Invalid(false), UsedAsTypeAttr(false),\n        IsAvailability(false), IsTypeTagForDatatype(false), IsProperty(true),\n        HasParsedType(false), HasProcessingCache(false),\n        IsPragmaClangAttribute(false), Info(ParsedAttrInfo::get(*this)) {\n    new (&getPropertyDataBuffer()) detail::PropertyData(getterId, setterId);\n  }\n\n  /// Type tag information is stored immediately following the arguments, if\n  /// any, at the end of the object.  They are mutually exclusive with\n  /// availability slots.\n  detail::TypeTagForDatatypeData &getTypeTagForDatatypeDataSlot() {\n    return *getTrailingObjects<detail::TypeTagForDatatypeData>();\n  }\n  const detail::TypeTagForDatatypeData &getTypeTagForDatatypeDataSlot() const {\n    return *getTrailingObjects<detail::TypeTagForDatatypeData>();\n  }\n\n  /// The type buffer immediately follows the object and are mutually exclusive\n  /// with arguments.\n  ParsedType &getTypeBuffer() { return *getTrailingObjects<ParsedType>(); }\n  const ParsedType &getTypeBuffer() const {\n    return *getTrailingObjects<ParsedType>();\n  }\n\n  /// The property data immediately follows the object is is mutually exclusive\n  /// with arguments.\n  detail::PropertyData &getPropertyDataBuffer() {\n    assert(IsProperty);\n    return *getTrailingObjects<detail::PropertyData>();\n  }\n  const detail::PropertyData &getPropertyDataBuffer() const {\n    assert(IsProperty);\n    return *getTrailingObjects<detail::PropertyData>();\n  }\n\n  size_t allocated_size() const;\n\npublic:\n  ParsedAttr(const ParsedAttr &) = delete;\n  ParsedAttr(ParsedAttr &&) = delete;\n  ParsedAttr &operator=(const ParsedAttr &) = delete;\n  ParsedAttr &operator=(ParsedAttr &&) = delete;\n  ~ParsedAttr() = delete;\n\n  void operator delete(void *) = delete;\n\n  bool hasParsedType() const { return HasParsedType; }\n\n  /// Is this the Microsoft __declspec(property) attribute?\n  bool isDeclspecPropertyAttribute() const  {\n    return IsProperty;\n  }\n\n  bool isInvalid() const { return Invalid; }\n  void setInvalid(bool b = true) const { Invalid = b; }\n\n  bool hasProcessingCache() const { return HasProcessingCache; }\n\n  unsigned getProcessingCache() const {\n    assert(hasProcessingCache());\n    return ProcessingCache;\n  }\n\n  void setProcessingCache(unsigned value) const {\n    ProcessingCache = value;\n    HasProcessingCache = true;\n  }\n\n  bool isUsedAsTypeAttr() const { return UsedAsTypeAttr; }\n  void setUsedAsTypeAttr(bool Used = true) { UsedAsTypeAttr = Used; }\n\n  /// True if the attribute is specified using '#pragma clang attribute'.\n  bool isPragmaClangAttribute() const { return IsPragmaClangAttribute; }\n\n  void setIsPragmaClangAttribute() { IsPragmaClangAttribute = true; }\n\n  bool isPackExpansion() const { return EllipsisLoc.isValid(); }\n  SourceLocation getEllipsisLoc() const { return EllipsisLoc; }\n\n  /// getNumArgs - Return the number of actual arguments to this attribute.\n  unsigned getNumArgs() const { return NumArgs; }\n\n  /// getArg - Return the specified argument.\n  ArgsUnion getArg(unsigned Arg) const {\n    assert(Arg < NumArgs && \"Arg access out of range!\");\n    return getArgsBuffer()[Arg];\n  }\n\n  bool isArgExpr(unsigned Arg) const {\n    return Arg < NumArgs && getArg(Arg).is<Expr*>();\n  }\n\n  Expr *getArgAsExpr(unsigned Arg) const {\n    return getArg(Arg).get<Expr*>();\n  }\n\n  bool isArgIdent(unsigned Arg) const {\n    return Arg < NumArgs && getArg(Arg).is<IdentifierLoc*>();\n  }\n\n  IdentifierLoc *getArgAsIdent(unsigned Arg) const {\n    return getArg(Arg).get<IdentifierLoc*>();\n  }\n\n  const AvailabilityChange &getAvailabilityIntroduced() const {\n    assert(getParsedKind() == AT_Availability &&\n           \"Not an availability attribute\");\n    return getAvailabilityData()->Changes[detail::IntroducedSlot];\n  }\n\n  const AvailabilityChange &getAvailabilityDeprecated() const {\n    assert(getParsedKind() == AT_Availability &&\n           \"Not an availability attribute\");\n    return getAvailabilityData()->Changes[detail::DeprecatedSlot];\n  }\n\n  const AvailabilityChange &getAvailabilityObsoleted() const {\n    assert(getParsedKind() == AT_Availability &&\n           \"Not an availability attribute\");\n    return getAvailabilityData()->Changes[detail::ObsoletedSlot];\n  }\n\n  SourceLocation getStrictLoc() const {\n    assert(getParsedKind() == AT_Availability &&\n           \"Not an availability attribute\");\n    return getAvailabilityData()->StrictLoc;\n  }\n\n  SourceLocation getUnavailableLoc() const {\n    assert(getParsedKind() == AT_Availability &&\n           \"Not an availability attribute\");\n    return UnavailableLoc;\n  }\n\n  const Expr * getMessageExpr() const {\n    assert(getParsedKind() == AT_Availability &&\n           \"Not an availability attribute\");\n    return MessageExpr;\n  }\n\n  const Expr *getReplacementExpr() const {\n    assert(getParsedKind() == AT_Availability &&\n           \"Not an availability attribute\");\n    return getAvailabilityData()->Replacement;\n  }\n\n  const ParsedType &getMatchingCType() const {\n    assert(getParsedKind() == AT_TypeTagForDatatype &&\n           \"Not a type_tag_for_datatype attribute\");\n    return getTypeTagForDatatypeDataSlot().MatchingCType;\n  }\n\n  bool getLayoutCompatible() const {\n    assert(getParsedKind() == AT_TypeTagForDatatype &&\n           \"Not a type_tag_for_datatype attribute\");\n    return getTypeTagForDatatypeDataSlot().LayoutCompatible;\n  }\n\n  bool getMustBeNull() const {\n    assert(getParsedKind() == AT_TypeTagForDatatype &&\n           \"Not a type_tag_for_datatype attribute\");\n    return getTypeTagForDatatypeDataSlot().MustBeNull;\n  }\n\n  const ParsedType &getTypeArg() const {\n    assert(HasParsedType && \"Not a type attribute\");\n    return getTypeBuffer();\n  }\n\n  IdentifierInfo *getPropertyDataGetter() const {\n    assert(isDeclspecPropertyAttribute() &&\n           \"Not a __delcspec(property) attribute\");\n    return getPropertyDataBuffer().GetterId;\n  }\n\n  IdentifierInfo *getPropertyDataSetter() const {\n    assert(isDeclspecPropertyAttribute() &&\n           \"Not a __delcspec(property) attribute\");\n    return getPropertyDataBuffer().SetterId;\n  }\n\n  /// Set the macro identifier info object that this parsed attribute was\n  /// declared in if it was declared in a macro. Also set the expansion location\n  /// of the macro.\n  void setMacroIdentifier(IdentifierInfo *MacroName, SourceLocation Loc) {\n    MacroII = MacroName;\n    MacroExpansionLoc = Loc;\n  }\n\n  /// Returns true if this attribute was declared in a macro.\n  bool hasMacroIdentifier() const { return MacroII != nullptr; }\n\n  /// Return the macro identifier if this attribute was declared in a macro.\n  /// nullptr is returned if it was not declared in a macro.\n  IdentifierInfo *getMacroIdentifier() const { return MacroII; }\n\n  SourceLocation getMacroExpansionLoc() const {\n    assert(hasMacroIdentifier() && \"Can only get the macro expansion location \"\n                                   \"if this attribute has a macro identifier.\");\n    return MacroExpansionLoc;\n  }\n\n  /// Check if the attribute has exactly as many args as Num. May output an\n  /// error. Returns false if a diagnostic is produced.\n  bool checkExactlyNumArgs(class Sema &S, unsigned Num) const;\n  /// Check if the attribute has at least as many args as Num. May output an\n  /// error. Returns false if a diagnostic is produced.\n  bool checkAtLeastNumArgs(class Sema &S, unsigned Num) const;\n  /// Check if the attribute has at most as many args as Num. May output an\n  /// error. Returns false if a diagnostic is produced.\n  bool checkAtMostNumArgs(class Sema &S, unsigned Num) const;\n\n  bool isTargetSpecificAttr() const;\n  bool isTypeAttr() const;\n  bool isStmtAttr() const;\n\n  bool hasCustomParsing() const;\n  unsigned getMinArgs() const;\n  unsigned getMaxArgs() const;\n  bool hasVariadicArg() const;\n  bool diagnoseAppertainsTo(class Sema &S, const Decl *D) const;\n  bool diagnoseAppertainsTo(class Sema &S, const Stmt *St) const;\n  bool diagnoseMutualExclusion(class Sema &S, const Decl *D) const;\n  // This function stub exists for parity with the declaration checking code so\n  // that checkCommonAttributeFeatures() can work generically on declarations\n  // or statements.\n  bool diagnoseMutualExclusion(class Sema &S, const Stmt *St) const {\n    return true;\n  }\n  bool appliesToDecl(const Decl *D, attr::SubjectMatchRule MatchRule) const;\n  void getMatchRules(const LangOptions &LangOpts,\n                     SmallVectorImpl<std::pair<attr::SubjectMatchRule, bool>>\n                         &MatchRules) const;\n  bool diagnoseLangOpts(class Sema &S) const;\n  bool existsInTarget(const TargetInfo &Target) const;\n  bool isKnownToGCC() const;\n  bool isSupportedByPragmaAttribute() const;\n\n  /// If the parsed attribute has a semantic equivalent, and it would\n  /// have a semantic Spelling enumeration (due to having semantically-distinct\n  /// spelling variations), return the value of that semantic spelling. If the\n  /// parsed attribute does not have a semantic equivalent, or would not have\n  /// a Spelling enumeration, the value UINT_MAX is returned.\n  unsigned getSemanticSpelling() const;\n\n  /// If this is an OpenCL address space attribute returns its representation\n  /// in LangAS, otherwise returns default address space.\n  LangAS asOpenCLLangAS() const {\n    switch (getParsedKind()) {\n    case ParsedAttr::AT_OpenCLConstantAddressSpace:\n      return LangAS::opencl_constant;\n    case ParsedAttr::AT_OpenCLGlobalAddressSpace:\n      return LangAS::opencl_global;\n    case ParsedAttr::AT_OpenCLGlobalDeviceAddressSpace:\n      return LangAS::opencl_global_device;\n    case ParsedAttr::AT_OpenCLGlobalHostAddressSpace:\n      return LangAS::opencl_global_host;\n    case ParsedAttr::AT_OpenCLLocalAddressSpace:\n      return LangAS::opencl_local;\n    case ParsedAttr::AT_OpenCLPrivateAddressSpace:\n      return LangAS::opencl_private;\n    case ParsedAttr::AT_OpenCLGenericAddressSpace:\n      return LangAS::opencl_generic;\n    default:\n      return LangAS::Default;\n    }\n  }\n\n  /// If this is an OpenCL address space attribute returns its SYCL\n  /// representation in LangAS, otherwise returns default address space.\n  LangAS asSYCLLangAS() const {\n    switch (getKind()) {\n    case ParsedAttr::AT_OpenCLGlobalAddressSpace:\n      return LangAS::sycl_global;\n    case ParsedAttr::AT_OpenCLLocalAddressSpace:\n      return LangAS::sycl_local;\n    case ParsedAttr::AT_OpenCLPrivateAddressSpace:\n      return LangAS::sycl_private;\n    case ParsedAttr::AT_OpenCLGenericAddressSpace:\n    default:\n      return LangAS::Default;\n    }\n  }\n\n  AttributeCommonInfo::Kind getKind() const {\n    return AttributeCommonInfo::Kind(Info.AttrKind);\n  }\n  const ParsedAttrInfo &getInfo() const { return Info; }\n};\n\nclass AttributePool;\n/// A factory, from which one makes pools, from which one creates\n/// individual attributes which are deallocated with the pool.\n///\n/// Note that it's tolerably cheap to create and destroy one of\n/// these as long as you don't actually allocate anything in it.\nclass AttributeFactory {\npublic:\n  enum {\n    AvailabilityAllocSize =\n        ParsedAttr::totalSizeToAlloc<ArgsUnion, detail::AvailabilityData,\n                                     detail::TypeTagForDatatypeData, ParsedType,\n                                     detail::PropertyData>(1, 1, 0, 0, 0),\n    TypeTagForDatatypeAllocSize =\n        ParsedAttr::totalSizeToAlloc<ArgsUnion, detail::AvailabilityData,\n                                     detail::TypeTagForDatatypeData, ParsedType,\n                                     detail::PropertyData>(1, 0, 1, 0, 0),\n    PropertyAllocSize =\n        ParsedAttr::totalSizeToAlloc<ArgsUnion, detail::AvailabilityData,\n                                     detail::TypeTagForDatatypeData, ParsedType,\n                                     detail::PropertyData>(0, 0, 0, 0, 1),\n  };\n\nprivate:\n  enum {\n    /// The number of free lists we want to be sure to support\n    /// inline.  This is just enough that availability attributes\n    /// don't surpass it.  It's actually very unlikely we'll see an\n    /// attribute that needs more than that; on x86-64 you'd need 10\n    /// expression arguments, and on i386 you'd need 19.\n    InlineFreeListsCapacity =\n        1 + (AvailabilityAllocSize - sizeof(ParsedAttr)) / sizeof(void *)\n  };\n\n  llvm::BumpPtrAllocator Alloc;\n\n  /// Free lists.  The index is determined by the following formula:\n  ///   (size - sizeof(ParsedAttr)) / sizeof(void*)\n  SmallVector<SmallVector<ParsedAttr *, 8>, InlineFreeListsCapacity> FreeLists;\n\n  // The following are the private interface used by AttributePool.\n  friend class AttributePool;\n\n  /// Allocate an attribute of the given size.\n  void *allocate(size_t size);\n\n  void deallocate(ParsedAttr *AL);\n\n  /// Reclaim all the attributes in the given pool chain, which is\n  /// non-empty.  Note that the current implementation is safe\n  /// against reclaiming things which were not actually allocated\n  /// with the allocator, although of course it's important to make\n  /// sure that their allocator lives at least as long as this one.\n  void reclaimPool(AttributePool &head);\n\npublic:\n  AttributeFactory();\n  ~AttributeFactory();\n};\n\nclass AttributePool {\n  friend class AttributeFactory;\n  friend class ParsedAttributes;\n  AttributeFactory &Factory;\n  llvm::TinyPtrVector<ParsedAttr *> Attrs;\n\n  void *allocate(size_t size) {\n    return Factory.allocate(size);\n  }\n\n  ParsedAttr *add(ParsedAttr *attr) {\n    Attrs.push_back(attr);\n    return attr;\n  }\n\n  void remove(ParsedAttr *attr) {\n    assert(llvm::is_contained(Attrs, attr) &&\n           \"Can't take attribute from a pool that doesn't own it!\");\n    Attrs.erase(llvm::find(Attrs, attr));\n  }\n\n  void takePool(AttributePool &pool);\n\npublic:\n  /// Create a new pool for a factory.\n  AttributePool(AttributeFactory &factory) : Factory(factory) {}\n\n  AttributePool(const AttributePool &) = delete;\n\n  ~AttributePool() { Factory.reclaimPool(*this); }\n\n  /// Move the given pool's allocations to this pool.\n  AttributePool(AttributePool &&pool) = default;\n\n  AttributeFactory &getFactory() const { return Factory; }\n\n  void clear() {\n    Factory.reclaimPool(*this);\n    Attrs.clear();\n  }\n\n  /// Take the given pool's allocations and add them to this pool.\n  void takeAllFrom(AttributePool &pool) {\n    takePool(pool);\n    pool.Attrs.clear();\n  }\n\n  ParsedAttr *create(IdentifierInfo *attrName, SourceRange attrRange,\n                     IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                     ArgsUnion *args, unsigned numArgs,\n                     ParsedAttr::Syntax syntax,\n                     SourceLocation ellipsisLoc = SourceLocation()) {\n    size_t temp =\n        ParsedAttr::totalSizeToAlloc<ArgsUnion, detail::AvailabilityData,\n                                     detail::TypeTagForDatatypeData, ParsedType,\n                                     detail::PropertyData>(numArgs, 0, 0, 0, 0);\n    (void)temp;\n    void *memory = allocate(\n        ParsedAttr::totalSizeToAlloc<ArgsUnion, detail::AvailabilityData,\n                                     detail::TypeTagForDatatypeData, ParsedType,\n                                     detail::PropertyData>(numArgs, 0, 0, 0,\n                                                           0));\n    return add(new (memory) ParsedAttr(attrName, attrRange, scopeName, scopeLoc,\n                                       args, numArgs, syntax, ellipsisLoc));\n  }\n\n  ParsedAttr *create(IdentifierInfo *attrName, SourceRange attrRange,\n                     IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                     IdentifierLoc *Param, const AvailabilityChange &introduced,\n                     const AvailabilityChange &deprecated,\n                     const AvailabilityChange &obsoleted,\n                     SourceLocation unavailable, const Expr *MessageExpr,\n                     ParsedAttr::Syntax syntax, SourceLocation strict,\n                     const Expr *ReplacementExpr) {\n    void *memory = allocate(AttributeFactory::AvailabilityAllocSize);\n    return add(new (memory) ParsedAttr(\n        attrName, attrRange, scopeName, scopeLoc, Param, introduced, deprecated,\n        obsoleted, unavailable, MessageExpr, syntax, strict, ReplacementExpr));\n  }\n\n  ParsedAttr *create(IdentifierInfo *attrName, SourceRange attrRange,\n                     IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                     IdentifierLoc *Param1, IdentifierLoc *Param2,\n                     IdentifierLoc *Param3, ParsedAttr::Syntax syntax) {\n    void *memory = allocate(\n        ParsedAttr::totalSizeToAlloc<ArgsUnion, detail::AvailabilityData,\n                                     detail::TypeTagForDatatypeData, ParsedType,\n                                     detail::PropertyData>(3, 0, 0, 0, 0));\n    return add(new (memory) ParsedAttr(attrName, attrRange, scopeName, scopeLoc,\n                                       Param1, Param2, Param3, syntax));\n  }\n\n  ParsedAttr *\n  createTypeTagForDatatype(IdentifierInfo *attrName, SourceRange attrRange,\n                           IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                           IdentifierLoc *argumentKind,\n                           ParsedType matchingCType, bool layoutCompatible,\n                           bool mustBeNull, ParsedAttr::Syntax syntax) {\n    void *memory = allocate(AttributeFactory::TypeTagForDatatypeAllocSize);\n    return add(new (memory) ParsedAttr(attrName, attrRange, scopeName, scopeLoc,\n                                       argumentKind, matchingCType,\n                                       layoutCompatible, mustBeNull, syntax));\n  }\n\n  ParsedAttr *createTypeAttribute(IdentifierInfo *attrName,\n                                  SourceRange attrRange,\n                                  IdentifierInfo *scopeName,\n                                  SourceLocation scopeLoc, ParsedType typeArg,\n                                  ParsedAttr::Syntax syntaxUsed) {\n    void *memory = allocate(\n        ParsedAttr::totalSizeToAlloc<ArgsUnion, detail::AvailabilityData,\n                                     detail::TypeTagForDatatypeData, ParsedType,\n                                     detail::PropertyData>(0, 0, 0, 1, 0));\n    return add(new (memory) ParsedAttr(attrName, attrRange, scopeName, scopeLoc,\n                                       typeArg, syntaxUsed));\n  }\n\n  ParsedAttr *\n  createPropertyAttribute(IdentifierInfo *attrName, SourceRange attrRange,\n                          IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                          IdentifierInfo *getterId, IdentifierInfo *setterId,\n                          ParsedAttr::Syntax syntaxUsed) {\n    void *memory = allocate(AttributeFactory::PropertyAllocSize);\n    return add(new (memory) ParsedAttr(attrName, attrRange, scopeName, scopeLoc,\n                                       getterId, setterId, syntaxUsed));\n  }\n};\n\nclass ParsedAttributesView {\n  using VecTy = llvm::TinyPtrVector<ParsedAttr *>;\n  using SizeType = decltype(std::declval<VecTy>().size());\n\npublic:\n  bool empty() const { return AttrList.empty(); }\n  SizeType size() const { return AttrList.size(); }\n  ParsedAttr &operator[](SizeType pos) { return *AttrList[pos]; }\n  const ParsedAttr &operator[](SizeType pos) const { return *AttrList[pos]; }\n\n  void addAtEnd(ParsedAttr *newAttr) {\n    assert(newAttr);\n    AttrList.push_back(newAttr);\n  }\n\n  void remove(ParsedAttr *ToBeRemoved) {\n    assert(is_contained(AttrList, ToBeRemoved) &&\n           \"Cannot remove attribute that isn't in the list\");\n    AttrList.erase(llvm::find(AttrList, ToBeRemoved));\n  }\n\n  void clearListOnly() { AttrList.clear(); }\n\n  struct iterator : llvm::iterator_adaptor_base<iterator, VecTy::iterator,\n                                                std::random_access_iterator_tag,\n                                                ParsedAttr> {\n    iterator() : iterator_adaptor_base(nullptr) {}\n    iterator(VecTy::iterator I) : iterator_adaptor_base(I) {}\n    reference operator*() { return **I; }\n    friend class ParsedAttributesView;\n  };\n  struct const_iterator\n      : llvm::iterator_adaptor_base<const_iterator, VecTy::const_iterator,\n                                    std::random_access_iterator_tag,\n                                    ParsedAttr> {\n    const_iterator() : iterator_adaptor_base(nullptr) {}\n    const_iterator(VecTy::const_iterator I) : iterator_adaptor_base(I) {}\n\n    reference operator*() const { return **I; }\n    friend class ParsedAttributesView;\n  };\n\n  void addAll(iterator B, iterator E) {\n    AttrList.insert(AttrList.begin(), B.I, E.I);\n  }\n\n  void addAll(const_iterator B, const_iterator E) {\n    AttrList.insert(AttrList.begin(), B.I, E.I);\n  }\n\n  void addAllAtEnd(iterator B, iterator E) {\n    AttrList.insert(AttrList.end(), B.I, E.I);\n  }\n\n  void addAllAtEnd(const_iterator B, const_iterator E) {\n    AttrList.insert(AttrList.end(), B.I, E.I);\n  }\n\n  iterator begin() { return iterator(AttrList.begin()); }\n  const_iterator begin() const { return const_iterator(AttrList.begin()); }\n  iterator end() { return iterator(AttrList.end()); }\n  const_iterator end() const { return const_iterator(AttrList.end()); }\n\n  ParsedAttr &front() {\n    assert(!empty());\n    return *AttrList.front();\n  }\n  const ParsedAttr &front() const {\n    assert(!empty());\n    return *AttrList.front();\n  }\n  ParsedAttr &back() {\n    assert(!empty());\n    return *AttrList.back();\n  }\n  const ParsedAttr &back() const {\n    assert(!empty());\n    return *AttrList.back();\n  }\n\n  bool hasAttribute(ParsedAttr::Kind K) const {\n    return llvm::any_of(AttrList, [K](const ParsedAttr *AL) {\n      return AL->getParsedKind() == K;\n    });\n  }\n\nprivate:\n  VecTy AttrList;\n};\n\n/// ParsedAttributes - A collection of parsed attributes.  Currently\n/// we don't differentiate between the various attribute syntaxes,\n/// which is basically silly.\n///\n/// Right now this is a very lightweight container, but the expectation\n/// is that this will become significantly more serious.\nclass ParsedAttributes : public ParsedAttributesView {\npublic:\n  ParsedAttributes(AttributeFactory &factory) : pool(factory) {}\n  ParsedAttributes(const ParsedAttributes &) = delete;\n\n  AttributePool &getPool() const { return pool; }\n\n  void takeAllFrom(ParsedAttributes &attrs) {\n    addAll(attrs.begin(), attrs.end());\n    attrs.clearListOnly();\n    pool.takeAllFrom(attrs.pool);\n  }\n\n  void takeOneFrom(ParsedAttributes &Attrs, ParsedAttr *PA) {\n    Attrs.getPool().remove(PA);\n    Attrs.remove(PA);\n    getPool().add(PA);\n    addAtEnd(PA);\n  }\n\n  void clear() {\n    clearListOnly();\n    pool.clear();\n  }\n\n  /// Add attribute with expression arguments.\n  ParsedAttr *addNew(IdentifierInfo *attrName, SourceRange attrRange,\n                     IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                     ArgsUnion *args, unsigned numArgs,\n                     ParsedAttr::Syntax syntax,\n                     SourceLocation ellipsisLoc = SourceLocation()) {\n    ParsedAttr *attr = pool.create(attrName, attrRange, scopeName, scopeLoc,\n                                   args, numArgs, syntax, ellipsisLoc);\n    addAtEnd(attr);\n    return attr;\n  }\n\n  /// Add availability attribute.\n  ParsedAttr *addNew(IdentifierInfo *attrName, SourceRange attrRange,\n                     IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                     IdentifierLoc *Param, const AvailabilityChange &introduced,\n                     const AvailabilityChange &deprecated,\n                     const AvailabilityChange &obsoleted,\n                     SourceLocation unavailable, const Expr *MessageExpr,\n                     ParsedAttr::Syntax syntax, SourceLocation strict,\n                     const Expr *ReplacementExpr) {\n    ParsedAttr *attr = pool.create(\n        attrName, attrRange, scopeName, scopeLoc, Param, introduced, deprecated,\n        obsoleted, unavailable, MessageExpr, syntax, strict, ReplacementExpr);\n    addAtEnd(attr);\n    return attr;\n  }\n\n  /// Add objc_bridge_related attribute.\n  ParsedAttr *addNew(IdentifierInfo *attrName, SourceRange attrRange,\n                     IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                     IdentifierLoc *Param1, IdentifierLoc *Param2,\n                     IdentifierLoc *Param3, ParsedAttr::Syntax syntax) {\n    ParsedAttr *attr = pool.create(attrName, attrRange, scopeName, scopeLoc,\n                                   Param1, Param2, Param3, syntax);\n    addAtEnd(attr);\n    return attr;\n  }\n\n  /// Add type_tag_for_datatype attribute.\n  ParsedAttr *\n  addNewTypeTagForDatatype(IdentifierInfo *attrName, SourceRange attrRange,\n                           IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                           IdentifierLoc *argumentKind,\n                           ParsedType matchingCType, bool layoutCompatible,\n                           bool mustBeNull, ParsedAttr::Syntax syntax) {\n    ParsedAttr *attr = pool.createTypeTagForDatatype(\n        attrName, attrRange, scopeName, scopeLoc, argumentKind, matchingCType,\n        layoutCompatible, mustBeNull, syntax);\n    addAtEnd(attr);\n    return attr;\n  }\n\n  /// Add an attribute with a single type argument.\n  ParsedAttr *addNewTypeAttr(IdentifierInfo *attrName, SourceRange attrRange,\n                             IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                             ParsedType typeArg,\n                             ParsedAttr::Syntax syntaxUsed) {\n    ParsedAttr *attr = pool.createTypeAttribute(attrName, attrRange, scopeName,\n                                                scopeLoc, typeArg, syntaxUsed);\n    addAtEnd(attr);\n    return attr;\n  }\n\n  /// Add microsoft __delspec(property) attribute.\n  ParsedAttr *\n  addNewPropertyAttr(IdentifierInfo *attrName, SourceRange attrRange,\n                     IdentifierInfo *scopeName, SourceLocation scopeLoc,\n                     IdentifierInfo *getterId, IdentifierInfo *setterId,\n                     ParsedAttr::Syntax syntaxUsed) {\n    ParsedAttr *attr =\n        pool.createPropertyAttribute(attrName, attrRange, scopeName, scopeLoc,\n                                     getterId, setterId, syntaxUsed);\n    addAtEnd(attr);\n    return attr;\n  }\n\nprivate:\n  mutable AttributePool pool;\n};\n\nstruct ParsedAttributesWithRange : ParsedAttributes {\n  ParsedAttributesWithRange(AttributeFactory &factory)\n      : ParsedAttributes(factory) {}\n\n  void clear() {\n    ParsedAttributes::clear();\n    Range = SourceRange();\n  }\n\n  SourceRange Range;\n};\nstruct ParsedAttributesViewWithRange : ParsedAttributesView {\n  ParsedAttributesViewWithRange() : ParsedAttributesView() {}\n  void clearListOnly() {\n    ParsedAttributesView::clearListOnly();\n    Range = SourceRange();\n  }\n\n  SourceRange Range;\n};\n\n/// These constants match the enumerated choices of\n/// err_attribute_argument_n_type and err_attribute_argument_type.\nenum AttributeArgumentNType {\n  AANT_ArgumentIntOrBool,\n  AANT_ArgumentIntegerConstant,\n  AANT_ArgumentString,\n  AANT_ArgumentIdentifier,\n  AANT_ArgumentConstantExpr,\n};\n\n/// These constants match the enumerated choices of\n/// warn_attribute_wrong_decl_type and err_attribute_wrong_decl_type.\nenum AttributeDeclKind {\n  ExpectedFunction,\n  ExpectedUnion,\n  ExpectedVariableOrFunction,\n  ExpectedFunctionOrMethod,\n  ExpectedFunctionMethodOrBlock,\n  ExpectedFunctionMethodOrParameter,\n  ExpectedVariable,\n  ExpectedVariableOrField,\n  ExpectedVariableFieldOrTag,\n  ExpectedTypeOrNamespace,\n  ExpectedFunctionVariableOrClass,\n  ExpectedKernelFunction,\n  ExpectedFunctionWithProtoType,\n};\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             const ParsedAttr &At) {\n  DB.AddTaggedVal(reinterpret_cast<intptr_t>(At.getAttrName()),\n                  DiagnosticsEngine::ak_identifierinfo);\n  return DB;\n}\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             const ParsedAttr *At) {\n  DB.AddTaggedVal(reinterpret_cast<intptr_t>(At->getAttrName()),\n                  DiagnosticsEngine::ak_identifierinfo);\n  return DB;\n}\n\n/// AttributeCommonInfo has a non-explicit constructor which takes an\n/// SourceRange as its only argument, this constructor has many uses so making\n/// it explicit is hard. This constructor causes ambiguity with\n/// DiagnosticBuilder &operator<<(const DiagnosticBuilder &DB, SourceRange R).\n/// We use SFINAE to disable any conversion and remove any ambiguity.\ntemplate <typename ACI,\n          typename std::enable_if_t<\n              std::is_same<ACI, AttributeCommonInfo>::value, int> = 0>\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                           const ACI &CI) {\n  DB.AddTaggedVal(reinterpret_cast<intptr_t>(CI.getAttrName()),\n                  DiagnosticsEngine::ak_identifierinfo);\n  return DB;\n}\n\ntemplate <typename ACI,\n          typename std::enable_if_t<\n              std::is_same<ACI, AttributeCommonInfo>::value, int> = 0>\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                           const ACI* CI) {\n  DB.AddTaggedVal(reinterpret_cast<intptr_t>(CI->getAttrName()),\n                  DiagnosticsEngine::ak_identifierinfo);\n  return DB;\n}\n\n} // namespace clang\n\n#endif // LLVM_CLANG_SEMA_ATTRIBUTELIST_H\n"}, "30": {"id": 30, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ModuleFileExtension.h", "content": "//===-- ModuleFileExtension.h - Module File Extensions ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SERIALIZATION_MODULEFILEEXTENSION_H\n#define LLVM_CLANG_SERIALIZATION_MODULEFILEEXTENSION_H\n\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/Support/ExtensibleRTTI.h\"\n#include <memory>\n#include <string>\n\nnamespace llvm {\nclass BitstreamCursor;\nclass BitstreamWriter;\nclass hash_code;\nclass raw_ostream;\n}\n\nnamespace clang {\n\nclass ASTReader;\nclass ASTWriter;\nclass Sema;\n\nnamespace serialization {\n  class ModuleFile;\n} // end namespace serialization\n\n/// Metadata for a module file extension.\nstruct ModuleFileExtensionMetadata {\n  /// The name used to identify this particular extension block within\n  /// the resulting module file. It should be unique to the particular\n  /// extension, because this name will be used to match the name of\n  /// an extension block to the appropriate reader.\n  std::string BlockName;\n\n  /// The major version of the extension data.\n  unsigned MajorVersion;\n\n  /// The minor version of the extension data.\n  unsigned MinorVersion;\n\n  /// A string containing additional user information that will be\n  /// stored with the metadata.\n  std::string UserInfo;\n};\n\nclass ModuleFileExtensionReader;\nclass ModuleFileExtensionWriter;\n\n/// An abstract superclass that describes a custom extension to the\n/// module/precompiled header file format.\n///\n/// A module file extension can introduce additional information into\n/// compiled module files (.pcm) and precompiled headers (.pch) via a\n/// custom writer that can then be accessed via a custom reader when\n/// the module file or precompiled header is loaded.\n///\n/// Subclasses must use LLVM RTTI for open class hierarchies.\nclass ModuleFileExtension\n    : public llvm::RTTIExtends<ModuleFileExtension, llvm::RTTIRoot> {\npublic:\n  /// Discriminator for LLVM RTTI.\n  static char ID;\n\n  virtual ~ModuleFileExtension();\n\n  /// Retrieves the metadata for this module file extension.\n  virtual ModuleFileExtensionMetadata getExtensionMetadata() const = 0;\n\n  /// Hash information about the presence of this extension into the\n  /// module hash code.\n  ///\n  /// The module hash code is used to distinguish different variants\n  /// of a module that are incompatible. If the presence, absence, or\n  /// version of the module file extension should force the creation\n  /// of a separate set of module files, override this method to\n  /// combine that distinguishing information into the module hash\n  /// code.\n  ///\n  /// The default implementation of this function simply returns the\n  /// hash code as given, so the presence/absence of this extension\n  /// does not distinguish module files.\n  virtual llvm::hash_code hashExtension(llvm::hash_code c) const;\n\n  /// Create a new module file extension writer, which will be\n  /// responsible for writing the extension contents into a particular\n  /// module file.\n  virtual std::unique_ptr<ModuleFileExtensionWriter>\n  createExtensionWriter(ASTWriter &Writer) = 0;\n\n  /// Create a new module file extension reader, given the\n  /// metadata read from the block and the cursor into the extension\n  /// block.\n  ///\n  /// May return null to indicate that an extension block with the\n  /// given metadata cannot be read.\n  virtual std::unique_ptr<ModuleFileExtensionReader>\n  createExtensionReader(const ModuleFileExtensionMetadata &Metadata,\n                        ASTReader &Reader, serialization::ModuleFile &Mod,\n                        const llvm::BitstreamCursor &Stream) = 0;\n};\n\n/// Abstract base class that writes a module file extension block into\n/// a module file.\nclass ModuleFileExtensionWriter {\n  ModuleFileExtension *Extension;\n\nprotected:\n  ModuleFileExtensionWriter(ModuleFileExtension *Extension)\n    : Extension(Extension) { }\n\npublic:\n  virtual ~ModuleFileExtensionWriter();\n\n  /// Retrieve the module file extension with which this writer is\n  /// associated.\n  ModuleFileExtension *getExtension() const { return Extension; }\n\n  /// Write the contents of the extension block into the given bitstream.\n  ///\n  /// Responsible for writing the contents of the extension into the\n  /// given stream. All of the contents should be written into custom\n  /// records with IDs >= FIRST_EXTENSION_RECORD_ID.\n  virtual void writeExtensionContents(Sema &SemaRef,\n                                      llvm::BitstreamWriter &Stream) = 0;\n};\n\n/// Abstract base class that reads a module file extension block from\n/// a module file.\n///\n/// Subclasses\nclass ModuleFileExtensionReader {\n  ModuleFileExtension *Extension;\n\nprotected:\n  ModuleFileExtensionReader(ModuleFileExtension *Extension)\n    : Extension(Extension) { }\n\npublic:\n  /// Retrieve the module file extension with which this reader is\n  /// associated.\n  ModuleFileExtension *getExtension() const { return Extension; }\n\n  virtual ~ModuleFileExtensionReader();\n};\n\n} // end namespace clang\n\n#endif // LLVM_CLANG_FRONTEND_MODULEFILEEXTENSION_H\n"}, "31": {"id": 31, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-actions.h", "content": "// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n// Google Mock - a framework for writing C++ mock classes.\n//\n// This file implements some commonly used actions.\n\n// IWYU pragma: private, include \"gmock/gmock.h\"\n\n#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_ACTIONS_H_\n#define GMOCK_INCLUDE_GMOCK_GMOCK_ACTIONS_H_\n\n#ifndef _WIN32_WCE\n# include <errno.h>\n#endif\n\n#include <algorithm>\n#include <string>\n\n#include \"gmock/internal/gmock-internal-utils.h\"\n#include \"gmock/internal/gmock-port.h\"\n\n#if GTEST_HAS_STD_TYPE_TRAITS_  // Defined by gtest-port.h via gmock-port.h.\n#include <type_traits>\n#endif\n\nnamespace testing {\n\n// To implement an action Foo, define:\n//   1. a class FooAction that implements the ActionInterface interface, and\n//   2. a factory function that creates an Action object from a\n//      const FooAction*.\n//\n// The two-level delegation design follows that of Matcher, providing\n// consistency for extension developers.  It also eases ownership\n// management as Action objects can now be copied like plain values.\n\nnamespace internal {\n\ntemplate <typename F1, typename F2>\nclass ActionAdaptor;\n\n// BuiltInDefaultValueGetter<T, true>::Get() returns a\n// default-constructed T value.  BuiltInDefaultValueGetter<T,\n// false>::Get() crashes with an error.\n//\n// This primary template is used when kDefaultConstructible is true.\ntemplate <typename T, bool kDefaultConstructible>\nstruct BuiltInDefaultValueGetter {\n  static T Get() { return T(); }\n};\ntemplate <typename T>\nstruct BuiltInDefaultValueGetter<T, false> {\n  static T Get() {\n    Assert(false, __FILE__, __LINE__,\n           \"Default action undefined for the function return type.\");\n    return internal::Invalid<T>();\n    // The above statement will never be reached, but is required in\n    // order for this function to compile.\n  }\n};\n\n// BuiltInDefaultValue<T>::Get() returns the \"built-in\" default value\n// for type T, which is NULL when T is a raw pointer type, 0 when T is\n// a numeric type, false when T is bool, or \"\" when T is string or\n// std::string.  In addition, in C++11 and above, it turns a\n// default-constructed T value if T is default constructible.  For any\n// other type T, the built-in default T value is undefined, and the\n// function will abort the process.\ntemplate <typename T>\nclass BuiltInDefaultValue {\n public:\n#if GTEST_HAS_STD_TYPE_TRAITS_\n  // This function returns true iff type T has a built-in default value.\n  static bool Exists() {\n    return ::std::is_default_constructible<T>::value;\n  }\n\n  static T Get() {\n    return BuiltInDefaultValueGetter<\n        T, ::std::is_default_constructible<T>::value>::Get();\n  }\n\n#else  // GTEST_HAS_STD_TYPE_TRAITS_\n  // This function returns true iff type T has a built-in default value.\n  static bool Exists() {\n    return false;\n  }\n\n  static T Get() {\n    return BuiltInDefaultValueGetter<T, false>::Get();\n  }\n\n#endif  // GTEST_HAS_STD_TYPE_TRAITS_\n};\n\n// This partial specialization says that we use the same built-in\n// default value for T and const T.\ntemplate <typename T>\nclass BuiltInDefaultValue<const T> {\n public:\n  static bool Exists() { return BuiltInDefaultValue<T>::Exists(); }\n  static T Get() { return BuiltInDefaultValue<T>::Get(); }\n};\n\n// This partial specialization defines the default values for pointer\n// types.\ntemplate <typename T>\nclass BuiltInDefaultValue<T*> {\n public:\n  static bool Exists() { return true; }\n  static T* Get() { return NULL; }\n};\n\n// The following specializations define the default values for\n// specific types we care about.\n#define GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(type, value) \\\n  template <> \\\n  class BuiltInDefaultValue<type> { \\\n   public: \\\n    static bool Exists() { return true; } \\\n    static type Get() { return value; } \\\n  }\n\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(void, );  // NOLINT\n#if GTEST_HAS_GLOBAL_STRING\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(::string, \"\");\n#endif  // GTEST_HAS_GLOBAL_STRING\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(::std::string, \"\");\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(bool, false);\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned char, '\\0');\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed char, '\\0');\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(char, '\\0');\n\n// There's no need for a default action for signed wchar_t, as that\n// type is the same as wchar_t for gcc, and invalid for MSVC.\n//\n// There's also no need for a default action for unsigned wchar_t, as\n// that type is the same as unsigned int for gcc, and invalid for\n// MSVC.\n#if GMOCK_WCHAR_T_IS_NATIVE_\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(wchar_t, 0U);  // NOLINT\n#endif\n\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned short, 0U);  // NOLINT\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed short, 0);     // NOLINT\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned int, 0U);\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed int, 0);\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned long, 0UL);  // NOLINT\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed long, 0L);     // NOLINT\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(UInt64, 0);\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(Int64, 0);\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(float, 0);\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(double, 0);\n\n#undef GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_\n\n}  // namespace internal\n\n// When an unexpected function call is encountered, Google Mock will\n// let it return a default value if the user has specified one for its\n// return type, or if the return type has a built-in default value;\n// otherwise Google Mock won't know what value to return and will have\n// to abort the process.\n//\n// The DefaultValue<T> class allows a user to specify the\n// default value for a type T that is both copyable and publicly\n// destructible (i.e. anything that can be used as a function return\n// type).  The usage is:\n//\n//   // Sets the default value for type T to be foo.\n//   DefaultValue<T>::Set(foo);\ntemplate <typename T>\nclass DefaultValue {\n public:\n  // Sets the default value for type T; requires T to be\n  // copy-constructable and have a public destructor.\n  static void Set(T x) {\n    delete producer_;\n    producer_ = new FixedValueProducer(x);\n  }\n\n  // Provides a factory function to be called to generate the default value.\n  // This method can be used even if T is only move-constructible, but it is not\n  // limited to that case.\n  typedef T (*FactoryFunction)();\n  static void SetFactory(FactoryFunction factory) {\n    delete producer_;\n    producer_ = new FactoryValueProducer(factory);\n  }\n\n  // Unsets the default value for type T.\n  static void Clear() {\n    delete producer_;\n    producer_ = NULL;\n  }\n\n  // Returns true iff the user has set the default value for type T.\n  static bool IsSet() { return producer_ != NULL; }\n\n  // Returns true if T has a default return value set by the user or there\n  // exists a built-in default value.\n  static bool Exists() {\n    return IsSet() || internal::BuiltInDefaultValue<T>::Exists();\n  }\n\n  // Returns the default value for type T if the user has set one;\n  // otherwise returns the built-in default value. Requires that Exists()\n  // is true, which ensures that the return value is well-defined.\n  static T Get() {\n    return producer_ == NULL ?\n        internal::BuiltInDefaultValue<T>::Get() : producer_->Produce();\n  }\n\n private:\n  class ValueProducer {\n   public:\n    virtual ~ValueProducer() {}\n    virtual T Produce() = 0;\n  };\n\n  class FixedValueProducer : public ValueProducer {\n   public:\n    explicit FixedValueProducer(T value) : value_(value) {}\n    virtual T Produce() { return value_; }\n\n   private:\n    const T value_;\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(FixedValueProducer);\n  };\n\n  class FactoryValueProducer : public ValueProducer {\n   public:\n    explicit FactoryValueProducer(FactoryFunction factory)\n        : factory_(factory) {}\n    virtual T Produce() { return factory_(); }\n\n   private:\n    const FactoryFunction factory_;\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(FactoryValueProducer);\n  };\n\n  static ValueProducer* producer_;\n};\n\n// This partial specialization allows a user to set default values for\n// reference types.\ntemplate <typename T>\nclass DefaultValue<T&> {\n public:\n  // Sets the default value for type T&.\n  static void Set(T& x) {  // NOLINT\n    address_ = &x;\n  }\n\n  // Unsets the default value for type T&.\n  static void Clear() {\n    address_ = NULL;\n  }\n\n  // Returns true iff the user has set the default value for type T&.\n  static bool IsSet() { return address_ != NULL; }\n\n  // Returns true if T has a default return value set by the user or there\n  // exists a built-in default value.\n  static bool Exists() {\n    return IsSet() || internal::BuiltInDefaultValue<T&>::Exists();\n  }\n\n  // Returns the default value for type T& if the user has set one;\n  // otherwise returns the built-in default value if there is one;\n  // otherwise aborts the process.\n  static T& Get() {\n    return address_ == NULL ?\n        internal::BuiltInDefaultValue<T&>::Get() : *address_;\n  }\n\n private:\n  static T* address_;\n};\n\n// This specialization allows DefaultValue<void>::Get() to\n// compile.\ntemplate <>\nclass DefaultValue<void> {\n public:\n  static bool Exists() { return true; }\n  static void Get() {}\n};\n\n// Points to the user-set default value for type T.\ntemplate <typename T>\ntypename DefaultValue<T>::ValueProducer* DefaultValue<T>::producer_ = NULL;\n\n// Points to the user-set default value for type T&.\ntemplate <typename T>\nT* DefaultValue<T&>::address_ = NULL;\n\n// Implement this interface to define an action for function type F.\ntemplate <typename F>\nclass ActionInterface {\n public:\n  typedef typename internal::Function<F>::Result Result;\n  typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n\n  ActionInterface() {}\n  virtual ~ActionInterface() {}\n\n  // Performs the action.  This method is not const, as in general an\n  // action can have side effects and be stateful.  For example, a\n  // get-the-next-element-from-the-collection action will need to\n  // remember the current element.\n  virtual Result Perform(const ArgumentTuple& args) = 0;\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ActionInterface);\n};\n\n// An Action<F> is a copyable and IMMUTABLE (except by assignment)\n// object that represents an action to be taken when a mock function\n// of type F is called.  The implementation of Action<T> is just a\n// linked_ptr to const ActionInterface<T>, so copying is fairly cheap.\n// Don't inherit from Action!\n//\n// You can view an object implementing ActionInterface<F> as a\n// concrete action (including its current state), and an Action<F>\n// object as a handle to it.\ntemplate <typename F>\nclass Action {\n public:\n  typedef typename internal::Function<F>::Result Result;\n  typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n\n  // Constructs a null Action.  Needed for storing Action objects in\n  // STL containers.\n  Action() : impl_(NULL) {}\n\n  // Constructs an Action from its implementation.  A NULL impl is\n  // used to represent the \"do-default\" action.\n  explicit Action(ActionInterface<F>* impl) : impl_(impl) {}\n\n  // Copy constructor.\n  Action(const Action &action) = default;\n  Action &operator=(const Action &action) = default;\n\n  // This constructor allows us to turn an Action<Func> object into an\n  // Action<F>, as long as F's arguments can be implicitly converted\n  // to Func's and Func's return type can be implicitly converted to\n  // F's.\n  template <typename Func>\n  explicit Action(const Action<Func>& action);\n\n  // Returns true iff this is the DoDefault() action.\n  bool IsDoDefault() const { return impl_.get() == NULL; }\n\n  // Performs the action.  Note that this method is const even though\n  // the corresponding method in ActionInterface is not.  The reason\n  // is that a const Action<F> means that it cannot be re-bound to\n  // another concrete action, not that the concrete action it binds to\n  // cannot change state.  (Think of the difference between a const\n  // pointer and a pointer to const.)\n  Result Perform(const ArgumentTuple& args) const {\n    internal::Assert(\n        !IsDoDefault(), __FILE__, __LINE__,\n        \"You are using DoDefault() inside a composite action like \"\n        \"DoAll() or WithArgs().  This is not supported for technical \"\n        \"reasons.  Please instead spell out the default action, or \"\n        \"assign the default action to an Action variable and use \"\n        \"the variable in various places.\");\n    return impl_->Perform(args);\n  }\n\n private:\n  template <typename F1, typename F2>\n  friend class internal::ActionAdaptor;\n\n  internal::linked_ptr<ActionInterface<F> > impl_;\n};\n\n// The PolymorphicAction class template makes it easy to implement a\n// polymorphic action (i.e. an action that can be used in mock\n// functions of than one type, e.g. Return()).\n//\n// To define a polymorphic action, a user first provides a COPYABLE\n// implementation class that has a Perform() method template:\n//\n//   class FooAction {\n//    public:\n//     template <typename Result, typename ArgumentTuple>\n//     Result Perform(const ArgumentTuple& args) const {\n//       // Processes the arguments and returns a result, using\n//       // tr1::get<N>(args) to get the N-th (0-based) argument in the tuple.\n//     }\n//     ...\n//   };\n//\n// Then the user creates the polymorphic action using\n// MakePolymorphicAction(object) where object has type FooAction.  See\n// the definition of Return(void) and SetArgumentPointee<N>(value) for\n// complete examples.\ntemplate <typename Impl>\nclass PolymorphicAction {\n public:\n  explicit PolymorphicAction(const Impl& impl) : impl_(impl) {}\n\n  template <typename F>\n  operator Action<F>() const {\n    return Action<F>(new MonomorphicImpl<F>(impl_));\n  }\n\n private:\n  template <typename F>\n  class MonomorphicImpl : public ActionInterface<F> {\n   public:\n    typedef typename internal::Function<F>::Result Result;\n    typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n\n    explicit MonomorphicImpl(const Impl& impl) : impl_(impl) {}\n\n    virtual Result Perform(const ArgumentTuple& args) {\n      return impl_.template Perform<Result>(args);\n    }\n\n   private:\n    Impl impl_;\n\n    GTEST_DISALLOW_ASSIGN_(MonomorphicImpl);\n  };\n\n  Impl impl_;\n\n  GTEST_DISALLOW_ASSIGN_(PolymorphicAction);\n};\n\n// Creates an Action from its implementation and returns it.  The\n// created Action object owns the implementation.\ntemplate <typename F>\nAction<F> MakeAction(ActionInterface<F>* impl) {\n  return Action<F>(impl);\n}\n\n// Creates a polymorphic action from its implementation.  This is\n// easier to use than the PolymorphicAction<Impl> constructor as it\n// doesn't require you to explicitly write the template argument, e.g.\n//\n//   MakePolymorphicAction(foo);\n// vs\n//   PolymorphicAction<TypeOfFoo>(foo);\ntemplate <typename Impl>\ninline PolymorphicAction<Impl> MakePolymorphicAction(const Impl& impl) {\n  return PolymorphicAction<Impl>(impl);\n}\n\nnamespace internal {\n\n// Allows an Action<F2> object to pose as an Action<F1>, as long as F2\n// and F1 are compatible.\ntemplate <typename F1, typename F2>\nclass ActionAdaptor : public ActionInterface<F1> {\n public:\n  typedef typename internal::Function<F1>::Result Result;\n  typedef typename internal::Function<F1>::ArgumentTuple ArgumentTuple;\n\n  explicit ActionAdaptor(const Action<F2>& from) : impl_(from.impl_) {}\n\n  virtual Result Perform(const ArgumentTuple& args) {\n    return impl_->Perform(args);\n  }\n\n private:\n  const internal::linked_ptr<ActionInterface<F2> > impl_;\n\n  GTEST_DISALLOW_ASSIGN_(ActionAdaptor);\n};\n\n// Helper struct to specialize ReturnAction to execute a move instead of a copy\n// on return. Useful for move-only types, but could be used on any type.\ntemplate <typename T>\nstruct ByMoveWrapper {\n  explicit ByMoveWrapper(T value) : payload(internal::move(value)) {}\n  T payload;\n};\n\n// Implements the polymorphic Return(x) action, which can be used in\n// any function that returns the type of x, regardless of the argument\n// types.\n//\n// Note: The value passed into Return must be converted into\n// Function<F>::Result when this action is cast to Action<F> rather than\n// when that action is performed. This is important in scenarios like\n//\n// MOCK_METHOD1(Method, T(U));\n// ...\n// {\n//   Foo foo;\n//   X x(&foo);\n//   EXPECT_CALL(mock, Method(_)).WillOnce(Return(x));\n// }\n//\n// In the example above the variable x holds reference to foo which leaves\n// scope and gets destroyed.  If copying X just copies a reference to foo,\n// that copy will be left with a hanging reference.  If conversion to T\n// makes a copy of foo, the above code is safe. To support that scenario, we\n// need to make sure that the type conversion happens inside the EXPECT_CALL\n// statement, and conversion of the result of Return to Action<T(U)> is a\n// good place for that.\n//\ntemplate <typename R>\nclass ReturnAction {\n public:\n  // Constructs a ReturnAction object from the value to be returned.\n  // 'value' is passed by value instead of by const reference in order\n  // to allow Return(\"string literal\") to compile.\n  explicit ReturnAction(R value) : value_(new R(internal::move(value))) {}\n\n  // This template type conversion operator allows Return(x) to be\n  // used in ANY function that returns x's type.\n  template <typename F>\n  operator Action<F>() const {\n    // Assert statement belongs here because this is the best place to verify\n    // conditions on F. It produces the clearest error messages\n    // in most compilers.\n    // Impl really belongs in this scope as a local class but can't\n    // because MSVC produces duplicate symbols in different translation units\n    // in this case. Until MS fixes that bug we put Impl into the class scope\n    // and put the typedef both here (for use in assert statement) and\n    // in the Impl class. But both definitions must be the same.\n    typedef typename Function<F>::Result Result;\n    GTEST_COMPILE_ASSERT_(\n        !is_reference<Result>::value,\n        use_ReturnRef_instead_of_Return_to_return_a_reference);\n    return Action<F>(new Impl<R, F>(value_));\n  }\n\n private:\n  // Implements the Return(x) action for a particular function type F.\n  template <typename R_, typename F>\n  class Impl : public ActionInterface<F> {\n   public:\n    typedef typename Function<F>::Result Result;\n    typedef typename Function<F>::ArgumentTuple ArgumentTuple;\n\n    // The implicit cast is necessary when Result has more than one\n    // single-argument constructor (e.g. Result is std::vector<int>) and R\n    // has a type conversion operator template.  In that case, value_(value)\n    // won't compile as the compiler doesn't known which constructor of\n    // Result to call.  ImplicitCast_ forces the compiler to convert R to\n    // Result without considering explicit constructors, thus resolving the\n    // ambiguity. value_ is then initialized using its copy constructor.\n    explicit Impl(const linked_ptr<R>& value)\n        : value_before_cast_(*value),\n          value_(ImplicitCast_<Result>(value_before_cast_)) {}\n\n    virtual Result Perform(const ArgumentTuple&) { return value_; }\n\n   private:\n    GTEST_COMPILE_ASSERT_(!is_reference<Result>::value,\n                          Result_cannot_be_a_reference_type);\n    // We save the value before casting just in case it is being cast to a\n    // wrapper type.\n    R value_before_cast_;\n    Result value_;\n\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(Impl);\n  };\n\n  // Partially specialize for ByMoveWrapper. This version of ReturnAction will\n  // move its contents instead.\n  template <typename R_, typename F>\n  class Impl<ByMoveWrapper<R_>, F> : public ActionInterface<F> {\n   public:\n    typedef typename Function<F>::Result Result;\n    typedef typename Function<F>::ArgumentTuple ArgumentTuple;\n\n    explicit Impl(const linked_ptr<R>& wrapper)\n        : performed_(false), wrapper_(wrapper) {}\n\n    virtual Result Perform(const ArgumentTuple&) {\n      GTEST_CHECK_(!performed_)\n          << \"A ByMove() action should only be performed once.\";\n      performed_ = true;\n      return internal::move(wrapper_->payload);\n    }\n\n   private:\n    bool performed_;\n    const linked_ptr<R> wrapper_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  const linked_ptr<R> value_;\n\n  GTEST_DISALLOW_ASSIGN_(ReturnAction);\n};\n\n// Implements the ReturnNull() action.\nclass ReturnNullAction {\n public:\n  // Allows ReturnNull() to be used in any pointer-returning function. In C++11\n  // this is enforced by returning nullptr, and in non-C++11 by asserting a\n  // pointer type on compile time.\n  template <typename Result, typename ArgumentTuple>\n  static Result Perform(const ArgumentTuple&) {\n#if GTEST_LANG_CXX11\n    return nullptr;\n#else\n    GTEST_COMPILE_ASSERT_(internal::is_pointer<Result>::value,\n                          ReturnNull_can_be_used_to_return_a_pointer_only);\n    return NULL;\n#endif  // GTEST_LANG_CXX11\n  }\n};\n\n// Implements the Return() action.\nclass ReturnVoidAction {\n public:\n  // Allows Return() to be used in any void-returning function.\n  template <typename Result, typename ArgumentTuple>\n  static void Perform(const ArgumentTuple&) {\n    CompileAssertTypesEqual<void, Result>();\n  }\n};\n\n// Implements the polymorphic ReturnRef(x) action, which can be used\n// in any function that returns a reference to the type of x,\n// regardless of the argument types.\ntemplate <typename T>\nclass ReturnRefAction {\n public:\n  // Constructs a ReturnRefAction object from the reference to be returned.\n  explicit ReturnRefAction(T& ref) : ref_(ref) {}  // NOLINT\n\n  // This template type conversion operator allows ReturnRef(x) to be\n  // used in ANY function that returns a reference to x's type.\n  template <typename F>\n  operator Action<F>() const {\n    typedef typename Function<F>::Result Result;\n    // Asserts that the function return type is a reference.  This\n    // catches the user error of using ReturnRef(x) when Return(x)\n    // should be used, and generates some helpful error message.\n    GTEST_COMPILE_ASSERT_(internal::is_reference<Result>::value,\n                          use_Return_instead_of_ReturnRef_to_return_a_value);\n    return Action<F>(new Impl<F>(ref_));\n  }\n\n private:\n  // Implements the ReturnRef(x) action for a particular function type F.\n  template <typename F>\n  class Impl : public ActionInterface<F> {\n   public:\n    typedef typename Function<F>::Result Result;\n    typedef typename Function<F>::ArgumentTuple ArgumentTuple;\n\n    explicit Impl(T& ref) : ref_(ref) {}  // NOLINT\n\n    virtual Result Perform(const ArgumentTuple&) {\n      return ref_;\n    }\n\n   private:\n    T& ref_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  T& ref_;\n\n  GTEST_DISALLOW_ASSIGN_(ReturnRefAction);\n};\n\n// Implements the polymorphic ReturnRefOfCopy(x) action, which can be\n// used in any function that returns a reference to the type of x,\n// regardless of the argument types.\ntemplate <typename T>\nclass ReturnRefOfCopyAction {\n public:\n  // Constructs a ReturnRefOfCopyAction object from the reference to\n  // be returned.\n  explicit ReturnRefOfCopyAction(const T& value) : value_(value) {}  // NOLINT\n\n  // This template type conversion operator allows ReturnRefOfCopy(x) to be\n  // used in ANY function that returns a reference to x's type.\n  template <typename F>\n  operator Action<F>() const {\n    typedef typename Function<F>::Result Result;\n    // Asserts that the function return type is a reference.  This\n    // catches the user error of using ReturnRefOfCopy(x) when Return(x)\n    // should be used, and generates some helpful error message.\n    GTEST_COMPILE_ASSERT_(\n        internal::is_reference<Result>::value,\n        use_Return_instead_of_ReturnRefOfCopy_to_return_a_value);\n    return Action<F>(new Impl<F>(value_));\n  }\n\n private:\n  // Implements the ReturnRefOfCopy(x) action for a particular function type F.\n  template <typename F>\n  class Impl : public ActionInterface<F> {\n   public:\n    typedef typename Function<F>::Result Result;\n    typedef typename Function<F>::ArgumentTuple ArgumentTuple;\n\n    explicit Impl(const T& value) : value_(value) {}  // NOLINT\n\n    virtual Result Perform(const ArgumentTuple&) {\n      return value_;\n    }\n\n   private:\n    T value_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  const T value_;\n\n  GTEST_DISALLOW_ASSIGN_(ReturnRefOfCopyAction);\n};\n\n// Implements the polymorphic DoDefault() action.\nclass DoDefaultAction {\n public:\n  // This template type conversion operator allows DoDefault() to be\n  // used in any function.\n  template <typename F>\n  operator Action<F>() const { return Action<F>(NULL); }\n};\n\n// Implements the Assign action to set a given pointer referent to a\n// particular value.\ntemplate <typename T1, typename T2>\nclass AssignAction {\n public:\n  AssignAction(T1* ptr, T2 value) : ptr_(ptr), value_(value) {}\n\n  template <typename Result, typename ArgumentTuple>\n  void Perform(const ArgumentTuple& /* args */) const {\n    *ptr_ = value_;\n  }\n\n private:\n  T1* const ptr_;\n  const T2 value_;\n\n  GTEST_DISALLOW_ASSIGN_(AssignAction);\n};\n\n#if !GTEST_OS_WINDOWS_MOBILE\n\n// Implements the SetErrnoAndReturn action to simulate return from\n// various system calls and libc functions.\ntemplate <typename T>\nclass SetErrnoAndReturnAction {\n public:\n  SetErrnoAndReturnAction(int errno_value, T result)\n      : errno_(errno_value),\n        result_(result) {}\n  template <typename Result, typename ArgumentTuple>\n  Result Perform(const ArgumentTuple& /* args */) const {\n    errno = errno_;\n    return result_;\n  }\n\n private:\n  const int errno_;\n  const T result_;\n\n  GTEST_DISALLOW_ASSIGN_(SetErrnoAndReturnAction);\n};\n\n#endif  // !GTEST_OS_WINDOWS_MOBILE\n\n// Implements the SetArgumentPointee<N>(x) action for any function\n// whose N-th argument (0-based) is a pointer to x's type.  The\n// template parameter kIsProto is true iff type A is ProtocolMessage,\n// proto2::Message, or a sub-class of those.\ntemplate <size_t N, typename A, bool kIsProto>\nclass SetArgumentPointeeAction {\n public:\n  // Constructs an action that sets the variable pointed to by the\n  // N-th function argument to 'value'.\n  explicit SetArgumentPointeeAction(const A& value) : value_(value) {}\n\n  template <typename Result, typename ArgumentTuple>\n  void Perform(const ArgumentTuple& args) const {\n    CompileAssertTypesEqual<void, Result>();\n    *::testing::get<N>(args) = value_;\n  }\n\n private:\n  const A value_;\n\n  GTEST_DISALLOW_ASSIGN_(SetArgumentPointeeAction);\n};\n\ntemplate <size_t N, typename Proto>\nclass SetArgumentPointeeAction<N, Proto, true> {\n public:\n  // Constructs an action that sets the variable pointed to by the\n  // N-th function argument to 'proto'.  Both ProtocolMessage and\n  // proto2::Message have the CopyFrom() method, so the same\n  // implementation works for both.\n  explicit SetArgumentPointeeAction(const Proto& proto) : proto_(new Proto) {\n    proto_->CopyFrom(proto);\n  }\n\n  template <typename Result, typename ArgumentTuple>\n  void Perform(const ArgumentTuple& args) const {\n    CompileAssertTypesEqual<void, Result>();\n    ::testing::get<N>(args)->CopyFrom(*proto_);\n  }\n\n private:\n  const internal::linked_ptr<Proto> proto_;\n\n  GTEST_DISALLOW_ASSIGN_(SetArgumentPointeeAction);\n};\n\n// Implements the InvokeWithoutArgs(f) action.  The template argument\n// FunctionImpl is the implementation type of f, which can be either a\n// function pointer or a functor.  InvokeWithoutArgs(f) can be used as an\n// Action<F> as long as f's type is compatible with F (i.e. f can be\n// assigned to a tr1::function<F>).\ntemplate <typename FunctionImpl>\nclass InvokeWithoutArgsAction {\n public:\n  // The c'tor makes a copy of function_impl (either a function\n  // pointer or a functor).\n  explicit InvokeWithoutArgsAction(FunctionImpl function_impl)\n      : function_impl_(function_impl) {}\n\n  // Allows InvokeWithoutArgs(f) to be used as any action whose type is\n  // compatible with f.\n  template <typename Result, typename ArgumentTuple>\n  Result Perform(const ArgumentTuple&) { return function_impl_(); }\n\n private:\n  FunctionImpl function_impl_;\n\n  GTEST_DISALLOW_ASSIGN_(InvokeWithoutArgsAction);\n};\n\n// Implements the InvokeWithoutArgs(object_ptr, &Class::Method) action.\ntemplate <class Class, typename MethodPtr>\nclass InvokeMethodWithoutArgsAction {\n public:\n  InvokeMethodWithoutArgsAction(Class* obj_ptr, MethodPtr method_ptr)\n      : obj_ptr_(obj_ptr), method_ptr_(method_ptr) {}\n\n  template <typename Result, typename ArgumentTuple>\n  Result Perform(const ArgumentTuple&) const {\n    return (obj_ptr_->*method_ptr_)();\n  }\n\n private:\n  Class* const obj_ptr_;\n  const MethodPtr method_ptr_;\n\n  GTEST_DISALLOW_ASSIGN_(InvokeMethodWithoutArgsAction);\n};\n\n// Implements the IgnoreResult(action) action.\ntemplate <typename A>\nclass IgnoreResultAction {\n public:\n  explicit IgnoreResultAction(const A& action) : action_(action) {}\n\n  template <typename F>\n  operator Action<F>() const {\n    // Assert statement belongs here because this is the best place to verify\n    // conditions on F. It produces the clearest error messages\n    // in most compilers.\n    // Impl really belongs in this scope as a local class but can't\n    // because MSVC produces duplicate symbols in different translation units\n    // in this case. Until MS fixes that bug we put Impl into the class scope\n    // and put the typedef both here (for use in assert statement) and\n    // in the Impl class. But both definitions must be the same.\n    typedef typename internal::Function<F>::Result Result;\n\n    // Asserts at compile time that F returns void.\n    CompileAssertTypesEqual<void, Result>();\n\n    return Action<F>(new Impl<F>(action_));\n  }\n\n private:\n  template <typename F>\n  class Impl : public ActionInterface<F> {\n   public:\n    typedef typename internal::Function<F>::Result Result;\n    typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n\n    explicit Impl(const A& action) : action_(action) {}\n\n    virtual void Perform(const ArgumentTuple& args) {\n      // Performs the action and ignores its result.\n      action_.Perform(args);\n    }\n\n   private:\n    // Type OriginalFunction is the same as F except that its return\n    // type is IgnoredValue.\n    typedef typename internal::Function<F>::MakeResultIgnoredValue\n        OriginalFunction;\n\n    const Action<OriginalFunction> action_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  const A action_;\n\n  GTEST_DISALLOW_ASSIGN_(IgnoreResultAction);\n};\n\n// A ReferenceWrapper<T> object represents a reference to type T,\n// which can be either const or not.  It can be explicitly converted\n// from, and implicitly converted to, a T&.  Unlike a reference,\n// ReferenceWrapper<T> can be copied and can survive template type\n// inference.  This is used to support by-reference arguments in the\n// InvokeArgument<N>(...) action.  The idea was from \"reference\n// wrappers\" in tr1, which we don't have in our source tree yet.\ntemplate <typename T>\nclass ReferenceWrapper {\n public:\n  // Constructs a ReferenceWrapper<T> object from a T&.\n  explicit ReferenceWrapper(T& l_value) : pointer_(&l_value) {}  // NOLINT\n\n  // Allows a ReferenceWrapper<T> object to be implicitly converted to\n  // a T&.\n  operator T&() const { return *pointer_; }\n private:\n  T* pointer_;\n};\n\n// Allows the expression ByRef(x) to be printed as a reference to x.\ntemplate <typename T>\nvoid PrintTo(const ReferenceWrapper<T>& ref, ::std::ostream* os) {\n  T& value = ref;\n  UniversalPrinter<T&>::Print(value, os);\n}\n\n// Does two actions sequentially.  Used for implementing the DoAll(a1,\n// a2, ...) action.\ntemplate <typename Action1, typename Action2>\nclass DoBothAction {\n public:\n  DoBothAction(Action1 action1, Action2 action2)\n      : action1_(action1), action2_(action2) {}\n\n  // This template type conversion operator allows DoAll(a1, ..., a_n)\n  // to be used in ANY function of compatible type.\n  template <typename F>\n  operator Action<F>() const {\n    return Action<F>(new Impl<F>(action1_, action2_));\n  }\n\n private:\n  // Implements the DoAll(...) action for a particular function type F.\n  template <typename F>\n  class Impl : public ActionInterface<F> {\n   public:\n    typedef typename Function<F>::Result Result;\n    typedef typename Function<F>::ArgumentTuple ArgumentTuple;\n    typedef typename Function<F>::MakeResultVoid VoidResult;\n\n    Impl(const Action<VoidResult>& action1, const Action<F>& action2)\n        : action1_(action1), action2_(action2) {}\n\n    virtual Result Perform(const ArgumentTuple& args) {\n      action1_.Perform(args);\n      return action2_.Perform(args);\n    }\n\n   private:\n    const Action<VoidResult> action1_;\n    const Action<F> action2_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  Action1 action1_;\n  Action2 action2_;\n\n  GTEST_DISALLOW_ASSIGN_(DoBothAction);\n};\n\n}  // namespace internal\n\n// An Unused object can be implicitly constructed from ANY value.\n// This is handy when defining actions that ignore some or all of the\n// mock function arguments.  For example, given\n//\n//   MOCK_METHOD3(Foo, double(const string& label, double x, double y));\n//   MOCK_METHOD3(Bar, double(int index, double x, double y));\n//\n// instead of\n//\n//   double DistanceToOriginWithLabel(const string& label, double x, double y) {\n//     return sqrt(x*x + y*y);\n//   }\n//   double DistanceToOriginWithIndex(int index, double x, double y) {\n//     return sqrt(x*x + y*y);\n//   }\n//   ...\n//   EXEPCT_CALL(mock, Foo(\"abc\", _, _))\n//       .WillOnce(Invoke(DistanceToOriginWithLabel));\n//   EXEPCT_CALL(mock, Bar(5, _, _))\n//       .WillOnce(Invoke(DistanceToOriginWithIndex));\n//\n// you could write\n//\n//   // We can declare any uninteresting argument as Unused.\n//   double DistanceToOrigin(Unused, double x, double y) {\n//     return sqrt(x*x + y*y);\n//   }\n//   ...\n//   EXEPCT_CALL(mock, Foo(\"abc\", _, _)).WillOnce(Invoke(DistanceToOrigin));\n//   EXEPCT_CALL(mock, Bar(5, _, _)).WillOnce(Invoke(DistanceToOrigin));\ntypedef internal::IgnoredValue Unused;\n\n// This constructor allows us to turn an Action<From> object into an\n// Action<To>, as long as To's arguments can be implicitly converted\n// to From's and From's return type cann be implicitly converted to\n// To's.\ntemplate <typename To>\ntemplate <typename From>\nAction<To>::Action(const Action<From>& from)\n    : impl_(new internal::ActionAdaptor<To, From>(from)) {}\n\n// Creates an action that returns 'value'.  'value' is passed by value\n// instead of const reference - otherwise Return(\"string literal\")\n// will trigger a compiler error about using array as initializer.\ntemplate <typename R>\ninternal::ReturnAction<R> Return(R value) {\n  return internal::ReturnAction<R>(internal::move(value));\n}\n\n// Creates an action that returns NULL.\ninline PolymorphicAction<internal::ReturnNullAction> ReturnNull() {\n  return MakePolymorphicAction(internal::ReturnNullAction());\n}\n\n// Creates an action that returns from a void function.\ninline PolymorphicAction<internal::ReturnVoidAction> Return() {\n  return MakePolymorphicAction(internal::ReturnVoidAction());\n}\n\n// Creates an action that returns the reference to a variable.\ntemplate <typename R>\ninline internal::ReturnRefAction<R> ReturnRef(R& x) {  // NOLINT\n  return internal::ReturnRefAction<R>(x);\n}\n\n// Creates an action that returns the reference to a copy of the\n// argument.  The copy is created when the action is constructed and\n// lives as long as the action.\ntemplate <typename R>\ninline internal::ReturnRefOfCopyAction<R> ReturnRefOfCopy(const R& x) {\n  return internal::ReturnRefOfCopyAction<R>(x);\n}\n\n// Modifies the parent action (a Return() action) to perform a move of the\n// argument instead of a copy.\n// Return(ByMove()) actions can only be executed once and will assert this\n// invariant.\ntemplate <typename R>\ninternal::ByMoveWrapper<R> ByMove(R x) {\n  return internal::ByMoveWrapper<R>(internal::move(x));\n}\n\n// Creates an action that does the default action for the give mock function.\ninline internal::DoDefaultAction DoDefault() {\n  return internal::DoDefaultAction();\n}\n\n// Creates an action that sets the variable pointed by the N-th\n// (0-based) function argument to 'value'.\ntemplate <size_t N, typename T>\nPolymorphicAction<\n  internal::SetArgumentPointeeAction<\n    N, T, internal::IsAProtocolMessage<T>::value> >\nSetArgPointee(const T& x) {\n  return MakePolymorphicAction(internal::SetArgumentPointeeAction<\n      N, T, internal::IsAProtocolMessage<T>::value>(x));\n}\n\n#if !((GTEST_GCC_VER_ && GTEST_GCC_VER_ < 40000) || GTEST_OS_SYMBIAN)\n// This overload allows SetArgPointee() to accept a string literal.\n// GCC prior to the version 4.0 and Symbian C++ compiler cannot distinguish\n// this overload from the templated version and emit a compile error.\ntemplate <size_t N>\nPolymorphicAction<\n  internal::SetArgumentPointeeAction<N, const char*, false> >\nSetArgPointee(const char* p) {\n  return MakePolymorphicAction(internal::SetArgumentPointeeAction<\n      N, const char*, false>(p));\n}\n\ntemplate <size_t N>\nPolymorphicAction<\n  internal::SetArgumentPointeeAction<N, const wchar_t*, false> >\nSetArgPointee(const wchar_t* p) {\n  return MakePolymorphicAction(internal::SetArgumentPointeeAction<\n      N, const wchar_t*, false>(p));\n}\n#endif\n\n// The following version is DEPRECATED.\ntemplate <size_t N, typename T>\nPolymorphicAction<\n  internal::SetArgumentPointeeAction<\n    N, T, internal::IsAProtocolMessage<T>::value> >\nSetArgumentPointee(const T& x) {\n  return MakePolymorphicAction(internal::SetArgumentPointeeAction<\n      N, T, internal::IsAProtocolMessage<T>::value>(x));\n}\n\n// Creates an action that sets a pointer referent to a given value.\ntemplate <typename T1, typename T2>\nPolymorphicAction<internal::AssignAction<T1, T2> > Assign(T1* ptr, T2 val) {\n  return MakePolymorphicAction(internal::AssignAction<T1, T2>(ptr, val));\n}\n\n#if !GTEST_OS_WINDOWS_MOBILE\n\n// Creates an action that sets errno and returns the appropriate error.\ntemplate <typename T>\nPolymorphicAction<internal::SetErrnoAndReturnAction<T> >\nSetErrnoAndReturn(int errval, T result) {\n  return MakePolymorphicAction(\n      internal::SetErrnoAndReturnAction<T>(errval, result));\n}\n\n#endif  // !GTEST_OS_WINDOWS_MOBILE\n\n// Various overloads for InvokeWithoutArgs().\n\n// Creates an action that invokes 'function_impl' with no argument.\ntemplate <typename FunctionImpl>\nPolymorphicAction<internal::InvokeWithoutArgsAction<FunctionImpl> >\nInvokeWithoutArgs(FunctionImpl function_impl) {\n  return MakePolymorphicAction(\n      internal::InvokeWithoutArgsAction<FunctionImpl>(function_impl));\n}\n\n// Creates an action that invokes the given method on the given object\n// with no argument.\ntemplate <class Class, typename MethodPtr>\nPolymorphicAction<internal::InvokeMethodWithoutArgsAction<Class, MethodPtr> >\nInvokeWithoutArgs(Class* obj_ptr, MethodPtr method_ptr) {\n  return MakePolymorphicAction(\n      internal::InvokeMethodWithoutArgsAction<Class, MethodPtr>(\n          obj_ptr, method_ptr));\n}\n\n// Creates an action that performs an_action and throws away its\n// result.  In other words, it changes the return type of an_action to\n// void.  an_action MUST NOT return void, or the code won't compile.\ntemplate <typename A>\ninline internal::IgnoreResultAction<A> IgnoreResult(const A& an_action) {\n  return internal::IgnoreResultAction<A>(an_action);\n}\n\n// Creates a reference wrapper for the given L-value.  If necessary,\n// you can explicitly specify the type of the reference.  For example,\n// suppose 'derived' is an object of type Derived, ByRef(derived)\n// would wrap a Derived&.  If you want to wrap a const Base& instead,\n// where Base is a base class of Derived, just write:\n//\n//   ByRef<const Base>(derived)\ntemplate <typename T>\ninline internal::ReferenceWrapper<T> ByRef(T& l_value) {  // NOLINT\n  return internal::ReferenceWrapper<T>(l_value);\n}\n\n}  // namespace testing\n\n#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_ACTIONS_H_\n"}, "32": {"id": 32, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-cardinalities.h", "content": "// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n// Google Mock - a framework for writing C++ mock classes.\n//\n// This file implements some commonly used cardinalities.  More\n// cardinalities can be defined by the user implementing the\n// CardinalityInterface interface if necessary.\n\n// IWYU pragma: private, include \"gmock/gmock.h\"\n\n#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_CARDINALITIES_H_\n#define GMOCK_INCLUDE_GMOCK_GMOCK_CARDINALITIES_H_\n\n#include <limits.h>\n#include <ostream>  // NOLINT\n#include \"gmock/internal/gmock-port.h\"\n#include \"gtest/gtest.h\"\n\nnamespace testing {\n\n// To implement a cardinality Foo, define:\n//   1. a class FooCardinality that implements the\n//      CardinalityInterface interface, and\n//   2. a factory function that creates a Cardinality object from a\n//      const FooCardinality*.\n//\n// The two-level delegation design follows that of Matcher, providing\n// consistency for extension developers.  It also eases ownership\n// management as Cardinality objects can now be copied like plain values.\n\n// The implementation of a cardinality.\nclass CardinalityInterface {\n public:\n  virtual ~CardinalityInterface() {}\n\n  // Conservative estimate on the lower/upper bound of the number of\n  // calls allowed.\n  virtual int ConservativeLowerBound() const { return 0; }\n  virtual int ConservativeUpperBound() const { return INT_MAX; }\n\n  // Returns true iff call_count calls will satisfy this cardinality.\n  virtual bool IsSatisfiedByCallCount(int call_count) const = 0;\n\n  // Returns true iff call_count calls will saturate this cardinality.\n  virtual bool IsSaturatedByCallCount(int call_count) const = 0;\n\n  // Describes self to an ostream.\n  virtual void DescribeTo(::std::ostream* os) const = 0;\n};\n\n// A Cardinality is a copyable and IMMUTABLE (except by assignment)\n// object that specifies how many times a mock function is expected to\n// be called.  The implementation of Cardinality is just a linked_ptr\n// to const CardinalityInterface, so copying is fairly cheap.\n// Don't inherit from Cardinality!\nclass GTEST_API_ Cardinality {\n public:\n  // Constructs a null cardinality.  Needed for storing Cardinality\n  // objects in STL containers.\n  Cardinality() {}\n\n  // Constructs a Cardinality from its implementation.\n  explicit Cardinality(const CardinalityInterface* impl) : impl_(impl) {}\n\n  // Conservative estimate on the lower/upper bound of the number of\n  // calls allowed.\n  int ConservativeLowerBound() const { return impl_->ConservativeLowerBound(); }\n  int ConservativeUpperBound() const { return impl_->ConservativeUpperBound(); }\n\n  // Returns true iff call_count calls will satisfy this cardinality.\n  bool IsSatisfiedByCallCount(int call_count) const {\n    return impl_->IsSatisfiedByCallCount(call_count);\n  }\n\n  // Returns true iff call_count calls will saturate this cardinality.\n  bool IsSaturatedByCallCount(int call_count) const {\n    return impl_->IsSaturatedByCallCount(call_count);\n  }\n\n  // Returns true iff call_count calls will over-saturate this\n  // cardinality, i.e. exceed the maximum number of allowed calls.\n  bool IsOverSaturatedByCallCount(int call_count) const {\n    return impl_->IsSaturatedByCallCount(call_count) &&\n        !impl_->IsSatisfiedByCallCount(call_count);\n  }\n\n  // Describes self to an ostream\n  void DescribeTo(::std::ostream* os) const { impl_->DescribeTo(os); }\n\n  // Describes the given actual call count to an ostream.\n  static void DescribeActualCallCountTo(int actual_call_count,\n                                        ::std::ostream* os);\n\n private:\n  internal::linked_ptr<const CardinalityInterface> impl_;\n};\n\n// Creates a cardinality that allows at least n calls.\nGTEST_API_ Cardinality AtLeast(int n);\n\n// Creates a cardinality that allows at most n calls.\nGTEST_API_ Cardinality AtMost(int n);\n\n// Creates a cardinality that allows any number of calls.\nGTEST_API_ Cardinality AnyNumber();\n\n// Creates a cardinality that allows between min and max calls.\nGTEST_API_ Cardinality Between(int min, int max);\n\n// Creates a cardinality that allows exactly n calls.\nGTEST_API_ Cardinality Exactly(int n);\n\n// Creates a cardinality from its implementation.\ninline Cardinality MakeCardinality(const CardinalityInterface* c) {\n  return Cardinality(c);\n}\n\n}  // namespace testing\n\n#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_CARDINALITIES_H_\n"}, "33": {"id": 33, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-generated-actions.h", "content": "// This file was GENERATED by a script.  DO NOT EDIT BY HAND!!!\n\n// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n// Google Mock - a framework for writing C++ mock classes.\n//\n// This file implements some commonly used variadic actions.\n\n// IWYU pragma: private, include \"gmock/gmock.h\"\n\n#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_ACTIONS_H_\n#define GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_ACTIONS_H_\n\n#include \"gmock/gmock-actions.h\"\n#include \"gmock/internal/gmock-port.h\"\n\nnamespace testing {\nnamespace internal {\n\n// InvokeHelper<F> knows how to unpack an N-tuple and invoke an N-ary\n// function or method with the unpacked values, where F is a function\n// type that takes N arguments.\ntemplate <typename Result, typename ArgumentTuple>\nclass InvokeHelper;\n\ntemplate <typename R>\nclass InvokeHelper<R, ::testing::tuple<> > {\n public:\n  template <typename Function>\n  static R Invoke(Function function, const ::testing::tuple<>&) {\n           return function();\n  }\n\n  template <class Class, typename MethodPtr>\n  static R InvokeMethod(Class* obj_ptr,\n                        MethodPtr method_ptr,\n                        const ::testing::tuple<>&) {\n           return (obj_ptr->*method_ptr)();\n  }\n};\n\ntemplate <typename R, typename A1>\nclass InvokeHelper<R, ::testing::tuple<A1> > {\n public:\n  template <typename Function>\n  static R Invoke(Function function, const ::testing::tuple<A1>& args) {\n           return function(get<0>(args));\n  }\n\n  template <class Class, typename MethodPtr>\n  static R InvokeMethod(Class* obj_ptr,\n                        MethodPtr method_ptr,\n                        const ::testing::tuple<A1>& args) {\n           return (obj_ptr->*method_ptr)(get<0>(args));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2>\nclass InvokeHelper<R, ::testing::tuple<A1, A2> > {\n public:\n  template <typename Function>\n  static R Invoke(Function function, const ::testing::tuple<A1, A2>& args) {\n           return function(get<0>(args), get<1>(args));\n  }\n\n  template <class Class, typename MethodPtr>\n  static R InvokeMethod(Class* obj_ptr,\n                        MethodPtr method_ptr,\n                        const ::testing::tuple<A1, A2>& args) {\n           return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3>\nclass InvokeHelper<R, ::testing::tuple<A1, A2, A3> > {\n public:\n  template <typename Function>\n  static R Invoke(Function function, const ::testing::tuple<A1, A2, A3>& args) {\n           return function(get<0>(args), get<1>(args), get<2>(args));\n  }\n\n  template <class Class, typename MethodPtr>\n  static R InvokeMethod(Class* obj_ptr,\n                        MethodPtr method_ptr,\n                        const ::testing::tuple<A1, A2, A3>& args) {\n           return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args),\n               get<2>(args));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4>\nclass InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4> > {\n public:\n  template <typename Function>\n  static R Invoke(Function function, const ::testing::tuple<A1, A2, A3,\n      A4>& args) {\n           return function(get<0>(args), get<1>(args), get<2>(args),\n               get<3>(args));\n  }\n\n  template <class Class, typename MethodPtr>\n  static R InvokeMethod(Class* obj_ptr,\n                        MethodPtr method_ptr,\n                        const ::testing::tuple<A1, A2, A3, A4>& args) {\n           return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args),\n               get<2>(args), get<3>(args));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5>\nclass InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4, A5> > {\n public:\n  template <typename Function>\n  static R Invoke(Function function, const ::testing::tuple<A1, A2, A3, A4,\n      A5>& args) {\n           return function(get<0>(args), get<1>(args), get<2>(args),\n               get<3>(args), get<4>(args));\n  }\n\n  template <class Class, typename MethodPtr>\n  static R InvokeMethod(Class* obj_ptr,\n                        MethodPtr method_ptr,\n                        const ::testing::tuple<A1, A2, A3, A4, A5>& args) {\n           return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args),\n               get<2>(args), get<3>(args), get<4>(args));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5, typename A6>\nclass InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4, A5, A6> > {\n public:\n  template <typename Function>\n  static R Invoke(Function function, const ::testing::tuple<A1, A2, A3, A4, A5,\n      A6>& args) {\n           return function(get<0>(args), get<1>(args), get<2>(args),\n               get<3>(args), get<4>(args), get<5>(args));\n  }\n\n  template <class Class, typename MethodPtr>\n  static R InvokeMethod(Class* obj_ptr,\n                        MethodPtr method_ptr,\n                        const ::testing::tuple<A1, A2, A3, A4, A5, A6>& args) {\n           return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args),\n               get<2>(args), get<3>(args), get<4>(args), get<5>(args));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5, typename A6, typename A7>\nclass InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4, A5, A6, A7> > {\n public:\n  template <typename Function>\n  static R Invoke(Function function, const ::testing::tuple<A1, A2, A3, A4, A5,\n      A6, A7>& args) {\n           return function(get<0>(args), get<1>(args), get<2>(args),\n               get<3>(args), get<4>(args), get<5>(args), get<6>(args));\n  }\n\n  template <class Class, typename MethodPtr>\n  static R InvokeMethod(Class* obj_ptr,\n                        MethodPtr method_ptr,\n                        const ::testing::tuple<A1, A2, A3, A4, A5, A6,\n                            A7>& args) {\n           return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args),\n               get<2>(args), get<3>(args), get<4>(args), get<5>(args),\n               get<6>(args));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5, typename A6, typename A7, typename A8>\nclass InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8> > {\n public:\n  template <typename Function>\n  static R Invoke(Function function, const ::testing::tuple<A1, A2, A3, A4, A5,\n      A6, A7, A8>& args) {\n           return function(get<0>(args), get<1>(args), get<2>(args),\n               get<3>(args), get<4>(args), get<5>(args), get<6>(args),\n               get<7>(args));\n  }\n\n  template <class Class, typename MethodPtr>\n  static R InvokeMethod(Class* obj_ptr,\n                        MethodPtr method_ptr,\n                        const ::testing::tuple<A1, A2, A3, A4, A5, A6, A7,\n                            A8>& args) {\n           return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args),\n               get<2>(args), get<3>(args), get<4>(args), get<5>(args),\n               get<6>(args), get<7>(args));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5, typename A6, typename A7, typename A8, typename A9>\nclass InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8, A9> > {\n public:\n  template <typename Function>\n  static R Invoke(Function function, const ::testing::tuple<A1, A2, A3, A4, A5,\n      A6, A7, A8, A9>& args) {\n           return function(get<0>(args), get<1>(args), get<2>(args),\n               get<3>(args), get<4>(args), get<5>(args), get<6>(args),\n               get<7>(args), get<8>(args));\n  }\n\n  template <class Class, typename MethodPtr>\n  static R InvokeMethod(Class* obj_ptr,\n                        MethodPtr method_ptr,\n                        const ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8,\n                            A9>& args) {\n           return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args),\n               get<2>(args), get<3>(args), get<4>(args), get<5>(args),\n               get<6>(args), get<7>(args), get<8>(args));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5, typename A6, typename A7, typename A8, typename A9,\n    typename A10>\nclass InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8, A9,\n    A10> > {\n public:\n  template <typename Function>\n  static R Invoke(Function function, const ::testing::tuple<A1, A2, A3, A4, A5,\n      A6, A7, A8, A9, A10>& args) {\n           return function(get<0>(args), get<1>(args), get<2>(args),\n               get<3>(args), get<4>(args), get<5>(args), get<6>(args),\n               get<7>(args), get<8>(args), get<9>(args));\n  }\n\n  template <class Class, typename MethodPtr>\n  static R InvokeMethod(Class* obj_ptr,\n                        MethodPtr method_ptr,\n                        const ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8,\n                            A9, A10>& args) {\n           return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args),\n               get<2>(args), get<3>(args), get<4>(args), get<5>(args),\n               get<6>(args), get<7>(args), get<8>(args), get<9>(args));\n  }\n};\n\n// An INTERNAL macro for extracting the type of a tuple field.  It's\n// subject to change without notice - DO NOT USE IN USER CODE!\n#define GMOCK_FIELD_(Tuple, N) \\\n    typename ::testing::tuple_element<N, Tuple>::type\n\n// SelectArgs<Result, ArgumentTuple, k1, k2, ..., k_n>::type is the\n// type of an n-ary function whose i-th (1-based) argument type is the\n// k{i}-th (0-based) field of ArgumentTuple, which must be a tuple\n// type, and whose return type is Result.  For example,\n//   SelectArgs<int, ::testing::tuple<bool, char, double, long>, 0, 3>::type\n// is int(bool, long).\n//\n// SelectArgs<Result, ArgumentTuple, k1, k2, ..., k_n>::Select(args)\n// returns the selected fields (k1, k2, ..., k_n) of args as a tuple.\n// For example,\n//   SelectArgs<int, tuple<bool, char, double>, 2, 0>::Select(\n//       ::testing::make_tuple(true, 'a', 2.5))\n// returns tuple (2.5, true).\n//\n// The numbers in list k1, k2, ..., k_n must be >= 0, where n can be\n// in the range [0, 10].  Duplicates are allowed and they don't have\n// to be in an ascending or descending order.\n\ntemplate <typename Result, typename ArgumentTuple, int k1, int k2, int k3,\n    int k4, int k5, int k6, int k7, int k8, int k9, int k10>\nclass SelectArgs {\n public:\n  typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),\n      GMOCK_FIELD_(ArgumentTuple, k2), GMOCK_FIELD_(ArgumentTuple, k3),\n      GMOCK_FIELD_(ArgumentTuple, k4), GMOCK_FIELD_(ArgumentTuple, k5),\n      GMOCK_FIELD_(ArgumentTuple, k6), GMOCK_FIELD_(ArgumentTuple, k7),\n      GMOCK_FIELD_(ArgumentTuple, k8), GMOCK_FIELD_(ArgumentTuple, k9),\n      GMOCK_FIELD_(ArgumentTuple, k10));\n  typedef typename Function<type>::ArgumentTuple SelectedArgs;\n  static SelectedArgs Select(const ArgumentTuple& args) {\n    return SelectedArgs(get<k1>(args), get<k2>(args), get<k3>(args),\n        get<k4>(args), get<k5>(args), get<k6>(args), get<k7>(args),\n        get<k8>(args), get<k9>(args), get<k10>(args));\n  }\n};\n\ntemplate <typename Result, typename ArgumentTuple>\nclass SelectArgs<Result, ArgumentTuple,\n                 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1> {\n public:\n  typedef Result type();\n  typedef typename Function<type>::ArgumentTuple SelectedArgs;\n  static SelectedArgs Select(const ArgumentTuple& /* args */) {\n    return SelectedArgs();\n  }\n};\n\ntemplate <typename Result, typename ArgumentTuple, int k1>\nclass SelectArgs<Result, ArgumentTuple,\n                 k1, -1, -1, -1, -1, -1, -1, -1, -1, -1> {\n public:\n  typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1));\n  typedef typename Function<type>::ArgumentTuple SelectedArgs;\n  static SelectedArgs Select(const ArgumentTuple& args) {\n    return SelectedArgs(get<k1>(args));\n  }\n};\n\ntemplate <typename Result, typename ArgumentTuple, int k1, int k2>\nclass SelectArgs<Result, ArgumentTuple,\n                 k1, k2, -1, -1, -1, -1, -1, -1, -1, -1> {\n public:\n  typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),\n      GMOCK_FIELD_(ArgumentTuple, k2));\n  typedef typename Function<type>::ArgumentTuple SelectedArgs;\n  static SelectedArgs Select(const ArgumentTuple& args) {\n    return SelectedArgs(get<k1>(args), get<k2>(args));\n  }\n};\n\ntemplate <typename Result, typename ArgumentTuple, int k1, int k2, int k3>\nclass SelectArgs<Result, ArgumentTuple,\n                 k1, k2, k3, -1, -1, -1, -1, -1, -1, -1> {\n public:\n  typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),\n      GMOCK_FIELD_(ArgumentTuple, k2), GMOCK_FIELD_(ArgumentTuple, k3));\n  typedef typename Function<type>::ArgumentTuple SelectedArgs;\n  static SelectedArgs Select(const ArgumentTuple& args) {\n    return SelectedArgs(get<k1>(args), get<k2>(args), get<k3>(args));\n  }\n};\n\ntemplate <typename Result, typename ArgumentTuple, int k1, int k2, int k3,\n    int k4>\nclass SelectArgs<Result, ArgumentTuple,\n                 k1, k2, k3, k4, -1, -1, -1, -1, -1, -1> {\n public:\n  typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),\n      GMOCK_FIELD_(ArgumentTuple, k2), GMOCK_FIELD_(ArgumentTuple, k3),\n      GMOCK_FIELD_(ArgumentTuple, k4));\n  typedef typename Function<type>::ArgumentTuple SelectedArgs;\n  static SelectedArgs Select(const ArgumentTuple& args) {\n    return SelectedArgs(get<k1>(args), get<k2>(args), get<k3>(args),\n        get<k4>(args));\n  }\n};\n\ntemplate <typename Result, typename ArgumentTuple, int k1, int k2, int k3,\n    int k4, int k5>\nclass SelectArgs<Result, ArgumentTuple,\n                 k1, k2, k3, k4, k5, -1, -1, -1, -1, -1> {\n public:\n  typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),\n      GMOCK_FIELD_(ArgumentTuple, k2), GMOCK_FIELD_(ArgumentTuple, k3),\n      GMOCK_FIELD_(ArgumentTuple, k4), GMOCK_FIELD_(ArgumentTuple, k5));\n  typedef typename Function<type>::ArgumentTuple SelectedArgs;\n  static SelectedArgs Select(const ArgumentTuple& args) {\n    return SelectedArgs(get<k1>(args), get<k2>(args), get<k3>(args),\n        get<k4>(args), get<k5>(args));\n  }\n};\n\ntemplate <typename Result, typename ArgumentTuple, int k1, int k2, int k3,\n    int k4, int k5, int k6>\nclass SelectArgs<Result, ArgumentTuple,\n                 k1, k2, k3, k4, k5, k6, -1, -1, -1, -1> {\n public:\n  typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),\n      GMOCK_FIELD_(ArgumentTuple, k2), GMOCK_FIELD_(ArgumentTuple, k3),\n      GMOCK_FIELD_(ArgumentTuple, k4), GMOCK_FIELD_(ArgumentTuple, k5),\n      GMOCK_FIELD_(ArgumentTuple, k6));\n  typedef typename Function<type>::ArgumentTuple SelectedArgs;\n  static SelectedArgs Select(const ArgumentTuple& args) {\n    return SelectedArgs(get<k1>(args), get<k2>(args), get<k3>(args),\n        get<k4>(args), get<k5>(args), get<k6>(args));\n  }\n};\n\ntemplate <typename Result, typename ArgumentTuple, int k1, int k2, int k3,\n    int k4, int k5, int k6, int k7>\nclass SelectArgs<Result, ArgumentTuple,\n                 k1, k2, k3, k4, k5, k6, k7, -1, -1, -1> {\n public:\n  typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),\n      GMOCK_FIELD_(ArgumentTuple, k2), GMOCK_FIELD_(ArgumentTuple, k3),\n      GMOCK_FIELD_(ArgumentTuple, k4), GMOCK_FIELD_(ArgumentTuple, k5),\n      GMOCK_FIELD_(ArgumentTuple, k6), GMOCK_FIELD_(ArgumentTuple, k7));\n  typedef typename Function<type>::ArgumentTuple SelectedArgs;\n  static SelectedArgs Select(const ArgumentTuple& args) {\n    return SelectedArgs(get<k1>(args), get<k2>(args), get<k3>(args),\n        get<k4>(args), get<k5>(args), get<k6>(args), get<k7>(args));\n  }\n};\n\ntemplate <typename Result, typename ArgumentTuple, int k1, int k2, int k3,\n    int k4, int k5, int k6, int k7, int k8>\nclass SelectArgs<Result, ArgumentTuple,\n                 k1, k2, k3, k4, k5, k6, k7, k8, -1, -1> {\n public:\n  typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),\n      GMOCK_FIELD_(ArgumentTuple, k2), GMOCK_FIELD_(ArgumentTuple, k3),\n      GMOCK_FIELD_(ArgumentTuple, k4), GMOCK_FIELD_(ArgumentTuple, k5),\n      GMOCK_FIELD_(ArgumentTuple, k6), GMOCK_FIELD_(ArgumentTuple, k7),\n      GMOCK_FIELD_(ArgumentTuple, k8));\n  typedef typename Function<type>::ArgumentTuple SelectedArgs;\n  static SelectedArgs Select(const ArgumentTuple& args) {\n    return SelectedArgs(get<k1>(args), get<k2>(args), get<k3>(args),\n        get<k4>(args), get<k5>(args), get<k6>(args), get<k7>(args),\n        get<k8>(args));\n  }\n};\n\ntemplate <typename Result, typename ArgumentTuple, int k1, int k2, int k3,\n    int k4, int k5, int k6, int k7, int k8, int k9>\nclass SelectArgs<Result, ArgumentTuple,\n                 k1, k2, k3, k4, k5, k6, k7, k8, k9, -1> {\n public:\n  typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),\n      GMOCK_FIELD_(ArgumentTuple, k2), GMOCK_FIELD_(ArgumentTuple, k3),\n      GMOCK_FIELD_(ArgumentTuple, k4), GMOCK_FIELD_(ArgumentTuple, k5),\n      GMOCK_FIELD_(ArgumentTuple, k6), GMOCK_FIELD_(ArgumentTuple, k7),\n      GMOCK_FIELD_(ArgumentTuple, k8), GMOCK_FIELD_(ArgumentTuple, k9));\n  typedef typename Function<type>::ArgumentTuple SelectedArgs;\n  static SelectedArgs Select(const ArgumentTuple& args) {\n    return SelectedArgs(get<k1>(args), get<k2>(args), get<k3>(args),\n        get<k4>(args), get<k5>(args), get<k6>(args), get<k7>(args),\n        get<k8>(args), get<k9>(args));\n  }\n};\n\n#undef GMOCK_FIELD_\n\n// Implements the WithArgs action.\ntemplate <typename InnerAction, int k1 = -1, int k2 = -1, int k3 = -1,\n    int k4 = -1, int k5 = -1, int k6 = -1, int k7 = -1, int k8 = -1,\n    int k9 = -1, int k10 = -1>\nclass WithArgsAction {\n public:\n  explicit WithArgsAction(const InnerAction& action) : action_(action) {}\n\n  template <typename F>\n  operator Action<F>() const { return MakeAction(new Impl<F>(action_)); }\n\n private:\n  template <typename F>\n  class Impl : public ActionInterface<F> {\n   public:\n    typedef typename Function<F>::Result Result;\n    typedef typename Function<F>::ArgumentTuple ArgumentTuple;\n\n    explicit Impl(const InnerAction& action) : action_(action) {}\n\n    virtual Result Perform(const ArgumentTuple& args) {\n      return action_.Perform(SelectArgs<Result, ArgumentTuple, k1, k2, k3, k4,\n          k5, k6, k7, k8, k9, k10>::Select(args));\n    }\n\n   private:\n    typedef typename SelectArgs<Result, ArgumentTuple,\n        k1, k2, k3, k4, k5, k6, k7, k8, k9, k10>::type InnerFunctionType;\n\n    Action<InnerFunctionType> action_;\n  };\n\n  const InnerAction action_;\n\n  GTEST_DISALLOW_ASSIGN_(WithArgsAction);\n};\n\n// A macro from the ACTION* family (defined later in this file)\n// defines an action that can be used in a mock function.  Typically,\n// these actions only care about a subset of the arguments of the mock\n// function.  For example, if such an action only uses the second\n// argument, it can be used in any mock function that takes >= 2\n// arguments where the type of the second argument is compatible.\n//\n// Therefore, the action implementation must be prepared to take more\n// arguments than it needs.  The ExcessiveArg type is used to\n// represent those excessive arguments.  In order to keep the compiler\n// error messages tractable, we define it in the testing namespace\n// instead of testing::internal.  However, this is an INTERNAL TYPE\n// and subject to change without notice, so a user MUST NOT USE THIS\n// TYPE DIRECTLY.\nstruct ExcessiveArg {};\n\n// A helper class needed for implementing the ACTION* macros.\ntemplate <typename Result, class Impl>\nclass ActionHelper {\n public:\n  static Result Perform(Impl* impl, const ::testing::tuple<>& args) {\n    return impl->template gmock_PerformImpl<>(args, ExcessiveArg(),\n        ExcessiveArg(), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg(), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg());\n  }\n\n  template <typename A0>\n  static Result Perform(Impl* impl, const ::testing::tuple<A0>& args) {\n    return impl->template gmock_PerformImpl<A0>(args, get<0>(args),\n        ExcessiveArg(), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg(), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg());\n  }\n\n  template <typename A0, typename A1>\n  static Result Perform(Impl* impl, const ::testing::tuple<A0, A1>& args) {\n    return impl->template gmock_PerformImpl<A0, A1>(args, get<0>(args),\n        get<1>(args), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg(), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg());\n  }\n\n  template <typename A0, typename A1, typename A2>\n  static Result Perform(Impl* impl, const ::testing::tuple<A0, A1, A2>& args) {\n    return impl->template gmock_PerformImpl<A0, A1, A2>(args, get<0>(args),\n        get<1>(args), get<2>(args), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg(), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg());\n  }\n\n  template <typename A0, typename A1, typename A2, typename A3>\n  static Result Perform(Impl* impl, const ::testing::tuple<A0, A1, A2,\n      A3>& args) {\n    return impl->template gmock_PerformImpl<A0, A1, A2, A3>(args, get<0>(args),\n        get<1>(args), get<2>(args), get<3>(args), ExcessiveArg(),\n        ExcessiveArg(), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg());\n  }\n\n  template <typename A0, typename A1, typename A2, typename A3, typename A4>\n  static Result Perform(Impl* impl, const ::testing::tuple<A0, A1, A2, A3,\n      A4>& args) {\n    return impl->template gmock_PerformImpl<A0, A1, A2, A3, A4>(args,\n        get<0>(args), get<1>(args), get<2>(args), get<3>(args), get<4>(args),\n        ExcessiveArg(), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg());\n  }\n\n  template <typename A0, typename A1, typename A2, typename A3, typename A4,\n      typename A5>\n  static Result Perform(Impl* impl, const ::testing::tuple<A0, A1, A2, A3, A4,\n      A5>& args) {\n    return impl->template gmock_PerformImpl<A0, A1, A2, A3, A4, A5>(args,\n        get<0>(args), get<1>(args), get<2>(args), get<3>(args), get<4>(args),\n        get<5>(args), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg());\n  }\n\n  template <typename A0, typename A1, typename A2, typename A3, typename A4,\n      typename A5, typename A6>\n  static Result Perform(Impl* impl, const ::testing::tuple<A0, A1, A2, A3, A4,\n      A5, A6>& args) {\n    return impl->template gmock_PerformImpl<A0, A1, A2, A3, A4, A5, A6>(args,\n        get<0>(args), get<1>(args), get<2>(args), get<3>(args), get<4>(args),\n        get<5>(args), get<6>(args), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg());\n  }\n\n  template <typename A0, typename A1, typename A2, typename A3, typename A4,\n      typename A5, typename A6, typename A7>\n  static Result Perform(Impl* impl, const ::testing::tuple<A0, A1, A2, A3, A4,\n      A5, A6, A7>& args) {\n    return impl->template gmock_PerformImpl<A0, A1, A2, A3, A4, A5, A6,\n        A7>(args, get<0>(args), get<1>(args), get<2>(args), get<3>(args),\n        get<4>(args), get<5>(args), get<6>(args), get<7>(args), ExcessiveArg(),\n        ExcessiveArg());\n  }\n\n  template <typename A0, typename A1, typename A2, typename A3, typename A4,\n      typename A5, typename A6, typename A7, typename A8>\n  static Result Perform(Impl* impl, const ::testing::tuple<A0, A1, A2, A3, A4,\n      A5, A6, A7, A8>& args) {\n    return impl->template gmock_PerformImpl<A0, A1, A2, A3, A4, A5, A6, A7,\n        A8>(args, get<0>(args), get<1>(args), get<2>(args), get<3>(args),\n        get<4>(args), get<5>(args), get<6>(args), get<7>(args), get<8>(args),\n        ExcessiveArg());\n  }\n\n  template <typename A0, typename A1, typename A2, typename A3, typename A4,\n      typename A5, typename A6, typename A7, typename A8, typename A9>\n  static Result Perform(Impl* impl, const ::testing::tuple<A0, A1, A2, A3, A4,\n      A5, A6, A7, A8, A9>& args) {\n    return impl->template gmock_PerformImpl<A0, A1, A2, A3, A4, A5, A6, A7, A8,\n        A9>(args, get<0>(args), get<1>(args), get<2>(args), get<3>(args),\n        get<4>(args), get<5>(args), get<6>(args), get<7>(args), get<8>(args),\n        get<9>(args));\n  }\n};\n\n}  // namespace internal\n\n// Various overloads for Invoke().\n\n// WithArgs<N1, N2, ..., Nk>(an_action) creates an action that passes\n// the selected arguments of the mock function to an_action and\n// performs it.  It serves as an adaptor between actions with\n// different argument lists.  C++ doesn't support default arguments for\n// function templates, so we have to overload it.\ntemplate <int k1, typename InnerAction>\ninline internal::WithArgsAction<InnerAction, k1>\nWithArgs(const InnerAction& action) {\n  return internal::WithArgsAction<InnerAction, k1>(action);\n}\n\ntemplate <int k1, int k2, typename InnerAction>\ninline internal::WithArgsAction<InnerAction, k1, k2>\nWithArgs(const InnerAction& action) {\n  return internal::WithArgsAction<InnerAction, k1, k2>(action);\n}\n\ntemplate <int k1, int k2, int k3, typename InnerAction>\ninline internal::WithArgsAction<InnerAction, k1, k2, k3>\nWithArgs(const InnerAction& action) {\n  return internal::WithArgsAction<InnerAction, k1, k2, k3>(action);\n}\n\ntemplate <int k1, int k2, int k3, int k4, typename InnerAction>\ninline internal::WithArgsAction<InnerAction, k1, k2, k3, k4>\nWithArgs(const InnerAction& action) {\n  return internal::WithArgsAction<InnerAction, k1, k2, k3, k4>(action);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, typename InnerAction>\ninline internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5>\nWithArgs(const InnerAction& action) {\n  return internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5>(action);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, int k6, typename InnerAction>\ninline internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6>\nWithArgs(const InnerAction& action) {\n  return internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6>(action);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, int k6, int k7,\n    typename InnerAction>\ninline internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6, k7>\nWithArgs(const InnerAction& action) {\n  return internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6,\n      k7>(action);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, int k6, int k7, int k8,\n    typename InnerAction>\ninline internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6, k7, k8>\nWithArgs(const InnerAction& action) {\n  return internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6, k7,\n      k8>(action);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, int k6, int k7, int k8,\n    int k9, typename InnerAction>\ninline internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6, k7, k8, k9>\nWithArgs(const InnerAction& action) {\n  return internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6, k7, k8,\n      k9>(action);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, int k6, int k7, int k8,\n    int k9, int k10, typename InnerAction>\ninline internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6, k7, k8,\n    k9, k10>\nWithArgs(const InnerAction& action) {\n  return internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6, k7, k8,\n      k9, k10>(action);\n}\n\n// Creates an action that does actions a1, a2, ..., sequentially in\n// each invocation.\ntemplate <typename Action1, typename Action2>\ninline internal::DoBothAction<Action1, Action2>\nDoAll(Action1 a1, Action2 a2) {\n  return internal::DoBothAction<Action1, Action2>(a1, a2);\n}\n\ntemplate <typename Action1, typename Action2, typename Action3>\ninline internal::DoBothAction<Action1, internal::DoBothAction<Action2,\n    Action3> >\nDoAll(Action1 a1, Action2 a2, Action3 a3) {\n  return DoAll(a1, DoAll(a2, a3));\n}\n\ntemplate <typename Action1, typename Action2, typename Action3,\n    typename Action4>\ninline internal::DoBothAction<Action1, internal::DoBothAction<Action2,\n    internal::DoBothAction<Action3, Action4> > >\nDoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4) {\n  return DoAll(a1, DoAll(a2, a3, a4));\n}\n\ntemplate <typename Action1, typename Action2, typename Action3,\n    typename Action4, typename Action5>\ninline internal::DoBothAction<Action1, internal::DoBothAction<Action2,\n    internal::DoBothAction<Action3, internal::DoBothAction<Action4,\n    Action5> > > >\nDoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4, Action5 a5) {\n  return DoAll(a1, DoAll(a2, a3, a4, a5));\n}\n\ntemplate <typename Action1, typename Action2, typename Action3,\n    typename Action4, typename Action5, typename Action6>\ninline internal::DoBothAction<Action1, internal::DoBothAction<Action2,\n    internal::DoBothAction<Action3, internal::DoBothAction<Action4,\n    internal::DoBothAction<Action5, Action6> > > > >\nDoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4, Action5 a5, Action6 a6) {\n  return DoAll(a1, DoAll(a2, a3, a4, a5, a6));\n}\n\ntemplate <typename Action1, typename Action2, typename Action3,\n    typename Action4, typename Action5, typename Action6, typename Action7>\ninline internal::DoBothAction<Action1, internal::DoBothAction<Action2,\n    internal::DoBothAction<Action3, internal::DoBothAction<Action4,\n    internal::DoBothAction<Action5, internal::DoBothAction<Action6,\n    Action7> > > > > >\nDoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4, Action5 a5, Action6 a6,\n    Action7 a7) {\n  return DoAll(a1, DoAll(a2, a3, a4, a5, a6, a7));\n}\n\ntemplate <typename Action1, typename Action2, typename Action3,\n    typename Action4, typename Action5, typename Action6, typename Action7,\n    typename Action8>\ninline internal::DoBothAction<Action1, internal::DoBothAction<Action2,\n    internal::DoBothAction<Action3, internal::DoBothAction<Action4,\n    internal::DoBothAction<Action5, internal::DoBothAction<Action6,\n    internal::DoBothAction<Action7, Action8> > > > > > >\nDoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4, Action5 a5, Action6 a6,\n    Action7 a7, Action8 a8) {\n  return DoAll(a1, DoAll(a2, a3, a4, a5, a6, a7, a8));\n}\n\ntemplate <typename Action1, typename Action2, typename Action3,\n    typename Action4, typename Action5, typename Action6, typename Action7,\n    typename Action8, typename Action9>\ninline internal::DoBothAction<Action1, internal::DoBothAction<Action2,\n    internal::DoBothAction<Action3, internal::DoBothAction<Action4,\n    internal::DoBothAction<Action5, internal::DoBothAction<Action6,\n    internal::DoBothAction<Action7, internal::DoBothAction<Action8,\n    Action9> > > > > > > >\nDoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4, Action5 a5, Action6 a6,\n    Action7 a7, Action8 a8, Action9 a9) {\n  return DoAll(a1, DoAll(a2, a3, a4, a5, a6, a7, a8, a9));\n}\n\ntemplate <typename Action1, typename Action2, typename Action3,\n    typename Action4, typename Action5, typename Action6, typename Action7,\n    typename Action8, typename Action9, typename Action10>\ninline internal::DoBothAction<Action1, internal::DoBothAction<Action2,\n    internal::DoBothAction<Action3, internal::DoBothAction<Action4,\n    internal::DoBothAction<Action5, internal::DoBothAction<Action6,\n    internal::DoBothAction<Action7, internal::DoBothAction<Action8,\n    internal::DoBothAction<Action9, Action10> > > > > > > > >\nDoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4, Action5 a5, Action6 a6,\n    Action7 a7, Action8 a8, Action9 a9, Action10 a10) {\n  return DoAll(a1, DoAll(a2, a3, a4, a5, a6, a7, a8, a9, a10));\n}\n\n}  // namespace testing\n\n// The ACTION* family of macros can be used in a namespace scope to\n// define custom actions easily.  The syntax:\n//\n//   ACTION(name) { statements; }\n//\n// will define an action with the given name that executes the\n// statements.  The value returned by the statements will be used as\n// the return value of the action.  Inside the statements, you can\n// refer to the K-th (0-based) argument of the mock function by\n// 'argK', and refer to its type by 'argK_type'.  For example:\n//\n//   ACTION(IncrementArg1) {\n//     arg1_type temp = arg1;\n//     return ++(*temp);\n//   }\n//\n// allows you to write\n//\n//   ...WillOnce(IncrementArg1());\n//\n// You can also refer to the entire argument tuple and its type by\n// 'args' and 'args_type', and refer to the mock function type and its\n// return type by 'function_type' and 'return_type'.\n//\n// Note that you don't need to specify the types of the mock function\n// arguments.  However rest assured that your code is still type-safe:\n// you'll get a compiler error if *arg1 doesn't support the ++\n// operator, or if the type of ++(*arg1) isn't compatible with the\n// mock function's return type, for example.\n//\n// Sometimes you'll want to parameterize the action.   For that you can use\n// another macro:\n//\n//   ACTION_P(name, param_name) { statements; }\n//\n// For example:\n//\n//   ACTION_P(Add, n) { return arg0 + n; }\n//\n// will allow you to write:\n//\n//   ...WillOnce(Add(5));\n//\n// Note that you don't need to provide the type of the parameter\n// either.  If you need to reference the type of a parameter named\n// 'foo', you can write 'foo_type'.  For example, in the body of\n// ACTION_P(Add, n) above, you can write 'n_type' to refer to the type\n// of 'n'.\n//\n// We also provide ACTION_P2, ACTION_P3, ..., up to ACTION_P10 to support\n// multi-parameter actions.\n//\n// For the purpose of typing, you can view\n//\n//   ACTION_Pk(Foo, p1, ..., pk) { ... }\n//\n// as shorthand for\n//\n//   template <typename p1_type, ..., typename pk_type>\n//   FooActionPk<p1_type, ..., pk_type> Foo(p1_type p1, ..., pk_type pk) { ... }\n//\n// In particular, you can provide the template type arguments\n// explicitly when invoking Foo(), as in Foo<long, bool>(5, false);\n// although usually you can rely on the compiler to infer the types\n// for you automatically.  You can assign the result of expression\n// Foo(p1, ..., pk) to a variable of type FooActionPk<p1_type, ...,\n// pk_type>.  This can be useful when composing actions.\n//\n// You can also overload actions with different numbers of parameters:\n//\n//   ACTION_P(Plus, a) { ... }\n//   ACTION_P2(Plus, a, b) { ... }\n//\n// While it's tempting to always use the ACTION* macros when defining\n// a new action, you should also consider implementing ActionInterface\n// or using MakePolymorphicAction() instead, especially if you need to\n// use the action a lot.  While these approaches require more work,\n// they give you more control on the types of the mock function\n// arguments and the action parameters, which in general leads to\n// better compiler error messages that pay off in the long run.  They\n// also allow overloading actions based on parameter types (as opposed\n// to just based on the number of parameters).\n//\n// CAVEAT:\n//\n// ACTION*() can only be used in a namespace scope.  The reason is\n// that C++ doesn't yet allow function-local types to be used to\n// instantiate templates.  The up-coming C++0x standard will fix this.\n// Once that's done, we'll consider supporting using ACTION*() inside\n// a function.\n//\n// MORE INFORMATION:\n//\n// To learn more about using these macros, please search for 'ACTION'\n// on http://code.google.com/p/googlemock/wiki/CookBook.\n\n// An internal macro needed for implementing ACTION*().\n#define GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_\\\n    const args_type& args GTEST_ATTRIBUTE_UNUSED_, \\\n    arg0_type arg0 GTEST_ATTRIBUTE_UNUSED_, \\\n    arg1_type arg1 GTEST_ATTRIBUTE_UNUSED_, \\\n    arg2_type arg2 GTEST_ATTRIBUTE_UNUSED_, \\\n    arg3_type arg3 GTEST_ATTRIBUTE_UNUSED_, \\\n    arg4_type arg4 GTEST_ATTRIBUTE_UNUSED_, \\\n    arg5_type arg5 GTEST_ATTRIBUTE_UNUSED_, \\\n    arg6_type arg6 GTEST_ATTRIBUTE_UNUSED_, \\\n    arg7_type arg7 GTEST_ATTRIBUTE_UNUSED_, \\\n    arg8_type arg8 GTEST_ATTRIBUTE_UNUSED_, \\\n    arg9_type arg9 GTEST_ATTRIBUTE_UNUSED_\n\n// Sometimes you want to give an action explicit template parameters\n// that cannot be inferred from its value parameters.  ACTION() and\n// ACTION_P*() don't support that.  ACTION_TEMPLATE() remedies that\n// and can be viewed as an extension to ACTION() and ACTION_P*().\n//\n// The syntax:\n//\n//   ACTION_TEMPLATE(ActionName,\n//                   HAS_m_TEMPLATE_PARAMS(kind1, name1, ..., kind_m, name_m),\n//                   AND_n_VALUE_PARAMS(p1, ..., p_n)) { statements; }\n//\n// defines an action template that takes m explicit template\n// parameters and n value parameters.  name_i is the name of the i-th\n// template parameter, and kind_i specifies whether it's a typename,\n// an integral constant, or a template.  p_i is the name of the i-th\n// value parameter.\n//\n// Example:\n//\n//   // DuplicateArg<k, T>(output) converts the k-th argument of the mock\n//   // function to type T and copies it to *output.\n//   ACTION_TEMPLATE(DuplicateArg,\n//                   HAS_2_TEMPLATE_PARAMS(int, k, typename, T),\n//                   AND_1_VALUE_PARAMS(output)) {\n//     *output = T(::testing::get<k>(args));\n//   }\n//   ...\n//     int n;\n//     EXPECT_CALL(mock, Foo(_, _))\n//         .WillOnce(DuplicateArg<1, unsigned char>(&n));\n//\n// To create an instance of an action template, write:\n//\n//   ActionName<t1, ..., t_m>(v1, ..., v_n)\n//\n// where the ts are the template arguments and the vs are the value\n// arguments.  The value argument types are inferred by the compiler.\n// If you want to explicitly specify the value argument types, you can\n// provide additional template arguments:\n//\n//   ActionName<t1, ..., t_m, u1, ..., u_k>(v1, ..., v_n)\n//\n// where u_i is the desired type of v_i.\n//\n// ACTION_TEMPLATE and ACTION/ACTION_P* can be overloaded on the\n// number of value parameters, but not on the number of template\n// parameters.  Without the restriction, the meaning of the following\n// is unclear:\n//\n//   OverloadedAction<int, bool>(x);\n//\n// Are we using a single-template-parameter action where 'bool' refers\n// to the type of x, or are we using a two-template-parameter action\n// where the compiler is asked to infer the type of x?\n//\n// Implementation notes:\n//\n// GMOCK_INTERNAL_*_HAS_m_TEMPLATE_PARAMS and\n// GMOCK_INTERNAL_*_AND_n_VALUE_PARAMS are internal macros for\n// implementing ACTION_TEMPLATE.  The main trick we use is to create\n// new macro invocations when expanding a macro.  For example, we have\n//\n//   #define ACTION_TEMPLATE(name, template_params, value_params)\n//       ... GMOCK_INTERNAL_DECL_##template_params ...\n//\n// which causes ACTION_TEMPLATE(..., HAS_1_TEMPLATE_PARAMS(typename, T), ...)\n// to expand to\n//\n//       ... GMOCK_INTERNAL_DECL_HAS_1_TEMPLATE_PARAMS(typename, T) ...\n//\n// Since GMOCK_INTERNAL_DECL_HAS_1_TEMPLATE_PARAMS is a macro, the\n// preprocessor will continue to expand it to\n//\n//       ... typename T ...\n//\n// This technique conforms to the C++ standard and is portable.  It\n// allows us to implement action templates using O(N) code, where N is\n// the maximum number of template/value parameters supported.  Without\n// using it, we'd have to devote O(N^2) amount of code to implement all\n// combinations of m and n.\n\n// Declares the template parameters.\n#define GMOCK_INTERNAL_DECL_HAS_1_TEMPLATE_PARAMS(kind0, name0) kind0 name0\n#define GMOCK_INTERNAL_DECL_HAS_2_TEMPLATE_PARAMS(kind0, name0, kind1, \\\n    name1) kind0 name0, kind1 name1\n#define GMOCK_INTERNAL_DECL_HAS_3_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2) kind0 name0, kind1 name1, kind2 name2\n#define GMOCK_INTERNAL_DECL_HAS_4_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3) kind0 name0, kind1 name1, kind2 name2, \\\n    kind3 name3\n#define GMOCK_INTERNAL_DECL_HAS_5_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3, kind4, name4) kind0 name0, kind1 name1, \\\n    kind2 name2, kind3 name3, kind4 name4\n#define GMOCK_INTERNAL_DECL_HAS_6_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3, kind4, name4, kind5, name5) kind0 name0, \\\n    kind1 name1, kind2 name2, kind3 name3, kind4 name4, kind5 name5\n#define GMOCK_INTERNAL_DECL_HAS_7_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3, kind4, name4, kind5, name5, kind6, \\\n    name6) kind0 name0, kind1 name1, kind2 name2, kind3 name3, kind4 name4, \\\n    kind5 name5, kind6 name6\n#define GMOCK_INTERNAL_DECL_HAS_8_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3, kind4, name4, kind5, name5, kind6, name6, \\\n    kind7, name7) kind0 name0, kind1 name1, kind2 name2, kind3 name3, \\\n    kind4 name4, kind5 name5, kind6 name6, kind7 name7\n#define GMOCK_INTERNAL_DECL_HAS_9_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3, kind4, name4, kind5, name5, kind6, name6, \\\n    kind7, name7, kind8, name8) kind0 name0, kind1 name1, kind2 name2, \\\n    kind3 name3, kind4 name4, kind5 name5, kind6 name6, kind7 name7, \\\n    kind8 name8\n#define GMOCK_INTERNAL_DECL_HAS_10_TEMPLATE_PARAMS(kind0, name0, kind1, \\\n    name1, kind2, name2, kind3, name3, kind4, name4, kind5, name5, kind6, \\\n    name6, kind7, name7, kind8, name8, kind9, name9) kind0 name0, \\\n    kind1 name1, kind2 name2, kind3 name3, kind4 name4, kind5 name5, \\\n    kind6 name6, kind7 name7, kind8 name8, kind9 name9\n\n// Lists the template parameters.\n#define GMOCK_INTERNAL_LIST_HAS_1_TEMPLATE_PARAMS(kind0, name0) name0\n#define GMOCK_INTERNAL_LIST_HAS_2_TEMPLATE_PARAMS(kind0, name0, kind1, \\\n    name1) name0, name1\n#define GMOCK_INTERNAL_LIST_HAS_3_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2) name0, name1, name2\n#define GMOCK_INTERNAL_LIST_HAS_4_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3) name0, name1, name2, name3\n#define GMOCK_INTERNAL_LIST_HAS_5_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3, kind4, name4) name0, name1, name2, name3, \\\n    name4\n#define GMOCK_INTERNAL_LIST_HAS_6_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3, kind4, name4, kind5, name5) name0, name1, \\\n    name2, name3, name4, name5\n#define GMOCK_INTERNAL_LIST_HAS_7_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3, kind4, name4, kind5, name5, kind6, \\\n    name6) name0, name1, name2, name3, name4, name5, name6\n#define GMOCK_INTERNAL_LIST_HAS_8_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3, kind4, name4, kind5, name5, kind6, name6, \\\n    kind7, name7) name0, name1, name2, name3, name4, name5, name6, name7\n#define GMOCK_INTERNAL_LIST_HAS_9_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3, kind4, name4, kind5, name5, kind6, name6, \\\n    kind7, name7, kind8, name8) name0, name1, name2, name3, name4, name5, \\\n    name6, name7, name8\n#define GMOCK_INTERNAL_LIST_HAS_10_TEMPLATE_PARAMS(kind0, name0, kind1, \\\n    name1, kind2, name2, kind3, name3, kind4, name4, kind5, name5, kind6, \\\n    name6, kind7, name7, kind8, name8, kind9, name9) name0, name1, name2, \\\n    name3, name4, name5, name6, name7, name8, name9\n\n// Declares the types of value parameters.\n#define GMOCK_INTERNAL_DECL_TYPE_AND_0_VALUE_PARAMS()\n#define GMOCK_INTERNAL_DECL_TYPE_AND_1_VALUE_PARAMS(p0) , typename p0##_type\n#define GMOCK_INTERNAL_DECL_TYPE_AND_2_VALUE_PARAMS(p0, p1) , \\\n    typename p0##_type, typename p1##_type\n#define GMOCK_INTERNAL_DECL_TYPE_AND_3_VALUE_PARAMS(p0, p1, p2) , \\\n    typename p0##_type, typename p1##_type, typename p2##_type\n#define GMOCK_INTERNAL_DECL_TYPE_AND_4_VALUE_PARAMS(p0, p1, p2, p3) , \\\n    typename p0##_type, typename p1##_type, typename p2##_type, \\\n    typename p3##_type\n#define GMOCK_INTERNAL_DECL_TYPE_AND_5_VALUE_PARAMS(p0, p1, p2, p3, p4) , \\\n    typename p0##_type, typename p1##_type, typename p2##_type, \\\n    typename p3##_type, typename p4##_type\n#define GMOCK_INTERNAL_DECL_TYPE_AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, p5) , \\\n    typename p0##_type, typename p1##_type, typename p2##_type, \\\n    typename p3##_type, typename p4##_type, typename p5##_type\n#define GMOCK_INTERNAL_DECL_TYPE_AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \\\n    p6) , typename p0##_type, typename p1##_type, typename p2##_type, \\\n    typename p3##_type, typename p4##_type, typename p5##_type, \\\n    typename p6##_type\n#define GMOCK_INTERNAL_DECL_TYPE_AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \\\n    p6, p7) , typename p0##_type, typename p1##_type, typename p2##_type, \\\n    typename p3##_type, typename p4##_type, typename p5##_type, \\\n    typename p6##_type, typename p7##_type\n#define GMOCK_INTERNAL_DECL_TYPE_AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \\\n    p6, p7, p8) , typename p0##_type, typename p1##_type, typename p2##_type, \\\n    typename p3##_type, typename p4##_type, typename p5##_type, \\\n    typename p6##_type, typename p7##_type, typename p8##_type\n#define GMOCK_INTERNAL_DECL_TYPE_AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \\\n    p6, p7, p8, p9) , typename p0##_type, typename p1##_type, \\\n    typename p2##_type, typename p3##_type, typename p4##_type, \\\n    typename p5##_type, typename p6##_type, typename p7##_type, \\\n    typename p8##_type, typename p9##_type\n\n// Initializes the value parameters.\n#define GMOCK_INTERNAL_INIT_AND_0_VALUE_PARAMS()\\\n    ()\n#define GMOCK_INTERNAL_INIT_AND_1_VALUE_PARAMS(p0)\\\n    (p0##_type gmock_p0) : p0(gmock_p0)\n#define GMOCK_INTERNAL_INIT_AND_2_VALUE_PARAMS(p0, p1)\\\n    (p0##_type gmock_p0, p1##_type gmock_p1) : p0(gmock_p0), p1(gmock_p1)\n#define GMOCK_INTERNAL_INIT_AND_3_VALUE_PARAMS(p0, p1, p2)\\\n    (p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2)\n#define GMOCK_INTERNAL_INIT_AND_4_VALUE_PARAMS(p0, p1, p2, p3)\\\n    (p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n        p3##_type gmock_p3) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3)\n#define GMOCK_INTERNAL_INIT_AND_5_VALUE_PARAMS(p0, p1, p2, p3, p4)\\\n    (p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n        p3##_type gmock_p3, p4##_type gmock_p4) : p0(gmock_p0), p1(gmock_p1), \\\n        p2(gmock_p2), p3(gmock_p3), p4(gmock_p4)\n#define GMOCK_INTERNAL_INIT_AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, p5)\\\n    (p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n        p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5)\n#define GMOCK_INTERNAL_INIT_AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6)\\\n    (p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n        p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n        p6##_type gmock_p6) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6)\n#define GMOCK_INTERNAL_INIT_AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, p7)\\\n    (p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n        p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n        p6##_type gmock_p6, p7##_type gmock_p7) : p0(gmock_p0), p1(gmock_p1), \\\n        p2(gmock_p2), p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), \\\n        p7(gmock_p7)\n#define GMOCK_INTERNAL_INIT_AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7, p8)\\\n    (p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n        p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n        p6##_type gmock_p6, p7##_type gmock_p7, \\\n        p8##_type gmock_p8) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7), \\\n        p8(gmock_p8)\n#define GMOCK_INTERNAL_INIT_AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7, p8, p9)\\\n    (p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n        p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n        p6##_type gmock_p6, p7##_type gmock_p7, p8##_type gmock_p8, \\\n        p9##_type gmock_p9) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7), \\\n        p8(gmock_p8), p9(gmock_p9)\n\n// Declares the fields for storing the value parameters.\n#define GMOCK_INTERNAL_DEFN_AND_0_VALUE_PARAMS()\n#define GMOCK_INTERNAL_DEFN_AND_1_VALUE_PARAMS(p0) p0##_type p0;\n#define GMOCK_INTERNAL_DEFN_AND_2_VALUE_PARAMS(p0, p1) p0##_type p0; \\\n    p1##_type p1;\n#define GMOCK_INTERNAL_DEFN_AND_3_VALUE_PARAMS(p0, p1, p2) p0##_type p0; \\\n    p1##_type p1; p2##_type p2;\n#define GMOCK_INTERNAL_DEFN_AND_4_VALUE_PARAMS(p0, p1, p2, p3) p0##_type p0; \\\n    p1##_type p1; p2##_type p2; p3##_type p3;\n#define GMOCK_INTERNAL_DEFN_AND_5_VALUE_PARAMS(p0, p1, p2, p3, \\\n    p4) p0##_type p0; p1##_type p1; p2##_type p2; p3##_type p3; p4##_type p4;\n#define GMOCK_INTERNAL_DEFN_AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, \\\n    p5) p0##_type p0; p1##_type p1; p2##_type p2; p3##_type p3; p4##_type p4; \\\n    p5##_type p5;\n#define GMOCK_INTERNAL_DEFN_AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \\\n    p6) p0##_type p0; p1##_type p1; p2##_type p2; p3##_type p3; p4##_type p4; \\\n    p5##_type p5; p6##_type p6;\n#define GMOCK_INTERNAL_DEFN_AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7) p0##_type p0; p1##_type p1; p2##_type p2; p3##_type p3; p4##_type p4; \\\n    p5##_type p5; p6##_type p6; p7##_type p7;\n#define GMOCK_INTERNAL_DEFN_AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7, p8) p0##_type p0; p1##_type p1; p2##_type p2; p3##_type p3; \\\n    p4##_type p4; p5##_type p5; p6##_type p6; p7##_type p7; p8##_type p8;\n#define GMOCK_INTERNAL_DEFN_AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7, p8, p9) p0##_type p0; p1##_type p1; p2##_type p2; p3##_type p3; \\\n    p4##_type p4; p5##_type p5; p6##_type p6; p7##_type p7; p8##_type p8; \\\n    p9##_type p9;\n\n// Lists the value parameters.\n#define GMOCK_INTERNAL_LIST_AND_0_VALUE_PARAMS()\n#define GMOCK_INTERNAL_LIST_AND_1_VALUE_PARAMS(p0) p0\n#define GMOCK_INTERNAL_LIST_AND_2_VALUE_PARAMS(p0, p1) p0, p1\n#define GMOCK_INTERNAL_LIST_AND_3_VALUE_PARAMS(p0, p1, p2) p0, p1, p2\n#define GMOCK_INTERNAL_LIST_AND_4_VALUE_PARAMS(p0, p1, p2, p3) p0, p1, p2, p3\n#define GMOCK_INTERNAL_LIST_AND_5_VALUE_PARAMS(p0, p1, p2, p3, p4) p0, p1, \\\n    p2, p3, p4\n#define GMOCK_INTERNAL_LIST_AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, p5) p0, \\\n    p1, p2, p3, p4, p5\n#define GMOCK_INTERNAL_LIST_AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \\\n    p6) p0, p1, p2, p3, p4, p5, p6\n#define GMOCK_INTERNAL_LIST_AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7) p0, p1, p2, p3, p4, p5, p6, p7\n#define GMOCK_INTERNAL_LIST_AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7, p8) p0, p1, p2, p3, p4, p5, p6, p7, p8\n#define GMOCK_INTERNAL_LIST_AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7, p8, p9) p0, p1, p2, p3, p4, p5, p6, p7, p8, p9\n\n// Lists the value parameter types.\n#define GMOCK_INTERNAL_LIST_TYPE_AND_0_VALUE_PARAMS()\n#define GMOCK_INTERNAL_LIST_TYPE_AND_1_VALUE_PARAMS(p0) , p0##_type\n#define GMOCK_INTERNAL_LIST_TYPE_AND_2_VALUE_PARAMS(p0, p1) , p0##_type, \\\n    p1##_type\n#define GMOCK_INTERNAL_LIST_TYPE_AND_3_VALUE_PARAMS(p0, p1, p2) , p0##_type, \\\n    p1##_type, p2##_type\n#define GMOCK_INTERNAL_LIST_TYPE_AND_4_VALUE_PARAMS(p0, p1, p2, p3) , \\\n    p0##_type, p1##_type, p2##_type, p3##_type\n#define GMOCK_INTERNAL_LIST_TYPE_AND_5_VALUE_PARAMS(p0, p1, p2, p3, p4) , \\\n    p0##_type, p1##_type, p2##_type, p3##_type, p4##_type\n#define GMOCK_INTERNAL_LIST_TYPE_AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, p5) , \\\n    p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, p5##_type\n#define GMOCK_INTERNAL_LIST_TYPE_AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \\\n    p6) , p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, p5##_type, \\\n    p6##_type\n#define GMOCK_INTERNAL_LIST_TYPE_AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \\\n    p6, p7) , p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n    p5##_type, p6##_type, p7##_type\n#define GMOCK_INTERNAL_LIST_TYPE_AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \\\n    p6, p7, p8) , p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n    p5##_type, p6##_type, p7##_type, p8##_type\n#define GMOCK_INTERNAL_LIST_TYPE_AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \\\n    p6, p7, p8, p9) , p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n    p5##_type, p6##_type, p7##_type, p8##_type, p9##_type\n\n// Declares the value parameters.\n#define GMOCK_INTERNAL_DECL_AND_0_VALUE_PARAMS()\n#define GMOCK_INTERNAL_DECL_AND_1_VALUE_PARAMS(p0) p0##_type p0\n#define GMOCK_INTERNAL_DECL_AND_2_VALUE_PARAMS(p0, p1) p0##_type p0, \\\n    p1##_type p1\n#define GMOCK_INTERNAL_DECL_AND_3_VALUE_PARAMS(p0, p1, p2) p0##_type p0, \\\n    p1##_type p1, p2##_type p2\n#define GMOCK_INTERNAL_DECL_AND_4_VALUE_PARAMS(p0, p1, p2, p3) p0##_type p0, \\\n    p1##_type p1, p2##_type p2, p3##_type p3\n#define GMOCK_INTERNAL_DECL_AND_5_VALUE_PARAMS(p0, p1, p2, p3, \\\n    p4) p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, p4##_type p4\n#define GMOCK_INTERNAL_DECL_AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, \\\n    p5) p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, p4##_type p4, \\\n    p5##_type p5\n#define GMOCK_INTERNAL_DECL_AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \\\n    p6) p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, p4##_type p4, \\\n    p5##_type p5, p6##_type p6\n#define GMOCK_INTERNAL_DECL_AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7) p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, p4##_type p4, \\\n    p5##_type p5, p6##_type p6, p7##_type p7\n#define GMOCK_INTERNAL_DECL_AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7, p8) p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \\\n    p4##_type p4, p5##_type p5, p6##_type p6, p7##_type p7, p8##_type p8\n#define GMOCK_INTERNAL_DECL_AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7, p8, p9) p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \\\n    p4##_type p4, p5##_type p5, p6##_type p6, p7##_type p7, p8##_type p8, \\\n    p9##_type p9\n\n// The suffix of the class template implementing the action template.\n#define GMOCK_INTERNAL_COUNT_AND_0_VALUE_PARAMS()\n#define GMOCK_INTERNAL_COUNT_AND_1_VALUE_PARAMS(p0) P\n#define GMOCK_INTERNAL_COUNT_AND_2_VALUE_PARAMS(p0, p1) P2\n#define GMOCK_INTERNAL_COUNT_AND_3_VALUE_PARAMS(p0, p1, p2) P3\n#define GMOCK_INTERNAL_COUNT_AND_4_VALUE_PARAMS(p0, p1, p2, p3) P4\n#define GMOCK_INTERNAL_COUNT_AND_5_VALUE_PARAMS(p0, p1, p2, p3, p4) P5\n#define GMOCK_INTERNAL_COUNT_AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, p5) P6\n#define GMOCK_INTERNAL_COUNT_AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6) P7\n#define GMOCK_INTERNAL_COUNT_AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7) P8\n#define GMOCK_INTERNAL_COUNT_AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7, p8) P9\n#define GMOCK_INTERNAL_COUNT_AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7, p8, p9) P10\n\n// The name of the class template implementing the action template.\n#define GMOCK_ACTION_CLASS_(name, value_params)\\\n    GTEST_CONCAT_TOKEN_(name##Action, GMOCK_INTERNAL_COUNT_##value_params)\n\n#define ACTION_TEMPLATE(name, template_params, value_params)\\\n  template <GMOCK_INTERNAL_DECL_##template_params\\\n            GMOCK_INTERNAL_DECL_TYPE_##value_params>\\\n  class GMOCK_ACTION_CLASS_(name, value_params) {\\\n   public:\\\n    explicit GMOCK_ACTION_CLASS_(name, value_params)\\\n        GMOCK_INTERNAL_INIT_##value_params {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      explicit gmock_Impl GMOCK_INTERNAL_INIT_##value_params {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n      GMOCK_INTERNAL_DEFN_##value_params\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(\\\n          new gmock_Impl<F>(GMOCK_INTERNAL_LIST_##value_params));\\\n    }\\\n    GMOCK_INTERNAL_DEFN_##value_params\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(GMOCK_ACTION_CLASS_(name, value_params));\\\n  };\\\n  template <GMOCK_INTERNAL_DECL_##template_params\\\n            GMOCK_INTERNAL_DECL_TYPE_##value_params>\\\n  inline GMOCK_ACTION_CLASS_(name, value_params)<\\\n      GMOCK_INTERNAL_LIST_##template_params\\\n      GMOCK_INTERNAL_LIST_TYPE_##value_params> name(\\\n          GMOCK_INTERNAL_DECL_##value_params) {\\\n    return GMOCK_ACTION_CLASS_(name, value_params)<\\\n        GMOCK_INTERNAL_LIST_##template_params\\\n        GMOCK_INTERNAL_LIST_TYPE_##value_params>(\\\n            GMOCK_INTERNAL_LIST_##value_params);\\\n  }\\\n  template <GMOCK_INTERNAL_DECL_##template_params\\\n            GMOCK_INTERNAL_DECL_TYPE_##value_params>\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      GMOCK_ACTION_CLASS_(name, value_params)<\\\n          GMOCK_INTERNAL_LIST_##template_params\\\n          GMOCK_INTERNAL_LIST_TYPE_##value_params>::gmock_Impl<F>::\\\n              gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\n#define ACTION(name)\\\n  class name##Action {\\\n   public:\\\n    name##Action() {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      gmock_Impl() {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(new gmock_Impl<F>());\\\n    }\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##Action);\\\n  };\\\n  inline name##Action name() {\\\n    return name##Action();\\\n  }\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      name##Action::gmock_Impl<F>::gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\n#define ACTION_P(name, p0)\\\n  template <typename p0##_type>\\\n  class name##ActionP {\\\n   public:\\\n    explicit name##ActionP(p0##_type gmock_p0) : p0(gmock_p0) {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      explicit gmock_Impl(p0##_type gmock_p0) : p0(gmock_p0) {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n      p0##_type p0;\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(new gmock_Impl<F>(p0));\\\n    }\\\n    p0##_type p0;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##ActionP);\\\n  };\\\n  template <typename p0##_type>\\\n  inline name##ActionP<p0##_type> name(p0##_type p0) {\\\n    return name##ActionP<p0##_type>(p0);\\\n  }\\\n  template <typename p0##_type>\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      name##ActionP<p0##_type>::gmock_Impl<F>::gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\n#define ACTION_P2(name, p0, p1)\\\n  template <typename p0##_type, typename p1##_type>\\\n  class name##ActionP2 {\\\n   public:\\\n    name##ActionP2(p0##_type gmock_p0, p1##_type gmock_p1) : p0(gmock_p0), \\\n        p1(gmock_p1) {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1) : p0(gmock_p0), \\\n          p1(gmock_p1) {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(new gmock_Impl<F>(p0, p1));\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##ActionP2);\\\n  };\\\n  template <typename p0##_type, typename p1##_type>\\\n  inline name##ActionP2<p0##_type, p1##_type> name(p0##_type p0, \\\n      p1##_type p1) {\\\n    return name##ActionP2<p0##_type, p1##_type>(p0, p1);\\\n  }\\\n  template <typename p0##_type, typename p1##_type>\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      name##ActionP2<p0##_type, p1##_type>::gmock_Impl<F>::gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\n#define ACTION_P3(name, p0, p1, p2)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type>\\\n  class name##ActionP3 {\\\n   public:\\\n    name##ActionP3(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2) {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, \\\n          p2##_type gmock_p2) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2) {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(new gmock_Impl<F>(p0, p1, p2));\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##ActionP3);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type>\\\n  inline name##ActionP3<p0##_type, p1##_type, p2##_type> name(p0##_type p0, \\\n      p1##_type p1, p2##_type p2) {\\\n    return name##ActionP3<p0##_type, p1##_type, p2##_type>(p0, p1, p2);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type>\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      name##ActionP3<p0##_type, p1##_type, \\\n          p2##_type>::gmock_Impl<F>::gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\n#define ACTION_P4(name, p0, p1, p2, p3)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type>\\\n  class name##ActionP4 {\\\n   public:\\\n    name##ActionP4(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3) : p0(gmock_p0), p1(gmock_p1), \\\n        p2(gmock_p2), p3(gmock_p3) {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n          p3(gmock_p3) {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(new gmock_Impl<F>(p0, p1, p2, p3));\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##ActionP4);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type>\\\n  inline name##ActionP4<p0##_type, p1##_type, p2##_type, \\\n      p3##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, \\\n      p3##_type p3) {\\\n    return name##ActionP4<p0##_type, p1##_type, p2##_type, p3##_type>(p0, p1, \\\n        p2, p3);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type>\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      name##ActionP4<p0##_type, p1##_type, p2##_type, \\\n          p3##_type>::gmock_Impl<F>::gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\n#define ACTION_P5(name, p0, p1, p2, p3, p4)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type>\\\n  class name##ActionP5 {\\\n   public:\\\n    name##ActionP5(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, \\\n        p4##_type gmock_p4) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4) {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4) : p0(gmock_p0), \\\n          p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), p4(gmock_p4) {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(new gmock_Impl<F>(p0, p1, p2, p3, p4));\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##ActionP5);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type>\\\n  inline name##ActionP5<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \\\n      p4##_type p4) {\\\n    return name##ActionP5<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type>(p0, p1, p2, p3, p4);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type>\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      name##ActionP5<p0##_type, p1##_type, p2##_type, p3##_type, \\\n          p4##_type>::gmock_Impl<F>::gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\n#define ACTION_P6(name, p0, p1, p2, p3, p4, p5)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type>\\\n  class name##ActionP6 {\\\n   public:\\\n    name##ActionP6(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5) {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4, \\\n          p5##_type gmock_p5) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n          p3(gmock_p3), p4(gmock_p4), p5(gmock_p5) {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n      p5##_type p5;\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(new gmock_Impl<F>(p0, p1, p2, p3, p4, p5));\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n    p5##_type p5;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##ActionP6);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type>\\\n  inline name##ActionP6<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, \\\n      p3##_type p3, p4##_type p4, p5##_type p5) {\\\n    return name##ActionP6<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type, p5##_type>(p0, p1, p2, p3, p4, p5);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type>\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      name##ActionP6<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n          p5##_type>::gmock_Impl<F>::gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\n#define ACTION_P7(name, p0, p1, p2, p3, p4, p5, p6)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type>\\\n  class name##ActionP7 {\\\n   public:\\\n    name##ActionP7(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5, p6##_type gmock_p6) : p0(gmock_p0), p1(gmock_p1), \\\n        p2(gmock_p2), p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), \\\n        p6(gmock_p6) {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n          p6##_type gmock_p6) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n          p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6) {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n      p5##_type p5;\\\n      p6##_type p6;\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(new gmock_Impl<F>(p0, p1, p2, p3, p4, p5, \\\n          p6));\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n    p5##_type p5;\\\n    p6##_type p6;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##ActionP7);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type>\\\n  inline name##ActionP7<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type, p6##_type> name(p0##_type p0, p1##_type p1, \\\n      p2##_type p2, p3##_type p3, p4##_type p4, p5##_type p5, \\\n      p6##_type p6) {\\\n    return name##ActionP7<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type, p5##_type, p6##_type>(p0, p1, p2, p3, p4, p5, p6);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type>\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      name##ActionP7<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n          p5##_type, p6##_type>::gmock_Impl<F>::gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\n#define ACTION_P8(name, p0, p1, p2, p3, p4, p5, p6, p7)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type>\\\n  class name##ActionP8 {\\\n   public:\\\n    name##ActionP8(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5, p6##_type gmock_p6, \\\n        p7##_type gmock_p7) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), \\\n        p7(gmock_p7) {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n          p6##_type gmock_p6, p7##_type gmock_p7) : p0(gmock_p0), \\\n          p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), p4(gmock_p4), \\\n          p5(gmock_p5), p6(gmock_p6), p7(gmock_p7) {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n      p5##_type p5;\\\n      p6##_type p6;\\\n      p7##_type p7;\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(new gmock_Impl<F>(p0, p1, p2, p3, p4, p5, \\\n          p6, p7));\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n    p5##_type p5;\\\n    p6##_type p6;\\\n    p7##_type p7;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##ActionP8);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type>\\\n  inline name##ActionP8<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type, p6##_type, p7##_type> name(p0##_type p0, \\\n      p1##_type p1, p2##_type p2, p3##_type p3, p4##_type p4, p5##_type p5, \\\n      p6##_type p6, p7##_type p7) {\\\n    return name##ActionP8<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type, p5##_type, p6##_type, p7##_type>(p0, p1, p2, p3, p4, p5, \\\n        p6, p7);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type>\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      name##ActionP8<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n          p5##_type, p6##_type, \\\n          p7##_type>::gmock_Impl<F>::gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\n#define ACTION_P9(name, p0, p1, p2, p3, p4, p5, p6, p7, p8)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type>\\\n  class name##ActionP9 {\\\n   public:\\\n    name##ActionP9(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5, p6##_type gmock_p6, p7##_type gmock_p7, \\\n        p8##_type gmock_p8) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7), \\\n        p8(gmock_p8) {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n          p6##_type gmock_p6, p7##_type gmock_p7, \\\n          p8##_type gmock_p8) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n          p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), \\\n          p7(gmock_p7), p8(gmock_p8) {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n      p5##_type p5;\\\n      p6##_type p6;\\\n      p7##_type p7;\\\n      p8##_type p8;\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(new gmock_Impl<F>(p0, p1, p2, p3, p4, p5, \\\n          p6, p7, p8));\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n    p5##_type p5;\\\n    p6##_type p6;\\\n    p7##_type p7;\\\n    p8##_type p8;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##ActionP9);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type>\\\n  inline name##ActionP9<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type, p6##_type, p7##_type, \\\n      p8##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \\\n      p4##_type p4, p5##_type p5, p6##_type p6, p7##_type p7, \\\n      p8##_type p8) {\\\n    return name##ActionP9<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type, p5##_type, p6##_type, p7##_type, p8##_type>(p0, p1, p2, \\\n        p3, p4, p5, p6, p7, p8);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type>\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      name##ActionP9<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n          p5##_type, p6##_type, p7##_type, \\\n          p8##_type>::gmock_Impl<F>::gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\n#define ACTION_P10(name, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type, \\\n      typename p9##_type>\\\n  class name##ActionP10 {\\\n   public:\\\n    name##ActionP10(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5, p6##_type gmock_p6, p7##_type gmock_p7, \\\n        p8##_type gmock_p8, p9##_type gmock_p9) : p0(gmock_p0), p1(gmock_p1), \\\n        p2(gmock_p2), p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), \\\n        p7(gmock_p7), p8(gmock_p8), p9(gmock_p9) {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n          p6##_type gmock_p6, p7##_type gmock_p7, p8##_type gmock_p8, \\\n          p9##_type gmock_p9) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n          p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), \\\n          p7(gmock_p7), p8(gmock_p8), p9(gmock_p9) {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n      p5##_type p5;\\\n      p6##_type p6;\\\n      p7##_type p7;\\\n      p8##_type p8;\\\n      p9##_type p9;\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(new gmock_Impl<F>(p0, p1, p2, p3, p4, p5, \\\n          p6, p7, p8, p9));\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n    p5##_type p5;\\\n    p6##_type p6;\\\n    p7##_type p7;\\\n    p8##_type p8;\\\n    p9##_type p9;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##ActionP10);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type, \\\n      typename p9##_type>\\\n  inline name##ActionP10<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, \\\n      p9##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \\\n      p4##_type p4, p5##_type p5, p6##_type p6, p7##_type p7, p8##_type p8, \\\n      p9##_type p9) {\\\n    return name##ActionP10<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, p9##_type>(p0, \\\n        p1, p2, p3, p4, p5, p6, p7, p8, p9);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type, \\\n      typename p9##_type>\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      name##ActionP10<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n          p5##_type, p6##_type, p7##_type, p8##_type, \\\n          p9##_type>::gmock_Impl<F>::gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\nnamespace testing {\n\n\n// The ACTION*() macros trigger warning C4100 (unreferenced formal\n// parameter) in MSVC with -W4.  Unfortunately they cannot be fixed in\n// the macro definition, as the warnings are generated when the macro\n// is expanded and macro expansion cannot contain #pragma.  Therefore\n// we suppress them here.\n#ifdef _MSC_VER\n# pragma warning(push)\n# pragma warning(disable:4100)\n#endif\n\n// Various overloads for InvokeArgument<N>().\n//\n// The InvokeArgument<N>(a1, a2, ..., a_k) action invokes the N-th\n// (0-based) argument, which must be a k-ary callable, of the mock\n// function, with arguments a1, a2, ..., a_k.\n//\n// Notes:\n//\n//   1. The arguments are passed by value by default.  If you need to\n//   pass an argument by reference, wrap it inside ByRef().  For\n//   example,\n//\n//     InvokeArgument<1>(5, string(\"Hello\"), ByRef(foo))\n//\n//   passes 5 and string(\"Hello\") by value, and passes foo by\n//   reference.\n//\n//   2. If the callable takes an argument by reference but ByRef() is\n//   not used, it will receive the reference to a copy of the value,\n//   instead of the original value.  For example, when the 0-th\n//   argument of the mock function takes a const string&, the action\n//\n//     InvokeArgument<0>(string(\"Hello\"))\n//\n//   makes a copy of the temporary string(\"Hello\") object and passes a\n//   reference of the copy, instead of the original temporary object,\n//   to the callable.  This makes it easy for a user to define an\n//   InvokeArgument action from temporary values and have it performed\n//   later.\n\nnamespace internal {\nnamespace invoke_argument {\n\n// Appears in InvokeArgumentAdl's argument list to help avoid\n// accidental calls to user functions of the same name.\nstruct AdlTag {};\n\n// InvokeArgumentAdl - a helper for InvokeArgument.\n// The basic overloads are provided here for generic functors.\n// Overloads for other custom-callables are provided in the\n// internal/custom/callback-actions.h header.\n\ntemplate <typename R, typename F>\nR InvokeArgumentAdl(AdlTag, F f) {\n  return f();\n}\ntemplate <typename R, typename F, typename A1>\nR InvokeArgumentAdl(AdlTag, F f, A1 a1) {\n  return f(a1);\n}\ntemplate <typename R, typename F, typename A1, typename A2>\nR InvokeArgumentAdl(AdlTag, F f, A1 a1, A2 a2) {\n  return f(a1, a2);\n}\ntemplate <typename R, typename F, typename A1, typename A2, typename A3>\nR InvokeArgumentAdl(AdlTag, F f, A1 a1, A2 a2, A3 a3) {\n  return f(a1, a2, a3);\n}\ntemplate <typename R, typename F, typename A1, typename A2, typename A3,\n    typename A4>\nR InvokeArgumentAdl(AdlTag, F f, A1 a1, A2 a2, A3 a3, A4 a4) {\n  return f(a1, a2, a3, a4);\n}\ntemplate <typename R, typename F, typename A1, typename A2, typename A3,\n    typename A4, typename A5>\nR InvokeArgumentAdl(AdlTag, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) {\n  return f(a1, a2, a3, a4, a5);\n}\ntemplate <typename R, typename F, typename A1, typename A2, typename A3,\n    typename A4, typename A5, typename A6>\nR InvokeArgumentAdl(AdlTag, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) {\n  return f(a1, a2, a3, a4, a5, a6);\n}\ntemplate <typename R, typename F, typename A1, typename A2, typename A3,\n    typename A4, typename A5, typename A6, typename A7>\nR InvokeArgumentAdl(AdlTag, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6,\n    A7 a7) {\n  return f(a1, a2, a3, a4, a5, a6, a7);\n}\ntemplate <typename R, typename F, typename A1, typename A2, typename A3,\n    typename A4, typename A5, typename A6, typename A7, typename A8>\nR InvokeArgumentAdl(AdlTag, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6,\n    A7 a7, A8 a8) {\n  return f(a1, a2, a3, a4, a5, a6, a7, a8);\n}\ntemplate <typename R, typename F, typename A1, typename A2, typename A3,\n    typename A4, typename A5, typename A6, typename A7, typename A8,\n    typename A9>\nR InvokeArgumentAdl(AdlTag, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6,\n    A7 a7, A8 a8, A9 a9) {\n  return f(a1, a2, a3, a4, a5, a6, a7, a8, a9);\n}\ntemplate <typename R, typename F, typename A1, typename A2, typename A3,\n    typename A4, typename A5, typename A6, typename A7, typename A8,\n    typename A9, typename A10>\nR InvokeArgumentAdl(AdlTag, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6,\n    A7 a7, A8 a8, A9 a9, A10 a10) {\n  return f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);\n}\n}  // namespace invoke_argument\n}  // namespace internal\n\nACTION_TEMPLATE(InvokeArgument,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_0_VALUE_PARAMS()) {\n  using internal::invoke_argument::InvokeArgumentAdl;\n  return InvokeArgumentAdl<return_type>(\n      internal::invoke_argument::AdlTag(),\n      ::testing::get<k>(args));\n}\n\nACTION_TEMPLATE(InvokeArgument,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_1_VALUE_PARAMS(p0)) {\n  using internal::invoke_argument::InvokeArgumentAdl;\n  return InvokeArgumentAdl<return_type>(\n      internal::invoke_argument::AdlTag(),\n      ::testing::get<k>(args), p0);\n}\n\nACTION_TEMPLATE(InvokeArgument,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_2_VALUE_PARAMS(p0, p1)) {\n  using internal::invoke_argument::InvokeArgumentAdl;\n  return InvokeArgumentAdl<return_type>(\n      internal::invoke_argument::AdlTag(),\n      ::testing::get<k>(args), p0, p1);\n}\n\nACTION_TEMPLATE(InvokeArgument,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_3_VALUE_PARAMS(p0, p1, p2)) {\n  using internal::invoke_argument::InvokeArgumentAdl;\n  return InvokeArgumentAdl<return_type>(\n      internal::invoke_argument::AdlTag(),\n      ::testing::get<k>(args), p0, p1, p2);\n}\n\nACTION_TEMPLATE(InvokeArgument,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_4_VALUE_PARAMS(p0, p1, p2, p3)) {\n  using internal::invoke_argument::InvokeArgumentAdl;\n  return InvokeArgumentAdl<return_type>(\n      internal::invoke_argument::AdlTag(),\n      ::testing::get<k>(args), p0, p1, p2, p3);\n}\n\nACTION_TEMPLATE(InvokeArgument,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_5_VALUE_PARAMS(p0, p1, p2, p3, p4)) {\n  using internal::invoke_argument::InvokeArgumentAdl;\n  return InvokeArgumentAdl<return_type>(\n      internal::invoke_argument::AdlTag(),\n      ::testing::get<k>(args), p0, p1, p2, p3, p4);\n}\n\nACTION_TEMPLATE(InvokeArgument,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, p5)) {\n  using internal::invoke_argument::InvokeArgumentAdl;\n  return InvokeArgumentAdl<return_type>(\n      internal::invoke_argument::AdlTag(),\n      ::testing::get<k>(args), p0, p1, p2, p3, p4, p5);\n}\n\nACTION_TEMPLATE(InvokeArgument,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6)) {\n  using internal::invoke_argument::InvokeArgumentAdl;\n  return InvokeArgumentAdl<return_type>(\n      internal::invoke_argument::AdlTag(),\n      ::testing::get<k>(args), p0, p1, p2, p3, p4, p5, p6);\n}\n\nACTION_TEMPLATE(InvokeArgument,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, p7)) {\n  using internal::invoke_argument::InvokeArgumentAdl;\n  return InvokeArgumentAdl<return_type>(\n      internal::invoke_argument::AdlTag(),\n      ::testing::get<k>(args), p0, p1, p2, p3, p4, p5, p6, p7);\n}\n\nACTION_TEMPLATE(InvokeArgument,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, p7, p8)) {\n  using internal::invoke_argument::InvokeArgumentAdl;\n  return InvokeArgumentAdl<return_type>(\n      internal::invoke_argument::AdlTag(),\n      ::testing::get<k>(args), p0, p1, p2, p3, p4, p5, p6, p7, p8);\n}\n\nACTION_TEMPLATE(InvokeArgument,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9)) {\n  using internal::invoke_argument::InvokeArgumentAdl;\n  return InvokeArgumentAdl<return_type>(\n      internal::invoke_argument::AdlTag(),\n      ::testing::get<k>(args), p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);\n}\n\n// Various overloads for ReturnNew<T>().\n//\n// The ReturnNew<T>(a1, a2, ..., a_k) action returns a pointer to a new\n// instance of type T, constructed on the heap with constructor arguments\n// a1, a2, ..., and a_k. The caller assumes ownership of the returned value.\nACTION_TEMPLATE(ReturnNew,\n                HAS_1_TEMPLATE_PARAMS(typename, T),\n                AND_0_VALUE_PARAMS()) {\n  return new T();\n}\n\nACTION_TEMPLATE(ReturnNew,\n                HAS_1_TEMPLATE_PARAMS(typename, T),\n                AND_1_VALUE_PARAMS(p0)) {\n  return new T(p0);\n}\n\nACTION_TEMPLATE(ReturnNew,\n                HAS_1_TEMPLATE_PARAMS(typename, T),\n                AND_2_VALUE_PARAMS(p0, p1)) {\n  return new T(p0, p1);\n}\n\nACTION_TEMPLATE(ReturnNew,\n                HAS_1_TEMPLATE_PARAMS(typename, T),\n                AND_3_VALUE_PARAMS(p0, p1, p2)) {\n  return new T(p0, p1, p2);\n}\n\nACTION_TEMPLATE(ReturnNew,\n                HAS_1_TEMPLATE_PARAMS(typename, T),\n                AND_4_VALUE_PARAMS(p0, p1, p2, p3)) {\n  return new T(p0, p1, p2, p3);\n}\n\nACTION_TEMPLATE(ReturnNew,\n                HAS_1_TEMPLATE_PARAMS(typename, T),\n                AND_5_VALUE_PARAMS(p0, p1, p2, p3, p4)) {\n  return new T(p0, p1, p2, p3, p4);\n}\n\nACTION_TEMPLATE(ReturnNew,\n                HAS_1_TEMPLATE_PARAMS(typename, T),\n                AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, p5)) {\n  return new T(p0, p1, p2, p3, p4, p5);\n}\n\nACTION_TEMPLATE(ReturnNew,\n                HAS_1_TEMPLATE_PARAMS(typename, T),\n                AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6)) {\n  return new T(p0, p1, p2, p3, p4, p5, p6);\n}\n\nACTION_TEMPLATE(ReturnNew,\n                HAS_1_TEMPLATE_PARAMS(typename, T),\n                AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, p7)) {\n  return new T(p0, p1, p2, p3, p4, p5, p6, p7);\n}\n\nACTION_TEMPLATE(ReturnNew,\n                HAS_1_TEMPLATE_PARAMS(typename, T),\n                AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, p7, p8)) {\n  return new T(p0, p1, p2, p3, p4, p5, p6, p7, p8);\n}\n\nACTION_TEMPLATE(ReturnNew,\n                HAS_1_TEMPLATE_PARAMS(typename, T),\n                AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9)) {\n  return new T(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);\n}\n\n#ifdef _MSC_VER\n# pragma warning(pop)\n#endif\n\n}  // namespace testing\n\n// Include any custom actions added by the local installation.\n// We must include this header at the end to make sure it can use the\n// declarations from this file.\n#include \"gmock/internal/custom/gmock-generated-actions.h\"\n\n#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_ACTIONS_H_\n"}, "34": {"id": 34, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-generated-function-mockers.h", "content": "// This file was GENERATED by command:\n//     pump.py gmock-generated-function-mockers.h.pump\n// DO NOT EDIT BY HAND!!!\n\n// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n// Google Mock - a framework for writing C++ mock classes.\n//\n// This file implements function mockers of various arities.\n\n// IWYU pragma: private, include \"gmock/gmock.h\"\n\n#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_FUNCTION_MOCKERS_H_\n#define GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_FUNCTION_MOCKERS_H_\n\n#include \"gmock/gmock-spec-builders.h\"\n#include \"gmock/internal/gmock-internal-utils.h\"\n\n#if GTEST_HAS_STD_FUNCTION_\n# include <functional>\n#endif\n\nnamespace testing {\nnamespace internal {\n\ntemplate <typename F>\nclass FunctionMockerBase;\n\n// Note: class FunctionMocker really belongs to the ::testing\n// namespace.  However if we define it in ::testing, MSVC will\n// complain when classes in ::testing::internal declare it as a\n// friend class template.  To workaround this compiler bug, we define\n// FunctionMocker in ::testing::internal and import it into ::testing.\ntemplate <typename F>\nclass FunctionMocker;\n\ntemplate <typename R>\nclass FunctionMocker<R()> : public\n    internal::FunctionMockerBase<R()> {\n public:\n  typedef R F();\n  typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n\n  MockSpec<F>& With() {\n    return this->current_spec();\n  }\n\n  R Invoke() {\n    // Even though gcc and MSVC don't enforce it, 'this->' is required\n    // by the C++ standard [14.6.4] here, as the base class type is\n    // dependent on the template argument (and thus shouldn't be\n    // looked into when resolving InvokeWith).\n    return this->InvokeWith(ArgumentTuple());\n  }\n};\n\ntemplate <typename R, typename A1>\nclass FunctionMocker<R(A1)> : public\n    internal::FunctionMockerBase<R(A1)> {\n public:\n  typedef R F(A1);\n  typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n\n  MockSpec<F>& With(const Matcher<A1>& m1) {\n    this->current_spec().SetMatchers(::testing::make_tuple(m1));\n    return this->current_spec();\n  }\n\n  R Invoke(A1 a1) {\n    // Even though gcc and MSVC don't enforce it, 'this->' is required\n    // by the C++ standard [14.6.4] here, as the base class type is\n    // dependent on the template argument (and thus shouldn't be\n    // looked into when resolving InvokeWith).\n    return this->InvokeWith(ArgumentTuple(a1));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2>\nclass FunctionMocker<R(A1, A2)> : public\n    internal::FunctionMockerBase<R(A1, A2)> {\n public:\n  typedef R F(A1, A2);\n  typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n\n  MockSpec<F>& With(const Matcher<A1>& m1, const Matcher<A2>& m2) {\n    this->current_spec().SetMatchers(::testing::make_tuple(m1, m2));\n    return this->current_spec();\n  }\n\n  R Invoke(A1 a1, A2 a2) {\n    // Even though gcc and MSVC don't enforce it, 'this->' is required\n    // by the C++ standard [14.6.4] here, as the base class type is\n    // dependent on the template argument (and thus shouldn't be\n    // looked into when resolving InvokeWith).\n    return this->InvokeWith(ArgumentTuple(a1, a2));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3>\nclass FunctionMocker<R(A1, A2, A3)> : public\n    internal::FunctionMockerBase<R(A1, A2, A3)> {\n public:\n  typedef R F(A1, A2, A3);\n  typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n\n  MockSpec<F>& With(const Matcher<A1>& m1, const Matcher<A2>& m2,\n      const Matcher<A3>& m3) {\n    this->current_spec().SetMatchers(::testing::make_tuple(m1, m2, m3));\n    return this->current_spec();\n  }\n\n  R Invoke(A1 a1, A2 a2, A3 a3) {\n    // Even though gcc and MSVC don't enforce it, 'this->' is required\n    // by the C++ standard [14.6.4] here, as the base class type is\n    // dependent on the template argument (and thus shouldn't be\n    // looked into when resolving InvokeWith).\n    return this->InvokeWith(ArgumentTuple(a1, a2, a3));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4>\nclass FunctionMocker<R(A1, A2, A3, A4)> : public\n    internal::FunctionMockerBase<R(A1, A2, A3, A4)> {\n public:\n  typedef R F(A1, A2, A3, A4);\n  typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n\n  MockSpec<F>& With(const Matcher<A1>& m1, const Matcher<A2>& m2,\n      const Matcher<A3>& m3, const Matcher<A4>& m4) {\n    this->current_spec().SetMatchers(::testing::make_tuple(m1, m2, m3, m4));\n    return this->current_spec();\n  }\n\n  R Invoke(A1 a1, A2 a2, A3 a3, A4 a4) {\n    // Even though gcc and MSVC don't enforce it, 'this->' is required\n    // by the C++ standard [14.6.4] here, as the base class type is\n    // dependent on the template argument (and thus shouldn't be\n    // looked into when resolving InvokeWith).\n    return this->InvokeWith(ArgumentTuple(a1, a2, a3, a4));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5>\nclass FunctionMocker<R(A1, A2, A3, A4, A5)> : public\n    internal::FunctionMockerBase<R(A1, A2, A3, A4, A5)> {\n public:\n  typedef R F(A1, A2, A3, A4, A5);\n  typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n\n  MockSpec<F>& With(const Matcher<A1>& m1, const Matcher<A2>& m2,\n      const Matcher<A3>& m3, const Matcher<A4>& m4, const Matcher<A5>& m5) {\n    this->current_spec().SetMatchers(::testing::make_tuple(m1, m2, m3, m4, m5));\n    return this->current_spec();\n  }\n\n  R Invoke(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) {\n    // Even though gcc and MSVC don't enforce it, 'this->' is required\n    // by the C++ standard [14.6.4] here, as the base class type is\n    // dependent on the template argument (and thus shouldn't be\n    // looked into when resolving InvokeWith).\n    return this->InvokeWith(ArgumentTuple(a1, a2, a3, a4, a5));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5, typename A6>\nclass FunctionMocker<R(A1, A2, A3, A4, A5, A6)> : public\n    internal::FunctionMockerBase<R(A1, A2, A3, A4, A5, A6)> {\n public:\n  typedef R F(A1, A2, A3, A4, A5, A6);\n  typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n\n  MockSpec<F>& With(const Matcher<A1>& m1, const Matcher<A2>& m2,\n      const Matcher<A3>& m3, const Matcher<A4>& m4, const Matcher<A5>& m5,\n      const Matcher<A6>& m6) {\n    this->current_spec().SetMatchers(::testing::make_tuple(m1, m2, m3, m4, m5,\n        m6));\n    return this->current_spec();\n  }\n\n  R Invoke(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) {\n    // Even though gcc and MSVC don't enforce it, 'this->' is required\n    // by the C++ standard [14.6.4] here, as the base class type is\n    // dependent on the template argument (and thus shouldn't be\n    // looked into when resolving InvokeWith).\n    return this->InvokeWith(ArgumentTuple(a1, a2, a3, a4, a5, a6));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5, typename A6, typename A7>\nclass FunctionMocker<R(A1, A2, A3, A4, A5, A6, A7)> : public\n    internal::FunctionMockerBase<R(A1, A2, A3, A4, A5, A6, A7)> {\n public:\n  typedef R F(A1, A2, A3, A4, A5, A6, A7);\n  typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n\n  MockSpec<F>& With(const Matcher<A1>& m1, const Matcher<A2>& m2,\n      const Matcher<A3>& m3, const Matcher<A4>& m4, const Matcher<A5>& m5,\n      const Matcher<A6>& m6, const Matcher<A7>& m7) {\n    this->current_spec().SetMatchers(::testing::make_tuple(m1, m2, m3, m4, m5,\n        m6, m7));\n    return this->current_spec();\n  }\n\n  R Invoke(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) {\n    // Even though gcc and MSVC don't enforce it, 'this->' is required\n    // by the C++ standard [14.6.4] here, as the base class type is\n    // dependent on the template argument (and thus shouldn't be\n    // looked into when resolving InvokeWith).\n    return this->InvokeWith(ArgumentTuple(a1, a2, a3, a4, a5, a6, a7));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5, typename A6, typename A7, typename A8>\nclass FunctionMocker<R(A1, A2, A3, A4, A5, A6, A7, A8)> : public\n    internal::FunctionMockerBase<R(A1, A2, A3, A4, A5, A6, A7, A8)> {\n public:\n  typedef R F(A1, A2, A3, A4, A5, A6, A7, A8);\n  typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n\n  MockSpec<F>& With(const Matcher<A1>& m1, const Matcher<A2>& m2,\n      const Matcher<A3>& m3, const Matcher<A4>& m4, const Matcher<A5>& m5,\n      const Matcher<A6>& m6, const Matcher<A7>& m7, const Matcher<A8>& m8) {\n    this->current_spec().SetMatchers(::testing::make_tuple(m1, m2, m3, m4, m5,\n        m6, m7, m8));\n    return this->current_spec();\n  }\n\n  R Invoke(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) {\n    // Even though gcc and MSVC don't enforce it, 'this->' is required\n    // by the C++ standard [14.6.4] here, as the base class type is\n    // dependent on the template argument (and thus shouldn't be\n    // looked into when resolving InvokeWith).\n    return this->InvokeWith(ArgumentTuple(a1, a2, a3, a4, a5, a6, a7, a8));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5, typename A6, typename A7, typename A8, typename A9>\nclass FunctionMocker<R(A1, A2, A3, A4, A5, A6, A7, A8, A9)> : public\n    internal::FunctionMockerBase<R(A1, A2, A3, A4, A5, A6, A7, A8, A9)> {\n public:\n  typedef R F(A1, A2, A3, A4, A5, A6, A7, A8, A9);\n  typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n\n  MockSpec<F>& With(const Matcher<A1>& m1, const Matcher<A2>& m2,\n      const Matcher<A3>& m3, const Matcher<A4>& m4, const Matcher<A5>& m5,\n      const Matcher<A6>& m6, const Matcher<A7>& m7, const Matcher<A8>& m8,\n      const Matcher<A9>& m9) {\n    this->current_spec().SetMatchers(::testing::make_tuple(m1, m2, m3, m4, m5,\n        m6, m7, m8, m9));\n    return this->current_spec();\n  }\n\n  R Invoke(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) {\n    // Even though gcc and MSVC don't enforce it, 'this->' is required\n    // by the C++ standard [14.6.4] here, as the base class type is\n    // dependent on the template argument (and thus shouldn't be\n    // looked into when resolving InvokeWith).\n    return this->InvokeWith(ArgumentTuple(a1, a2, a3, a4, a5, a6, a7, a8, a9));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5, typename A6, typename A7, typename A8, typename A9,\n    typename A10>\nclass FunctionMocker<R(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)> : public\n    internal::FunctionMockerBase<R(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)> {\n public:\n  typedef R F(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);\n  typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n\n  MockSpec<F>& With(const Matcher<A1>& m1, const Matcher<A2>& m2,\n      const Matcher<A3>& m3, const Matcher<A4>& m4, const Matcher<A5>& m5,\n      const Matcher<A6>& m6, const Matcher<A7>& m7, const Matcher<A8>& m8,\n      const Matcher<A9>& m9, const Matcher<A10>& m10) {\n    this->current_spec().SetMatchers(::testing::make_tuple(m1, m2, m3, m4, m5,\n        m6, m7, m8, m9, m10));\n    return this->current_spec();\n  }\n\n  R Invoke(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9,\n      A10 a10) {\n    // Even though gcc and MSVC don't enforce it, 'this->' is required\n    // by the C++ standard [14.6.4] here, as the base class type is\n    // dependent on the template argument (and thus shouldn't be\n    // looked into when resolving InvokeWith).\n    return this->InvokeWith(ArgumentTuple(a1, a2, a3, a4, a5, a6, a7, a8, a9,\n        a10));\n  }\n};\n\n}  // namespace internal\n\n// The style guide prohibits \"using\" statements in a namespace scope\n// inside a header file.  However, the FunctionMocker class template\n// is meant to be defined in the ::testing namespace.  The following\n// line is just a trick for working around a bug in MSVC 8.0, which\n// cannot handle it if we define FunctionMocker in ::testing.\nusing internal::FunctionMocker;\n\n// GMOCK_RESULT_(tn, F) expands to the result type of function type F.\n// We define this as a variadic macro in case F contains unprotected\n// commas (the same reason that we use variadic macros in other places\n// in this file).\n// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!\n#define GMOCK_RESULT_(tn, ...) \\\n    tn ::testing::internal::Function<__VA_ARGS__>::Result\n\n// The type of argument N of the given function type.\n// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!\n#define GMOCK_ARG_(tn, N, ...) \\\n    tn ::testing::internal::Function<__VA_ARGS__>::Argument##N\n\n// The matcher type for argument N of the given function type.\n// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!\n#define GMOCK_MATCHER_(tn, N, ...) \\\n    const ::testing::Matcher<GMOCK_ARG_(tn, N, __VA_ARGS__)>&\n\n// The variable for mocking the given method.\n// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!\n#define GMOCK_MOCKER_(arity, constness, Method) \\\n    GTEST_CONCAT_TOKEN_(gmock##constness##arity##_##Method##_, __LINE__)\n\n// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!\n#define GMOCK_METHOD0_(tn, constness, ct, Method, ...) \\\n  GMOCK_RESULT_(tn, __VA_ARGS__) ct Method( \\\n      ) constness { \\\n    GTEST_COMPILE_ASSERT_((::testing::tuple_size<                          \\\n        tn ::testing::internal::Function<__VA_ARGS__>::ArgumentTuple>::value \\\n            == 0), \\\n        this_method_does_not_take_0_arguments); \\\n    GMOCK_MOCKER_(0, constness, Method).SetOwnerAndName(this, #Method); \\\n    return GMOCK_MOCKER_(0, constness, Method).Invoke(); \\\n  } \\\n  ::testing::MockSpec<__VA_ARGS__>& \\\n      gmock_##Method() constness { \\\n    GMOCK_MOCKER_(0, constness, Method).RegisterOwner(this); \\\n    return GMOCK_MOCKER_(0, constness, Method).With(); \\\n  } \\\n  mutable ::testing::FunctionMocker<__VA_ARGS__> GMOCK_MOCKER_(0, constness, \\\n      Method)\n\n// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!\n#define GMOCK_METHOD1_(tn, constness, ct, Method, ...) \\\n  GMOCK_RESULT_(tn, __VA_ARGS__) ct Method( \\\n      GMOCK_ARG_(tn, 1, __VA_ARGS__) gmock_a1) constness { \\\n    GTEST_COMPILE_ASSERT_((::testing::tuple_size<                          \\\n        tn ::testing::internal::Function<__VA_ARGS__>::ArgumentTuple>::value \\\n            == 1), \\\n        this_method_does_not_take_1_argument); \\\n    GMOCK_MOCKER_(1, constness, Method).SetOwnerAndName(this, #Method); \\\n    return GMOCK_MOCKER_(1, constness, Method).Invoke(gmock_a1); \\\n  } \\\n  ::testing::MockSpec<__VA_ARGS__>& \\\n      gmock_##Method(GMOCK_MATCHER_(tn, 1, __VA_ARGS__) gmock_a1) constness { \\\n    GMOCK_MOCKER_(1, constness, Method).RegisterOwner(this); \\\n    return GMOCK_MOCKER_(1, constness, Method).With(gmock_a1); \\\n  } \\\n  mutable ::testing::FunctionMocker<__VA_ARGS__> GMOCK_MOCKER_(1, constness, \\\n      Method)\n\n// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!\n#define GMOCK_METHOD2_(tn, constness, ct, Method, ...) \\\n  GMOCK_RESULT_(tn, __VA_ARGS__) ct Method( \\\n      GMOCK_ARG_(tn, 1, __VA_ARGS__) gmock_a1, \\\n      GMOCK_ARG_(tn, 2, __VA_ARGS__) gmock_a2) constness { \\\n    GTEST_COMPILE_ASSERT_((::testing::tuple_size<                          \\\n        tn ::testing::internal::Function<__VA_ARGS__>::ArgumentTuple>::value \\\n            == 2), \\\n        this_method_does_not_take_2_arguments); \\\n    GMOCK_MOCKER_(2, constness, Method).SetOwnerAndName(this, #Method); \\\n    return GMOCK_MOCKER_(2, constness, Method).Invoke(gmock_a1, gmock_a2); \\\n  } \\\n  ::testing::MockSpec<__VA_ARGS__>& \\\n      gmock_##Method(GMOCK_MATCHER_(tn, 1, __VA_ARGS__) gmock_a1, \\\n                     GMOCK_MATCHER_(tn, 2, __VA_ARGS__) gmock_a2) constness { \\\n    GMOCK_MOCKER_(2, constness, Method).RegisterOwner(this); \\\n    return GMOCK_MOCKER_(2, constness, Method).With(gmock_a1, gmock_a2); \\\n  } \\\n  mutable ::testing::FunctionMocker<__VA_ARGS__> GMOCK_MOCKER_(2, constness, \\\n      Method)\n\n// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!\n#define GMOCK_METHOD3_(tn, constness, ct, Method, ...) \\\n  GMOCK_RESULT_(tn, __VA_ARGS__) ct Method( \\\n      GMOCK_ARG_(tn, 1, __VA_ARGS__) gmock_a1, \\\n      GMOCK_ARG_(tn, 2, __VA_ARGS__) gmock_a2, \\\n      GMOCK_ARG_(tn, 3, __VA_ARGS__) gmock_a3) constness { \\\n    GTEST_COMPILE_ASSERT_((::testing::tuple_size<                          \\\n        tn ::testing::internal::Function<__VA_ARGS__>::ArgumentTuple>::value \\\n            == 3), \\\n        this_method_does_not_take_3_arguments); \\\n    GMOCK_MOCKER_(3, constness, Method).SetOwnerAndName(this, #Method); \\\n    return GMOCK_MOCKER_(3, constness, Method).Invoke(gmock_a1, gmock_a2, \\\n        gmock_a3); \\\n  } \\\n  ::testing::MockSpec<__VA_ARGS__>& \\\n      gmock_##Method(GMOCK_MATCHER_(tn, 1, __VA_ARGS__) gmock_a1, \\\n                     GMOCK_MATCHER_(tn, 2, __VA_ARGS__) gmock_a2, \\\n                     GMOCK_MATCHER_(tn, 3, __VA_ARGS__) gmock_a3) constness { \\\n    GMOCK_MOCKER_(3, constness, Method).RegisterOwner(this); \\\n    return GMOCK_MOCKER_(3, constness, Method).With(gmock_a1, gmock_a2, \\\n        gmock_a3); \\\n  } \\\n  mutable ::testing::FunctionMocker<__VA_ARGS__> GMOCK_MOCKER_(3, constness, \\\n      Method)\n\n// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!\n#define GMOCK_METHOD4_(tn, constness, ct, Method, ...) \\\n  GMOCK_RESULT_(tn, __VA_ARGS__) ct Method( \\\n      GMOCK_ARG_(tn, 1, __VA_ARGS__) gmock_a1, \\\n      GMOCK_ARG_(tn, 2, __VA_ARGS__) gmock_a2, \\\n      GMOCK_ARG_(tn, 3, __VA_ARGS__) gmock_a3, \\\n      GMOCK_ARG_(tn, 4, __VA_ARGS__) gmock_a4) constness { \\\n    GTEST_COMPILE_ASSERT_((::testing::tuple_size<                          \\\n        tn ::testing::internal::Function<__VA_ARGS__>::ArgumentTuple>::value \\\n            == 4), \\\n        this_method_does_not_take_4_arguments); \\\n    GMOCK_MOCKER_(4, constness, Method).SetOwnerAndName(this, #Method); \\\n    return GMOCK_MOCKER_(4, constness, Method).Invoke(gmock_a1, gmock_a2, \\\n        gmock_a3, gmock_a4); \\\n  } \\\n  ::testing::MockSpec<__VA_ARGS__>& \\\n      gmock_##Method(GMOCK_MATCHER_(tn, 1, __VA_ARGS__) gmock_a1, \\\n                     GMOCK_MATCHER_(tn, 2, __VA_ARGS__) gmock_a2, \\\n                     GMOCK_MATCHER_(tn, 3, __VA_ARGS__) gmock_a3, \\\n                     GMOCK_MATCHER_(tn, 4, __VA_ARGS__) gmock_a4) constness { \\\n    GMOCK_MOCKER_(4, constness, Method).RegisterOwner(this); \\\n    return GMOCK_MOCKER_(4, constness, Method).With(gmock_a1, gmock_a2, \\\n        gmock_a3, gmock_a4); \\\n  } \\\n  mutable ::testing::FunctionMocker<__VA_ARGS__> GMOCK_MOCKER_(4, constness, \\\n      Method)\n\n// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!\n#define GMOCK_METHOD5_(tn, constness, ct, Method, ...) \\\n  GMOCK_RESULT_(tn, __VA_ARGS__) ct Method( \\\n      GMOCK_ARG_(tn, 1, __VA_ARGS__) gmock_a1, \\\n      GMOCK_ARG_(tn, 2, __VA_ARGS__) gmock_a2, \\\n      GMOCK_ARG_(tn, 3, __VA_ARGS__) gmock_a3, \\\n      GMOCK_ARG_(tn, 4, __VA_ARGS__) gmock_a4, \\\n      GMOCK_ARG_(tn, 5, __VA_ARGS__) gmock_a5) constness { \\\n    GTEST_COMPILE_ASSERT_((::testing::tuple_size<                          \\\n        tn ::testing::internal::Function<__VA_ARGS__>::ArgumentTuple>::value \\\n            == 5), \\\n        this_method_does_not_take_5_arguments); \\\n    GMOCK_MOCKER_(5, constness, Method).SetOwnerAndName(this, #Method); \\\n    return GMOCK_MOCKER_(5, constness, Method).Invoke(gmock_a1, gmock_a2, \\\n        gmock_a3, gmock_a4, gmock_a5); \\\n  } \\\n  ::testing::MockSpec<__VA_ARGS__>& \\\n      gmock_##Method(GMOCK_MATCHER_(tn, 1, __VA_ARGS__) gmock_a1, \\\n                     GMOCK_MATCHER_(tn, 2, __VA_ARGS__) gmock_a2, \\\n                     GMOCK_MATCHER_(tn, 3, __VA_ARGS__) gmock_a3, \\\n                     GMOCK_MATCHER_(tn, 4, __VA_ARGS__) gmock_a4, \\\n                     GMOCK_MATCHER_(tn, 5, __VA_ARGS__) gmock_a5) constness { \\\n    GMOCK_MOCKER_(5, constness, Method).RegisterOwner(this); \\\n    return GMOCK_MOCKER_(5, constness, Method).With(gmock_a1, gmock_a2, \\\n        gmock_a3, gmock_a4, gmock_a5); \\\n  } \\\n  mutable ::testing::FunctionMocker<__VA_ARGS__> GMOCK_MOCKER_(5, constness, \\\n      Method)\n\n// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!\n#define GMOCK_METHOD6_(tn, constness, ct, Method, ...) \\\n  GMOCK_RESULT_(tn, __VA_ARGS__) ct Method( \\\n      GMOCK_ARG_(tn, 1, __VA_ARGS__) gmock_a1, \\\n      GMOCK_ARG_(tn, 2, __VA_ARGS__) gmock_a2, \\\n      GMOCK_ARG_(tn, 3, __VA_ARGS__) gmock_a3, \\\n      GMOCK_ARG_(tn, 4, __VA_ARGS__) gmock_a4, \\\n      GMOCK_ARG_(tn, 5, __VA_ARGS__) gmock_a5, \\\n      GMOCK_ARG_(tn, 6, __VA_ARGS__) gmock_a6) constness { \\\n    GTEST_COMPILE_ASSERT_((::testing::tuple_size<                          \\\n        tn ::testing::internal::Function<__VA_ARGS__>::ArgumentTuple>::value \\\n            == 6), \\\n        this_method_does_not_take_6_arguments); \\\n    GMOCK_MOCKER_(6, constness, Method).SetOwnerAndName(this, #Method); \\\n    return GMOCK_MOCKER_(6, constness, Method).Invoke(gmock_a1, gmock_a2, \\\n        gmock_a3, gmock_a4, gmock_a5, gmock_a6); \\\n  } \\\n  ::testing::MockSpec<__VA_ARGS__>& \\\n      gmock_##Method(GMOCK_MATCHER_(tn, 1, __VA_ARGS__) gmock_a1, \\\n                     GMOCK_MATCHER_(tn, 2, __VA_ARGS__) gmock_a2, \\\n                     GMOCK_MATCHER_(tn, 3, __VA_ARGS__) gmock_a3, \\\n                     GMOCK_MATCHER_(tn, 4, __VA_ARGS__) gmock_a4, \\\n                     GMOCK_MATCHER_(tn, 5, __VA_ARGS__) gmock_a5, \\\n                     GMOCK_MATCHER_(tn, 6, __VA_ARGS__) gmock_a6) constness { \\\n    GMOCK_MOCKER_(6, constness, Method).RegisterOwner(this); \\\n    return GMOCK_MOCKER_(6, constness, Method).With(gmock_a1, gmock_a2, \\\n        gmock_a3, gmock_a4, gmock_a5, gmock_a6); \\\n  } \\\n  mutable ::testing::FunctionMocker<__VA_ARGS__> GMOCK_MOCKER_(6, constness, \\\n      Method)\n\n// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!\n#define GMOCK_METHOD7_(tn, constness, ct, Method, ...) \\\n  GMOCK_RESULT_(tn, __VA_ARGS__) ct Method( \\\n      GMOCK_ARG_(tn, 1, __VA_ARGS__) gmock_a1, \\\n      GMOCK_ARG_(tn, 2, __VA_ARGS__) gmock_a2, \\\n      GMOCK_ARG_(tn, 3, __VA_ARGS__) gmock_a3, \\\n      GMOCK_ARG_(tn, 4, __VA_ARGS__) gmock_a4, \\\n      GMOCK_ARG_(tn, 5, __VA_ARGS__) gmock_a5, \\\n      GMOCK_ARG_(tn, 6, __VA_ARGS__) gmock_a6, \\\n      GMOCK_ARG_(tn, 7, __VA_ARGS__) gmock_a7) constness { \\\n    GTEST_COMPILE_ASSERT_((::testing::tuple_size<                          \\\n        tn ::testing::internal::Function<__VA_ARGS__>::ArgumentTuple>::value \\\n            == 7), \\\n        this_method_does_not_take_7_arguments); \\\n    GMOCK_MOCKER_(7, constness, Method).SetOwnerAndName(this, #Method); \\\n    return GMOCK_MOCKER_(7, constness, Method).Invoke(gmock_a1, gmock_a2, \\\n        gmock_a3, gmock_a4, gmock_a5, gmock_a6, gmock_a7); \\\n  } \\\n  ::testing::MockSpec<__VA_ARGS__>& \\\n      gmock_##Method(GMOCK_MATCHER_(tn, 1, __VA_ARGS__) gmock_a1, \\\n                     GMOCK_MATCHER_(tn, 2, __VA_ARGS__) gmock_a2, \\\n                     GMOCK_MATCHER_(tn, 3, __VA_ARGS__) gmock_a3, \\\n                     GMOCK_MATCHER_(tn, 4, __VA_ARGS__) gmock_a4, \\\n                     GMOCK_MATCHER_(tn, 5, __VA_ARGS__) gmock_a5, \\\n                     GMOCK_MATCHER_(tn, 6, __VA_ARGS__) gmock_a6, \\\n                     GMOCK_MATCHER_(tn, 7, __VA_ARGS__) gmock_a7) constness { \\\n    GMOCK_MOCKER_(7, constness, Method).RegisterOwner(this); \\\n    return GMOCK_MOCKER_(7, constness, Method).With(gmock_a1, gmock_a2, \\\n        gmock_a3, gmock_a4, gmock_a5, gmock_a6, gmock_a7); \\\n  } \\\n  mutable ::testing::FunctionMocker<__VA_ARGS__> GMOCK_MOCKER_(7, constness, \\\n      Method)\n\n// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!\n#define GMOCK_METHOD8_(tn, constness, ct, Method, ...) \\\n  GMOCK_RESULT_(tn, __VA_ARGS__) ct Method( \\\n      GMOCK_ARG_(tn, 1, __VA_ARGS__) gmock_a1, \\\n      GMOCK_ARG_(tn, 2, __VA_ARGS__) gmock_a2, \\\n      GMOCK_ARG_(tn, 3, __VA_ARGS__) gmock_a3, \\\n      GMOCK_ARG_(tn, 4, __VA_ARGS__) gmock_a4, \\\n      GMOCK_ARG_(tn, 5, __VA_ARGS__) gmock_a5, \\\n      GMOCK_ARG_(tn, 6, __VA_ARGS__) gmock_a6, \\\n      GMOCK_ARG_(tn, 7, __VA_ARGS__) gmock_a7, \\\n      GMOCK_ARG_(tn, 8, __VA_ARGS__) gmock_a8) constness { \\\n    GTEST_COMPILE_ASSERT_((::testing::tuple_size<                          \\\n        tn ::testing::internal::Function<__VA_ARGS__>::ArgumentTuple>::value \\\n            == 8), \\\n        this_method_does_not_take_8_arguments); \\\n    GMOCK_MOCKER_(8, constness, Method).SetOwnerAndName(this, #Method); \\\n    return GMOCK_MOCKER_(8, constness, Method).Invoke(gmock_a1, gmock_a2, \\\n        gmock_a3, gmock_a4, gmock_a5, gmock_a6, gmock_a7, gmock_a8); \\\n  } \\\n  ::testing::MockSpec<__VA_ARGS__>& \\\n      gmock_##Method(GMOCK_MATCHER_(tn, 1, __VA_ARGS__) gmock_a1, \\\n                     GMOCK_MATCHER_(tn, 2, __VA_ARGS__) gmock_a2, \\\n                     GMOCK_MATCHER_(tn, 3, __VA_ARGS__) gmock_a3, \\\n                     GMOCK_MATCHER_(tn, 4, __VA_ARGS__) gmock_a4, \\\n                     GMOCK_MATCHER_(tn, 5, __VA_ARGS__) gmock_a5, \\\n                     GMOCK_MATCHER_(tn, 6, __VA_ARGS__) gmock_a6, \\\n                     GMOCK_MATCHER_(tn, 7, __VA_ARGS__) gmock_a7, \\\n                     GMOCK_MATCHER_(tn, 8, __VA_ARGS__) gmock_a8) constness { \\\n    GMOCK_MOCKER_(8, constness, Method).RegisterOwner(this); \\\n    return GMOCK_MOCKER_(8, constness, Method).With(gmock_a1, gmock_a2, \\\n        gmock_a3, gmock_a4, gmock_a5, gmock_a6, gmock_a7, gmock_a8); \\\n  } \\\n  mutable ::testing::FunctionMocker<__VA_ARGS__> GMOCK_MOCKER_(8, constness, \\\n      Method)\n\n// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!\n#define GMOCK_METHOD9_(tn, constness, ct, Method, ...) \\\n  GMOCK_RESULT_(tn, __VA_ARGS__) ct Method( \\\n      GMOCK_ARG_(tn, 1, __VA_ARGS__) gmock_a1, \\\n      GMOCK_ARG_(tn, 2, __VA_ARGS__) gmock_a2, \\\n      GMOCK_ARG_(tn, 3, __VA_ARGS__) gmock_a3, \\\n      GMOCK_ARG_(tn, 4, __VA_ARGS__) gmock_a4, \\\n      GMOCK_ARG_(tn, 5, __VA_ARGS__) gmock_a5, \\\n      GMOCK_ARG_(tn, 6, __VA_ARGS__) gmock_a6, \\\n      GMOCK_ARG_(tn, 7, __VA_ARGS__) gmock_a7, \\\n      GMOCK_ARG_(tn, 8, __VA_ARGS__) gmock_a8, \\\n      GMOCK_ARG_(tn, 9, __VA_ARGS__) gmock_a9) constness { \\\n    GTEST_COMPILE_ASSERT_((::testing::tuple_size<                          \\\n        tn ::testing::internal::Function<__VA_ARGS__>::ArgumentTuple>::value \\\n            == 9), \\\n        this_method_does_not_take_9_arguments); \\\n    GMOCK_MOCKER_(9, constness, Method).SetOwnerAndName(this, #Method); \\\n    return GMOCK_MOCKER_(9, constness, Method).Invoke(gmock_a1, gmock_a2, \\\n        gmock_a3, gmock_a4, gmock_a5, gmock_a6, gmock_a7, gmock_a8, \\\n        gmock_a9); \\\n  } \\\n  ::testing::MockSpec<__VA_ARGS__>& \\\n      gmock_##Method(GMOCK_MATCHER_(tn, 1, __VA_ARGS__) gmock_a1, \\\n                     GMOCK_MATCHER_(tn, 2, __VA_ARGS__) gmock_a2, \\\n                     GMOCK_MATCHER_(tn, 3, __VA_ARGS__) gmock_a3, \\\n                     GMOCK_MATCHER_(tn, 4, __VA_ARGS__) gmock_a4, \\\n                     GMOCK_MATCHER_(tn, 5, __VA_ARGS__) gmock_a5, \\\n                     GMOCK_MATCHER_(tn, 6, __VA_ARGS__) gmock_a6, \\\n                     GMOCK_MATCHER_(tn, 7, __VA_ARGS__) gmock_a7, \\\n                     GMOCK_MATCHER_(tn, 8, __VA_ARGS__) gmock_a8, \\\n                     GMOCK_MATCHER_(tn, 9, __VA_ARGS__) gmock_a9) constness { \\\n    GMOCK_MOCKER_(9, constness, Method).RegisterOwner(this); \\\n    return GMOCK_MOCKER_(9, constness, Method).With(gmock_a1, gmock_a2, \\\n        gmock_a3, gmock_a4, gmock_a5, gmock_a6, gmock_a7, gmock_a8, \\\n        gmock_a9); \\\n  } \\\n  mutable ::testing::FunctionMocker<__VA_ARGS__> GMOCK_MOCKER_(9, constness, \\\n      Method)\n\n// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!\n#define GMOCK_METHOD10_(tn, constness, ct, Method, ...) \\\n  GMOCK_RESULT_(tn, __VA_ARGS__) ct Method( \\\n      GMOCK_ARG_(tn, 1, __VA_ARGS__) gmock_a1, \\\n      GMOCK_ARG_(tn, 2, __VA_ARGS__) gmock_a2, \\\n      GMOCK_ARG_(tn, 3, __VA_ARGS__) gmock_a3, \\\n      GMOCK_ARG_(tn, 4, __VA_ARGS__) gmock_a4, \\\n      GMOCK_ARG_(tn, 5, __VA_ARGS__) gmock_a5, \\\n      GMOCK_ARG_(tn, 6, __VA_ARGS__) gmock_a6, \\\n      GMOCK_ARG_(tn, 7, __VA_ARGS__) gmock_a7, \\\n      GMOCK_ARG_(tn, 8, __VA_ARGS__) gmock_a8, \\\n      GMOCK_ARG_(tn, 9, __VA_ARGS__) gmock_a9, \\\n      GMOCK_ARG_(tn, 10, __VA_ARGS__) gmock_a10) constness { \\\n    GTEST_COMPILE_ASSERT_((::testing::tuple_size<                          \\\n        tn ::testing::internal::Function<__VA_ARGS__>::ArgumentTuple>::value \\\n            == 10), \\\n        this_method_does_not_take_10_arguments); \\\n    GMOCK_MOCKER_(10, constness, Method).SetOwnerAndName(this, #Method); \\\n    return GMOCK_MOCKER_(10, constness, Method).Invoke(gmock_a1, gmock_a2, \\\n        gmock_a3, gmock_a4, gmock_a5, gmock_a6, gmock_a7, gmock_a8, gmock_a9, \\\n        gmock_a10); \\\n  } \\\n  ::testing::MockSpec<__VA_ARGS__>& \\\n      gmock_##Method(GMOCK_MATCHER_(tn, 1, __VA_ARGS__) gmock_a1, \\\n                     GMOCK_MATCHER_(tn, 2, __VA_ARGS__) gmock_a2, \\\n                     GMOCK_MATCHER_(tn, 3, __VA_ARGS__) gmock_a3, \\\n                     GMOCK_MATCHER_(tn, 4, __VA_ARGS__) gmock_a4, \\\n                     GMOCK_MATCHER_(tn, 5, __VA_ARGS__) gmock_a5, \\\n                     GMOCK_MATCHER_(tn, 6, __VA_ARGS__) gmock_a6, \\\n                     GMOCK_MATCHER_(tn, 7, __VA_ARGS__) gmock_a7, \\\n                     GMOCK_MATCHER_(tn, 8, __VA_ARGS__) gmock_a8, \\\n                     GMOCK_MATCHER_(tn, 9, __VA_ARGS__) gmock_a9, \\\n                     GMOCK_MATCHER_(tn, 10, \\\n                         __VA_ARGS__) gmock_a10) constness { \\\n    GMOCK_MOCKER_(10, constness, Method).RegisterOwner(this); \\\n    return GMOCK_MOCKER_(10, constness, Method).With(gmock_a1, gmock_a2, \\\n        gmock_a3, gmock_a4, gmock_a5, gmock_a6, gmock_a7, gmock_a8, gmock_a9, \\\n        gmock_a10); \\\n  } \\\n  mutable ::testing::FunctionMocker<__VA_ARGS__> GMOCK_MOCKER_(10, constness, \\\n      Method)\n\n#define MOCK_METHOD0(m, ...) GMOCK_METHOD0_(, , , m, __VA_ARGS__)\n#define MOCK_METHOD1(m, ...) GMOCK_METHOD1_(, , , m, __VA_ARGS__)\n#define MOCK_METHOD2(m, ...) GMOCK_METHOD2_(, , , m, __VA_ARGS__)\n#define MOCK_METHOD3(m, ...) GMOCK_METHOD3_(, , , m, __VA_ARGS__)\n#define MOCK_METHOD4(m, ...) GMOCK_METHOD4_(, , , m, __VA_ARGS__)\n#define MOCK_METHOD5(m, ...) GMOCK_METHOD5_(, , , m, __VA_ARGS__)\n#define MOCK_METHOD6(m, ...) GMOCK_METHOD6_(, , , m, __VA_ARGS__)\n#define MOCK_METHOD7(m, ...) GMOCK_METHOD7_(, , , m, __VA_ARGS__)\n#define MOCK_METHOD8(m, ...) GMOCK_METHOD8_(, , , m, __VA_ARGS__)\n#define MOCK_METHOD9(m, ...) GMOCK_METHOD9_(, , , m, __VA_ARGS__)\n#define MOCK_METHOD10(m, ...) GMOCK_METHOD10_(, , , m, __VA_ARGS__)\n\n#define MOCK_CONST_METHOD0(m, ...) GMOCK_METHOD0_(, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD1(m, ...) GMOCK_METHOD1_(, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD2(m, ...) GMOCK_METHOD2_(, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD3(m, ...) GMOCK_METHOD3_(, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD4(m, ...) GMOCK_METHOD4_(, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD5(m, ...) GMOCK_METHOD5_(, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD6(m, ...) GMOCK_METHOD6_(, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD7(m, ...) GMOCK_METHOD7_(, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD8(m, ...) GMOCK_METHOD8_(, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD9(m, ...) GMOCK_METHOD9_(, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD10(m, ...) GMOCK_METHOD10_(, const, , m, __VA_ARGS__)\n\n#define MOCK_METHOD0_T(m, ...) GMOCK_METHOD0_(typename, , , m, __VA_ARGS__)\n#define MOCK_METHOD1_T(m, ...) GMOCK_METHOD1_(typename, , , m, __VA_ARGS__)\n#define MOCK_METHOD2_T(m, ...) GMOCK_METHOD2_(typename, , , m, __VA_ARGS__)\n#define MOCK_METHOD3_T(m, ...) GMOCK_METHOD3_(typename, , , m, __VA_ARGS__)\n#define MOCK_METHOD4_T(m, ...) GMOCK_METHOD4_(typename, , , m, __VA_ARGS__)\n#define MOCK_METHOD5_T(m, ...) GMOCK_METHOD5_(typename, , , m, __VA_ARGS__)\n#define MOCK_METHOD6_T(m, ...) GMOCK_METHOD6_(typename, , , m, __VA_ARGS__)\n#define MOCK_METHOD7_T(m, ...) GMOCK_METHOD7_(typename, , , m, __VA_ARGS__)\n#define MOCK_METHOD8_T(m, ...) GMOCK_METHOD8_(typename, , , m, __VA_ARGS__)\n#define MOCK_METHOD9_T(m, ...) GMOCK_METHOD9_(typename, , , m, __VA_ARGS__)\n#define MOCK_METHOD10_T(m, ...) GMOCK_METHOD10_(typename, , , m, __VA_ARGS__)\n\n#define MOCK_CONST_METHOD0_T(m, ...) \\\n    GMOCK_METHOD0_(typename, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD1_T(m, ...) \\\n    GMOCK_METHOD1_(typename, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD2_T(m, ...) \\\n    GMOCK_METHOD2_(typename, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD3_T(m, ...) \\\n    GMOCK_METHOD3_(typename, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD4_T(m, ...) \\\n    GMOCK_METHOD4_(typename, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD5_T(m, ...) \\\n    GMOCK_METHOD5_(typename, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD6_T(m, ...) \\\n    GMOCK_METHOD6_(typename, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD7_T(m, ...) \\\n    GMOCK_METHOD7_(typename, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD8_T(m, ...) \\\n    GMOCK_METHOD8_(typename, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD9_T(m, ...) \\\n    GMOCK_METHOD9_(typename, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD10_T(m, ...) \\\n    GMOCK_METHOD10_(typename, const, , m, __VA_ARGS__)\n\n#define MOCK_METHOD0_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD0_(, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD1_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD1_(, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD2_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD2_(, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD3_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD3_(, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD4_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD4_(, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD5_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD5_(, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD6_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD6_(, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD7_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD7_(, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD8_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD8_(, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD9_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD9_(, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD10_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD10_(, , ct, m, __VA_ARGS__)\n\n#define MOCK_CONST_METHOD0_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD0_(, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD1_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD1_(, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD2_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD2_(, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD3_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD3_(, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD4_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD4_(, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD5_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD5_(, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD6_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD6_(, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD7_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD7_(, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD8_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD8_(, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD9_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD9_(, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD10_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD10_(, const, ct, m, __VA_ARGS__)\n\n#define MOCK_METHOD0_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD0_(typename, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD1_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD1_(typename, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD2_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD2_(typename, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD3_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD3_(typename, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD4_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD4_(typename, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD5_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD5_(typename, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD6_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD6_(typename, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD7_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD7_(typename, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD8_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD8_(typename, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD9_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD9_(typename, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD10_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD10_(typename, , ct, m, __VA_ARGS__)\n\n#define MOCK_CONST_METHOD0_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD0_(typename, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD1_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD1_(typename, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD2_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD2_(typename, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD3_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD3_(typename, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD4_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD4_(typename, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD5_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD5_(typename, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD6_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD6_(typename, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD7_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD7_(typename, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD8_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD8_(typename, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD9_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD9_(typename, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD10_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD10_(typename, const, ct, m, __VA_ARGS__)\n\n// A MockFunction<F> class has one mock method whose type is F.  It is\n// useful when you just want your test code to emit some messages and\n// have Google Mock verify the right messages are sent (and perhaps at\n// the right times).  For example, if you are exercising code:\n//\n//   Foo(1);\n//   Foo(2);\n//   Foo(3);\n//\n// and want to verify that Foo(1) and Foo(3) both invoke\n// mock.Bar(\"a\"), but Foo(2) doesn't invoke anything, you can write:\n//\n// TEST(FooTest, InvokesBarCorrectly) {\n//   MyMock mock;\n//   MockFunction<void(string check_point_name)> check;\n//   {\n//     InSequence s;\n//\n//     EXPECT_CALL(mock, Bar(\"a\"));\n//     EXPECT_CALL(check, Call(\"1\"));\n//     EXPECT_CALL(check, Call(\"2\"));\n//     EXPECT_CALL(mock, Bar(\"a\"));\n//   }\n//   Foo(1);\n//   check.Call(\"1\");\n//   Foo(2);\n//   check.Call(\"2\");\n//   Foo(3);\n// }\n//\n// The expectation spec says that the first Bar(\"a\") must happen\n// before check point \"1\", the second Bar(\"a\") must happen after check\n// point \"2\", and nothing should happen between the two check\n// points. The explicit check points make it easy to tell which\n// Bar(\"a\") is called by which call to Foo().\n//\n// MockFunction<F> can also be used to exercise code that accepts\n// std::function<F> callbacks. To do so, use AsStdFunction() method\n// to create std::function proxy forwarding to original object's Call.\n// Example:\n//\n// TEST(FooTest, RunsCallbackWithBarArgument) {\n//   MockFunction<int(string)> callback;\n//   EXPECT_CALL(callback, Call(\"bar\")).WillOnce(Return(1));\n//   Foo(callback.AsStdFunction());\n// }\ntemplate <typename F>\nclass MockFunction;\n\ntemplate <typename R>\nclass MockFunction<R()> {\n public:\n  MockFunction() {}\n\n  MOCK_METHOD0_T(Call, R());\n\n#if GTEST_HAS_STD_FUNCTION_\n  std::function<R()> AsStdFunction() {\n    return [this]() -> R {\n      return this->Call();\n    };\n  }\n#endif  // GTEST_HAS_STD_FUNCTION_\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFunction);\n};\n\ntemplate <typename R, typename A0>\nclass MockFunction<R(A0)> {\n public:\n  MockFunction() {}\n\n  MOCK_METHOD1_T(Call, R(A0));\n\n#if GTEST_HAS_STD_FUNCTION_\n  std::function<R(A0)> AsStdFunction() {\n    return [this](A0 a0) -> R {\n      return this->Call(a0);\n    };\n  }\n#endif  // GTEST_HAS_STD_FUNCTION_\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFunction);\n};\n\ntemplate <typename R, typename A0, typename A1>\nclass MockFunction<R(A0, A1)> {\n public:\n  MockFunction() {}\n\n  MOCK_METHOD2_T(Call, R(A0, A1));\n\n#if GTEST_HAS_STD_FUNCTION_\n  std::function<R(A0, A1)> AsStdFunction() {\n    return [this](A0 a0, A1 a1) -> R {\n      return this->Call(a0, a1);\n    };\n  }\n#endif  // GTEST_HAS_STD_FUNCTION_\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFunction);\n};\n\ntemplate <typename R, typename A0, typename A1, typename A2>\nclass MockFunction<R(A0, A1, A2)> {\n public:\n  MockFunction() {}\n\n  MOCK_METHOD3_T(Call, R(A0, A1, A2));\n\n#if GTEST_HAS_STD_FUNCTION_\n  std::function<R(A0, A1, A2)> AsStdFunction() {\n    return [this](A0 a0, A1 a1, A2 a2) -> R {\n      return this->Call(a0, a1, a2);\n    };\n  }\n#endif  // GTEST_HAS_STD_FUNCTION_\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFunction);\n};\n\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nclass MockFunction<R(A0, A1, A2, A3)> {\n public:\n  MockFunction() {}\n\n  MOCK_METHOD4_T(Call, R(A0, A1, A2, A3));\n\n#if GTEST_HAS_STD_FUNCTION_\n  std::function<R(A0, A1, A2, A3)> AsStdFunction() {\n    return [this](A0 a0, A1 a1, A2 a2, A3 a3) -> R {\n      return this->Call(a0, a1, a2, a3);\n    };\n  }\n#endif  // GTEST_HAS_STD_FUNCTION_\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFunction);\n};\n\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3,\n    typename A4>\nclass MockFunction<R(A0, A1, A2, A3, A4)> {\n public:\n  MockFunction() {}\n\n  MOCK_METHOD5_T(Call, R(A0, A1, A2, A3, A4));\n\n#if GTEST_HAS_STD_FUNCTION_\n  std::function<R(A0, A1, A2, A3, A4)> AsStdFunction() {\n    return [this](A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) -> R {\n      return this->Call(a0, a1, a2, a3, a4);\n    };\n  }\n#endif  // GTEST_HAS_STD_FUNCTION_\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFunction);\n};\n\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3,\n    typename A4, typename A5>\nclass MockFunction<R(A0, A1, A2, A3, A4, A5)> {\n public:\n  MockFunction() {}\n\n  MOCK_METHOD6_T(Call, R(A0, A1, A2, A3, A4, A5));\n\n#if GTEST_HAS_STD_FUNCTION_\n  std::function<R(A0, A1, A2, A3, A4, A5)> AsStdFunction() {\n    return [this](A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) -> R {\n      return this->Call(a0, a1, a2, a3, a4, a5);\n    };\n  }\n#endif  // GTEST_HAS_STD_FUNCTION_\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFunction);\n};\n\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3,\n    typename A4, typename A5, typename A6>\nclass MockFunction<R(A0, A1, A2, A3, A4, A5, A6)> {\n public:\n  MockFunction() {}\n\n  MOCK_METHOD7_T(Call, R(A0, A1, A2, A3, A4, A5, A6));\n\n#if GTEST_HAS_STD_FUNCTION_\n  std::function<R(A0, A1, A2, A3, A4, A5, A6)> AsStdFunction() {\n    return [this](A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) -> R {\n      return this->Call(a0, a1, a2, a3, a4, a5, a6);\n    };\n  }\n#endif  // GTEST_HAS_STD_FUNCTION_\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFunction);\n};\n\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3,\n    typename A4, typename A5, typename A6, typename A7>\nclass MockFunction<R(A0, A1, A2, A3, A4, A5, A6, A7)> {\n public:\n  MockFunction() {}\n\n  MOCK_METHOD8_T(Call, R(A0, A1, A2, A3, A4, A5, A6, A7));\n\n#if GTEST_HAS_STD_FUNCTION_\n  std::function<R(A0, A1, A2, A3, A4, A5, A6, A7)> AsStdFunction() {\n    return [this](A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) -> R {\n      return this->Call(a0, a1, a2, a3, a4, a5, a6, a7);\n    };\n  }\n#endif  // GTEST_HAS_STD_FUNCTION_\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFunction);\n};\n\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3,\n    typename A4, typename A5, typename A6, typename A7, typename A8>\nclass MockFunction<R(A0, A1, A2, A3, A4, A5, A6, A7, A8)> {\n public:\n  MockFunction() {}\n\n  MOCK_METHOD9_T(Call, R(A0, A1, A2, A3, A4, A5, A6, A7, A8));\n\n#if GTEST_HAS_STD_FUNCTION_\n  std::function<R(A0, A1, A2, A3, A4, A5, A6, A7, A8)> AsStdFunction() {\n    return [this](A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7,\n        A8 a8) -> R {\n      return this->Call(a0, a1, a2, a3, a4, a5, a6, a7, a8);\n    };\n  }\n#endif  // GTEST_HAS_STD_FUNCTION_\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFunction);\n};\n\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3,\n    typename A4, typename A5, typename A6, typename A7, typename A8,\n    typename A9>\nclass MockFunction<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)> {\n public:\n  MockFunction() {}\n\n  MOCK_METHOD10_T(Call, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));\n\n#if GTEST_HAS_STD_FUNCTION_\n  std::function<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)> AsStdFunction() {\n    return [this](A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7,\n        A8 a8, A9 a9) -> R {\n      return this->Call(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);\n    };\n  }\n#endif  // GTEST_HAS_STD_FUNCTION_\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFunction);\n};\n\n}  // namespace testing\n\n#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_FUNCTION_MOCKERS_H_\n"}, "35": {"id": 35, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-generated-matchers.h", "content": "// This file was GENERATED by command:\n//     pump.py gmock-generated-matchers.h.pump\n// DO NOT EDIT BY HAND!!!\n\n// Copyright 2008, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// Google Mock - a framework for writing C++ mock classes.\n//\n// This file implements some commonly used variadic matchers.\n\n// IWYU pragma: private, include \"gmock/gmock.h\"\n\n#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_MATCHERS_H_\n#define GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_MATCHERS_H_\n\n#include <iterator>\n#include <sstream>\n#include <string>\n#include <vector>\n#include \"gmock/gmock-matchers.h\"\n\nnamespace testing {\nnamespace internal {\n\n// The type of the i-th (0-based) field of Tuple.\n#define GMOCK_FIELD_TYPE_(Tuple, i) \\\n    typename ::testing::tuple_element<i, Tuple>::type\n\n// TupleFields<Tuple, k0, ..., kn> is for selecting fields from a\n// tuple of type Tuple.  It has two members:\n//\n//   type: a tuple type whose i-th field is the ki-th field of Tuple.\n//   GetSelectedFields(t): returns fields k0, ..., and kn of t as a tuple.\n//\n// For example, in class TupleFields<tuple<bool, char, int>, 2, 0>, we have:\n//\n//   type is tuple<int, bool>, and\n//   GetSelectedFields(make_tuple(true, 'a', 42)) is (42, true).\n\ntemplate <class Tuple, int k0 = -1, int k1 = -1, int k2 = -1, int k3 = -1,\n    int k4 = -1, int k5 = -1, int k6 = -1, int k7 = -1, int k8 = -1,\n    int k9 = -1>\nclass TupleFields;\n\n// This generic version is used when there are 10 selectors.\ntemplate <class Tuple, int k0, int k1, int k2, int k3, int k4, int k5, int k6,\n    int k7, int k8, int k9>\nclass TupleFields {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2),\n      GMOCK_FIELD_TYPE_(Tuple, k3), GMOCK_FIELD_TYPE_(Tuple, k4),\n      GMOCK_FIELD_TYPE_(Tuple, k5), GMOCK_FIELD_TYPE_(Tuple, k6),\n      GMOCK_FIELD_TYPE_(Tuple, k7), GMOCK_FIELD_TYPE_(Tuple, k8),\n      GMOCK_FIELD_TYPE_(Tuple, k9)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t), get<k2>(t), get<k3>(t), get<k4>(t),\n        get<k5>(t), get<k6>(t), get<k7>(t), get<k8>(t), get<k9>(t));\n  }\n};\n\n// The following specialization is used for 0 ~ 9 selectors.\n\ntemplate <class Tuple>\nclass TupleFields<Tuple, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1> {\n public:\n  typedef ::testing::tuple<> type;\n  static type GetSelectedFields(const Tuple& /* t */) {\n    return type();\n  }\n};\n\ntemplate <class Tuple, int k0>\nclass TupleFields<Tuple, k0, -1, -1, -1, -1, -1, -1, -1, -1, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t));\n  }\n};\n\ntemplate <class Tuple, int k0, int k1>\nclass TupleFields<Tuple, k0, k1, -1, -1, -1, -1, -1, -1, -1, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t));\n  }\n};\n\ntemplate <class Tuple, int k0, int k1, int k2>\nclass TupleFields<Tuple, k0, k1, k2, -1, -1, -1, -1, -1, -1, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t), get<k2>(t));\n  }\n};\n\ntemplate <class Tuple, int k0, int k1, int k2, int k3>\nclass TupleFields<Tuple, k0, k1, k2, k3, -1, -1, -1, -1, -1, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2),\n      GMOCK_FIELD_TYPE_(Tuple, k3)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t), get<k2>(t), get<k3>(t));\n  }\n};\n\ntemplate <class Tuple, int k0, int k1, int k2, int k3, int k4>\nclass TupleFields<Tuple, k0, k1, k2, k3, k4, -1, -1, -1, -1, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2),\n      GMOCK_FIELD_TYPE_(Tuple, k3), GMOCK_FIELD_TYPE_(Tuple, k4)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t), get<k2>(t), get<k3>(t), get<k4>(t));\n  }\n};\n\ntemplate <class Tuple, int k0, int k1, int k2, int k3, int k4, int k5>\nclass TupleFields<Tuple, k0, k1, k2, k3, k4, k5, -1, -1, -1, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2),\n      GMOCK_FIELD_TYPE_(Tuple, k3), GMOCK_FIELD_TYPE_(Tuple, k4),\n      GMOCK_FIELD_TYPE_(Tuple, k5)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t), get<k2>(t), get<k3>(t), get<k4>(t),\n        get<k5>(t));\n  }\n};\n\ntemplate <class Tuple, int k0, int k1, int k2, int k3, int k4, int k5, int k6>\nclass TupleFields<Tuple, k0, k1, k2, k3, k4, k5, k6, -1, -1, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2),\n      GMOCK_FIELD_TYPE_(Tuple, k3), GMOCK_FIELD_TYPE_(Tuple, k4),\n      GMOCK_FIELD_TYPE_(Tuple, k5), GMOCK_FIELD_TYPE_(Tuple, k6)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t), get<k2>(t), get<k3>(t), get<k4>(t),\n        get<k5>(t), get<k6>(t));\n  }\n};\n\ntemplate <class Tuple, int k0, int k1, int k2, int k3, int k4, int k5, int k6,\n    int k7>\nclass TupleFields<Tuple, k0, k1, k2, k3, k4, k5, k6, k7, -1, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2),\n      GMOCK_FIELD_TYPE_(Tuple, k3), GMOCK_FIELD_TYPE_(Tuple, k4),\n      GMOCK_FIELD_TYPE_(Tuple, k5), GMOCK_FIELD_TYPE_(Tuple, k6),\n      GMOCK_FIELD_TYPE_(Tuple, k7)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t), get<k2>(t), get<k3>(t), get<k4>(t),\n        get<k5>(t), get<k6>(t), get<k7>(t));\n  }\n};\n\ntemplate <class Tuple, int k0, int k1, int k2, int k3, int k4, int k5, int k6,\n    int k7, int k8>\nclass TupleFields<Tuple, k0, k1, k2, k3, k4, k5, k6, k7, k8, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2),\n      GMOCK_FIELD_TYPE_(Tuple, k3), GMOCK_FIELD_TYPE_(Tuple, k4),\n      GMOCK_FIELD_TYPE_(Tuple, k5), GMOCK_FIELD_TYPE_(Tuple, k6),\n      GMOCK_FIELD_TYPE_(Tuple, k7), GMOCK_FIELD_TYPE_(Tuple, k8)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t), get<k2>(t), get<k3>(t), get<k4>(t),\n        get<k5>(t), get<k6>(t), get<k7>(t), get<k8>(t));\n  }\n};\n\n#undef GMOCK_FIELD_TYPE_\n\n// Implements the Args() matcher.\ntemplate <class ArgsTuple, int k0 = -1, int k1 = -1, int k2 = -1, int k3 = -1,\n    int k4 = -1, int k5 = -1, int k6 = -1, int k7 = -1, int k8 = -1,\n    int k9 = -1>\nclass ArgsMatcherImpl : public MatcherInterface<ArgsTuple> {\n public:\n  // ArgsTuple may have top-level const or reference modifiers.\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(ArgsTuple) RawArgsTuple;\n  typedef typename internal::TupleFields<RawArgsTuple, k0, k1, k2, k3, k4, k5,\n      k6, k7, k8, k9>::type SelectedArgs;\n  typedef Matcher<const SelectedArgs&> MonomorphicInnerMatcher;\n\n  template <typename InnerMatcher>\n  explicit ArgsMatcherImpl(const InnerMatcher& inner_matcher)\n      : inner_matcher_(SafeMatcherCast<const SelectedArgs&>(inner_matcher)) {}\n\n  virtual bool MatchAndExplain(ArgsTuple args,\n                               MatchResultListener* listener) const {\n    const SelectedArgs& selected_args = GetSelectedArgs(args);\n    if (!listener->IsInterested())\n      return inner_matcher_.Matches(selected_args);\n\n    PrintIndices(listener->stream());\n    *listener << \"are \" << PrintToString(selected_args);\n\n    StringMatchResultListener inner_listener;\n    const bool match = inner_matcher_.MatchAndExplain(selected_args,\n                                                      &inner_listener);\n    PrintIfNotEmpty(inner_listener.str(), listener->stream());\n    return match;\n  }\n\n  virtual void DescribeTo(::std::ostream* os) const {\n    *os << \"are a tuple \";\n    PrintIndices(os);\n    inner_matcher_.DescribeTo(os);\n  }\n\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"are a tuple \";\n    PrintIndices(os);\n    inner_matcher_.DescribeNegationTo(os);\n  }\n\n private:\n  static SelectedArgs GetSelectedArgs(ArgsTuple args) {\n    return TupleFields<RawArgsTuple, k0, k1, k2, k3, k4, k5, k6, k7, k8,\n        k9>::GetSelectedFields(args);\n  }\n\n  // Prints the indices of the selected fields.\n  static void PrintIndices(::std::ostream* os) {\n    *os << \"whose fields (\";\n    const int indices[10] = { k0, k1, k2, k3, k4, k5, k6, k7, k8, k9 };\n    for (int i = 0; i < 10; i++) {\n      if (indices[i] < 0)\n        break;\n\n      if (i >= 1)\n        *os << \", \";\n\n      *os << \"#\" << indices[i];\n    }\n    *os << \") \";\n  }\n\n  const MonomorphicInnerMatcher inner_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(ArgsMatcherImpl);\n};\n\ntemplate <class InnerMatcher, int k0 = -1, int k1 = -1, int k2 = -1,\n    int k3 = -1, int k4 = -1, int k5 = -1, int k6 = -1, int k7 = -1,\n    int k8 = -1, int k9 = -1>\nclass ArgsMatcher {\n public:\n  explicit ArgsMatcher(const InnerMatcher& inner_matcher)\n      : inner_matcher_(inner_matcher) {}\n\n  template <typename ArgsTuple>\n  operator Matcher<ArgsTuple>() const {\n    return MakeMatcher(new ArgsMatcherImpl<ArgsTuple, k0, k1, k2, k3, k4, k5,\n        k6, k7, k8, k9>(inner_matcher_));\n  }\n\n private:\n  const InnerMatcher inner_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(ArgsMatcher);\n};\n\n// A set of metafunctions for computing the result type of AllOf.\n// AllOf(m1, ..., mN) returns\n// AllOfResultN<decltype(m1), ..., decltype(mN)>::type.\n\n// Although AllOf isn't defined for one argument, AllOfResult1 is defined\n// to simplify the implementation.\ntemplate <typename M1>\nstruct AllOfResult1 {\n  typedef M1 type;\n};\n\ntemplate <typename M1, typename M2>\nstruct AllOfResult2 {\n  typedef BothOfMatcher<\n      typename AllOfResult1<M1>::type,\n      typename AllOfResult1<M2>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3>\nstruct AllOfResult3 {\n  typedef BothOfMatcher<\n      typename AllOfResult1<M1>::type,\n      typename AllOfResult2<M2, M3>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4>\nstruct AllOfResult4 {\n  typedef BothOfMatcher<\n      typename AllOfResult2<M1, M2>::type,\n      typename AllOfResult2<M3, M4>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5>\nstruct AllOfResult5 {\n  typedef BothOfMatcher<\n      typename AllOfResult2<M1, M2>::type,\n      typename AllOfResult3<M3, M4, M5>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6>\nstruct AllOfResult6 {\n  typedef BothOfMatcher<\n      typename AllOfResult3<M1, M2, M3>::type,\n      typename AllOfResult3<M4, M5, M6>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7>\nstruct AllOfResult7 {\n  typedef BothOfMatcher<\n      typename AllOfResult3<M1, M2, M3>::type,\n      typename AllOfResult4<M4, M5, M6, M7>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8>\nstruct AllOfResult8 {\n  typedef BothOfMatcher<\n      typename AllOfResult4<M1, M2, M3, M4>::type,\n      typename AllOfResult4<M5, M6, M7, M8>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8, typename M9>\nstruct AllOfResult9 {\n  typedef BothOfMatcher<\n      typename AllOfResult4<M1, M2, M3, M4>::type,\n      typename AllOfResult5<M5, M6, M7, M8, M9>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8, typename M9, typename M10>\nstruct AllOfResult10 {\n  typedef BothOfMatcher<\n      typename AllOfResult5<M1, M2, M3, M4, M5>::type,\n      typename AllOfResult5<M6, M7, M8, M9, M10>::type\n  > type;\n};\n\n// A set of metafunctions for computing the result type of AnyOf.\n// AnyOf(m1, ..., mN) returns\n// AnyOfResultN<decltype(m1), ..., decltype(mN)>::type.\n\n// Although AnyOf isn't defined for one argument, AnyOfResult1 is defined\n// to simplify the implementation.\ntemplate <typename M1>\nstruct AnyOfResult1 {\n  typedef M1 type;\n};\n\ntemplate <typename M1, typename M2>\nstruct AnyOfResult2 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult1<M1>::type,\n      typename AnyOfResult1<M2>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3>\nstruct AnyOfResult3 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult1<M1>::type,\n      typename AnyOfResult2<M2, M3>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4>\nstruct AnyOfResult4 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult2<M1, M2>::type,\n      typename AnyOfResult2<M3, M4>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5>\nstruct AnyOfResult5 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult2<M1, M2>::type,\n      typename AnyOfResult3<M3, M4, M5>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6>\nstruct AnyOfResult6 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult3<M1, M2, M3>::type,\n      typename AnyOfResult3<M4, M5, M6>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7>\nstruct AnyOfResult7 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult3<M1, M2, M3>::type,\n      typename AnyOfResult4<M4, M5, M6, M7>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8>\nstruct AnyOfResult8 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult4<M1, M2, M3, M4>::type,\n      typename AnyOfResult4<M5, M6, M7, M8>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8, typename M9>\nstruct AnyOfResult9 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult4<M1, M2, M3, M4>::type,\n      typename AnyOfResult5<M5, M6, M7, M8, M9>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8, typename M9, typename M10>\nstruct AnyOfResult10 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult5<M1, M2, M3, M4, M5>::type,\n      typename AnyOfResult5<M6, M7, M8, M9, M10>::type\n  > type;\n};\n\n}  // namespace internal\n\n// Args<N1, N2, ..., Nk>(a_matcher) matches a tuple if the selected\n// fields of it matches a_matcher.  C++ doesn't support default\n// arguments for function templates, so we have to overload it.\ntemplate <typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher>(matcher);\n}\n\ntemplate <int k1, typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1>(matcher);\n}\n\ntemplate <int k1, int k2, typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2>(matcher);\n}\n\ntemplate <int k1, int k2, int k3, typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2, k3>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2, k3>(matcher);\n}\n\ntemplate <int k1, int k2, int k3, int k4, typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4>(matcher);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5>(matcher);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, int k6, typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6>(matcher);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, int k6, int k7,\n    typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6, k7>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6,\n      k7>(matcher);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, int k6, int k7, int k8,\n    typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6, k7, k8>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6, k7,\n      k8>(matcher);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, int k6, int k7, int k8,\n    int k9, typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6, k7, k8, k9>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6, k7, k8,\n      k9>(matcher);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, int k6, int k7, int k8,\n    int k9, int k10, typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6, k7, k8, k9,\n    k10>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6, k7, k8,\n      k9, k10>(matcher);\n}\n\n// ElementsAre(e_1, e_2, ... e_n) matches an STL-style container with\n// n elements, where the i-th element in the container must\n// match the i-th argument in the list.  Each argument of\n// ElementsAre() can be either a value or a matcher.  We support up to\n// 10 arguments.\n//\n// The use of DecayArray in the implementation allows ElementsAre()\n// to accept string literals, whose type is const char[N], but we\n// want to treat them as const char*.\n//\n// NOTE: Since ElementsAre() cares about the order of the elements, it\n// must not be used with containers whose elements's order is\n// undefined (e.g. hash_map).\n\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<> >\nElementsAre() {\n  typedef ::testing::tuple<> Args;\n  return internal::ElementsAreMatcher<Args>(Args());\n}\n\ntemplate <typename T1>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type> >\nElementsAre(const T1& e1) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1));\n}\n\ntemplate <typename T1, typename T2>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type> >\nElementsAre(const T1& e1, const T2& e2) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2));\n}\n\ntemplate <typename T1, typename T2, typename T3>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type> >\nElementsAre(const T1& e1, const T2& e2, const T3& e3) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2, e3));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type> >\nElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2, e3, e4));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type> >\nElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type> >\nElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5, e6));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type,\n        typename internal::DecayArray<T7>::type> >\nElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6, const T7& e7) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type,\n      typename internal::DecayArray<T7>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5, e6, e7));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type,\n        typename internal::DecayArray<T7>::type,\n        typename internal::DecayArray<T8>::type> >\nElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6, const T7& e7, const T8& e8) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type,\n      typename internal::DecayArray<T7>::type,\n      typename internal::DecayArray<T8>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5, e6, e7,\n      e8));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type,\n        typename internal::DecayArray<T7>::type,\n        typename internal::DecayArray<T8>::type,\n        typename internal::DecayArray<T9>::type> >\nElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6, const T7& e7, const T8& e8, const T9& e9) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type,\n      typename internal::DecayArray<T7>::type,\n      typename internal::DecayArray<T8>::type,\n      typename internal::DecayArray<T9>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5, e6, e7,\n      e8, e9));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type,\n        typename internal::DecayArray<T7>::type,\n        typename internal::DecayArray<T8>::type,\n        typename internal::DecayArray<T9>::type,\n        typename internal::DecayArray<T10>::type> >\nElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6, const T7& e7, const T8& e8, const T9& e9,\n    const T10& e10) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type,\n      typename internal::DecayArray<T7>::type,\n      typename internal::DecayArray<T8>::type,\n      typename internal::DecayArray<T9>::type,\n      typename internal::DecayArray<T10>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5, e6, e7,\n      e8, e9, e10));\n}\n\n// UnorderedElementsAre(e_1, e_2, ..., e_n) is an ElementsAre extension\n// that matches n elements in any order.  We support up to n=10 arguments.\n\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<> >\nUnorderedElementsAre() {\n  typedef ::testing::tuple<> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args());\n}\n\ntemplate <typename T1>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type> >\nUnorderedElementsAre(const T1& e1) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1));\n}\n\ntemplate <typename T1, typename T2>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2));\n}\n\ntemplate <typename T1, typename T2, typename T3>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2, const T3& e3) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2, e3));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2, e3, e4));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5,\n      e6));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type,\n        typename internal::DecayArray<T7>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6, const T7& e7) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type,\n      typename internal::DecayArray<T7>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5,\n      e6, e7));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type,\n        typename internal::DecayArray<T7>::type,\n        typename internal::DecayArray<T8>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6, const T7& e7, const T8& e8) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type,\n      typename internal::DecayArray<T7>::type,\n      typename internal::DecayArray<T8>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5,\n      e6, e7, e8));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type,\n        typename internal::DecayArray<T7>::type,\n        typename internal::DecayArray<T8>::type,\n        typename internal::DecayArray<T9>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6, const T7& e7, const T8& e8, const T9& e9) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type,\n      typename internal::DecayArray<T7>::type,\n      typename internal::DecayArray<T8>::type,\n      typename internal::DecayArray<T9>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5,\n      e6, e7, e8, e9));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type,\n        typename internal::DecayArray<T7>::type,\n        typename internal::DecayArray<T8>::type,\n        typename internal::DecayArray<T9>::type,\n        typename internal::DecayArray<T10>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6, const T7& e7, const T8& e8, const T9& e9,\n    const T10& e10) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type,\n      typename internal::DecayArray<T7>::type,\n      typename internal::DecayArray<T8>::type,\n      typename internal::DecayArray<T9>::type,\n      typename internal::DecayArray<T10>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5,\n      e6, e7, e8, e9, e10));\n}\n\n// AllOf(m1, m2, ..., mk) matches any value that matches all of the given\n// sub-matchers.  AllOf is called fully qualified to prevent ADL from firing.\n\ntemplate <typename M1, typename M2>\ninline typename internal::AllOfResult2<M1, M2>::type\nAllOf(M1 m1, M2 m2) {\n  return typename internal::AllOfResult2<M1, M2>::type(\n      m1,\n      m2);\n}\n\ntemplate <typename M1, typename M2, typename M3>\ninline typename internal::AllOfResult3<M1, M2, M3>::type\nAllOf(M1 m1, M2 m2, M3 m3) {\n  return typename internal::AllOfResult3<M1, M2, M3>::type(\n      m1,\n      ::testing::AllOf(m2, m3));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4>\ninline typename internal::AllOfResult4<M1, M2, M3, M4>::type\nAllOf(M1 m1, M2 m2, M3 m3, M4 m4) {\n  return typename internal::AllOfResult4<M1, M2, M3, M4>::type(\n      ::testing::AllOf(m1, m2),\n      ::testing::AllOf(m3, m4));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5>\ninline typename internal::AllOfResult5<M1, M2, M3, M4, M5>::type\nAllOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5) {\n  return typename internal::AllOfResult5<M1, M2, M3, M4, M5>::type(\n      ::testing::AllOf(m1, m2),\n      ::testing::AllOf(m3, m4, m5));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6>\ninline typename internal::AllOfResult6<M1, M2, M3, M4, M5, M6>::type\nAllOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6) {\n  return typename internal::AllOfResult6<M1, M2, M3, M4, M5, M6>::type(\n      ::testing::AllOf(m1, m2, m3),\n      ::testing::AllOf(m4, m5, m6));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7>\ninline typename internal::AllOfResult7<M1, M2, M3, M4, M5, M6, M7>::type\nAllOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7) {\n  return typename internal::AllOfResult7<M1, M2, M3, M4, M5, M6, M7>::type(\n      ::testing::AllOf(m1, m2, m3),\n      ::testing::AllOf(m4, m5, m6, m7));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8>\ninline typename internal::AllOfResult8<M1, M2, M3, M4, M5, M6, M7, M8>::type\nAllOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8) {\n  return typename internal::AllOfResult8<M1, M2, M3, M4, M5, M6, M7, M8>::type(\n      ::testing::AllOf(m1, m2, m3, m4),\n      ::testing::AllOf(m5, m6, m7, m8));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8, typename M9>\ninline typename internal::AllOfResult9<M1, M2, M3, M4, M5, M6, M7, M8, M9>::type\nAllOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8, M9 m9) {\n  return typename internal::AllOfResult9<M1, M2, M3, M4, M5, M6, M7, M8,\n      M9>::type(\n      ::testing::AllOf(m1, m2, m3, m4),\n      ::testing::AllOf(m5, m6, m7, m8, m9));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8, typename M9, typename M10>\ninline typename internal::AllOfResult10<M1, M2, M3, M4, M5, M6, M7, M8, M9,\n    M10>::type\nAllOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8, M9 m9, M10 m10) {\n  return typename internal::AllOfResult10<M1, M2, M3, M4, M5, M6, M7, M8, M9,\n      M10>::type(\n      ::testing::AllOf(m1, m2, m3, m4, m5),\n      ::testing::AllOf(m6, m7, m8, m9, m10));\n}\n\n// AnyOf(m1, m2, ..., mk) matches any value that matches any of the given\n// sub-matchers.  AnyOf is called fully qualified to prevent ADL from firing.\n\ntemplate <typename M1, typename M2>\ninline typename internal::AnyOfResult2<M1, M2>::type\nAnyOf(M1 m1, M2 m2) {\n  return typename internal::AnyOfResult2<M1, M2>::type(\n      m1,\n      m2);\n}\n\ntemplate <typename M1, typename M2, typename M3>\ninline typename internal::AnyOfResult3<M1, M2, M3>::type\nAnyOf(M1 m1, M2 m2, M3 m3) {\n  return typename internal::AnyOfResult3<M1, M2, M3>::type(\n      m1,\n      ::testing::AnyOf(m2, m3));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4>\ninline typename internal::AnyOfResult4<M1, M2, M3, M4>::type\nAnyOf(M1 m1, M2 m2, M3 m3, M4 m4) {\n  return typename internal::AnyOfResult4<M1, M2, M3, M4>::type(\n      ::testing::AnyOf(m1, m2),\n      ::testing::AnyOf(m3, m4));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5>\ninline typename internal::AnyOfResult5<M1, M2, M3, M4, M5>::type\nAnyOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5) {\n  return typename internal::AnyOfResult5<M1, M2, M3, M4, M5>::type(\n      ::testing::AnyOf(m1, m2),\n      ::testing::AnyOf(m3, m4, m5));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6>\ninline typename internal::AnyOfResult6<M1, M2, M3, M4, M5, M6>::type\nAnyOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6) {\n  return typename internal::AnyOfResult6<M1, M2, M3, M4, M5, M6>::type(\n      ::testing::AnyOf(m1, m2, m3),\n      ::testing::AnyOf(m4, m5, m6));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7>\ninline typename internal::AnyOfResult7<M1, M2, M3, M4, M5, M6, M7>::type\nAnyOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7) {\n  return typename internal::AnyOfResult7<M1, M2, M3, M4, M5, M6, M7>::type(\n      ::testing::AnyOf(m1, m2, m3),\n      ::testing::AnyOf(m4, m5, m6, m7));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8>\ninline typename internal::AnyOfResult8<M1, M2, M3, M4, M5, M6, M7, M8>::type\nAnyOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8) {\n  return typename internal::AnyOfResult8<M1, M2, M3, M4, M5, M6, M7, M8>::type(\n      ::testing::AnyOf(m1, m2, m3, m4),\n      ::testing::AnyOf(m5, m6, m7, m8));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8, typename M9>\ninline typename internal::AnyOfResult9<M1, M2, M3, M4, M5, M6, M7, M8, M9>::type\nAnyOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8, M9 m9) {\n  return typename internal::AnyOfResult9<M1, M2, M3, M4, M5, M6, M7, M8,\n      M9>::type(\n      ::testing::AnyOf(m1, m2, m3, m4),\n      ::testing::AnyOf(m5, m6, m7, m8, m9));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8, typename M9, typename M10>\ninline typename internal::AnyOfResult10<M1, M2, M3, M4, M5, M6, M7, M8, M9,\n    M10>::type\nAnyOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8, M9 m9, M10 m10) {\n  return typename internal::AnyOfResult10<M1, M2, M3, M4, M5, M6, M7, M8, M9,\n      M10>::type(\n      ::testing::AnyOf(m1, m2, m3, m4, m5),\n      ::testing::AnyOf(m6, m7, m8, m9, m10));\n}\n\n}  // namespace testing\n\n\n// The MATCHER* family of macros can be used in a namespace scope to\n// define custom matchers easily.\n//\n// Basic Usage\n// ===========\n//\n// The syntax\n//\n//   MATCHER(name, description_string) { statements; }\n//\n// defines a matcher with the given name that executes the statements,\n// which must return a bool to indicate if the match succeeds.  Inside\n// the statements, you can refer to the value being matched by 'arg',\n// and refer to its type by 'arg_type'.\n//\n// The description string documents what the matcher does, and is used\n// to generate the failure message when the match fails.  Since a\n// MATCHER() is usually defined in a header file shared by multiple\n// C++ source files, we require the description to be a C-string\n// literal to avoid possible side effects.  It can be empty, in which\n// case we'll use the sequence of words in the matcher name as the\n// description.\n//\n// For example:\n//\n//   MATCHER(IsEven, \"\") { return (arg % 2) == 0; }\n//\n// allows you to write\n//\n//   // Expects mock_foo.Bar(n) to be called where n is even.\n//   EXPECT_CALL(mock_foo, Bar(IsEven()));\n//\n// or,\n//\n//   // Verifies that the value of some_expression is even.\n//   EXPECT_THAT(some_expression, IsEven());\n//\n// If the above assertion fails, it will print something like:\n//\n//   Value of: some_expression\n//   Expected: is even\n//     Actual: 7\n//\n// where the description \"is even\" is automatically calculated from the\n// matcher name IsEven.\n//\n// Argument Type\n// =============\n//\n// Note that the type of the value being matched (arg_type) is\n// determined by the context in which you use the matcher and is\n// supplied to you by the compiler, so you don't need to worry about\n// declaring it (nor can you).  This allows the matcher to be\n// polymorphic.  For example, IsEven() can be used to match any type\n// where the value of \"(arg % 2) == 0\" can be implicitly converted to\n// a bool.  In the \"Bar(IsEven())\" example above, if method Bar()\n// takes an int, 'arg_type' will be int; if it takes an unsigned long,\n// 'arg_type' will be unsigned long; and so on.\n//\n// Parameterizing Matchers\n// =======================\n//\n// Sometimes you'll want to parameterize the matcher.  For that you\n// can use another macro:\n//\n//   MATCHER_P(name, param_name, description_string) { statements; }\n//\n// For example:\n//\n//   MATCHER_P(HasAbsoluteValue, value, \"\") { return abs(arg) == value; }\n//\n// will allow you to write:\n//\n//   EXPECT_THAT(Blah(\"a\"), HasAbsoluteValue(n));\n//\n// which may lead to this message (assuming n is 10):\n//\n//   Value of: Blah(\"a\")\n//   Expected: has absolute value 10\n//     Actual: -9\n//\n// Note that both the matcher description and its parameter are\n// printed, making the message human-friendly.\n//\n// In the matcher definition body, you can write 'foo_type' to\n// reference the type of a parameter named 'foo'.  For example, in the\n// body of MATCHER_P(HasAbsoluteValue, value) above, you can write\n// 'value_type' to refer to the type of 'value'.\n//\n// We also provide MATCHER_P2, MATCHER_P3, ..., up to MATCHER_P10 to\n// support multi-parameter matchers.\n//\n// Describing Parameterized Matchers\n// =================================\n//\n// The last argument to MATCHER*() is a string-typed expression.  The\n// expression can reference all of the matcher's parameters and a\n// special bool-typed variable named 'negation'.  When 'negation' is\n// false, the expression should evaluate to the matcher's description;\n// otherwise it should evaluate to the description of the negation of\n// the matcher.  For example,\n//\n//   using testing::PrintToString;\n//\n//   MATCHER_P2(InClosedRange, low, hi,\n//       string(negation ? \"is not\" : \"is\") + \" in range [\" +\n//       PrintToString(low) + \", \" + PrintToString(hi) + \"]\") {\n//     return low <= arg && arg <= hi;\n//   }\n//   ...\n//   EXPECT_THAT(3, InClosedRange(4, 6));\n//   EXPECT_THAT(3, Not(InClosedRange(2, 4)));\n//\n// would generate two failures that contain the text:\n//\n//   Expected: is in range [4, 6]\n//   ...\n//   Expected: is not in range [2, 4]\n//\n// If you specify \"\" as the description, the failure message will\n// contain the sequence of words in the matcher name followed by the\n// parameter values printed as a tuple.  For example,\n//\n//   MATCHER_P2(InClosedRange, low, hi, \"\") { ... }\n//   ...\n//   EXPECT_THAT(3, InClosedRange(4, 6));\n//   EXPECT_THAT(3, Not(InClosedRange(2, 4)));\n//\n// would generate two failures that contain the text:\n//\n//   Expected: in closed range (4, 6)\n//   ...\n//   Expected: not (in closed range (2, 4))\n//\n// Types of Matcher Parameters\n// ===========================\n//\n// For the purpose of typing, you can view\n//\n//   MATCHER_Pk(Foo, p1, ..., pk, description_string) { ... }\n//\n// as shorthand for\n//\n//   template <typename p1_type, ..., typename pk_type>\n//   FooMatcherPk<p1_type, ..., pk_type>\n//   Foo(p1_type p1, ..., pk_type pk) { ... }\n//\n// When you write Foo(v1, ..., vk), the compiler infers the types of\n// the parameters v1, ..., and vk for you.  If you are not happy with\n// the result of the type inference, you can specify the types by\n// explicitly instantiating the template, as in Foo<long, bool>(5,\n// false).  As said earlier, you don't get to (or need to) specify\n// 'arg_type' as that's determined by the context in which the matcher\n// is used.  You can assign the result of expression Foo(p1, ..., pk)\n// to a variable of type FooMatcherPk<p1_type, ..., pk_type>.  This\n// can be useful when composing matchers.\n//\n// While you can instantiate a matcher template with reference types,\n// passing the parameters by pointer usually makes your code more\n// readable.  If, however, you still want to pass a parameter by\n// reference, be aware that in the failure message generated by the\n// matcher you will see the value of the referenced object but not its\n// address.\n//\n// Explaining Match Results\n// ========================\n//\n// Sometimes the matcher description alone isn't enough to explain why\n// the match has failed or succeeded.  For example, when expecting a\n// long string, it can be very helpful to also print the diff between\n// the expected string and the actual one.  To achieve that, you can\n// optionally stream additional information to a special variable\n// named result_listener, whose type is a pointer to class\n// MatchResultListener:\n//\n//   MATCHER_P(EqualsLongString, str, \"\") {\n//     if (arg == str) return true;\n//\n//     *result_listener << \"the difference: \"\n///                     << DiffStrings(str, arg);\n//     return false;\n//   }\n//\n// Overloading Matchers\n// ====================\n//\n// You can overload matchers with different numbers of parameters:\n//\n//   MATCHER_P(Blah, a, description_string1) { ... }\n//   MATCHER_P2(Blah, a, b, description_string2) { ... }\n//\n// Caveats\n// =======\n//\n// When defining a new matcher, you should also consider implementing\n// MatcherInterface or using MakePolymorphicMatcher().  These\n// approaches require more work than the MATCHER* macros, but also\n// give you more control on the types of the value being matched and\n// the matcher parameters, which may leads to better compiler error\n// messages when the matcher is used wrong.  They also allow\n// overloading matchers based on parameter types (as opposed to just\n// based on the number of parameters).\n//\n// MATCHER*() can only be used in a namespace scope.  The reason is\n// that C++ doesn't yet allow function-local types to be used to\n// instantiate templates.  The up-coming C++0x standard will fix this.\n// Once that's done, we'll consider supporting using MATCHER*() inside\n// a function.\n//\n// More Information\n// ================\n//\n// To learn more about using these macros, please search for 'MATCHER'\n// on http://code.google.com/p/googlemock/wiki/CookBook.\n\n#define GTEST_DISALLOW_ASSIGN_MATCHER_(type)\\\npublic:\\\n  type(type const &) = default;\\\nprivate:\\\n  void operator=(type const &) = delete\n\n#define MATCHER(name, description)\\\n  class name##Matcher {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl()\\\n           {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<>()));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>());\\\n    }\\\n    name##Matcher() {\\\n    }\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_MATCHER_(name##Matcher);\\\n  };\\\n  inline name##Matcher name() {\\\n    return name##Matcher();\\\n  }\\\n  template <typename arg_type>\\\n  bool name##Matcher::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P(name, p0, description)\\\n  template <typename p0##_type>\\\n  class name##MatcherP {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      explicit gmock_Impl(p0##_type gmock_p0)\\\n           : p0(gmock_p0) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type>(p0)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0));\\\n    }\\\n    explicit name##MatcherP(p0##_type gmock_p0) : p0(gmock_p0) {\\\n    }\\\n    p0##_type p0;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_MATCHER_(name##MatcherP);\\\n  };\\\n  template <typename p0##_type>\\\n  inline name##MatcherP<p0##_type> name(p0##_type p0) {\\\n    return name##MatcherP<p0##_type>(p0);\\\n  }\\\n  template <typename p0##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP<p0##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P2(name, p0, p1, description)\\\n  template <typename p0##_type, typename p1##_type>\\\n  class name##MatcherP2 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1)\\\n           : p0(gmock_p0), p1(gmock_p1) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type>(p0, p1)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1));\\\n    }\\\n    name##MatcherP2(p0##_type gmock_p0, p1##_type gmock_p1) : p0(gmock_p0), \\\n        p1(gmock_p1) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_MATCHER_(name##MatcherP2);\\\n  };\\\n  template <typename p0##_type, typename p1##_type>\\\n  inline name##MatcherP2<p0##_type, p1##_type> name(p0##_type p0, \\\n      p1##_type p1) {\\\n    return name##MatcherP2<p0##_type, p1##_type>(p0, p1);\\\n  }\\\n  template <typename p0##_type, typename p1##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP2<p0##_type, \\\n      p1##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P3(name, p0, p1, p2, description)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type>\\\n  class name##MatcherP3 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2)\\\n           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type, p2##_type>(p0, p1, \\\n                    p2)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1, p2));\\\n    }\\\n    name##MatcherP3(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_MATCHER_(name##MatcherP3);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type>\\\n  inline name##MatcherP3<p0##_type, p1##_type, p2##_type> name(p0##_type p0, \\\n      p1##_type p1, p2##_type p2) {\\\n    return name##MatcherP3<p0##_type, p1##_type, p2##_type>(p0, p1, p2);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP3<p0##_type, p1##_type, \\\n      p2##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P4(name, p0, p1, p2, p3, description)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type>\\\n  class name##MatcherP4 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3)\\\n           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type, p2##_type, \\\n                    p3##_type>(p0, p1, p2, p3)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1, p2, p3));\\\n    }\\\n    name##MatcherP4(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3) : p0(gmock_p0), p1(gmock_p1), \\\n        p2(gmock_p2), p3(gmock_p3) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_MATCHER_(name##MatcherP4);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type>\\\n  inline name##MatcherP4<p0##_type, p1##_type, p2##_type, \\\n      p3##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, \\\n      p3##_type p3) {\\\n    return name##MatcherP4<p0##_type, p1##_type, p2##_type, p3##_type>(p0, \\\n        p1, p2, p3);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP4<p0##_type, p1##_type, p2##_type, \\\n      p3##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P5(name, p0, p1, p2, p3, p4, description)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type>\\\n  class name##MatcherP5 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4)\\\n           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \\\n               p4(gmock_p4) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type, p2##_type, p3##_type, \\\n                    p4##_type>(p0, p1, p2, p3, p4)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1, p2, p3, p4));\\\n    }\\\n    name##MatcherP5(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, \\\n        p4##_type gmock_p4) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_MATCHER_(name##MatcherP5);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type>\\\n  inline name##MatcherP5<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \\\n      p4##_type p4) {\\\n    return name##MatcherP5<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type>(p0, p1, p2, p3, p4);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP5<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P6(name, p0, p1, p2, p3, p4, p5, description)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type>\\\n  class name##MatcherP6 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5)\\\n           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \\\n               p4(gmock_p4), p5(gmock_p5) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n      p5##_type p5;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type, p2##_type, p3##_type, \\\n                    p4##_type, p5##_type>(p0, p1, p2, p3, p4, p5)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1, p2, p3, p4, p5));\\\n    }\\\n    name##MatcherP6(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n    p5##_type p5;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_MATCHER_(name##MatcherP6);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type>\\\n  inline name##MatcherP6<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, \\\n      p3##_type p3, p4##_type p4, p5##_type p5) {\\\n    return name##MatcherP6<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type, p5##_type>(p0, p1, p2, p3, p4, p5);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP6<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n      p5##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P7(name, p0, p1, p2, p3, p4, p5, p6, description)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type>\\\n  class name##MatcherP7 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n          p6##_type gmock_p6)\\\n           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \\\n               p4(gmock_p4), p5(gmock_p5), p6(gmock_p6) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n      p5##_type p5;\\\n      p6##_type p6;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type, p2##_type, p3##_type, \\\n                    p4##_type, p5##_type, p6##_type>(p0, p1, p2, p3, p4, p5, \\\n                    p6)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1, p2, p3, p4, p5, p6));\\\n    }\\\n    name##MatcherP7(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5, p6##_type gmock_p6) : p0(gmock_p0), p1(gmock_p1), \\\n        p2(gmock_p2), p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), \\\n        p6(gmock_p6) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n    p5##_type p5;\\\n    p6##_type p6;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_MATCHER_(name##MatcherP7);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type>\\\n  inline name##MatcherP7<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type, p6##_type> name(p0##_type p0, p1##_type p1, \\\n      p2##_type p2, p3##_type p3, p4##_type p4, p5##_type p5, \\\n      p6##_type p6) {\\\n    return name##MatcherP7<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type, p5##_type, p6##_type>(p0, p1, p2, p3, p4, p5, p6);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP7<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n      p5##_type, p6##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P8(name, p0, p1, p2, p3, p4, p5, p6, p7, description)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type>\\\n  class name##MatcherP8 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n          p6##_type gmock_p6, p7##_type gmock_p7)\\\n           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \\\n               p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n      p5##_type p5;\\\n      p6##_type p6;\\\n      p7##_type p7;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type, p2##_type, p3##_type, \\\n                    p4##_type, p5##_type, p6##_type, p7##_type>(p0, p1, p2, \\\n                    p3, p4, p5, p6, p7)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1, p2, p3, p4, p5, p6, p7));\\\n    }\\\n    name##MatcherP8(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5, p6##_type gmock_p6, \\\n        p7##_type gmock_p7) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), \\\n        p7(gmock_p7) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n    p5##_type p5;\\\n    p6##_type p6;\\\n    p7##_type p7;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_MATCHER_(name##MatcherP8);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type>\\\n  inline name##MatcherP8<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type, p6##_type, p7##_type> name(p0##_type p0, \\\n      p1##_type p1, p2##_type p2, p3##_type p3, p4##_type p4, p5##_type p5, \\\n      p6##_type p6, p7##_type p7) {\\\n    return name##MatcherP8<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type, p5##_type, p6##_type, p7##_type>(p0, p1, p2, p3, p4, p5, \\\n        p6, p7);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP8<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n      p5##_type, p6##_type, \\\n      p7##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P9(name, p0, p1, p2, p3, p4, p5, p6, p7, p8, description)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type>\\\n  class name##MatcherP9 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n          p6##_type gmock_p6, p7##_type gmock_p7, p8##_type gmock_p8)\\\n           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \\\n               p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7), \\\n               p8(gmock_p8) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n      p5##_type p5;\\\n      p6##_type p6;\\\n      p7##_type p7;\\\n      p8##_type p8;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type, p2##_type, p3##_type, \\\n                    p4##_type, p5##_type, p6##_type, p7##_type, \\\n                    p8##_type>(p0, p1, p2, p3, p4, p5, p6, p7, p8)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1, p2, p3, p4, p5, p6, p7, p8));\\\n    }\\\n    name##MatcherP9(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5, p6##_type gmock_p6, p7##_type gmock_p7, \\\n        p8##_type gmock_p8) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7), \\\n        p8(gmock_p8) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n    p5##_type p5;\\\n    p6##_type p6;\\\n    p7##_type p7;\\\n    p8##_type p8;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_MATCHER_(name##MatcherP9);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type>\\\n  inline name##MatcherP9<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type, p6##_type, p7##_type, \\\n      p8##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \\\n      p4##_type p4, p5##_type p5, p6##_type p6, p7##_type p7, \\\n      p8##_type p8) {\\\n    return name##MatcherP9<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type, p5##_type, p6##_type, p7##_type, p8##_type>(p0, p1, p2, \\\n        p3, p4, p5, p6, p7, p8);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP9<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n      p5##_type, p6##_type, p7##_type, \\\n      p8##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P10(name, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, description)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type, \\\n      typename p9##_type>\\\n  class name##MatcherP10 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n          p6##_type gmock_p6, p7##_type gmock_p7, p8##_type gmock_p8, \\\n          p9##_type gmock_p9)\\\n           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \\\n               p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7), \\\n               p8(gmock_p8), p9(gmock_p9) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n      p5##_type p5;\\\n      p6##_type p6;\\\n      p7##_type p7;\\\n      p8##_type p8;\\\n      p9##_type p9;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type, p2##_type, p3##_type, \\\n                    p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, \\\n                    p9##_type>(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9));\\\n    }\\\n    name##MatcherP10(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5, p6##_type gmock_p6, p7##_type gmock_p7, \\\n        p8##_type gmock_p8, p9##_type gmock_p9) : p0(gmock_p0), p1(gmock_p1), \\\n        p2(gmock_p2), p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), \\\n        p7(gmock_p7), p8(gmock_p8), p9(gmock_p9) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n    p5##_type p5;\\\n    p6##_type p6;\\\n    p7##_type p7;\\\n    p8##_type p8;\\\n    p9##_type p9;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_MATCHER_(name##MatcherP10);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type, \\\n      typename p9##_type>\\\n  inline name##MatcherP10<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, \\\n      p9##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \\\n      p4##_type p4, p5##_type p5, p6##_type p6, p7##_type p7, p8##_type p8, \\\n      p9##_type p9) {\\\n    return name##MatcherP10<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, p9##_type>(p0, \\\n        p1, p2, p3, p4, p5, p6, p7, p8, p9);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type, \\\n      typename p9##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP10<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, \\\n      p9##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_MATCHERS_H_\n"}, "36": {"id": 36, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-generated-nice-strict.h", "content": "// This file was GENERATED by command:\n//     pump.py gmock-generated-nice-strict.h.pump\n// DO NOT EDIT BY HAND!!!\n\n// Copyright 2008, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n// Implements class templates NiceMock, NaggyMock, and StrictMock.\n//\n// Given a mock class MockFoo that is created using Google Mock,\n// NiceMock<MockFoo> is a subclass of MockFoo that allows\n// uninteresting calls (i.e. calls to mock methods that have no\n// EXPECT_CALL specs), NaggyMock<MockFoo> is a subclass of MockFoo\n// that prints a warning when an uninteresting call occurs, and\n// StrictMock<MockFoo> is a subclass of MockFoo that treats all\n// uninteresting calls as errors.\n//\n// Currently a mock is naggy by default, so MockFoo and\n// NaggyMock<MockFoo> behave like the same.  However, we will soon\n// switch the default behavior of mocks to be nice, as that in general\n// leads to more maintainable tests.  When that happens, MockFoo will\n// stop behaving like NaggyMock<MockFoo> and start behaving like\n// NiceMock<MockFoo>.\n//\n// NiceMock, NaggyMock, and StrictMock \"inherit\" the constructors of\n// their respective base class, with up-to 10 arguments.  Therefore\n// you can write NiceMock<MockFoo>(5, \"a\") to construct a nice mock\n// where MockFoo has a constructor that accepts (int, const char*),\n// for example.\n//\n// A known limitation is that NiceMock<MockFoo>, NaggyMock<MockFoo>,\n// and StrictMock<MockFoo> only works for mock methods defined using\n// the MOCK_METHOD* family of macros DIRECTLY in the MockFoo class.\n// If a mock method is defined in a base class of MockFoo, the \"nice\"\n// or \"strict\" modifier may not affect it, depending on the compiler.\n// In particular, nesting NiceMock, NaggyMock, and StrictMock is NOT\n// supported.\n//\n// Another known limitation is that the constructors of the base mock\n// cannot have arguments passed by non-const reference, which are\n// banned by the Google C++ style guide anyway.\n\n// IWYU pragma: private, include \"gmock/gmock.h\"\n\n#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_NICE_STRICT_H_\n#define GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_NICE_STRICT_H_\n\n#include \"gmock/gmock-spec-builders.h\"\n#include \"gmock/internal/gmock-port.h\"\n\nnamespace testing {\n\ntemplate <class MockClass>\nclass NiceMock : public MockClass {\n public:\n  // We don't factor out the constructor body to a common method, as\n  // we have to avoid a possible clash with members of MockClass.\n  NiceMock() {\n    ::testing::Mock::AllowUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  // C++ doesn't (yet) allow inheritance of constructors, so we have\n  // to define it for each arity.\n  template <typename A1>\n  explicit NiceMock(const A1& a1) : MockClass(a1) {\n    ::testing::Mock::AllowUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n  template <typename A1, typename A2>\n  NiceMock(const A1& a1, const A2& a2) : MockClass(a1, a2) {\n    ::testing::Mock::AllowUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3>\n  NiceMock(const A1& a1, const A2& a2, const A3& a3) : MockClass(a1, a2, a3) {\n    ::testing::Mock::AllowUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4>\n  NiceMock(const A1& a1, const A2& a2, const A3& a3,\n      const A4& a4) : MockClass(a1, a2, a3, a4) {\n    ::testing::Mock::AllowUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5>\n  NiceMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5) : MockClass(a1, a2, a3, a4, a5) {\n    ::testing::Mock::AllowUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5,\n      typename A6>\n  NiceMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5, const A6& a6) : MockClass(a1, a2, a3, a4, a5, a6) {\n    ::testing::Mock::AllowUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5,\n      typename A6, typename A7>\n  NiceMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5, const A6& a6, const A7& a7) : MockClass(a1, a2, a3, a4, a5,\n      a6, a7) {\n    ::testing::Mock::AllowUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5,\n      typename A6, typename A7, typename A8>\n  NiceMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5, const A6& a6, const A7& a7, const A8& a8) : MockClass(a1,\n      a2, a3, a4, a5, a6, a7, a8) {\n    ::testing::Mock::AllowUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5,\n      typename A6, typename A7, typename A8, typename A9>\n  NiceMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5, const A6& a6, const A7& a7, const A8& a8,\n      const A9& a9) : MockClass(a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n    ::testing::Mock::AllowUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5,\n      typename A6, typename A7, typename A8, typename A9, typename A10>\n  NiceMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5, const A6& a6, const A7& a7, const A8& a8, const A9& a9,\n      const A10& a10) : MockClass(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {\n    ::testing::Mock::AllowUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  virtual ~NiceMock() {\n    ::testing::Mock::UnregisterCallReaction(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(NiceMock);\n};\n\ntemplate <class MockClass>\nclass NaggyMock : public MockClass {\n public:\n  // We don't factor out the constructor body to a common method, as\n  // we have to avoid a possible clash with members of MockClass.\n  NaggyMock() {\n    ::testing::Mock::WarnUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  // C++ doesn't (yet) allow inheritance of constructors, so we have\n  // to define it for each arity.\n  template <typename A1>\n  explicit NaggyMock(const A1& a1) : MockClass(a1) {\n    ::testing::Mock::WarnUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n  template <typename A1, typename A2>\n  NaggyMock(const A1& a1, const A2& a2) : MockClass(a1, a2) {\n    ::testing::Mock::WarnUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3>\n  NaggyMock(const A1& a1, const A2& a2, const A3& a3) : MockClass(a1, a2, a3) {\n    ::testing::Mock::WarnUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4>\n  NaggyMock(const A1& a1, const A2& a2, const A3& a3,\n      const A4& a4) : MockClass(a1, a2, a3, a4) {\n    ::testing::Mock::WarnUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5>\n  NaggyMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5) : MockClass(a1, a2, a3, a4, a5) {\n    ::testing::Mock::WarnUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5,\n      typename A6>\n  NaggyMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5, const A6& a6) : MockClass(a1, a2, a3, a4, a5, a6) {\n    ::testing::Mock::WarnUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5,\n      typename A6, typename A7>\n  NaggyMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5, const A6& a6, const A7& a7) : MockClass(a1, a2, a3, a4, a5,\n      a6, a7) {\n    ::testing::Mock::WarnUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5,\n      typename A6, typename A7, typename A8>\n  NaggyMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5, const A6& a6, const A7& a7, const A8& a8) : MockClass(a1,\n      a2, a3, a4, a5, a6, a7, a8) {\n    ::testing::Mock::WarnUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5,\n      typename A6, typename A7, typename A8, typename A9>\n  NaggyMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5, const A6& a6, const A7& a7, const A8& a8,\n      const A9& a9) : MockClass(a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n    ::testing::Mock::WarnUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5,\n      typename A6, typename A7, typename A8, typename A9, typename A10>\n  NaggyMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5, const A6& a6, const A7& a7, const A8& a8, const A9& a9,\n      const A10& a10) : MockClass(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {\n    ::testing::Mock::WarnUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  virtual ~NaggyMock() {\n    ::testing::Mock::UnregisterCallReaction(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(NaggyMock);\n};\n\ntemplate <class MockClass>\nclass StrictMock : public MockClass {\n public:\n  // We don't factor out the constructor body to a common method, as\n  // we have to avoid a possible clash with members of MockClass.\n  StrictMock() {\n    ::testing::Mock::FailUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  // C++ doesn't (yet) allow inheritance of constructors, so we have\n  // to define it for each arity.\n  template <typename A1>\n  explicit StrictMock(const A1& a1) : MockClass(a1) {\n    ::testing::Mock::FailUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n  template <typename A1, typename A2>\n  StrictMock(const A1& a1, const A2& a2) : MockClass(a1, a2) {\n    ::testing::Mock::FailUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3>\n  StrictMock(const A1& a1, const A2& a2, const A3& a3) : MockClass(a1, a2, a3) {\n    ::testing::Mock::FailUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4>\n  StrictMock(const A1& a1, const A2& a2, const A3& a3,\n      const A4& a4) : MockClass(a1, a2, a3, a4) {\n    ::testing::Mock::FailUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5>\n  StrictMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5) : MockClass(a1, a2, a3, a4, a5) {\n    ::testing::Mock::FailUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5,\n      typename A6>\n  StrictMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5, const A6& a6) : MockClass(a1, a2, a3, a4, a5, a6) {\n    ::testing::Mock::FailUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5,\n      typename A6, typename A7>\n  StrictMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5, const A6& a6, const A7& a7) : MockClass(a1, a2, a3, a4, a5,\n      a6, a7) {\n    ::testing::Mock::FailUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5,\n      typename A6, typename A7, typename A8>\n  StrictMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5, const A6& a6, const A7& a7, const A8& a8) : MockClass(a1,\n      a2, a3, a4, a5, a6, a7, a8) {\n    ::testing::Mock::FailUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5,\n      typename A6, typename A7, typename A8, typename A9>\n  StrictMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5, const A6& a6, const A7& a7, const A8& a8,\n      const A9& a9) : MockClass(a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n    ::testing::Mock::FailUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5,\n      typename A6, typename A7, typename A8, typename A9, typename A10>\n  StrictMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5, const A6& a6, const A7& a7, const A8& a8, const A9& a9,\n      const A10& a10) : MockClass(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {\n    ::testing::Mock::FailUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  virtual ~StrictMock() {\n    ::testing::Mock::UnregisterCallReaction(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(StrictMock);\n};\n\n// The following specializations catch some (relatively more common)\n// user errors of nesting nice and strict mocks.  They do NOT catch\n// all possible errors.\n\n// These specializations are declared but not defined, as NiceMock,\n// NaggyMock, and StrictMock cannot be nested.\n\ntemplate <typename MockClass>\nclass NiceMock<NiceMock<MockClass> >;\ntemplate <typename MockClass>\nclass NiceMock<NaggyMock<MockClass> >;\ntemplate <typename MockClass>\nclass NiceMock<StrictMock<MockClass> >;\n\ntemplate <typename MockClass>\nclass NaggyMock<NiceMock<MockClass> >;\ntemplate <typename MockClass>\nclass NaggyMock<NaggyMock<MockClass> >;\ntemplate <typename MockClass>\nclass NaggyMock<StrictMock<MockClass> >;\n\ntemplate <typename MockClass>\nclass StrictMock<NiceMock<MockClass> >;\ntemplate <typename MockClass>\nclass StrictMock<NaggyMock<MockClass> >;\ntemplate <typename MockClass>\nclass StrictMock<StrictMock<MockClass> >;\n\n}  // namespace testing\n\n#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_NICE_STRICT_H_\n"}, "37": {"id": 37, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-matchers.h", "content": "// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n// Google Mock - a framework for writing C++ mock classes.\n//\n// This file implements some commonly used argument matchers.  More\n// matchers can be defined by the user implementing the\n// MatcherInterface<T> interface if necessary.\n\n// IWYU pragma: private, include \"gmock/gmock.h\"\n\n#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_MATCHERS_H_\n#define GMOCK_INCLUDE_GMOCK_GMOCK_MATCHERS_H_\n\n#include <math.h>\n#include <algorithm>\n#include <iterator>\n#include <limits>\n#include <ostream>  // NOLINT\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\n#include \"gmock/internal/gmock-internal-utils.h\"\n#include \"gmock/internal/gmock-port.h\"\n#include \"gtest/gtest.h\"\n\n#if GTEST_HAS_STD_INITIALIZER_LIST_\n# include <initializer_list>  // NOLINT -- must be after gtest.h\n#endif\n\n#ifdef __clang__\n#if __has_warning(\"-Wdeprecated-copy\")\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wdeprecated-copy\"\n#endif\n#endif\n\nnamespace testing {\n\n// To implement a matcher Foo for type T, define:\n//   1. a class FooMatcherImpl that implements the\n//      MatcherInterface<T> interface, and\n//   2. a factory function that creates a Matcher<T> object from a\n//      FooMatcherImpl*.\n//\n// The two-level delegation design makes it possible to allow a user\n// to write \"v\" instead of \"Eq(v)\" where a Matcher is expected, which\n// is impossible if we pass matchers by pointers.  It also eases\n// ownership management as Matcher objects can now be copied like\n// plain values.\n\n// MatchResultListener is an abstract class.  Its << operator can be\n// used by a matcher to explain why a value matches or doesn't match.\n//\n// TODO(wan@google.com): add method\n//   bool InterestedInWhy(bool result) const;\n// to indicate whether the listener is interested in why the match\n// result is 'result'.\nclass MatchResultListener {\n public:\n  // Creates a listener object with the given underlying ostream.  The\n  // listener does not own the ostream, and does not dereference it\n  // in the constructor or destructor.\n  explicit MatchResultListener(::std::ostream* os) : stream_(os) {}\n  virtual ~MatchResultListener() = 0;  // Makes this class abstract.\n\n  // Streams x to the underlying ostream; does nothing if the ostream\n  // is NULL.\n  template <typename T>\n  MatchResultListener& operator<<(const T& x) {\n    if (stream_ != NULL)\n      *stream_ << x;\n    return *this;\n  }\n\n  // Returns the underlying ostream.\n  ::std::ostream* stream() { return stream_; }\n\n  // Returns true iff the listener is interested in an explanation of\n  // the match result.  A matcher's MatchAndExplain() method can use\n  // this information to avoid generating the explanation when no one\n  // intends to hear it.\n  bool IsInterested() const { return stream_ != NULL; }\n\n private:\n  ::std::ostream* const stream_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(MatchResultListener);\n};\n\ninline MatchResultListener::~MatchResultListener() {\n}\n\n// An instance of a subclass of this knows how to describe itself as a\n// matcher.\nclass MatcherDescriberInterface {\n public:\n  virtual ~MatcherDescriberInterface() {}\n\n  // Describes this matcher to an ostream.  The function should print\n  // a verb phrase that describes the property a value matching this\n  // matcher should have.  The subject of the verb phrase is the value\n  // being matched.  For example, the DescribeTo() method of the Gt(7)\n  // matcher prints \"is greater than 7\".\n  virtual void DescribeTo(::std::ostream* os) const = 0;\n\n  // Describes the negation of this matcher to an ostream.  For\n  // example, if the description of this matcher is \"is greater than\n  // 7\", the negated description could be \"is not greater than 7\".\n  // You are not required to override this when implementing\n  // MatcherInterface, but it is highly advised so that your matcher\n  // can produce good error messages.\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"not (\";\n    DescribeTo(os);\n    *os << \")\";\n  }\n};\n\n// The implementation of a matcher.\ntemplate <typename T>\nclass MatcherInterface : public MatcherDescriberInterface {\n public:\n  // Returns true iff the matcher matches x; also explains the match\n  // result to 'listener' if necessary (see the next paragraph), in\n  // the form of a non-restrictive relative clause (\"which ...\",\n  // \"whose ...\", etc) that describes x.  For example, the\n  // MatchAndExplain() method of the Pointee(...) matcher should\n  // generate an explanation like \"which points to ...\".\n  //\n  // Implementations of MatchAndExplain() should add an explanation of\n  // the match result *if and only if* they can provide additional\n  // information that's not already present (or not obvious) in the\n  // print-out of x and the matcher's description.  Whether the match\n  // succeeds is not a factor in deciding whether an explanation is\n  // needed, as sometimes the caller needs to print a failure message\n  // when the match succeeds (e.g. when the matcher is used inside\n  // Not()).\n  //\n  // For example, a \"has at least 10 elements\" matcher should explain\n  // what the actual element count is, regardless of the match result,\n  // as it is useful information to the reader; on the other hand, an\n  // \"is empty\" matcher probably only needs to explain what the actual\n  // size is when the match fails, as it's redundant to say that the\n  // size is 0 when the value is already known to be empty.\n  //\n  // You should override this method when defining a new matcher.\n  //\n  // It's the responsibility of the caller (Google Mock) to guarantee\n  // that 'listener' is not NULL.  This helps to simplify a matcher's\n  // implementation when it doesn't care about the performance, as it\n  // can talk to 'listener' without checking its validity first.\n  // However, in order to implement dummy listeners efficiently,\n  // listener->stream() may be NULL.\n  virtual bool MatchAndExplain(T x, MatchResultListener* listener) const = 0;\n\n  // Inherits these methods from MatcherDescriberInterface:\n  //   virtual void DescribeTo(::std::ostream* os) const = 0;\n  //   virtual void DescribeNegationTo(::std::ostream* os) const;\n};\n\n// A match result listener that stores the explanation in a string.\nclass StringMatchResultListener : public MatchResultListener {\n public:\n  StringMatchResultListener() : MatchResultListener(&ss_) {}\n\n  // Returns the explanation accumulated so far.\n  internal::string str() const { return ss_.str(); }\n\n  // Clears the explanation accumulated so far.\n  void Clear() { ss_.str(\"\"); }\n\n private:\n  ::std::stringstream ss_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(StringMatchResultListener);\n};\n\nnamespace internal {\n\nstruct AnyEq {\n  template <typename A, typename B>\n  bool operator()(const A& a, const B& b) const { return a == b; }\n};\nstruct AnyNe {\n  template <typename A, typename B>\n  bool operator()(const A& a, const B& b) const { return a != b; }\n};\nstruct AnyLt {\n  template <typename A, typename B>\n  bool operator()(const A& a, const B& b) const { return a < b; }\n};\nstruct AnyGt {\n  template <typename A, typename B>\n  bool operator()(const A& a, const B& b) const { return a > b; }\n};\nstruct AnyLe {\n  template <typename A, typename B>\n  bool operator()(const A& a, const B& b) const { return a <= b; }\n};\nstruct AnyGe {\n  template <typename A, typename B>\n  bool operator()(const A& a, const B& b) const { return a >= b; }\n};\n\n// A match result listener that ignores the explanation.\nclass DummyMatchResultListener : public MatchResultListener {\n public:\n  DummyMatchResultListener() : MatchResultListener(NULL) {}\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(DummyMatchResultListener);\n};\n\n// A match result listener that forwards the explanation to a given\n// ostream.  The difference between this and MatchResultListener is\n// that the former is concrete.\nclass StreamMatchResultListener : public MatchResultListener {\n public:\n  explicit StreamMatchResultListener(::std::ostream* os)\n      : MatchResultListener(os) {}\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(StreamMatchResultListener);\n};\n\n// An internal class for implementing Matcher<T>, which will derive\n// from it.  We put functionalities common to all Matcher<T>\n// specializations here to avoid code duplication.\ntemplate <typename T>\nclass MatcherBase {\n public:\n  // Returns true iff the matcher matches x; also explains the match\n  // result to 'listener'.\n  bool MatchAndExplain(T x, MatchResultListener* listener) const {\n    return impl_->MatchAndExplain(x, listener);\n  }\n\n  // Returns true iff this matcher matches x.\n  bool Matches(T x) const {\n    DummyMatchResultListener dummy;\n    return MatchAndExplain(x, &dummy);\n  }\n\n  // Describes this matcher to an ostream.\n  void DescribeTo(::std::ostream* os) const { impl_->DescribeTo(os); }\n\n  // Describes the negation of this matcher to an ostream.\n  void DescribeNegationTo(::std::ostream* os) const {\n    impl_->DescribeNegationTo(os);\n  }\n\n  // Explains why x matches, or doesn't match, the matcher.\n  void ExplainMatchResultTo(T x, ::std::ostream* os) const {\n    StreamMatchResultListener listener(os);\n    MatchAndExplain(x, &listener);\n  }\n\n  // Returns the describer for this matcher object; retains ownership\n  // of the describer, which is only guaranteed to be alive when\n  // this matcher object is alive.\n  const MatcherDescriberInterface* GetDescriber() const {\n    return impl_.get();\n  }\n\n protected:\n  MatcherBase() {}\n\n  // Constructs a matcher from its implementation.\n  explicit MatcherBase(const MatcherInterface<T>* impl)\n      : impl_(impl) {}\n\n  virtual ~MatcherBase() {}\n\n private:\n  // shared_ptr (util/gtl/shared_ptr.h) and linked_ptr have similar\n  // interfaces.  The former dynamically allocates a chunk of memory\n  // to hold the reference count, while the latter tracks all\n  // references using a circular linked list without allocating\n  // memory.  It has been observed that linked_ptr performs better in\n  // typical scenarios.  However, shared_ptr can out-perform\n  // linked_ptr when there are many more uses of the copy constructor\n  // than the default constructor.\n  //\n  // If performance becomes a problem, we should see if using\n  // shared_ptr helps.\n  ::testing::internal::linked_ptr<const MatcherInterface<T> > impl_;\n};\n\n}  // namespace internal\n\n// A Matcher<T> is a copyable and IMMUTABLE (except by assignment)\n// object that can check whether a value of type T matches.  The\n// implementation of Matcher<T> is just a linked_ptr to const\n// MatcherInterface<T>, so copying is fairly cheap.  Don't inherit\n// from Matcher!\ntemplate <typename T>\nclass Matcher : public internal::MatcherBase<T> {\n public:\n  // Constructs a null matcher.  Needed for storing Matcher objects in STL\n  // containers.  A default-constructed matcher is not yet initialized.  You\n  // cannot use it until a valid value has been assigned to it.\n  explicit Matcher() {}  // NOLINT\n\n  // Constructs a matcher from its implementation.\n  explicit Matcher(const MatcherInterface<T>* impl)\n      : internal::MatcherBase<T>(impl) {}\n\n  // Implicit constructor here allows people to write\n  // EXPECT_CALL(foo, Bar(5)) instead of EXPECT_CALL(foo, Bar(Eq(5))) sometimes\n  Matcher(T value);  // NOLINT\n};\n\n// The following two specializations allow the user to write str\n// instead of Eq(str) and \"foo\" instead of Eq(\"foo\") when a string\n// matcher is expected.\ntemplate <>\nclass GTEST_API_ Matcher<const internal::string&>\n    : public internal::MatcherBase<const internal::string&> {\n public:\n  Matcher() {}\n\n  explicit Matcher(const MatcherInterface<const internal::string&>* impl)\n      : internal::MatcherBase<const internal::string&>(impl) {}\n\n  // Allows the user to write str instead of Eq(str) sometimes, where\n  // str is a string object.\n  Matcher(const internal::string& s);  // NOLINT\n\n  // Allows the user to write \"foo\" instead of Eq(\"foo\") sometimes.\n  Matcher(const char* s);  // NOLINT\n};\n\ntemplate <>\nclass GTEST_API_ Matcher<internal::string>\n    : public internal::MatcherBase<internal::string> {\n public:\n  Matcher() {}\n\n  explicit Matcher(const MatcherInterface<internal::string>* impl)\n      : internal::MatcherBase<internal::string>(impl) {}\n\n  // Allows the user to write str instead of Eq(str) sometimes, where\n  // str is a string object.\n  Matcher(const internal::string& s);  // NOLINT\n\n  // Allows the user to write \"foo\" instead of Eq(\"foo\") sometimes.\n  Matcher(const char* s);  // NOLINT\n};\n\n#if GTEST_HAS_STRING_PIECE_\n// The following two specializations allow the user to write str\n// instead of Eq(str) and \"foo\" instead of Eq(\"foo\") when a StringPiece\n// matcher is expected.\ntemplate <>\nclass GTEST_API_ Matcher<const StringPiece&>\n    : public internal::MatcherBase<const StringPiece&> {\n public:\n  Matcher() {}\n\n  explicit Matcher(const MatcherInterface<const StringPiece&>* impl)\n      : internal::MatcherBase<const StringPiece&>(impl) {}\n\n  // Allows the user to write str instead of Eq(str) sometimes, where\n  // str is a string object.\n  Matcher(const internal::string& s);  // NOLINT\n\n  // Allows the user to write \"foo\" instead of Eq(\"foo\") sometimes.\n  Matcher(const char* s);  // NOLINT\n\n  // Allows the user to pass StringPieces directly.\n  Matcher(StringPiece s);  // NOLINT\n};\n\ntemplate <>\nclass GTEST_API_ Matcher<StringPiece>\n    : public internal::MatcherBase<StringPiece> {\n public:\n  Matcher() {}\n\n  explicit Matcher(const MatcherInterface<StringPiece>* impl)\n      : internal::MatcherBase<StringPiece>(impl) {}\n\n  // Allows the user to write str instead of Eq(str) sometimes, where\n  // str is a string object.\n  Matcher(const internal::string& s);  // NOLINT\n\n  // Allows the user to write \"foo\" instead of Eq(\"foo\") sometimes.\n  Matcher(const char* s);  // NOLINT\n\n  // Allows the user to pass StringPieces directly.\n  Matcher(StringPiece s);  // NOLINT\n};\n#endif  // GTEST_HAS_STRING_PIECE_\n\n// The PolymorphicMatcher class template makes it easy to implement a\n// polymorphic matcher (i.e. a matcher that can match values of more\n// than one type, e.g. Eq(n) and NotNull()).\n//\n// To define a polymorphic matcher, a user should provide an Impl\n// class that has a DescribeTo() method and a DescribeNegationTo()\n// method, and define a member function (or member function template)\n//\n//   bool MatchAndExplain(const Value& value,\n//                        MatchResultListener* listener) const;\n//\n// See the definition of NotNull() for a complete example.\ntemplate <class Impl>\nclass PolymorphicMatcher {\n public:\n  explicit PolymorphicMatcher(const Impl& an_impl) : impl_(an_impl) {}\n\n  // Returns a mutable reference to the underlying matcher\n  // implementation object.\n  Impl& mutable_impl() { return impl_; }\n\n  // Returns an immutable reference to the underlying matcher\n  // implementation object.\n  const Impl& impl() const { return impl_; }\n\n  template <typename T>\n  operator Matcher<T>() const {\n    return Matcher<T>(new MonomorphicImpl<T>(impl_));\n  }\n\n private:\n  template <typename T>\n  class MonomorphicImpl : public MatcherInterface<T> {\n   public:\n    explicit MonomorphicImpl(const Impl& impl) : impl_(impl) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      impl_.DescribeTo(os);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      impl_.DescribeNegationTo(os);\n    }\n\n    virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {\n      return impl_.MatchAndExplain(x, listener);\n    }\n\n   private:\n    const Impl impl_;\n\n    GTEST_DISALLOW_ASSIGN_(MonomorphicImpl);\n  };\n\n  Impl impl_;\n\n  GTEST_DISALLOW_ASSIGN_(PolymorphicMatcher);\n};\n\n// Creates a matcher from its implementation.  This is easier to use\n// than the Matcher<T> constructor as it doesn't require you to\n// explicitly write the template argument, e.g.\n//\n//   MakeMatcher(foo);\n// vs\n//   Matcher<const string&>(foo);\ntemplate <typename T>\ninline Matcher<T> MakeMatcher(const MatcherInterface<T>* impl) {\n  return Matcher<T>(impl);\n}\n\n// Creates a polymorphic matcher from its implementation.  This is\n// easier to use than the PolymorphicMatcher<Impl> constructor as it\n// doesn't require you to explicitly write the template argument, e.g.\n//\n//   MakePolymorphicMatcher(foo);\n// vs\n//   PolymorphicMatcher<TypeOfFoo>(foo);\ntemplate <class Impl>\ninline PolymorphicMatcher<Impl> MakePolymorphicMatcher(const Impl& impl) {\n  return PolymorphicMatcher<Impl>(impl);\n}\n\n// Anything inside the 'internal' namespace IS INTERNAL IMPLEMENTATION\n// and MUST NOT BE USED IN USER CODE!!!\nnamespace internal {\n\n// The MatcherCastImpl class template is a helper for implementing\n// MatcherCast().  We need this helper in order to partially\n// specialize the implementation of MatcherCast() (C++ allows\n// class/struct templates to be partially specialized, but not\n// function templates.).\n\n// This general version is used when MatcherCast()'s argument is a\n// polymorphic matcher (i.e. something that can be converted to a\n// Matcher but is not one yet; for example, Eq(value)) or a value (for\n// example, \"hello\").\ntemplate <typename T, typename M>\nclass MatcherCastImpl {\n public:\n  static Matcher<T> Cast(const M& polymorphic_matcher_or_value) {\n    // M can be a polymorhic matcher, in which case we want to use\n    // its conversion operator to create Matcher<T>.  Or it can be a value\n    // that should be passed to the Matcher<T>'s constructor.\n    //\n    // We can't call Matcher<T>(polymorphic_matcher_or_value) when M is a\n    // polymorphic matcher because it'll be ambiguous if T has an implicit\n    // constructor from M (this usually happens when T has an implicit\n    // constructor from any type).\n    //\n    // It won't work to unconditionally implict_cast\n    // polymorphic_matcher_or_value to Matcher<T> because it won't trigger\n    // a user-defined conversion from M to T if one exists (assuming M is\n    // a value).\n    return CastImpl(\n        polymorphic_matcher_or_value,\n        BooleanConstant<\n            internal::ImplicitlyConvertible<M, Matcher<T> >::value>());\n  }\n\n private:\n  static Matcher<T> CastImpl(const M& value, BooleanConstant<false>) {\n    // M can't be implicitly converted to Matcher<T>, so M isn't a polymorphic\n    // matcher.  It must be a value then.  Use direct initialization to create\n    // a matcher.\n    return Matcher<T>(ImplicitCast_<T>(value));\n  }\n\n  static Matcher<T> CastImpl(const M& polymorphic_matcher_or_value,\n                             BooleanConstant<true>) {\n    // M is implicitly convertible to Matcher<T>, which means that either\n    // M is a polymorhpic matcher or Matcher<T> has an implicit constructor\n    // from M.  In both cases using the implicit conversion will produce a\n    // matcher.\n    //\n    // Even if T has an implicit constructor from M, it won't be called because\n    // creating Matcher<T> would require a chain of two user-defined conversions\n    // (first to create T from M and then to create Matcher<T> from T).\n    return polymorphic_matcher_or_value;\n  }\n};\n\n// This more specialized version is used when MatcherCast()'s argument\n// is already a Matcher.  This only compiles when type T can be\n// statically converted to type U.\ntemplate <typename T, typename U>\nclass MatcherCastImpl<T, Matcher<U> > {\n public:\n  static Matcher<T> Cast(const Matcher<U>& source_matcher) {\n    return Matcher<T>(new Impl(source_matcher));\n  }\n\n private:\n  class Impl : public MatcherInterface<T> {\n   public:\n    explicit Impl(const Matcher<U>& source_matcher)\n        : source_matcher_(source_matcher) {}\n\n    // We delegate the matching logic to the source matcher.\n    virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {\n      return source_matcher_.MatchAndExplain(static_cast<U>(x), listener);\n    }\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      source_matcher_.DescribeTo(os);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      source_matcher_.DescribeNegationTo(os);\n    }\n\n   private:\n    const Matcher<U> source_matcher_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n};\n\n// This even more specialized version is used for efficiently casting\n// a matcher to its own type.\ntemplate <typename T>\nclass MatcherCastImpl<T, Matcher<T> > {\n public:\n  static Matcher<T> Cast(const Matcher<T>& matcher) { return matcher; }\n};\n\n}  // namespace internal\n\n// In order to be safe and clear, casting between different matcher\n// types is done explicitly via MatcherCast<T>(m), which takes a\n// matcher m and returns a Matcher<T>.  It compiles only when T can be\n// statically converted to the argument type of m.\ntemplate <typename T, typename M>\ninline Matcher<T> MatcherCast(const M& matcher) {\n  return internal::MatcherCastImpl<T, M>::Cast(matcher);\n}\n\n// Implements SafeMatcherCast().\n//\n// We use an intermediate class to do the actual safe casting as Nokia's\n// Symbian compiler cannot decide between\n// template <T, M> ... (M) and\n// template <T, U> ... (const Matcher<U>&)\n// for function templates but can for member function templates.\ntemplate <typename T>\nclass SafeMatcherCastImpl {\n public:\n  // This overload handles polymorphic matchers and values only since\n  // monomorphic matchers are handled by the next one.\n  template <typename M>\n  static inline Matcher<T> Cast(const M& polymorphic_matcher_or_value) {\n    return internal::MatcherCastImpl<T, M>::Cast(polymorphic_matcher_or_value);\n  }\n\n  // This overload handles monomorphic matchers.\n  //\n  // In general, if type T can be implicitly converted to type U, we can\n  // safely convert a Matcher<U> to a Matcher<T> (i.e. Matcher is\n  // contravariant): just keep a copy of the original Matcher<U>, convert the\n  // argument from type T to U, and then pass it to the underlying Matcher<U>.\n  // The only exception is when U is a reference and T is not, as the\n  // underlying Matcher<U> may be interested in the argument's address, which\n  // is not preserved in the conversion from T to U.\n  template <typename U>\n  static inline Matcher<T> Cast(const Matcher<U>& matcher) {\n    // Enforce that T can be implicitly converted to U.\n    GTEST_COMPILE_ASSERT_((internal::ImplicitlyConvertible<T, U>::value),\n                          T_must_be_implicitly_convertible_to_U);\n    // Enforce that we are not converting a non-reference type T to a reference\n    // type U.\n    GTEST_COMPILE_ASSERT_(\n        internal::is_reference<T>::value || !internal::is_reference<U>::value,\n        cannot_convert_non_referentce_arg_to_reference);\n    // In case both T and U are arithmetic types, enforce that the\n    // conversion is not lossy.\n    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(T) RawT;\n    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(U) RawU;\n    const bool kTIsOther = GMOCK_KIND_OF_(RawT) == internal::kOther;\n    const bool kUIsOther = GMOCK_KIND_OF_(RawU) == internal::kOther;\n    GTEST_COMPILE_ASSERT_(\n        kTIsOther || kUIsOther ||\n        (internal::LosslessArithmeticConvertible<RawT, RawU>::value),\n        conversion_of_arithmetic_types_must_be_lossless);\n    return MatcherCast<T>(matcher);\n  }\n};\n\ntemplate <typename T, typename M>\ninline Matcher<T> SafeMatcherCast(const M& polymorphic_matcher) {\n  return SafeMatcherCastImpl<T>::Cast(polymorphic_matcher);\n}\n\n// A<T>() returns a matcher that matches any value of type T.\ntemplate <typename T>\nMatcher<T> A();\n\n// Anything inside the 'internal' namespace IS INTERNAL IMPLEMENTATION\n// and MUST NOT BE USED IN USER CODE!!!\nnamespace internal {\n\n// If the explanation is not empty, prints it to the ostream.\ninline void PrintIfNotEmpty(const internal::string& explanation,\n                            ::std::ostream* os) {\n  if (explanation != \"\" && os != NULL) {\n    *os << \", \" << explanation;\n  }\n}\n\n// Returns true if the given type name is easy to read by a human.\n// This is used to decide whether printing the type of a value might\n// be helpful.\ninline bool IsReadableTypeName(const string& type_name) {\n  // We consider a type name readable if it's short or doesn't contain\n  // a template or function type.\n  return (type_name.length() <= 20 ||\n          type_name.find_first_of(\"<(\") == string::npos);\n}\n\n// Matches the value against the given matcher, prints the value and explains\n// the match result to the listener. Returns the match result.\n// 'listener' must not be NULL.\n// Value cannot be passed by const reference, because some matchers take a\n// non-const argument.\ntemplate <typename Value, typename T>\nbool MatchPrintAndExplain(Value& value, const Matcher<T>& matcher,\n                          MatchResultListener* listener) {\n  if (!listener->IsInterested()) {\n    // If the listener is not interested, we do not need to construct the\n    // inner explanation.\n    return matcher.Matches(value);\n  }\n\n  StringMatchResultListener inner_listener;\n  const bool match = matcher.MatchAndExplain(value, &inner_listener);\n\n  UniversalPrint(value, listener->stream());\n#if GTEST_HAS_RTTI\n  const string& type_name = GetTypeName<Value>();\n  if (IsReadableTypeName(type_name))\n    *listener->stream() << \" (of type \" << type_name << \")\";\n#endif\n  PrintIfNotEmpty(inner_listener.str(), listener->stream());\n\n  return match;\n}\n\n// An internal helper class for doing compile-time loop on a tuple's\n// fields.\ntemplate <size_t N>\nclass TuplePrefix {\n public:\n  // TuplePrefix<N>::Matches(matcher_tuple, value_tuple) returns true\n  // iff the first N fields of matcher_tuple matches the first N\n  // fields of value_tuple, respectively.\n  template <typename MatcherTuple, typename ValueTuple>\n  static bool Matches(const MatcherTuple& matcher_tuple,\n                      const ValueTuple& value_tuple) {\n    return TuplePrefix<N - 1>::Matches(matcher_tuple, value_tuple)\n        && get<N - 1>(matcher_tuple).Matches(get<N - 1>(value_tuple));\n  }\n\n  // TuplePrefix<N>::ExplainMatchFailuresTo(matchers, values, os)\n  // describes failures in matching the first N fields of matchers\n  // against the first N fields of values.  If there is no failure,\n  // nothing will be streamed to os.\n  template <typename MatcherTuple, typename ValueTuple>\n  static void ExplainMatchFailuresTo(const MatcherTuple& matchers,\n                                     const ValueTuple& values,\n                                     ::std::ostream* os) {\n    // First, describes failures in the first N - 1 fields.\n    TuplePrefix<N - 1>::ExplainMatchFailuresTo(matchers, values, os);\n\n    // Then describes the failure (if any) in the (N - 1)-th (0-based)\n    // field.\n    typename tuple_element<N - 1, MatcherTuple>::type matcher =\n        get<N - 1>(matchers);\n    typedef typename tuple_element<N - 1, ValueTuple>::type Value;\n    Value value = get<N - 1>(values);\n    StringMatchResultListener listener;\n    if (!matcher.MatchAndExplain(value, &listener)) {\n      // TODO(wan): include in the message the name of the parameter\n      // as used in MOCK_METHOD*() when possible.\n      *os << \"  Expected arg #\" << N - 1 << \": \";\n      get<N - 1>(matchers).DescribeTo(os);\n      *os << \"\\n           Actual: \";\n      // We remove the reference in type Value to prevent the\n      // universal printer from printing the address of value, which\n      // isn't interesting to the user most of the time.  The\n      // matcher's MatchAndExplain() method handles the case when\n      // the address is interesting.\n      internal::UniversalPrint(value, os);\n      PrintIfNotEmpty(listener.str(), os);\n      *os << \"\\n\";\n    }\n  }\n};\n\n// The base case.\ntemplate <>\nclass TuplePrefix<0> {\n public:\n  template <typename MatcherTuple, typename ValueTuple>\n  static bool Matches(const MatcherTuple& /* matcher_tuple */,\n                      const ValueTuple& /* value_tuple */) {\n    return true;\n  }\n\n  template <typename MatcherTuple, typename ValueTuple>\n  static void ExplainMatchFailuresTo(const MatcherTuple& /* matchers */,\n                                     const ValueTuple& /* values */,\n                                     ::std::ostream* /* os */) {}\n};\n\n// TupleMatches(matcher_tuple, value_tuple) returns true iff all\n// matchers in matcher_tuple match the corresponding fields in\n// value_tuple.  It is a compiler error if matcher_tuple and\n// value_tuple have different number of fields or incompatible field\n// types.\ntemplate <typename MatcherTuple, typename ValueTuple>\nbool TupleMatches(const MatcherTuple& matcher_tuple,\n                  const ValueTuple& value_tuple) {\n  // Makes sure that matcher_tuple and value_tuple have the same\n  // number of fields.\n  GTEST_COMPILE_ASSERT_(tuple_size<MatcherTuple>::value ==\n                        tuple_size<ValueTuple>::value,\n                        matcher_and_value_have_different_numbers_of_fields);\n  return TuplePrefix<tuple_size<ValueTuple>::value>::\n      Matches(matcher_tuple, value_tuple);\n}\n\n// Describes failures in matching matchers against values.  If there\n// is no failure, nothing will be streamed to os.\ntemplate <typename MatcherTuple, typename ValueTuple>\nvoid ExplainMatchFailureTupleTo(const MatcherTuple& matchers,\n                                const ValueTuple& values,\n                                ::std::ostream* os) {\n  TuplePrefix<tuple_size<MatcherTuple>::value>::ExplainMatchFailuresTo(\n      matchers, values, os);\n}\n\n// TransformTupleValues and its helper.\n//\n// TransformTupleValuesHelper hides the internal machinery that\n// TransformTupleValues uses to implement a tuple traversal.\ntemplate <typename Tuple, typename Func, typename OutIter>\nclass TransformTupleValuesHelper {\n private:\n  typedef ::testing::tuple_size<Tuple> TupleSize;\n\n public:\n  // For each member of tuple 't', taken in order, evaluates '*out++ = f(t)'.\n  // Returns the final value of 'out' in case the caller needs it.\n  static OutIter Run(Func f, const Tuple& t, OutIter out) {\n    return IterateOverTuple<Tuple, TupleSize::value>()(f, t, out);\n  }\n\n private:\n  template <typename Tup, size_t kRemainingSize>\n  struct IterateOverTuple {\n    OutIter operator() (Func f, const Tup& t, OutIter out) const {\n      *out++ = f(::testing::get<TupleSize::value - kRemainingSize>(t));\n      return IterateOverTuple<Tup, kRemainingSize - 1>()(f, t, out);\n    }\n  };\n  template <typename Tup>\n  struct IterateOverTuple<Tup, 0> {\n    OutIter operator() (Func /* f */, const Tup& /* t */, OutIter out) const {\n      return out;\n    }\n  };\n};\n\n// Successively invokes 'f(element)' on each element of the tuple 't',\n// appending each result to the 'out' iterator. Returns the final value\n// of 'out'.\ntemplate <typename Tuple, typename Func, typename OutIter>\nOutIter TransformTupleValues(Func f, const Tuple& t, OutIter out) {\n  return TransformTupleValuesHelper<Tuple, Func, OutIter>::Run(f, t, out);\n}\n\n// Implements A<T>().\ntemplate <typename T>\nclass AnyMatcherImpl : public MatcherInterface<T> {\n public:\n  virtual bool MatchAndExplain(\n      T /* x */, MatchResultListener* /* listener */) const { return true; }\n  virtual void DescribeTo(::std::ostream* os) const { *os << \"is anything\"; }\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    // This is mostly for completeness' safe, as it's not very useful\n    // to write Not(A<bool>()).  However we cannot completely rule out\n    // such a possibility, and it doesn't hurt to be prepared.\n    *os << \"never matches\";\n  }\n};\n\n// Implements _, a matcher that matches any value of any\n// type.  This is a polymorphic matcher, so we need a template type\n// conversion operator to make it appearing as a Matcher<T> for any\n// type T.\nclass AnythingMatcher {\n public:\n  template <typename T>\n  operator Matcher<T>() const { return A<T>(); }\n};\n\n// Implements a matcher that compares a given value with a\n// pre-supplied value using one of the ==, <=, <, etc, operators.  The\n// two values being compared don't have to have the same type.\n//\n// The matcher defined here is polymorphic (for example, Eq(5) can be\n// used to match an int, a short, a double, etc).  Therefore we use\n// a template type conversion operator in the implementation.\n//\n// The following template definition assumes that the Rhs parameter is\n// a \"bare\" type (i.e. neither 'const T' nor 'T&').\ntemplate <typename D, typename Rhs, typename Op>\nclass ComparisonBase {\n public:\n  explicit ComparisonBase(const Rhs& rhs) : rhs_(rhs) {}\n  template <typename Lhs>\n  operator Matcher<Lhs>() const {\n    return MakeMatcher(new Impl<Lhs>(rhs_));\n  }\n\n private:\n  template <typename Lhs>\n  class Impl : public MatcherInterface<Lhs> {\n   public:\n    explicit Impl(const Rhs& rhs) : rhs_(rhs) {}\n    virtual bool MatchAndExplain(\n        Lhs lhs, MatchResultListener* /* listener */) const {\n      return Op()(lhs, rhs_);\n    }\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << D::Desc() << \" \";\n      UniversalPrint(rhs_, os);\n    }\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << D::NegatedDesc() <<  \" \";\n      UniversalPrint(rhs_, os);\n    }\n   private:\n    Rhs rhs_;\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n  Rhs rhs_;\n  GTEST_DISALLOW_ASSIGN_(ComparisonBase);\n};\n\ntemplate <typename Rhs>\nclass EqMatcher : public ComparisonBase<EqMatcher<Rhs>, Rhs, AnyEq> {\n public:\n  explicit EqMatcher(const Rhs& rhs)\n      : ComparisonBase<EqMatcher<Rhs>, Rhs, AnyEq>(rhs) { }\n  static const char* Desc() { return \"is equal to\"; }\n  static const char* NegatedDesc() { return \"isn't equal to\"; }\n};\ntemplate <typename Rhs>\nclass NeMatcher : public ComparisonBase<NeMatcher<Rhs>, Rhs, AnyNe> {\n public:\n  explicit NeMatcher(const Rhs& rhs)\n      : ComparisonBase<NeMatcher<Rhs>, Rhs, AnyNe>(rhs) { }\n  static const char* Desc() { return \"isn't equal to\"; }\n  static const char* NegatedDesc() { return \"is equal to\"; }\n};\ntemplate <typename Rhs>\nclass LtMatcher : public ComparisonBase<LtMatcher<Rhs>, Rhs, AnyLt> {\n public:\n  explicit LtMatcher(const Rhs& rhs)\n      : ComparisonBase<LtMatcher<Rhs>, Rhs, AnyLt>(rhs) { }\n  static const char* Desc() { return \"is <\"; }\n  static const char* NegatedDesc() { return \"isn't <\"; }\n};\ntemplate <typename Rhs>\nclass GtMatcher : public ComparisonBase<GtMatcher<Rhs>, Rhs, AnyGt> {\n public:\n  explicit GtMatcher(const Rhs& rhs)\n      : ComparisonBase<GtMatcher<Rhs>, Rhs, AnyGt>(rhs) { }\n  static const char* Desc() { return \"is >\"; }\n  static const char* NegatedDesc() { return \"isn't >\"; }\n};\ntemplate <typename Rhs>\nclass LeMatcher : public ComparisonBase<LeMatcher<Rhs>, Rhs, AnyLe> {\n public:\n  explicit LeMatcher(const Rhs& rhs)\n      : ComparisonBase<LeMatcher<Rhs>, Rhs, AnyLe>(rhs) { }\n  static const char* Desc() { return \"is <=\"; }\n  static const char* NegatedDesc() { return \"isn't <=\"; }\n};\ntemplate <typename Rhs>\nclass GeMatcher : public ComparisonBase<GeMatcher<Rhs>, Rhs, AnyGe> {\n public:\n  explicit GeMatcher(const Rhs& rhs)\n      : ComparisonBase<GeMatcher<Rhs>, Rhs, AnyGe>(rhs) { }\n  static const char* Desc() { return \"is >=\"; }\n  static const char* NegatedDesc() { return \"isn't >=\"; }\n};\n\n// Implements the polymorphic IsNull() matcher, which matches any raw or smart\n// pointer that is NULL.\nclass IsNullMatcher {\n public:\n  template <typename Pointer>\n  bool MatchAndExplain(const Pointer& p,\n                       MatchResultListener* /* listener */) const {\n#if GTEST_LANG_CXX11\n    return p == nullptr;\n#else  // GTEST_LANG_CXX11\n    return GetRawPointer(p) == NULL;\n#endif  // GTEST_LANG_CXX11\n  }\n\n  void DescribeTo(::std::ostream* os) const { *os << \"is NULL\"; }\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"isn't NULL\";\n  }\n};\n\n// Implements the polymorphic NotNull() matcher, which matches any raw or smart\n// pointer that is not NULL.\nclass NotNullMatcher {\n public:\n  template <typename Pointer>\n  bool MatchAndExplain(const Pointer& p,\n                       MatchResultListener* /* listener */) const {\n#if GTEST_LANG_CXX11\n    return p != nullptr;\n#else  // GTEST_LANG_CXX11\n    return GetRawPointer(p) != NULL;\n#endif  // GTEST_LANG_CXX11\n  }\n\n  void DescribeTo(::std::ostream* os) const { *os << \"isn't NULL\"; }\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"is NULL\";\n  }\n};\n\n// Ref(variable) matches any argument that is a reference to\n// 'variable'.  This matcher is polymorphic as it can match any\n// super type of the type of 'variable'.\n//\n// The RefMatcher template class implements Ref(variable).  It can\n// only be instantiated with a reference type.  This prevents a user\n// from mistakenly using Ref(x) to match a non-reference function\n// argument.  For example, the following will righteously cause a\n// compiler error:\n//\n//   int n;\n//   Matcher<int> m1 = Ref(n);   // This won't compile.\n//   Matcher<int&> m2 = Ref(n);  // This will compile.\ntemplate <typename T>\nclass RefMatcher;\n\ntemplate <typename T>\nclass RefMatcher<T&> {\n  // Google Mock is a generic framework and thus needs to support\n  // mocking any function types, including those that take non-const\n  // reference arguments.  Therefore the template parameter T (and\n  // Super below) can be instantiated to either a const type or a\n  // non-const type.\n public:\n  // RefMatcher() takes a T& instead of const T&, as we want the\n  // compiler to catch using Ref(const_value) as a matcher for a\n  // non-const reference.\n  explicit RefMatcher(T& x) : object_(x) {}  // NOLINT\n\n  template <typename Super>\n  operator Matcher<Super&>() const {\n    // By passing object_ (type T&) to Impl(), which expects a Super&,\n    // we make sure that Super is a super type of T.  In particular,\n    // this catches using Ref(const_value) as a matcher for a\n    // non-const reference, as you cannot implicitly convert a const\n    // reference to a non-const reference.\n    return MakeMatcher(new Impl<Super>(object_));\n  }\n\n private:\n  template <typename Super>\n  class Impl : public MatcherInterface<Super&> {\n   public:\n    explicit Impl(Super& x) : object_(x) {}  // NOLINT\n\n    // MatchAndExplain() takes a Super& (as opposed to const Super&)\n    // in order to match the interface MatcherInterface<Super&>.\n    virtual bool MatchAndExplain(\n        Super& x, MatchResultListener* listener) const {\n      *listener << \"which is located @\" << static_cast<const void*>(&x);\n      return &x == &object_;\n    }\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"references the variable \";\n      UniversalPrinter<Super&>::Print(object_, os);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"does not reference the variable \";\n      UniversalPrinter<Super&>::Print(object_, os);\n    }\n\n   private:\n    const Super& object_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  T& object_;\n\n  GTEST_DISALLOW_ASSIGN_(RefMatcher);\n};\n\n// Polymorphic helper functions for narrow and wide string matchers.\ninline bool CaseInsensitiveCStringEquals(const char* lhs, const char* rhs) {\n  return String::CaseInsensitiveCStringEquals(lhs, rhs);\n}\n\ninline bool CaseInsensitiveCStringEquals(const wchar_t* lhs,\n                                         const wchar_t* rhs) {\n  return String::CaseInsensitiveWideCStringEquals(lhs, rhs);\n}\n\n// String comparison for narrow or wide strings that can have embedded NUL\n// characters.\ntemplate <typename StringType>\nbool CaseInsensitiveStringEquals(const StringType& s1,\n                                 const StringType& s2) {\n  // Are the heads equal?\n  if (!CaseInsensitiveCStringEquals(s1.c_str(), s2.c_str())) {\n    return false;\n  }\n\n  // Skip the equal heads.\n  const typename StringType::value_type nul = 0;\n  const size_t i1 = s1.find(nul), i2 = s2.find(nul);\n\n  // Are we at the end of either s1 or s2?\n  if (i1 == StringType::npos || i2 == StringType::npos) {\n    return i1 == i2;\n  }\n\n  // Are the tails equal?\n  return CaseInsensitiveStringEquals(s1.substr(i1 + 1), s2.substr(i2 + 1));\n}\n\n// String matchers.\n\n// Implements equality-based string matchers like StrEq, StrCaseNe, and etc.\ntemplate <typename StringType>\nclass StrEqualityMatcher {\n public:\n  StrEqualityMatcher(const StringType& str, bool expect_eq,\n                     bool case_sensitive)\n      : string_(str), expect_eq_(expect_eq), case_sensitive_(case_sensitive) {}\n\n  // Accepts pointer types, particularly:\n  //   const char*\n  //   char*\n  //   const wchar_t*\n  //   wchar_t*\n  template <typename CharType>\n  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {\n    if (s == NULL) {\n      return !expect_eq_;\n    }\n    return MatchAndExplain(StringType(s), listener);\n  }\n\n  // Matches anything that can convert to StringType.\n  //\n  // This is a template, not just a plain function with const StringType&,\n  // because StringPiece has some interfering non-explicit constructors.\n  template <typename MatcheeStringType>\n  bool MatchAndExplain(const MatcheeStringType& s,\n                       MatchResultListener* /* listener */) const {\n    const StringType& s2(s);\n    const bool eq = case_sensitive_ ? s2 == string_ :\n        CaseInsensitiveStringEquals(s2, string_);\n    return expect_eq_ == eq;\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    DescribeToHelper(expect_eq_, os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    DescribeToHelper(!expect_eq_, os);\n  }\n\n private:\n  void DescribeToHelper(bool expect_eq, ::std::ostream* os) const {\n    *os << (expect_eq ? \"is \" : \"isn't \");\n    *os << \"equal to \";\n    if (!case_sensitive_) {\n      *os << \"(ignoring case) \";\n    }\n    UniversalPrint(string_, os);\n  }\n\n  const StringType string_;\n  const bool expect_eq_;\n  const bool case_sensitive_;\n\n  GTEST_DISALLOW_ASSIGN_(StrEqualityMatcher);\n};\n\n// Implements the polymorphic HasSubstr(substring) matcher, which\n// can be used as a Matcher<T> as long as T can be converted to a\n// string.\ntemplate <typename StringType>\nclass HasSubstrMatcher {\n public:\n  explicit HasSubstrMatcher(const StringType& substring)\n      : substring_(substring) {}\n\n  // Accepts pointer types, particularly:\n  //   const char*\n  //   char*\n  //   const wchar_t*\n  //   wchar_t*\n  template <typename CharType>\n  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {\n    return s != NULL && MatchAndExplain(StringType(s), listener);\n  }\n\n  // Matches anything that can convert to StringType.\n  //\n  // This is a template, not just a plain function with const StringType&,\n  // because StringPiece has some interfering non-explicit constructors.\n  template <typename MatcheeStringType>\n  bool MatchAndExplain(const MatcheeStringType& s,\n                       MatchResultListener* /* listener */) const {\n    const StringType& s2(s);\n    return s2.find(substring_) != StringType::npos;\n  }\n\n  // Describes what this matcher matches.\n  void DescribeTo(::std::ostream* os) const {\n    *os << \"has substring \";\n    UniversalPrint(substring_, os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"has no substring \";\n    UniversalPrint(substring_, os);\n  }\n\n private:\n  const StringType substring_;\n\n  GTEST_DISALLOW_ASSIGN_(HasSubstrMatcher);\n};\n\n// Implements the polymorphic StartsWith(substring) matcher, which\n// can be used as a Matcher<T> as long as T can be converted to a\n// string.\ntemplate <typename StringType>\nclass StartsWithMatcher {\n public:\n  explicit StartsWithMatcher(const StringType& prefix) : prefix_(prefix) {\n  }\n\n  // Accepts pointer types, particularly:\n  //   const char*\n  //   char*\n  //   const wchar_t*\n  //   wchar_t*\n  template <typename CharType>\n  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {\n    return s != NULL && MatchAndExplain(StringType(s), listener);\n  }\n\n  // Matches anything that can convert to StringType.\n  //\n  // This is a template, not just a plain function with const StringType&,\n  // because StringPiece has some interfering non-explicit constructors.\n  template <typename MatcheeStringType>\n  bool MatchAndExplain(const MatcheeStringType& s,\n                       MatchResultListener* /* listener */) const {\n    const StringType& s2(s);\n    return s2.length() >= prefix_.length() &&\n        s2.substr(0, prefix_.length()) == prefix_;\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    *os << \"starts with \";\n    UniversalPrint(prefix_, os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"doesn't start with \";\n    UniversalPrint(prefix_, os);\n  }\n\n private:\n  const StringType prefix_;\n\n  GTEST_DISALLOW_ASSIGN_(StartsWithMatcher);\n};\n\n// Implements the polymorphic EndsWith(substring) matcher, which\n// can be used as a Matcher<T> as long as T can be converted to a\n// string.\ntemplate <typename StringType>\nclass EndsWithMatcher {\n public:\n  explicit EndsWithMatcher(const StringType& suffix) : suffix_(suffix) {}\n\n  // Accepts pointer types, particularly:\n  //   const char*\n  //   char*\n  //   const wchar_t*\n  //   wchar_t*\n  template <typename CharType>\n  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {\n    return s != NULL && MatchAndExplain(StringType(s), listener);\n  }\n\n  // Matches anything that can convert to StringType.\n  //\n  // This is a template, not just a plain function with const StringType&,\n  // because StringPiece has some interfering non-explicit constructors.\n  template <typename MatcheeStringType>\n  bool MatchAndExplain(const MatcheeStringType& s,\n                       MatchResultListener* /* listener */) const {\n    const StringType& s2(s);\n    return s2.length() >= suffix_.length() &&\n        s2.substr(s2.length() - suffix_.length()) == suffix_;\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    *os << \"ends with \";\n    UniversalPrint(suffix_, os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"doesn't end with \";\n    UniversalPrint(suffix_, os);\n  }\n\n private:\n  const StringType suffix_;\n\n  GTEST_DISALLOW_ASSIGN_(EndsWithMatcher);\n};\n\n// Implements polymorphic matchers MatchesRegex(regex) and\n// ContainsRegex(regex), which can be used as a Matcher<T> as long as\n// T can be converted to a string.\nclass MatchesRegexMatcher {\n public:\n  MatchesRegexMatcher(const RE* regex, bool full_match)\n      : regex_(regex), full_match_(full_match) {}\n\n  // Accepts pointer types, particularly:\n  //   const char*\n  //   char*\n  //   const wchar_t*\n  //   wchar_t*\n  template <typename CharType>\n  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {\n    return s != NULL && MatchAndExplain(internal::string(s), listener);\n  }\n\n  // Matches anything that can convert to internal::string.\n  //\n  // This is a template, not just a plain function with const internal::string&,\n  // because StringPiece has some interfering non-explicit constructors.\n  template <class MatcheeStringType>\n  bool MatchAndExplain(const MatcheeStringType& s,\n                       MatchResultListener* /* listener */) const {\n    const internal::string& s2(s);\n    return full_match_ ? RE::FullMatch(s2, *regex_) :\n        RE::PartialMatch(s2, *regex_);\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    *os << (full_match_ ? \"matches\" : \"contains\")\n        << \" regular expression \";\n    UniversalPrinter<internal::string>::Print(regex_->pattern(), os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"doesn't \" << (full_match_ ? \"match\" : \"contain\")\n        << \" regular expression \";\n    UniversalPrinter<internal::string>::Print(regex_->pattern(), os);\n  }\n\n private:\n  const internal::linked_ptr<const RE> regex_;\n  const bool full_match_;\n\n  GTEST_DISALLOW_ASSIGN_(MatchesRegexMatcher);\n};\n\n// Implements a matcher that compares the two fields of a 2-tuple\n// using one of the ==, <=, <, etc, operators.  The two fields being\n// compared don't have to have the same type.\n//\n// The matcher defined here is polymorphic (for example, Eq() can be\n// used to match a tuple<int, short>, a tuple<const long&, double>,\n// etc).  Therefore we use a template type conversion operator in the\n// implementation.\ntemplate <typename D, typename Op>\nclass PairMatchBase {\n public:\n  template <typename T1, typename T2>\n  operator Matcher< ::testing::tuple<T1, T2> >() const {\n    return MakeMatcher(new Impl< ::testing::tuple<T1, T2> >);\n  }\n  template <typename T1, typename T2>\n  operator Matcher<const ::testing::tuple<T1, T2>&>() const {\n    return MakeMatcher(new Impl<const ::testing::tuple<T1, T2>&>);\n  }\n\n private:\n  static ::std::ostream& GetDesc(::std::ostream& os) {  // NOLINT\n    return os << D::Desc();\n  }\n\n  template <typename Tuple>\n  class Impl : public MatcherInterface<Tuple> {\n   public:\n    virtual bool MatchAndExplain(\n        Tuple args,\n        MatchResultListener* /* listener */) const {\n      return Op()(::testing::get<0>(args), ::testing::get<1>(args));\n    }\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"are \" << GetDesc;\n    }\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"aren't \" << GetDesc;\n    }\n  };\n};\n\nclass Eq2Matcher : public PairMatchBase<Eq2Matcher, AnyEq> {\n public:\n  static const char* Desc() { return \"an equal pair\"; }\n};\nclass Ne2Matcher : public PairMatchBase<Ne2Matcher, AnyNe> {\n public:\n  static const char* Desc() { return \"an unequal pair\"; }\n};\nclass Lt2Matcher : public PairMatchBase<Lt2Matcher, AnyLt> {\n public:\n  static const char* Desc() { return \"a pair where the first < the second\"; }\n};\nclass Gt2Matcher : public PairMatchBase<Gt2Matcher, AnyGt> {\n public:\n  static const char* Desc() { return \"a pair where the first > the second\"; }\n};\nclass Le2Matcher : public PairMatchBase<Le2Matcher, AnyLe> {\n public:\n  static const char* Desc() { return \"a pair where the first <= the second\"; }\n};\nclass Ge2Matcher : public PairMatchBase<Ge2Matcher, AnyGe> {\n public:\n  static const char* Desc() { return \"a pair where the first >= the second\"; }\n};\n\n// Implements the Not(...) matcher for a particular argument type T.\n// We do not nest it inside the NotMatcher class template, as that\n// will prevent different instantiations of NotMatcher from sharing\n// the same NotMatcherImpl<T> class.\ntemplate <typename T>\nclass NotMatcherImpl : public MatcherInterface<T> {\n public:\n  explicit NotMatcherImpl(const Matcher<T>& matcher)\n      : matcher_(matcher) {}\n\n  virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {\n    return !matcher_.MatchAndExplain(x, listener);\n  }\n\n  virtual void DescribeTo(::std::ostream* os) const {\n    matcher_.DescribeNegationTo(os);\n  }\n\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    matcher_.DescribeTo(os);\n  }\n\n private:\n  const Matcher<T> matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(NotMatcherImpl);\n};\n\n// Implements the Not(m) matcher, which matches a value that doesn't\n// match matcher m.\ntemplate <typename InnerMatcher>\nclass NotMatcher {\n public:\n  explicit NotMatcher(InnerMatcher matcher) : matcher_(matcher) {}\n\n  // This template type conversion operator allows Not(m) to be used\n  // to match any type m can match.\n  template <typename T>\n  operator Matcher<T>() const {\n    return Matcher<T>(new NotMatcherImpl<T>(SafeMatcherCast<T>(matcher_)));\n  }\n\n private:\n  InnerMatcher matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(NotMatcher);\n};\n\n// Implements the AllOf(m1, m2) matcher for a particular argument type\n// T. We do not nest it inside the BothOfMatcher class template, as\n// that will prevent different instantiations of BothOfMatcher from\n// sharing the same BothOfMatcherImpl<T> class.\ntemplate <typename T>\nclass BothOfMatcherImpl : public MatcherInterface<T> {\n public:\n  BothOfMatcherImpl(const Matcher<T>& matcher1, const Matcher<T>& matcher2)\n      : matcher1_(matcher1), matcher2_(matcher2) {}\n\n  virtual void DescribeTo(::std::ostream* os) const {\n    *os << \"(\";\n    matcher1_.DescribeTo(os);\n    *os << \") and (\";\n    matcher2_.DescribeTo(os);\n    *os << \")\";\n  }\n\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"(\";\n    matcher1_.DescribeNegationTo(os);\n    *os << \") or (\";\n    matcher2_.DescribeNegationTo(os);\n    *os << \")\";\n  }\n\n  virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {\n    // If either matcher1_ or matcher2_ doesn't match x, we only need\n    // to explain why one of them fails.\n    StringMatchResultListener listener1;\n    if (!matcher1_.MatchAndExplain(x, &listener1)) {\n      *listener << listener1.str();\n      return false;\n    }\n\n    StringMatchResultListener listener2;\n    if (!matcher2_.MatchAndExplain(x, &listener2)) {\n      *listener << listener2.str();\n      return false;\n    }\n\n    // Otherwise we need to explain why *both* of them match.\n    const internal::string s1 = listener1.str();\n    const internal::string s2 = listener2.str();\n\n    if (s1 == \"\") {\n      *listener << s2;\n    } else {\n      *listener << s1;\n      if (s2 != \"\") {\n        *listener << \", and \" << s2;\n      }\n    }\n    return true;\n  }\n\n private:\n  const Matcher<T> matcher1_;\n  const Matcher<T> matcher2_;\n\n  GTEST_DISALLOW_ASSIGN_(BothOfMatcherImpl);\n};\n\n#if GTEST_LANG_CXX11\n// MatcherList provides mechanisms for storing a variable number of matchers in\n// a list structure (ListType) and creating a combining matcher from such a\n// list.\n// The template is defined recursively using the following template paramters:\n//   * kSize is the length of the MatcherList.\n//   * Head is the type of the first matcher of the list.\n//   * Tail denotes the types of the remaining matchers of the list.\ntemplate <int kSize, typename Head, typename... Tail>\nstruct MatcherList {\n  typedef MatcherList<kSize - 1, Tail...> MatcherListTail;\n  typedef ::std::pair<Head, typename MatcherListTail::ListType> ListType;\n\n  // BuildList stores variadic type values in a nested pair structure.\n  // Example:\n  // MatcherList<3, int, string, float>::BuildList(5, \"foo\", 2.0) will return\n  // the corresponding result of type pair<int, pair<string, float>>.\n  static ListType BuildList(const Head& matcher, const Tail&... tail) {\n    return ListType(matcher, MatcherListTail::BuildList(tail...));\n  }\n\n  // CreateMatcher<T> creates a Matcher<T> from a given list of matchers (built\n  // by BuildList()). CombiningMatcher<T> is used to combine the matchers of the\n  // list. CombiningMatcher<T> must implement MatcherInterface<T> and have a\n  // constructor taking two Matcher<T>s as input.\n  template <typename T, template <typename /* T */> class CombiningMatcher>\n  static Matcher<T> CreateMatcher(const ListType& matchers) {\n    return Matcher<T>(new CombiningMatcher<T>(\n        SafeMatcherCast<T>(matchers.first),\n        MatcherListTail::template CreateMatcher<T, CombiningMatcher>(\n            matchers.second)));\n  }\n};\n\n// The following defines the base case for the recursive definition of\n// MatcherList.\ntemplate <typename Matcher1, typename Matcher2>\nstruct MatcherList<2, Matcher1, Matcher2> {\n  typedef ::std::pair<Matcher1, Matcher2> ListType;\n\n  static ListType BuildList(const Matcher1& matcher1,\n                            const Matcher2& matcher2) {\n    return ::std::pair<Matcher1, Matcher2>(matcher1, matcher2);\n  }\n\n  template <typename T, template <typename /* T */> class CombiningMatcher>\n  static Matcher<T> CreateMatcher(const ListType& matchers) {\n    return Matcher<T>(new CombiningMatcher<T>(\n        SafeMatcherCast<T>(matchers.first),\n        SafeMatcherCast<T>(matchers.second)));\n  }\n};\n\n// VariadicMatcher is used for the variadic implementation of\n// AllOf(m_1, m_2, ...) and AnyOf(m_1, m_2, ...).\n// CombiningMatcher<T> is used to recursively combine the provided matchers\n// (of type Args...).\ntemplate <template <typename T> class CombiningMatcher, typename... Args>\nclass VariadicMatcher {\n public:\n  VariadicMatcher(const Args&... matchers)  // NOLINT\n      : matchers_(MatcherListType::BuildList(matchers...)) {}\n\n  // This template type conversion operator allows an\n  // VariadicMatcher<Matcher1, Matcher2...> object to match any type that\n  // all of the provided matchers (Matcher1, Matcher2, ...) can match.\n  template <typename T>\n  operator Matcher<T>() const {\n    return MatcherListType::template CreateMatcher<T, CombiningMatcher>(\n        matchers_);\n  }\n\n private:\n  typedef MatcherList<sizeof...(Args), Args...> MatcherListType;\n\n  const typename MatcherListType::ListType matchers_;\n\n  GTEST_DISALLOW_ASSIGN_(VariadicMatcher);\n};\n\ntemplate <typename... Args>\nusing AllOfMatcher = VariadicMatcher<BothOfMatcherImpl, Args...>;\n\n#endif  // GTEST_LANG_CXX11\n\n// Used for implementing the AllOf(m_1, ..., m_n) matcher, which\n// matches a value that matches all of the matchers m_1, ..., and m_n.\ntemplate <typename Matcher1, typename Matcher2>\nclass BothOfMatcher {\n public:\n  BothOfMatcher(Matcher1 matcher1, Matcher2 matcher2)\n      : matcher1_(matcher1), matcher2_(matcher2) {}\n\n  // This template type conversion operator allows a\n  // BothOfMatcher<Matcher1, Matcher2> object to match any type that\n  // both Matcher1 and Matcher2 can match.\n  template <typename T>\n  operator Matcher<T>() const {\n    return Matcher<T>(new BothOfMatcherImpl<T>(SafeMatcherCast<T>(matcher1_),\n                                               SafeMatcherCast<T>(matcher2_)));\n  }\n\n private:\n  Matcher1 matcher1_;\n  Matcher2 matcher2_;\n\n  GTEST_DISALLOW_ASSIGN_(BothOfMatcher);\n};\n\n// Implements the AnyOf(m1, m2) matcher for a particular argument type\n// T.  We do not nest it inside the AnyOfMatcher class template, as\n// that will prevent different instantiations of AnyOfMatcher from\n// sharing the same EitherOfMatcherImpl<T> class.\ntemplate <typename T>\nclass EitherOfMatcherImpl : public MatcherInterface<T> {\n public:\n  EitherOfMatcherImpl(const Matcher<T>& matcher1, const Matcher<T>& matcher2)\n      : matcher1_(matcher1), matcher2_(matcher2) {}\n\n  virtual void DescribeTo(::std::ostream* os) const {\n    *os << \"(\";\n    matcher1_.DescribeTo(os);\n    *os << \") or (\";\n    matcher2_.DescribeTo(os);\n    *os << \")\";\n  }\n\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"(\";\n    matcher1_.DescribeNegationTo(os);\n    *os << \") and (\";\n    matcher2_.DescribeNegationTo(os);\n    *os << \")\";\n  }\n\n  virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {\n    // If either matcher1_ or matcher2_ matches x, we just need to\n    // explain why *one* of them matches.\n    StringMatchResultListener listener1;\n    if (matcher1_.MatchAndExplain(x, &listener1)) {\n      *listener << listener1.str();\n      return true;\n    }\n\n    StringMatchResultListener listener2;\n    if (matcher2_.MatchAndExplain(x, &listener2)) {\n      *listener << listener2.str();\n      return true;\n    }\n\n    // Otherwise we need to explain why *both* of them fail.\n    const internal::string s1 = listener1.str();\n    const internal::string s2 = listener2.str();\n\n    if (s1 == \"\") {\n      *listener << s2;\n    } else {\n      *listener << s1;\n      if (s2 != \"\") {\n        *listener << \", and \" << s2;\n      }\n    }\n    return false;\n  }\n\n private:\n  const Matcher<T> matcher1_;\n  const Matcher<T> matcher2_;\n\n  GTEST_DISALLOW_ASSIGN_(EitherOfMatcherImpl);\n};\n\n#if GTEST_LANG_CXX11\n// AnyOfMatcher is used for the variadic implementation of AnyOf(m_1, m_2, ...).\ntemplate <typename... Args>\nusing AnyOfMatcher = VariadicMatcher<EitherOfMatcherImpl, Args...>;\n\n#endif  // GTEST_LANG_CXX11\n\n// Used for implementing the AnyOf(m_1, ..., m_n) matcher, which\n// matches a value that matches at least one of the matchers m_1, ...,\n// and m_n.\ntemplate <typename Matcher1, typename Matcher2>\nclass EitherOfMatcher {\n public:\n  EitherOfMatcher(Matcher1 matcher1, Matcher2 matcher2)\n      : matcher1_(matcher1), matcher2_(matcher2) {}\n\n  // This template type conversion operator allows a\n  // EitherOfMatcher<Matcher1, Matcher2> object to match any type that\n  // both Matcher1 and Matcher2 can match.\n  template <typename T>\n  operator Matcher<T>() const {\n    return Matcher<T>(new EitherOfMatcherImpl<T>(\n        SafeMatcherCast<T>(matcher1_), SafeMatcherCast<T>(matcher2_)));\n  }\n\n private:\n  Matcher1 matcher1_;\n  Matcher2 matcher2_;\n\n  GTEST_DISALLOW_ASSIGN_(EitherOfMatcher);\n};\n\n// Used for implementing Truly(pred), which turns a predicate into a\n// matcher.\ntemplate <typename Predicate>\nclass TrulyMatcher {\n public:\n  explicit TrulyMatcher(Predicate pred) : predicate_(pred) {}\n\n  // This method template allows Truly(pred) to be used as a matcher\n  // for type T where T is the argument type of predicate 'pred'.  The\n  // argument is passed by reference as the predicate may be\n  // interested in the address of the argument.\n  template <typename T>\n  bool MatchAndExplain(T& x,  // NOLINT\n                       MatchResultListener* /* listener */) const {\n    // Without the if-statement, MSVC sometimes warns about converting\n    // a value to bool (warning 4800).\n    //\n    // We cannot write 'return !!predicate_(x);' as that doesn't work\n    // when predicate_(x) returns a class convertible to bool but\n    // having no operator!().\n    if (predicate_(x))\n      return true;\n    return false;\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    *os << \"satisfies the given predicate\";\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"doesn't satisfy the given predicate\";\n  }\n\n private:\n  Predicate predicate_;\n\n  GTEST_DISALLOW_ASSIGN_(TrulyMatcher);\n};\n\n// Used for implementing Matches(matcher), which turns a matcher into\n// a predicate.\ntemplate <typename M>\nclass MatcherAsPredicate {\n public:\n  explicit MatcherAsPredicate(M matcher) : matcher_(matcher) {}\n\n  // This template operator() allows Matches(m) to be used as a\n  // predicate on type T where m is a matcher on type T.\n  //\n  // The argument x is passed by reference instead of by value, as\n  // some matcher may be interested in its address (e.g. as in\n  // Matches(Ref(n))(x)).\n  template <typename T>\n  bool operator()(const T& x) const {\n    // We let matcher_ commit to a particular type here instead of\n    // when the MatcherAsPredicate object was constructed.  This\n    // allows us to write Matches(m) where m is a polymorphic matcher\n    // (e.g. Eq(5)).\n    //\n    // If we write Matcher<T>(matcher_).Matches(x) here, it won't\n    // compile when matcher_ has type Matcher<const T&>; if we write\n    // Matcher<const T&>(matcher_).Matches(x) here, it won't compile\n    // when matcher_ has type Matcher<T>; if we just write\n    // matcher_.Matches(x), it won't compile when matcher_ is\n    // polymorphic, e.g. Eq(5).\n    //\n    // MatcherCast<const T&>() is necessary for making the code work\n    // in all of the above situations.\n    return MatcherCast<const T&>(matcher_).Matches(x);\n  }\n\n private:\n  M matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(MatcherAsPredicate);\n};\n\n// For implementing ASSERT_THAT() and EXPECT_THAT().  The template\n// argument M must be a type that can be converted to a matcher.\ntemplate <typename M>\nclass PredicateFormatterFromMatcher {\n public:\n  explicit PredicateFormatterFromMatcher(M m) : matcher_(internal::move(m)) {}\n\n  // This template () operator allows a PredicateFormatterFromMatcher\n  // object to act as a predicate-formatter suitable for using with\n  // Google Test's EXPECT_PRED_FORMAT1() macro.\n  template <typename T>\n  AssertionResult operator()(const char* value_text, const T& x) const {\n    // We convert matcher_ to a Matcher<const T&> *now* instead of\n    // when the PredicateFormatterFromMatcher object was constructed,\n    // as matcher_ may be polymorphic (e.g. NotNull()) and we won't\n    // know which type to instantiate it to until we actually see the\n    // type of x here.\n    //\n    // We write SafeMatcherCast<const T&>(matcher_) instead of\n    // Matcher<const T&>(matcher_), as the latter won't compile when\n    // matcher_ has type Matcher<T> (e.g. An<int>()).\n    // We don't write MatcherCast<const T&> either, as that allows\n    // potentially unsafe downcasting of the matcher argument.\n    const Matcher<const T&> matcher = SafeMatcherCast<const T&>(matcher_);\n    StringMatchResultListener listener;\n    if (MatchPrintAndExplain(x, matcher, &listener))\n      return AssertionSuccess();\n\n    ::std::stringstream ss;\n    ss << \"Value of: \" << value_text << \"\\n\"\n       << \"Expected: \";\n    matcher.DescribeTo(&ss);\n    ss << \"\\n  Actual: \" << listener.str();\n    return AssertionFailure() << ss.str();\n  }\n\n private:\n  const M matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(PredicateFormatterFromMatcher);\n};\n\n// A helper function for converting a matcher to a predicate-formatter\n// without the user needing to explicitly write the type.  This is\n// used for implementing ASSERT_THAT() and EXPECT_THAT().\n// Implementation detail: 'matcher' is received by-value to force decaying.\ntemplate <typename M>\ninline PredicateFormatterFromMatcher<M>\nMakePredicateFormatterFromMatcher(M matcher) {\n  return PredicateFormatterFromMatcher<M>(internal::move(matcher));\n}\n\n// Implements the polymorphic floating point equality matcher, which matches\n// two float values using ULP-based approximation or, optionally, a\n// user-specified epsilon.  The template is meant to be instantiated with\n// FloatType being either float or double.\ntemplate <typename FloatType>\nclass FloatingEqMatcher {\n public:\n  // Constructor for FloatingEqMatcher.\n  // The matcher's input will be compared with expected.  The matcher treats two\n  // NANs as equal if nan_eq_nan is true.  Otherwise, under IEEE standards,\n  // equality comparisons between NANs will always return false.  We specify a\n  // negative max_abs_error_ term to indicate that ULP-based approximation will\n  // be used for comparison.\n  FloatingEqMatcher(FloatType expected, bool nan_eq_nan) :\n    expected_(expected), nan_eq_nan_(nan_eq_nan), max_abs_error_(-1) {\n  }\n\n  // Constructor that supports a user-specified max_abs_error that will be used\n  // for comparison instead of ULP-based approximation.  The max absolute\n  // should be non-negative.\n  FloatingEqMatcher(FloatType expected, bool nan_eq_nan,\n                    FloatType max_abs_error)\n      : expected_(expected),\n        nan_eq_nan_(nan_eq_nan),\n        max_abs_error_(max_abs_error) {\n    GTEST_CHECK_(max_abs_error >= 0)\n        << \", where max_abs_error is\" << max_abs_error;\n  }\n\n  // Implements floating point equality matcher as a Matcher<T>.\n  template <typename T>\n  class Impl : public MatcherInterface<T> {\n   public:\n    Impl(FloatType expected, bool nan_eq_nan, FloatType max_abs_error)\n        : expected_(expected),\n          nan_eq_nan_(nan_eq_nan),\n          max_abs_error_(max_abs_error) {}\n\n    virtual bool MatchAndExplain(T value,\n                                 MatchResultListener* listener) const {\n      const FloatingPoint<FloatType> actual(value), expected(expected_);\n\n      // Compares NaNs first, if nan_eq_nan_ is true.\n      if (actual.is_nan() || expected.is_nan()) {\n        if (actual.is_nan() && expected.is_nan()) {\n          return nan_eq_nan_;\n        }\n        // One is nan; the other is not nan.\n        return false;\n      }\n      if (HasMaxAbsError()) {\n        // We perform an equality check so that inf will match inf, regardless\n        // of error bounds.  If the result of value - expected_ would result in\n        // overflow or if either value is inf, the default result is infinity,\n        // which should only match if max_abs_error_ is also infinity.\n        if (value == expected_) {\n          return true;\n        }\n\n        const FloatType diff = value - expected_;\n        if (fabs(diff) <= max_abs_error_) {\n          return true;\n        }\n\n        if (listener->IsInterested()) {\n          *listener << \"which is \" << diff << \" from \" << expected_;\n        }\n        return false;\n      } else {\n        return actual.AlmostEquals(expected);\n      }\n    }\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      // os->precision() returns the previously set precision, which we\n      // store to restore the ostream to its original configuration\n      // after outputting.\n      const ::std::streamsize old_precision = os->precision(\n          ::std::numeric_limits<FloatType>::digits10 + 2);\n      if (FloatingPoint<FloatType>(expected_).is_nan()) {\n        if (nan_eq_nan_) {\n          *os << \"is NaN\";\n        } else {\n          *os << \"never matches\";\n        }\n      } else {\n        *os << \"is approximately \" << expected_;\n        if (HasMaxAbsError()) {\n          *os << \" (absolute error <= \" << max_abs_error_ << \")\";\n        }\n      }\n      os->precision(old_precision);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      // As before, get original precision.\n      const ::std::streamsize old_precision = os->precision(\n          ::std::numeric_limits<FloatType>::digits10 + 2);\n      if (FloatingPoint<FloatType>(expected_).is_nan()) {\n        if (nan_eq_nan_) {\n          *os << \"isn't NaN\";\n        } else {\n          *os << \"is anything\";\n        }\n      } else {\n        *os << \"isn't approximately \" << expected_;\n        if (HasMaxAbsError()) {\n          *os << \" (absolute error > \" << max_abs_error_ << \")\";\n        }\n      }\n      // Restore original precision.\n      os->precision(old_precision);\n    }\n\n   private:\n    bool HasMaxAbsError() const {\n      return max_abs_error_ >= 0;\n    }\n\n    const FloatType expected_;\n    const bool nan_eq_nan_;\n    // max_abs_error will be used for value comparison when >= 0.\n    const FloatType max_abs_error_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  // The following 3 type conversion operators allow FloatEq(expected) and\n  // NanSensitiveFloatEq(expected) to be used as a Matcher<float>, a\n  // Matcher<const float&>, or a Matcher<float&>, but nothing else.\n  // (While Google's C++ coding style doesn't allow arguments passed\n  // by non-const reference, we may see them in code not conforming to\n  // the style.  Therefore Google Mock needs to support them.)\n  operator Matcher<FloatType>() const {\n    return MakeMatcher(\n        new Impl<FloatType>(expected_, nan_eq_nan_, max_abs_error_));\n  }\n\n  operator Matcher<const FloatType&>() const {\n    return MakeMatcher(\n        new Impl<const FloatType&>(expected_, nan_eq_nan_, max_abs_error_));\n  }\n\n  operator Matcher<FloatType&>() const {\n    return MakeMatcher(\n        new Impl<FloatType&>(expected_, nan_eq_nan_, max_abs_error_));\n  }\n\n private:\n  const FloatType expected_;\n  const bool nan_eq_nan_;\n  // max_abs_error will be used for value comparison when >= 0.\n  const FloatType max_abs_error_;\n\n  GTEST_DISALLOW_ASSIGN_(FloatingEqMatcher);\n};\n\n// Implements the Pointee(m) matcher for matching a pointer whose\n// pointee matches matcher m.  The pointer can be either raw or smart.\ntemplate <typename InnerMatcher>\nclass PointeeMatcher {\n public:\n  explicit PointeeMatcher(const InnerMatcher& matcher) : matcher_(matcher) {}\n\n  // This type conversion operator template allows Pointee(m) to be\n  // used as a matcher for any pointer type whose pointee type is\n  // compatible with the inner matcher, where type Pointer can be\n  // either a raw pointer or a smart pointer.\n  //\n  // The reason we do this instead of relying on\n  // MakePolymorphicMatcher() is that the latter is not flexible\n  // enough for implementing the DescribeTo() method of Pointee().\n  template <typename Pointer>\n  operator Matcher<Pointer>() const {\n    return MakeMatcher(new Impl<Pointer>(matcher_));\n  }\n\n private:\n  // The monomorphic implementation that works for a particular pointer type.\n  template <typename Pointer>\n  class Impl : public MatcherInterface<Pointer> {\n   public:\n    typedef typename PointeeOf<GTEST_REMOVE_CONST_(  // NOLINT\n        GTEST_REMOVE_REFERENCE_(Pointer))>::type Pointee;\n\n    explicit Impl(const InnerMatcher& matcher)\n        : matcher_(MatcherCast<const Pointee&>(matcher)) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"points to a value that \";\n      matcher_.DescribeTo(os);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"does not point to a value that \";\n      matcher_.DescribeTo(os);\n    }\n\n    virtual bool MatchAndExplain(Pointer pointer,\n                                 MatchResultListener* listener) const {\n      if (GetRawPointer(pointer) == NULL)\n        return false;\n\n      *listener << \"which points to \";\n      return MatchPrintAndExplain(*pointer, matcher_, listener);\n    }\n\n   private:\n    const Matcher<const Pointee&> matcher_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  const InnerMatcher matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(PointeeMatcher);\n};\n\n// Implements the WhenDynamicCastTo<T>(m) matcher that matches a pointer or\n// reference that matches inner_matcher when dynamic_cast<T> is applied.\n// The result of dynamic_cast<To> is forwarded to the inner matcher.\n// If To is a pointer and the cast fails, the inner matcher will receive NULL.\n// If To is a reference and the cast fails, this matcher returns false\n// immediately.\ntemplate <typename To>\nclass WhenDynamicCastToMatcherBase {\n public:\n  explicit WhenDynamicCastToMatcherBase(const Matcher<To>& matcher)\n      : matcher_(matcher) {}\n\n  void DescribeTo(::std::ostream* os) const {\n    GetCastTypeDescription(os);\n    matcher_.DescribeTo(os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    GetCastTypeDescription(os);\n    matcher_.DescribeNegationTo(os);\n  }\n\n protected:\n  const Matcher<To> matcher_;\n\n  static string GetToName() {\n#if GTEST_HAS_RTTI\n    return GetTypeName<To>();\n#else  // GTEST_HAS_RTTI\n    return \"the target type\";\n#endif  // GTEST_HAS_RTTI\n  }\n\n private:\n  static void GetCastTypeDescription(::std::ostream* os) {\n    *os << \"when dynamic_cast to \" << GetToName() << \", \";\n  }\n\n  GTEST_DISALLOW_ASSIGN_(WhenDynamicCastToMatcherBase);\n};\n\n// Primary template.\n// To is a pointer. Cast and forward the result.\ntemplate <typename To>\nclass WhenDynamicCastToMatcher : public WhenDynamicCastToMatcherBase<To> {\n public:\n  explicit WhenDynamicCastToMatcher(const Matcher<To>& matcher)\n      : WhenDynamicCastToMatcherBase<To>(matcher) {}\n\n  template <typename From>\n  bool MatchAndExplain(From from, MatchResultListener* listener) const {\n    // TODO(sbenza): Add more detail on failures. ie did the dyn_cast fail?\n    To to = dynamic_cast<To>(from);\n    return MatchPrintAndExplain(to, this->matcher_, listener);\n  }\n};\n\n// Specialize for references.\n// In this case we return false if the dynamic_cast fails.\ntemplate <typename To>\nclass WhenDynamicCastToMatcher<To&> : public WhenDynamicCastToMatcherBase<To&> {\n public:\n  explicit WhenDynamicCastToMatcher(const Matcher<To&>& matcher)\n      : WhenDynamicCastToMatcherBase<To&>(matcher) {}\n\n  template <typename From>\n  bool MatchAndExplain(From& from, MatchResultListener* listener) const {\n    // We don't want an std::bad_cast here, so do the cast with pointers.\n    To* to = dynamic_cast<To*>(&from);\n    if (to == NULL) {\n      *listener << \"which cannot be dynamic_cast to \" << this->GetToName();\n      return false;\n    }\n    return MatchPrintAndExplain(*to, this->matcher_, listener);\n  }\n};\n\n// Implements the Field() matcher for matching a field (i.e. member\n// variable) of an object.\ntemplate <typename Class, typename FieldType>\nclass FieldMatcher {\n public:\n  FieldMatcher(FieldType Class::*field,\n               const Matcher<const FieldType&>& matcher)\n      : field_(field), matcher_(matcher) {}\n\n  void DescribeTo(::std::ostream* os) const {\n    *os << \"is an object whose given field \";\n    matcher_.DescribeTo(os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"is an object whose given field \";\n    matcher_.DescribeNegationTo(os);\n  }\n\n  template <typename T>\n  bool MatchAndExplain(const T& value, MatchResultListener* listener) const {\n    return MatchAndExplainImpl(\n        typename ::testing::internal::\n            is_pointer<GTEST_REMOVE_CONST_(T)>::type(),\n        value, listener);\n  }\n\n private:\n  // The first argument of MatchAndExplainImpl() is needed to help\n  // Symbian's C++ compiler choose which overload to use.  Its type is\n  // true_type iff the Field() matcher is used to match a pointer.\n  bool MatchAndExplainImpl(false_type /* is_not_pointer */, const Class& obj,\n                           MatchResultListener* listener) const {\n    *listener << \"whose given field is \";\n    return MatchPrintAndExplain(obj.*field_, matcher_, listener);\n  }\n\n  bool MatchAndExplainImpl(true_type /* is_pointer */, const Class* p,\n                           MatchResultListener* listener) const {\n    if (p == NULL)\n      return false;\n\n    *listener << \"which points to an object \";\n    // Since *p has a field, it must be a class/struct/union type and\n    // thus cannot be a pointer.  Therefore we pass false_type() as\n    // the first argument.\n    return MatchAndExplainImpl(false_type(), *p, listener);\n  }\n\n  const FieldType Class::*field_;\n  const Matcher<const FieldType&> matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(FieldMatcher);\n};\n\n// Implements the Property() matcher for matching a property\n// (i.e. return value of a getter method) of an object.\ntemplate <typename Class, typename PropertyType>\nclass PropertyMatcher {\n public:\n  // The property may have a reference type, so 'const PropertyType&'\n  // may cause double references and fail to compile.  That's why we\n  // need GTEST_REFERENCE_TO_CONST, which works regardless of\n  // PropertyType being a reference or not.\n  typedef GTEST_REFERENCE_TO_CONST_(PropertyType) RefToConstProperty;\n\n  PropertyMatcher(PropertyType (Class::*property)() const,\n                  const Matcher<RefToConstProperty>& matcher)\n      : property_(property), matcher_(matcher) {}\n\n  void DescribeTo(::std::ostream* os) const {\n    *os << \"is an object whose given property \";\n    matcher_.DescribeTo(os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"is an object whose given property \";\n    matcher_.DescribeNegationTo(os);\n  }\n\n  template <typename T>\n  bool MatchAndExplain(const T&value, MatchResultListener* listener) const {\n    return MatchAndExplainImpl(\n        typename ::testing::internal::\n            is_pointer<GTEST_REMOVE_CONST_(T)>::type(),\n        value, listener);\n  }\n\n private:\n  // The first argument of MatchAndExplainImpl() is needed to help\n  // Symbian's C++ compiler choose which overload to use.  Its type is\n  // true_type iff the Property() matcher is used to match a pointer.\n  bool MatchAndExplainImpl(false_type /* is_not_pointer */, const Class& obj,\n                           MatchResultListener* listener) const {\n    *listener << \"whose given property is \";\n    // Cannot pass the return value (for example, int) to MatchPrintAndExplain,\n    // which takes a non-const reference as argument.\n#if defined(_PREFAST_ ) && _MSC_VER == 1800\n    // Workaround bug in VC++ 2013's /analyze parser.\n    // https://connect.microsoft.com/VisualStudio/feedback/details/1106363/internal-compiler-error-with-analyze-due-to-failure-to-infer-move\n    posix::Abort();  // To make sure it is never run.\n    return false;\n#else\n    RefToConstProperty result = (obj.*property_)();\n    return MatchPrintAndExplain(result, matcher_, listener);\n#endif\n  }\n\n  bool MatchAndExplainImpl(true_type /* is_pointer */, const Class* p,\n                           MatchResultListener* listener) const {\n    if (p == NULL)\n      return false;\n\n    *listener << \"which points to an object \";\n    // Since *p has a property method, it must be a class/struct/union\n    // type and thus cannot be a pointer.  Therefore we pass\n    // false_type() as the first argument.\n    return MatchAndExplainImpl(false_type(), *p, listener);\n  }\n\n  PropertyType (Class::*property_)() const;\n  const Matcher<RefToConstProperty> matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(PropertyMatcher);\n};\n\n// Type traits specifying various features of different functors for ResultOf.\n// The default template specifies features for functor objects.\n// Functor classes have to typedef argument_type and result_type\n// to be compatible with ResultOf.\ntemplate <typename Functor>\nstruct CallableTraits {\n  typedef typename Functor::result_type ResultType;\n  typedef Functor StorageType;\n\n  static void CheckIsValid(Functor /* functor */) {}\n  template <typename T>\n  static ResultType Invoke(Functor f, T arg) { return f(arg); }\n};\n\n// Specialization for function pointers.\ntemplate <typename ArgType, typename ResType>\nstruct CallableTraits<ResType(*)(ArgType)> {\n  typedef ResType ResultType;\n  typedef ResType(*StorageType)(ArgType);\n\n  static void CheckIsValid(ResType(*f)(ArgType)) {\n    GTEST_CHECK_(f != NULL)\n        << \"NULL function pointer is passed into ResultOf().\";\n  }\n  template <typename T>\n  static ResType Invoke(ResType(*f)(ArgType), T arg) {\n    return (*f)(arg);\n  }\n};\n\n// Implements the ResultOf() matcher for matching a return value of a\n// unary function of an object.\ntemplate <typename Callable>\nclass ResultOfMatcher {\n public:\n  typedef typename CallableTraits<Callable>::ResultType ResultType;\n\n  ResultOfMatcher(Callable callable, const Matcher<ResultType>& matcher)\n      : callable_(callable), matcher_(matcher) {\n    CallableTraits<Callable>::CheckIsValid(callable_);\n  }\n\n  template <typename T>\n  operator Matcher<T>() const {\n    return Matcher<T>(new Impl<T>(callable_, matcher_));\n  }\n\n private:\n  typedef typename CallableTraits<Callable>::StorageType CallableStorageType;\n\n  template <typename T>\n  class Impl : public MatcherInterface<T> {\n   public:\n    Impl(CallableStorageType callable, const Matcher<ResultType>& matcher)\n        : callable_(callable), matcher_(matcher) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"is mapped by the given callable to a value that \";\n      matcher_.DescribeTo(os);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"is mapped by the given callable to a value that \";\n      matcher_.DescribeNegationTo(os);\n    }\n\n    virtual bool MatchAndExplain(T obj, MatchResultListener* listener) const {\n      *listener << \"which is mapped by the given callable to \";\n      // Cannot pass the return value (for example, int) to\n      // MatchPrintAndExplain, which takes a non-const reference as argument.\n      ResultType result =\n          CallableTraits<Callable>::template Invoke<T>(callable_, obj);\n      return MatchPrintAndExplain(result, matcher_, listener);\n    }\n\n   private:\n    // Functors often define operator() as non-const method even though\n    // they are actualy stateless. But we need to use them even when\n    // 'this' is a const pointer. It's the user's responsibility not to\n    // use stateful callables with ResultOf(), which does't guarantee\n    // how many times the callable will be invoked.\n    mutable CallableStorageType callable_;\n    const Matcher<ResultType> matcher_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };  // class Impl\n\n  const CallableStorageType callable_;\n  const Matcher<ResultType> matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(ResultOfMatcher);\n};\n\n// Implements a matcher that checks the size of an STL-style container.\ntemplate <typename SizeMatcher>\nclass SizeIsMatcher {\n public:\n  explicit SizeIsMatcher(const SizeMatcher& size_matcher)\n       : size_matcher_(size_matcher) {\n  }\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    return MakeMatcher(new Impl<Container>(size_matcher_));\n  }\n\n  template <typename Container>\n  class Impl : public MatcherInterface<Container> {\n   public:\n    typedef internal::StlContainerView<\n         GTEST_REMOVE_REFERENCE_AND_CONST_(Container)> ContainerView;\n    typedef typename ContainerView::type::size_type SizeType;\n    explicit Impl(const SizeMatcher& size_matcher)\n        : size_matcher_(MatcherCast<SizeType>(size_matcher)) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"size \";\n      size_matcher_.DescribeTo(os);\n    }\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"size \";\n      size_matcher_.DescribeNegationTo(os);\n    }\n\n    virtual bool MatchAndExplain(Container container,\n                                 MatchResultListener* listener) const {\n      SizeType size = container.size();\n      StringMatchResultListener size_listener;\n      const bool result = size_matcher_.MatchAndExplain(size, &size_listener);\n      *listener\n          << \"whose size \" << size << (result ? \" matches\" : \" doesn't match\");\n      PrintIfNotEmpty(size_listener.str(), listener->stream());\n      return result;\n    }\n\n   private:\n    const Matcher<SizeType> size_matcher_;\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n private:\n  const SizeMatcher size_matcher_;\n  GTEST_DISALLOW_ASSIGN_(SizeIsMatcher);\n};\n\n// Implements a matcher that checks the begin()..end() distance of an STL-style\n// container.\ntemplate <typename DistanceMatcher>\nclass BeginEndDistanceIsMatcher {\n public:\n  explicit BeginEndDistanceIsMatcher(const DistanceMatcher& distance_matcher)\n      : distance_matcher_(distance_matcher) {}\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    return MakeMatcher(new Impl<Container>(distance_matcher_));\n  }\n\n  template <typename Container>\n  class Impl : public MatcherInterface<Container> {\n   public:\n    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;\n    typedef internal::StlContainerView<RawContainer> View;\n    typedef typename View::type StlContainer;\n    typedef typename View::const_reference StlContainerReference;\n    typedef decltype(std::begin(\n        std::declval<StlContainerReference>())) StlContainerConstIterator;\n    typedef typename std::iterator_traits<\n        StlContainerConstIterator>::difference_type DistanceType;\n    explicit Impl(const DistanceMatcher& distance_matcher)\n        : distance_matcher_(MatcherCast<DistanceType>(distance_matcher)) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"distance between begin() and end() \";\n      distance_matcher_.DescribeTo(os);\n    }\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"distance between begin() and end() \";\n      distance_matcher_.DescribeNegationTo(os);\n    }\n\n    virtual bool MatchAndExplain(Container container,\n                                 MatchResultListener* listener) const {\n#if GTEST_HAS_STD_BEGIN_AND_END_\n      using std::begin;\n      using std::end;\n      DistanceType distance = std::distance(begin(container), end(container));\n#else\n      DistanceType distance = std::distance(container.begin(), container.end());\n#endif\n      StringMatchResultListener distance_listener;\n      const bool result =\n          distance_matcher_.MatchAndExplain(distance, &distance_listener);\n      *listener << \"whose distance between begin() and end() \" << distance\n                << (result ? \" matches\" : \" doesn't match\");\n      PrintIfNotEmpty(distance_listener.str(), listener->stream());\n      return result;\n    }\n\n   private:\n    const Matcher<DistanceType> distance_matcher_;\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n private:\n  const DistanceMatcher distance_matcher_;\n  GTEST_DISALLOW_ASSIGN_(BeginEndDistanceIsMatcher);\n};\n\n// Implements an equality matcher for any STL-style container whose elements\n// support ==. This matcher is like Eq(), but its failure explanations provide\n// more detailed information that is useful when the container is used as a set.\n// The failure message reports elements that are in one of the operands but not\n// the other. The failure messages do not report duplicate or out-of-order\n// elements in the containers (which don't properly matter to sets, but can\n// occur if the containers are vectors or lists, for example).\n//\n// Uses the container's const_iterator, value_type, operator ==,\n// begin(), and end().\ntemplate <typename Container>\nclass ContainerEqMatcher {\n public:\n  typedef internal::StlContainerView<Container> View;\n  typedef typename View::type StlContainer;\n  typedef typename View::const_reference StlContainerReference;\n\n  // We make a copy of expected in case the elements in it are modified\n  // after this matcher is created.\n  explicit ContainerEqMatcher(const Container& expected)\n      : expected_(View::Copy(expected)) {\n    // Makes sure the user doesn't instantiate this class template\n    // with a const or reference type.\n    (void)testing::StaticAssertTypeEq<Container,\n        GTEST_REMOVE_REFERENCE_AND_CONST_(Container)>();\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    *os << \"equals \";\n    UniversalPrint(expected_, os);\n  }\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"does not equal \";\n    UniversalPrint(expected_, os);\n  }\n\n  template <typename LhsContainer>\n  bool MatchAndExplain(const LhsContainer& lhs,\n                       MatchResultListener* listener) const {\n    // GTEST_REMOVE_CONST_() is needed to work around an MSVC 8.0 bug\n    // that causes LhsContainer to be a const type sometimes.\n    typedef internal::StlContainerView<GTEST_REMOVE_CONST_(LhsContainer)>\n        LhsView;\n    typedef typename LhsView::type LhsStlContainer;\n    StlContainerReference lhs_stl_container = LhsView::ConstReference(lhs);\n    if (lhs_stl_container == expected_)\n      return true;\n\n    ::std::ostream* const os = listener->stream();\n    if (os != NULL) {\n      // Something is different. Check for extra values first.\n      bool printed_header = false;\n      for (typename LhsStlContainer::const_iterator it =\n               lhs_stl_container.begin();\n           it != lhs_stl_container.end(); ++it) {\n        if (internal::ArrayAwareFind(expected_.begin(), expected_.end(), *it) ==\n            expected_.end()) {\n          if (printed_header) {\n            *os << \", \";\n          } else {\n            *os << \"which has these unexpected elements: \";\n            printed_header = true;\n          }\n          UniversalPrint(*it, os);\n        }\n      }\n\n      // Now check for missing values.\n      bool printed_header2 = false;\n      for (typename StlContainer::const_iterator it = expected_.begin();\n           it != expected_.end(); ++it) {\n        if (internal::ArrayAwareFind(\n                lhs_stl_container.begin(), lhs_stl_container.end(), *it) ==\n            lhs_stl_container.end()) {\n          if (printed_header2) {\n            *os << \", \";\n          } else {\n            *os << (printed_header ? \",\\nand\" : \"which\")\n                << \" doesn't have these expected elements: \";\n            printed_header2 = true;\n          }\n          UniversalPrint(*it, os);\n        }\n      }\n    }\n\n    return false;\n  }\n\n private:\n  const StlContainer expected_;\n\n  GTEST_DISALLOW_ASSIGN_(ContainerEqMatcher);\n};\n\n// A comparator functor that uses the < operator to compare two values.\nstruct LessComparator {\n  template <typename T, typename U>\n  bool operator()(const T& lhs, const U& rhs) const { return lhs < rhs; }\n};\n\n// Implements WhenSortedBy(comparator, container_matcher).\ntemplate <typename Comparator, typename ContainerMatcher>\nclass WhenSortedByMatcher {\n public:\n  WhenSortedByMatcher(const Comparator& comparator,\n                      const ContainerMatcher& matcher)\n      : comparator_(comparator), matcher_(matcher) {}\n\n  template <typename LhsContainer>\n  operator Matcher<LhsContainer>() const {\n    return MakeMatcher(new Impl<LhsContainer>(comparator_, matcher_));\n  }\n\n  template <typename LhsContainer>\n  class Impl : public MatcherInterface<LhsContainer> {\n   public:\n    typedef internal::StlContainerView<\n         GTEST_REMOVE_REFERENCE_AND_CONST_(LhsContainer)> LhsView;\n    typedef typename LhsView::type LhsStlContainer;\n    typedef typename LhsView::const_reference LhsStlContainerReference;\n    // Transforms std::pair<const Key, Value> into std::pair<Key, Value>\n    // so that we can match associative containers.\n    typedef typename RemoveConstFromKey<\n        typename LhsStlContainer::value_type>::type LhsValue;\n\n    Impl(const Comparator& comparator, const ContainerMatcher& matcher)\n        : comparator_(comparator), matcher_(matcher) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"(when sorted) \";\n      matcher_.DescribeTo(os);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"(when sorted) \";\n      matcher_.DescribeNegationTo(os);\n    }\n\n    virtual bool MatchAndExplain(LhsContainer lhs,\n                                 MatchResultListener* listener) const {\n      LhsStlContainerReference lhs_stl_container = LhsView::ConstReference(lhs);\n      ::std::vector<LhsValue> sorted_container(lhs_stl_container.begin(),\n                                               lhs_stl_container.end());\n      ::std::sort(\n           sorted_container.begin(), sorted_container.end(), comparator_);\n\n      if (!listener->IsInterested()) {\n        // If the listener is not interested, we do not need to\n        // construct the inner explanation.\n        return matcher_.Matches(sorted_container);\n      }\n\n      *listener << \"which is \";\n      UniversalPrint(sorted_container, listener->stream());\n      *listener << \" when sorted\";\n\n      StringMatchResultListener inner_listener;\n      const bool match = matcher_.MatchAndExplain(sorted_container,\n                                                  &inner_listener);\n      PrintIfNotEmpty(inner_listener.str(), listener->stream());\n      return match;\n    }\n\n   private:\n    const Comparator comparator_;\n    const Matcher<const ::std::vector<LhsValue>&> matcher_;\n\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(Impl);\n  };\n\n private:\n  const Comparator comparator_;\n  const ContainerMatcher matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(WhenSortedByMatcher);\n};\n\n// Implements Pointwise(tuple_matcher, rhs_container).  tuple_matcher\n// must be able to be safely cast to Matcher<tuple<const T1&, const\n// T2&> >, where T1 and T2 are the types of elements in the LHS\n// container and the RHS container respectively.\ntemplate <typename TupleMatcher, typename RhsContainer>\nclass PointwiseMatcher {\n public:\n  typedef internal::StlContainerView<RhsContainer> RhsView;\n  typedef typename RhsView::type RhsStlContainer;\n  typedef typename RhsStlContainer::value_type RhsValue;\n\n  // Like ContainerEq, we make a copy of rhs in case the elements in\n  // it are modified after this matcher is created.\n  PointwiseMatcher(const TupleMatcher& tuple_matcher, const RhsContainer& rhs)\n      : tuple_matcher_(tuple_matcher), rhs_(RhsView::Copy(rhs)) {\n    // Makes sure the user doesn't instantiate this class template\n    // with a const or reference type.\n    (void)testing::StaticAssertTypeEq<RhsContainer,\n        GTEST_REMOVE_REFERENCE_AND_CONST_(RhsContainer)>();\n  }\n\n  template <typename LhsContainer>\n  operator Matcher<LhsContainer>() const {\n    return MakeMatcher(new Impl<LhsContainer>(tuple_matcher_, rhs_));\n  }\n\n  template <typename LhsContainer>\n  class Impl : public MatcherInterface<LhsContainer> {\n   public:\n    typedef internal::StlContainerView<\n         GTEST_REMOVE_REFERENCE_AND_CONST_(LhsContainer)> LhsView;\n    typedef typename LhsView::type LhsStlContainer;\n    typedef typename LhsView::const_reference LhsStlContainerReference;\n    typedef typename LhsStlContainer::value_type LhsValue;\n    // We pass the LHS value and the RHS value to the inner matcher by\n    // reference, as they may be expensive to copy.  We must use tuple\n    // instead of pair here, as a pair cannot hold references (C++ 98,\n    // 20.2.2 [lib.pairs]).\n    typedef ::testing::tuple<const LhsValue&, const RhsValue&> InnerMatcherArg;\n\n    Impl(const TupleMatcher& tuple_matcher, const RhsStlContainer& rhs)\n        // mono_tuple_matcher_ holds a monomorphic version of the tuple matcher.\n        : mono_tuple_matcher_(SafeMatcherCast<InnerMatcherArg>(tuple_matcher)),\n          rhs_(rhs) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"contains \" << rhs_.size()\n          << \" values, where each value and its corresponding value in \";\n      UniversalPrinter<RhsStlContainer>::Print(rhs_, os);\n      *os << \" \";\n      mono_tuple_matcher_.DescribeTo(os);\n    }\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"doesn't contain exactly \" << rhs_.size()\n          << \" values, or contains a value x at some index i\"\n          << \" where x and the i-th value of \";\n      UniversalPrint(rhs_, os);\n      *os << \" \";\n      mono_tuple_matcher_.DescribeNegationTo(os);\n    }\n\n    virtual bool MatchAndExplain(LhsContainer lhs,\n                                 MatchResultListener* listener) const {\n      LhsStlContainerReference lhs_stl_container = LhsView::ConstReference(lhs);\n      const size_t actual_size = lhs_stl_container.size();\n      if (actual_size != rhs_.size()) {\n        *listener << \"which contains \" << actual_size << \" values\";\n        return false;\n      }\n\n      typename LhsStlContainer::const_iterator left = lhs_stl_container.begin();\n      typename RhsStlContainer::const_iterator right = rhs_.begin();\n      for (size_t i = 0; i != actual_size; ++i, ++left, ++right) {\n        const InnerMatcherArg value_pair(*left, *right);\n\n        if (listener->IsInterested()) {\n          StringMatchResultListener inner_listener;\n          if (!mono_tuple_matcher_.MatchAndExplain(\n                  value_pair, &inner_listener)) {\n            *listener << \"where the value pair (\";\n            UniversalPrint(*left, listener->stream());\n            *listener << \", \";\n            UniversalPrint(*right, listener->stream());\n            *listener << \") at index #\" << i << \" don't match\";\n            PrintIfNotEmpty(inner_listener.str(), listener->stream());\n            return false;\n          }\n        } else {\n          if (!mono_tuple_matcher_.Matches(value_pair))\n            return false;\n        }\n      }\n\n      return true;\n    }\n\n   private:\n    const Matcher<InnerMatcherArg> mono_tuple_matcher_;\n    const RhsStlContainer rhs_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n private:\n  const TupleMatcher tuple_matcher_;\n  const RhsStlContainer rhs_;\n\n  GTEST_DISALLOW_ASSIGN_(PointwiseMatcher);\n};\n\n// Holds the logic common to ContainsMatcherImpl and EachMatcherImpl.\ntemplate <typename Container>\nclass QuantifierMatcherImpl : public MatcherInterface<Container> {\n public:\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;\n  typedef StlContainerView<RawContainer> View;\n  typedef typename View::type StlContainer;\n  typedef typename View::const_reference StlContainerReference;\n  typedef typename StlContainer::value_type Element;\n\n  template <typename InnerMatcher>\n  explicit QuantifierMatcherImpl(InnerMatcher inner_matcher)\n      : inner_matcher_(\n           testing::SafeMatcherCast<const Element&>(inner_matcher)) {}\n\n  // Checks whether:\n  // * All elements in the container match, if all_elements_should_match.\n  // * Any element in the container matches, if !all_elements_should_match.\n  bool MatchAndExplainImpl(bool all_elements_should_match,\n                           Container container,\n                           MatchResultListener* listener) const {\n    StlContainerReference stl_container = View::ConstReference(container);\n    size_t i = 0;\n    for (typename StlContainer::const_iterator it = stl_container.begin();\n         it != stl_container.end(); ++it, ++i) {\n      StringMatchResultListener inner_listener;\n      const bool matches = inner_matcher_.MatchAndExplain(*it, &inner_listener);\n\n      if (matches != all_elements_should_match) {\n        *listener << \"whose element #\" << i\n                  << (matches ? \" matches\" : \" doesn't match\");\n        PrintIfNotEmpty(inner_listener.str(), listener->stream());\n        return !all_elements_should_match;\n      }\n    }\n    return all_elements_should_match;\n  }\n\n protected:\n  const Matcher<const Element&> inner_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(QuantifierMatcherImpl);\n};\n\n// Implements Contains(element_matcher) for the given argument type Container.\n// Symmetric to EachMatcherImpl.\ntemplate <typename Container>\nclass ContainsMatcherImpl : public QuantifierMatcherImpl<Container> {\n public:\n  template <typename InnerMatcher>\n  explicit ContainsMatcherImpl(InnerMatcher inner_matcher)\n      : QuantifierMatcherImpl<Container>(inner_matcher) {}\n\n  // Describes what this matcher does.\n  virtual void DescribeTo(::std::ostream* os) const {\n    *os << \"contains at least one element that \";\n    this->inner_matcher_.DescribeTo(os);\n  }\n\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"doesn't contain any element that \";\n    this->inner_matcher_.DescribeTo(os);\n  }\n\n  virtual bool MatchAndExplain(Container container,\n                               MatchResultListener* listener) const {\n    return this->MatchAndExplainImpl(false, container, listener);\n  }\n\n private:\n  GTEST_DISALLOW_ASSIGN_(ContainsMatcherImpl);\n};\n\n// Implements Each(element_matcher) for the given argument type Container.\n// Symmetric to ContainsMatcherImpl.\ntemplate <typename Container>\nclass EachMatcherImpl : public QuantifierMatcherImpl<Container> {\n public:\n  template <typename InnerMatcher>\n  explicit EachMatcherImpl(InnerMatcher inner_matcher)\n      : QuantifierMatcherImpl<Container>(inner_matcher) {}\n\n  // Describes what this matcher does.\n  virtual void DescribeTo(::std::ostream* os) const {\n    *os << \"only contains elements that \";\n    this->inner_matcher_.DescribeTo(os);\n  }\n\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"contains some element that \";\n    this->inner_matcher_.DescribeNegationTo(os);\n  }\n\n  virtual bool MatchAndExplain(Container container,\n                               MatchResultListener* listener) const {\n    return this->MatchAndExplainImpl(true, container, listener);\n  }\n\n private:\n  GTEST_DISALLOW_ASSIGN_(EachMatcherImpl);\n};\n\n// Implements polymorphic Contains(element_matcher).\ntemplate <typename M>\nclass ContainsMatcher {\n public:\n  explicit ContainsMatcher(M m) : inner_matcher_(m) {}\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    return MakeMatcher(new ContainsMatcherImpl<Container>(inner_matcher_));\n  }\n\n private:\n  const M inner_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(ContainsMatcher);\n};\n\n// Implements polymorphic Each(element_matcher).\ntemplate <typename M>\nclass EachMatcher {\n public:\n  explicit EachMatcher(M m) : inner_matcher_(m) {}\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    return MakeMatcher(new EachMatcherImpl<Container>(inner_matcher_));\n  }\n\n private:\n  const M inner_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(EachMatcher);\n};\n\n// Implements Key(inner_matcher) for the given argument pair type.\n// Key(inner_matcher) matches an std::pair whose 'first' field matches\n// inner_matcher.  For example, Contains(Key(Ge(5))) can be used to match an\n// std::map that contains at least one element whose key is >= 5.\ntemplate <typename PairType>\nclass KeyMatcherImpl : public MatcherInterface<PairType> {\n public:\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(PairType) RawPairType;\n  typedef typename RawPairType::first_type KeyType;\n\n  template <typename InnerMatcher>\n  explicit KeyMatcherImpl(InnerMatcher inner_matcher)\n      : inner_matcher_(\n          testing::SafeMatcherCast<const KeyType&>(inner_matcher)) {\n  }\n\n  // Returns true iff 'key_value.first' (the key) matches the inner matcher.\n  virtual bool MatchAndExplain(PairType key_value,\n                               MatchResultListener* listener) const {\n    StringMatchResultListener inner_listener;\n    const bool match = inner_matcher_.MatchAndExplain(key_value.first,\n                                                      &inner_listener);\n    const internal::string explanation = inner_listener.str();\n    if (explanation != \"\") {\n      *listener << \"whose first field is a value \" << explanation;\n    }\n    return match;\n  }\n\n  // Describes what this matcher does.\n  virtual void DescribeTo(::std::ostream* os) const {\n    *os << \"has a key that \";\n    inner_matcher_.DescribeTo(os);\n  }\n\n  // Describes what the negation of this matcher does.\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"doesn't have a key that \";\n    inner_matcher_.DescribeTo(os);\n  }\n\n private:\n  const Matcher<const KeyType&> inner_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(KeyMatcherImpl);\n};\n\n// Implements polymorphic Key(matcher_for_key).\ntemplate <typename M>\nclass KeyMatcher {\n public:\n  explicit KeyMatcher(M m) : matcher_for_key_(m) {}\n\n  template <typename PairType>\n  operator Matcher<PairType>() const {\n    return MakeMatcher(new KeyMatcherImpl<PairType>(matcher_for_key_));\n  }\n\n private:\n  const M matcher_for_key_;\n\n  GTEST_DISALLOW_ASSIGN_(KeyMatcher);\n};\n\n// Implements Pair(first_matcher, second_matcher) for the given argument pair\n// type with its two matchers. See Pair() function below.\ntemplate <typename PairType>\nclass PairMatcherImpl : public MatcherInterface<PairType> {\n public:\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(PairType) RawPairType;\n  typedef typename RawPairType::first_type FirstType;\n  typedef typename RawPairType::second_type SecondType;\n\n  template <typename FirstMatcher, typename SecondMatcher>\n  PairMatcherImpl(FirstMatcher first_matcher, SecondMatcher second_matcher)\n      : first_matcher_(\n            testing::SafeMatcherCast<const FirstType&>(first_matcher)),\n        second_matcher_(\n            testing::SafeMatcherCast<const SecondType&>(second_matcher)) {\n  }\n\n  // Describes what this matcher does.\n  virtual void DescribeTo(::std::ostream* os) const {\n    *os << \"has a first field that \";\n    first_matcher_.DescribeTo(os);\n    *os << \", and has a second field that \";\n    second_matcher_.DescribeTo(os);\n  }\n\n  // Describes what the negation of this matcher does.\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"has a first field that \";\n    first_matcher_.DescribeNegationTo(os);\n    *os << \", or has a second field that \";\n    second_matcher_.DescribeNegationTo(os);\n  }\n\n  // Returns true iff 'a_pair.first' matches first_matcher and 'a_pair.second'\n  // matches second_matcher.\n  virtual bool MatchAndExplain(PairType a_pair,\n                               MatchResultListener* listener) const {\n    if (!listener->IsInterested()) {\n      // If the listener is not interested, we don't need to construct the\n      // explanation.\n      return first_matcher_.Matches(a_pair.first) &&\n             second_matcher_.Matches(a_pair.second);\n    }\n    StringMatchResultListener first_inner_listener;\n    if (!first_matcher_.MatchAndExplain(a_pair.first,\n                                        &first_inner_listener)) {\n      *listener << \"whose first field does not match\";\n      PrintIfNotEmpty(first_inner_listener.str(), listener->stream());\n      return false;\n    }\n    StringMatchResultListener second_inner_listener;\n    if (!second_matcher_.MatchAndExplain(a_pair.second,\n                                         &second_inner_listener)) {\n      *listener << \"whose second field does not match\";\n      PrintIfNotEmpty(second_inner_listener.str(), listener->stream());\n      return false;\n    }\n    ExplainSuccess(first_inner_listener.str(), second_inner_listener.str(),\n                   listener);\n    return true;\n  }\n\n private:\n  void ExplainSuccess(const internal::string& first_explanation,\n                      const internal::string& second_explanation,\n                      MatchResultListener* listener) const {\n    *listener << \"whose both fields match\";\n    if (first_explanation != \"\") {\n      *listener << \", where the first field is a value \" << first_explanation;\n    }\n    if (second_explanation != \"\") {\n      *listener << \", \";\n      if (first_explanation != \"\") {\n        *listener << \"and \";\n      } else {\n        *listener << \"where \";\n      }\n      *listener << \"the second field is a value \" << second_explanation;\n    }\n  }\n\n  const Matcher<const FirstType&> first_matcher_;\n  const Matcher<const SecondType&> second_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(PairMatcherImpl);\n};\n\n// Implements polymorphic Pair(first_matcher, second_matcher).\ntemplate <typename FirstMatcher, typename SecondMatcher>\nclass PairMatcher {\n public:\n  PairMatcher(FirstMatcher first_matcher, SecondMatcher second_matcher)\n      : first_matcher_(first_matcher), second_matcher_(second_matcher) {}\n\n  template <typename PairType>\n  operator Matcher<PairType> () const {\n    return MakeMatcher(\n        new PairMatcherImpl<PairType>(\n            first_matcher_, second_matcher_));\n  }\n\n private:\n  const FirstMatcher first_matcher_;\n  const SecondMatcher second_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(PairMatcher);\n};\n\n// Implements ElementsAre() and ElementsAreArray().\ntemplate <typename Container>\nclass ElementsAreMatcherImpl : public MatcherInterface<Container> {\n public:\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;\n  typedef internal::StlContainerView<RawContainer> View;\n  typedef typename View::type StlContainer;\n  typedef typename View::const_reference StlContainerReference;\n  typedef decltype(std::begin(\n      std::declval<StlContainerReference>())) StlContainerConstIterator;\n  typedef std::remove_reference_t<decltype(\n      *std::declval<StlContainerConstIterator &>())>\n      Element;\n\n  // Constructs the matcher from a sequence of element values or\n  // element matchers.\n  template <typename InputIter>\n  ElementsAreMatcherImpl(InputIter first, InputIter last) {\n    while (first != last) {\n      matchers_.push_back(MatcherCast<const Element&>(*first++));\n    }\n  }\n\n  // Describes what this matcher does.\n  virtual void DescribeTo(::std::ostream* os) const {\n    if (count() == 0) {\n      *os << \"is empty\";\n    } else if (count() == 1) {\n      *os << \"has 1 element that \";\n      matchers_[0].DescribeTo(os);\n    } else {\n      *os << \"has \" << Elements(count()) << \" where\\n\";\n      for (size_t i = 0; i != count(); ++i) {\n        *os << \"element #\" << i << \" \";\n        matchers_[i].DescribeTo(os);\n        if (i + 1 < count()) {\n          *os << \",\\n\";\n        }\n      }\n    }\n  }\n\n  // Describes what the negation of this matcher does.\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    if (count() == 0) {\n      *os << \"isn't empty\";\n      return;\n    }\n\n    *os << \"doesn't have \" << Elements(count()) << \", or\\n\";\n    for (size_t i = 0; i != count(); ++i) {\n      *os << \"element #\" << i << \" \";\n      matchers_[i].DescribeNegationTo(os);\n      if (i + 1 < count()) {\n        *os << \", or\\n\";\n      }\n    }\n  }\n\n  virtual bool MatchAndExplain(Container container,\n                               MatchResultListener* listener) const {\n    // To work with stream-like \"containers\", we must only walk\n    // through the elements in one pass.\n\n    const bool listener_interested = listener->IsInterested();\n\n    // explanations[i] is the explanation of the element at index i.\n    ::std::vector<internal::string> explanations(count());\n    StlContainerReference stl_container = View::ConstReference(container);\n    StlContainerConstIterator it = stl_container.begin();\n    size_t exam_pos = 0;\n    bool mismatch_found = false;  // Have we found a mismatched element yet?\n\n    // Go through the elements and matchers in pairs, until we reach\n    // the end of either the elements or the matchers, or until we find a\n    // mismatch.\n    for (; it != stl_container.end() && exam_pos != count(); ++it, ++exam_pos) {\n      bool match;  // Does the current element match the current matcher?\n      if (listener_interested) {\n        StringMatchResultListener s;\n        match = matchers_[exam_pos].MatchAndExplain(*it, &s);\n        explanations[exam_pos] = s.str();\n      } else {\n        match = matchers_[exam_pos].Matches(*it);\n      }\n\n      if (!match) {\n        mismatch_found = true;\n        break;\n      }\n    }\n    // If mismatch_found is true, 'exam_pos' is the index of the mismatch.\n\n    // Find how many elements the actual container has.  We avoid\n    // calling size() s.t. this code works for stream-like \"containers\"\n    // that don't define size().\n    size_t actual_count = exam_pos;\n    for (; it != stl_container.end(); ++it) {\n      ++actual_count;\n    }\n\n    if (actual_count != count()) {\n      // The element count doesn't match.  If the container is empty,\n      // there's no need to explain anything as Google Mock already\n      // prints the empty container.  Otherwise we just need to show\n      // how many elements there actually are.\n      if (listener_interested && (actual_count != 0)) {\n        *listener << \"which has \" << Elements(actual_count);\n      }\n      return false;\n    }\n\n    if (mismatch_found) {\n      // The element count matches, but the exam_pos-th element doesn't match.\n      if (listener_interested) {\n        *listener << \"whose element #\" << exam_pos << \" doesn't match\";\n        PrintIfNotEmpty(explanations[exam_pos], listener->stream());\n      }\n      return false;\n    }\n\n    // Every element matches its expectation.  We need to explain why\n    // (the obvious ones can be skipped).\n    if (listener_interested) {\n      bool reason_printed = false;\n      for (size_t i = 0; i != count(); ++i) {\n        const internal::string& s = explanations[i];\n        if (!s.empty()) {\n          if (reason_printed) {\n            *listener << \",\\nand \";\n          }\n          *listener << \"whose element #\" << i << \" matches, \" << s;\n          reason_printed = true;\n        }\n      }\n    }\n    return true;\n  }\n\n private:\n  static Message Elements(size_t count) {\n    return Message() << count << (count == 1 ? \" element\" : \" elements\");\n  }\n\n  size_t count() const { return matchers_.size(); }\n\n  ::std::vector<Matcher<const Element&> > matchers_;\n\n  GTEST_DISALLOW_ASSIGN_(ElementsAreMatcherImpl);\n};\n\n// Connectivity matrix of (elements X matchers), in element-major order.\n// Initially, there are no edges.\n// Use NextGraph() to iterate over all possible edge configurations.\n// Use Randomize() to generate a random edge configuration.\nclass GTEST_API_ MatchMatrix {\n public:\n  MatchMatrix(size_t num_elements, size_t num_matchers)\n      : num_elements_(num_elements),\n        num_matchers_(num_matchers),\n        matched_(num_elements_* num_matchers_, 0) {\n  }\n\n  size_t LhsSize() const { return num_elements_; }\n  size_t RhsSize() const { return num_matchers_; }\n  bool HasEdge(size_t ilhs, size_t irhs) const {\n    return matched_[SpaceIndex(ilhs, irhs)] == 1;\n  }\n  void SetEdge(size_t ilhs, size_t irhs, bool b) {\n    matched_[SpaceIndex(ilhs, irhs)] = b ? 1 : 0;\n  }\n\n  // Treating the connectivity matrix as a (LhsSize()*RhsSize())-bit number,\n  // adds 1 to that number; returns false if incrementing the graph left it\n  // empty.\n  bool NextGraph();\n\n  void Randomize();\n\n  string DebugString() const;\n\n private:\n  size_t SpaceIndex(size_t ilhs, size_t irhs) const {\n    return ilhs * num_matchers_ + irhs;\n  }\n\n  size_t num_elements_;\n  size_t num_matchers_;\n\n  // Each element is a char interpreted as bool. They are stored as a\n  // flattened array in lhs-major order, use 'SpaceIndex()' to translate\n  // a (ilhs, irhs) matrix coordinate into an offset.\n  ::std::vector<char> matched_;\n};\n\ntypedef ::std::pair<size_t, size_t> ElementMatcherPair;\ntypedef ::std::vector<ElementMatcherPair> ElementMatcherPairs;\n\n// Returns a maximum bipartite matching for the specified graph 'g'.\n// The matching is represented as a vector of {element, matcher} pairs.\nGTEST_API_ ElementMatcherPairs\nFindMaxBipartiteMatching(const MatchMatrix& g);\n\nGTEST_API_ bool FindPairing(const MatchMatrix& matrix,\n                            MatchResultListener* listener);\n\n// Untyped base class for implementing UnorderedElementsAre.  By\n// putting logic that's not specific to the element type here, we\n// reduce binary bloat and increase compilation speed.\nclass GTEST_API_ UnorderedElementsAreMatcherImplBase {\n protected:\n  // A vector of matcher describers, one for each element matcher.\n  // Does not own the describers (and thus can be used only when the\n  // element matchers are alive).\n  typedef ::std::vector<const MatcherDescriberInterface*> MatcherDescriberVec;\n\n  // Describes this UnorderedElementsAre matcher.\n  void DescribeToImpl(::std::ostream* os) const;\n\n  // Describes the negation of this UnorderedElementsAre matcher.\n  void DescribeNegationToImpl(::std::ostream* os) const;\n\n  bool VerifyAllElementsAndMatchersAreMatched(\n      const ::std::vector<string>& element_printouts,\n      const MatchMatrix& matrix,\n      MatchResultListener* listener) const;\n\n  MatcherDescriberVec& matcher_describers() {\n    return matcher_describers_;\n  }\n\n  static Message Elements(size_t n) {\n    return Message() << n << \" element\" << (n == 1 ? \"\" : \"s\");\n  }\n\n private:\n  MatcherDescriberVec matcher_describers_;\n\n  GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreMatcherImplBase);\n};\n\n// Implements unordered ElementsAre and unordered ElementsAreArray.\ntemplate <typename Container>\nclass UnorderedElementsAreMatcherImpl\n    : public MatcherInterface<Container>,\n      public UnorderedElementsAreMatcherImplBase {\n public:\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;\n  typedef internal::StlContainerView<RawContainer> View;\n  typedef typename View::type StlContainer;\n  typedef typename View::const_reference StlContainerReference;\n  typedef decltype(std::begin(\n      std::declval<StlContainerReference>())) StlContainerConstIterator;\n  typedef std::remove_reference_t<decltype(\n      *std::declval<StlContainerConstIterator &>())>\n      Element;\n\n  // Constructs the matcher from a sequence of element values or\n  // element matchers.\n  template <typename InputIter>\n  UnorderedElementsAreMatcherImpl(InputIter first, InputIter last) {\n    for (; first != last; ++first) {\n      matchers_.push_back(MatcherCast<const Element&>(*first));\n      matcher_describers().push_back(matchers_.back().GetDescriber());\n    }\n  }\n\n  // Describes what this matcher does.\n  virtual void DescribeTo(::std::ostream* os) const {\n    return UnorderedElementsAreMatcherImplBase::DescribeToImpl(os);\n  }\n\n  // Describes what the negation of this matcher does.\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    return UnorderedElementsAreMatcherImplBase::DescribeNegationToImpl(os);\n  }\n\n  virtual bool MatchAndExplain(Container container,\n                               MatchResultListener* listener) const {\n    StlContainerReference stl_container = View::ConstReference(container);\n    ::std::vector<string> element_printouts;\n    MatchMatrix matrix = AnalyzeElements(stl_container.begin(),\n                                         stl_container.end(),\n                                         &element_printouts,\n                                         listener);\n\n    const size_t actual_count = matrix.LhsSize();\n    if (actual_count == 0 && matchers_.empty()) {\n      return true;\n    }\n    if (actual_count != matchers_.size()) {\n      // The element count doesn't match.  If the container is empty,\n      // there's no need to explain anything as Google Mock already\n      // prints the empty container. Otherwise we just need to show\n      // how many elements there actually are.\n      if (actual_count != 0 && listener->IsInterested()) {\n        *listener << \"which has \" << Elements(actual_count);\n      }\n      return false;\n    }\n\n    return VerifyAllElementsAndMatchersAreMatched(element_printouts,\n                                                  matrix, listener) &&\n           FindPairing(matrix, listener);\n  }\n\n private:\n  typedef ::std::vector<Matcher<const Element&> > MatcherVec;\n\n  template <typename ElementIter>\n  MatchMatrix AnalyzeElements(ElementIter elem_first, ElementIter elem_last,\n                              ::std::vector<string>* element_printouts,\n                              MatchResultListener* listener) const {\n    element_printouts->clear();\n    ::std::vector<char> did_match;\n    size_t num_elements = 0;\n    for (; elem_first != elem_last; ++num_elements, ++elem_first) {\n      if (listener->IsInterested()) {\n        element_printouts->push_back(PrintToString(*elem_first));\n      }\n      for (size_t irhs = 0; irhs != matchers_.size(); ++irhs) {\n        did_match.push_back(Matches(matchers_[irhs])(*elem_first));\n      }\n    }\n\n    MatchMatrix matrix(num_elements, matchers_.size());\n    ::std::vector<char>::const_iterator did_match_iter = did_match.begin();\n    for (size_t ilhs = 0; ilhs != num_elements; ++ilhs) {\n      for (size_t irhs = 0; irhs != matchers_.size(); ++irhs) {\n        matrix.SetEdge(ilhs, irhs, *did_match_iter++ != 0);\n      }\n    }\n    return matrix;\n  }\n\n  MatcherVec matchers_;\n\n  GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreMatcherImpl);\n};\n\n// Functor for use in TransformTuple.\n// Performs MatcherCast<Target> on an input argument of any type.\ntemplate <typename Target>\nstruct CastAndAppendTransform {\n  template <typename Arg>\n  Matcher<Target> operator()(const Arg& a) const {\n    return MatcherCast<Target>(a);\n  }\n};\n\n// Implements UnorderedElementsAre.\ntemplate <typename MatcherTuple>\nclass UnorderedElementsAreMatcher {\n public:\n  explicit UnorderedElementsAreMatcher(const MatcherTuple& args)\n      : matchers_(args) {}\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;\n    typedef internal::StlContainerView<RawContainer> View;\n    typedef typename View::const_reference StlContainerReference;\n    typedef decltype(std::begin(\n        std::declval<StlContainerReference>())) StlContainerConstIterator;\n    typedef std::remove_reference_t<decltype(\n        *std::declval<StlContainerConstIterator &>())>\n        Element;\n    typedef ::std::vector<Matcher<const Element&> > MatcherVec;\n    MatcherVec matchers;\n    matchers.reserve(::testing::tuple_size<MatcherTuple>::value);\n    TransformTupleValues(CastAndAppendTransform<const Element&>(), matchers_,\n                         ::std::back_inserter(matchers));\n    return MakeMatcher(new UnorderedElementsAreMatcherImpl<Container>(\n                           matchers.begin(), matchers.end()));\n  }\n\n private:\n  const MatcherTuple matchers_;\n  GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreMatcher);\n};\n\n// Implements ElementsAre.\ntemplate <typename MatcherTuple>\nclass ElementsAreMatcher {\n public:\n  explicit ElementsAreMatcher(const MatcherTuple& args) : matchers_(args) {}\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;\n    typedef internal::StlContainerView<RawContainer> View;\n    typedef typename View::const_reference StlContainerReference;\n    typedef decltype(std::begin(\n        std::declval<StlContainerReference>())) StlContainerConstIterator;\n    typedef std::remove_reference_t<decltype(\n        *std::declval<StlContainerConstIterator &>())>\n        Element;\n    typedef ::std::vector<Matcher<const Element&> > MatcherVec;\n    MatcherVec matchers;\n    matchers.reserve(::testing::tuple_size<MatcherTuple>::value);\n    TransformTupleValues(CastAndAppendTransform<const Element&>(), matchers_,\n                         ::std::back_inserter(matchers));\n    return MakeMatcher(new ElementsAreMatcherImpl<Container>(\n                           matchers.begin(), matchers.end()));\n  }\n\n private:\n  const MatcherTuple matchers_;\n  GTEST_DISALLOW_ASSIGN_(ElementsAreMatcher);\n};\n\n// Implements UnorderedElementsAreArray().\ntemplate <typename T>\nclass UnorderedElementsAreArrayMatcher {\n public:\n  UnorderedElementsAreArrayMatcher() {}\n\n  template <typename Iter>\n  UnorderedElementsAreArrayMatcher(Iter first, Iter last)\n      : matchers_(first, last) {}\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    return MakeMatcher(\n        new UnorderedElementsAreMatcherImpl<Container>(matchers_.begin(),\n                                                       matchers_.end()));\n  }\n\n private:\n  ::std::vector<T> matchers_;\n\n  GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreArrayMatcher);\n};\n\n// Implements ElementsAreArray().\ntemplate <typename T>\nclass ElementsAreArrayMatcher {\n public:\n  template <typename Iter>\n  ElementsAreArrayMatcher(Iter first, Iter last) : matchers_(first, last) {}\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    return MakeMatcher(new ElementsAreMatcherImpl<Container>(\n        matchers_.begin(), matchers_.end()));\n  }\n\n private:\n  const ::std::vector<T> matchers_;\n\n  GTEST_DISALLOW_ASSIGN_(ElementsAreArrayMatcher);\n};\n\n// Given a 2-tuple matcher tm of type Tuple2Matcher and a value second\n// of type Second, BoundSecondMatcher<Tuple2Matcher, Second>(tm,\n// second) is a polymorphic matcher that matches a value x iff tm\n// matches tuple (x, second).  Useful for implementing\n// UnorderedPointwise() in terms of UnorderedElementsAreArray().\n//\n// BoundSecondMatcher is copyable and assignable, as we need to put\n// instances of this class in a vector when implementing\n// UnorderedPointwise().\ntemplate <typename Tuple2Matcher, typename Second>\nclass BoundSecondMatcher {\n public:\n  BoundSecondMatcher(const Tuple2Matcher& tm, const Second& second)\n      : tuple2_matcher_(tm), second_value_(second) {}\n\n  template <typename T>\n  operator Matcher<T>() const {\n    return MakeMatcher(new Impl<T>(tuple2_matcher_, second_value_));\n  }\n\n  // We have to define this for UnorderedPointwise() to compile in\n  // C++98 mode, as it puts BoundSecondMatcher instances in a vector,\n  // which requires the elements to be assignable in C++98.  The\n  // compiler cannot generate the operator= for us, as Tuple2Matcher\n  // and Second may not be assignable.\n  //\n  // However, this should never be called, so the implementation just\n  // need to assert.\n  void operator=(const BoundSecondMatcher& /*rhs*/) {\n    GTEST_LOG_(FATAL) << \"BoundSecondMatcher should never be assigned.\";\n  }\n\n  BoundSecondMatcher(const BoundSecondMatcher &) = default;\n\n private:\n  template <typename T>\n  class Impl : public MatcherInterface<T> {\n   public:\n    typedef ::testing::tuple<T, Second> ArgTuple;\n\n    Impl(const Tuple2Matcher& tm, const Second& second)\n        : mono_tuple2_matcher_(SafeMatcherCast<const ArgTuple&>(tm)),\n          second_value_(second) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"and \";\n      UniversalPrint(second_value_, os);\n      *os << \" \";\n      mono_tuple2_matcher_.DescribeTo(os);\n    }\n\n    virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {\n      return mono_tuple2_matcher_.MatchAndExplain(ArgTuple(x, second_value_),\n                                                  listener);\n    }\n\n   private:\n    const Matcher<const ArgTuple&> mono_tuple2_matcher_;\n    const Second second_value_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  const Tuple2Matcher tuple2_matcher_;\n  const Second second_value_;\n};\n\n// Given a 2-tuple matcher tm and a value second,\n// MatcherBindSecond(tm, second) returns a matcher that matches a\n// value x iff tm matches tuple (x, second).  Useful for implementing\n// UnorderedPointwise() in terms of UnorderedElementsAreArray().\ntemplate <typename Tuple2Matcher, typename Second>\nBoundSecondMatcher<Tuple2Matcher, Second> MatcherBindSecond(\n    const Tuple2Matcher& tm, const Second& second) {\n  return BoundSecondMatcher<Tuple2Matcher, Second>(tm, second);\n}\n\n// Returns the description for a matcher defined using the MATCHER*()\n// macro where the user-supplied description string is \"\", if\n// 'negation' is false; otherwise returns the description of the\n// negation of the matcher.  'param_values' contains a list of strings\n// that are the print-out of the matcher's parameters.\nGTEST_API_ string FormatMatcherDescription(bool negation,\n                                           const char* matcher_name,\n                                           const Strings& param_values);\n\n}  // namespace internal\n\n// ElementsAreArray(first, last)\n// ElementsAreArray(pointer, count)\n// ElementsAreArray(array)\n// ElementsAreArray(container)\n// ElementsAreArray({ e1, e2, ..., en })\n//\n// The ElementsAreArray() functions are like ElementsAre(...), except\n// that they are given a homogeneous sequence rather than taking each\n// element as a function argument. The sequence can be specified as an\n// array, a pointer and count, a vector, an initializer list, or an\n// STL iterator range. In each of these cases, the underlying sequence\n// can be either a sequence of values or a sequence of matchers.\n//\n// All forms of ElementsAreArray() make a copy of the input matcher sequence.\n\ntemplate <typename Iter>\ninline internal::ElementsAreArrayMatcher<\n    typename ::std::iterator_traits<Iter>::value_type>\nElementsAreArray(Iter first, Iter last) {\n  typedef typename ::std::iterator_traits<Iter>::value_type T;\n  return internal::ElementsAreArrayMatcher<T>(first, last);\n}\n\ntemplate <typename T>\ninline internal::ElementsAreArrayMatcher<T> ElementsAreArray(\n    const T* pointer, size_t count) {\n  return ElementsAreArray(pointer, pointer + count);\n}\n\ntemplate <typename T, size_t N>\ninline internal::ElementsAreArrayMatcher<T> ElementsAreArray(\n    const T (&array)[N]) {\n  return ElementsAreArray(array, N);\n}\n\ntemplate <typename Container>\ninline internal::ElementsAreArrayMatcher<typename Container::value_type>\nElementsAreArray(const Container& container) {\n  return ElementsAreArray(container.begin(), container.end());\n}\n\n#if GTEST_HAS_STD_INITIALIZER_LIST_\ntemplate <typename T>\ninline internal::ElementsAreArrayMatcher<T>\nElementsAreArray(::std::initializer_list<T> xs) {\n  return ElementsAreArray(xs.begin(), xs.end());\n}\n#endif\n\n// UnorderedElementsAreArray(first, last)\n// UnorderedElementsAreArray(pointer, count)\n// UnorderedElementsAreArray(array)\n// UnorderedElementsAreArray(container)\n// UnorderedElementsAreArray({ e1, e2, ..., en })\n//\n// The UnorderedElementsAreArray() functions are like\n// ElementsAreArray(...), but allow matching the elements in any order.\ntemplate <typename Iter>\ninline internal::UnorderedElementsAreArrayMatcher<\n    typename ::std::iterator_traits<Iter>::value_type>\nUnorderedElementsAreArray(Iter first, Iter last) {\n  typedef typename ::std::iterator_traits<Iter>::value_type T;\n  return internal::UnorderedElementsAreArrayMatcher<T>(first, last);\n}\n\ntemplate <typename T>\ninline internal::UnorderedElementsAreArrayMatcher<T>\nUnorderedElementsAreArray(const T* pointer, size_t count) {\n  return UnorderedElementsAreArray(pointer, pointer + count);\n}\n\ntemplate <typename T, size_t N>\ninline internal::UnorderedElementsAreArrayMatcher<T>\nUnorderedElementsAreArray(const T (&array)[N]) {\n  return UnorderedElementsAreArray(array, N);\n}\n\ntemplate <typename Container>\ninline internal::UnorderedElementsAreArrayMatcher<\n    typename Container::value_type>\nUnorderedElementsAreArray(const Container& container) {\n  return UnorderedElementsAreArray(container.begin(), container.end());\n}\n\n#if GTEST_HAS_STD_INITIALIZER_LIST_\ntemplate <typename T>\ninline internal::UnorderedElementsAreArrayMatcher<T>\nUnorderedElementsAreArray(::std::initializer_list<T> xs) {\n  return UnorderedElementsAreArray(xs.begin(), xs.end());\n}\n#endif\n\n// _ is a matcher that matches anything of any type.\n//\n// This definition is fine as:\n//\n//   1. The C++ standard permits using the name _ in a namespace that\n//      is not the global namespace or ::std.\n//   2. The AnythingMatcher class has no data member or constructor,\n//      so it's OK to create global variables of this type.\n//   3. c-style has approved of using _ in this case.\nconst internal::AnythingMatcher _ = {};\n// Creates a matcher that matches any value of the given type T.\ntemplate <typename T>\ninline Matcher<T> A() { return MakeMatcher(new internal::AnyMatcherImpl<T>()); }\n\n// Creates a matcher that matches any value of the given type T.\ntemplate <typename T>\ninline Matcher<T> An() { return A<T>(); }\n\n// Creates a polymorphic matcher that matches anything equal to x.\n// Note: if the parameter of Eq() were declared as const T&, Eq(\"foo\")\n// wouldn't compile.\ntemplate <typename T>\ninline internal::EqMatcher<T> Eq(T x) { return internal::EqMatcher<T>(x); }\n\n// Constructs a Matcher<T> from a 'value' of type T.  The constructed\n// matcher matches any value that's equal to 'value'.\ntemplate <typename T>\nMatcher<T>::Matcher(T value) { *this = Eq(value); }\n\n// Creates a monomorphic matcher that matches anything with type Lhs\n// and equal to rhs.  A user may need to use this instead of Eq(...)\n// in order to resolve an overloading ambiguity.\n//\n// TypedEq<T>(x) is just a convenient short-hand for Matcher<T>(Eq(x))\n// or Matcher<T>(x), but more readable than the latter.\n//\n// We could define similar monomorphic matchers for other comparison\n// operations (e.g. TypedLt, TypedGe, and etc), but decided not to do\n// it yet as those are used much less than Eq() in practice.  A user\n// can always write Matcher<T>(Lt(5)) to be explicit about the type,\n// for example.\ntemplate <typename Lhs, typename Rhs>\ninline Matcher<Lhs> TypedEq(const Rhs& rhs) { return Eq(rhs); }\n\n// Creates a polymorphic matcher that matches anything >= x.\ntemplate <typename Rhs>\ninline internal::GeMatcher<Rhs> Ge(Rhs x) {\n  return internal::GeMatcher<Rhs>(x);\n}\n\n// Creates a polymorphic matcher that matches anything > x.\ntemplate <typename Rhs>\ninline internal::GtMatcher<Rhs> Gt(Rhs x) {\n  return internal::GtMatcher<Rhs>(x);\n}\n\n// Creates a polymorphic matcher that matches anything <= x.\ntemplate <typename Rhs>\ninline internal::LeMatcher<Rhs> Le(Rhs x) {\n  return internal::LeMatcher<Rhs>(x);\n}\n\n// Creates a polymorphic matcher that matches anything < x.\ntemplate <typename Rhs>\ninline internal::LtMatcher<Rhs> Lt(Rhs x) {\n  return internal::LtMatcher<Rhs>(x);\n}\n\n// Creates a polymorphic matcher that matches anything != x.\ntemplate <typename Rhs>\ninline internal::NeMatcher<Rhs> Ne(Rhs x) {\n  return internal::NeMatcher<Rhs>(x);\n}\n\n// Creates a polymorphic matcher that matches any NULL pointer.\ninline PolymorphicMatcher<internal::IsNullMatcher > IsNull() {\n  return MakePolymorphicMatcher(internal::IsNullMatcher());\n}\n\n// Creates a polymorphic matcher that matches any non-NULL pointer.\n// This is convenient as Not(NULL) doesn't compile (the compiler\n// thinks that that expression is comparing a pointer with an integer).\ninline PolymorphicMatcher<internal::NotNullMatcher > NotNull() {\n  return MakePolymorphicMatcher(internal::NotNullMatcher());\n}\n\n// Creates a polymorphic matcher that matches any argument that\n// references variable x.\ntemplate <typename T>\ninline internal::RefMatcher<T&> Ref(T& x) {  // NOLINT\n  return internal::RefMatcher<T&>(x);\n}\n\n// Creates a matcher that matches any double argument approximately\n// equal to rhs, where two NANs are considered unequal.\ninline internal::FloatingEqMatcher<double> DoubleEq(double rhs) {\n  return internal::FloatingEqMatcher<double>(rhs, false);\n}\n\n// Creates a matcher that matches any double argument approximately\n// equal to rhs, including NaN values when rhs is NaN.\ninline internal::FloatingEqMatcher<double> NanSensitiveDoubleEq(double rhs) {\n  return internal::FloatingEqMatcher<double>(rhs, true);\n}\n\n// Creates a matcher that matches any double argument approximately equal to\n// rhs, up to the specified max absolute error bound, where two NANs are\n// considered unequal.  The max absolute error bound must be non-negative.\ninline internal::FloatingEqMatcher<double> DoubleNear(\n    double rhs, double max_abs_error) {\n  return internal::FloatingEqMatcher<double>(rhs, false, max_abs_error);\n}\n\n// Creates a matcher that matches any double argument approximately equal to\n// rhs, up to the specified max absolute error bound, including NaN values when\n// rhs is NaN.  The max absolute error bound must be non-negative.\ninline internal::FloatingEqMatcher<double> NanSensitiveDoubleNear(\n    double rhs, double max_abs_error) {\n  return internal::FloatingEqMatcher<double>(rhs, true, max_abs_error);\n}\n\n// Creates a matcher that matches any float argument approximately\n// equal to rhs, where two NANs are considered unequal.\ninline internal::FloatingEqMatcher<float> FloatEq(float rhs) {\n  return internal::FloatingEqMatcher<float>(rhs, false);\n}\n\n// Creates a matcher that matches any float argument approximately\n// equal to rhs, including NaN values when rhs is NaN.\ninline internal::FloatingEqMatcher<float> NanSensitiveFloatEq(float rhs) {\n  return internal::FloatingEqMatcher<float>(rhs, true);\n}\n\n// Creates a matcher that matches any float argument approximately equal to\n// rhs, up to the specified max absolute error bound, where two NANs are\n// considered unequal.  The max absolute error bound must be non-negative.\ninline internal::FloatingEqMatcher<float> FloatNear(\n    float rhs, float max_abs_error) {\n  return internal::FloatingEqMatcher<float>(rhs, false, max_abs_error);\n}\n\n// Creates a matcher that matches any float argument approximately equal to\n// rhs, up to the specified max absolute error bound, including NaN values when\n// rhs is NaN.  The max absolute error bound must be non-negative.\ninline internal::FloatingEqMatcher<float> NanSensitiveFloatNear(\n    float rhs, float max_abs_error) {\n  return internal::FloatingEqMatcher<float>(rhs, true, max_abs_error);\n}\n\n// Creates a matcher that matches a pointer (raw or smart) that points\n// to a value that matches inner_matcher.\ntemplate <typename InnerMatcher>\ninline internal::PointeeMatcher<InnerMatcher> Pointee(\n    const InnerMatcher& inner_matcher) {\n  return internal::PointeeMatcher<InnerMatcher>(inner_matcher);\n}\n\n// Creates a matcher that matches a pointer or reference that matches\n// inner_matcher when dynamic_cast<To> is applied.\n// The result of dynamic_cast<To> is forwarded to the inner matcher.\n// If To is a pointer and the cast fails, the inner matcher will receive NULL.\n// If To is a reference and the cast fails, this matcher returns false\n// immediately.\ntemplate <typename To>\ninline PolymorphicMatcher<internal::WhenDynamicCastToMatcher<To> >\nWhenDynamicCastTo(const Matcher<To>& inner_matcher) {\n  return MakePolymorphicMatcher(\n      internal::WhenDynamicCastToMatcher<To>(inner_matcher));\n}\n\n// Creates a matcher that matches an object whose given field matches\n// 'matcher'.  For example,\n//   Field(&Foo::number, Ge(5))\n// matches a Foo object x iff x.number >= 5.\ntemplate <typename Class, typename FieldType, typename FieldMatcher>\ninline PolymorphicMatcher<\n  internal::FieldMatcher<Class, FieldType> > Field(\n    FieldType Class::*field, const FieldMatcher& matcher) {\n  return MakePolymorphicMatcher(\n      internal::FieldMatcher<Class, FieldType>(\n          field, MatcherCast<const FieldType&>(matcher)));\n  // The call to MatcherCast() is required for supporting inner\n  // matchers of compatible types.  For example, it allows\n  //   Field(&Foo::bar, m)\n  // to compile where bar is an int32 and m is a matcher for int64.\n}\n\n// Creates a matcher that matches an object whose given property\n// matches 'matcher'.  For example,\n//   Property(&Foo::str, StartsWith(\"hi\"))\n// matches a Foo object x iff x.str() starts with \"hi\".\ntemplate <typename Class, typename PropertyType, typename PropertyMatcher>\ninline PolymorphicMatcher<\n  internal::PropertyMatcher<Class, PropertyType> > Property(\n    PropertyType (Class::*property)() const, const PropertyMatcher& matcher) {\n  return MakePolymorphicMatcher(\n      internal::PropertyMatcher<Class, PropertyType>(\n          property,\n          MatcherCast<GTEST_REFERENCE_TO_CONST_(PropertyType)>(matcher)));\n  // The call to MatcherCast() is required for supporting inner\n  // matchers of compatible types.  For example, it allows\n  //   Property(&Foo::bar, m)\n  // to compile where bar() returns an int32 and m is a matcher for int64.\n}\n\n// Creates a matcher that matches an object iff the result of applying\n// a callable to x matches 'matcher'.\n// For example,\n//   ResultOf(f, StartsWith(\"hi\"))\n// matches a Foo object x iff f(x) starts with \"hi\".\n// callable parameter can be a function, function pointer, or a functor.\n// Callable has to satisfy the following conditions:\n//   * It is required to keep no state affecting the results of\n//     the calls on it and make no assumptions about how many calls\n//     will be made. Any state it keeps must be protected from the\n//     concurrent access.\n//   * If it is a function object, it has to define type result_type.\n//     We recommend deriving your functor classes from std::unary_function.\ntemplate <typename Callable, typename ResultOfMatcher>\ninternal::ResultOfMatcher<Callable> ResultOf(\n    Callable callable, const ResultOfMatcher& matcher) {\n  return internal::ResultOfMatcher<Callable>(\n          callable,\n          MatcherCast<typename internal::CallableTraits<Callable>::ResultType>(\n              matcher));\n  // The call to MatcherCast() is required for supporting inner\n  // matchers of compatible types.  For example, it allows\n  //   ResultOf(Function, m)\n  // to compile where Function() returns an int32 and m is a matcher for int64.\n}\n\n// String matchers.\n\n// Matches a string equal to str.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::string> >\n    StrEq(const internal::string& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::string>(\n      str, true, true));\n}\n\n// Matches a string not equal to str.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::string> >\n    StrNe(const internal::string& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::string>(\n      str, false, true));\n}\n\n// Matches a string equal to str, ignoring case.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::string> >\n    StrCaseEq(const internal::string& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::string>(\n      str, true, false));\n}\n\n// Matches a string not equal to str, ignoring case.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::string> >\n    StrCaseNe(const internal::string& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::string>(\n      str, false, false));\n}\n\n// Creates a matcher that matches any string, std::string, or C string\n// that contains the given substring.\ninline PolymorphicMatcher<internal::HasSubstrMatcher<internal::string> >\n    HasSubstr(const internal::string& substring) {\n  return MakePolymorphicMatcher(internal::HasSubstrMatcher<internal::string>(\n      substring));\n}\n\n// Matches a string that starts with 'prefix' (case-sensitive).\ninline PolymorphicMatcher<internal::StartsWithMatcher<internal::string> >\n    StartsWith(const internal::string& prefix) {\n  return MakePolymorphicMatcher(internal::StartsWithMatcher<internal::string>(\n      prefix));\n}\n\n// Matches a string that ends with 'suffix' (case-sensitive).\ninline PolymorphicMatcher<internal::EndsWithMatcher<internal::string> >\n    EndsWith(const internal::string& suffix) {\n  return MakePolymorphicMatcher(internal::EndsWithMatcher<internal::string>(\n      suffix));\n}\n\n// Matches a string that fully matches regular expression 'regex'.\n// The matcher takes ownership of 'regex'.\ninline PolymorphicMatcher<internal::MatchesRegexMatcher> MatchesRegex(\n    const internal::RE* regex) {\n  return MakePolymorphicMatcher(internal::MatchesRegexMatcher(regex, true));\n}\ninline PolymorphicMatcher<internal::MatchesRegexMatcher> MatchesRegex(\n    const internal::string& regex) {\n  return MatchesRegex(new internal::RE(regex));\n}\n\n// Matches a string that contains regular expression 'regex'.\n// The matcher takes ownership of 'regex'.\ninline PolymorphicMatcher<internal::MatchesRegexMatcher> ContainsRegex(\n    const internal::RE* regex) {\n  return MakePolymorphicMatcher(internal::MatchesRegexMatcher(regex, false));\n}\ninline PolymorphicMatcher<internal::MatchesRegexMatcher> ContainsRegex(\n    const internal::string& regex) {\n  return ContainsRegex(new internal::RE(regex));\n}\n\n#if GTEST_HAS_GLOBAL_WSTRING || GTEST_HAS_STD_WSTRING\n// Wide string matchers.\n\n// Matches a string equal to str.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::wstring> >\n    StrEq(const internal::wstring& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::wstring>(\n      str, true, true));\n}\n\n// Matches a string not equal to str.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::wstring> >\n    StrNe(const internal::wstring& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::wstring>(\n      str, false, true));\n}\n\n// Matches a string equal to str, ignoring case.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::wstring> >\n    StrCaseEq(const internal::wstring& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::wstring>(\n      str, true, false));\n}\n\n// Matches a string not equal to str, ignoring case.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::wstring> >\n    StrCaseNe(const internal::wstring& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::wstring>(\n      str, false, false));\n}\n\n// Creates a matcher that matches any wstring, std::wstring, or C wide string\n// that contains the given substring.\ninline PolymorphicMatcher<internal::HasSubstrMatcher<internal::wstring> >\n    HasSubstr(const internal::wstring& substring) {\n  return MakePolymorphicMatcher(internal::HasSubstrMatcher<internal::wstring>(\n      substring));\n}\n\n// Matches a string that starts with 'prefix' (case-sensitive).\ninline PolymorphicMatcher<internal::StartsWithMatcher<internal::wstring> >\n    StartsWith(const internal::wstring& prefix) {\n  return MakePolymorphicMatcher(internal::StartsWithMatcher<internal::wstring>(\n      prefix));\n}\n\n// Matches a string that ends with 'suffix' (case-sensitive).\ninline PolymorphicMatcher<internal::EndsWithMatcher<internal::wstring> >\n    EndsWith(const internal::wstring& suffix) {\n  return MakePolymorphicMatcher(internal::EndsWithMatcher<internal::wstring>(\n      suffix));\n}\n\n#endif  // GTEST_HAS_GLOBAL_WSTRING || GTEST_HAS_STD_WSTRING\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field == the second field.\ninline internal::Eq2Matcher Eq() { return internal::Eq2Matcher(); }\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field >= the second field.\ninline internal::Ge2Matcher Ge() { return internal::Ge2Matcher(); }\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field > the second field.\ninline internal::Gt2Matcher Gt() { return internal::Gt2Matcher(); }\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field <= the second field.\ninline internal::Le2Matcher Le() { return internal::Le2Matcher(); }\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field < the second field.\ninline internal::Lt2Matcher Lt() { return internal::Lt2Matcher(); }\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field != the second field.\ninline internal::Ne2Matcher Ne() { return internal::Ne2Matcher(); }\n\n// Creates a matcher that matches any value of type T that m doesn't\n// match.\ntemplate <typename InnerMatcher>\ninline internal::NotMatcher<InnerMatcher> Not(InnerMatcher m) {\n  return internal::NotMatcher<InnerMatcher>(m);\n}\n\n// Returns a matcher that matches anything that satisfies the given\n// predicate.  The predicate can be any unary function or functor\n// whose return type can be implicitly converted to bool.\ntemplate <typename Predicate>\ninline PolymorphicMatcher<internal::TrulyMatcher<Predicate> >\nTruly(Predicate pred) {\n  return MakePolymorphicMatcher(internal::TrulyMatcher<Predicate>(pred));\n}\n\n// Returns a matcher that matches the container size. The container must\n// support both size() and size_type which all STL-like containers provide.\n// Note that the parameter 'size' can be a value of type size_type as well as\n// matcher. For instance:\n//   EXPECT_THAT(container, SizeIs(2));     // Checks container has 2 elements.\n//   EXPECT_THAT(container, SizeIs(Le(2));  // Checks container has at most 2.\ntemplate <typename SizeMatcher>\ninline internal::SizeIsMatcher<SizeMatcher>\nSizeIs(const SizeMatcher& size_matcher) {\n  return internal::SizeIsMatcher<SizeMatcher>(size_matcher);\n}\n\n// Returns a matcher that matches the distance between the container's begin()\n// iterator and its end() iterator, i.e. the size of the container. This matcher\n// can be used instead of SizeIs with containers such as std::forward_list which\n// do not implement size(). The container must provide const_iterator (with\n// valid iterator_traits), begin() and end().\ntemplate <typename DistanceMatcher>\ninline internal::BeginEndDistanceIsMatcher<DistanceMatcher>\nBeginEndDistanceIs(const DistanceMatcher& distance_matcher) {\n  return internal::BeginEndDistanceIsMatcher<DistanceMatcher>(distance_matcher);\n}\n\n// Returns a matcher that matches an equal container.\n// This matcher behaves like Eq(), but in the event of mismatch lists the\n// values that are included in one container but not the other. (Duplicate\n// values and order differences are not explained.)\ntemplate <typename Container>\ninline PolymorphicMatcher<internal::ContainerEqMatcher<  // NOLINT\n                            GTEST_REMOVE_CONST_(Container)> >\n    ContainerEq(const Container& rhs) {\n  // This following line is for working around a bug in MSVC 8.0,\n  // which causes Container to be a const type sometimes.\n  typedef GTEST_REMOVE_CONST_(Container) RawContainer;\n  return MakePolymorphicMatcher(\n      internal::ContainerEqMatcher<RawContainer>(rhs));\n}\n\n// Returns a matcher that matches a container that, when sorted using\n// the given comparator, matches container_matcher.\ntemplate <typename Comparator, typename ContainerMatcher>\ninline internal::WhenSortedByMatcher<Comparator, ContainerMatcher>\nWhenSortedBy(const Comparator& comparator,\n             const ContainerMatcher& container_matcher) {\n  return internal::WhenSortedByMatcher<Comparator, ContainerMatcher>(\n      comparator, container_matcher);\n}\n\n// Returns a matcher that matches a container that, when sorted using\n// the < operator, matches container_matcher.\ntemplate <typename ContainerMatcher>\ninline internal::WhenSortedByMatcher<internal::LessComparator, ContainerMatcher>\nWhenSorted(const ContainerMatcher& container_matcher) {\n  return\n      internal::WhenSortedByMatcher<internal::LessComparator, ContainerMatcher>(\n          internal::LessComparator(), container_matcher);\n}\n\n// Matches an STL-style container or a native array that contains the\n// same number of elements as in rhs, where its i-th element and rhs's\n// i-th element (as a pair) satisfy the given pair matcher, for all i.\n// TupleMatcher must be able to be safely cast to Matcher<tuple<const\n// T1&, const T2&> >, where T1 and T2 are the types of elements in the\n// LHS container and the RHS container respectively.\ntemplate <typename TupleMatcher, typename Container>\ninline internal::PointwiseMatcher<TupleMatcher,\n                                  GTEST_REMOVE_CONST_(Container)>\nPointwise(const TupleMatcher& tuple_matcher, const Container& rhs) {\n  // This following line is for working around a bug in MSVC 8.0,\n  // which causes Container to be a const type sometimes (e.g. when\n  // rhs is a const int[])..\n  typedef GTEST_REMOVE_CONST_(Container) RawContainer;\n  return internal::PointwiseMatcher<TupleMatcher, RawContainer>(\n      tuple_matcher, rhs);\n}\n\n#if GTEST_HAS_STD_INITIALIZER_LIST_\n\n// Supports the Pointwise(m, {a, b, c}) syntax.\ntemplate <typename TupleMatcher, typename T>\ninline internal::PointwiseMatcher<TupleMatcher, std::vector<T> > Pointwise(\n    const TupleMatcher& tuple_matcher, std::initializer_list<T> rhs) {\n  return Pointwise(tuple_matcher, std::vector<T>(rhs));\n}\n\n#endif  // GTEST_HAS_STD_INITIALIZER_LIST_\n\n// UnorderedPointwise(pair_matcher, rhs) matches an STL-style\n// container or a native array that contains the same number of\n// elements as in rhs, where in some permutation of the container, its\n// i-th element and rhs's i-th element (as a pair) satisfy the given\n// pair matcher, for all i.  Tuple2Matcher must be able to be safely\n// cast to Matcher<tuple<const T1&, const T2&> >, where T1 and T2 are\n// the types of elements in the LHS container and the RHS container\n// respectively.\n//\n// This is like Pointwise(pair_matcher, rhs), except that the element\n// order doesn't matter.\ntemplate <typename Tuple2Matcher, typename RhsContainer>\ninline internal::UnorderedElementsAreArrayMatcher<\n    typename internal::BoundSecondMatcher<\n        Tuple2Matcher, typename internal::StlContainerView<GTEST_REMOVE_CONST_(\n                           RhsContainer)>::type::value_type> >\nUnorderedPointwise(const Tuple2Matcher& tuple2_matcher,\n                   const RhsContainer& rhs_container) {\n  // This following line is for working around a bug in MSVC 8.0,\n  // which causes RhsContainer to be a const type sometimes (e.g. when\n  // rhs_container is a const int[]).\n  typedef GTEST_REMOVE_CONST_(RhsContainer) RawRhsContainer;\n\n  // RhsView allows the same code to handle RhsContainer being a\n  // STL-style container and it being a native C-style array.\n  typedef typename internal::StlContainerView<RawRhsContainer> RhsView;\n  typedef typename RhsView::type RhsStlContainer;\n  typedef typename RhsStlContainer::value_type Second;\n  const RhsStlContainer& rhs_stl_container =\n      RhsView::ConstReference(rhs_container);\n\n  // Create a matcher for each element in rhs_container.\n  ::std::vector<internal::BoundSecondMatcher<Tuple2Matcher, Second> > matchers;\n  for (typename RhsStlContainer::const_iterator it = rhs_stl_container.begin();\n       it != rhs_stl_container.end(); ++it) {\n    matchers.push_back(\n        internal::MatcherBindSecond(tuple2_matcher, *it));\n  }\n\n  // Delegate the work to UnorderedElementsAreArray().\n  return UnorderedElementsAreArray(matchers);\n}\n\n#if GTEST_HAS_STD_INITIALIZER_LIST_\n\n// Supports the UnorderedPointwise(m, {a, b, c}) syntax.\ntemplate <typename Tuple2Matcher, typename T>\ninline internal::UnorderedElementsAreArrayMatcher<\n    typename internal::BoundSecondMatcher<Tuple2Matcher, T> >\nUnorderedPointwise(const Tuple2Matcher& tuple2_matcher,\n                   std::initializer_list<T> rhs) {\n  return UnorderedPointwise(tuple2_matcher, std::vector<T>(rhs));\n}\n\n#endif  // GTEST_HAS_STD_INITIALIZER_LIST_\n\n// Matches an STL-style container or a native array that contains at\n// least one element matching the given value or matcher.\n//\n// Examples:\n//   ::std::set<int> page_ids;\n//   page_ids.insert(3);\n//   page_ids.insert(1);\n//   EXPECT_THAT(page_ids, Contains(1));\n//   EXPECT_THAT(page_ids, Contains(Gt(2)));\n//   EXPECT_THAT(page_ids, Not(Contains(4)));\n//\n//   ::std::map<int, size_t> page_lengths;\n//   page_lengths[1] = 100;\n//   EXPECT_THAT(page_lengths,\n//               Contains(::std::pair<const int, size_t>(1, 100)));\n//\n//   const char* user_ids[] = { \"joe\", \"mike\", \"tom\" };\n//   EXPECT_THAT(user_ids, Contains(Eq(::std::string(\"tom\"))));\ntemplate <typename M>\ninline internal::ContainsMatcher<M> Contains(M matcher) {\n  return internal::ContainsMatcher<M>(matcher);\n}\n\n// Matches an STL-style container or a native array that contains only\n// elements matching the given value or matcher.\n//\n// Each(m) is semantically equivalent to Not(Contains(Not(m))). Only\n// the messages are different.\n//\n// Examples:\n//   ::std::set<int> page_ids;\n//   // Each(m) matches an empty container, regardless of what m is.\n//   EXPECT_THAT(page_ids, Each(Eq(1)));\n//   EXPECT_THAT(page_ids, Each(Eq(77)));\n//\n//   page_ids.insert(3);\n//   EXPECT_THAT(page_ids, Each(Gt(0)));\n//   EXPECT_THAT(page_ids, Not(Each(Gt(4))));\n//   page_ids.insert(1);\n//   EXPECT_THAT(page_ids, Not(Each(Lt(2))));\n//\n//   ::std::map<int, size_t> page_lengths;\n//   page_lengths[1] = 100;\n//   page_lengths[2] = 200;\n//   page_lengths[3] = 300;\n//   EXPECT_THAT(page_lengths, Not(Each(Pair(1, 100))));\n//   EXPECT_THAT(page_lengths, Each(Key(Le(3))));\n//\n//   const char* user_ids[] = { \"joe\", \"mike\", \"tom\" };\n//   EXPECT_THAT(user_ids, Not(Each(Eq(::std::string(\"tom\")))));\ntemplate <typename M>\ninline internal::EachMatcher<M> Each(M matcher) {\n  return internal::EachMatcher<M>(matcher);\n}\n\n// Key(inner_matcher) matches an std::pair whose 'first' field matches\n// inner_matcher.  For example, Contains(Key(Ge(5))) can be used to match an\n// std::map that contains at least one element whose key is >= 5.\ntemplate <typename M>\ninline internal::KeyMatcher<M> Key(M inner_matcher) {\n  return internal::KeyMatcher<M>(inner_matcher);\n}\n\n// Pair(first_matcher, second_matcher) matches a std::pair whose 'first' field\n// matches first_matcher and whose 'second' field matches second_matcher.  For\n// example, EXPECT_THAT(map_type, ElementsAre(Pair(Ge(5), \"foo\"))) can be used\n// to match a std::map<int, string> that contains exactly one element whose key\n// is >= 5 and whose value equals \"foo\".\ntemplate <typename FirstMatcher, typename SecondMatcher>\ninline internal::PairMatcher<FirstMatcher, SecondMatcher>\nPair(FirstMatcher first_matcher, SecondMatcher second_matcher) {\n  return internal::PairMatcher<FirstMatcher, SecondMatcher>(\n      first_matcher, second_matcher);\n}\n\n// Returns a predicate that is satisfied by anything that matches the\n// given matcher.\ntemplate <typename M>\ninline internal::MatcherAsPredicate<M> Matches(M matcher) {\n  return internal::MatcherAsPredicate<M>(matcher);\n}\n\n// Returns true iff the value matches the matcher.\ntemplate <typename T, typename M>\ninline bool Value(const T& value, M matcher) {\n  return testing::Matches(matcher)(value);\n}\n\n// Matches the value against the given matcher and explains the match\n// result to listener.\ntemplate <typename T, typename M>\ninline bool ExplainMatchResult(\n    M matcher, const T& value, MatchResultListener* listener) {\n  return SafeMatcherCast<const T&>(matcher).MatchAndExplain(value, listener);\n}\n\n#if GTEST_LANG_CXX11\n// Define variadic matcher versions. They are overloaded in\n// gmock-generated-matchers.h for the cases supported by pre C++11 compilers.\ntemplate <typename... Args>\ninline internal::AllOfMatcher<Args...> AllOf(const Args&... matchers) {\n  return internal::AllOfMatcher<Args...>(matchers...);\n}\n\ntemplate <typename... Args>\ninline internal::AnyOfMatcher<Args...> AnyOf(const Args&... matchers) {\n  return internal::AnyOfMatcher<Args...>(matchers...);\n}\n\n#endif  // GTEST_LANG_CXX11\n\n// AllArgs(m) is a synonym of m.  This is useful in\n//\n//   EXPECT_CALL(foo, Bar(_, _)).With(AllArgs(Eq()));\n//\n// which is easier to read than\n//\n//   EXPECT_CALL(foo, Bar(_, _)).With(Eq());\ntemplate <typename InnerMatcher>\ninline InnerMatcher AllArgs(const InnerMatcher& matcher) { return matcher; }\n\n// These macros allow using matchers to check values in Google Test\n// tests.  ASSERT_THAT(value, matcher) and EXPECT_THAT(value, matcher)\n// succeed iff the value matches the matcher.  If the assertion fails,\n// the value and the description of the matcher will be printed.\n#define ASSERT_THAT(value, matcher) ASSERT_PRED_FORMAT1(\\\n    ::testing::internal::MakePredicateFormatterFromMatcher(matcher), value)\n#define EXPECT_THAT(value, matcher) EXPECT_PRED_FORMAT1(\\\n    ::testing::internal::MakePredicateFormatterFromMatcher(matcher), value)\n\n}  // namespace testing\n\n#ifdef __clang__\n#if __has_warning(\"-Wdeprecated-copy\")\n#pragma clang diagnostic pop\n#endif\n#endif\n\n// Include any custom callback matchers added by the local installation.\n// We must include this header at the end to make sure it can use the\n// declarations from this file.\n#include \"gmock/internal/custom/gmock-matchers.h\"\n#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_MATCHERS_H_\n"}, "38": {"id": 38, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-more-actions.h", "content": "// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n// Google Mock - a framework for writing C++ mock classes.\n//\n// This file implements some actions that depend on gmock-generated-actions.h.\n\n// IWYU pragma: private, include \"gmock/gmock.h\"\n\n#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_MORE_ACTIONS_H_\n#define GMOCK_INCLUDE_GMOCK_GMOCK_MORE_ACTIONS_H_\n\n#include <algorithm>\n\n#include \"gmock/gmock-generated-actions.h\"\n\nnamespace testing {\nnamespace internal {\n\n// Implements the Invoke(f) action.  The template argument\n// FunctionImpl is the implementation type of f, which can be either a\n// function pointer or a functor.  Invoke(f) can be used as an\n// Action<F> as long as f's type is compatible with F (i.e. f can be\n// assigned to a tr1::function<F>).\ntemplate <typename FunctionImpl>\nclass InvokeAction {\n public:\n  // The c'tor makes a copy of function_impl (either a function\n  // pointer or a functor).\n  explicit InvokeAction(FunctionImpl function_impl)\n      : function_impl_(function_impl) {}\n\n  template <typename Result, typename ArgumentTuple>\n  Result Perform(const ArgumentTuple& args) {\n    return InvokeHelper<Result, ArgumentTuple>::Invoke(function_impl_, args);\n  }\n\n private:\n  FunctionImpl function_impl_;\n\n  GTEST_DISALLOW_ASSIGN_(InvokeAction);\n};\n\n// Implements the Invoke(object_ptr, &Class::Method) action.\ntemplate <class Class, typename MethodPtr>\nclass InvokeMethodAction {\n public:\n  InvokeMethodAction(Class* obj_ptr, MethodPtr method_ptr)\n      : method_ptr_(method_ptr), obj_ptr_(obj_ptr) {}\n\n  template <typename Result, typename ArgumentTuple>\n  Result Perform(const ArgumentTuple& args) const {\n    return InvokeHelper<Result, ArgumentTuple>::InvokeMethod(\n        obj_ptr_, method_ptr_, args);\n  }\n\n private:\n  // The order of these members matters.  Reversing the order can trigger\n  // warning C4121 in MSVC (see\n  // http://computer-programming-forum.com/7-vc.net/6fbc30265f860ad1.htm ).\n  const MethodPtr method_ptr_;\n  Class* const obj_ptr_;\n\n  GTEST_DISALLOW_ASSIGN_(InvokeMethodAction);\n};\n\n// An internal replacement for std::copy which mimics its behavior. This is\n// necessary because Visual Studio deprecates ::std::copy, issuing warning 4996.\n// However Visual Studio 2010 and later do not honor #pragmas which disable that\n// warning.\ntemplate<typename InputIterator, typename OutputIterator>\ninline OutputIterator CopyElements(InputIterator first,\n                                   InputIterator last,\n                                   OutputIterator output) {\n  for (; first != last; ++first, ++output) {\n    *output = *first;\n  }\n  return output;\n}\n\n}  // namespace internal\n\n// Various overloads for Invoke().\n\n// Creates an action that invokes 'function_impl' with the mock\n// function's arguments.\ntemplate <typename FunctionImpl>\nPolymorphicAction<internal::InvokeAction<FunctionImpl> > Invoke(\n    FunctionImpl function_impl) {\n  return MakePolymorphicAction(\n      internal::InvokeAction<FunctionImpl>(function_impl));\n}\n\n// Creates an action that invokes the given method on the given object\n// with the mock function's arguments.\ntemplate <class Class, typename MethodPtr>\nPolymorphicAction<internal::InvokeMethodAction<Class, MethodPtr> > Invoke(\n    Class* obj_ptr, MethodPtr method_ptr) {\n  return MakePolymorphicAction(\n      internal::InvokeMethodAction<Class, MethodPtr>(obj_ptr, method_ptr));\n}\n\n// WithoutArgs(inner_action) can be used in a mock function with a\n// non-empty argument list to perform inner_action, which takes no\n// argument.  In other words, it adapts an action accepting no\n// argument to one that accepts (and ignores) arguments.\ntemplate <typename InnerAction>\ninline internal::WithArgsAction<InnerAction>\nWithoutArgs(const InnerAction& action) {\n  return internal::WithArgsAction<InnerAction>(action);\n}\n\n// WithArg<k>(an_action) creates an action that passes the k-th\n// (0-based) argument of the mock function to an_action and performs\n// it.  It adapts an action accepting one argument to one that accepts\n// multiple arguments.  For convenience, we also provide\n// WithArgs<k>(an_action) (defined below) as a synonym.\ntemplate <int k, typename InnerAction>\ninline internal::WithArgsAction<InnerAction, k>\nWithArg(const InnerAction& action) {\n  return internal::WithArgsAction<InnerAction, k>(action);\n}\n\n// The ACTION*() macros trigger warning C4100 (unreferenced formal\n// parameter) in MSVC with -W4.  Unfortunately they cannot be fixed in\n// the macro definition, as the warnings are generated when the macro\n// is expanded and macro expansion cannot contain #pragma.  Therefore\n// we suppress them here.\n#ifdef _MSC_VER\n# pragma warning(push)\n# pragma warning(disable:4100)\n#endif\n\n// Action ReturnArg<k>() returns the k-th argument of the mock function.\nACTION_TEMPLATE(ReturnArg,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_0_VALUE_PARAMS()) {\n  return ::testing::get<k>(args);\n}\n\n// Action SaveArg<k>(pointer) saves the k-th (0-based) argument of the\n// mock function to *pointer.\nACTION_TEMPLATE(SaveArg,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_1_VALUE_PARAMS(pointer)) {\n  *pointer = ::testing::get<k>(args);\n}\n\n// Action SaveArgPointee<k>(pointer) saves the value pointed to\n// by the k-th (0-based) argument of the mock function to *pointer.\nACTION_TEMPLATE(SaveArgPointee,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_1_VALUE_PARAMS(pointer)) {\n  *pointer = *::testing::get<k>(args);\n}\n\n// Action SetArgReferee<k>(value) assigns 'value' to the variable\n// referenced by the k-th (0-based) argument of the mock function.\nACTION_TEMPLATE(SetArgReferee,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_1_VALUE_PARAMS(value)) {\n  typedef typename ::testing::tuple_element<k, args_type>::type argk_type;\n  // Ensures that argument #k is a reference.  If you get a compiler\n  // error on the next line, you are using SetArgReferee<k>(value) in\n  // a mock function whose k-th (0-based) argument is not a reference.\n  GTEST_COMPILE_ASSERT_(internal::is_reference<argk_type>::value,\n                        SetArgReferee_must_be_used_with_a_reference_argument);\n  ::testing::get<k>(args) = value;\n}\n\n// Action SetArrayArgument<k>(first, last) copies the elements in\n// source range [first, last) to the array pointed to by the k-th\n// (0-based) argument, which can be either a pointer or an\n// iterator. The action does not take ownership of the elements in the\n// source range.\nACTION_TEMPLATE(SetArrayArgument,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_2_VALUE_PARAMS(first, last)) {\n  // Visual Studio deprecates ::std::copy, so we use our own copy in that case.\n#ifdef _MSC_VER\n  internal::CopyElements(first, last, ::testing::get<k>(args));\n#else\n  ::std::copy(first, last, ::testing::get<k>(args));\n#endif\n}\n\n// Action DeleteArg<k>() deletes the k-th (0-based) argument of the mock\n// function.\nACTION_TEMPLATE(DeleteArg,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_0_VALUE_PARAMS()) {\n  delete ::testing::get<k>(args);\n}\n\n// This action returns the value pointed to by 'pointer'.\nACTION_P(ReturnPointee, pointer) { return *pointer; }\n\n// Action Throw(exception) can be used in a mock function of any type\n// to throw the given exception.  Any copyable value can be thrown.\n#if GTEST_HAS_EXCEPTIONS\n\n// Suppresses the 'unreachable code' warning that VC generates in opt modes.\n# ifdef _MSC_VER\n#  pragma warning(push)          // Saves the current warning state.\n#  pragma warning(disable:4702)  // Temporarily disables warning 4702.\n# endif\nACTION_P(Throw, exception) { throw exception; }\n# ifdef _MSC_VER\n#  pragma warning(pop)           // Restores the warning state.\n# endif\n\n#endif  // GTEST_HAS_EXCEPTIONS\n\n#ifdef _MSC_VER\n# pragma warning(pop)\n#endif\n\n}  // namespace testing\n\n#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_MORE_ACTIONS_H_\n"}, "39": {"id": 39, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-spec-builders.h", "content": "// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n// Google Mock - a framework for writing C++ mock classes.\n//\n// This file implements the ON_CALL() and EXPECT_CALL() macros.\n//\n// A user can use the ON_CALL() macro to specify the default action of\n// a mock method.  The syntax is:\n//\n//   ON_CALL(mock_object, Method(argument-matchers))\n//       .With(multi-argument-matcher)\n//       .WillByDefault(action);\n//\n//  where the .With() clause is optional.\n//\n// A user can use the EXPECT_CALL() macro to specify an expectation on\n// a mock method.  The syntax is:\n//\n//   EXPECT_CALL(mock_object, Method(argument-matchers))\n//       .With(multi-argument-matchers)\n//       .Times(cardinality)\n//       .InSequence(sequences)\n//       .After(expectations)\n//       .WillOnce(action)\n//       .WillRepeatedly(action)\n//       .RetiresOnSaturation();\n//\n// where all clauses are optional, and .InSequence()/.After()/\n// .WillOnce() can appear any number of times.\n\n// IWYU pragma: private, include \"gmock/gmock.h\"\n\n#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_SPEC_BUILDERS_H_\n#define GMOCK_INCLUDE_GMOCK_GMOCK_SPEC_BUILDERS_H_\n\n#include <map>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\n#if GTEST_HAS_EXCEPTIONS\n# include <stdexcept>  // NOLINT\n#endif\n\n#include \"gmock/gmock-actions.h\"\n#include \"gmock/gmock-cardinalities.h\"\n#include \"gmock/gmock-matchers.h\"\n#include \"gmock/internal/gmock-internal-utils.h\"\n#include \"gmock/internal/gmock-port.h\"\n#include \"gtest/gtest.h\"\n\nnamespace testing {\n\n// An abstract handle of an expectation.\nclass Expectation;\n\n// A set of expectation handles.\nclass ExpectationSet;\n\n// Anything inside the 'internal' namespace IS INTERNAL IMPLEMENTATION\n// and MUST NOT BE USED IN USER CODE!!!\nnamespace internal {\n\n// Implements a mock function.\ntemplate <typename F> class FunctionMocker;\n\n// Base class for expectations.\nclass ExpectationBase;\n\n// Implements an expectation.\ntemplate <typename F> class TypedExpectation;\n\n// Helper class for testing the Expectation class template.\nclass ExpectationTester;\n\n// Base class for function mockers.\ntemplate <typename F> class FunctionMockerBase;\n\n// Protects the mock object registry (in class Mock), all function\n// mockers, and all expectations.\n//\n// The reason we don't use more fine-grained protection is: when a\n// mock function Foo() is called, it needs to consult its expectations\n// to see which one should be picked.  If another thread is allowed to\n// call a mock function (either Foo() or a different one) at the same\n// time, it could affect the \"retired\" attributes of Foo()'s\n// expectations when InSequence() is used, and thus affect which\n// expectation gets picked.  Therefore, we sequence all mock function\n// calls to ensure the integrity of the mock objects' states.\nGTEST_API_ GTEST_DECLARE_STATIC_MUTEX_(g_gmock_mutex);\n\n// Untyped base class for ActionResultHolder<R>.\nclass UntypedActionResultHolderBase;\n\n// Abstract base class of FunctionMockerBase.  This is the\n// type-agnostic part of the function mocker interface.  Its pure\n// virtual methods are implemented by FunctionMockerBase.\nclass GTEST_API_ UntypedFunctionMockerBase {\n public:\n  UntypedFunctionMockerBase();\n  virtual ~UntypedFunctionMockerBase();\n\n  // Verifies that all expectations on this mock function have been\n  // satisfied.  Reports one or more Google Test non-fatal failures\n  // and returns false if not.\n  bool VerifyAndClearExpectationsLocked()\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);\n\n  // Clears the ON_CALL()s set on this mock function.\n  virtual void ClearDefaultActionsLocked()\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) = 0;\n\n  // In all of the following Untyped* functions, it's the caller's\n  // responsibility to guarantee the correctness of the arguments'\n  // types.\n\n  // Performs the default action with the given arguments and returns\n  // the action's result.  The call description string will be used in\n  // the error message to describe the call in the case the default\n  // action fails.\n  // L = *\n  virtual UntypedActionResultHolderBase* UntypedPerformDefaultAction(\n      const void* untyped_args,\n      const string& call_description) const = 0;\n\n  // Performs the given action with the given arguments and returns\n  // the action's result.\n  // L = *\n  virtual UntypedActionResultHolderBase* UntypedPerformAction(\n      const void* untyped_action,\n      const void* untyped_args) const = 0;\n\n  // Writes a message that the call is uninteresting (i.e. neither\n  // explicitly expected nor explicitly unexpected) to the given\n  // ostream.\n  virtual void UntypedDescribeUninterestingCall(\n      const void* untyped_args,\n      ::std::ostream* os) const\n          GTEST_LOCK_EXCLUDED_(g_gmock_mutex) = 0;\n\n  // Returns the expectation that matches the given function arguments\n  // (or NULL is there's no match); when a match is found,\n  // untyped_action is set to point to the action that should be\n  // performed (or NULL if the action is \"do default\"), and\n  // is_excessive is modified to indicate whether the call exceeds the\n  // expected number.\n  virtual const ExpectationBase* UntypedFindMatchingExpectation(\n      const void* untyped_args,\n      const void** untyped_action, bool* is_excessive,\n      ::std::ostream* what, ::std::ostream* why)\n          GTEST_LOCK_EXCLUDED_(g_gmock_mutex) = 0;\n\n  // Prints the given function arguments to the ostream.\n  virtual void UntypedPrintArgs(const void* untyped_args,\n                                ::std::ostream* os) const = 0;\n\n  // Sets the mock object this mock method belongs to, and registers\n  // this information in the global mock registry.  Will be called\n  // whenever an EXPECT_CALL() or ON_CALL() is executed on this mock\n  // method.\n  // TODO(wan@google.com): rename to SetAndRegisterOwner().\n  void RegisterOwner(const void* mock_obj)\n      GTEST_LOCK_EXCLUDED_(g_gmock_mutex);\n\n  // Sets the mock object this mock method belongs to, and sets the\n  // name of the mock function.  Will be called upon each invocation\n  // of this mock function.\n  void SetOwnerAndName(const void* mock_obj, const char* name)\n      GTEST_LOCK_EXCLUDED_(g_gmock_mutex);\n\n  // Returns the mock object this mock method belongs to.  Must be\n  // called after RegisterOwner() or SetOwnerAndName() has been\n  // called.\n  const void* MockObject() const\n      GTEST_LOCK_EXCLUDED_(g_gmock_mutex);\n\n  // Returns the name of this mock method.  Must be called after\n  // SetOwnerAndName() has been called.\n  const char* Name() const\n      GTEST_LOCK_EXCLUDED_(g_gmock_mutex);\n\n  // Returns the result of invoking this mock function with the given\n  // arguments.  This function can be safely called from multiple\n  // threads concurrently.  The caller is responsible for deleting the\n  // result.\n  UntypedActionResultHolderBase* UntypedInvokeWith(\n      const void* untyped_args)\n          GTEST_LOCK_EXCLUDED_(g_gmock_mutex);\n\n protected:\n  typedef std::vector<const void*> UntypedOnCallSpecs;\n\n  typedef std::vector<internal::linked_ptr<ExpectationBase> >\n  UntypedExpectations;\n\n  // Returns an Expectation object that references and co-owns exp,\n  // which must be an expectation on this mock function.\n  Expectation GetHandleOf(ExpectationBase* exp);\n\n  // Address of the mock object this mock method belongs to.  Only\n  // valid after this mock method has been called or\n  // ON_CALL/EXPECT_CALL has been invoked on it.\n  const void* mock_obj_;  // Protected by g_gmock_mutex.\n\n  // Name of the function being mocked.  Only valid after this mock\n  // method has been called.\n  const char* name_;  // Protected by g_gmock_mutex.\n\n  // All default action specs for this function mocker.\n  UntypedOnCallSpecs untyped_on_call_specs_;\n\n  // All expectations for this function mocker.\n  UntypedExpectations untyped_expectations_;\n};  // class UntypedFunctionMockerBase\n\n// Untyped base class for OnCallSpec<F>.\nclass UntypedOnCallSpecBase {\n public:\n  // The arguments are the location of the ON_CALL() statement.\n  UntypedOnCallSpecBase(const char* a_file, int a_line)\n      : file_(a_file), line_(a_line), last_clause_(kNone) {}\n\n  // Where in the source file was the default action spec defined?\n  const char* file() const { return file_; }\n  int line() const { return line_; }\n\n protected:\n  // Gives each clause in the ON_CALL() statement a name.\n  enum Clause {\n    // Do not change the order of the enum members!  The run-time\n    // syntax checking relies on it.\n    kNone,\n    kWith,\n    kWillByDefault\n  };\n\n  // Asserts that the ON_CALL() statement has a certain property.\n  void AssertSpecProperty(bool property, const string& failure_message) const {\n    Assert(property, file_, line_, failure_message);\n  }\n\n  // Expects that the ON_CALL() statement has a certain property.\n  void ExpectSpecProperty(bool property, const string& failure_message) const {\n    Expect(property, file_, line_, failure_message);\n  }\n\n  const char* file_;\n  int line_;\n\n  // The last clause in the ON_CALL() statement as seen so far.\n  // Initially kNone and changes as the statement is parsed.\n  Clause last_clause_;\n};  // class UntypedOnCallSpecBase\n\n// This template class implements an ON_CALL spec.\ntemplate <typename F>\nclass OnCallSpec : public UntypedOnCallSpecBase {\n public:\n  typedef typename Function<F>::ArgumentTuple ArgumentTuple;\n  typedef typename Function<F>::ArgumentMatcherTuple ArgumentMatcherTuple;\n\n  // Constructs an OnCallSpec object from the information inside\n  // the parenthesis of an ON_CALL() statement.\n  OnCallSpec(const char* a_file, int a_line,\n             const ArgumentMatcherTuple& matchers)\n      : UntypedOnCallSpecBase(a_file, a_line),\n        matchers_(matchers),\n        // By default, extra_matcher_ should match anything.  However,\n        // we cannot initialize it with _ as that triggers a compiler\n        // bug in Symbian's C++ compiler (cannot decide between two\n        // overloaded constructors of Matcher<const ArgumentTuple&>).\n        extra_matcher_(A<const ArgumentTuple&>()) {\n  }\n\n  // Implements the .With() clause.\n  OnCallSpec& With(const Matcher<const ArgumentTuple&>& m) {\n    // Makes sure this is called at most once.\n    ExpectSpecProperty(last_clause_ < kWith,\n                       \".With() cannot appear \"\n                       \"more than once in an ON_CALL().\");\n    last_clause_ = kWith;\n\n    extra_matcher_ = m;\n    return *this;\n  }\n\n  // Implements the .WillByDefault() clause.\n  OnCallSpec& WillByDefault(const Action<F>& action) {\n    ExpectSpecProperty(last_clause_ < kWillByDefault,\n                       \".WillByDefault() must appear \"\n                       \"exactly once in an ON_CALL().\");\n    last_clause_ = kWillByDefault;\n\n    ExpectSpecProperty(!action.IsDoDefault(),\n                       \"DoDefault() cannot be used in ON_CALL().\");\n    action_ = action;\n    return *this;\n  }\n\n  // Returns true iff the given arguments match the matchers.\n  bool Matches(const ArgumentTuple& args) const {\n    return TupleMatches(matchers_, args) && extra_matcher_.Matches(args);\n  }\n\n  // Returns the action specified by the user.\n  const Action<F>& GetAction() const {\n    AssertSpecProperty(last_clause_ == kWillByDefault,\n                       \".WillByDefault() must appear exactly \"\n                       \"once in an ON_CALL().\");\n    return action_;\n  }\n\n private:\n  // The information in statement\n  //\n  //   ON_CALL(mock_object, Method(matchers))\n  //       .With(multi-argument-matcher)\n  //       .WillByDefault(action);\n  //\n  // is recorded in the data members like this:\n  //\n  //   source file that contains the statement => file_\n  //   line number of the statement            => line_\n  //   matchers                                => matchers_\n  //   multi-argument-matcher                  => extra_matcher_\n  //   action                                  => action_\n  ArgumentMatcherTuple matchers_;\n  Matcher<const ArgumentTuple&> extra_matcher_;\n  Action<F> action_;\n};  // class OnCallSpec\n\n// Possible reactions on uninteresting calls.\nenum CallReaction {\n  kAllow,\n  kWarn,\n  kFail,\n  kDefault = kWarn  // By default, warn about uninteresting calls.\n};\n\n}  // namespace internal\n\n// Utilities for manipulating mock objects.\nclass GTEST_API_ Mock {\n public:\n  // The following public methods can be called concurrently.\n\n  // Tells Google Mock to ignore mock_obj when checking for leaked\n  // mock objects.\n  static void AllowLeak(const void* mock_obj)\n      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);\n\n  // Verifies and clears all expectations on the given mock object.\n  // If the expectations aren't satisfied, generates one or more\n  // Google Test non-fatal failures and returns false.\n  static bool VerifyAndClearExpectations(void* mock_obj)\n      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);\n\n  // Verifies all expectations on the given mock object and clears its\n  // default actions and expectations.  Returns true iff the\n  // verification was successful.\n  static bool VerifyAndClear(void* mock_obj)\n      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);\n\n private:\n  friend class internal::UntypedFunctionMockerBase;\n\n  // Needed for a function mocker to register itself (so that we know\n  // how to clear a mock object).\n  template <typename F>\n  friend class internal::FunctionMockerBase;\n\n  template <typename M>\n  friend class NiceMock;\n\n  template <typename M>\n  friend class NaggyMock;\n\n  template <typename M>\n  friend class StrictMock;\n\n  // Tells Google Mock to allow uninteresting calls on the given mock\n  // object.\n  static void AllowUninterestingCalls(const void* mock_obj)\n      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);\n\n  // Tells Google Mock to warn the user about uninteresting calls on\n  // the given mock object.\n  static void WarnUninterestingCalls(const void* mock_obj)\n      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);\n\n  // Tells Google Mock to fail uninteresting calls on the given mock\n  // object.\n  static void FailUninterestingCalls(const void* mock_obj)\n      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);\n\n  // Tells Google Mock the given mock object is being destroyed and\n  // its entry in the call-reaction table should be removed.\n  static void UnregisterCallReaction(const void* mock_obj)\n      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);\n\n  // Returns the reaction Google Mock will have on uninteresting calls\n  // made on the given mock object.\n  static internal::CallReaction GetReactionOnUninterestingCalls(\n      const void* mock_obj)\n          GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);\n\n  // Verifies that all expectations on the given mock object have been\n  // satisfied.  Reports one or more Google Test non-fatal failures\n  // and returns false if not.\n  static bool VerifyAndClearExpectationsLocked(void* mock_obj)\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(internal::g_gmock_mutex);\n\n  // Clears all ON_CALL()s set on the given mock object.\n  static void ClearDefaultActionsLocked(void* mock_obj)\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(internal::g_gmock_mutex);\n\n  // Registers a mock object and a mock method it owns.\n  static void Register(\n      const void* mock_obj,\n      internal::UntypedFunctionMockerBase* mocker)\n          GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);\n\n  // Tells Google Mock where in the source code mock_obj is used in an\n  // ON_CALL or EXPECT_CALL.  In case mock_obj is leaked, this\n  // information helps the user identify which object it is.\n  static void RegisterUseByOnCallOrExpectCall(\n      const void* mock_obj, const char* file, int line)\n          GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);\n\n  // Unregisters a mock method; removes the owning mock object from\n  // the registry when the last mock method associated with it has\n  // been unregistered.  This is called only in the destructor of\n  // FunctionMockerBase.\n  static void UnregisterLocked(internal::UntypedFunctionMockerBase* mocker)\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(internal::g_gmock_mutex);\n};  // class Mock\n\n// An abstract handle of an expectation.  Useful in the .After()\n// clause of EXPECT_CALL() for setting the (partial) order of\n// expectations.  The syntax:\n//\n//   Expectation e1 = EXPECT_CALL(...)...;\n//   EXPECT_CALL(...).After(e1)...;\n//\n// sets two expectations where the latter can only be matched after\n// the former has been satisfied.\n//\n// Notes:\n//   - This class is copyable and has value semantics.\n//   - Constness is shallow: a const Expectation object itself cannot\n//     be modified, but the mutable methods of the ExpectationBase\n//     object it references can be called via expectation_base().\n//   - The constructors and destructor are defined out-of-line because\n//     the Symbian WINSCW compiler wants to otherwise instantiate them\n//     when it sees this class definition, at which point it doesn't have\n//     ExpectationBase available yet, leading to incorrect destruction\n//     in the linked_ptr (or compilation errors if using a checking\n//     linked_ptr).\nclass GTEST_API_ Expectation {\n public:\n  // Constructs a null object that doesn't reference any expectation.\n  Expectation();\n\n  ~Expectation();\n\n  // This single-argument ctor must not be explicit, in order to support the\n  //   Expectation e = EXPECT_CALL(...);\n  // syntax.\n  //\n  // A TypedExpectation object stores its pre-requisites as\n  // Expectation objects, and needs to call the non-const Retire()\n  // method on the ExpectationBase objects they reference.  Therefore\n  // Expectation must receive a *non-const* reference to the\n  // ExpectationBase object.\n  Expectation(internal::ExpectationBase& exp);  // NOLINT\n\n  // The compiler-generated copy ctor and operator= work exactly as\n  // intended, so we don't need to define our own.\n\n  // Returns true iff rhs references the same expectation as this object does.\n  bool operator==(const Expectation& rhs) const {\n    return expectation_base_ == rhs.expectation_base_;\n  }\n\n  bool operator!=(const Expectation& rhs) const { return !(*this == rhs); }\n\n private:\n  friend class ExpectationSet;\n  friend class Sequence;\n  friend class ::testing::internal::ExpectationBase;\n  friend class ::testing::internal::UntypedFunctionMockerBase;\n\n  template <typename F>\n  friend class ::testing::internal::FunctionMockerBase;\n\n  template <typename F>\n  friend class ::testing::internal::TypedExpectation;\n\n  // This comparator is needed for putting Expectation objects into a set.\n  class Less {\n   public:\n    bool operator()(const Expectation& lhs, const Expectation& rhs) const {\n      return lhs.expectation_base_.get() < rhs.expectation_base_.get();\n    }\n  };\n\n  typedef ::std::set<Expectation, Less> Set;\n\n  Expectation(\n      const internal::linked_ptr<internal::ExpectationBase>& expectation_base);\n\n  // Returns the expectation this object references.\n  const internal::linked_ptr<internal::ExpectationBase>&\n  expectation_base() const {\n    return expectation_base_;\n  }\n\n  // A linked_ptr that co-owns the expectation this handle references.\n  internal::linked_ptr<internal::ExpectationBase> expectation_base_;\n};\n\n// A set of expectation handles.  Useful in the .After() clause of\n// EXPECT_CALL() for setting the (partial) order of expectations.  The\n// syntax:\n//\n//   ExpectationSet es;\n//   es += EXPECT_CALL(...)...;\n//   es += EXPECT_CALL(...)...;\n//   EXPECT_CALL(...).After(es)...;\n//\n// sets three expectations where the last one can only be matched\n// after the first two have both been satisfied.\n//\n// This class is copyable and has value semantics.\nclass ExpectationSet {\n public:\n  // A bidirectional iterator that can read a const element in the set.\n  typedef Expectation::Set::const_iterator const_iterator;\n\n  // An object stored in the set.  This is an alias of Expectation.\n  typedef Expectation::Set::value_type value_type;\n\n  // Constructs an empty set.\n  ExpectationSet() {}\n\n  // This single-argument ctor must not be explicit, in order to support the\n  //   ExpectationSet es = EXPECT_CALL(...);\n  // syntax.\n  ExpectationSet(internal::ExpectationBase& exp) {  // NOLINT\n    *this += Expectation(exp);\n  }\n\n  // This single-argument ctor implements implicit conversion from\n  // Expectation and thus must not be explicit.  This allows either an\n  // Expectation or an ExpectationSet to be used in .After().\n  ExpectationSet(const Expectation& e) {  // NOLINT\n    *this += e;\n  }\n\n  // The compiler-generator ctor and operator= works exactly as\n  // intended, so we don't need to define our own.\n\n  // Returns true iff rhs contains the same set of Expectation objects\n  // as this does.\n  bool operator==(const ExpectationSet& rhs) const {\n    return expectations_ == rhs.expectations_;\n  }\n\n  bool operator!=(const ExpectationSet& rhs) const { return !(*this == rhs); }\n\n  // Implements the syntax\n  //   expectation_set += EXPECT_CALL(...);\n  ExpectationSet& operator+=(const Expectation& e) {\n    expectations_.insert(e);\n    return *this;\n  }\n\n  int size() const { return static_cast<int>(expectations_.size()); }\n\n  const_iterator begin() const { return expectations_.begin(); }\n  const_iterator end() const { return expectations_.end(); }\n\n private:\n  Expectation::Set expectations_;\n};\n\n\n// Sequence objects are used by a user to specify the relative order\n// in which the expectations should match.  They are copyable (we rely\n// on the compiler-defined copy constructor and assignment operator).\nclass GTEST_API_ Sequence {\n public:\n  // Constructs an empty sequence.\n  Sequence() : last_expectation_(new Expectation) {}\n\n  // Adds an expectation to this sequence.  The caller must ensure\n  // that no other thread is accessing this Sequence object.\n  void AddExpectation(const Expectation& expectation) const;\n\n private:\n  // The last expectation in this sequence.  We use a linked_ptr here\n  // because Sequence objects are copyable and we want the copies to\n  // be aliases.  The linked_ptr allows the copies to co-own and share\n  // the same Expectation object.\n  internal::linked_ptr<Expectation> last_expectation_;\n};  // class Sequence\n\n// An object of this type causes all EXPECT_CALL() statements\n// encountered in its scope to be put in an anonymous sequence.  The\n// work is done in the constructor and destructor.  You should only\n// create an InSequence object on the stack.\n//\n// The sole purpose for this class is to support easy definition of\n// sequential expectations, e.g.\n//\n//   {\n//     InSequence dummy;  // The name of the object doesn't matter.\n//\n//     // The following expectations must match in the order they appear.\n//     EXPECT_CALL(a, Bar())...;\n//     EXPECT_CALL(a, Baz())...;\n//     ...\n//     EXPECT_CALL(b, Xyz())...;\n//   }\n//\n// You can create InSequence objects in multiple threads, as long as\n// they are used to affect different mock objects.  The idea is that\n// each thread can create and set up its own mocks as if it's the only\n// thread.  However, for clarity of your tests we recommend you to set\n// up mocks in the main thread unless you have a good reason not to do\n// so.\nclass GTEST_API_ InSequence {\n public:\n  InSequence();\n  ~InSequence();\n private:\n  bool sequence_created_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(InSequence);  // NOLINT\n} GTEST_ATTRIBUTE_UNUSED_;\n\nnamespace internal {\n\n// Points to the implicit sequence introduced by a living InSequence\n// object (if any) in the current thread or NULL.\nGTEST_API_ extern ThreadLocal<Sequence*> g_gmock_implicit_sequence;\n\n// Base class for implementing expectations.\n//\n// There are two reasons for having a type-agnostic base class for\n// Expectation:\n//\n//   1. We need to store collections of expectations of different\n//   types (e.g. all pre-requisites of a particular expectation, all\n//   expectations in a sequence).  Therefore these expectation objects\n//   must share a common base class.\n//\n//   2. We can avoid binary code bloat by moving methods not depending\n//   on the template argument of Expectation to the base class.\n//\n// This class is internal and mustn't be used by user code directly.\nclass GTEST_API_ ExpectationBase {\n public:\n  // source_text is the EXPECT_CALL(...) source that created this Expectation.\n  ExpectationBase(const char* file, int line, const string& source_text);\n\n  virtual ~ExpectationBase();\n\n  // Where in the source file was the expectation spec defined?\n  const char* file() const { return file_; }\n  int line() const { return line_; }\n  const char* source_text() const { return source_text_.c_str(); }\n  // Returns the cardinality specified in the expectation spec.\n  const Cardinality& cardinality() const { return cardinality_; }\n\n  // Describes the source file location of this expectation.\n  void DescribeLocationTo(::std::ostream* os) const {\n    *os << FormatFileLocation(file(), line()) << \" \";\n  }\n\n  // Describes how many times a function call matching this\n  // expectation has occurred.\n  void DescribeCallCountTo(::std::ostream* os) const\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);\n\n  // If this mock method has an extra matcher (i.e. .With(matcher)),\n  // describes it to the ostream.\n  virtual void MaybeDescribeExtraMatcherTo(::std::ostream* os) = 0;\n\n protected:\n  friend class ::testing::Expectation;\n  friend class UntypedFunctionMockerBase;\n\n  enum Clause {\n    // Don't change the order of the enum members!\n    kNone,\n    kWith,\n    kTimes,\n    kInSequence,\n    kAfter,\n    kWillOnce,\n    kWillRepeatedly,\n    kRetiresOnSaturation\n  };\n\n  typedef std::vector<const void*> UntypedActions;\n\n  // Returns an Expectation object that references and co-owns this\n  // expectation.\n  virtual Expectation GetHandle() = 0;\n\n  // Asserts that the EXPECT_CALL() statement has the given property.\n  void AssertSpecProperty(bool property, const string& failure_message) const {\n    Assert(property, file_, line_, failure_message);\n  }\n\n  // Expects that the EXPECT_CALL() statement has the given property.\n  void ExpectSpecProperty(bool property, const string& failure_message) const {\n    Expect(property, file_, line_, failure_message);\n  }\n\n  // Explicitly specifies the cardinality of this expectation.  Used\n  // by the subclasses to implement the .Times() clause.\n  void SpecifyCardinality(const Cardinality& cardinality);\n\n  // Returns true iff the user specified the cardinality explicitly\n  // using a .Times().\n  bool cardinality_specified() const { return cardinality_specified_; }\n\n  // Sets the cardinality of this expectation spec.\n  void set_cardinality(const Cardinality& a_cardinality) {\n    cardinality_ = a_cardinality;\n  }\n\n  // The following group of methods should only be called after the\n  // EXPECT_CALL() statement, and only when g_gmock_mutex is held by\n  // the current thread.\n\n  // Retires all pre-requisites of this expectation.\n  void RetireAllPreRequisites()\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);\n\n  // Returns true iff this expectation is retired.\n  bool is_retired() const\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    return retired_;\n  }\n\n  // Retires this expectation.\n  void Retire()\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    retired_ = true;\n  }\n\n  // Returns true iff this expectation is satisfied.\n  bool IsSatisfied() const\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    return cardinality().IsSatisfiedByCallCount(call_count_);\n  }\n\n  // Returns true iff this expectation is saturated.\n  bool IsSaturated() const\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    return cardinality().IsSaturatedByCallCount(call_count_);\n  }\n\n  // Returns true iff this expectation is over-saturated.\n  bool IsOverSaturated() const\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    return cardinality().IsOverSaturatedByCallCount(call_count_);\n  }\n\n  // Returns true iff all pre-requisites of this expectation are satisfied.\n  bool AllPrerequisitesAreSatisfied() const\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);\n\n  // Adds unsatisfied pre-requisites of this expectation to 'result'.\n  void FindUnsatisfiedPrerequisites(ExpectationSet* result) const\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);\n\n  // Returns the number this expectation has been invoked.\n  int call_count() const\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    return call_count_;\n  }\n\n  // Increments the number this expectation has been invoked.\n  void IncrementCallCount()\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    call_count_++;\n  }\n\n  // Checks the action count (i.e. the number of WillOnce() and\n  // WillRepeatedly() clauses) against the cardinality if this hasn't\n  // been done before.  Prints a warning if there are too many or too\n  // few actions.\n  void CheckActionCountIfNotDone() const\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  friend class ::testing::Sequence;\n  friend class ::testing::internal::ExpectationTester;\n\n  template <typename Function>\n  friend class TypedExpectation;\n\n  // Implements the .Times() clause.\n  void UntypedTimes(const Cardinality& a_cardinality);\n\n  // This group of fields are part of the spec and won't change after\n  // an EXPECT_CALL() statement finishes.\n  const char* file_;          // The file that contains the expectation.\n  int line_;                  // The line number of the expectation.\n  const string source_text_;  // The EXPECT_CALL(...) source text.\n  // True iff the cardinality is specified explicitly.\n  bool cardinality_specified_;\n  Cardinality cardinality_;            // The cardinality of the expectation.\n  // The immediate pre-requisites (i.e. expectations that must be\n  // satisfied before this expectation can be matched) of this\n  // expectation.  We use linked_ptr in the set because we want an\n  // Expectation object to be co-owned by its FunctionMocker and its\n  // successors.  This allows multiple mock objects to be deleted at\n  // different times.\n  ExpectationSet immediate_prerequisites_;\n\n  // This group of fields are the current state of the expectation,\n  // and can change as the mock function is called.\n  int call_count_;  // How many times this expectation has been invoked.\n  bool retired_;    // True iff this expectation has retired.\n  UntypedActions untyped_actions_;\n  bool extra_matcher_specified_;\n  bool repeated_action_specified_;  // True if a WillRepeatedly() was specified.\n  bool retires_on_saturation_;\n  Clause last_clause_;\n  mutable bool action_count_checked_;  // Under mutex_.\n  mutable Mutex mutex_;  // Protects action_count_checked_.\n\n  GTEST_DISALLOW_ASSIGN_(ExpectationBase);\n};  // class ExpectationBase\n\n// Impements an expectation for the given function type.\ntemplate <typename F>\nclass TypedExpectation : public ExpectationBase {\n public:\n  typedef typename Function<F>::ArgumentTuple ArgumentTuple;\n  typedef typename Function<F>::ArgumentMatcherTuple ArgumentMatcherTuple;\n  typedef typename Function<F>::Result Result;\n\n  TypedExpectation(FunctionMockerBase<F>* owner,\n                   const char* a_file, int a_line, const string& a_source_text,\n                   const ArgumentMatcherTuple& m)\n      : ExpectationBase(a_file, a_line, a_source_text),\n        owner_(owner),\n        matchers_(m),\n        // By default, extra_matcher_ should match anything.  However,\n        // we cannot initialize it with _ as that triggers a compiler\n        // bug in Symbian's C++ compiler (cannot decide between two\n        // overloaded constructors of Matcher<const ArgumentTuple&>).\n        extra_matcher_(A<const ArgumentTuple&>()),\n        repeated_action_(DoDefault()) {}\n\n  virtual ~TypedExpectation() {\n    // Check the validity of the action count if it hasn't been done\n    // yet (for example, if the expectation was never used).\n    CheckActionCountIfNotDone();\n    for (UntypedActions::const_iterator it = untyped_actions_.begin();\n         it != untyped_actions_.end(); ++it) {\n      delete static_cast<const Action<F>*>(*it);\n    }\n  }\n\n  // Implements the .With() clause.\n  TypedExpectation& With(const Matcher<const ArgumentTuple&>& m) {\n    if (last_clause_ == kWith) {\n      ExpectSpecProperty(false,\n                         \".With() cannot appear \"\n                         \"more than once in an EXPECT_CALL().\");\n    } else {\n      ExpectSpecProperty(last_clause_ < kWith,\n                         \".With() must be the first \"\n                         \"clause in an EXPECT_CALL().\");\n    }\n    last_clause_ = kWith;\n\n    extra_matcher_ = m;\n    extra_matcher_specified_ = true;\n    return *this;\n  }\n\n  // Implements the .Times() clause.\n  TypedExpectation& Times(const Cardinality& a_cardinality) {\n    ExpectationBase::UntypedTimes(a_cardinality);\n    return *this;\n  }\n\n  // Implements the .Times() clause.\n  TypedExpectation& Times(int n) {\n    return Times(Exactly(n));\n  }\n\n  // Implements the .InSequence() clause.\n  TypedExpectation& InSequence(const Sequence& s) {\n    ExpectSpecProperty(last_clause_ <= kInSequence,\n                       \".InSequence() cannot appear after .After(),\"\n                       \" .WillOnce(), .WillRepeatedly(), or \"\n                       \".RetiresOnSaturation().\");\n    last_clause_ = kInSequence;\n\n    s.AddExpectation(GetHandle());\n    return *this;\n  }\n  TypedExpectation& InSequence(const Sequence& s1, const Sequence& s2) {\n    return InSequence(s1).InSequence(s2);\n  }\n  TypedExpectation& InSequence(const Sequence& s1, const Sequence& s2,\n                               const Sequence& s3) {\n    return InSequence(s1, s2).InSequence(s3);\n  }\n  TypedExpectation& InSequence(const Sequence& s1, const Sequence& s2,\n                               const Sequence& s3, const Sequence& s4) {\n    return InSequence(s1, s2, s3).InSequence(s4);\n  }\n  TypedExpectation& InSequence(const Sequence& s1, const Sequence& s2,\n                               const Sequence& s3, const Sequence& s4,\n                               const Sequence& s5) {\n    return InSequence(s1, s2, s3, s4).InSequence(s5);\n  }\n\n  // Implements that .After() clause.\n  TypedExpectation& After(const ExpectationSet& s) {\n    ExpectSpecProperty(last_clause_ <= kAfter,\n                       \".After() cannot appear after .WillOnce(),\"\n                       \" .WillRepeatedly(), or \"\n                       \".RetiresOnSaturation().\");\n    last_clause_ = kAfter;\n\n    for (ExpectationSet::const_iterator it = s.begin(); it != s.end(); ++it) {\n      immediate_prerequisites_ += *it;\n    }\n    return *this;\n  }\n  TypedExpectation& After(const ExpectationSet& s1, const ExpectationSet& s2) {\n    return After(s1).After(s2);\n  }\n  TypedExpectation& After(const ExpectationSet& s1, const ExpectationSet& s2,\n                          const ExpectationSet& s3) {\n    return After(s1, s2).After(s3);\n  }\n  TypedExpectation& After(const ExpectationSet& s1, const ExpectationSet& s2,\n                          const ExpectationSet& s3, const ExpectationSet& s4) {\n    return After(s1, s2, s3).After(s4);\n  }\n  TypedExpectation& After(const ExpectationSet& s1, const ExpectationSet& s2,\n                          const ExpectationSet& s3, const ExpectationSet& s4,\n                          const ExpectationSet& s5) {\n    return After(s1, s2, s3, s4).After(s5);\n  }\n\n  // Implements the .WillOnce() clause.\n  TypedExpectation& WillOnce(const Action<F>& action) {\n    ExpectSpecProperty(last_clause_ <= kWillOnce,\n                       \".WillOnce() cannot appear after \"\n                       \".WillRepeatedly() or .RetiresOnSaturation().\");\n    last_clause_ = kWillOnce;\n\n    untyped_actions_.push_back(new Action<F>(action));\n    if (!cardinality_specified()) {\n      set_cardinality(Exactly(static_cast<int>(untyped_actions_.size())));\n    }\n    return *this;\n  }\n\n  // Implements the .WillRepeatedly() clause.\n  TypedExpectation& WillRepeatedly(const Action<F>& action) {\n    if (last_clause_ == kWillRepeatedly) {\n      ExpectSpecProperty(false,\n                         \".WillRepeatedly() cannot appear \"\n                         \"more than once in an EXPECT_CALL().\");\n    } else {\n      ExpectSpecProperty(last_clause_ < kWillRepeatedly,\n                         \".WillRepeatedly() cannot appear \"\n                         \"after .RetiresOnSaturation().\");\n    }\n    last_clause_ = kWillRepeatedly;\n    repeated_action_specified_ = true;\n\n    repeated_action_ = action;\n    if (!cardinality_specified()) {\n      set_cardinality(AtLeast(static_cast<int>(untyped_actions_.size())));\n    }\n\n    // Now that no more action clauses can be specified, we check\n    // whether their count makes sense.\n    CheckActionCountIfNotDone();\n    return *this;\n  }\n\n  // Implements the .RetiresOnSaturation() clause.\n  TypedExpectation& RetiresOnSaturation() {\n    ExpectSpecProperty(last_clause_ < kRetiresOnSaturation,\n                       \".RetiresOnSaturation() cannot appear \"\n                       \"more than once.\");\n    last_clause_ = kRetiresOnSaturation;\n    retires_on_saturation_ = true;\n\n    // Now that no more action clauses can be specified, we check\n    // whether their count makes sense.\n    CheckActionCountIfNotDone();\n    return *this;\n  }\n\n  // Returns the matchers for the arguments as specified inside the\n  // EXPECT_CALL() macro.\n  const ArgumentMatcherTuple& matchers() const {\n    return matchers_;\n  }\n\n  // Returns the matcher specified by the .With() clause.\n  const Matcher<const ArgumentTuple&>& extra_matcher() const {\n    return extra_matcher_;\n  }\n\n  // Returns the action specified by the .WillRepeatedly() clause.\n  const Action<F>& repeated_action() const { return repeated_action_; }\n\n  // If this mock method has an extra matcher (i.e. .With(matcher)),\n  // describes it to the ostream.\n  virtual void MaybeDescribeExtraMatcherTo(::std::ostream* os) {\n    if (extra_matcher_specified_) {\n      *os << \"    Expected args: \";\n      extra_matcher_.DescribeTo(os);\n      *os << \"\\n\";\n    }\n  }\n\n private:\n  template <typename Function>\n  friend class FunctionMockerBase;\n\n  // Returns an Expectation object that references and co-owns this\n  // expectation.\n  virtual Expectation GetHandle() {\n    return owner_->GetHandleOf(this);\n  }\n\n  // The following methods will be called only after the EXPECT_CALL()\n  // statement finishes and when the current thread holds\n  // g_gmock_mutex.\n\n  // Returns true iff this expectation matches the given arguments.\n  bool Matches(const ArgumentTuple& args) const\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    return TupleMatches(matchers_, args) && extra_matcher_.Matches(args);\n  }\n\n  // Returns true iff this expectation should handle the given arguments.\n  bool ShouldHandleArguments(const ArgumentTuple& args) const\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n\n    // In case the action count wasn't checked when the expectation\n    // was defined (e.g. if this expectation has no WillRepeatedly()\n    // or RetiresOnSaturation() clause), we check it when the\n    // expectation is used for the first time.\n    CheckActionCountIfNotDone();\n    return !is_retired() && AllPrerequisitesAreSatisfied() && Matches(args);\n  }\n\n  // Describes the result of matching the arguments against this\n  // expectation to the given ostream.\n  void ExplainMatchResultTo(\n      const ArgumentTuple& args,\n      ::std::ostream* os) const\n          GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n\n    if (is_retired()) {\n      *os << \"         Expected: the expectation is active\\n\"\n          << \"           Actual: it is retired\\n\";\n    } else if (!Matches(args)) {\n      if (!TupleMatches(matchers_, args)) {\n        ExplainMatchFailureTupleTo(matchers_, args, os);\n      }\n      StringMatchResultListener listener;\n      if (!extra_matcher_.MatchAndExplain(args, &listener)) {\n        *os << \"    Expected args: \";\n        extra_matcher_.DescribeTo(os);\n        *os << \"\\n           Actual: don't match\";\n\n        internal::PrintIfNotEmpty(listener.str(), os);\n        *os << \"\\n\";\n      }\n    } else if (!AllPrerequisitesAreSatisfied()) {\n      *os << \"         Expected: all pre-requisites are satisfied\\n\"\n          << \"           Actual: the following immediate pre-requisites \"\n          << \"are not satisfied:\\n\";\n      ExpectationSet unsatisfied_prereqs;\n      FindUnsatisfiedPrerequisites(&unsatisfied_prereqs);\n      int i = 0;\n      for (ExpectationSet::const_iterator it = unsatisfied_prereqs.begin();\n           it != unsatisfied_prereqs.end(); ++it) {\n        it->expectation_base()->DescribeLocationTo(os);\n        *os << \"pre-requisite #\" << i++ << \"\\n\";\n      }\n      *os << \"                   (end of pre-requisites)\\n\";\n    } else {\n      // This line is here just for completeness' sake.  It will never\n      // be executed as currently the ExplainMatchResultTo() function\n      // is called only when the mock function call does NOT match the\n      // expectation.\n      *os << \"The call matches the expectation.\\n\";\n    }\n  }\n\n  // Returns the action that should be taken for the current invocation.\n  const Action<F>& GetCurrentAction(\n      const FunctionMockerBase<F>* mocker,\n      const ArgumentTuple& args) const\n          GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    const int count = call_count();\n    Assert(count >= 1, __FILE__, __LINE__,\n           \"call_count() is <= 0 when GetCurrentAction() is \"\n           \"called - this should never happen.\");\n\n    const int action_count = static_cast<int>(untyped_actions_.size());\n    if (action_count > 0 && !repeated_action_specified_ &&\n        count > action_count) {\n      // If there is at least one WillOnce() and no WillRepeatedly(),\n      // we warn the user when the WillOnce() clauses ran out.\n      ::std::stringstream ss;\n      DescribeLocationTo(&ss);\n      ss << \"Actions ran out in \" << source_text() << \"...\\n\"\n         << \"Called \" << count << \" times, but only \"\n         << action_count << \" WillOnce()\"\n         << (action_count == 1 ? \" is\" : \"s are\") << \" specified - \";\n      mocker->DescribeDefaultActionTo(args, &ss);\n      Log(kWarning, ss.str(), 1);\n    }\n\n    return count <= action_count ?\n        *static_cast<const Action<F>*>(untyped_actions_[count - 1]) :\n        repeated_action();\n  }\n\n  // Given the arguments of a mock function call, if the call will\n  // over-saturate this expectation, returns the default action;\n  // otherwise, returns the next action in this expectation.  Also\n  // describes *what* happened to 'what', and explains *why* Google\n  // Mock does it to 'why'.  This method is not const as it calls\n  // IncrementCallCount().  A return value of NULL means the default\n  // action.\n  const Action<F>* GetActionForArguments(\n      const FunctionMockerBase<F>* mocker,\n      const ArgumentTuple& args,\n      ::std::ostream* what,\n      ::std::ostream* why)\n          GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    if (IsSaturated()) {\n      // We have an excessive call.\n      IncrementCallCount();\n      *what << \"Mock function called more times than expected - \";\n      mocker->DescribeDefaultActionTo(args, what);\n      DescribeCallCountTo(why);\n\n      // TODO(wan@google.com): allow the user to control whether\n      // unexpected calls should fail immediately or continue using a\n      // flag --gmock_unexpected_calls_are_fatal.\n      return NULL;\n    }\n\n    IncrementCallCount();\n    RetireAllPreRequisites();\n\n    if (retires_on_saturation_ && IsSaturated()) {\n      Retire();\n    }\n\n    // Must be done after IncrementCount()!\n    *what << \"Mock function call matches \" << source_text() <<\"...\\n\";\n    return &(GetCurrentAction(mocker, args));\n  }\n\n  // All the fields below won't change once the EXPECT_CALL()\n  // statement finishes.\n  FunctionMockerBase<F>* const owner_;\n  ArgumentMatcherTuple matchers_;\n  Matcher<const ArgumentTuple&> extra_matcher_;\n  Action<F> repeated_action_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TypedExpectation);\n};  // class TypedExpectation\n\n// A MockSpec object is used by ON_CALL() or EXPECT_CALL() for\n// specifying the default behavior of, or expectation on, a mock\n// function.\n\n// Note: class MockSpec really belongs to the ::testing namespace.\n// However if we define it in ::testing, MSVC will complain when\n// classes in ::testing::internal declare it as a friend class\n// template.  To workaround this compiler bug, we define MockSpec in\n// ::testing::internal and import it into ::testing.\n\n// Logs a message including file and line number information.\nGTEST_API_ void LogWithLocation(testing::internal::LogSeverity severity,\n                                const char* file, int line,\n                                const string& message);\n\ntemplate <typename F>\nclass MockSpec {\n public:\n  typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n  typedef typename internal::Function<F>::ArgumentMatcherTuple\n      ArgumentMatcherTuple;\n\n  // Constructs a MockSpec object, given the function mocker object\n  // that the spec is associated with.\n  explicit MockSpec(internal::FunctionMockerBase<F>* function_mocker)\n      : function_mocker_(function_mocker) {}\n\n  // Adds a new default action spec to the function mocker and returns\n  // the newly created spec.\n  internal::OnCallSpec<F>& InternalDefaultActionSetAt(\n      const char* file, int line, const char* obj, const char* call) {\n    LogWithLocation(internal::kInfo, file, line,\n        string(\"ON_CALL(\") + obj + \", \" + call + \") invoked\");\n    return function_mocker_->AddNewOnCallSpec(file, line, matchers_);\n  }\n\n  // Adds a new expectation spec to the function mocker and returns\n  // the newly created spec.\n  internal::TypedExpectation<F>& InternalExpectedAt(\n      const char* file, int line, const char* obj, const char* call) {\n    const string source_text(string(\"EXPECT_CALL(\") + obj + \", \" + call + \")\");\n    LogWithLocation(internal::kInfo, file, line, source_text + \" invoked\");\n    return function_mocker_->AddNewExpectation(\n        file, line, source_text, matchers_);\n  }\n\n private:\n  template <typename Function>\n  friend class internal::FunctionMocker;\n\n  void SetMatchers(const ArgumentMatcherTuple& matchers) {\n    matchers_ = matchers;\n  }\n\n  // The function mocker that owns this spec.\n  internal::FunctionMockerBase<F>* const function_mocker_;\n  // The argument matchers specified in the spec.\n  ArgumentMatcherTuple matchers_;\n\n  GTEST_DISALLOW_ASSIGN_(MockSpec);\n};  // class MockSpec\n\n// Wrapper type for generically holding an ordinary value or lvalue reference.\n// If T is not a reference type, it must be copyable or movable.\n// ReferenceOrValueWrapper<T> is movable, and will also be copyable unless\n// T is a move-only value type (which means that it will always be copyable\n// if the current platform does not support move semantics).\n//\n// The primary template defines handling for values, but function header\n// comments describe the contract for the whole template (including\n// specializations).\ntemplate <typename T>\nclass ReferenceOrValueWrapper {\n public:\n  // Constructs a wrapper from the given value/reference.\n  explicit ReferenceOrValueWrapper(T value)\n      : value_(::testing::internal::move(value)) {\n  }\n\n  // Unwraps and returns the underlying value/reference, exactly as\n  // originally passed. The behavior of calling this more than once on\n  // the same object is unspecified.\n  T Unwrap() { return ::testing::internal::move(value_); }\n\n  // Provides nondestructive access to the underlying value/reference.\n  // Always returns a const reference (more precisely,\n  // const RemoveReference<T>&). The behavior of calling this after\n  // calling Unwrap on the same object is unspecified.\n  const T& Peek() const {\n    return value_;\n  }\n\n private:\n  T value_;\n};\n\n// Specialization for lvalue reference types. See primary template\n// for documentation.\ntemplate <typename T>\nclass ReferenceOrValueWrapper<T&> {\n public:\n  // Workaround for debatable pass-by-reference lint warning (c-library-team\n  // policy precludes NOLINT in this context)\n  typedef T& reference;\n  explicit ReferenceOrValueWrapper(reference ref)\n      : value_ptr_(&ref) {}\n  T& Unwrap() { return *value_ptr_; }\n  const T& Peek() const { return *value_ptr_; }\n\n private:\n  T* value_ptr_;\n};\n\n// MSVC warns about using 'this' in base member initializer list, so\n// we need to temporarily disable the warning.  We have to do it for\n// the entire class to suppress the warning, even though it's about\n// the constructor only.\n\n#ifdef _MSC_VER\n# pragma warning(push)          // Saves the current warning state.\n# pragma warning(disable:4355)  // Temporarily disables warning 4355.\n#endif  // _MSV_VER\n\n// C++ treats the void type specially.  For example, you cannot define\n// a void-typed variable or pass a void value to a function.\n// ActionResultHolder<T> holds a value of type T, where T must be a\n// copyable type or void (T doesn't need to be default-constructable).\n// It hides the syntactic difference between void and other types, and\n// is used to unify the code for invoking both void-returning and\n// non-void-returning mock functions.\n\n// Untyped base class for ActionResultHolder<T>.\nclass UntypedActionResultHolderBase {\n public:\n  virtual ~UntypedActionResultHolderBase() {}\n\n  // Prints the held value as an action's result to os.\n  virtual void PrintAsActionResult(::std::ostream* os) const = 0;\n};\n\n// This generic definition is used when T is not void.\ntemplate <typename T>\nclass ActionResultHolder : public UntypedActionResultHolderBase {\n public:\n  // Returns the held value. Must not be called more than once.\n  T Unwrap() {\n    return result_.Unwrap();\n  }\n\n  // Prints the held value as an action's result to os.\n  virtual void PrintAsActionResult(::std::ostream* os) const {\n    *os << \"\\n          Returns: \";\n    // T may be a reference type, so we don't use UniversalPrint().\n    UniversalPrinter<T>::Print(result_.Peek(), os);\n  }\n\n  // Performs the given mock function's default action and returns the\n  // result in a new-ed ActionResultHolder.\n  template <typename F>\n  static ActionResultHolder* PerformDefaultAction(\n      const FunctionMockerBase<F>* func_mocker,\n      const typename Function<F>::ArgumentTuple& args,\n      const string& call_description) {\n    return new ActionResultHolder(Wrapper(\n        func_mocker->PerformDefaultAction(args, call_description)));\n  }\n\n  // Performs the given action and returns the result in a new-ed\n  // ActionResultHolder.\n  template <typename F>\n  static ActionResultHolder*\n  PerformAction(const Action<F>& action,\n                const typename Function<F>::ArgumentTuple& args) {\n    return new ActionResultHolder(Wrapper(action.Perform(args)));\n  }\n\n private:\n  typedef ReferenceOrValueWrapper<T> Wrapper;\n\n  explicit ActionResultHolder(Wrapper result)\n      : result_(::testing::internal::move(result)) {\n  }\n\n  Wrapper result_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ActionResultHolder);\n};\n\n// Specialization for T = void.\ntemplate <>\nclass ActionResultHolder<void> : public UntypedActionResultHolderBase {\n public:\n  void Unwrap() { }\n\n  virtual void PrintAsActionResult(::std::ostream* /* os */) const {}\n\n  // Performs the given mock function's default action and returns ownership\n  // of an empty ActionResultHolder*.\n  template <typename F>\n  static ActionResultHolder* PerformDefaultAction(\n      const FunctionMockerBase<F>* func_mocker,\n      const typename Function<F>::ArgumentTuple& args,\n      const string& call_description) {\n    func_mocker->PerformDefaultAction(args, call_description);\n    return new ActionResultHolder;\n  }\n\n  // Performs the given action and returns ownership of an empty\n  // ActionResultHolder*.\n  template <typename F>\n  static ActionResultHolder* PerformAction(\n      const Action<F>& action,\n      const typename Function<F>::ArgumentTuple& args) {\n    action.Perform(args);\n    return new ActionResultHolder;\n  }\n\n private:\n  ActionResultHolder() {}\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ActionResultHolder);\n};\n\n// The base of the function mocker class for the given function type.\n// We put the methods in this class instead of its child to avoid code\n// bloat.\ntemplate <typename F>\nclass FunctionMockerBase : public UntypedFunctionMockerBase {\n public:\n  typedef typename Function<F>::Result Result;\n  typedef typename Function<F>::ArgumentTuple ArgumentTuple;\n  typedef typename Function<F>::ArgumentMatcherTuple ArgumentMatcherTuple;\n\n  FunctionMockerBase() : current_spec_(this) {}\n\n  // The destructor verifies that all expectations on this mock\n  // function have been satisfied.  If not, it will report Google Test\n  // non-fatal failures for the violations.\n  virtual ~FunctionMockerBase()\n        GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {\n    MutexLock l(&g_gmock_mutex);\n    VerifyAndClearExpectationsLocked();\n    Mock::UnregisterLocked(this);\n    ClearDefaultActionsLocked();\n  }\n\n  // Returns the ON_CALL spec that matches this mock function with the\n  // given arguments; returns NULL if no matching ON_CALL is found.\n  // L = *\n  const OnCallSpec<F>* FindOnCallSpec(\n      const ArgumentTuple& args) const {\n    for (UntypedOnCallSpecs::const_reverse_iterator it\n             = untyped_on_call_specs_.rbegin();\n         it != untyped_on_call_specs_.rend(); ++it) {\n      const OnCallSpec<F>* spec = static_cast<const OnCallSpec<F>*>(*it);\n      if (spec->Matches(args))\n        return spec;\n    }\n\n    return NULL;\n  }\n\n  // Performs the default action of this mock function on the given\n  // arguments and returns the result. Asserts (or throws if\n  // exceptions are enabled) with a helpful call descrption if there\n  // is no valid return value. This method doesn't depend on the\n  // mutable state of this object, and thus can be called concurrently\n  // without locking.\n  // L = *\n  Result PerformDefaultAction(const ArgumentTuple& args,\n                              const string& call_description) const {\n    const OnCallSpec<F>* const spec =\n        this->FindOnCallSpec(args);\n    if (spec != NULL) {\n      return spec->GetAction().Perform(args);\n    }\n    const string message = call_description +\n        \"\\n    The mock function has no default action \"\n        \"set, and its return type has no default value set.\";\n#if GTEST_HAS_EXCEPTIONS\n    if (!DefaultValue<Result>::Exists()) {\n      throw std::runtime_error(message);\n    }\n#else\n    Assert(DefaultValue<Result>::Exists(), \"\", -1, message);\n#endif\n    return DefaultValue<Result>::Get();\n  }\n\n  // Performs the default action with the given arguments and returns\n  // the action's result.  The call description string will be used in\n  // the error message to describe the call in the case the default\n  // action fails.  The caller is responsible for deleting the result.\n  // L = *\n  virtual UntypedActionResultHolderBase* UntypedPerformDefaultAction(\n      const void* untyped_args,  // must point to an ArgumentTuple\n      const string& call_description) const {\n    const ArgumentTuple& args =\n        *static_cast<const ArgumentTuple*>(untyped_args);\n    return ResultHolder::PerformDefaultAction(this, args, call_description);\n  }\n\n  // Performs the given action with the given arguments and returns\n  // the action's result.  The caller is responsible for deleting the\n  // result.\n  // L = *\n  virtual UntypedActionResultHolderBase* UntypedPerformAction(\n      const void* untyped_action, const void* untyped_args) const {\n    // Make a copy of the action before performing it, in case the\n    // action deletes the mock object (and thus deletes itself).\n    const Action<F> action = *static_cast<const Action<F>*>(untyped_action);\n    const ArgumentTuple& args =\n        *static_cast<const ArgumentTuple*>(untyped_args);\n    return ResultHolder::PerformAction(action, args);\n  }\n\n  // Implements UntypedFunctionMockerBase::ClearDefaultActionsLocked():\n  // clears the ON_CALL()s set on this mock function.\n  virtual void ClearDefaultActionsLocked()\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n\n    // Deleting our default actions may trigger other mock objects to be\n    // deleted, for example if an action contains a reference counted smart\n    // pointer to that mock object, and that is the last reference. So if we\n    // delete our actions within the context of the global mutex we may deadlock\n    // when this method is called again. Instead, make a copy of the set of\n    // actions to delete, clear our set within the mutex, and then delete the\n    // actions outside of the mutex.\n    UntypedOnCallSpecs specs_to_delete;\n    untyped_on_call_specs_.swap(specs_to_delete);\n\n    g_gmock_mutex.Unlock();\n    for (UntypedOnCallSpecs::const_iterator it =\n             specs_to_delete.begin();\n         it != specs_to_delete.end(); ++it) {\n      delete static_cast<const OnCallSpec<F>*>(*it);\n    }\n\n    // Lock the mutex again, since the caller expects it to be locked when we\n    // return.\n    g_gmock_mutex.Lock();\n  }\n\n protected:\n  template <typename Function>\n  friend class MockSpec;\n\n  typedef ActionResultHolder<Result> ResultHolder;\n\n  // Returns the result of invoking this mock function with the given\n  // arguments.  This function can be safely called from multiple\n  // threads concurrently.\n  Result InvokeWith(const ArgumentTuple& args)\n        GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {\n    scoped_ptr<ResultHolder> holder(\n        DownCast_<ResultHolder*>(this->UntypedInvokeWith(&args)));\n    return holder->Unwrap();\n  }\n\n  // Adds and returns a default action spec for this mock function.\n  OnCallSpec<F>& AddNewOnCallSpec(\n      const char* file, int line,\n      const ArgumentMatcherTuple& m)\n          GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {\n    Mock::RegisterUseByOnCallOrExpectCall(MockObject(), file, line);\n    OnCallSpec<F>* const on_call_spec = new OnCallSpec<F>(file, line, m);\n    untyped_on_call_specs_.push_back(on_call_spec);\n    return *on_call_spec;\n  }\n\n  // Adds and returns an expectation spec for this mock function.\n  TypedExpectation<F>& AddNewExpectation(\n      const char* file,\n      int line,\n      const string& source_text,\n      const ArgumentMatcherTuple& m)\n          GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {\n    Mock::RegisterUseByOnCallOrExpectCall(MockObject(), file, line);\n    TypedExpectation<F>* const expectation =\n        new TypedExpectation<F>(this, file, line, source_text, m);\n    const linked_ptr<ExpectationBase> untyped_expectation(expectation);\n    untyped_expectations_.push_back(untyped_expectation);\n\n    // Adds this expectation into the implicit sequence if there is one.\n    Sequence* const implicit_sequence = g_gmock_implicit_sequence.get();\n    if (implicit_sequence != NULL) {\n      implicit_sequence->AddExpectation(Expectation(untyped_expectation));\n    }\n\n    return *expectation;\n  }\n\n  // The current spec (either default action spec or expectation spec)\n  // being described on this function mocker.\n  MockSpec<F>& current_spec() { return current_spec_; }\n\n private:\n  template <typename Func> friend class TypedExpectation;\n\n  // Some utilities needed for implementing UntypedInvokeWith().\n\n  // Describes what default action will be performed for the given\n  // arguments.\n  // L = *\n  void DescribeDefaultActionTo(const ArgumentTuple& args,\n                               ::std::ostream* os) const {\n    const OnCallSpec<F>* const spec = FindOnCallSpec(args);\n\n    if (spec == NULL) {\n      *os << (internal::type_equals<Result, void>::value ?\n              \"returning directly.\\n\" :\n              \"returning default value.\\n\");\n    } else {\n      *os << \"taking default action specified at:\\n\"\n          << FormatFileLocation(spec->file(), spec->line()) << \"\\n\";\n    }\n  }\n\n  // Writes a message that the call is uninteresting (i.e. neither\n  // explicitly expected nor explicitly unexpected) to the given\n  // ostream.\n  virtual void UntypedDescribeUninterestingCall(\n      const void* untyped_args,\n      ::std::ostream* os) const\n          GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {\n    const ArgumentTuple& args =\n        *static_cast<const ArgumentTuple*>(untyped_args);\n    *os << \"Uninteresting mock function call - \";\n    DescribeDefaultActionTo(args, os);\n    *os << \"    Function call: \" << Name();\n    UniversalPrint(args, os);\n  }\n\n  // Returns the expectation that matches the given function arguments\n  // (or NULL is there's no match); when a match is found,\n  // untyped_action is set to point to the action that should be\n  // performed (or NULL if the action is \"do default\"), and\n  // is_excessive is modified to indicate whether the call exceeds the\n  // expected number.\n  //\n  // Critical section: We must find the matching expectation and the\n  // corresponding action that needs to be taken in an ATOMIC\n  // transaction.  Otherwise another thread may call this mock\n  // method in the middle and mess up the state.\n  //\n  // However, performing the action has to be left out of the critical\n  // section.  The reason is that we have no control on what the\n  // action does (it can invoke an arbitrary user function or even a\n  // mock function) and excessive locking could cause a dead lock.\n  virtual const ExpectationBase* UntypedFindMatchingExpectation(\n      const void* untyped_args,\n      const void** untyped_action, bool* is_excessive,\n      ::std::ostream* what, ::std::ostream* why)\n          GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {\n    const ArgumentTuple& args =\n        *static_cast<const ArgumentTuple*>(untyped_args);\n    MutexLock l(&g_gmock_mutex);\n    TypedExpectation<F>* exp = this->FindMatchingExpectationLocked(args);\n    if (exp == NULL) {  // A match wasn't found.\n      this->FormatUnexpectedCallMessageLocked(args, what, why);\n      return NULL;\n    }\n\n    // This line must be done before calling GetActionForArguments(),\n    // which will increment the call count for *exp and thus affect\n    // its saturation status.\n    *is_excessive = exp->IsSaturated();\n    const Action<F>* action = exp->GetActionForArguments(this, args, what, why);\n    if (action != NULL && action->IsDoDefault())\n      action = NULL;  // Normalize \"do default\" to NULL.\n    *untyped_action = action;\n    return exp;\n  }\n\n  // Prints the given function arguments to the ostream.\n  virtual void UntypedPrintArgs(const void* untyped_args,\n                                ::std::ostream* os) const {\n    const ArgumentTuple& args =\n        *static_cast<const ArgumentTuple*>(untyped_args);\n    UniversalPrint(args, os);\n  }\n\n  // Returns the expectation that matches the arguments, or NULL if no\n  // expectation matches them.\n  TypedExpectation<F>* FindMatchingExpectationLocked(\n      const ArgumentTuple& args) const\n          GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    for (typename UntypedExpectations::const_reverse_iterator it =\n             untyped_expectations_.rbegin();\n         it != untyped_expectations_.rend(); ++it) {\n      TypedExpectation<F>* const exp =\n          static_cast<TypedExpectation<F>*>(it->get());\n      if (exp->ShouldHandleArguments(args)) {\n        return exp;\n      }\n    }\n    return NULL;\n  }\n\n  // Returns a message that the arguments don't match any expectation.\n  void FormatUnexpectedCallMessageLocked(\n      const ArgumentTuple& args,\n      ::std::ostream* os,\n      ::std::ostream* why) const\n          GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    *os << \"\\nUnexpected mock function call - \";\n    DescribeDefaultActionTo(args, os);\n    PrintTriedExpectationsLocked(args, why);\n  }\n\n  // Prints a list of expectations that have been tried against the\n  // current mock function call.\n  void PrintTriedExpectationsLocked(\n      const ArgumentTuple& args,\n      ::std::ostream* why) const\n          GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    const int count = static_cast<int>(untyped_expectations_.size());\n    *why << \"Google Mock tried the following \" << count << \" \"\n         << (count == 1 ? \"expectation, but it didn't match\" :\n             \"expectations, but none matched\")\n         << \":\\n\";\n    for (int i = 0; i < count; i++) {\n      TypedExpectation<F>* const expectation =\n          static_cast<TypedExpectation<F>*>(untyped_expectations_[i].get());\n      *why << \"\\n\";\n      expectation->DescribeLocationTo(why);\n      if (count > 1) {\n        *why << \"tried expectation #\" << i << \": \";\n      }\n      *why << expectation->source_text() << \"...\\n\";\n      expectation->ExplainMatchResultTo(args, why);\n      expectation->DescribeCallCountTo(why);\n    }\n  }\n\n  // The current spec (either default action spec or expectation spec)\n  // being described on this function mocker.\n  MockSpec<F> current_spec_;\n\n  // There is no generally useful and implementable semantics of\n  // copying a mock object, so copying a mock is usually a user error.\n  // Thus we disallow copying function mockers.  If the user really\n  // wants to copy a mock object, he should implement his own copy\n  // operation, for example:\n  //\n  //   class MockFoo : public Foo {\n  //    public:\n  //     // Defines a copy constructor explicitly.\n  //     MockFoo(const MockFoo& src) {}\n  //     ...\n  //   };\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(FunctionMockerBase);\n};  // class FunctionMockerBase\n\n#ifdef _MSC_VER\n# pragma warning(pop)  // Restores the warning state.\n#endif  // _MSV_VER\n\n// Implements methods of FunctionMockerBase.\n\n// Verifies that all expectations on this mock function have been\n// satisfied.  Reports one or more Google Test non-fatal failures and\n// returns false if not.\n\n// Reports an uninteresting call (whose description is in msg) in the\n// manner specified by 'reaction'.\nvoid ReportUninterestingCall(CallReaction reaction, const string& msg);\n\n}  // namespace internal\n\n// The style guide prohibits \"using\" statements in a namespace scope\n// inside a header file.  However, the MockSpec class template is\n// meant to be defined in the ::testing namespace.  The following line\n// is just a trick for working around a bug in MSVC 8.0, which cannot\n// handle it if we define MockSpec in ::testing.\nusing internal::MockSpec;\n\n// Const(x) is a convenient function for obtaining a const reference\n// to x.  This is useful for setting expectations on an overloaded\n// const mock method, e.g.\n//\n//   class MockFoo : public FooInterface {\n//    public:\n//     MOCK_METHOD0(Bar, int());\n//     MOCK_CONST_METHOD0(Bar, int&());\n//   };\n//\n//   MockFoo foo;\n//   // Expects a call to non-const MockFoo::Bar().\n//   EXPECT_CALL(foo, Bar());\n//   // Expects a call to const MockFoo::Bar().\n//   EXPECT_CALL(Const(foo), Bar());\ntemplate <typename T>\ninline const T& Const(const T& x) { return x; }\n\n// Constructs an Expectation object that references and co-owns exp.\ninline Expectation::Expectation(internal::ExpectationBase& exp)  // NOLINT\n    : expectation_base_(exp.GetHandle().expectation_base()) {}\n\n}  // namespace testing\n\n// A separate macro is required to avoid compile errors when the name\n// of the method used in call is a result of macro expansion.\n// See CompilesWithMethodNameExpandedFromMacro tests in\n// internal/gmock-spec-builders_test.cc for more details.\n#define GMOCK_ON_CALL_IMPL_(obj, call) \\\n    ((obj).gmock_##call).InternalDefaultActionSetAt(__FILE__, __LINE__, \\\n                                                    #obj, #call)\n#define ON_CALL(obj, call) GMOCK_ON_CALL_IMPL_(obj, call)\n\n#define GMOCK_EXPECT_CALL_IMPL_(obj, call) \\\n    ((obj).gmock_##call).InternalExpectedAt(__FILE__, __LINE__, #obj, #call)\n#define EXPECT_CALL(obj, call) GMOCK_EXPECT_CALL_IMPL_(obj, call)\n\n#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_SPEC_BUILDERS_H_\n"}, "40": {"id": 40, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock.h", "content": "// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n// Google Mock - a framework for writing C++ mock classes.\n//\n// This is the main header file a user should include.\n\n#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_H_\n#define GMOCK_INCLUDE_GMOCK_GMOCK_H_\n\n// This file implements the following syntax:\n//\n//   ON_CALL(mock_object.Method(...))\n//     .With(...) ?\n//     .WillByDefault(...);\n//\n// where With() is optional and WillByDefault() must appear exactly\n// once.\n//\n//   EXPECT_CALL(mock_object.Method(...))\n//     .With(...) ?\n//     .Times(...) ?\n//     .InSequence(...) *\n//     .WillOnce(...) *\n//     .WillRepeatedly(...) ?\n//     .RetiresOnSaturation() ? ;\n//\n// where all clauses are optional and WillOnce() can be repeated.\n\n#ifdef __clang__\n#if __has_warning(\"-Wdeprecated-copy\")\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wdeprecated-copy\"\n#endif\n#endif\n\n#include \"gmock/gmock-actions.h\"\n#include \"gmock/gmock-cardinalities.h\"\n#include \"gmock/gmock-generated-actions.h\"\n#include \"gmock/gmock-generated-function-mockers.h\"\n#include \"gmock/gmock-generated-nice-strict.h\"\n#include \"gmock/gmock-generated-matchers.h\"\n#include \"gmock/gmock-matchers.h\"\n#include \"gmock/gmock-more-actions.h\"\n#include \"gmock/gmock-more-matchers.h\"\n#include \"gmock/internal/gmock-internal-utils.h\"\n\nnamespace testing {\n\n// Declares Google Mock flags that we want a user to use programmatically.\nGMOCK_DECLARE_bool_(catch_leaked_mocks);\nGMOCK_DECLARE_string_(verbose);\n\n// Initializes Google Mock.  This must be called before running the\n// tests.  In particular, it parses the command line for the flags\n// that Google Mock recognizes.  Whenever a Google Mock flag is seen,\n// it is removed from argv, and *argc is decremented.\n//\n// No value is returned.  Instead, the Google Mock flag variables are\n// updated.\n//\n// Since Google Test is needed for Google Mock to work, this function\n// also initializes Google Test and parses its flags, if that hasn't\n// been done.\nGTEST_API_ void InitGoogleMock(int* argc, char** argv);\n\n// This overloaded version can be used in Windows programs compiled in\n// UNICODE mode.\nGTEST_API_ void InitGoogleMock(int* argc, wchar_t** argv);\n\n}  // namespace testing\n\n#ifdef __clang__\n#if __has_warning(\"-Wdeprecated-copy\")\n#pragma clang diagnostic pop\n#endif\n#endif\n#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_H_\n"}, "41": {"id": 41, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/internal/custom/gmock-generated-actions.h", "content": "// This file was GENERATED by command:\n//     pump.py gmock-generated-actions.h.pump\n// DO NOT EDIT BY HAND!!!\n\n#ifndef GMOCK_INCLUDE_GMOCK_INTERNAL_CUSTOM_GMOCK_GENERATED_ACTIONS_H_\n#define GMOCK_INCLUDE_GMOCK_INTERNAL_CUSTOM_GMOCK_GENERATED_ACTIONS_H_\n\n#endif  // GMOCK_INCLUDE_GMOCK_INTERNAL_CUSTOM_GMOCK_GENERATED_ACTIONS_H_\n"}, "42": {"id": 42, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/internal/custom/gmock-matchers.h", "content": "// Copyright 2015, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// ============================================================\n// An installation-specific extension point for gmock-matchers.h.\n// ============================================================\n//\n// Adds google3 callback support to CallableTraits.\n//\n#ifndef GMOCK_INCLUDE_GMOCK_INTERNAL_CUSTOM_CALLBACK_MATCHERS_H_\n#define GMOCK_INCLUDE_GMOCK_INTERNAL_CUSTOM_CALLBACK_MATCHERS_H_\n\n#endif  //  GMOCK_INCLUDE_GMOCK_INTERNAL_CUSTOM_CALLBACK_MATCHERS_H_\n"}, "43": {"id": 43, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/internal/custom/gmock-port.h", "content": "// Copyright 2015, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Injection point for custom user configurations.\n// The following macros can be defined:\n//\n//   Flag related macros:\n//     GMOCK_DECLARE_bool_(name)\n//     GMOCK_DECLARE_int32_(name)\n//     GMOCK_DECLARE_string_(name)\n//     GMOCK_DEFINE_bool_(name, default_val, doc)\n//     GMOCK_DEFINE_int32_(name, default_val, doc)\n//     GMOCK_DEFINE_string_(name, default_val, doc)\n//\n// ** Custom implementation starts here **\n\n#ifndef GMOCK_INCLUDE_GMOCK_INTERNAL_CUSTOM_GMOCK_PORT_H_\n#define GMOCK_INCLUDE_GMOCK_INTERNAL_CUSTOM_GMOCK_PORT_H_\n\n#endif  // GMOCK_INCLUDE_GMOCK_INTERNAL_CUSTOM_GMOCK_PORT_H_\n"}, "44": {"id": 44, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/internal/gmock-generated-internal-utils.h", "content": "// This file was GENERATED by command:\n//     pump.py gmock-generated-internal-utils.h.pump\n// DO NOT EDIT BY HAND!!!\n\n// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n// Google Mock - a framework for writing C++ mock classes.\n//\n// This file contains template meta-programming utility classes needed\n// for implementing Google Mock.\n\n// IWYU pragma: private, include \"gmock/gmock.h\"\n\n#ifndef GMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_GENERATED_INTERNAL_UTILS_H_\n#define GMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_GENERATED_INTERNAL_UTILS_H_\n\n#include \"gmock/internal/gmock-port.h\"\n\nnamespace testing {\n\ntemplate <typename T>\nclass Matcher;\n\nnamespace internal {\n\n// An IgnoredValue object can be implicitly constructed from ANY value.\n// This is used in implementing the IgnoreResult(a) action.\nclass IgnoredValue {\n public:\n  // This constructor template allows any value to be implicitly\n  // converted to IgnoredValue.  The object has no data member and\n  // doesn't try to remember anything about the argument.  We\n  // deliberately omit the 'explicit' keyword in order to allow the\n  // conversion to be implicit.\n  template <typename T>\n  IgnoredValue(const T& /* ignored */) {}  // NOLINT(runtime/explicit)\n};\n\n// MatcherTuple<T>::type is a tuple type where each field is a Matcher\n// for the corresponding field in tuple type T.\ntemplate <typename Tuple>\nstruct MatcherTuple;\n\ntemplate <>\nstruct MatcherTuple< ::testing::tuple<> > {\n  typedef ::testing::tuple< > type;\n};\n\ntemplate <typename A1>\nstruct MatcherTuple< ::testing::tuple<A1> > {\n  typedef ::testing::tuple<Matcher<A1> > type;\n};\n\ntemplate <typename A1, typename A2>\nstruct MatcherTuple< ::testing::tuple<A1, A2> > {\n  typedef ::testing::tuple<Matcher<A1>, Matcher<A2> > type;\n};\n\ntemplate <typename A1, typename A2, typename A3>\nstruct MatcherTuple< ::testing::tuple<A1, A2, A3> > {\n  typedef ::testing::tuple<Matcher<A1>, Matcher<A2>, Matcher<A3> > type;\n};\n\ntemplate <typename A1, typename A2, typename A3, typename A4>\nstruct MatcherTuple< ::testing::tuple<A1, A2, A3, A4> > {\n  typedef ::testing::tuple<Matcher<A1>, Matcher<A2>, Matcher<A3>,\n      Matcher<A4> > type;\n};\n\ntemplate <typename A1, typename A2, typename A3, typename A4, typename A5>\nstruct MatcherTuple< ::testing::tuple<A1, A2, A3, A4, A5> > {\n  typedef ::testing::tuple<Matcher<A1>, Matcher<A2>, Matcher<A3>, Matcher<A4>,\n      Matcher<A5> > type;\n};\n\ntemplate <typename A1, typename A2, typename A3, typename A4, typename A5,\n    typename A6>\nstruct MatcherTuple< ::testing::tuple<A1, A2, A3, A4, A5, A6> > {\n  typedef ::testing::tuple<Matcher<A1>, Matcher<A2>, Matcher<A3>, Matcher<A4>,\n      Matcher<A5>, Matcher<A6> > type;\n};\n\ntemplate <typename A1, typename A2, typename A3, typename A4, typename A5,\n    typename A6, typename A7>\nstruct MatcherTuple< ::testing::tuple<A1, A2, A3, A4, A5, A6, A7> > {\n  typedef ::testing::tuple<Matcher<A1>, Matcher<A2>, Matcher<A3>, Matcher<A4>,\n      Matcher<A5>, Matcher<A6>, Matcher<A7> > type;\n};\n\ntemplate <typename A1, typename A2, typename A3, typename A4, typename A5,\n    typename A6, typename A7, typename A8>\nstruct MatcherTuple< ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8> > {\n  typedef ::testing::tuple<Matcher<A1>, Matcher<A2>, Matcher<A3>, Matcher<A4>,\n      Matcher<A5>, Matcher<A6>, Matcher<A7>, Matcher<A8> > type;\n};\n\ntemplate <typename A1, typename A2, typename A3, typename A4, typename A5,\n    typename A6, typename A7, typename A8, typename A9>\nstruct MatcherTuple< ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8, A9> > {\n  typedef ::testing::tuple<Matcher<A1>, Matcher<A2>, Matcher<A3>, Matcher<A4>,\n      Matcher<A5>, Matcher<A6>, Matcher<A7>, Matcher<A8>, Matcher<A9> > type;\n};\n\ntemplate <typename A1, typename A2, typename A3, typename A4, typename A5,\n    typename A6, typename A7, typename A8, typename A9, typename A10>\nstruct MatcherTuple< ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8, A9,\n    A10> > {\n  typedef ::testing::tuple<Matcher<A1>, Matcher<A2>, Matcher<A3>, Matcher<A4>,\n      Matcher<A5>, Matcher<A6>, Matcher<A7>, Matcher<A8>, Matcher<A9>,\n      Matcher<A10> > type;\n};\n\n// Template struct Function<F>, where F must be a function type, contains\n// the following typedefs:\n//\n//   Result:               the function's return type.\n//   ArgumentN:            the type of the N-th argument, where N starts with 1.\n//   ArgumentTuple:        the tuple type consisting of all parameters of F.\n//   ArgumentMatcherTuple: the tuple type consisting of Matchers for all\n//                         parameters of F.\n//   MakeResultVoid:       the function type obtained by substituting void\n//                         for the return type of F.\n//   MakeResultIgnoredValue:\n//                         the function type obtained by substituting Something\n//                         for the return type of F.\ntemplate <typename F>\nstruct Function;\n\ntemplate <typename R>\nstruct Function<R()> {\n  typedef R Result;\n  typedef ::testing::tuple<> ArgumentTuple;\n  typedef typename MatcherTuple<ArgumentTuple>::type ArgumentMatcherTuple;\n  typedef void MakeResultVoid();\n  typedef IgnoredValue MakeResultIgnoredValue();\n};\n\ntemplate <typename R, typename A1>\nstruct Function<R(A1)>\n    : Function<R()> {\n  typedef A1 Argument1;\n  typedef ::testing::tuple<A1> ArgumentTuple;\n  typedef typename MatcherTuple<ArgumentTuple>::type ArgumentMatcherTuple;\n  typedef void MakeResultVoid(A1);\n  typedef IgnoredValue MakeResultIgnoredValue(A1);\n};\n\ntemplate <typename R, typename A1, typename A2>\nstruct Function<R(A1, A2)>\n    : Function<R(A1)> {\n  typedef A2 Argument2;\n  typedef ::testing::tuple<A1, A2> ArgumentTuple;\n  typedef typename MatcherTuple<ArgumentTuple>::type ArgumentMatcherTuple;\n  typedef void MakeResultVoid(A1, A2);\n  typedef IgnoredValue MakeResultIgnoredValue(A1, A2);\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3>\nstruct Function<R(A1, A2, A3)>\n    : Function<R(A1, A2)> {\n  typedef A3 Argument3;\n  typedef ::testing::tuple<A1, A2, A3> ArgumentTuple;\n  typedef typename MatcherTuple<ArgumentTuple>::type ArgumentMatcherTuple;\n  typedef void MakeResultVoid(A1, A2, A3);\n  typedef IgnoredValue MakeResultIgnoredValue(A1, A2, A3);\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4>\nstruct Function<R(A1, A2, A3, A4)>\n    : Function<R(A1, A2, A3)> {\n  typedef A4 Argument4;\n  typedef ::testing::tuple<A1, A2, A3, A4> ArgumentTuple;\n  typedef typename MatcherTuple<ArgumentTuple>::type ArgumentMatcherTuple;\n  typedef void MakeResultVoid(A1, A2, A3, A4);\n  typedef IgnoredValue MakeResultIgnoredValue(A1, A2, A3, A4);\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5>\nstruct Function<R(A1, A2, A3, A4, A5)>\n    : Function<R(A1, A2, A3, A4)> {\n  typedef A5 Argument5;\n  typedef ::testing::tuple<A1, A2, A3, A4, A5> ArgumentTuple;\n  typedef typename MatcherTuple<ArgumentTuple>::type ArgumentMatcherTuple;\n  typedef void MakeResultVoid(A1, A2, A3, A4, A5);\n  typedef IgnoredValue MakeResultIgnoredValue(A1, A2, A3, A4, A5);\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5, typename A6>\nstruct Function<R(A1, A2, A3, A4, A5, A6)>\n    : Function<R(A1, A2, A3, A4, A5)> {\n  typedef A6 Argument6;\n  typedef ::testing::tuple<A1, A2, A3, A4, A5, A6> ArgumentTuple;\n  typedef typename MatcherTuple<ArgumentTuple>::type ArgumentMatcherTuple;\n  typedef void MakeResultVoid(A1, A2, A3, A4, A5, A6);\n  typedef IgnoredValue MakeResultIgnoredValue(A1, A2, A3, A4, A5, A6);\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5, typename A6, typename A7>\nstruct Function<R(A1, A2, A3, A4, A5, A6, A7)>\n    : Function<R(A1, A2, A3, A4, A5, A6)> {\n  typedef A7 Argument7;\n  typedef ::testing::tuple<A1, A2, A3, A4, A5, A6, A7> ArgumentTuple;\n  typedef typename MatcherTuple<ArgumentTuple>::type ArgumentMatcherTuple;\n  typedef void MakeResultVoid(A1, A2, A3, A4, A5, A6, A7);\n  typedef IgnoredValue MakeResultIgnoredValue(A1, A2, A3, A4, A5, A6, A7);\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5, typename A6, typename A7, typename A8>\nstruct Function<R(A1, A2, A3, A4, A5, A6, A7, A8)>\n    : Function<R(A1, A2, A3, A4, A5, A6, A7)> {\n  typedef A8 Argument8;\n  typedef ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8> ArgumentTuple;\n  typedef typename MatcherTuple<ArgumentTuple>::type ArgumentMatcherTuple;\n  typedef void MakeResultVoid(A1, A2, A3, A4, A5, A6, A7, A8);\n  typedef IgnoredValue MakeResultIgnoredValue(A1, A2, A3, A4, A5, A6, A7, A8);\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5, typename A6, typename A7, typename A8, typename A9>\nstruct Function<R(A1, A2, A3, A4, A5, A6, A7, A8, A9)>\n    : Function<R(A1, A2, A3, A4, A5, A6, A7, A8)> {\n  typedef A9 Argument9;\n  typedef ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8, A9> ArgumentTuple;\n  typedef typename MatcherTuple<ArgumentTuple>::type ArgumentMatcherTuple;\n  typedef void MakeResultVoid(A1, A2, A3, A4, A5, A6, A7, A8, A9);\n  typedef IgnoredValue MakeResultIgnoredValue(A1, A2, A3, A4, A5, A6, A7, A8,\n      A9);\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5, typename A6, typename A7, typename A8, typename A9,\n    typename A10>\nstruct Function<R(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>\n    : Function<R(A1, A2, A3, A4, A5, A6, A7, A8, A9)> {\n  typedef A10 Argument10;\n  typedef ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8, A9,\n      A10> ArgumentTuple;\n  typedef typename MatcherTuple<ArgumentTuple>::type ArgumentMatcherTuple;\n  typedef void MakeResultVoid(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);\n  typedef IgnoredValue MakeResultIgnoredValue(A1, A2, A3, A4, A5, A6, A7, A8,\n      A9, A10);\n};\n\n}  // namespace internal\n\n}  // namespace testing\n\n#endif  // GMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_GENERATED_INTERNAL_UTILS_H_\n"}, "45": {"id": 45, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/internal/gmock-internal-utils.h", "content": "// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n// Google Mock - a framework for writing C++ mock classes.\n//\n// This file defines some utilities useful for implementing Google\n// Mock.  They are subject to change without notice, so please DO NOT\n// USE THEM IN USER CODE.\n\n// IWYU pragma: private, include \"gmock/gmock.h\"\n\n#ifndef GMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_INTERNAL_UTILS_H_\n#define GMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_INTERNAL_UTILS_H_\n\n#include <stdio.h>\n#include <ostream>  // NOLINT\n#include <string>\n\n#include \"gmock/internal/gmock-generated-internal-utils.h\"\n#include \"gmock/internal/gmock-port.h\"\n#include \"gtest/gtest.h\"\n\nnamespace testing {\nnamespace internal {\n\n// Converts an identifier name to a space-separated list of lower-case\n// words.  Each maximum substring of the form [A-Za-z][a-z]*|\\d+ is\n// treated as one word.  For example, both \"FooBar123\" and\n// \"foo_bar_123\" are converted to \"foo bar 123\".\nGTEST_API_ string ConvertIdentifierNameToWords(const char* id_name);\n\n// PointeeOf<Pointer>::type is the type of a value pointed to by a\n// Pointer, which can be either a smart pointer or a raw pointer.  The\n// following default implementation is for the case where Pointer is a\n// smart pointer.\ntemplate <typename Pointer>\nstruct PointeeOf {\n  // Smart pointer classes define type element_type as the type of\n  // their pointees.\n  typedef typename Pointer::element_type type;\n};\n// This specialization is for the raw pointer case.\ntemplate <typename T>\nstruct PointeeOf<T*> { typedef T type; };  // NOLINT\n\n// GetRawPointer(p) returns the raw pointer underlying p when p is a\n// smart pointer, or returns p itself when p is already a raw pointer.\n// The following default implementation is for the smart pointer case.\ntemplate <typename Pointer>\ninline const typename Pointer::element_type* GetRawPointer(const Pointer& p) {\n  return p.get();\n}\n// This overloaded version is for the raw pointer case.\ntemplate <typename Element>\ninline Element* GetRawPointer(Element* p) { return p; }\n\n// This comparator allows linked_ptr to be stored in sets.\ntemplate <typename T>\nstruct LinkedPtrLessThan {\n  bool operator()(const ::testing::internal::linked_ptr<T>& lhs,\n                  const ::testing::internal::linked_ptr<T>& rhs) const {\n    return lhs.get() < rhs.get();\n  }\n};\n\n// Symbian compilation can be done with wchar_t being either a native\n// type or a typedef.  Using Google Mock with OpenC without wchar_t\n// should require the definition of _STLP_NO_WCHAR_T.\n//\n// MSVC treats wchar_t as a native type usually, but treats it as the\n// same as unsigned short when the compiler option /Zc:wchar_t- is\n// specified.  It defines _NATIVE_WCHAR_T_DEFINED symbol when wchar_t\n// is a native type.\n#if (GTEST_OS_SYMBIAN && defined(_STLP_NO_WCHAR_T)) || \\\n    (defined(_MSC_VER) && !defined(_NATIVE_WCHAR_T_DEFINED))\n// wchar_t is a typedef.\n#else\n# define GMOCK_WCHAR_T_IS_NATIVE_ 1\n#endif\n\n// signed wchar_t and unsigned wchar_t are NOT in the C++ standard.\n// Using them is a bad practice and not portable.  So DON'T use them.\n//\n// Still, Google Mock is designed to work even if the user uses signed\n// wchar_t or unsigned wchar_t (obviously, assuming the compiler\n// supports them).\n//\n// To gcc,\n//   wchar_t == signed wchar_t != unsigned wchar_t == unsigned int\n#ifdef __GNUC__\n// signed/unsigned wchar_t are valid types.\n# define GMOCK_HAS_SIGNED_WCHAR_T_ 1\n#endif\n\n// In what follows, we use the term \"kind\" to indicate whether a type\n// is bool, an integer type (excluding bool), a floating-point type,\n// or none of them.  This categorization is useful for determining\n// when a matcher argument type can be safely converted to another\n// type in the implementation of SafeMatcherCast.\nenum TypeKind {\n  kBool, kInteger, kFloatingPoint, kOther\n};\n\n// KindOf<T>::value is the kind of type T.\ntemplate <typename T> struct KindOf {\n  enum { value = kOther };  // The default kind.\n};\n\n// This macro declares that the kind of 'type' is 'kind'.\n#define GMOCK_DECLARE_KIND_(type, kind) \\\n  template <> struct KindOf<type> { enum { value = kind }; }\n\nGMOCK_DECLARE_KIND_(bool, kBool);\n\n// All standard integer types.\nGMOCK_DECLARE_KIND_(char, kInteger);\nGMOCK_DECLARE_KIND_(signed char, kInteger);\nGMOCK_DECLARE_KIND_(unsigned char, kInteger);\nGMOCK_DECLARE_KIND_(short, kInteger);  // NOLINT\nGMOCK_DECLARE_KIND_(unsigned short, kInteger);  // NOLINT\nGMOCK_DECLARE_KIND_(int, kInteger);\nGMOCK_DECLARE_KIND_(unsigned int, kInteger);\nGMOCK_DECLARE_KIND_(long, kInteger);  // NOLINT\nGMOCK_DECLARE_KIND_(unsigned long, kInteger);  // NOLINT\n\n#if GMOCK_WCHAR_T_IS_NATIVE_\nGMOCK_DECLARE_KIND_(wchar_t, kInteger);\n#endif\n\n// Non-standard integer types.\nGMOCK_DECLARE_KIND_(Int64, kInteger);\nGMOCK_DECLARE_KIND_(UInt64, kInteger);\n\n// All standard floating-point types.\nGMOCK_DECLARE_KIND_(float, kFloatingPoint);\nGMOCK_DECLARE_KIND_(double, kFloatingPoint);\nGMOCK_DECLARE_KIND_(long double, kFloatingPoint);\n\n#undef GMOCK_DECLARE_KIND_\n\n// Evaluates to the kind of 'type'.\n#define GMOCK_KIND_OF_(type) \\\n  static_cast< ::testing::internal::TypeKind>( \\\n      ::testing::internal::KindOf<type>::value)\n\n// Evaluates to true iff integer type T is signed.\n#define GMOCK_IS_SIGNED_(T) (static_cast<T>(-1) < 0)\n\n// LosslessArithmeticConvertibleImpl<kFromKind, From, kToKind, To>::value\n// is true iff arithmetic type From can be losslessly converted to\n// arithmetic type To.\n//\n// It's the user's responsibility to ensure that both From and To are\n// raw (i.e. has no CV modifier, is not a pointer, and is not a\n// reference) built-in arithmetic types, kFromKind is the kind of\n// From, and kToKind is the kind of To; the value is\n// implementation-defined when the above pre-condition is violated.\ntemplate <TypeKind kFromKind, typename From, TypeKind kToKind, typename To>\nstruct LosslessArithmeticConvertibleImpl : public false_type {};\n\n// Converting bool to bool is lossless.\ntemplate <>\nstruct LosslessArithmeticConvertibleImpl<kBool, bool, kBool, bool>\n    : public true_type {};  // NOLINT\n\n// Converting bool to any integer type is lossless.\ntemplate <typename To>\nstruct LosslessArithmeticConvertibleImpl<kBool, bool, kInteger, To>\n    : public true_type {};  // NOLINT\n\n// Converting bool to any floating-point type is lossless.\ntemplate <typename To>\nstruct LosslessArithmeticConvertibleImpl<kBool, bool, kFloatingPoint, To>\n    : public true_type {};  // NOLINT\n\n// Converting an integer to bool is lossy.\ntemplate <typename From>\nstruct LosslessArithmeticConvertibleImpl<kInteger, From, kBool, bool>\n    : public false_type {};  // NOLINT\n\n// Converting an integer to another non-bool integer is lossless iff\n// the target type's range encloses the source type's range.\ntemplate <typename From, typename To>\nstruct LosslessArithmeticConvertibleImpl<kInteger, From, kInteger, To>\n    : public bool_constant<\n      // When converting from a smaller size to a larger size, we are\n      // fine as long as we are not converting from signed to unsigned.\n      ((sizeof(From) < sizeof(To)) &&\n       (!GMOCK_IS_SIGNED_(From) || GMOCK_IS_SIGNED_(To))) ||\n      // When converting between the same size, the signedness must match.\n      ((sizeof(From) == sizeof(To)) &&\n       (GMOCK_IS_SIGNED_(From) == GMOCK_IS_SIGNED_(To)))> {};  // NOLINT\n\n#undef GMOCK_IS_SIGNED_\n\n// Converting an integer to a floating-point type may be lossy, since\n// the format of a floating-point number is implementation-defined.\ntemplate <typename From, typename To>\nstruct LosslessArithmeticConvertibleImpl<kInteger, From, kFloatingPoint, To>\n    : public false_type {};  // NOLINT\n\n// Converting a floating-point to bool is lossy.\ntemplate <typename From>\nstruct LosslessArithmeticConvertibleImpl<kFloatingPoint, From, kBool, bool>\n    : public false_type {};  // NOLINT\n\n// Converting a floating-point to an integer is lossy.\ntemplate <typename From, typename To>\nstruct LosslessArithmeticConvertibleImpl<kFloatingPoint, From, kInteger, To>\n    : public false_type {};  // NOLINT\n\n// Converting a floating-point to another floating-point is lossless\n// iff the target type is at least as big as the source type.\ntemplate <typename From, typename To>\nstruct LosslessArithmeticConvertibleImpl<\n  kFloatingPoint, From, kFloatingPoint, To>\n    : public bool_constant<sizeof(From) <= sizeof(To)> {};  // NOLINT\n\n// LosslessArithmeticConvertible<From, To>::value is true iff arithmetic\n// type From can be losslessly converted to arithmetic type To.\n//\n// It's the user's responsibility to ensure that both From and To are\n// raw (i.e. has no CV modifier, is not a pointer, and is not a\n// reference) built-in arithmetic types; the value is\n// implementation-defined when the above pre-condition is violated.\ntemplate <typename From, typename To>\nstruct LosslessArithmeticConvertible\n    : public LosslessArithmeticConvertibleImpl<\n  GMOCK_KIND_OF_(From), From, GMOCK_KIND_OF_(To), To> {};  // NOLINT\n\n// This interface knows how to report a Google Mock failure (either\n// non-fatal or fatal).\nclass FailureReporterInterface {\n public:\n  // The type of a failure (either non-fatal or fatal).\n  enum FailureType {\n    kNonfatal, kFatal\n  };\n\n  virtual ~FailureReporterInterface() {}\n\n  // Reports a failure that occurred at the given source file location.\n  virtual void ReportFailure(FailureType type, const char* file, int line,\n                             const string& message) = 0;\n};\n\n// Returns the failure reporter used by Google Mock.\nGTEST_API_ FailureReporterInterface* GetFailureReporter();\n\n// Asserts that condition is true; aborts the process with the given\n// message if condition is false.  We cannot use LOG(FATAL) or CHECK()\n// as Google Mock might be used to mock the log sink itself.  We\n// inline this function to prevent it from showing up in the stack\n// trace.\ninline void Assert(bool condition, const char* file, int line,\n                   const string& msg) {\n  if (!condition) {\n    GetFailureReporter()->ReportFailure(FailureReporterInterface::kFatal,\n                                        file, line, msg);\n  }\n}\ninline void Assert(bool condition, const char* file, int line) {\n  Assert(condition, file, line, \"Assertion failed.\");\n}\n\n// Verifies that condition is true; generates a non-fatal failure if\n// condition is false.\ninline void Expect(bool condition, const char* file, int line,\n                   const string& msg) {\n  if (!condition) {\n    GetFailureReporter()->ReportFailure(FailureReporterInterface::kNonfatal,\n                                        file, line, msg);\n  }\n}\ninline void Expect(bool condition, const char* file, int line) {\n  Expect(condition, file, line, \"Expectation failed.\");\n}\n\n// Severity level of a log.\nenum LogSeverity {\n  kInfo = 0,\n  kWarning = 1\n};\n\n// Valid values for the --gmock_verbose flag.\n\n// All logs (informational and warnings) are printed.\nconst char kInfoVerbosity[] = \"info\";\n// Only warnings are printed.\nconst char kWarningVerbosity[] = \"warning\";\n// No logs are printed.\nconst char kErrorVerbosity[] = \"error\";\n\n// Returns true iff a log with the given severity is visible according\n// to the --gmock_verbose flag.\nGTEST_API_ bool LogIsVisible(LogSeverity severity);\n\n// Prints the given message to stdout iff 'severity' >= the level\n// specified by the --gmock_verbose flag.  If stack_frames_to_skip >=\n// 0, also prints the stack trace excluding the top\n// stack_frames_to_skip frames.  In opt mode, any positive\n// stack_frames_to_skip is treated as 0, since we don't know which\n// function calls will be inlined by the compiler and need to be\n// conservative.\nGTEST_API_ void Log(LogSeverity severity,\n                    const string& message,\n                    int stack_frames_to_skip);\n\n// TODO(wan@google.com): group all type utilities together.\n\n// Type traits.\n\n// is_reference<T>::value is non-zero iff T is a reference type.\ntemplate <typename T> struct is_reference : public false_type {};\ntemplate <typename T> struct is_reference<T&> : public true_type {};\n\n// type_equals<T1, T2>::value is non-zero iff T1 and T2 are the same type.\ntemplate <typename T1, typename T2> struct type_equals : public false_type {};\ntemplate <typename T> struct type_equals<T, T> : public true_type {};\n\n// remove_reference<T>::type removes the reference from type T, if any.\ntemplate <typename T> struct remove_reference { typedef T type; };  // NOLINT\ntemplate <typename T> struct remove_reference<T&> { typedef T type; }; // NOLINT\n\n// DecayArray<T>::type turns an array type U[N] to const U* and preserves\n// other types.  Useful for saving a copy of a function argument.\ntemplate <typename T> struct DecayArray { typedef T type; };  // NOLINT\ntemplate <typename T, size_t N> struct DecayArray<T[N]> {\n  typedef const T* type;\n};\n// Sometimes people use arrays whose size is not available at the use site\n// (e.g. extern const char kNamePrefix[]).  This specialization covers that\n// case.\ntemplate <typename T> struct DecayArray<T[]> {\n  typedef const T* type;\n};\n\n// Disable MSVC warnings for infinite recursion, since in this case the\n// the recursion is unreachable.\n#ifdef _MSC_VER\n# pragma warning(push)\n# pragma warning(disable:4717)\n#endif\n\n// Invalid<T>() is usable as an expression of type T, but will terminate\n// the program with an assertion failure if actually run.  This is useful\n// when a value of type T is needed for compilation, but the statement\n// will not really be executed (or we don't care if the statement\n// crashes).\ntemplate <typename T>\ninline T Invalid() {\n  Assert(false, \"\", -1, \"Internal error: attempt to return invalid value\");\n  // This statement is unreachable, and would never terminate even if it\n  // could be reached. It is provided only to placate compiler warnings\n  // about missing return statements.\n  return Invalid<T>();\n}\n\n#ifdef _MSC_VER\n# pragma warning(pop)\n#endif\n\n// Given a raw type (i.e. having no top-level reference or const\n// modifier) RawContainer that's either an STL-style container or a\n// native array, class StlContainerView<RawContainer> has the\n// following members:\n//\n//   - type is a type that provides an STL-style container view to\n//     (i.e. implements the STL container concept for) RawContainer;\n//   - const_reference is a type that provides a reference to a const\n//     RawContainer;\n//   - ConstReference(raw_container) returns a const reference to an STL-style\n//     container view to raw_container, which is a RawContainer.\n//   - Copy(raw_container) returns an STL-style container view of a\n//     copy of raw_container, which is a RawContainer.\n//\n// This generic version is used when RawContainer itself is already an\n// STL-style container.\ntemplate <class RawContainer>\nclass StlContainerView {\n public:\n  typedef RawContainer type;\n  typedef const type& const_reference;\n\n  static const_reference ConstReference(const RawContainer& container) {\n    // Ensures that RawContainer is not a const type.\n    testing::StaticAssertTypeEq<RawContainer,\n        GTEST_REMOVE_CONST_(RawContainer)>();\n    return container;\n  }\n  static type Copy(const RawContainer& container) { return container; }\n};\n\n// This specialization is used when RawContainer is a native array type.\ntemplate <typename Element, size_t N>\nclass StlContainerView<Element[N]> {\n public:\n  typedef GTEST_REMOVE_CONST_(Element) RawElement;\n  typedef internal::NativeArray<RawElement> type;\n  // NativeArray<T> can represent a native array either by value or by\n  // reference (selected by a constructor argument), so 'const type'\n  // can be used to reference a const native array.  We cannot\n  // 'typedef const type& const_reference' here, as that would mean\n  // ConstReference() has to return a reference to a local variable.\n  typedef const type const_reference;\n\n  static const_reference ConstReference(const Element (&array)[N]) {\n    // Ensures that Element is not a const type.\n    testing::StaticAssertTypeEq<Element, RawElement>();\n#if GTEST_OS_SYMBIAN\n    // The Nokia Symbian compiler confuses itself in template instantiation\n    // for this call without the cast to Element*:\n    // function call '[testing::internal::NativeArray<char *>].NativeArray(\n    //     {lval} const char *[4], long, testing::internal::RelationToSource)'\n    //     does not match\n    // 'testing::internal::NativeArray<char *>::NativeArray(\n    //     char *const *, unsigned int, testing::internal::RelationToSource)'\n    // (instantiating: 'testing::internal::ContainsMatcherImpl\n    //     <const char * (&)[4]>::Matches(const char * (&)[4]) const')\n    // (instantiating: 'testing::internal::StlContainerView<char *[4]>::\n    //     ConstReference(const char * (&)[4])')\n    // (and though the N parameter type is mismatched in the above explicit\n    // conversion of it doesn't help - only the conversion of the array).\n    return type(const_cast<Element*>(&array[0]), N,\n                RelationToSourceReference());\n#else\n    return type(array, N, RelationToSourceReference());\n#endif  // GTEST_OS_SYMBIAN\n  }\n  static type Copy(const Element (&array)[N]) {\n#if GTEST_OS_SYMBIAN\n    return type(const_cast<Element*>(&array[0]), N, RelationToSourceCopy());\n#else\n    return type(array, N, RelationToSourceCopy());\n#endif  // GTEST_OS_SYMBIAN\n  }\n};\n\n// This specialization is used when RawContainer is a native array\n// represented as a (pointer, size) tuple.\ntemplate <typename ElementPointer, typename Size>\nclass StlContainerView< ::testing::tuple<ElementPointer, Size> > {\n public:\n  typedef GTEST_REMOVE_CONST_(\n      typename internal::PointeeOf<ElementPointer>::type) RawElement;\n  typedef internal::NativeArray<RawElement> type;\n  typedef const type const_reference;\n\n  static const_reference ConstReference(\n      const ::testing::tuple<ElementPointer, Size>& array) {\n    return type(get<0>(array), get<1>(array), RelationToSourceReference());\n  }\n  static type Copy(const ::testing::tuple<ElementPointer, Size>& array) {\n    return type(get<0>(array), get<1>(array), RelationToSourceCopy());\n  }\n};\n\n// The following specialization prevents the user from instantiating\n// StlContainer with a reference type.\ntemplate <typename T> class StlContainerView<T&>;\n\n// A type transform to remove constness from the first part of a pair.\n// Pairs like that are used as the value_type of associative containers,\n// and this transform produces a similar but assignable pair.\ntemplate <typename T>\nstruct RemoveConstFromKey {\n  typedef T type;\n};\n\n// Partially specialized to remove constness from std::pair<const K, V>.\ntemplate <typename K, typename V>\nstruct RemoveConstFromKey<std::pair<const K, V> > {\n  typedef std::pair<K, V> type;\n};\n\n// Mapping from booleans to types. Similar to boost::bool_<kValue> and\n// std::integral_constant<bool, kValue>.\ntemplate <bool kValue>\nstruct BooleanConstant {};\n\n}  // namespace internal\n}  // namespace testing\n\n#endif  // GMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_INTERNAL_UTILS_H_\n\n"}, "46": {"id": 46, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/internal/gmock-port.h", "content": "// Copyright 2008, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: vadimb@google.com (Vadim Berman)\n//\n// Low-level types and utilities for porting Google Mock to various\n// platforms.  All macros ending with _ and symbols defined in an\n// internal namespace are subject to change without notice.  Code\n// outside Google Mock MUST NOT USE THEM DIRECTLY.  Macros that don't\n// end with _ are part of Google Mock's public API and can be used by\n// code outside Google Mock.\n\n// IWYU pragma: private, include \"gmock/gmock.h\"\n\n#ifndef GMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_PORT_H_\n#define GMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_PORT_H_\n\n#include <assert.h>\n#include <stdlib.h>\n#include <iostream>\n\n// Most of the utilities needed for porting Google Mock are also\n// required for Google Test and are defined in gtest-port.h.\n//\n// Note to maintainers: to reduce code duplication, prefer adding\n// portability utilities to Google Test's gtest-port.h instead of\n// here, as Google Mock depends on Google Test.  Only add a utility\n// here if it's truly specific to Google Mock.\n#include \"gtest/internal/gtest-linked_ptr.h\"\n#include \"gtest/internal/gtest-port.h\"\n#include \"gmock/internal/custom/gmock-port.h\"\n\n// To avoid conditional compilation everywhere, we make it\n// gmock-port.h's responsibility to #include the header implementing\n// tr1/tuple.  gmock-port.h does this via gtest-port.h, which is\n// guaranteed to pull in the tuple header.\n\n// For MS Visual C++, check the compiler version. At least VS 2003 is\n// required to compile Google Mock.\n#if defined(_MSC_VER) && _MSC_VER < 1310\n# error \"At least Visual C++ 2003 (7.1) is required to compile Google Mock.\"\n#endif\n\n// Macro for referencing flags.  This is public as we want the user to\n// use this syntax to reference Google Mock flags.\n#define GMOCK_FLAG(name) FLAGS_gmock_##name\n\n#if !defined(GMOCK_DECLARE_bool_)\n\n// Macros for declaring flags.\n#define GMOCK_DECLARE_bool_(name) extern GTEST_API_ bool GMOCK_FLAG(name)\n#define GMOCK_DECLARE_int32_(name) \\\n    extern GTEST_API_ ::testing::internal::Int32 GMOCK_FLAG(name)\n#define GMOCK_DECLARE_string_(name) \\\n    extern GTEST_API_ ::std::string GMOCK_FLAG(name)\n\n// Macros for defining flags.\n#define GMOCK_DEFINE_bool_(name, default_val, doc) \\\n    GTEST_API_ bool GMOCK_FLAG(name) = (default_val)\n#define GMOCK_DEFINE_int32_(name, default_val, doc) \\\n    GTEST_API_ ::testing::internal::Int32 GMOCK_FLAG(name) = (default_val)\n#define GMOCK_DEFINE_string_(name, default_val, doc) \\\n    GTEST_API_ ::std::string GMOCK_FLAG(name) = (default_val)\n\n#endif  // !defined(GMOCK_DECLARE_bool_)\n\n#endif  // GMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_PORT_H_\n"}, "47": {"id": 47, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest-death-test.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n//\n// The Google C++ Testing Framework (Google Test)\n//\n// This header file defines the public API for death tests.  It is\n// #included by gtest.h so a user doesn't need to include this\n// directly.\n\n#ifndef GTEST_INCLUDE_GTEST_GTEST_DEATH_TEST_H_\n#define GTEST_INCLUDE_GTEST_GTEST_DEATH_TEST_H_\n\n#include \"gtest/internal/gtest-death-test-internal.h\"\n\nnamespace testing {\n\n// This flag controls the style of death tests.  Valid values are \"threadsafe\",\n// meaning that the death test child process will re-execute the test binary\n// from the start, running only a single death test, or \"fast\",\n// meaning that the child process will execute the test logic immediately\n// after forking.\nGTEST_DECLARE_string_(death_test_style);\n\n#if GTEST_HAS_DEATH_TEST\n\nnamespace internal {\n\n// Returns a Boolean value indicating whether the caller is currently\n// executing in the context of the death test child process.  Tools such as\n// Valgrind heap checkers may need this to modify their behavior in death\n// tests.  IMPORTANT: This is an internal utility.  Using it may break the\n// implementation of death tests.  User code MUST NOT use it.\nGTEST_API_ bool InDeathTestChild();\n\n}  // namespace internal\n\n// The following macros are useful for writing death tests.\n\n// Here's what happens when an ASSERT_DEATH* or EXPECT_DEATH* is\n// executed:\n//\n//   1. It generates a warning if there is more than one active\n//   thread.  This is because it's safe to fork() or clone() only\n//   when there is a single thread.\n//\n//   2. The parent process clone()s a sub-process and runs the death\n//   test in it; the sub-process exits with code 0 at the end of the\n//   death test, if it hasn't exited already.\n//\n//   3. The parent process waits for the sub-process to terminate.\n//\n//   4. The parent process checks the exit code and error message of\n//   the sub-process.\n//\n// Examples:\n//\n//   ASSERT_DEATH(server.SendMessage(56, \"Hello\"), \"Invalid port number\");\n//   for (int i = 0; i < 5; i++) {\n//     EXPECT_DEATH(server.ProcessRequest(i),\n//                  \"Invalid request .* in ProcessRequest()\")\n//                  << \"Failed to die on request \" << i;\n//   }\n//\n//   ASSERT_EXIT(server.ExitNow(), ::testing::ExitedWithCode(0), \"Exiting\");\n//\n//   bool KilledBySIGHUP(int exit_code) {\n//     return WIFSIGNALED(exit_code) && WTERMSIG(exit_code) == SIGHUP;\n//   }\n//\n//   ASSERT_EXIT(client.HangUpServer(), KilledBySIGHUP, \"Hanging up!\");\n//\n// On the regular expressions used in death tests:\n//\n//   On POSIX-compliant systems (*nix), we use the <regex.h> library,\n//   which uses the POSIX extended regex syntax.\n//\n//   On other platforms (e.g. Windows), we only support a simple regex\n//   syntax implemented as part of Google Test.  This limited\n//   implementation should be enough most of the time when writing\n//   death tests; though it lacks many features you can find in PCRE\n//   or POSIX extended regex syntax.  For example, we don't support\n//   union (\"x|y\"), grouping (\"(xy)\"), brackets (\"[xy]\"), and\n//   repetition count (\"x{5,7}\"), among others.\n//\n//   Below is the syntax that we do support.  We chose it to be a\n//   subset of both PCRE and POSIX extended regex, so it's easy to\n//   learn wherever you come from.  In the following: 'A' denotes a\n//   literal character, period (.), or a single \\\\ escape sequence;\n//   'x' and 'y' denote regular expressions; 'm' and 'n' are for\n//   natural numbers.\n//\n//     c     matches any literal character c\n//     \\\\d   matches any decimal digit\n//     \\\\D   matches any character that's not a decimal digit\n//     \\\\f   matches \\f\n//     \\\\n   matches \\n\n//     \\\\r   matches \\r\n//     \\\\s   matches any ASCII whitespace, including \\n\n//     \\\\S   matches any character that's not a whitespace\n//     \\\\t   matches \\t\n//     \\\\v   matches \\v\n//     \\\\w   matches any letter, _, or decimal digit\n//     \\\\W   matches any character that \\\\w doesn't match\n//     \\\\c   matches any literal character c, which must be a punctuation\n//     .     matches any single character except \\n\n//     A?    matches 0 or 1 occurrences of A\n//     A*    matches 0 or many occurrences of A\n//     A+    matches 1 or many occurrences of A\n//     ^     matches the beginning of a string (not that of each line)\n//     $     matches the end of a string (not that of each line)\n//     xy    matches x followed by y\n//\n//   If you accidentally use PCRE or POSIX extended regex features\n//   not implemented by us, you will get a run-time failure.  In that\n//   case, please try to rewrite your regular expression within the\n//   above syntax.\n//\n//   This implementation is *not* meant to be as highly tuned or robust\n//   as a compiled regex library, but should perform well enough for a\n//   death test, which already incurs significant overhead by launching\n//   a child process.\n//\n// Known caveats:\n//\n//   A \"threadsafe\" style death test obtains the path to the test\n//   program from argv[0] and re-executes it in the sub-process.  For\n//   simplicity, the current implementation doesn't search the PATH\n//   when launching the sub-process.  This means that the user must\n//   invoke the test program via a path that contains at least one\n//   path separator (e.g. path/to/foo_test and\n//   /absolute/path/to/bar_test are fine, but foo_test is not).  This\n//   is rarely a problem as people usually don't put the test binary\n//   directory in PATH.\n//\n// TODO(wan@google.com): make thread-safe death tests search the PATH.\n\n// Asserts that a given statement causes the program to exit, with an\n// integer exit status that satisfies predicate, and emitting error output\n// that matches regex.\n# define ASSERT_EXIT(statement, predicate, regex) \\\n    GTEST_DEATH_TEST_(statement, predicate, regex, GTEST_FATAL_FAILURE_)\n\n// Like ASSERT_EXIT, but continues on to successive tests in the\n// test case, if any:\n# define EXPECT_EXIT(statement, predicate, regex) \\\n    GTEST_DEATH_TEST_(statement, predicate, regex, GTEST_NONFATAL_FAILURE_)\n\n// Asserts that a given statement causes the program to exit, either by\n// explicitly exiting with a nonzero exit code or being killed by a\n// signal, and emitting error output that matches regex.\n# define ASSERT_DEATH(statement, regex) \\\n    ASSERT_EXIT(statement, ::testing::internal::ExitedUnsuccessfully, regex)\n\n// Like ASSERT_DEATH, but continues on to successive tests in the\n// test case, if any:\n# define EXPECT_DEATH(statement, regex) \\\n    EXPECT_EXIT(statement, ::testing::internal::ExitedUnsuccessfully, regex)\n\n// Two predicate classes that can be used in {ASSERT,EXPECT}_EXIT*:\n\n// Tests that an exit code describes a normal exit with a given exit code.\nclass GTEST_API_ ExitedWithCode {\n public:\n  explicit ExitedWithCode(int exit_code);\n  bool operator()(int exit_status) const;\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ExitedWithCode& other);\n\n  const int exit_code_;\n};\n\n# if !GTEST_OS_WINDOWS\n// Tests that an exit code describes an exit due to termination by a\n// given signal.\nclass GTEST_API_ KilledBySignal {\n public:\n  explicit KilledBySignal(int signum);\n  bool operator()(int exit_status) const;\n private:\n  const int signum_;\n};\n# endif  // !GTEST_OS_WINDOWS\n\n// EXPECT_DEBUG_DEATH asserts that the given statements die in debug mode.\n// The death testing framework causes this to have interesting semantics,\n// since the sideeffects of the call are only visible in opt mode, and not\n// in debug mode.\n//\n// In practice, this can be used to test functions that utilize the\n// LOG(DFATAL) macro using the following style:\n//\n// int DieInDebugOr12(int* sideeffect) {\n//   if (sideeffect) {\n//     *sideeffect = 12;\n//   }\n//   LOG(DFATAL) << \"death\";\n//   return 12;\n// }\n//\n// TEST(TestCase, TestDieOr12WorksInDgbAndOpt) {\n//   int sideeffect = 0;\n//   // Only asserts in dbg.\n//   EXPECT_DEBUG_DEATH(DieInDebugOr12(&sideeffect), \"death\");\n//\n// #ifdef NDEBUG\n//   // opt-mode has sideeffect visible.\n//   EXPECT_EQ(12, sideeffect);\n// #else\n//   // dbg-mode no visible sideeffect.\n//   EXPECT_EQ(0, sideeffect);\n// #endif\n// }\n//\n// This will assert that DieInDebugReturn12InOpt() crashes in debug\n// mode, usually due to a DCHECK or LOG(DFATAL), but returns the\n// appropriate fallback value (12 in this case) in opt mode. If you\n// need to test that a function has appropriate side-effects in opt\n// mode, include assertions against the side-effects.  A general\n// pattern for this is:\n//\n// EXPECT_DEBUG_DEATH({\n//   // Side-effects here will have an effect after this statement in\n//   // opt mode, but none in debug mode.\n//   EXPECT_EQ(12, DieInDebugOr12(&sideeffect));\n// }, \"death\");\n//\n# ifdef NDEBUG\n\n#  define EXPECT_DEBUG_DEATH(statement, regex) \\\n  GTEST_EXECUTE_STATEMENT_(statement, regex)\n\n#  define ASSERT_DEBUG_DEATH(statement, regex) \\\n  GTEST_EXECUTE_STATEMENT_(statement, regex)\n\n# else\n\n#  define EXPECT_DEBUG_DEATH(statement, regex) \\\n  EXPECT_DEATH(statement, regex)\n\n#  define ASSERT_DEBUG_DEATH(statement, regex) \\\n  ASSERT_DEATH(statement, regex)\n\n# endif  // NDEBUG for EXPECT_DEBUG_DEATH\n#endif  // GTEST_HAS_DEATH_TEST\n\n// EXPECT_DEATH_IF_SUPPORTED(statement, regex) and\n// ASSERT_DEATH_IF_SUPPORTED(statement, regex) expand to real death tests if\n// death tests are supported; otherwise they just issue a warning.  This is\n// useful when you are combining death test assertions with normal test\n// assertions in one test.\n#if GTEST_HAS_DEATH_TEST\n# define EXPECT_DEATH_IF_SUPPORTED(statement, regex) \\\n    EXPECT_DEATH(statement, regex)\n# define ASSERT_DEATH_IF_SUPPORTED(statement, regex) \\\n    ASSERT_DEATH(statement, regex)\n#else\n# define EXPECT_DEATH_IF_SUPPORTED(statement, regex) \\\n    GTEST_UNSUPPORTED_DEATH_TEST_(statement, regex, )\n# define ASSERT_DEATH_IF_SUPPORTED(statement, regex) \\\n    GTEST_UNSUPPORTED_DEATH_TEST_(statement, regex, return)\n#endif\n\n}  // namespace testing\n\n#endif  // GTEST_INCLUDE_GTEST_GTEST_DEATH_TEST_H_\n"}, "48": {"id": 48, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest-message.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n//\n// The Google C++ Testing Framework (Google Test)\n//\n// This header file defines the Message class.\n//\n// IMPORTANT NOTE: Due to limitation of the C++ language, we have to\n// leave some internal implementation details in this header file.\n// They are clearly marked by comments like this:\n//\n//   // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n//\n// Such code is NOT meant to be used by a user directly, and is subject\n// to CHANGE WITHOUT NOTICE.  Therefore DO NOT DEPEND ON IT in a user\n// program!\n\n#ifndef GTEST_INCLUDE_GTEST_GTEST_MESSAGE_H_\n#define GTEST_INCLUDE_GTEST_GTEST_MESSAGE_H_\n\n#include <limits>\n\n#include \"gtest/internal/gtest-port.h\"\n#include \"gtest/internal/custom/raw-ostream.h\"\n\n// Ensures that there is at least one operator<< in the global namespace.\n// See Message& operator<<(...) below for why.\nvoid operator<<(const testing::internal::Secret&, int);\n\nnamespace testing {\n\n// The Message class works like an ostream repeater.\n//\n// Typical usage:\n//\n//   1. You stream a bunch of values to a Message object.\n//      It will remember the text in a stringstream.\n//   2. Then you stream the Message object to an ostream.\n//      This causes the text in the Message to be streamed\n//      to the ostream.\n//\n// For example;\n//\n//   testing::Message foo;\n//   foo << 1 << \" != \" << 2;\n//   std::cout << foo;\n//\n// will print \"1 != 2\".\n//\n// Message is not intended to be inherited from.  In particular, its\n// destructor is not virtual.\n//\n// Note that stringstream behaves differently in gcc and in MSVC.  You\n// can stream a NULL char pointer to it in the former, but not in the\n// latter (it causes an access violation if you do).  The Message\n// class hides this difference by treating a NULL char pointer as\n// \"(null)\".\nclass GTEST_API_ Message {\n private:\n  // The type of basic IO manipulators (endl, ends, and flush) for\n  // narrow streams.\n  typedef std::ostream& (*BasicNarrowIoManip)(std::ostream&);\n\n public:\n  // Constructs an empty Message.\n  Message();\n\n  // Copy constructor.\n  Message(const Message& msg) : ss_(new ::std::stringstream) {  // NOLINT\n    *ss_ << msg.GetString();\n  }\n\n  // Constructs a Message from a C-string.\n  explicit Message(const char* str) : ss_(new ::std::stringstream) {\n    *ss_ << str;\n  }\n\n#if GTEST_OS_SYMBIAN\n  // Streams a value (either a pointer or not) to this object.\n  template <typename T>\n  inline Message& operator <<(const T& value) {\n    StreamHelper(typename internal::is_pointer<T>::type(), value);\n    return *this;\n  }\n#else\n  // Streams a non-pointer value to this object.\n  template <typename T>\n  inline Message& operator <<(const T& val) {\n    // Some libraries overload << for STL containers.  These\n    // overloads are defined in the global namespace instead of ::std.\n    //\n    // C++'s symbol lookup rule (i.e. Koenig lookup) says that these\n    // overloads are visible in either the std namespace or the global\n    // namespace, but not other namespaces, including the testing\n    // namespace which Google Test's Message class is in.\n    //\n    // To allow STL containers (and other types that has a << operator\n    // defined in the global namespace) to be used in Google Test\n    // assertions, testing::Message must access the custom << operator\n    // from the global namespace.  With this using declaration,\n    // overloads of << defined in the global namespace and those\n    // visible via Koenig lookup are both exposed in this function.\n    using ::operator <<;\n    *ss_ << llvm_gtest::printable(val);\n    return *this;\n  }\n\n  // Streams a pointer value to this object.\n  //\n  // This function is an overload of the previous one.  When you\n  // stream a pointer to a Message, this definition will be used as it\n  // is more specialized.  (The C++ Standard, section\n  // [temp.func.order].)  If you stream a non-pointer, then the\n  // previous definition will be used.\n  //\n  // The reason for this overload is that streaming a NULL pointer to\n  // ostream is undefined behavior.  Depending on the compiler, you\n  // may get \"0\", \"(nil)\", \"(null)\", or an access violation.  To\n  // ensure consistent result across compilers, we always treat NULL\n  // as \"(null)\".\n  template <typename T>\n  inline Message& operator <<(T* const& pointer) {  // NOLINT\n    if (pointer == NULL) {\n      *ss_ << \"(null)\";\n    } else {\n      *ss_ << llvm_gtest::printable(pointer);\n    }\n    return *this;\n  }\n#endif  // GTEST_OS_SYMBIAN\n\n  // Since the basic IO manipulators are overloaded for both narrow\n  // and wide streams, we have to provide this specialized definition\n  // of operator <<, even though its body is the same as the\n  // templatized version above.  Without this definition, streaming\n  // endl or other basic IO manipulators to Message will confuse the\n  // compiler.\n  Message& operator <<(BasicNarrowIoManip val) {\n    *ss_ << val;\n    return *this;\n  }\n\n  // Instead of 1/0, we want to see true/false for bool values.\n  Message& operator <<(bool b) {\n    return *this << (b ? \"true\" : \"false\");\n  }\n\n  // These two overloads allow streaming a wide C string to a Message\n  // using the UTF-8 encoding.\n  Message& operator <<(const wchar_t* wide_c_str);\n  Message& operator <<(wchar_t* wide_c_str);\n\n#if GTEST_HAS_STD_WSTRING\n  // Converts the given wide string to a narrow string using the UTF-8\n  // encoding, and streams the result to this Message object.\n  Message& operator <<(const ::std::wstring& wstr);\n#endif  // GTEST_HAS_STD_WSTRING\n\n#if GTEST_HAS_GLOBAL_WSTRING\n  // Converts the given wide string to a narrow string using the UTF-8\n  // encoding, and streams the result to this Message object.\n  Message& operator <<(const ::wstring& wstr);\n#endif  // GTEST_HAS_GLOBAL_WSTRING\n\n  // Gets the text streamed to this object so far as an std::string.\n  // Each '\\0' character in the buffer is replaced with \"\\\\0\".\n  //\n  // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n  std::string GetString() const;\n\n private:\n\n#if GTEST_OS_SYMBIAN\n  // These are needed as the Nokia Symbian Compiler cannot decide between\n  // const T& and const T* in a function template. The Nokia compiler _can_\n  // decide between class template specializations for T and T*, so a\n  // tr1::type_traits-like is_pointer works, and we can overload on that.\n  template <typename T>\n  inline void StreamHelper(internal::true_type /*is_pointer*/, T* pointer) {\n    if (pointer == NULL) {\n      *ss_ << \"(null)\";\n    } else {\n      *ss_ << pointer;\n    }\n  }\n  template <typename T>\n  inline void StreamHelper(internal::false_type /*is_pointer*/,\n                           const T& value) {\n    // See the comments in Message& operator <<(const T&) above for why\n    // we need this using statement.\n    using ::operator <<;\n    *ss_ << value;\n  }\n#endif  // GTEST_OS_SYMBIAN\n\n  // We'll hold the text streamed to this object here.\n  const internal::scoped_ptr< ::std::stringstream> ss_;\n\n  // We declare (but don't implement) this to prevent the compiler\n  // from implementing the assignment operator.\n  void operator=(const Message&);\n};\n\n// Streams a Message to an ostream.\ninline std::ostream& operator <<(std::ostream& os, const Message& sb) {\n  return os << sb.GetString();\n}\n\nnamespace internal {\n\n// Converts a streamable value to an std::string.  A NULL pointer is\n// converted to \"(null)\".  When the input value is a ::string,\n// ::std::string, ::wstring, or ::std::wstring object, each NUL\n// character in it is replaced with \"\\\\0\".\ntemplate <typename T>\nstd::string StreamableToString(const T& streamable) {\n  return (Message() << streamable).GetString();\n}\n\n}  // namespace internal\n}  // namespace testing\n\n#endif  // GTEST_INCLUDE_GTEST_GTEST_MESSAGE_H_\n"}, "49": {"id": 49, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest-param-test.h", "content": "// This file was GENERATED by command:\n//     pump.py gtest-param-test.h.pump\n// DO NOT EDIT BY HAND!!!\n\n// Copyright 2008, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Authors: vladl@google.com (Vlad Losev)\n//\n// Macros and functions for implementing parameterized tests\n// in Google C++ Testing Framework (Google Test)\n//\n// This file is generated by a SCRIPT.  DO NOT EDIT BY HAND!\n//\n#ifndef GTEST_INCLUDE_GTEST_GTEST_PARAM_TEST_H_\n#define GTEST_INCLUDE_GTEST_GTEST_PARAM_TEST_H_\n\n\n// Value-parameterized tests allow you to test your code with different\n// parameters without writing multiple copies of the same test.\n//\n// Here is how you use value-parameterized tests:\n\n#if 0\n\n// To write value-parameterized tests, first you should define a fixture\n// class. It is usually derived from testing::TestWithParam<T> (see below for\n// another inheritance scheme that's sometimes useful in more complicated\n// class hierarchies), where the type of your parameter values.\n// TestWithParam<T> is itself derived from testing::Test. T can be any\n// copyable type. If it's a raw pointer, you are responsible for managing the\n// lifespan of the pointed values.\n\nclass FooTest : public ::testing::TestWithParam<const char*> {\n  // You can implement all the usual class fixture members here.\n};\n\n// Then, use the TEST_P macro to define as many parameterized tests\n// for this fixture as you want. The _P suffix is for \"parameterized\"\n// or \"pattern\", whichever you prefer to think.\n\nTEST_P(FooTest, DoesBlah) {\n  // Inside a test, access the test parameter with the GetParam() method\n  // of the TestWithParam<T> class:\n  EXPECT_TRUE(foo.Blah(GetParam()));\n  ...\n}\n\nTEST_P(FooTest, HasBlahBlah) {\n  ...\n}\n\n// Finally, you can use INSTANTIATE_TEST_CASE_P to instantiate the test\n// case with any set of parameters you want. Google Test defines a number\n// of functions for generating test parameters. They return what we call\n// (surprise!) parameter generators. Here is a  summary of them, which\n// are all in the testing namespace:\n//\n//\n//  Range(begin, end [, step]) - Yields values {begin, begin+step,\n//                               begin+step+step, ...}. The values do not\n//                               include end. step defaults to 1.\n//  Values(v1, v2, ..., vN)    - Yields values {v1, v2, ..., vN}.\n//  ValuesIn(container)        - Yields values from a C-style array, an STL\n//  ValuesIn(begin,end)          container, or an iterator range [begin, end).\n//  Bool()                     - Yields sequence {false, true}.\n//  Combine(g1, g2, ..., gN)   - Yields all combinations (the Cartesian product\n//                               for the math savvy) of the values generated\n//                               by the N generators.\n//\n// For more details, see comments at the definitions of these functions below\n// in this file.\n//\n// The following statement will instantiate tests from the FooTest test case\n// each with parameter values \"meeny\", \"miny\", and \"moe\".\n\nINSTANTIATE_TEST_CASE_P(InstantiationName,\n                        FooTest,\n                        Values(\"meeny\", \"miny\", \"moe\"));\n\n// To distinguish different instances of the pattern, (yes, you\n// can instantiate it more then once) the first argument to the\n// INSTANTIATE_TEST_CASE_P macro is a prefix that will be added to the\n// actual test case name. Remember to pick unique prefixes for different\n// instantiations. The tests from the instantiation above will have\n// these names:\n//\n//    * InstantiationName/FooTest.DoesBlah/0 for \"meeny\"\n//    * InstantiationName/FooTest.DoesBlah/1 for \"miny\"\n//    * InstantiationName/FooTest.DoesBlah/2 for \"moe\"\n//    * InstantiationName/FooTest.HasBlahBlah/0 for \"meeny\"\n//    * InstantiationName/FooTest.HasBlahBlah/1 for \"miny\"\n//    * InstantiationName/FooTest.HasBlahBlah/2 for \"moe\"\n//\n// You can use these names in --gtest_filter.\n//\n// This statement will instantiate all tests from FooTest again, each\n// with parameter values \"cat\" and \"dog\":\n\nconst char* pets[] = {\"cat\", \"dog\"};\nINSTANTIATE_TEST_CASE_P(AnotherInstantiationName, FooTest, ValuesIn(pets));\n\n// The tests from the instantiation above will have these names:\n//\n//    * AnotherInstantiationName/FooTest.DoesBlah/0 for \"cat\"\n//    * AnotherInstantiationName/FooTest.DoesBlah/1 for \"dog\"\n//    * AnotherInstantiationName/FooTest.HasBlahBlah/0 for \"cat\"\n//    * AnotherInstantiationName/FooTest.HasBlahBlah/1 for \"dog\"\n//\n// Please note that INSTANTIATE_TEST_CASE_P will instantiate all tests\n// in the given test case, whether their definitions come before or\n// AFTER the INSTANTIATE_TEST_CASE_P statement.\n//\n// Please also note that generator expressions (including parameters to the\n// generators) are evaluated in InitGoogleTest(), after main() has started.\n// This allows the user on one hand, to adjust generator parameters in order\n// to dynamically determine a set of tests to run and on the other hand,\n// give the user a chance to inspect the generated tests with Google Test\n// reflection API before RUN_ALL_TESTS() is executed.\n//\n// You can see samples/sample7_unittest.cc and samples/sample8_unittest.cc\n// for more examples.\n//\n// In the future, we plan to publish the API for defining new parameter\n// generators. But for now this interface remains part of the internal\n// implementation and is subject to change.\n//\n//\n// A parameterized test fixture must be derived from testing::Test and from\n// testing::WithParamInterface<T>, where T is the type of the parameter\n// values. Inheriting from TestWithParam<T> satisfies that requirement because\n// TestWithParam<T> inherits from both Test and WithParamInterface. In more\n// complicated hierarchies, however, it is occasionally useful to inherit\n// separately from Test and WithParamInterface. For example:\n\nclass BaseTest : public ::testing::Test {\n  // You can inherit all the usual members for a non-parameterized test\n  // fixture here.\n};\n\nclass DerivedTest : public BaseTest, public ::testing::WithParamInterface<int> {\n  // The usual test fixture members go here too.\n};\n\nTEST_F(BaseTest, HasFoo) {\n  // This is an ordinary non-parameterized test.\n}\n\nTEST_P(DerivedTest, DoesBlah) {\n  // GetParam works just the same here as if you inherit from TestWithParam.\n  EXPECT_TRUE(foo.Blah(GetParam()));\n}\n\n#endif  // 0\n\n#include \"gtest/internal/gtest-port.h\"\n\n#if !GTEST_OS_SYMBIAN\n# include <utility>\n#endif\n\n// scripts/fuse_gtest.py depends on gtest's own header being #included\n// *unconditionally*.  Therefore these #includes cannot be moved\n// inside #if GTEST_HAS_PARAM_TEST.\n#include \"gtest/internal/gtest-internal.h\"\n#include \"gtest/internal/gtest-param-util.h\"\n#include \"gtest/internal/gtest-param-util-generated.h\"\n\n#if GTEST_HAS_PARAM_TEST\n\nnamespace testing {\n\n// Functions producing parameter generators.\n//\n// Google Test uses these generators to produce parameters for value-\n// parameterized tests. When a parameterized test case is instantiated\n// with a particular generator, Google Test creates and runs tests\n// for each element in the sequence produced by the generator.\n//\n// In the following sample, tests from test case FooTest are instantiated\n// each three times with parameter values 3, 5, and 8:\n//\n// class FooTest : public TestWithParam<int> { ... };\n//\n// TEST_P(FooTest, TestThis) {\n// }\n// TEST_P(FooTest, TestThat) {\n// }\n// INSTANTIATE_TEST_CASE_P(TestSequence, FooTest, Values(3, 5, 8));\n//\n\n// Range() returns generators providing sequences of values in a range.\n//\n// Synopsis:\n// Range(start, end)\n//   - returns a generator producing a sequence of values {start, start+1,\n//     start+2, ..., }.\n// Range(start, end, step)\n//   - returns a generator producing a sequence of values {start, start+step,\n//     start+step+step, ..., }.\n// Notes:\n//   * The generated sequences never include end. For example, Range(1, 5)\n//     returns a generator producing a sequence {1, 2, 3, 4}. Range(1, 9, 2)\n//     returns a generator producing {1, 3, 5, 7}.\n//   * start and end must have the same type. That type may be any integral or\n//     floating-point type or a user defined type satisfying these conditions:\n//     * It must be assignable (have operator=() defined).\n//     * It must have operator+() (operator+(int-compatible type) for\n//       two-operand version).\n//     * It must have operator<() defined.\n//     Elements in the resulting sequences will also have that type.\n//   * Condition start < end must be satisfied in order for resulting sequences\n//     to contain any elements.\n//\ntemplate <typename T, typename IncrementT>\ninternal::ParamGenerator<T> Range(T start, T end, IncrementT step) {\n  return internal::ParamGenerator<T>(\n      new internal::RangeGenerator<T, IncrementT>(start, end, step));\n}\n\ntemplate <typename T>\ninternal::ParamGenerator<T> Range(T start, T end) {\n  return Range(start, end, 1);\n}\n\n// ValuesIn() function allows generation of tests with parameters coming from\n// a container.\n//\n// Synopsis:\n// ValuesIn(const T (&array)[N])\n//   - returns a generator producing sequences with elements from\n//     a C-style array.\n// ValuesIn(const Container& container)\n//   - returns a generator producing sequences with elements from\n//     an STL-style container.\n// ValuesIn(Iterator begin, Iterator end)\n//   - returns a generator producing sequences with elements from\n//     a range [begin, end) defined by a pair of STL-style iterators. These\n//     iterators can also be plain C pointers.\n//\n// Please note that ValuesIn copies the values from the containers\n// passed in and keeps them to generate tests in RUN_ALL_TESTS().\n//\n// Examples:\n//\n// This instantiates tests from test case StringTest\n// each with C-string values of \"foo\", \"bar\", and \"baz\":\n//\n// const char* strings[] = {\"foo\", \"bar\", \"baz\"};\n// INSTANTIATE_TEST_CASE_P(StringSequence, SrtingTest, ValuesIn(strings));\n//\n// This instantiates tests from test case StlStringTest\n// each with STL strings with values \"a\" and \"b\":\n//\n// ::std::vector< ::std::string> GetParameterStrings() {\n//   ::std::vector< ::std::string> v;\n//   v.push_back(\"a\");\n//   v.push_back(\"b\");\n//   return v;\n// }\n//\n// INSTANTIATE_TEST_CASE_P(CharSequence,\n//                         StlStringTest,\n//                         ValuesIn(GetParameterStrings()));\n//\n//\n// This will also instantiate tests from CharTest\n// each with parameter values 'a' and 'b':\n//\n// ::std::list<char> GetParameterChars() {\n//   ::std::list<char> list;\n//   list.push_back('a');\n//   list.push_back('b');\n//   return list;\n// }\n// ::std::list<char> l = GetParameterChars();\n// INSTANTIATE_TEST_CASE_P(CharSequence2,\n//                         CharTest,\n//                         ValuesIn(l.begin(), l.end()));\n//\ntemplate <typename ForwardIterator>\ninternal::ParamGenerator<\n  typename ::testing::internal::IteratorTraits<ForwardIterator>::value_type>\nValuesIn(ForwardIterator begin, ForwardIterator end) {\n  typedef typename ::testing::internal::IteratorTraits<ForwardIterator>\n      ::value_type ParamType;\n  return internal::ParamGenerator<ParamType>(\n      new internal::ValuesInIteratorRangeGenerator<ParamType>(begin, end));\n}\n\ntemplate <typename T, size_t N>\ninternal::ParamGenerator<T> ValuesIn(const T (&array)[N]) {\n  return ValuesIn(array, array + N);\n}\n\ntemplate <class Container>\ninternal::ParamGenerator<typename Container::value_type> ValuesIn(\n    const Container& container) {\n  return ValuesIn(container.begin(), container.end());\n}\n\n// Values() allows generating tests from explicitly specified list of\n// parameters.\n//\n// Synopsis:\n// Values(T v1, T v2, ..., T vN)\n//   - returns a generator producing sequences with elements v1, v2, ..., vN.\n//\n// For example, this instantiates tests from test case BarTest each\n// with values \"one\", \"two\", and \"three\":\n//\n// INSTANTIATE_TEST_CASE_P(NumSequence, BarTest, Values(\"one\", \"two\", \"three\"));\n//\n// This instantiates tests from test case BazTest each with values 1, 2, 3.5.\n// The exact type of values will depend on the type of parameter in BazTest.\n//\n// INSTANTIATE_TEST_CASE_P(FloatingNumbers, BazTest, Values(1, 2, 3.5));\n//\n// Currently, Values() supports from 1 to 50 parameters.\n//\ntemplate <typename T1>\ninternal::ValueArray1<T1> Values(T1 v1) {\n  return internal::ValueArray1<T1>(v1);\n}\n\ntemplate <typename T1, typename T2>\ninternal::ValueArray2<T1, T2> Values(T1 v1, T2 v2) {\n  return internal::ValueArray2<T1, T2>(v1, v2);\n}\n\ntemplate <typename T1, typename T2, typename T3>\ninternal::ValueArray3<T1, T2, T3> Values(T1 v1, T2 v2, T3 v3) {\n  return internal::ValueArray3<T1, T2, T3>(v1, v2, v3);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4>\ninternal::ValueArray4<T1, T2, T3, T4> Values(T1 v1, T2 v2, T3 v3, T4 v4) {\n  return internal::ValueArray4<T1, T2, T3, T4>(v1, v2, v3, v4);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5>\ninternal::ValueArray5<T1, T2, T3, T4, T5> Values(T1 v1, T2 v2, T3 v3, T4 v4,\n    T5 v5) {\n  return internal::ValueArray5<T1, T2, T3, T4, T5>(v1, v2, v3, v4, v5);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6>\ninternal::ValueArray6<T1, T2, T3, T4, T5, T6> Values(T1 v1, T2 v2, T3 v3,\n    T4 v4, T5 v5, T6 v6) {\n  return internal::ValueArray6<T1, T2, T3, T4, T5, T6>(v1, v2, v3, v4, v5, v6);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7>\ninternal::ValueArray7<T1, T2, T3, T4, T5, T6, T7> Values(T1 v1, T2 v2, T3 v3,\n    T4 v4, T5 v5, T6 v6, T7 v7) {\n  return internal::ValueArray7<T1, T2, T3, T4, T5, T6, T7>(v1, v2, v3, v4, v5,\n      v6, v7);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8>\ninternal::ValueArray8<T1, T2, T3, T4, T5, T6, T7, T8> Values(T1 v1, T2 v2,\n    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8) {\n  return internal::ValueArray8<T1, T2, T3, T4, T5, T6, T7, T8>(v1, v2, v3, v4,\n      v5, v6, v7, v8);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9>\ninternal::ValueArray9<T1, T2, T3, T4, T5, T6, T7, T8, T9> Values(T1 v1, T2 v2,\n    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9) {\n  return internal::ValueArray9<T1, T2, T3, T4, T5, T6, T7, T8, T9>(v1, v2, v3,\n      v4, v5, v6, v7, v8, v9);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10>\ninternal::ValueArray10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> Values(T1 v1,\n    T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10) {\n  return internal::ValueArray10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(v1,\n      v2, v3, v4, v5, v6, v7, v8, v9, v10);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11>\ninternal::ValueArray11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10,\n    T11> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11) {\n  return internal::ValueArray11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10,\n      T11>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12>\ninternal::ValueArray12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n    T12> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12) {\n  return internal::ValueArray12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13>\ninternal::ValueArray13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n    T13> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13) {\n  return internal::ValueArray13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14>\ninternal::ValueArray14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14) {\n  return internal::ValueArray14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,\n      v14);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15>\ninternal::ValueArray15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8,\n    T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15) {\n  return internal::ValueArray15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\n      v13, v14, v15);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16>\ninternal::ValueArray16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,\n    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16) {\n  return internal::ValueArray16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\n      v12, v13, v14, v15, v16);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17>\ninternal::ValueArray17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,\n    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16, T17 v17) {\n  return internal::ValueArray17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10,\n      v11, v12, v13, v14, v15, v16, v17);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18>\ninternal::ValueArray18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6,\n    T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16, T17 v17, T18 v18) {\n  return internal::ValueArray18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18>(v1, v2, v3, v4, v5, v6, v7, v8, v9,\n      v10, v11, v12, v13, v14, v15, v16, v17, v18);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19>\ninternal::ValueArray19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5,\n    T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14,\n    T15 v15, T16 v16, T17 v17, T18 v18, T19 v19) {\n  return internal::ValueArray19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19>(v1, v2, v3, v4, v5, v6, v7, v8,\n      v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20>\ninternal::ValueArray20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20> Values(T1 v1, T2 v2, T3 v3, T4 v4,\n    T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13,\n    T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20) {\n  return internal::ValueArray20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20>(v1, v2, v3, v4, v5, v6, v7,\n      v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21>\ninternal::ValueArray21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21> Values(T1 v1, T2 v2, T3 v3, T4 v4,\n    T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13,\n    T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21) {\n  return internal::ValueArray21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>(v1, v2, v3, v4, v5, v6,\n      v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22>\ninternal::ValueArray22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22> Values(T1 v1, T2 v2, T3 v3,\n    T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,\n    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,\n    T21 v21, T22 v22) {\n  return internal::ValueArray22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>(v1, v2, v3, v4,\n      v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,\n      v20, v21, v22);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23>\ninternal::ValueArray23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> Values(T1 v1, T2 v2,\n    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,\n    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,\n    T21 v21, T22 v22, T23 v23) {\n  return internal::ValueArray23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23>(v1, v2, v3,\n      v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,\n      v20, v21, v22, v23);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24>\ninternal::ValueArray24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> Values(T1 v1, T2 v2,\n    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,\n    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,\n    T21 v21, T22 v22, T23 v23, T24 v24) {\n  return internal::ValueArray24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24>(v1, v2,\n      v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18,\n      v19, v20, v21, v22, v23, v24);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25>\ninternal::ValueArray25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> Values(T1 v1,\n    T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11,\n    T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19,\n    T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25) {\n  return internal::ValueArray25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25>(v1,\n      v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17,\n      v18, v19, v20, v21, v22, v23, v24, v25);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26>\ninternal::ValueArray26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n    T26> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n    T26 v26) {\n  return internal::ValueArray26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15,\n      v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27>\ninternal::ValueArray27<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n    T27> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n    T26 v26, T27 v27) {\n  return internal::ValueArray27<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,\n      v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28>\ninternal::ValueArray28<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n    T28> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n    T26 v26, T27 v27, T28 v28) {\n  return internal::ValueArray28<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,\n      v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27,\n      v28);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29>\ninternal::ValueArray29<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n    T26 v26, T27 v27, T28 v28, T29 v29) {\n  return internal::ValueArray29<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\n      v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26,\n      v27, v28, v29);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30>\ninternal::ValueArray30<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8,\n    T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16,\n    T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24,\n    T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30) {\n  return internal::ValueArray30<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\n      v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25,\n      v26, v27, v28, v29, v30);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31>\ninternal::ValueArray31<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,\n    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,\n    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31) {\n  return internal::ValueArray31<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10,\n      v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24,\n      v25, v26, v27, v28, v29, v30, v31);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32>\ninternal::ValueArray32<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,\n    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,\n    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31,\n    T32 v32) {\n  return internal::ValueArray32<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32>(v1, v2, v3, v4, v5, v6, v7, v8, v9,\n      v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23,\n      v24, v25, v26, v27, v28, v29, v30, v31, v32);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33>\ninternal::ValueArray33<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6,\n    T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,\n    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31,\n    T32 v32, T33 v33) {\n  return internal::ValueArray33<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33>(v1, v2, v3, v4, v5, v6, v7, v8,\n      v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23,\n      v24, v25, v26, v27, v28, v29, v30, v31, v32, v33);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34>\ninternal::ValueArray34<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5,\n    T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14,\n    T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22,\n    T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30,\n    T31 v31, T32 v32, T33 v33, T34 v34) {\n  return internal::ValueArray34<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34>(v1, v2, v3, v4, v5, v6, v7,\n      v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\n      v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35>\ninternal::ValueArray35<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35> Values(T1 v1, T2 v2, T3 v3, T4 v4,\n    T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13,\n    T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21,\n    T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29,\n    T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35) {\n  return internal::ValueArray35<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35>(v1, v2, v3, v4, v5, v6,\n      v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,\n      v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36>\ninternal::ValueArray36<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36> Values(T1 v1, T2 v2, T3 v3, T4 v4,\n    T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13,\n    T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21,\n    T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29,\n    T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36) {\n  return internal::ValueArray36<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36>(v1, v2, v3, v4,\n      v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,\n      v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33,\n      v34, v35, v36);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37>\ninternal::ValueArray37<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37> Values(T1 v1, T2 v2, T3 v3,\n    T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,\n    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,\n    T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28,\n    T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36,\n    T37 v37) {\n  return internal::ValueArray37<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37>(v1, v2, v3,\n      v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,\n      v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33,\n      v34, v35, v36, v37);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38>\ninternal::ValueArray38<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38> Values(T1 v1, T2 v2,\n    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,\n    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,\n    T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28,\n    T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36,\n    T37 v37, T38 v38) {\n  return internal::ValueArray38<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38>(v1, v2,\n      v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18,\n      v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32,\n      v33, v34, v35, v36, v37, v38);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39>\ninternal::ValueArray39<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39> Values(T1 v1, T2 v2,\n    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,\n    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,\n    T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28,\n    T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36,\n    T37 v37, T38 v38, T39 v39) {\n  return internal::ValueArray39<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39>(v1,\n      v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17,\n      v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31,\n      v32, v33, v34, v35, v36, v37, v38, v39);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40>\ninternal::ValueArray40<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40> Values(T1 v1,\n    T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11,\n    T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19,\n    T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27,\n    T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35,\n    T36 v36, T37 v37, T38 v38, T39 v39, T40 v40) {\n  return internal::ValueArray40<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15,\n      v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29,\n      v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41>\ninternal::ValueArray41<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\n    T41> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n    T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n    T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41) {\n  return internal::ValueArray41<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,\n      v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28,\n      v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42>\ninternal::ValueArray42<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,\n    T42> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n    T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n    T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\n    T42 v42) {\n  return internal::ValueArray42<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,\n      v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27,\n      v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41,\n      v42);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43>\ninternal::ValueArray43<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,\n    T43> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n    T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n    T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\n    T42 v42, T43 v43) {\n  return internal::ValueArray43<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42, T43>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\n      v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26,\n      v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40,\n      v41, v42, v43);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44>\ninternal::ValueArray44<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n    T44> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n    T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n    T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\n    T42 v42, T43 v43, T44 v44) {\n  return internal::ValueArray44<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42, T43, T44>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\n      v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25,\n      v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39,\n      v40, v41, v42, v43, v44);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45>\ninternal::ValueArray45<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n    T44, T45> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8,\n    T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16,\n    T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24,\n    T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32,\n    T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40,\n    T41 v41, T42 v42, T43 v43, T44 v44, T45 v45) {\n  return internal::ValueArray45<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42, T43, T44, T45>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10,\n      v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24,\n      v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38,\n      v39, v40, v41, v42, v43, v44, v45);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46>\ninternal::ValueArray46<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n    T44, T45, T46> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,\n    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,\n    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31,\n    T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39,\n    T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45, T46 v46) {\n  return internal::ValueArray46<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42, T43, T44, T45, T46>(v1, v2, v3, v4, v5, v6, v7, v8, v9,\n      v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23,\n      v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37,\n      v38, v39, v40, v41, v42, v43, v44, v45, v46);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47>\ninternal::ValueArray47<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n    T44, T45, T46, T47> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,\n    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,\n    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31,\n    T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39,\n    T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47) {\n  return internal::ValueArray47<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42, T43, T44, T45, T46, T47>(v1, v2, v3, v4, v5, v6, v7, v8,\n      v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23,\n      v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37,\n      v38, v39, v40, v41, v42, v43, v44, v45, v46, v47);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47, typename T48>\ninternal::ValueArray48<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n    T44, T45, T46, T47, T48> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6,\n    T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,\n    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,\n    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31,\n    T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39,\n    T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47,\n    T48 v48) {\n  return internal::ValueArray48<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42, T43, T44, T45, T46, T47, T48>(v1, v2, v3, v4, v5, v6, v7,\n      v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\n      v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36,\n      v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47, typename T48, typename T49>\ninternal::ValueArray49<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n    T44, T45, T46, T47, T48, T49> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5,\n    T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14,\n    T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22,\n    T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30,\n    T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38,\n    T39 v39, T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45, T46 v46,\n    T47 v47, T48 v48, T49 v49) {\n  return internal::ValueArray49<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42, T43, T44, T45, T46, T47, T48, T49>(v1, v2, v3, v4, v5, v6,\n      v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,\n      v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35,\n      v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47, typename T48, typename T49, typename T50>\ninternal::ValueArray50<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n    T44, T45, T46, T47, T48, T49, T50> Values(T1 v1, T2 v2, T3 v3, T4 v4,\n    T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13,\n    T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21,\n    T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29,\n    T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37,\n    T38 v38, T39 v39, T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45,\n    T46 v46, T47 v47, T48 v48, T49 v49, T50 v50) {\n  return internal::ValueArray50<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40, T41, T42, T43, T44, T45, T46, T47, T48, T49, T50>(v1, v2, v3, v4,\n      v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,\n      v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33,\n      v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47,\n      v48, v49, v50);\n}\n\n// Bool() allows generating tests with parameters in a set of (false, true).\n//\n// Synopsis:\n// Bool()\n//   - returns a generator producing sequences with elements {false, true}.\n//\n// It is useful when testing code that depends on Boolean flags. Combinations\n// of multiple flags can be tested when several Bool()'s are combined using\n// Combine() function.\n//\n// In the following example all tests in the test case FlagDependentTest\n// will be instantiated twice with parameters false and true.\n//\n// class FlagDependentTest : public testing::TestWithParam<bool> {\n//   virtual void SetUp() {\n//     external_flag = GetParam();\n//   }\n// }\n// INSTANTIATE_TEST_CASE_P(BoolSequence, FlagDependentTest, Bool());\n//\ninline internal::ParamGenerator<bool> Bool() {\n  return Values(false, true);\n}\n\n# if GTEST_HAS_COMBINE\n// Combine() allows the user to combine two or more sequences to produce\n// values of a Cartesian product of those sequences' elements.\n//\n// Synopsis:\n// Combine(gen1, gen2, ..., genN)\n//   - returns a generator producing sequences with elements coming from\n//     the Cartesian product of elements from the sequences generated by\n//     gen1, gen2, ..., genN. The sequence elements will have a type of\n//     tuple<T1, T2, ..., TN> where T1, T2, ..., TN are the types\n//     of elements from sequences produces by gen1, gen2, ..., genN.\n//\n// Combine can have up to 10 arguments. This number is currently limited\n// by the maximum number of elements in the tuple implementation used by Google\n// Test.\n//\n// Example:\n//\n// This will instantiate tests in test case AnimalTest each one with\n// the parameter values tuple(\"cat\", BLACK), tuple(\"cat\", WHITE),\n// tuple(\"dog\", BLACK), and tuple(\"dog\", WHITE):\n//\n// enum Color { BLACK, GRAY, WHITE };\n// class AnimalTest\n//     : public testing::TestWithParam<tuple<const char*, Color> > {...};\n//\n// TEST_P(AnimalTest, AnimalLooksNice) {...}\n//\n// INSTANTIATE_TEST_CASE_P(AnimalVariations, AnimalTest,\n//                         Combine(Values(\"cat\", \"dog\"),\n//                                 Values(BLACK, WHITE)));\n//\n// This will instantiate tests in FlagDependentTest with all variations of two\n// Boolean flags:\n//\n// class FlagDependentTest\n//     : public testing::TestWithParam<tuple<bool, bool> > {\n//   virtual void SetUp() {\n//     // Assigns external_flag_1 and external_flag_2 values from the tuple.\n//     tie(external_flag_1, external_flag_2) = GetParam();\n//   }\n// };\n//\n// TEST_P(FlagDependentTest, TestFeature1) {\n//   // Test your code using external_flag_1 and external_flag_2 here.\n// }\n// INSTANTIATE_TEST_CASE_P(TwoBoolSequence, FlagDependentTest,\n//                         Combine(Bool(), Bool()));\n//\ntemplate <typename Generator1, typename Generator2>\ninternal::CartesianProductHolder2<Generator1, Generator2> Combine(\n    const Generator1& g1, const Generator2& g2) {\n  return internal::CartesianProductHolder2<Generator1, Generator2>(\n      g1, g2);\n}\n\ntemplate <typename Generator1, typename Generator2, typename Generator3>\ninternal::CartesianProductHolder3<Generator1, Generator2, Generator3> Combine(\n    const Generator1& g1, const Generator2& g2, const Generator3& g3) {\n  return internal::CartesianProductHolder3<Generator1, Generator2, Generator3>(\n      g1, g2, g3);\n}\n\ntemplate <typename Generator1, typename Generator2, typename Generator3,\n    typename Generator4>\ninternal::CartesianProductHolder4<Generator1, Generator2, Generator3,\n    Generator4> Combine(\n    const Generator1& g1, const Generator2& g2, const Generator3& g3,\n        const Generator4& g4) {\n  return internal::CartesianProductHolder4<Generator1, Generator2, Generator3,\n      Generator4>(\n      g1, g2, g3, g4);\n}\n\ntemplate <typename Generator1, typename Generator2, typename Generator3,\n    typename Generator4, typename Generator5>\ninternal::CartesianProductHolder5<Generator1, Generator2, Generator3,\n    Generator4, Generator5> Combine(\n    const Generator1& g1, const Generator2& g2, const Generator3& g3,\n        const Generator4& g4, const Generator5& g5) {\n  return internal::CartesianProductHolder5<Generator1, Generator2, Generator3,\n      Generator4, Generator5>(\n      g1, g2, g3, g4, g5);\n}\n\ntemplate <typename Generator1, typename Generator2, typename Generator3,\n    typename Generator4, typename Generator5, typename Generator6>\ninternal::CartesianProductHolder6<Generator1, Generator2, Generator3,\n    Generator4, Generator5, Generator6> Combine(\n    const Generator1& g1, const Generator2& g2, const Generator3& g3,\n        const Generator4& g4, const Generator5& g5, const Generator6& g6) {\n  return internal::CartesianProductHolder6<Generator1, Generator2, Generator3,\n      Generator4, Generator5, Generator6>(\n      g1, g2, g3, g4, g5, g6);\n}\n\ntemplate <typename Generator1, typename Generator2, typename Generator3,\n    typename Generator4, typename Generator5, typename Generator6,\n    typename Generator7>\ninternal::CartesianProductHolder7<Generator1, Generator2, Generator3,\n    Generator4, Generator5, Generator6, Generator7> Combine(\n    const Generator1& g1, const Generator2& g2, const Generator3& g3,\n        const Generator4& g4, const Generator5& g5, const Generator6& g6,\n        const Generator7& g7) {\n  return internal::CartesianProductHolder7<Generator1, Generator2, Generator3,\n      Generator4, Generator5, Generator6, Generator7>(\n      g1, g2, g3, g4, g5, g6, g7);\n}\n\ntemplate <typename Generator1, typename Generator2, typename Generator3,\n    typename Generator4, typename Generator5, typename Generator6,\n    typename Generator7, typename Generator8>\ninternal::CartesianProductHolder8<Generator1, Generator2, Generator3,\n    Generator4, Generator5, Generator6, Generator7, Generator8> Combine(\n    const Generator1& g1, const Generator2& g2, const Generator3& g3,\n        const Generator4& g4, const Generator5& g5, const Generator6& g6,\n        const Generator7& g7, const Generator8& g8) {\n  return internal::CartesianProductHolder8<Generator1, Generator2, Generator3,\n      Generator4, Generator5, Generator6, Generator7, Generator8>(\n      g1, g2, g3, g4, g5, g6, g7, g8);\n}\n\ntemplate <typename Generator1, typename Generator2, typename Generator3,\n    typename Generator4, typename Generator5, typename Generator6,\n    typename Generator7, typename Generator8, typename Generator9>\ninternal::CartesianProductHolder9<Generator1, Generator2, Generator3,\n    Generator4, Generator5, Generator6, Generator7, Generator8,\n    Generator9> Combine(\n    const Generator1& g1, const Generator2& g2, const Generator3& g3,\n        const Generator4& g4, const Generator5& g5, const Generator6& g6,\n        const Generator7& g7, const Generator8& g8, const Generator9& g9) {\n  return internal::CartesianProductHolder9<Generator1, Generator2, Generator3,\n      Generator4, Generator5, Generator6, Generator7, Generator8, Generator9>(\n      g1, g2, g3, g4, g5, g6, g7, g8, g9);\n}\n\ntemplate <typename Generator1, typename Generator2, typename Generator3,\n    typename Generator4, typename Generator5, typename Generator6,\n    typename Generator7, typename Generator8, typename Generator9,\n    typename Generator10>\ninternal::CartesianProductHolder10<Generator1, Generator2, Generator3,\n    Generator4, Generator5, Generator6, Generator7, Generator8, Generator9,\n    Generator10> Combine(\n    const Generator1& g1, const Generator2& g2, const Generator3& g3,\n        const Generator4& g4, const Generator5& g5, const Generator6& g6,\n        const Generator7& g7, const Generator8& g8, const Generator9& g9,\n        const Generator10& g10) {\n  return internal::CartesianProductHolder10<Generator1, Generator2, Generator3,\n      Generator4, Generator5, Generator6, Generator7, Generator8, Generator9,\n      Generator10>(\n      g1, g2, g3, g4, g5, g6, g7, g8, g9, g10);\n}\n# endif  // GTEST_HAS_COMBINE\n\n\n\n# define TEST_P(test_case_name, test_name) \\\n  class GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \\\n      : public test_case_name { \\\n   public: \\\n    GTEST_TEST_CLASS_NAME_(test_case_name, test_name)() {} \\\n    virtual void TestBody(); \\\n   private: \\\n    static int AddToRegistry() { \\\n      ::testing::UnitTest::GetInstance()->parameterized_test_registry(). \\\n          GetTestCasePatternHolder<test_case_name>(\\\n              #test_case_name, \\\n              ::testing::internal::CodeLocation(\\\n                  __FILE__, __LINE__))->AddTestPattern(\\\n                      #test_case_name, \\\n                      #test_name, \\\n                      new ::testing::internal::TestMetaFactory< \\\n                          GTEST_TEST_CLASS_NAME_(\\\n                              test_case_name, test_name)>()); \\\n      return 0; \\\n    } \\\n    static int gtest_registering_dummy_ GTEST_ATTRIBUTE_UNUSED_; \\\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(\\\n        GTEST_TEST_CLASS_NAME_(test_case_name, test_name)); \\\n  }; \\\n  int GTEST_TEST_CLASS_NAME_(test_case_name, \\\n                             test_name)::gtest_registering_dummy_ = \\\n      GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::AddToRegistry(); \\\n  void GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()\n\n// The optional last argument to INSTANTIATE_TEST_CASE_P allows the user\n// to specify a function or functor that generates custom test name suffixes\n// based on the test parameters. The function should accept one argument of\n// type testing::TestParamInfo<class ParamType>, and return std::string.\n//\n// testing::PrintToStringParamName is a builtin test suffix generator that\n// returns the value of testing::PrintToString(GetParam()). It does not work\n// for std::string or C strings.\n//\n// Note: test names must be non-empty, unique, and may only contain ASCII\n// alphanumeric characters or underscore.\n\n# define INSTANTIATE_TEST_CASE_P(prefix, test_case_name, generator, ...) \\\n  ::testing::internal::ParamGenerator<test_case_name::ParamType> \\\n      gtest_##prefix##test_case_name##_EvalGenerator_() { return generator; } \\\n  ::std::string gtest_##prefix##test_case_name##_EvalGenerateName_( \\\n      const ::testing::TestParamInfo<test_case_name::ParamType>& info) { \\\n    return ::testing::internal::GetParamNameGen<test_case_name::ParamType> \\\n        (__VA_ARGS__)(info); \\\n  } \\\n  int gtest_##prefix##test_case_name##_dummy_ GTEST_ATTRIBUTE_UNUSED_ = \\\n      ::testing::UnitTest::GetInstance()->parameterized_test_registry(). \\\n          GetTestCasePatternHolder<test_case_name>(\\\n              #test_case_name, \\\n              ::testing::internal::CodeLocation(\\\n                  __FILE__, __LINE__))->AddTestCaseInstantiation(\\\n                      #prefix, \\\n                      &gtest_##prefix##test_case_name##_EvalGenerator_, \\\n                      &gtest_##prefix##test_case_name##_EvalGenerateName_, \\\n                      __FILE__, __LINE__)\n\n}  // namespace testing\n\n#endif  // GTEST_HAS_PARAM_TEST\n\n#endif  // GTEST_INCLUDE_GTEST_GTEST_PARAM_TEST_H_\n"}, "50": {"id": 50, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest-printers.h", "content": "// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n// Google Test - The Google C++ Testing Framework\n//\n// This file implements a universal value printer that can print a\n// value of any type T:\n//\n//   void ::testing::internal::UniversalPrinter<T>::Print(value, ostream_ptr);\n//\n// A user can teach this function how to print a class type T by\n// defining either operator<<() or PrintTo() in the namespace that\n// defines T.  More specifically, the FIRST defined function in the\n// following list will be used (assuming T is defined in namespace\n// foo):\n//\n//   1. foo::PrintTo(const T&, ostream*)\n//   2. operator<<(ostream&, const T&) defined in either foo or the\n//      global namespace.\n//\n// If none of the above is defined, it will print the debug string of\n// the value if it is a protocol buffer, or print the raw bytes in the\n// value otherwise.\n//\n// To aid debugging: when T is a reference type, the address of the\n// value is also printed; when T is a (const) char pointer, both the\n// pointer value and the NUL-terminated string it points to are\n// printed.\n//\n// We also provide some convenient wrappers:\n//\n//   // Prints a value to a string.  For a (const or not) char\n//   // pointer, the NUL-terminated string (but not the pointer) is\n//   // printed.\n//   std::string ::testing::PrintToString(const T& value);\n//\n//   // Prints a value tersely: for a reference type, the referenced\n//   // value (but not the address) is printed; for a (const or not) char\n//   // pointer, the NUL-terminated string (but not the pointer) is\n//   // printed.\n//   void ::testing::internal::UniversalTersePrint(const T& value, ostream*);\n//\n//   // Prints value using the type inferred by the compiler.  The difference\n//   // from UniversalTersePrint() is that this function prints both the\n//   // pointer and the NUL-terminated string for a (const or not) char pointer.\n//   void ::testing::internal::UniversalPrint(const T& value, ostream*);\n//\n//   // Prints the fields of a tuple tersely to a string vector, one\n//   // element for each field. Tuple support must be enabled in\n//   // gtest-port.h.\n//   std::vector<string> UniversalTersePrintTupleFieldsToStrings(\n//       const Tuple& value);\n//\n// Known limitation:\n//\n// The print primitives print the elements of an STL-style container\n// using the compiler-inferred type of *iter where iter is a\n// const_iterator of the container.  When const_iterator is an input\n// iterator but not a forward iterator, this inferred type may not\n// match value_type, and the print output may be incorrect.  In\n// practice, this is rarely a problem as for most containers\n// const_iterator is a forward iterator.  We'll fix this if there's an\n// actual need for it.  Note that this fix cannot rely on value_type\n// being defined as many user-defined container types don't have\n// value_type.\n\n#ifndef GTEST_INCLUDE_GTEST_GTEST_PRINTERS_H_\n#define GTEST_INCLUDE_GTEST_GTEST_PRINTERS_H_\n\n#include <ostream>  // NOLINT\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n#include \"gtest/internal/gtest-port.h\"\n#include \"gtest/internal/gtest-internal.h\"\n#include \"gtest/internal/custom/raw-ostream.h\"\n\n#if GTEST_HAS_STD_TUPLE_\n# include <tuple>\n#endif\n\nnamespace testing {\n\n// Definitions in the 'internal' and 'internal2' name spaces are\n// subject to change without notice.  DO NOT USE THEM IN USER CODE!\nnamespace internal2 {\n\n// Prints the given number of bytes in the given object to the given\n// ostream.\nGTEST_API_ void PrintBytesInObjectTo(const unsigned char* obj_bytes,\n                                     size_t count,\n                                     ::std::ostream* os);\n\n// For selecting which printer to use when a given type has neither <<\n// nor PrintTo().\nenum TypeKind {\n  kProtobuf,              // a protobuf type\n  kConvertibleToInteger,  // a type implicitly convertible to BiggestInt\n                          // (e.g. a named or unnamed enum type)\n  kOtherType              // anything else\n};\n\n// TypeWithoutFormatter<T, kTypeKind>::PrintValue(value, os) is called\n// by the universal printer to print a value of type T when neither\n// operator<< nor PrintTo() is defined for T, where kTypeKind is the\n// \"kind\" of T as defined by enum TypeKind.\ntemplate <typename T, TypeKind kTypeKind>\nclass TypeWithoutFormatter {\n public:\n  // This default version is called when kTypeKind is kOtherType.\n  static void PrintValue(const T& value, ::std::ostream* os) {\n    PrintBytesInObjectTo(reinterpret_cast<const unsigned char*>(&value),\n                         sizeof(value), os);\n  }\n};\n\n// We print a protobuf using its ShortDebugString() when the string\n// doesn't exceed this many characters; otherwise we print it using\n// DebugString() for better readability.\nconst size_t kProtobufOneLinerMaxLength = 50;\n\ntemplate <typename T>\nclass TypeWithoutFormatter<T, kProtobuf> {\n public:\n  static void PrintValue(const T& value, ::std::ostream* os) {\n    const ::testing::internal::string short_str = value.ShortDebugString();\n    const ::testing::internal::string pretty_str =\n        short_str.length() <= kProtobufOneLinerMaxLength ?\n        short_str : (\"\\n\" + value.DebugString());\n    *os << (\"<\" + pretty_str + \">\");\n  }\n};\n\ntemplate <typename T>\nclass TypeWithoutFormatter<T, kConvertibleToInteger> {\n public:\n  // Since T has no << operator or PrintTo() but can be implicitly\n  // converted to BiggestInt, we print it as a BiggestInt.\n  //\n  // Most likely T is an enum type (either named or unnamed), in which\n  // case printing it as an integer is the desired behavior.  In case\n  // T is not an enum, printing it as an integer is the best we can do\n  // given that it has no user-defined printer.\n  static void PrintValue(const T& value, ::std::ostream* os) {\n    const internal::BiggestInt kBigInt = value;\n    *os << kBigInt;\n  }\n};\n\n// Prints the given value to the given ostream.  If the value is a\n// protocol message, its debug string is printed; if it's an enum or\n// of a type implicitly convertible to BiggestInt, it's printed as an\n// integer; otherwise the bytes in the value are printed.  This is\n// what UniversalPrinter<T>::Print() does when it knows nothing about\n// type T and T has neither << operator nor PrintTo().\n//\n// A user can override this behavior for a class type Foo by defining\n// a << operator in the namespace where Foo is defined.\n//\n// We put this operator in namespace 'internal2' instead of 'internal'\n// to simplify the implementation, as much code in 'internal' needs to\n// use << in STL, which would conflict with our own << were it defined\n// in 'internal'.\n//\n// Note that this operator<< takes a generic std::basic_ostream<Char,\n// CharTraits> type instead of the more restricted std::ostream.  If\n// we define it to take an std::ostream instead, we'll get an\n// \"ambiguous overloads\" compiler error when trying to print a type\n// Foo that supports streaming to std::basic_ostream<Char,\n// CharTraits>, as the compiler cannot tell whether\n// operator<<(std::ostream&, const T&) or\n// operator<<(std::basic_stream<Char, CharTraits>, const Foo&) is more\n// specific.\ntemplate <typename Char, typename CharTraits, typename T>\n::std::basic_ostream<Char, CharTraits>& operator<<(\n    ::std::basic_ostream<Char, CharTraits>& os, const T& x) {\n  TypeWithoutFormatter<T,\n      (internal::IsAProtocolMessage<T>::value ? kProtobuf :\n       internal::ImplicitlyConvertible<const T&, internal::BiggestInt>::value ?\n       kConvertibleToInteger : kOtherType)>::PrintValue(x, &os);\n  return os;\n}\n\n}  // namespace internal2\n}  // namespace testing\n\n// This namespace MUST NOT BE NESTED IN ::testing, or the name look-up\n// magic needed for implementing UniversalPrinter won't work.\nnamespace testing_internal {\n\n// Used to print a value that is not an STL-style container when the\n// user doesn't define PrintTo() for it.\ntemplate <typename T>\nvoid DefaultPrintNonContainerTo(const T& value, ::std::ostream* os) {\n  // With the following statement, during unqualified name lookup,\n  // testing::internal2::operator<< appears as if it was declared in\n  // the nearest enclosing namespace that contains both\n  // ::testing_internal and ::testing::internal2, i.e. the global\n  // namespace.  For more details, refer to the C++ Standard section\n  // 7.3.4-1 [namespace.udir].  This allows us to fall back onto\n  // testing::internal2::operator<< in case T doesn't come with a <<\n  // operator.\n  //\n  // We cannot write 'using ::testing::internal2::operator<<;', which\n  // gcc 3.3 fails to compile due to a compiler bug.\n  using namespace ::testing::internal2;  // NOLINT\n\n  // Assuming T is defined in namespace foo, in the next statement,\n  // the compiler will consider all of:\n  //\n  //   1. foo::operator<< (thanks to Koenig look-up),\n  //   2. ::operator<< (as the current namespace is enclosed in ::),\n  //   3. testing::internal2::operator<< (thanks to the using statement above).\n  //\n  // The operator<< whose type matches T best will be picked.\n  //\n  // We deliberately allow #2 to be a candidate, as sometimes it's\n  // impossible to define #1 (e.g. when foo is ::std, defining\n  // anything in it is undefined behavior unless you are a compiler\n  // vendor.).\n  *os << ::llvm_gtest::printable(value);\n}\n\n}  // namespace testing_internal\n\nnamespace testing {\nnamespace internal {\n\n// FormatForComparison<ToPrint, OtherOperand>::Format(value) formats a\n// value of type ToPrint that is an operand of a comparison assertion\n// (e.g. ASSERT_EQ).  OtherOperand is the type of the other operand in\n// the comparison, and is used to help determine the best way to\n// format the value.  In particular, when the value is a C string\n// (char pointer) and the other operand is an STL string object, we\n// want to format the C string as a string, since we know it is\n// compared by value with the string object.  If the value is a char\n// pointer but the other operand is not an STL string object, we don't\n// know whether the pointer is supposed to point to a NUL-terminated\n// string, and thus want to print it as a pointer to be safe.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n\n// The default case.\ntemplate <typename ToPrint, typename OtherOperand>\nclass FormatForComparison {\n public:\n  static ::std::string Format(const ToPrint& value) {\n    return ::testing::PrintToString(value);\n  }\n};\n\n// Array.\ntemplate <typename ToPrint, size_t N, typename OtherOperand>\nclass FormatForComparison<ToPrint[N], OtherOperand> {\n public:\n  static ::std::string Format(const ToPrint* value) {\n    return FormatForComparison<const ToPrint*, OtherOperand>::Format(value);\n  }\n};\n\n// By default, print C string as pointers to be safe, as we don't know\n// whether they actually point to a NUL-terminated string.\n\n#define GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_(CharType)                \\\n  template <typename OtherOperand>                                      \\\n  class FormatForComparison<CharType*, OtherOperand> {                  \\\n   public:                                                              \\\n    static ::std::string Format(CharType* value) {                      \\\n      return ::testing::PrintToString(static_cast<const void*>(value)); \\\n    }                                                                   \\\n  }\n\nGTEST_IMPL_FORMAT_C_STRING_AS_POINTER_(char);\nGTEST_IMPL_FORMAT_C_STRING_AS_POINTER_(const char);\nGTEST_IMPL_FORMAT_C_STRING_AS_POINTER_(wchar_t);\nGTEST_IMPL_FORMAT_C_STRING_AS_POINTER_(const wchar_t);\n\n#undef GTEST_IMPL_FORMAT_C_STRING_AS_POINTER_\n\n// If a C string is compared with an STL string object, we know it's meant\n// to point to a NUL-terminated string, and thus can print it as a string.\n\n#define GTEST_IMPL_FORMAT_C_STRING_AS_STRING_(CharType, OtherStringType) \\\n  template <>                                                           \\\n  class FormatForComparison<CharType*, OtherStringType> {               \\\n   public:                                                              \\\n    static ::std::string Format(CharType* value) {                      \\\n      return ::testing::PrintToString(value);                           \\\n    }                                                                   \\\n  }\n\nGTEST_IMPL_FORMAT_C_STRING_AS_STRING_(char, ::std::string);\nGTEST_IMPL_FORMAT_C_STRING_AS_STRING_(const char, ::std::string);\n\n#if GTEST_HAS_GLOBAL_STRING\nGTEST_IMPL_FORMAT_C_STRING_AS_STRING_(char, ::string);\nGTEST_IMPL_FORMAT_C_STRING_AS_STRING_(const char, ::string);\n#endif\n\n#if GTEST_HAS_GLOBAL_WSTRING\nGTEST_IMPL_FORMAT_C_STRING_AS_STRING_(wchar_t, ::wstring);\nGTEST_IMPL_FORMAT_C_STRING_AS_STRING_(const wchar_t, ::wstring);\n#endif\n\n#if GTEST_HAS_STD_WSTRING\nGTEST_IMPL_FORMAT_C_STRING_AS_STRING_(wchar_t, ::std::wstring);\nGTEST_IMPL_FORMAT_C_STRING_AS_STRING_(const wchar_t, ::std::wstring);\n#endif\n\n#undef GTEST_IMPL_FORMAT_C_STRING_AS_STRING_\n\n// Formats a comparison assertion (e.g. ASSERT_EQ, EXPECT_LT, and etc)\n// operand to be used in a failure message.  The type (but not value)\n// of the other operand may affect the format.  This allows us to\n// print a char* as a raw pointer when it is compared against another\n// char* or void*, and print it as a C string when it is compared\n// against an std::string object, for example.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\ntemplate <typename T1, typename T2>\nstd::string FormatForComparisonFailureMessage(\n    const T1& value, const T2& /* other_operand */) {\n  return FormatForComparison<T1, T2>::Format(value);\n}\n\n// UniversalPrinter<T>::Print(value, ostream_ptr) prints the given\n// value to the given ostream.  The caller must ensure that\n// 'ostream_ptr' is not NULL, or the behavior is undefined.\n//\n// We define UniversalPrinter as a class template (as opposed to a\n// function template), as we need to partially specialize it for\n// reference types, which cannot be done with function templates.\ntemplate <typename T>\nclass UniversalPrinter;\n\ntemplate <typename T>\nvoid UniversalPrint(const T& value, ::std::ostream* os);\n\n// Used to print an STL-style container when the user doesn't define\n// a PrintTo() for it.\ntemplate <typename C>\nvoid DefaultPrintTo(IsContainer /* dummy */,\n                    false_type /* is not a pointer */,\n                    const C& container, ::std::ostream* os) {\n  const size_t kMaxCount = 32;  // The maximum number of elements to print.\n  *os << '{';\n  size_t count = 0;\n  for (typename C::const_iterator it = container.begin();\n       it != container.end(); ++it, ++count) {\n    if (count > 0) {\n      *os << ',';\n      if (count == kMaxCount) {  // Enough has been printed.\n        *os << \" ...\";\n        break;\n      }\n    }\n    *os << ' ';\n    // We cannot call PrintTo(*it, os) here as PrintTo() doesn't\n    // handle *it being a native array.\n    internal::UniversalPrint(*it, os);\n  }\n\n  if (count > 0) {\n    *os << ' ';\n  }\n  *os << '}';\n}\n\n// Used to print a pointer that is neither a char pointer nor a member\n// pointer, when the user doesn't define PrintTo() for it.  (A member\n// variable pointer or member function pointer doesn't really point to\n// a location in the address space.  Their representation is\n// implementation-defined.  Therefore they will be printed as raw\n// bytes.)\ntemplate <typename T>\nvoid DefaultPrintTo(IsNotContainer /* dummy */,\n                    true_type /* is a pointer */,\n                    T* p, ::std::ostream* os) {\n  if (p == NULL) {\n    *os << \"NULL\";\n  } else {\n    // C++ doesn't allow casting from a function pointer to any object\n    // pointer.\n    //\n    // IsTrue() silences warnings: \"Condition is always true\",\n    // \"unreachable code\".\n    if (IsTrue(ImplicitlyConvertible<T*, const void*>::value)) {\n      // T is not a function type.  We just call << to print p,\n      // relying on ADL to pick up user-defined << for their pointer\n      // types, if any.\n      *os << p;\n    } else {\n      // T is a function type, so '*os << p' doesn't do what we want\n      // (it just prints p as bool).  We want to print p as a const\n      // void*.  However, we cannot cast it to const void* directly,\n      // even using reinterpret_cast, as earlier versions of gcc\n      // (e.g. 3.4.5) cannot compile the cast when p is a function\n      // pointer.  Casting to UInt64 first solves the problem.\n      *os << reinterpret_cast<const void*>(\n          reinterpret_cast<internal::UInt64>(p));\n    }\n  }\n}\n\n// Used to print a non-container, non-pointer value when the user\n// doesn't define PrintTo() for it.\ntemplate <typename T>\nvoid DefaultPrintTo(IsNotContainer /* dummy */,\n                    false_type /* is not a pointer */,\n                    const T& value, ::std::ostream* os) {\n  ::testing_internal::DefaultPrintNonContainerTo(value, os);\n}\n\n// Prints the given value using the << operator if it has one;\n// otherwise prints the bytes in it.  This is what\n// UniversalPrinter<T>::Print() does when PrintTo() is not specialized\n// or overloaded for type T.\n//\n// A user can override this behavior for a class type Foo by defining\n// an overload of PrintTo() in the namespace where Foo is defined.  We\n// give the user this option as sometimes defining a << operator for\n// Foo is not desirable (e.g. the coding style may prevent doing it,\n// or there is already a << operator but it doesn't do what the user\n// wants).\ntemplate <typename T>\nvoid PrintTo(const T& value, ::std::ostream* os) {\n  // DefaultPrintTo() is overloaded.  The type of its first two\n  // arguments determine which version will be picked.  If T is an\n  // STL-style container, the version for container will be called; if\n  // T is a pointer, the pointer version will be called; otherwise the\n  // generic version will be called.\n  //\n  // Note that we check for container types here, prior to we check\n  // for protocol message types in our operator<<.  The rationale is:\n  //\n  // For protocol messages, we want to give people a chance to\n  // override Google Mock's format by defining a PrintTo() or\n  // operator<<.  For STL containers, other formats can be\n  // incompatible with Google Mock's format for the container\n  // elements; therefore we check for container types here to ensure\n  // that our format is used.\n  //\n  // The second argument of DefaultPrintTo() is needed to bypass a bug\n  // in Symbian's C++ compiler that prevents it from picking the right\n  // overload between:\n  //\n  //   PrintTo(const T& x, ...);\n  //   PrintTo(T* x, ...);\n  DefaultPrintTo(IsContainerTest<T>(0), is_pointer<T>(), value, os);\n}\n\n// The following list of PrintTo() overloads tells\n// UniversalPrinter<T>::Print() how to print standard types (built-in\n// types, strings, plain arrays, and pointers).\n\n// Overloads for various char types.\nGTEST_API_ void PrintTo(unsigned char c, ::std::ostream* os);\nGTEST_API_ void PrintTo(signed char c, ::std::ostream* os);\ninline void PrintTo(char c, ::std::ostream* os) {\n  // When printing a plain char, we always treat it as unsigned.  This\n  // way, the output won't be affected by whether the compiler thinks\n  // char is signed or not.\n  PrintTo(static_cast<unsigned char>(c), os);\n}\n\n// Overloads for other simple built-in types.\ninline void PrintTo(bool x, ::std::ostream* os) {\n  *os << (x ? \"true\" : \"false\");\n}\n\n// Overload for wchar_t type.\n// Prints a wchar_t as a symbol if it is printable or as its internal\n// code otherwise and also as its decimal code (except for L'\\0').\n// The L'\\0' char is printed as \"L'\\\\0'\". The decimal code is printed\n// as signed integer when wchar_t is implemented by the compiler\n// as a signed type and is printed as an unsigned integer when wchar_t\n// is implemented as an unsigned type.\nGTEST_API_ void PrintTo(wchar_t wc, ::std::ostream* os);\n\n// Overloads for C strings.\nGTEST_API_ void PrintTo(const char* s, ::std::ostream* os);\ninline void PrintTo(char* s, ::std::ostream* os) {\n  PrintTo(ImplicitCast_<const char*>(s), os);\n}\n\n// signed/unsigned char is often used for representing binary data, so\n// we print pointers to it as void* to be safe.\ninline void PrintTo(const signed char* s, ::std::ostream* os) {\n  PrintTo(ImplicitCast_<const void*>(s), os);\n}\ninline void PrintTo(signed char* s, ::std::ostream* os) {\n  PrintTo(ImplicitCast_<const void*>(s), os);\n}\ninline void PrintTo(const unsigned char* s, ::std::ostream* os) {\n  PrintTo(ImplicitCast_<const void*>(s), os);\n}\ninline void PrintTo(unsigned char* s, ::std::ostream* os) {\n  PrintTo(ImplicitCast_<const void*>(s), os);\n}\n\n// MSVC can be configured to define wchar_t as a typedef of unsigned\n// short.  It defines _NATIVE_WCHAR_T_DEFINED when wchar_t is a native\n// type.  When wchar_t is a typedef, defining an overload for const\n// wchar_t* would cause unsigned short* be printed as a wide string,\n// possibly causing invalid memory accesses.\n#if !defined(_MSC_VER) || defined(_NATIVE_WCHAR_T_DEFINED)\n// Overloads for wide C strings\nGTEST_API_ void PrintTo(const wchar_t* s, ::std::ostream* os);\ninline void PrintTo(wchar_t* s, ::std::ostream* os) {\n  PrintTo(ImplicitCast_<const wchar_t*>(s), os);\n}\n#endif\n\n// Overload for C arrays.  Multi-dimensional arrays are printed\n// properly.\n\n// Prints the given number of elements in an array, without printing\n// the curly braces.\ntemplate <typename T>\nvoid PrintRawArrayTo(const T a[], size_t count, ::std::ostream* os) {\n  UniversalPrint(a[0], os);\n  for (size_t i = 1; i != count; i++) {\n    *os << \", \";\n    UniversalPrint(a[i], os);\n  }\n}\n\n// Overloads for ::string and ::std::string.\n#if GTEST_HAS_GLOBAL_STRING\nGTEST_API_ void PrintStringTo(const ::string&s, ::std::ostream* os);\ninline void PrintTo(const ::string& s, ::std::ostream* os) {\n  PrintStringTo(s, os);\n}\n#endif  // GTEST_HAS_GLOBAL_STRING\n\nGTEST_API_ void PrintStringTo(const ::std::string&s, ::std::ostream* os);\ninline void PrintTo(const ::std::string& s, ::std::ostream* os) {\n  PrintStringTo(s, os);\n}\n\n// Overloads for ::wstring and ::std::wstring.\n#if GTEST_HAS_GLOBAL_WSTRING\nGTEST_API_ void PrintWideStringTo(const ::wstring&s, ::std::ostream* os);\ninline void PrintTo(const ::wstring& s, ::std::ostream* os) {\n  PrintWideStringTo(s, os);\n}\n#endif  // GTEST_HAS_GLOBAL_WSTRING\n\n#if GTEST_HAS_STD_WSTRING\nGTEST_API_ void PrintWideStringTo(const ::std::wstring&s, ::std::ostream* os);\ninline void PrintTo(const ::std::wstring& s, ::std::ostream* os) {\n  PrintWideStringTo(s, os);\n}\n#endif  // GTEST_HAS_STD_WSTRING\n\n#if GTEST_HAS_TR1_TUPLE || GTEST_HAS_STD_TUPLE_\n// Helper function for printing a tuple.  T must be instantiated with\n// a tuple type.\ntemplate <typename T>\nvoid PrintTupleTo(const T& t, ::std::ostream* os);\n#endif  // GTEST_HAS_TR1_TUPLE || GTEST_HAS_STD_TUPLE_\n\n#if GTEST_HAS_TR1_TUPLE\n// Overload for ::std::tr1::tuple.  Needed for printing function arguments,\n// which are packed as tuples.\n\n// Overloaded PrintTo() for tuples of various arities.  We support\n// tuples of up-to 10 fields.  The following implementation works\n// regardless of whether tr1::tuple is implemented using the\n// non-standard variadic template feature or not.\n\ninline void PrintTo(const ::std::tr1::tuple<>& t, ::std::ostream* os) {\n  PrintTupleTo(t, os);\n}\n\ntemplate <typename T1>\nvoid PrintTo(const ::std::tr1::tuple<T1>& t, ::std::ostream* os) {\n  PrintTupleTo(t, os);\n}\n\ntemplate <typename T1, typename T2>\nvoid PrintTo(const ::std::tr1::tuple<T1, T2>& t, ::std::ostream* os) {\n  PrintTupleTo(t, os);\n}\n\ntemplate <typename T1, typename T2, typename T3>\nvoid PrintTo(const ::std::tr1::tuple<T1, T2, T3>& t, ::std::ostream* os) {\n  PrintTupleTo(t, os);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4>\nvoid PrintTo(const ::std::tr1::tuple<T1, T2, T3, T4>& t, ::std::ostream* os) {\n  PrintTupleTo(t, os);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5>\nvoid PrintTo(const ::std::tr1::tuple<T1, T2, T3, T4, T5>& t,\n             ::std::ostream* os) {\n  PrintTupleTo(t, os);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n          typename T6>\nvoid PrintTo(const ::std::tr1::tuple<T1, T2, T3, T4, T5, T6>& t,\n             ::std::ostream* os) {\n  PrintTupleTo(t, os);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n          typename T6, typename T7>\nvoid PrintTo(const ::std::tr1::tuple<T1, T2, T3, T4, T5, T6, T7>& t,\n             ::std::ostream* os) {\n  PrintTupleTo(t, os);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n          typename T6, typename T7, typename T8>\nvoid PrintTo(const ::std::tr1::tuple<T1, T2, T3, T4, T5, T6, T7, T8>& t,\n             ::std::ostream* os) {\n  PrintTupleTo(t, os);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n          typename T6, typename T7, typename T8, typename T9>\nvoid PrintTo(const ::std::tr1::tuple<T1, T2, T3, T4, T5, T6, T7, T8, T9>& t,\n             ::std::ostream* os) {\n  PrintTupleTo(t, os);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n          typename T6, typename T7, typename T8, typename T9, typename T10>\nvoid PrintTo(\n    const ::std::tr1::tuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>& t,\n    ::std::ostream* os) {\n  PrintTupleTo(t, os);\n}\n#endif  // GTEST_HAS_TR1_TUPLE\n\n#if GTEST_HAS_STD_TUPLE_\ntemplate <typename... Types>\nvoid PrintTo(const ::std::tuple<Types...>& t, ::std::ostream* os) {\n  PrintTupleTo(t, os);\n}\n#endif  // GTEST_HAS_STD_TUPLE_\n\n// Overload for std::pair.\ntemplate <typename T1, typename T2>\nvoid PrintTo(const ::std::pair<T1, T2>& value, ::std::ostream* os) {\n  *os << '(';\n  // We cannot use UniversalPrint(value.first, os) here, as T1 may be\n  // a reference type.  The same for printing value.second.\n  UniversalPrinter<T1>::Print(value.first, os);\n  *os << \", \";\n  UniversalPrinter<T2>::Print(value.second, os);\n  *os << ')';\n}\n\n// Implements printing a non-reference type T by letting the compiler\n// pick the right overload of PrintTo() for T.\ntemplate <typename T>\nclass UniversalPrinter {\n public:\n  // MSVC warns about adding const to a function type, so we want to\n  // disable the warning.\n  GTEST_DISABLE_MSC_WARNINGS_PUSH_(4180)\n\n  // Note: we deliberately don't call this PrintTo(), as that name\n  // conflicts with ::testing::internal::PrintTo in the body of the\n  // function.\n  static void Print(const T& value, ::std::ostream* os) {\n    // By default, ::testing::internal::PrintTo() is used for printing\n    // the value.\n    //\n    // Thanks to Koenig look-up, if T is a class and has its own\n    // PrintTo() function defined in its namespace, that function will\n    // be visible here.  Since it is more specific than the generic ones\n    // in ::testing::internal, it will be picked by the compiler in the\n    // following statement - exactly what we want.\n    PrintTo(value, os);\n  }\n\n  GTEST_DISABLE_MSC_WARNINGS_POP_()\n};\n\n// UniversalPrintArray(begin, len, os) prints an array of 'len'\n// elements, starting at address 'begin'.\ntemplate <typename T>\nvoid UniversalPrintArray(const T* begin, size_t len, ::std::ostream* os) {\n  if (len == 0) {\n    *os << \"{}\";\n  } else {\n    *os << \"{ \";\n    const size_t kThreshold = 18;\n    const size_t kChunkSize = 8;\n    // If the array has more than kThreshold elements, we'll have to\n    // omit some details by printing only the first and the last\n    // kChunkSize elements.\n    // TODO(wan@google.com): let the user control the threshold using a flag.\n    if (len <= kThreshold) {\n      PrintRawArrayTo(begin, len, os);\n    } else {\n      PrintRawArrayTo(begin, kChunkSize, os);\n      *os << \", ..., \";\n      PrintRawArrayTo(begin + len - kChunkSize, kChunkSize, os);\n    }\n    *os << \" }\";\n  }\n}\n// This overload prints a (const) char array compactly.\nGTEST_API_ void UniversalPrintArray(\n    const char* begin, size_t len, ::std::ostream* os);\n\n// This overload prints a (const) wchar_t array compactly.\nGTEST_API_ void UniversalPrintArray(\n    const wchar_t* begin, size_t len, ::std::ostream* os);\n\n// Implements printing an array type T[N].\ntemplate <typename T, size_t N>\nclass UniversalPrinter<T[N]> {\n public:\n  // Prints the given array, omitting some elements when there are too\n  // many.\n  static void Print(const T (&a)[N], ::std::ostream* os) {\n    UniversalPrintArray(a, N, os);\n  }\n};\n\n// Implements printing a reference type T&.\ntemplate <typename T>\nclass UniversalPrinter<T&> {\n public:\n  // MSVC warns about adding const to a function type, so we want to\n  // disable the warning.\n  GTEST_DISABLE_MSC_WARNINGS_PUSH_(4180)\n\n  static void Print(const T& value, ::std::ostream* os) {\n    // Prints the address of the value.  We use reinterpret_cast here\n    // as static_cast doesn't compile when T is a function type.\n    *os << \"@\" << reinterpret_cast<const void*>(&value) << \" \";\n\n    // Then prints the value itself.\n    UniversalPrint(value, os);\n  }\n\n  GTEST_DISABLE_MSC_WARNINGS_POP_()\n};\n\n// Prints a value tersely: for a reference type, the referenced value\n// (but not the address) is printed; for a (const) char pointer, the\n// NUL-terminated string (but not the pointer) is printed.\n\ntemplate <typename T>\nclass UniversalTersePrinter {\n public:\n  static void Print(const T& value, ::std::ostream* os) {\n    UniversalPrint(value, os);\n  }\n};\ntemplate <typename T>\nclass UniversalTersePrinter<T&> {\n public:\n  static void Print(const T& value, ::std::ostream* os) {\n    UniversalPrint(value, os);\n  }\n};\ntemplate <typename T, size_t N>\nclass UniversalTersePrinter<T[N]> {\n public:\n  static void Print(const T (&value)[N], ::std::ostream* os) {\n    UniversalPrinter<T[N]>::Print(value, os);\n  }\n};\ntemplate <>\nclass UniversalTersePrinter<const char*> {\n public:\n  static void Print(const char* str, ::std::ostream* os) {\n    if (str == NULL) {\n      *os << \"NULL\";\n    } else {\n      UniversalPrint(string(str), os);\n    }\n  }\n};\ntemplate <>\nclass UniversalTersePrinter<char*> {\n public:\n  static void Print(char* str, ::std::ostream* os) {\n    UniversalTersePrinter<const char*>::Print(str, os);\n  }\n};\n\n#if GTEST_HAS_STD_WSTRING\ntemplate <>\nclass UniversalTersePrinter<const wchar_t*> {\n public:\n  static void Print(const wchar_t* str, ::std::ostream* os) {\n    if (str == NULL) {\n      *os << \"NULL\";\n    } else {\n      UniversalPrint(::std::wstring(str), os);\n    }\n  }\n};\n#endif\n\ntemplate <>\nclass UniversalTersePrinter<wchar_t*> {\n public:\n  static void Print(wchar_t* str, ::std::ostream* os) {\n    UniversalTersePrinter<const wchar_t*>::Print(str, os);\n  }\n};\n\ntemplate <typename T>\nvoid UniversalTersePrint(const T& value, ::std::ostream* os) {\n  UniversalTersePrinter<T>::Print(value, os);\n}\n\n// Prints a value using the type inferred by the compiler.  The\n// difference between this and UniversalTersePrint() is that for a\n// (const) char pointer, this prints both the pointer and the\n// NUL-terminated string.\ntemplate <typename T>\nvoid UniversalPrint(const T& value, ::std::ostream* os) {\n  // A workarond for the bug in VC++ 7.1 that prevents us from instantiating\n  // UniversalPrinter with T directly.\n  typedef T T1;\n  UniversalPrinter<T1>::Print(value, os);\n}\n\ntypedef ::std::vector<string> Strings;\n\n// TuplePolicy<TupleT> must provide:\n// - tuple_size\n//     size of tuple TupleT.\n// - get<size_t I>(const TupleT& t)\n//     static function extracting element I of tuple TupleT.\n// - tuple_element<size_t I>::type\n//     type of element I of tuple TupleT.\ntemplate <typename TupleT>\nstruct TuplePolicy;\n\n#if GTEST_HAS_TR1_TUPLE\ntemplate <typename TupleT>\nstruct TuplePolicy {\n  typedef TupleT Tuple;\n  static const size_t tuple_size = ::std::tr1::tuple_size<Tuple>::value;\n\n  template <size_t I>\n  struct tuple_element : ::std::tr1::tuple_element<I, Tuple> {};\n\n  template <size_t I>\n  static typename AddReference<\n      const typename ::std::tr1::tuple_element<I, Tuple>::type>::type get(\n      const Tuple& tuple) {\n    return ::std::tr1::get<I>(tuple);\n  }\n};\ntemplate <typename TupleT>\nconst size_t TuplePolicy<TupleT>::tuple_size;\n#endif  // GTEST_HAS_TR1_TUPLE\n\n#if GTEST_HAS_STD_TUPLE_\ntemplate <typename... Types>\nstruct TuplePolicy< ::std::tuple<Types...> > {\n  typedef ::std::tuple<Types...> Tuple;\n  static const size_t tuple_size = ::std::tuple_size<Tuple>::value;\n\n  template <size_t I>\n  struct tuple_element : ::std::tuple_element<I, Tuple> {};\n\n  template <size_t I>\n  static const typename ::std::tuple_element<I, Tuple>::type& get(\n      const Tuple& tuple) {\n    return ::std::get<I>(tuple);\n  }\n};\ntemplate <typename... Types>\nconst size_t TuplePolicy< ::std::tuple<Types...> >::tuple_size;\n#endif  // GTEST_HAS_STD_TUPLE_\n\n#if GTEST_HAS_TR1_TUPLE || GTEST_HAS_STD_TUPLE_\n// This helper template allows PrintTo() for tuples and\n// UniversalTersePrintTupleFieldsToStrings() to be defined by\n// induction on the number of tuple fields.  The idea is that\n// TuplePrefixPrinter<N>::PrintPrefixTo(t, os) prints the first N\n// fields in tuple t, and can be defined in terms of\n// TuplePrefixPrinter<N - 1>.\n//\n// The inductive case.\ntemplate <size_t N>\nstruct TuplePrefixPrinter {\n  // Prints the first N fields of a tuple.\n  template <typename Tuple>\n  static void PrintPrefixTo(const Tuple& t, ::std::ostream* os) {\n    TuplePrefixPrinter<N - 1>::PrintPrefixTo(t, os);\n    GTEST_INTENTIONAL_CONST_COND_PUSH_()\n    if (N > 1) {\n    GTEST_INTENTIONAL_CONST_COND_POP_()\n      *os << \", \";\n    }\n    UniversalPrinter<\n        typename TuplePolicy<Tuple>::template tuple_element<N - 1>::type>\n        ::Print(TuplePolicy<Tuple>::template get<N - 1>(t), os);\n  }\n\n  // Tersely prints the first N fields of a tuple to a string vector,\n  // one element for each field.\n  template <typename Tuple>\n  static void TersePrintPrefixToStrings(const Tuple& t, Strings* strings) {\n    TuplePrefixPrinter<N - 1>::TersePrintPrefixToStrings(t, strings);\n    ::std::stringstream ss;\n    UniversalTersePrint(TuplePolicy<Tuple>::template get<N - 1>(t), &ss);\n    strings->push_back(ss.str());\n  }\n};\n\n// Base case.\ntemplate <>\nstruct TuplePrefixPrinter<0> {\n  template <typename Tuple>\n  static void PrintPrefixTo(const Tuple&, ::std::ostream*) {}\n\n  template <typename Tuple>\n  static void TersePrintPrefixToStrings(const Tuple&, Strings*) {}\n};\n\n// Helper function for printing a tuple.\n// Tuple must be either std::tr1::tuple or std::tuple type.\ntemplate <typename Tuple>\nvoid PrintTupleTo(const Tuple& t, ::std::ostream* os) {\n  *os << \"(\";\n  TuplePrefixPrinter<TuplePolicy<Tuple>::tuple_size>::PrintPrefixTo(t, os);\n  *os << \")\";\n}\n\n// Prints the fields of a tuple tersely to a string vector, one\n// element for each field.  See the comment before\n// UniversalTersePrint() for how we define \"tersely\".\ntemplate <typename Tuple>\nStrings UniversalTersePrintTupleFieldsToStrings(const Tuple& value) {\n  Strings result;\n  TuplePrefixPrinter<TuplePolicy<Tuple>::tuple_size>::\n      TersePrintPrefixToStrings(value, &result);\n  return result;\n}\n#endif  // GTEST_HAS_TR1_TUPLE || GTEST_HAS_STD_TUPLE_\n\n}  // namespace internal\n\ntemplate <typename T>\n::std::string PrintToString(const T& value) {\n  ::std::stringstream ss;\n  internal::UniversalTersePrinter<T>::Print(value, &ss);\n  return ss.str();\n}\n\n}  // namespace testing\n\n// Include any custom printer added by the local installation.\n// We must include this header at the end to make sure it can use the\n// declarations from this file.\n#include \"gtest/internal/custom/gtest-printers.h\"\n\n#endif  // GTEST_INCLUDE_GTEST_GTEST_PRINTERS_H_\n"}, "51": {"id": 51, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest-test-part.h", "content": "// Copyright 2008, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: mheule@google.com (Markus Heule)\n//\n\n#ifndef GTEST_INCLUDE_GTEST_GTEST_TEST_PART_H_\n#define GTEST_INCLUDE_GTEST_GTEST_TEST_PART_H_\n\n#include <iosfwd>\n#include <vector>\n#include \"gtest/internal/gtest-internal.h\"\n#include \"gtest/internal/gtest-string.h\"\n\nnamespace testing {\n\n// A copyable object representing the result of a test part (i.e. an\n// assertion or an explicit FAIL(), ADD_FAILURE(), or SUCCESS()).\n//\n// Don't inherit from TestPartResult as its destructor is not virtual.\nclass GTEST_API_ TestPartResult {\n public:\n  // The possible outcomes of a test part (i.e. an assertion or an\n  // explicit SUCCEED(), FAIL(), or ADD_FAILURE()).\n  enum Type {\n    kSuccess,          // Succeeded.\n    kNonFatalFailure,  // Failed but the test can continue.\n    kFatalFailure      // Failed and the test should be terminated.\n  };\n\n  // C'tor.  TestPartResult does NOT have a default constructor.\n  // Always use this constructor (with parameters) to create a\n  // TestPartResult object.\n  TestPartResult(Type a_type,\n                 const char* a_file_name,\n                 int a_line_number,\n                 const char* a_message)\n      : type_(a_type),\n        file_name_(a_file_name == NULL ? \"\" : a_file_name),\n        line_number_(a_line_number),\n        summary_(ExtractSummary(a_message)),\n        message_(a_message) {\n  }\n\n  // Gets the outcome of the test part.\n  Type type() const { return type_; }\n\n  // Gets the name of the source file where the test part took place, or\n  // NULL if it's unknown.\n  const char* file_name() const {\n    return file_name_.empty() ? NULL : file_name_.c_str();\n  }\n\n  // Gets the line in the source file where the test part took place,\n  // or -1 if it's unknown.\n  int line_number() const { return line_number_; }\n\n  // Gets the summary of the failure message.\n  const char* summary() const { return summary_.c_str(); }\n\n  // Gets the message associated with the test part.\n  const char* message() const { return message_.c_str(); }\n\n  // Returns true iff the test part passed.\n  bool passed() const { return type_ == kSuccess; }\n\n  // Returns true iff the test part failed.\n  bool failed() const { return type_ != kSuccess; }\n\n  // Returns true iff the test part non-fatally failed.\n  bool nonfatally_failed() const { return type_ == kNonFatalFailure; }\n\n  // Returns true iff the test part fatally failed.\n  bool fatally_failed() const { return type_ == kFatalFailure; }\n\n private:\n  Type type_;\n\n  // Gets the summary of the failure message by omitting the stack\n  // trace in it.\n  static std::string ExtractSummary(const char* message);\n\n  // The name of the source file where the test part took place, or\n  // \"\" if the source file is unknown.\n  std::string file_name_;\n  // The line in the source file where the test part took place, or -1\n  // if the line number is unknown.\n  int line_number_;\n  std::string summary_;  // The test failure summary.\n  std::string message_;  // The test failure message.\n};\n\n// Prints a TestPartResult object.\nstd::ostream& operator<<(std::ostream& os, const TestPartResult& result);\n\n// An array of TestPartResult objects.\n//\n// Don't inherit from TestPartResultArray as its destructor is not\n// virtual.\nclass GTEST_API_ TestPartResultArray {\n public:\n  TestPartResultArray() {}\n\n  // Appends the given TestPartResult to the array.\n  void Append(const TestPartResult& result);\n\n  // Returns the TestPartResult at the given index (0-based).\n  const TestPartResult& GetTestPartResult(int index) const;\n\n  // Returns the number of TestPartResult objects in the array.\n  int size() const;\n\n private:\n  std::vector<TestPartResult> array_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestPartResultArray);\n};\n\n// This interface knows how to report a test part result.\nclass TestPartResultReporterInterface {\n public:\n  virtual ~TestPartResultReporterInterface() {}\n\n  virtual void ReportTestPartResult(const TestPartResult& result) = 0;\n};\n\nnamespace internal {\n\n// This helper class is used by {ASSERT|EXPECT}_NO_FATAL_FAILURE to check if a\n// statement generates new fatal failures. To do so it registers itself as the\n// current test part result reporter. Besides checking if fatal failures were\n// reported, it only delegates the reporting to the former result reporter.\n// The original result reporter is restored in the destructor.\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nclass GTEST_API_ HasNewFatalFailureHelper\n    : public TestPartResultReporterInterface {\n public:\n  HasNewFatalFailureHelper();\n  virtual ~HasNewFatalFailureHelper();\n  virtual void ReportTestPartResult(const TestPartResult& result);\n  bool has_new_fatal_failure() const { return has_new_fatal_failure_; }\n private:\n  bool has_new_fatal_failure_;\n  TestPartResultReporterInterface* original_reporter_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(HasNewFatalFailureHelper);\n};\n\n}  // namespace internal\n\n}  // namespace testing\n\n#endif  // GTEST_INCLUDE_GTEST_GTEST_TEST_PART_H_\n"}, "52": {"id": 52, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest-typed-test.h", "content": "// Copyright 2008 Google Inc.\n// All Rights Reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n#ifndef GTEST_INCLUDE_GTEST_GTEST_TYPED_TEST_H_\n#define GTEST_INCLUDE_GTEST_GTEST_TYPED_TEST_H_\n\n// This header implements typed tests and type-parameterized tests.\n\n// Typed (aka type-driven) tests repeat the same test for types in a\n// list.  You must know which types you want to test with when writing\n// typed tests. Here's how you do it:\n\n#if 0\n\n// First, define a fixture class template.  It should be parameterized\n// by a type.  Remember to derive it from testing::Test.\ntemplate <typename T>\nclass FooTest : public testing::Test {\n public:\n  ...\n  typedef std::list<T> List;\n  static T shared_;\n  T value_;\n};\n\n// Next, associate a list of types with the test case, which will be\n// repeated for each type in the list.  The typedef is necessary for\n// the macro to parse correctly.\ntypedef testing::Types<char, int, unsigned int> MyTypes;\nTYPED_TEST_CASE(FooTest, MyTypes);\n\n// If the type list contains only one type, you can write that type\n// directly without Types<...>:\n//   TYPED_TEST_CASE(FooTest, int);\n\n// Then, use TYPED_TEST() instead of TEST_F() to define as many typed\n// tests for this test case as you want.\nTYPED_TEST(FooTest, DoesBlah) {\n  // Inside a test, refer to TypeParam to get the type parameter.\n  // Since we are inside a derived class template, C++ requires use to\n  // visit the members of FooTest via 'this'.\n  TypeParam n = this->value_;\n\n  // To visit static members of the fixture, add the TestFixture::\n  // prefix.\n  n += TestFixture::shared_;\n\n  // To refer to typedefs in the fixture, add the \"typename\n  // TestFixture::\" prefix.\n  typename TestFixture::List values;\n  values.push_back(n);\n  ...\n}\n\nTYPED_TEST(FooTest, HasPropertyA) { ... }\n\n#endif  // 0\n\n// Type-parameterized tests are abstract test patterns parameterized\n// by a type.  Compared with typed tests, type-parameterized tests\n// allow you to define the test pattern without knowing what the type\n// parameters are.  The defined pattern can be instantiated with\n// different types any number of times, in any number of translation\n// units.\n//\n// If you are designing an interface or concept, you can define a\n// suite of type-parameterized tests to verify properties that any\n// valid implementation of the interface/concept should have.  Then,\n// each implementation can easily instantiate the test suite to verify\n// that it conforms to the requirements, without having to write\n// similar tests repeatedly.  Here's an example:\n\n#if 0\n\n// First, define a fixture class template.  It should be parameterized\n// by a type.  Remember to derive it from testing::Test.\ntemplate <typename T>\nclass FooTest : public testing::Test {\n  ...\n};\n\n// Next, declare that you will define a type-parameterized test case\n// (the _P suffix is for \"parameterized\" or \"pattern\", whichever you\n// prefer):\nTYPED_TEST_CASE_P(FooTest);\n\n// Then, use TYPED_TEST_P() to define as many type-parameterized tests\n// for this type-parameterized test case as you want.\nTYPED_TEST_P(FooTest, DoesBlah) {\n  // Inside a test, refer to TypeParam to get the type parameter.\n  TypeParam n = 0;\n  ...\n}\n\nTYPED_TEST_P(FooTest, HasPropertyA) { ... }\n\n// Now the tricky part: you need to register all test patterns before\n// you can instantiate them.  The first argument of the macro is the\n// test case name; the rest are the names of the tests in this test\n// case.\nREGISTER_TYPED_TEST_CASE_P(FooTest,\n                           DoesBlah, HasPropertyA);\n\n// Finally, you are free to instantiate the pattern with the types you\n// want.  If you put the above code in a header file, you can #include\n// it in multiple C++ source files and instantiate it multiple times.\n//\n// To distinguish different instances of the pattern, the first\n// argument to the INSTANTIATE_* macro is a prefix that will be added\n// to the actual test case name.  Remember to pick unique prefixes for\n// different instances.\ntypedef testing::Types<char, int, unsigned int> MyTypes;\nINSTANTIATE_TYPED_TEST_CASE_P(My, FooTest, MyTypes);\n\n// If the type list contains only one type, you can write that type\n// directly without Types<...>:\n//   INSTANTIATE_TYPED_TEST_CASE_P(My, FooTest, int);\n\n#endif  // 0\n\n#include \"gtest/internal/gtest-port.h\"\n#include \"gtest/internal/gtest-type-util.h\"\n\n// Implements typed tests.\n\n#if GTEST_HAS_TYPED_TEST\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// Expands to the name of the typedef for the type parameters of the\n// given test case.\n# define GTEST_TYPE_PARAMS_(TestCaseName) gtest_type_params_##TestCaseName##_\n\n// The 'Types' template argument below must have spaces around it\n// since some compilers may choke on '>>' when passing a template\n// instance (e.g. Types<int>)\n# define TYPED_TEST_CASE(CaseName, Types) \\\n  typedef ::testing::internal::TypeList< Types >::type \\\n      GTEST_TYPE_PARAMS_(CaseName)\n\n# define TYPED_TEST(CaseName, TestName) \\\n  template <typename gtest_TypeParam_> \\\n  class GTEST_TEST_CLASS_NAME_(CaseName, TestName) \\\n      : public CaseName<gtest_TypeParam_> { \\\n   private: \\\n    typedef CaseName<gtest_TypeParam_> TestFixture; \\\n    typedef gtest_TypeParam_ TypeParam; \\\n    virtual void TestBody(); \\\n  }; \\\n  bool gtest_##CaseName##_##TestName##_registered_ GTEST_ATTRIBUTE_UNUSED_ = \\\n      ::testing::internal::TypeParameterizedTest< \\\n          CaseName, \\\n          ::testing::internal::TemplateSel< \\\n              GTEST_TEST_CLASS_NAME_(CaseName, TestName)>, \\\n          GTEST_TYPE_PARAMS_(CaseName)>::Register(\\\n              \"\", ::testing::internal::CodeLocation(__FILE__, __LINE__), \\\n              #CaseName, #TestName, 0); \\\n  template <typename gtest_TypeParam_> \\\n  void GTEST_TEST_CLASS_NAME_(CaseName, TestName)<gtest_TypeParam_>::TestBody()\n\n#endif  // GTEST_HAS_TYPED_TEST\n\n// Implements type-parameterized tests.\n\n#if GTEST_HAS_TYPED_TEST_P\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// Expands to the namespace name that the type-parameterized tests for\n// the given type-parameterized test case are defined in.  The exact\n// name of the namespace is subject to change without notice.\n# define GTEST_CASE_NAMESPACE_(TestCaseName) \\\n  gtest_case_##TestCaseName##_\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// Expands to the name of the variable used to remember the names of\n// the defined tests in the given test case.\n# define GTEST_TYPED_TEST_CASE_P_STATE_(TestCaseName) \\\n  gtest_typed_test_case_p_state_##TestCaseName##_\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE DIRECTLY.\n//\n// Expands to the name of the variable used to remember the names of\n// the registered tests in the given test case.\n# define GTEST_REGISTERED_TEST_NAMES_(TestCaseName) \\\n  gtest_registered_test_names_##TestCaseName##_\n\n// The variables defined in the type-parameterized test macros are\n// static as typically these macros are used in a .h file that can be\n// #included in multiple translation units linked together.\n# define TYPED_TEST_CASE_P(CaseName) \\\n  static ::testing::internal::TypedTestCasePState \\\n      GTEST_TYPED_TEST_CASE_P_STATE_(CaseName)\n\n# define TYPED_TEST_P(CaseName, TestName) \\\n  namespace GTEST_CASE_NAMESPACE_(CaseName) { \\\n  template <typename gtest_TypeParam_> \\\n  class TestName : public CaseName<gtest_TypeParam_> { \\\n   private: \\\n    typedef CaseName<gtest_TypeParam_> TestFixture; \\\n    typedef gtest_TypeParam_ TypeParam; \\\n    virtual void TestBody(); \\\n  }; \\\n  static bool gtest_##TestName##_defined_ GTEST_ATTRIBUTE_UNUSED_ = \\\n      GTEST_TYPED_TEST_CASE_P_STATE_(CaseName).AddTestName(\\\n          __FILE__, __LINE__, #CaseName, #TestName); \\\n  } \\\n  template <typename gtest_TypeParam_> \\\n  void GTEST_CASE_NAMESPACE_(CaseName)::TestName<gtest_TypeParam_>::TestBody()\n\n# define REGISTER_TYPED_TEST_CASE_P(CaseName, ...) \\\n  namespace GTEST_CASE_NAMESPACE_(CaseName) { \\\n  typedef ::testing::internal::Templates<__VA_ARGS__>::type gtest_AllTests_; \\\n  } \\\n  static const char* const GTEST_REGISTERED_TEST_NAMES_(CaseName) = \\\n      GTEST_TYPED_TEST_CASE_P_STATE_(CaseName).VerifyRegisteredTestNames(\\\n          __FILE__, __LINE__, #__VA_ARGS__)\n\n// The 'Types' template argument below must have spaces around it\n// since some compilers may choke on '>>' when passing a template\n// instance (e.g. Types<int>)\n# define INSTANTIATE_TYPED_TEST_CASE_P(Prefix, CaseName, Types) \\\n  bool gtest_##Prefix##_##CaseName GTEST_ATTRIBUTE_UNUSED_ = \\\n      ::testing::internal::TypeParameterizedTestCase<CaseName, \\\n          GTEST_CASE_NAMESPACE_(CaseName)::gtest_AllTests_, \\\n          ::testing::internal::TypeList< Types >::type>::Register(\\\n              #Prefix, \\\n              ::testing::internal::CodeLocation(__FILE__, __LINE__), \\\n              &GTEST_TYPED_TEST_CASE_P_STATE_(CaseName), \\\n              #CaseName, GTEST_REGISTERED_TEST_NAMES_(CaseName))\n\n#endif  // GTEST_HAS_TYPED_TEST_P\n\n#endif  // GTEST_INCLUDE_GTEST_GTEST_TYPED_TEST_H_\n"}, "53": {"id": 53, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n//\n// The Google C++ Testing Framework (Google Test)\n//\n// This header file defines the public API for Google Test.  It should be\n// included by any test program that uses Google Test.\n//\n// IMPORTANT NOTE: Due to limitation of the C++ language, we have to\n// leave some internal implementation details in this header file.\n// They are clearly marked by comments like this:\n//\n//   // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n//\n// Such code is NOT meant to be used by a user directly, and is subject\n// to CHANGE WITHOUT NOTICE.  Therefore DO NOT DEPEND ON IT in a user\n// program!\n//\n// Acknowledgment: Google Test borrowed the idea of automatic test\n// registration from Barthelemy Dagenais' (barthelemy@prologique.com)\n// easyUnit framework.\n\n#ifndef GTEST_INCLUDE_GTEST_GTEST_H_\n#define GTEST_INCLUDE_GTEST_GTEST_H_\n\n#include <limits>\n#include <ostream>\n#include <vector>\n\n#include \"gtest/internal/gtest-internal.h\"\n#include \"gtest/internal/gtest-string.h\"\n#include \"gtest/gtest-death-test.h\"\n#include \"gtest/gtest-message.h\"\n#include \"gtest/gtest-param-test.h\"\n#include \"gtest/gtest-printers.h\"\n#include \"gtest/gtest_prod.h\"\n#include \"gtest/gtest-test-part.h\"\n#include \"gtest/gtest-typed-test.h\"\n\n// Depending on the platform, different string classes are available.\n// On Linux, in addition to ::std::string, Google also makes use of\n// class ::string, which has the same interface as ::std::string, but\n// has a different implementation.\n//\n// You can define GTEST_HAS_GLOBAL_STRING to 1 to indicate that\n// ::string is available AND is a distinct type to ::std::string, or\n// define it to 0 to indicate otherwise.\n//\n// If ::std::string and ::string are the same class on your platform\n// due to aliasing, you should define GTEST_HAS_GLOBAL_STRING to 0.\n//\n// If you do not define GTEST_HAS_GLOBAL_STRING, it is defined\n// heuristically.\n\nnamespace testing {\n\n// Declares the flags.\n\n// This flag temporary enables the disabled tests.\nGTEST_DECLARE_bool_(also_run_disabled_tests);\n\n// This flag brings the debugger on an assertion failure.\nGTEST_DECLARE_bool_(break_on_failure);\n\n// This flag controls whether Google Test catches all test-thrown exceptions\n// and logs them as failures.\nGTEST_DECLARE_bool_(catch_exceptions);\n\n// This flag enables using colors in terminal output. Available values are\n// \"yes\" to enable colors, \"no\" (disable colors), or \"auto\" (the default)\n// to let Google Test decide.\nGTEST_DECLARE_string_(color);\n\n// This flag sets up the filter to select by name using a glob pattern\n// the tests to run. If the filter is not given all tests are executed.\nGTEST_DECLARE_string_(filter);\n\n// This flag causes the Google Test to list tests. None of the tests listed\n// are actually run if the flag is provided.\nGTEST_DECLARE_bool_(list_tests);\n\n// This flag controls whether Google Test emits a detailed XML report to a file\n// in addition to its normal textual output.\nGTEST_DECLARE_string_(output);\n\n// This flags control whether Google Test prints the elapsed time for each\n// test.\nGTEST_DECLARE_bool_(print_time);\n\n// This flag specifies the random number seed.\nGTEST_DECLARE_int32_(random_seed);\n\n// This flag sets how many times the tests are repeated. The default value\n// is 1. If the value is -1 the tests are repeating forever.\nGTEST_DECLARE_int32_(repeat);\n\n// This flag controls whether Google Test includes Google Test internal\n// stack frames in failure stack traces.\nGTEST_DECLARE_bool_(show_internal_stack_frames);\n\n// When this flag is specified, tests' order is randomized on every iteration.\nGTEST_DECLARE_bool_(shuffle);\n\n// This flag specifies the maximum number of stack frames to be\n// printed in a failure message.\nGTEST_DECLARE_int32_(stack_trace_depth);\n\n// When this flag is specified, a failed assertion will throw an\n// exception if exceptions are enabled, or exit the program with a\n// non-zero code otherwise.\nGTEST_DECLARE_bool_(throw_on_failure);\n\n// When this flag is set with a \"host:port\" string, on supported\n// platforms test results are streamed to the specified port on\n// the specified host machine.\nGTEST_DECLARE_string_(stream_result_to);\n\n// The upper limit for valid stack trace depths.\nconst int kMaxStackTraceDepth = 100;\n\nnamespace internal {\n\nclass AssertHelper;\nclass DefaultGlobalTestPartResultReporter;\nclass ExecDeathTest;\nclass NoExecDeathTest;\nclass FinalSuccessChecker;\nclass GTestFlagSaver;\nclass StreamingListenerTest;\nclass TestResultAccessor;\nclass TestEventListenersAccessor;\nclass TestEventRepeater;\nclass UnitTestRecordPropertyTestHelper;\nclass WindowsDeathTest;\nclass UnitTestImpl* GetUnitTestImpl();\nvoid ReportFailureInUnknownLocation(TestPartResult::Type result_type,\n                                    const std::string& message);\n\n}  // namespace internal\n\n// The friend relationship of some of these classes is cyclic.\n// If we don't forward declare them the compiler might confuse the classes\n// in friendship clauses with same named classes on the scope.\nclass Test;\nclass TestCase;\nclass TestInfo;\nclass UnitTest;\n\n// A class for indicating whether an assertion was successful.  When\n// the assertion wasn't successful, the AssertionResult object\n// remembers a non-empty message that describes how it failed.\n//\n// To create an instance of this class, use one of the factory functions\n// (AssertionSuccess() and AssertionFailure()).\n//\n// This class is useful for two purposes:\n//   1. Defining predicate functions to be used with Boolean test assertions\n//      EXPECT_TRUE/EXPECT_FALSE and their ASSERT_ counterparts\n//   2. Defining predicate-format functions to be\n//      used with predicate assertions (ASSERT_PRED_FORMAT*, etc).\n//\n// For example, if you define IsEven predicate:\n//\n//   testing::AssertionResult IsEven(int n) {\n//     if ((n % 2) == 0)\n//       return testing::AssertionSuccess();\n//     else\n//       return testing::AssertionFailure() << n << \" is odd\";\n//   }\n//\n// Then the failed expectation EXPECT_TRUE(IsEven(Fib(5)))\n// will print the message\n//\n//   Value of: IsEven(Fib(5))\n//     Actual: false (5 is odd)\n//   Expected: true\n//\n// instead of a more opaque\n//\n//   Value of: IsEven(Fib(5))\n//     Actual: false\n//   Expected: true\n//\n// in case IsEven is a simple Boolean predicate.\n//\n// If you expect your predicate to be reused and want to support informative\n// messages in EXPECT_FALSE and ASSERT_FALSE (negative assertions show up\n// about half as often as positive ones in our tests), supply messages for\n// both success and failure cases:\n//\n//   testing::AssertionResult IsEven(int n) {\n//     if ((n % 2) == 0)\n//       return testing::AssertionSuccess() << n << \" is even\";\n//     else\n//       return testing::AssertionFailure() << n << \" is odd\";\n//   }\n//\n// Then a statement EXPECT_FALSE(IsEven(Fib(6))) will print\n//\n//   Value of: IsEven(Fib(6))\n//     Actual: true (8 is even)\n//   Expected: false\n//\n// NB: Predicates that support negative Boolean assertions have reduced\n// performance in positive ones so be careful not to use them in tests\n// that have lots (tens of thousands) of positive Boolean assertions.\n//\n// To use this class with EXPECT_PRED_FORMAT assertions such as:\n//\n//   // Verifies that Foo() returns an even number.\n//   EXPECT_PRED_FORMAT1(IsEven, Foo());\n//\n// you need to define:\n//\n//   testing::AssertionResult IsEven(const char* expr, int n) {\n//     if ((n % 2) == 0)\n//       return testing::AssertionSuccess();\n//     else\n//       return testing::AssertionFailure()\n//         << \"Expected: \" << expr << \" is even\\n  Actual: it's \" << n;\n//   }\n//\n// If Foo() returns 5, you will see the following message:\n//\n//   Expected: Foo() is even\n//     Actual: it's 5\n//\nclass GTEST_API_ AssertionResult {\n public:\n  // Copy constructor.\n  // Used in EXPECT_TRUE/FALSE(assertion_result).\n  AssertionResult(const AssertionResult& other);\n\n  GTEST_DISABLE_MSC_WARNINGS_PUSH_(4800 /* forcing value to bool */)\n\n  // Used in the EXPECT_TRUE/FALSE(bool_expression).\n  //\n  // T must be contextually convertible to bool.\n  //\n  // The second parameter prevents this overload from being considered if\n  // the argument is implicitly convertible to AssertionResult. In that case\n  // we want AssertionResult's copy constructor to be used.\n  template <typename T>\n  explicit AssertionResult(\n      const T& success,\n      typename internal::EnableIf<\n          !internal::ImplicitlyConvertible<T, AssertionResult>::value>::type*\n          /*enabler*/ = NULL)\n      : success_(success) {}\n\n  GTEST_DISABLE_MSC_WARNINGS_POP_()\n\n  // Assignment operator.\n  AssertionResult& operator=(AssertionResult other) {\n    swap(other);\n    return *this;\n  }\n\n  // Returns true iff the assertion succeeded.\n  operator bool() const { return success_; }  // NOLINT\n\n  // Returns the assertion's negation. Used with EXPECT/ASSERT_FALSE.\n  AssertionResult operator!() const;\n\n  // Returns the text streamed into this AssertionResult. Test assertions\n  // use it when they fail (i.e., the predicate's outcome doesn't match the\n  // assertion's expectation). When nothing has been streamed into the\n  // object, returns an empty string.\n  const char* message() const {\n    return message_.get() != NULL ?  message_->c_str() : \"\";\n  }\n  // TODO(vladl@google.com): Remove this after making sure no clients use it.\n  // Deprecated; please use message() instead.\n  const char* failure_message() const { return message(); }\n\n  // Streams a custom failure message into this object.\n  template <typename T> AssertionResult& operator<<(const T& value) {\n    AppendMessage(Message() << value);\n    return *this;\n  }\n\n  // Allows streaming basic output manipulators such as endl or flush into\n  // this object.\n  AssertionResult& operator<<(\n      ::std::ostream& (*basic_manipulator)(::std::ostream& stream)) {\n    AppendMessage(Message() << basic_manipulator);\n    return *this;\n  }\n\n private:\n  // Appends the contents of message to message_.\n  void AppendMessage(const Message& a_message) {\n    if (message_.get() == NULL)\n      message_.reset(new ::std::string);\n    message_->append(a_message.GetString().c_str());\n  }\n\n  // Swap the contents of this AssertionResult with other.\n  void swap(AssertionResult& other);\n\n  // Stores result of the assertion predicate.\n  bool success_;\n  // Stores the message describing the condition in case the expectation\n  // construct is not satisfied with the predicate's outcome.\n  // Referenced via a pointer to avoid taking too much stack frame space\n  // with test assertions.\n  internal::scoped_ptr< ::std::string> message_;\n};\n\n// Makes a successful assertion result.\nGTEST_API_ AssertionResult AssertionSuccess();\n\n// Makes a failed assertion result.\nGTEST_API_ AssertionResult AssertionFailure();\n\n// Makes a failed assertion result with the given failure message.\n// Deprecated; use AssertionFailure() << msg.\nGTEST_API_ AssertionResult AssertionFailure(const Message& msg);\n\n// The abstract class that all tests inherit from.\n//\n// In Google Test, a unit test program contains one or many TestCases, and\n// each TestCase contains one or many Tests.\n//\n// When you define a test using the TEST macro, you don't need to\n// explicitly derive from Test - the TEST macro automatically does\n// this for you.\n//\n// The only time you derive from Test is when defining a test fixture\n// to be used a TEST_F.  For example:\n//\n//   class FooTest : public testing::Test {\n//    protected:\n//     void SetUp() override { ... }\n//     void TearDown() override { ... }\n//     ...\n//   };\n//\n//   TEST_F(FooTest, Bar) { ... }\n//   TEST_F(FooTest, Baz) { ... }\n//\n// Test is not copyable.\nclass GTEST_API_ Test {\n public:\n  friend class TestInfo;\n\n  // Defines types for pointers to functions that set up and tear down\n  // a test case.\n  typedef internal::SetUpTestCaseFunc SetUpTestCaseFunc;\n  typedef internal::TearDownTestCaseFunc TearDownTestCaseFunc;\n\n  // The d'tor is virtual as we intend to inherit from Test.\n  virtual ~Test();\n\n  // Sets up the stuff shared by all tests in this test case.\n  //\n  // Google Test will call Foo::SetUpTestCase() before running the first\n  // test in test case Foo.  Hence a sub-class can define its own\n  // SetUpTestCase() method to shadow the one defined in the super\n  // class.\n  static void SetUpTestCase() {}\n\n  // Tears down the stuff shared by all tests in this test case.\n  //\n  // Google Test will call Foo::TearDownTestCase() after running the last\n  // test in test case Foo.  Hence a sub-class can define its own\n  // TearDownTestCase() method to shadow the one defined in the super\n  // class.\n  static void TearDownTestCase() {}\n\n  // Returns true iff the current test has a fatal failure.\n  static bool HasFatalFailure();\n\n  // Returns true iff the current test has a non-fatal failure.\n  static bool HasNonfatalFailure();\n\n  // Returns true iff the current test has a (either fatal or\n  // non-fatal) failure.\n  static bool HasFailure() { return HasFatalFailure() || HasNonfatalFailure(); }\n\n  // Logs a property for the current test, test case, or for the entire\n  // invocation of the test program when used outside of the context of a\n  // test case.  Only the last value for a given key is remembered.  These\n  // are public static so they can be called from utility functions that are\n  // not members of the test fixture.  Calls to RecordProperty made during\n  // lifespan of the test (from the moment its constructor starts to the\n  // moment its destructor finishes) will be output in XML as attributes of\n  // the <testcase> element.  Properties recorded from fixture's\n  // SetUpTestCase or TearDownTestCase are logged as attributes of the\n  // corresponding <testsuite> element.  Calls to RecordProperty made in the\n  // global context (before or after invocation of RUN_ALL_TESTS and from\n  // SetUp/TearDown method of Environment objects registered with Google\n  // Test) will be output as attributes of the <testsuites> element.\n  static void RecordProperty(const std::string& key, const std::string& value);\n  static void RecordProperty(const std::string& key, int value);\n\n protected:\n  // Creates a Test object.\n  Test();\n\n  // Sets up the test fixture.\n  virtual void SetUp();\n\n  // Tears down the test fixture.\n  virtual void TearDown();\n\n private:\n  // Returns true iff the current test has the same fixture class as\n  // the first test in the current test case.\n  static bool HasSameFixtureClass();\n\n  // Runs the test after the test fixture has been set up.\n  //\n  // A sub-class must implement this to define the test logic.\n  //\n  // DO NOT OVERRIDE THIS FUNCTION DIRECTLY IN A USER PROGRAM.\n  // Instead, use the TEST or TEST_F macro.\n  virtual void TestBody() = 0;\n\n  // Sets up, executes, and tears down the test.\n  void Run();\n\n  // Deletes self.  We deliberately pick an unusual name for this\n  // internal method to avoid clashing with names used in user TESTs.\n  void DeleteSelf_() { delete this; }\n\n  const internal::scoped_ptr< GTEST_FLAG_SAVER_ > gtest_flag_saver_;\n\n  // Often a user misspells SetUp() as Setup() and spends a long time\n  // wondering why it is never called by Google Test.  The declaration of\n  // the following method is solely for catching such an error at\n  // compile time:\n  //\n  //   - The return type is deliberately chosen to be not void, so it\n  //   will be a conflict if void Setup() is declared in the user's\n  //   test fixture.\n  //\n  //   - This method is private, so it will be another compiler error\n  //   if the method is called from the user's test fixture.\n  //\n  // DO NOT OVERRIDE THIS FUNCTION.\n  //\n  // If you see an error about overriding the following function or\n  // about it being private, you have mis-spelled SetUp() as Setup().\n  struct Setup_should_be_spelled_SetUp {};\n  virtual Setup_should_be_spelled_SetUp* Setup() { return NULL; }\n\n  // We disallow copying Tests.\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Test);\n};\n\ntypedef internal::TimeInMillis TimeInMillis;\n\n// A copyable object representing a user specified test property which can be\n// output as a key/value string pair.\n//\n// Don't inherit from TestProperty as its destructor is not virtual.\nclass TestProperty {\n public:\n  // C'tor.  TestProperty does NOT have a default constructor.\n  // Always use this constructor (with parameters) to create a\n  // TestProperty object.\n  TestProperty(const std::string& a_key, const std::string& a_value) :\n    key_(a_key), value_(a_value) {\n  }\n\n  // Gets the user supplied key.\n  const char* key() const {\n    return key_.c_str();\n  }\n\n  // Gets the user supplied value.\n  const char* value() const {\n    return value_.c_str();\n  }\n\n  // Sets a new value, overriding the one supplied in the constructor.\n  void SetValue(const std::string& new_value) {\n    value_ = new_value;\n  }\n\n private:\n  // The key supplied by the user.\n  std::string key_;\n  // The value supplied by the user.\n  std::string value_;\n};\n\n// The result of a single Test.  This includes a list of\n// TestPartResults, a list of TestProperties, a count of how many\n// death tests there are in the Test, and how much time it took to run\n// the Test.\n//\n// TestResult is not copyable.\nclass GTEST_API_ TestResult {\n public:\n  // Creates an empty TestResult.\n  TestResult();\n\n  // D'tor.  Do not inherit from TestResult.\n  ~TestResult();\n\n  // Gets the number of all test parts.  This is the sum of the number\n  // of successful test parts and the number of failed test parts.\n  int total_part_count() const;\n\n  // Returns the number of the test properties.\n  int test_property_count() const;\n\n  // Returns true iff the test passed (i.e. no test part failed).\n  bool Passed() const { return !Failed(); }\n\n  // Returns true iff the test failed.\n  bool Failed() const;\n\n  // Returns true iff the test fatally failed.\n  bool HasFatalFailure() const;\n\n  // Returns true iff the test has a non-fatal failure.\n  bool HasNonfatalFailure() const;\n\n  // Returns the elapsed time, in milliseconds.\n  TimeInMillis elapsed_time() const { return elapsed_time_; }\n\n  // Returns the i-th test part result among all the results. i can range\n  // from 0 to test_property_count() - 1. If i is not in that range, aborts\n  // the program.\n  const TestPartResult& GetTestPartResult(int i) const;\n\n  // Returns the i-th test property. i can range from 0 to\n  // test_property_count() - 1. If i is not in that range, aborts the\n  // program.\n  const TestProperty& GetTestProperty(int i) const;\n\n private:\n  friend class TestInfo;\n  friend class TestCase;\n  friend class UnitTest;\n  friend class internal::DefaultGlobalTestPartResultReporter;\n  friend class internal::ExecDeathTest;\n  friend class internal::TestResultAccessor;\n  friend class internal::UnitTestImpl;\n  friend class internal::WindowsDeathTest;\n\n  // Gets the vector of TestPartResults.\n  const std::vector<TestPartResult>& test_part_results() const {\n    return test_part_results_;\n  }\n\n  // Gets the vector of TestProperties.\n  const std::vector<TestProperty>& test_properties() const {\n    return test_properties_;\n  }\n\n  // Sets the elapsed time.\n  void set_elapsed_time(TimeInMillis elapsed) { elapsed_time_ = elapsed; }\n\n  // Adds a test property to the list. The property is validated and may add\n  // a non-fatal failure if invalid (e.g., if it conflicts with reserved\n  // key names). If a property is already recorded for the same key, the\n  // value will be updated, rather than storing multiple values for the same\n  // key.  xml_element specifies the element for which the property is being\n  // recorded and is used for validation.\n  void RecordProperty(const std::string& xml_element,\n                      const TestProperty& test_property);\n\n  // Adds a failure if the key is a reserved attribute of Google Test\n  // testcase tags.  Returns true if the property is valid.\n  // TODO(russr): Validate attribute names are legal and human readable.\n  static bool ValidateTestProperty(const std::string& xml_element,\n                                   const TestProperty& test_property);\n\n  // Adds a test part result to the list.\n  void AddTestPartResult(const TestPartResult& test_part_result);\n\n  // Returns the death test count.\n  int death_test_count() const { return death_test_count_; }\n\n  // Increments the death test count, returning the new count.\n  int increment_death_test_count() { return ++death_test_count_; }\n\n  // Clears the test part results.\n  void ClearTestPartResults();\n\n  // Clears the object.\n  void Clear();\n\n  // Protects mutable state of the property vector and of owned\n  // properties, whose values may be updated.\n  internal::Mutex test_properites_mutex_;\n\n  // The vector of TestPartResults\n  std::vector<TestPartResult> test_part_results_;\n  // The vector of TestProperties\n  std::vector<TestProperty> test_properties_;\n  // Running count of death tests.\n  int death_test_count_;\n  // The elapsed time, in milliseconds.\n  TimeInMillis elapsed_time_;\n\n  // We disallow copying TestResult.\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestResult);\n};  // class TestResult\n\n// A TestInfo object stores the following information about a test:\n//\n//   Test case name\n//   Test name\n//   Whether the test should be run\n//   A function pointer that creates the test object when invoked\n//   Test result\n//\n// The constructor of TestInfo registers itself with the UnitTest\n// singleton such that the RUN_ALL_TESTS() macro knows which tests to\n// run.\nclass GTEST_API_ TestInfo {\n public:\n  // Destructs a TestInfo object.  This function is not virtual, so\n  // don't inherit from TestInfo.\n  ~TestInfo();\n\n  // Returns the test case name.\n  const char* test_case_name() const { return test_case_name_.c_str(); }\n\n  // Returns the test name.\n  const char* name() const { return name_.c_str(); }\n\n  // Returns the name of the parameter type, or NULL if this is not a typed\n  // or a type-parameterized test.\n  const char* type_param() const {\n    if (type_param_.get() != NULL)\n      return type_param_->c_str();\n    return NULL;\n  }\n\n  // Returns the text representation of the value parameter, or NULL if this\n  // is not a value-parameterized test.\n  const char* value_param() const {\n    if (value_param_.get() != NULL)\n      return value_param_->c_str();\n    return NULL;\n  }\n\n  // Returns the file name where this test is defined.\n  const char* file() const { return location_.file.c_str(); }\n\n  // Returns the line where this test is defined.\n  int line() const { return location_.line; }\n\n  // Returns true if this test should run, that is if the test is not\n  // disabled (or it is disabled but the also_run_disabled_tests flag has\n  // been specified) and its full name matches the user-specified filter.\n  //\n  // Google Test allows the user to filter the tests by their full names.\n  // The full name of a test Bar in test case Foo is defined as\n  // \"Foo.Bar\".  Only the tests that match the filter will run.\n  //\n  // A filter is a colon-separated list of glob (not regex) patterns,\n  // optionally followed by a '-' and a colon-separated list of\n  // negative patterns (tests to exclude).  A test is run if it\n  // matches one of the positive patterns and does not match any of\n  // the negative patterns.\n  //\n  // For example, *A*:Foo.* is a filter that matches any string that\n  // contains the character 'A' or starts with \"Foo.\".\n  bool should_run() const { return should_run_; }\n\n  // Returns true iff this test will appear in the XML report.\n  bool is_reportable() const {\n    // For now, the XML report includes all tests matching the filter.\n    // In the future, we may trim tests that are excluded because of\n    // sharding.\n    return matches_filter_;\n  }\n\n  // Returns the result of the test.\n  const TestResult* result() const { return &result_; }\n\n private:\n#if GTEST_HAS_DEATH_TEST\n  friend class internal::DefaultDeathTestFactory;\n#endif  // GTEST_HAS_DEATH_TEST\n  friend class Test;\n  friend class TestCase;\n  friend class internal::UnitTestImpl;\n  friend class internal::StreamingListenerTest;\n  friend TestInfo* internal::MakeAndRegisterTestInfo(\n      const char* test_case_name,\n      const char* name,\n      const char* type_param,\n      const char* value_param,\n      internal::CodeLocation code_location,\n      internal::TypeId fixture_class_id,\n      Test::SetUpTestCaseFunc set_up_tc,\n      Test::TearDownTestCaseFunc tear_down_tc,\n      internal::TestFactoryBase* factory);\n\n  // Constructs a TestInfo object. The newly constructed instance assumes\n  // ownership of the factory object.\n  TestInfo(const std::string& test_case_name,\n           const std::string& name,\n           const char* a_type_param,   // NULL if not a type-parameterized test\n           const char* a_value_param,  // NULL if not a value-parameterized test\n           internal::CodeLocation a_code_location,\n           internal::TypeId fixture_class_id,\n           internal::TestFactoryBase* factory);\n\n  // Increments the number of death tests encountered in this test so\n  // far.\n  int increment_death_test_count() {\n    return result_.increment_death_test_count();\n  }\n\n  // Creates the test object, runs it, records its result, and then\n  // deletes it.\n  void Run();\n\n  static void ClearTestResult(TestInfo* test_info) {\n    test_info->result_.Clear();\n  }\n\n  // These fields are immutable properties of the test.\n  const std::string test_case_name_;     // Test case name\n  const std::string name_;               // Test name\n  // Name of the parameter type, or NULL if this is not a typed or a\n  // type-parameterized test.\n  const internal::scoped_ptr<const ::std::string> type_param_;\n  // Text representation of the value parameter, or NULL if this is not a\n  // value-parameterized test.\n  const internal::scoped_ptr<const ::std::string> value_param_;\n  internal::CodeLocation location_;\n  const internal::TypeId fixture_class_id_;   // ID of the test fixture class\n  bool should_run_;                 // True iff this test should run\n  bool is_disabled_;                // True iff this test is disabled\n  bool matches_filter_;             // True if this test matches the\n                                    // user-specified filter.\n  internal::TestFactoryBase* const factory_;  // The factory that creates\n                                              // the test object\n\n  // This field is mutable and needs to be reset before running the\n  // test for the second time.\n  TestResult result_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestInfo);\n};\n\n// A test case, which consists of a vector of TestInfos.\n//\n// TestCase is not copyable.\nclass GTEST_API_ TestCase {\n public:\n  // Creates a TestCase with the given name.\n  //\n  // TestCase does NOT have a default constructor.  Always use this\n  // constructor to create a TestCase object.\n  //\n  // Arguments:\n  //\n  //   name:         name of the test case\n  //   a_type_param: the name of the test's type parameter, or NULL if\n  //                 this is not a type-parameterized test.\n  //   set_up_tc:    pointer to the function that sets up the test case\n  //   tear_down_tc: pointer to the function that tears down the test case\n  TestCase(const char* name, const char* a_type_param,\n           Test::SetUpTestCaseFunc set_up_tc,\n           Test::TearDownTestCaseFunc tear_down_tc);\n\n  // Destructor of TestCase.\n  virtual ~TestCase();\n\n  // Gets the name of the TestCase.\n  const char* name() const { return name_.c_str(); }\n\n  // Returns the name of the parameter type, or NULL if this is not a\n  // type-parameterized test case.\n  const char* type_param() const {\n    if (type_param_.get() != NULL)\n      return type_param_->c_str();\n    return NULL;\n  }\n\n  // Returns true if any test in this test case should run.\n  bool should_run() const { return should_run_; }\n\n  // Gets the number of successful tests in this test case.\n  int successful_test_count() const;\n\n  // Gets the number of failed tests in this test case.\n  int failed_test_count() const;\n\n  // Gets the number of disabled tests that will be reported in the XML report.\n  int reportable_disabled_test_count() const;\n\n  // Gets the number of disabled tests in this test case.\n  int disabled_test_count() const;\n\n  // Gets the number of tests to be printed in the XML report.\n  int reportable_test_count() const;\n\n  // Get the number of tests in this test case that should run.\n  int test_to_run_count() const;\n\n  // Gets the number of all tests in this test case.\n  int total_test_count() const;\n\n  // Returns true iff the test case passed.\n  bool Passed() const { return !Failed(); }\n\n  // Returns true iff the test case failed.\n  bool Failed() const { return failed_test_count() > 0; }\n\n  // Returns the elapsed time, in milliseconds.\n  TimeInMillis elapsed_time() const { return elapsed_time_; }\n\n  // Returns the i-th test among all the tests. i can range from 0 to\n  // total_test_count() - 1. If i is not in that range, returns NULL.\n  const TestInfo* GetTestInfo(int i) const;\n\n  // Returns the TestResult that holds test properties recorded during\n  // execution of SetUpTestCase and TearDownTestCase.\n  const TestResult& ad_hoc_test_result() const { return ad_hoc_test_result_; }\n\n private:\n  friend class Test;\n  friend class internal::UnitTestImpl;\n\n  // Gets the (mutable) vector of TestInfos in this TestCase.\n  std::vector<TestInfo*>& test_info_list() { return test_info_list_; }\n\n  // Gets the (immutable) vector of TestInfos in this TestCase.\n  const std::vector<TestInfo*>& test_info_list() const {\n    return test_info_list_;\n  }\n\n  // Returns the i-th test among all the tests. i can range from 0 to\n  // total_test_count() - 1. If i is not in that range, returns NULL.\n  TestInfo* GetMutableTestInfo(int i);\n\n  // Sets the should_run member.\n  void set_should_run(bool should) { should_run_ = should; }\n\n  // Adds a TestInfo to this test case.  Will delete the TestInfo upon\n  // destruction of the TestCase object.\n  void AddTestInfo(TestInfo * test_info);\n\n  // Clears the results of all tests in this test case.\n  void ClearResult();\n\n  // Clears the results of all tests in the given test case.\n  static void ClearTestCaseResult(TestCase* test_case) {\n    test_case->ClearResult();\n  }\n\n  // Runs every test in this TestCase.\n  void Run();\n\n  // Runs SetUpTestCase() for this TestCase.  This wrapper is needed\n  // for catching exceptions thrown from SetUpTestCase().\n  void RunSetUpTestCase() { (*set_up_tc_)(); }\n\n  // Runs TearDownTestCase() for this TestCase.  This wrapper is\n  // needed for catching exceptions thrown from TearDownTestCase().\n  void RunTearDownTestCase() { (*tear_down_tc_)(); }\n\n  // Returns true iff test passed.\n  static bool TestPassed(const TestInfo* test_info) {\n    return test_info->should_run() && test_info->result()->Passed();\n  }\n\n  // Returns true iff test failed.\n  static bool TestFailed(const TestInfo* test_info) {\n    return test_info->should_run() && test_info->result()->Failed();\n  }\n\n  // Returns true iff the test is disabled and will be reported in the XML\n  // report.\n  static bool TestReportableDisabled(const TestInfo* test_info) {\n    return test_info->is_reportable() && test_info->is_disabled_;\n  }\n\n  // Returns true iff test is disabled.\n  static bool TestDisabled(const TestInfo* test_info) {\n    return test_info->is_disabled_;\n  }\n\n  // Returns true iff this test will appear in the XML report.\n  static bool TestReportable(const TestInfo* test_info) {\n    return test_info->is_reportable();\n  }\n\n  // Returns true if the given test should run.\n  static bool ShouldRunTest(const TestInfo* test_info) {\n    return test_info->should_run();\n  }\n\n  // Shuffles the tests in this test case.\n  void ShuffleTests(internal::Random* random);\n\n  // Restores the test order to before the first shuffle.\n  void UnshuffleTests();\n\n  // Name of the test case.\n  std::string name_;\n  // Name of the parameter type, or NULL if this is not a typed or a\n  // type-parameterized test.\n  const internal::scoped_ptr<const ::std::string> type_param_;\n  // The vector of TestInfos in their original order.  It owns the\n  // elements in the vector.\n  std::vector<TestInfo*> test_info_list_;\n  // Provides a level of indirection for the test list to allow easy\n  // shuffling and restoring the test order.  The i-th element in this\n  // vector is the index of the i-th test in the shuffled test list.\n  std::vector<int> test_indices_;\n  // Pointer to the function that sets up the test case.\n  Test::SetUpTestCaseFunc set_up_tc_;\n  // Pointer to the function that tears down the test case.\n  Test::TearDownTestCaseFunc tear_down_tc_;\n  // True iff any test in this test case should run.\n  bool should_run_;\n  // Elapsed time, in milliseconds.\n  TimeInMillis elapsed_time_;\n  // Holds test properties recorded during execution of SetUpTestCase and\n  // TearDownTestCase.\n  TestResult ad_hoc_test_result_;\n\n  // We disallow copying TestCases.\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestCase);\n};\n\n// An Environment object is capable of setting up and tearing down an\n// environment.  You should subclass this to define your own\n// environment(s).\n//\n// An Environment object does the set-up and tear-down in virtual\n// methods SetUp() and TearDown() instead of the constructor and the\n// destructor, as:\n//\n//   1. You cannot safely throw from a destructor.  This is a problem\n//      as in some cases Google Test is used where exceptions are enabled, and\n//      we may want to implement ASSERT_* using exceptions where they are\n//      available.\n//   2. You cannot use ASSERT_* directly in a constructor or\n//      destructor.\nclass Environment {\n public:\n  // The d'tor is virtual as we need to subclass Environment.\n  virtual ~Environment() {}\n\n  // Override this to define how to set up the environment.\n  virtual void SetUp() {}\n\n  // Override this to define how to tear down the environment.\n  virtual void TearDown() {}\n private:\n  // If you see an error about overriding the following function or\n  // about it being private, you have mis-spelled SetUp() as Setup().\n  struct Setup_should_be_spelled_SetUp {};\n  virtual Setup_should_be_spelled_SetUp* Setup() { return NULL; }\n};\n\n// The interface for tracing execution of tests. The methods are organized in\n// the order the corresponding events are fired.\nclass TestEventListener {\n public:\n  virtual ~TestEventListener() {}\n\n  // Fired before any test activity starts.\n  virtual void OnTestProgramStart(const UnitTest& unit_test) = 0;\n\n  // Fired before each iteration of tests starts.  There may be more than\n  // one iteration if GTEST_FLAG(repeat) is set. iteration is the iteration\n  // index, starting from 0.\n  virtual void OnTestIterationStart(const UnitTest& unit_test,\n                                    int iteration) = 0;\n\n  // Fired before environment set-up for each iteration of tests starts.\n  virtual void OnEnvironmentsSetUpStart(const UnitTest& unit_test) = 0;\n\n  // Fired after environment set-up for each iteration of tests ends.\n  virtual void OnEnvironmentsSetUpEnd(const UnitTest& unit_test) = 0;\n\n  // Fired before the test case starts.\n  virtual void OnTestCaseStart(const TestCase& test_case) = 0;\n\n  // Fired before the test starts.\n  virtual void OnTestStart(const TestInfo& test_info) = 0;\n\n  // Fired after a failed assertion or a SUCCEED() invocation.\n  virtual void OnTestPartResult(const TestPartResult& test_part_result) = 0;\n\n  // Fired after the test ends.\n  virtual void OnTestEnd(const TestInfo& test_info) = 0;\n\n  // Fired after the test case ends.\n  virtual void OnTestCaseEnd(const TestCase& test_case) = 0;\n\n  // Fired before environment tear-down for each iteration of tests starts.\n  virtual void OnEnvironmentsTearDownStart(const UnitTest& unit_test) = 0;\n\n  // Fired after environment tear-down for each iteration of tests ends.\n  virtual void OnEnvironmentsTearDownEnd(const UnitTest& unit_test) = 0;\n\n  // Fired after each iteration of tests finishes.\n  virtual void OnTestIterationEnd(const UnitTest& unit_test,\n                                  int iteration) = 0;\n\n  // Fired after all test activities have ended.\n  virtual void OnTestProgramEnd(const UnitTest& unit_test) = 0;\n};\n\n// The convenience class for users who need to override just one or two\n// methods and are not concerned that a possible change to a signature of\n// the methods they override will not be caught during the build.  For\n// comments about each method please see the definition of TestEventListener\n// above.\nclass EmptyTestEventListener : public TestEventListener {\n public:\n  virtual void OnTestProgramStart(const UnitTest& /*unit_test*/) {}\n  virtual void OnTestIterationStart(const UnitTest& /*unit_test*/,\n                                    int /*iteration*/) {}\n  virtual void OnEnvironmentsSetUpStart(const UnitTest& /*unit_test*/) {}\n  virtual void OnEnvironmentsSetUpEnd(const UnitTest& /*unit_test*/) {}\n  virtual void OnTestCaseStart(const TestCase& /*test_case*/) {}\n  virtual void OnTestStart(const TestInfo& /*test_info*/) {}\n  virtual void OnTestPartResult(const TestPartResult& /*test_part_result*/) {}\n  virtual void OnTestEnd(const TestInfo& /*test_info*/) {}\n  virtual void OnTestCaseEnd(const TestCase& /*test_case*/) {}\n  virtual void OnEnvironmentsTearDownStart(const UnitTest& /*unit_test*/) {}\n  virtual void OnEnvironmentsTearDownEnd(const UnitTest& /*unit_test*/) {}\n  virtual void OnTestIterationEnd(const UnitTest& /*unit_test*/,\n                                  int /*iteration*/) {}\n  virtual void OnTestProgramEnd(const UnitTest& /*unit_test*/) {}\n};\n\n// TestEventListeners lets users add listeners to track events in Google Test.\nclass GTEST_API_ TestEventListeners {\n public:\n  TestEventListeners();\n  ~TestEventListeners();\n\n  // Appends an event listener to the end of the list. Google Test assumes\n  // the ownership of the listener (i.e. it will delete the listener when\n  // the test program finishes).\n  void Append(TestEventListener* listener);\n\n  // Removes the given event listener from the list and returns it.  It then\n  // becomes the caller's responsibility to delete the listener. Returns\n  // NULL if the listener is not found in the list.\n  TestEventListener* Release(TestEventListener* listener);\n\n  // Returns the standard listener responsible for the default console\n  // output.  Can be removed from the listeners list to shut down default\n  // console output.  Note that removing this object from the listener list\n  // with Release transfers its ownership to the caller and makes this\n  // function return NULL the next time.\n  TestEventListener* default_result_printer() const {\n    return default_result_printer_;\n  }\n\n  // Returns the standard listener responsible for the default XML output\n  // controlled by the --gtest_output=xml flag.  Can be removed from the\n  // listeners list by users who want to shut down the default XML output\n  // controlled by this flag and substitute it with custom one.  Note that\n  // removing this object from the listener list with Release transfers its\n  // ownership to the caller and makes this function return NULL the next\n  // time.\n  TestEventListener* default_xml_generator() const {\n    return default_xml_generator_;\n  }\n\n private:\n  friend class TestCase;\n  friend class TestInfo;\n  friend class internal::DefaultGlobalTestPartResultReporter;\n  friend class internal::NoExecDeathTest;\n  friend class internal::TestEventListenersAccessor;\n  friend class internal::UnitTestImpl;\n\n  // Returns repeater that broadcasts the TestEventListener events to all\n  // subscribers.\n  TestEventListener* repeater();\n\n  // Sets the default_result_printer attribute to the provided listener.\n  // The listener is also added to the listener list and previous\n  // default_result_printer is removed from it and deleted. The listener can\n  // also be NULL in which case it will not be added to the list. Does\n  // nothing if the previous and the current listener objects are the same.\n  void SetDefaultResultPrinter(TestEventListener* listener);\n\n  // Sets the default_xml_generator attribute to the provided listener.  The\n  // listener is also added to the listener list and previous\n  // default_xml_generator is removed from it and deleted. The listener can\n  // also be NULL in which case it will not be added to the list. Does\n  // nothing if the previous and the current listener objects are the same.\n  void SetDefaultXmlGenerator(TestEventListener* listener);\n\n  // Controls whether events will be forwarded by the repeater to the\n  // listeners in the list.\n  bool EventForwardingEnabled() const;\n  void SuppressEventForwarding();\n\n  // The actual list of listeners.\n  internal::TestEventRepeater* repeater_;\n  // Listener responsible for the standard result output.\n  TestEventListener* default_result_printer_;\n  // Listener responsible for the creation of the XML output file.\n  TestEventListener* default_xml_generator_;\n\n  // We disallow copying TestEventListeners.\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestEventListeners);\n};\n\n// A UnitTest consists of a vector of TestCases.\n//\n// This is a singleton class.  The only instance of UnitTest is\n// created when UnitTest::GetInstance() is first called.  This\n// instance is never deleted.\n//\n// UnitTest is not copyable.\n//\n// This class is thread-safe as long as the methods are called\n// according to their specification.\nclass GTEST_API_ UnitTest {\n public:\n  // Gets the singleton UnitTest object.  The first time this method\n  // is called, a UnitTest object is constructed and returned.\n  // Consecutive calls will return the same object.\n  static UnitTest* GetInstance();\n\n  // Runs all tests in this UnitTest object and prints the result.\n  // Returns 0 if successful, or 1 otherwise.\n  //\n  // This method can only be called from the main thread.\n  //\n  // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n  int Run() GTEST_MUST_USE_RESULT_;\n\n  // Returns the working directory when the first TEST() or TEST_F()\n  // was executed.  The UnitTest object owns the string.\n  const char* original_working_dir() const;\n\n  // Returns the TestCase object for the test that's currently running,\n  // or NULL if no test is running.\n  const TestCase* current_test_case() const\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Returns the TestInfo object for the test that's currently running,\n  // or NULL if no test is running.\n  const TestInfo* current_test_info() const\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Returns the random seed used at the start of the current test run.\n  int random_seed() const;\n\n#if GTEST_HAS_PARAM_TEST\n  // Returns the ParameterizedTestCaseRegistry object used to keep track of\n  // value-parameterized tests and instantiate and register them.\n  //\n  // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n  internal::ParameterizedTestCaseRegistry& parameterized_test_registry()\n      GTEST_LOCK_EXCLUDED_(mutex_);\n#endif  // GTEST_HAS_PARAM_TEST\n\n  // Gets the number of successful test cases.\n  int successful_test_case_count() const;\n\n  // Gets the number of failed test cases.\n  int failed_test_case_count() const;\n\n  // Gets the number of all test cases.\n  int total_test_case_count() const;\n\n  // Gets the number of all test cases that contain at least one test\n  // that should run.\n  int test_case_to_run_count() const;\n\n  // Gets the number of successful tests.\n  int successful_test_count() const;\n\n  // Gets the number of failed tests.\n  int failed_test_count() const;\n\n  // Gets the number of disabled tests that will be reported in the XML report.\n  int reportable_disabled_test_count() const;\n\n  // Gets the number of disabled tests.\n  int disabled_test_count() const;\n\n  // Gets the number of tests to be printed in the XML report.\n  int reportable_test_count() const;\n\n  // Gets the number of all tests.\n  int total_test_count() const;\n\n  // Gets the number of tests that should run.\n  int test_to_run_count() const;\n\n  // Gets the time of the test program start, in ms from the start of the\n  // UNIX epoch.\n  TimeInMillis start_timestamp() const;\n\n  // Gets the elapsed time, in milliseconds.\n  TimeInMillis elapsed_time() const;\n\n  // Returns true iff the unit test passed (i.e. all test cases passed).\n  bool Passed() const;\n\n  // Returns true iff the unit test failed (i.e. some test case failed\n  // or something outside of all tests failed).\n  bool Failed() const;\n\n  // Gets the i-th test case among all the test cases. i can range from 0 to\n  // total_test_case_count() - 1. If i is not in that range, returns NULL.\n  const TestCase* GetTestCase(int i) const;\n\n  // Returns the TestResult containing information on test failures and\n  // properties logged outside of individual test cases.\n  const TestResult& ad_hoc_test_result() const;\n\n  // Returns the list of event listeners that can be used to track events\n  // inside Google Test.\n  TestEventListeners& listeners();\n\n private:\n  // Registers and returns a global test environment.  When a test\n  // program is run, all global test environments will be set-up in\n  // the order they were registered.  After all tests in the program\n  // have finished, all global test environments will be torn-down in\n  // the *reverse* order they were registered.\n  //\n  // The UnitTest object takes ownership of the given environment.\n  //\n  // This method can only be called from the main thread.\n  Environment* AddEnvironment(Environment* env);\n\n  // Adds a TestPartResult to the current TestResult object.  All\n  // Google Test assertion macros (e.g. ASSERT_TRUE, EXPECT_EQ, etc)\n  // eventually call this to report their results.  The user code\n  // should use the assertion macros instead of calling this directly.\n  void AddTestPartResult(TestPartResult::Type result_type,\n                         const char* file_name,\n                         int line_number,\n                         const std::string& message,\n                         const std::string& os_stack_trace)\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Adds a TestProperty to the current TestResult object when invoked from\n  // inside a test, to current TestCase's ad_hoc_test_result_ when invoked\n  // from SetUpTestCase or TearDownTestCase, or to the global property set\n  // when invoked elsewhere.  If the result already contains a property with\n  // the same key, the value will be updated.\n  void RecordProperty(const std::string& key, const std::string& value);\n\n  // Gets the i-th test case among all the test cases. i can range from 0 to\n  // total_test_case_count() - 1. If i is not in that range, returns NULL.\n  TestCase* GetMutableTestCase(int i);\n\n  // Accessors for the implementation object.\n  internal::UnitTestImpl* impl() { return impl_; }\n  const internal::UnitTestImpl* impl() const { return impl_; }\n\n  // These classes and funcions are friends as they need to access private\n  // members of UnitTest.\n  friend class Test;\n  friend class internal::AssertHelper;\n  friend class internal::ScopedTrace;\n  friend class internal::StreamingListenerTest;\n  friend class internal::UnitTestRecordPropertyTestHelper;\n  friend Environment* AddGlobalTestEnvironment(Environment* env);\n  friend internal::UnitTestImpl* internal::GetUnitTestImpl();\n  friend void internal::ReportFailureInUnknownLocation(\n      TestPartResult::Type result_type,\n      const std::string& message);\n\n  // Creates an empty UnitTest.\n  UnitTest();\n\n  // D'tor\n  virtual ~UnitTest();\n\n  // Pushes a trace defined by SCOPED_TRACE() on to the per-thread\n  // Google Test trace stack.\n  void PushGTestTrace(const internal::TraceInfo& trace)\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Pops a trace from the per-thread Google Test trace stack.\n  void PopGTestTrace()\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Protects mutable state in *impl_.  This is mutable as some const\n  // methods need to lock it too.\n  mutable internal::Mutex mutex_;\n\n  // Opaque implementation object.  This field is never changed once\n  // the object is constructed.  We don't mark it as const here, as\n  // doing so will cause a warning in the constructor of UnitTest.\n  // Mutable state in *impl_ is protected by mutex_.\n  internal::UnitTestImpl* impl_;\n\n  // We disallow copying UnitTest.\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(UnitTest);\n};\n\n// A convenient wrapper for adding an environment for the test\n// program.\n//\n// You should call this before RUN_ALL_TESTS() is called, probably in\n// main().  If you use gtest_main, you need to call this before main()\n// starts for it to take effect.  For example, you can define a global\n// variable like this:\n//\n//   testing::Environment* const foo_env =\n//       testing::AddGlobalTestEnvironment(new FooEnvironment);\n//\n// However, we strongly recommend you to write your own main() and\n// call AddGlobalTestEnvironment() there, as relying on initialization\n// of global variables makes the code harder to read and may cause\n// problems when you register multiple environments from different\n// translation units and the environments have dependencies among them\n// (remember that the compiler doesn't guarantee the order in which\n// global variables from different translation units are initialized).\ninline Environment* AddGlobalTestEnvironment(Environment* env) {\n  return UnitTest::GetInstance()->AddEnvironment(env);\n}\n\n// Initializes Google Test.  This must be called before calling\n// RUN_ALL_TESTS().  In particular, it parses a command line for the\n// flags that Google Test recognizes.  Whenever a Google Test flag is\n// seen, it is removed from argv, and *argc is decremented.\n//\n// No value is returned.  Instead, the Google Test flag variables are\n// updated.\n//\n// Calling the function for the second time has no user-visible effect.\nGTEST_API_ void InitGoogleTest(int* argc, char** argv);\n\n// This overloaded version can be used in Windows programs compiled in\n// UNICODE mode.\nGTEST_API_ void InitGoogleTest(int* argc, wchar_t** argv);\n\nnamespace internal {\n\n// Separate the error generating code from the code path to reduce the stack\n// frame size of CmpHelperEQ. This helps reduce the overhead of some sanitizers\n// when calling EXPECT_* in a tight loop.\ntemplate <typename T1, typename T2>\nAssertionResult CmpHelperEQFailure(const char* lhs_expression,\n                                   const char* rhs_expression,\n                                   const T1& lhs, const T2& rhs) {\n  return EqFailure(lhs_expression,\n                   rhs_expression,\n                   FormatForComparisonFailureMessage(lhs, rhs),\n                   FormatForComparisonFailureMessage(rhs, lhs),\n                   false);\n}\n\n// The helper function for {ASSERT|EXPECT}_EQ.\ntemplate <typename T1, typename T2>\nAssertionResult CmpHelperEQ(const char* lhs_expression,\n                            const char* rhs_expression,\n                            const T1& lhs,\n                            const T2& rhs) {\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(4389 /* signed/unsigned mismatch */)\n  if (lhs == rhs) {\n    return AssertionSuccess();\n  }\nGTEST_DISABLE_MSC_WARNINGS_POP_()\n\n  return CmpHelperEQFailure(lhs_expression, rhs_expression, lhs, rhs);\n}\n\n// With this overloaded version, we allow anonymous enums to be used\n// in {ASSERT|EXPECT}_EQ when compiled with gcc 4, as anonymous enums\n// can be implicitly cast to BiggestInt.\nGTEST_API_ AssertionResult CmpHelperEQ(const char* lhs_expression,\n                                       const char* rhs_expression,\n                                       BiggestInt lhs,\n                                       BiggestInt rhs);\n\n// The helper class for {ASSERT|EXPECT}_EQ.  The template argument\n// lhs_is_null_literal is true iff the first argument to ASSERT_EQ()\n// is a null pointer literal.  The following default implementation is\n// for lhs_is_null_literal being false.\ntemplate <bool lhs_is_null_literal>\nclass EqHelper {\n public:\n  // This templatized version is for the general case.\n  template <typename T1, typename T2>\n  static AssertionResult Compare(const char* lhs_expression,\n                                 const char* rhs_expression,\n                                 const T1& lhs,\n                                 const T2& rhs) {\n    return CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);\n  }\n\n  // With this overloaded version, we allow anonymous enums to be used\n  // in {ASSERT|EXPECT}_EQ when compiled with gcc 4, as anonymous\n  // enums can be implicitly cast to BiggestInt.\n  //\n  // Even though its body looks the same as the above version, we\n  // cannot merge the two, as it will make anonymous enums unhappy.\n  static AssertionResult Compare(const char* lhs_expression,\n                                 const char* rhs_expression,\n                                 BiggestInt lhs,\n                                 BiggestInt rhs) {\n    return CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);\n  }\n};\n\n// This specialization is used when the first argument to ASSERT_EQ()\n// is a null pointer literal, like NULL, false, or 0.\ntemplate <>\nclass EqHelper<true> {\n public:\n  // We define two overloaded versions of Compare().  The first\n  // version will be picked when the second argument to ASSERT_EQ() is\n  // NOT a pointer, e.g. ASSERT_EQ(0, AnIntFunction()) or\n  // EXPECT_EQ(false, a_bool).\n  template <typename T1, typename T2>\n  static AssertionResult Compare(\n      const char* lhs_expression,\n      const char* rhs_expression,\n      const T1& lhs,\n      const T2& rhs,\n      // The following line prevents this overload from being considered if T2\n      // is not a pointer type.  We need this because ASSERT_EQ(NULL, my_ptr)\n      // expands to Compare(\"\", \"\", NULL, my_ptr), which requires a conversion\n      // to match the Secret* in the other overload, which would otherwise make\n      // this template match better.\n      typename EnableIf<!is_pointer<T2>::value>::type* = 0) {\n    return CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);\n  }\n\n  // This version will be picked when the second argument to ASSERT_EQ() is a\n  // pointer, e.g. ASSERT_EQ(NULL, a_pointer).\n  template <typename T>\n  static AssertionResult Compare(\n      const char* lhs_expression,\n      const char* rhs_expression,\n      // We used to have a second template parameter instead of Secret*.  That\n      // template parameter would deduce to 'long', making this a better match\n      // than the first overload even without the first overload's EnableIf.\n      // Unfortunately, gcc with -Wconversion-null warns when \"passing NULL to\n      // non-pointer argument\" (even a deduced integral argument), so the old\n      // implementation caused warnings in user code.\n      Secret* /* lhs (NULL) */,\n      T* rhs) {\n    // We already know that 'lhs' is a null pointer.\n    return CmpHelperEQ(lhs_expression, rhs_expression,\n                       static_cast<T*>(NULL), rhs);\n  }\n};\n\n// Separate the error generating code from the code path to reduce the stack\n// frame size of CmpHelperOP. This helps reduce the overhead of some sanitizers\n// when calling EXPECT_OP in a tight loop.\ntemplate <typename T1, typename T2>\nAssertionResult CmpHelperOpFailure(const char* expr1, const char* expr2,\n                                   const T1& val1, const T2& val2,\n                                   const char* op) {\n  return AssertionFailure()\n         << \"Expected: (\" << expr1 << \") \" << op << \" (\" << expr2\n         << \"), actual: \" << FormatForComparisonFailureMessage(val1, val2)\n         << \" vs \" << FormatForComparisonFailureMessage(val2, val1);\n}\n\n// A macro for implementing the helper functions needed to implement\n// ASSERT_?? and EXPECT_??.  It is here just to avoid copy-and-paste\n// of similar code.\n//\n// For each templatized helper function, we also define an overloaded\n// version for BiggestInt in order to reduce code bloat and allow\n// anonymous enums to be used with {ASSERT|EXPECT}_?? when compiled\n// with gcc 4.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n\n#define GTEST_IMPL_CMP_HELPER_(op_name, op)\\\ntemplate <typename T1, typename T2>\\\nAssertionResult CmpHelper##op_name(const char* expr1, const char* expr2, \\\n                                   const T1& val1, const T2& val2) {\\\n  if (val1 op val2) {\\\n    return AssertionSuccess();\\\n  } else {\\\n    return CmpHelperOpFailure(expr1, expr2, val1, val2, #op);\\\n  }\\\n}\\\nGTEST_API_ AssertionResult CmpHelper##op_name(\\\n    const char* expr1, const char* expr2, BiggestInt val1, BiggestInt val2)\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n\n// Implements the helper function for {ASSERT|EXPECT}_NE\nGTEST_IMPL_CMP_HELPER_(NE, !=);\n// Implements the helper function for {ASSERT|EXPECT}_LE\nGTEST_IMPL_CMP_HELPER_(LE, <=);\n// Implements the helper function for {ASSERT|EXPECT}_LT\nGTEST_IMPL_CMP_HELPER_(LT, <);\n// Implements the helper function for {ASSERT|EXPECT}_GE\nGTEST_IMPL_CMP_HELPER_(GE, >=);\n// Implements the helper function for {ASSERT|EXPECT}_GT\nGTEST_IMPL_CMP_HELPER_(GT, >);\n\n#undef GTEST_IMPL_CMP_HELPER_\n\n// The helper function for {ASSERT|EXPECT}_STREQ.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTREQ(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const char* s1,\n                                          const char* s2);\n\n// The helper function for {ASSERT|EXPECT}_STRCASEEQ.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRCASEEQ(const char* s1_expression,\n                                              const char* s2_expression,\n                                              const char* s1,\n                                              const char* s2);\n\n// The helper function for {ASSERT|EXPECT}_STRNE.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRNE(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const char* s1,\n                                          const char* s2);\n\n// The helper function for {ASSERT|EXPECT}_STRCASENE.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRCASENE(const char* s1_expression,\n                                              const char* s2_expression,\n                                              const char* s1,\n                                              const char* s2);\n\n\n// Helper function for *_STREQ on wide strings.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTREQ(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const wchar_t* s1,\n                                          const wchar_t* s2);\n\n// Helper function for *_STRNE on wide strings.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRNE(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const wchar_t* s1,\n                                          const wchar_t* s2);\n\n}  // namespace internal\n\n// IsSubstring() and IsNotSubstring() are intended to be used as the\n// first argument to {EXPECT,ASSERT}_PRED_FORMAT2(), not by\n// themselves.  They check whether needle is a substring of haystack\n// (NULL is considered a substring of itself only), and return an\n// appropriate error message when they fail.\n//\n// The {needle,haystack}_expr arguments are the stringified\n// expressions that generated the two real arguments.\nGTEST_API_ AssertionResult IsSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const char* needle, const char* haystack);\nGTEST_API_ AssertionResult IsSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const wchar_t* needle, const wchar_t* haystack);\nGTEST_API_ AssertionResult IsNotSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const char* needle, const char* haystack);\nGTEST_API_ AssertionResult IsNotSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const wchar_t* needle, const wchar_t* haystack);\nGTEST_API_ AssertionResult IsSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const ::std::string& needle, const ::std::string& haystack);\nGTEST_API_ AssertionResult IsNotSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const ::std::string& needle, const ::std::string& haystack);\n\n#if GTEST_HAS_STD_WSTRING\nGTEST_API_ AssertionResult IsSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const ::std::wstring& needle, const ::std::wstring& haystack);\nGTEST_API_ AssertionResult IsNotSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const ::std::wstring& needle, const ::std::wstring& haystack);\n#endif  // GTEST_HAS_STD_WSTRING\n\nnamespace internal {\n\n// Helper template function for comparing floating-points.\n//\n// Template parameter:\n//\n//   RawType: the raw floating-point type (either float or double)\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\ntemplate <typename RawType>\nAssertionResult CmpHelperFloatingPointEQ(const char* lhs_expression,\n                                         const char* rhs_expression,\n                                         RawType lhs_value,\n                                         RawType rhs_value) {\n  const FloatingPoint<RawType> lhs(lhs_value), rhs(rhs_value);\n\n  if (lhs.AlmostEquals(rhs)) {\n    return AssertionSuccess();\n  }\n\n  ::std::stringstream lhs_ss;\n  lhs_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)\n         << lhs_value;\n\n  ::std::stringstream rhs_ss;\n  rhs_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)\n         << rhs_value;\n\n  return EqFailure(lhs_expression,\n                   rhs_expression,\n                   StringStreamToString(&lhs_ss),\n                   StringStreamToString(&rhs_ss),\n                   false);\n}\n\n// Helper function for implementing ASSERT_NEAR.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult DoubleNearPredFormat(const char* expr1,\n                                                const char* expr2,\n                                                const char* abs_error_expr,\n                                                double val1,\n                                                double val2,\n                                                double abs_error);\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n// A class that enables one to stream messages to assertion macros\nclass GTEST_API_ AssertHelper {\n public:\n  // Constructor.\n  AssertHelper(TestPartResult::Type type,\n               const char* file,\n               int line,\n               const char* message);\n  ~AssertHelper();\n\n  // Message assignment is a semantic trick to enable assertion\n  // streaming; see the GTEST_MESSAGE_ macro below.\n  void operator=(const Message& message) const;\n\n private:\n  // We put our data in a struct so that the size of the AssertHelper class can\n  // be as small as possible.  This is important because gcc is incapable of\n  // re-using stack space even for temporary variables, so every EXPECT_EQ\n  // reserves stack space for another AssertHelper.\n  struct AssertHelperData {\n    AssertHelperData(TestPartResult::Type t,\n                     const char* srcfile,\n                     int line_num,\n                     const char* msg)\n        : type(t), file(srcfile), line(line_num), message(msg) { }\n\n    TestPartResult::Type const type;\n    const char* const file;\n    int const line;\n    std::string const message;\n\n   private:\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(AssertHelperData);\n  };\n\n  AssertHelperData* const data_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(AssertHelper);\n};\n\n}  // namespace internal\n\n#if GTEST_HAS_PARAM_TEST\n// The pure interface class that all value-parameterized tests inherit from.\n// A value-parameterized class must inherit from both ::testing::Test and\n// ::testing::WithParamInterface. In most cases that just means inheriting\n// from ::testing::TestWithParam, but more complicated test hierarchies\n// may need to inherit from Test and WithParamInterface at different levels.\n//\n// This interface has support for accessing the test parameter value via\n// the GetParam() method.\n//\n// Use it with one of the parameter generator defining functions, like Range(),\n// Values(), ValuesIn(), Bool(), and Combine().\n//\n// class FooTest : public ::testing::TestWithParam<int> {\n//  protected:\n//   FooTest() {\n//     // Can use GetParam() here.\n//   }\n//   virtual ~FooTest() {\n//     // Can use GetParam() here.\n//   }\n//   virtual void SetUp() {\n//     // Can use GetParam() here.\n//   }\n//   virtual void TearDown {\n//     // Can use GetParam() here.\n//   }\n// };\n// TEST_P(FooTest, DoesBar) {\n//   // Can use GetParam() method here.\n//   Foo foo;\n//   ASSERT_TRUE(foo.DoesBar(GetParam()));\n// }\n// INSTANTIATE_TEST_CASE_P(OneToTenRange, FooTest, ::testing::Range(1, 10));\n\ntemplate <typename T>\nclass WithParamInterface {\n public:\n  typedef T ParamType;\n  virtual ~WithParamInterface() {}\n\n  // The current parameter value. Is also available in the test fixture's\n  // constructor. This member function is non-static, even though it only\n  // references static data, to reduce the opportunity for incorrect uses\n  // like writing 'WithParamInterface<bool>::GetParam()' for a test that\n  // uses a fixture whose parameter type is int.\n  const ParamType& GetParam() const {\n    GTEST_CHECK_(parameter_ != NULL)\n        << \"GetParam() can only be called inside a value-parameterized test \"\n        << \"-- did you intend to write TEST_P instead of TEST_F?\";\n    return *parameter_;\n  }\n\n private:\n  // Sets parameter value. The caller is responsible for making sure the value\n  // remains alive and unchanged throughout the current test.\n  static void SetParam(const ParamType* parameter) {\n    parameter_ = parameter;\n  }\n\n  // Static value used for accessing parameter during a test lifetime.\n  static const ParamType* parameter_;\n\n  // TestClass must be a subclass of WithParamInterface<T> and Test.\n  template <class TestClass> friend class internal::ParameterizedTestFactory;\n};\n\ntemplate <typename T>\nconst T* WithParamInterface<T>::parameter_ = NULL;\n\n// Most value-parameterized classes can ignore the existence of\n// WithParamInterface, and can just inherit from ::testing::TestWithParam.\n\ntemplate <typename T>\nclass TestWithParam : public Test, public WithParamInterface<T> {\n};\n\n#endif  // GTEST_HAS_PARAM_TEST\n\n// Macros for indicating success/failure in test code.\n\n// ADD_FAILURE unconditionally adds a failure to the current test.\n// SUCCEED generates a success - it doesn't automatically make the\n// current test successful, as a test is only successful when it has\n// no failure.\n//\n// EXPECT_* verifies that a certain condition is satisfied.  If not,\n// it behaves like ADD_FAILURE.  In particular:\n//\n//   EXPECT_TRUE  verifies that a Boolean condition is true.\n//   EXPECT_FALSE verifies that a Boolean condition is false.\n//\n// FAIL and ASSERT_* are similar to ADD_FAILURE and EXPECT_*, except\n// that they will also abort the current function on failure.  People\n// usually want the fail-fast behavior of FAIL and ASSERT_*, but those\n// writing data-driven tests often find themselves using ADD_FAILURE\n// and EXPECT_* more.\n\n// Generates a nonfatal failure with a generic message.\n#define ADD_FAILURE() GTEST_NONFATAL_FAILURE_(\"Failed\")\n\n// Generates a nonfatal failure at the given source file location with\n// a generic message.\n#define ADD_FAILURE_AT(file, line) \\\n  GTEST_MESSAGE_AT_(file, line, \"Failed\", \\\n                    ::testing::TestPartResult::kNonFatalFailure)\n\n// Generates a fatal failure with a generic message.\n#define GTEST_FAIL() GTEST_FATAL_FAILURE_(\"Failed\")\n\n// Define this macro to 1 to omit the definition of FAIL(), which is a\n// generic name and clashes with some other libraries.\n#if !GTEST_DONT_DEFINE_FAIL\n# define FAIL() GTEST_FAIL()\n#endif\n\n// Generates a success with a generic message.\n#define GTEST_SUCCEED() GTEST_SUCCESS_(\"Succeeded\")\n\n// Define this macro to 1 to omit the definition of SUCCEED(), which\n// is a generic name and clashes with some other libraries.\n#if !GTEST_DONT_DEFINE_SUCCEED\n# define SUCCEED() GTEST_SUCCEED()\n#endif\n\n// Macros for testing exceptions.\n//\n//    * {ASSERT|EXPECT}_THROW(statement, expected_exception):\n//         Tests that the statement throws the expected exception.\n//    * {ASSERT|EXPECT}_NO_THROW(statement):\n//         Tests that the statement doesn't throw any exception.\n//    * {ASSERT|EXPECT}_ANY_THROW(statement):\n//         Tests that the statement throws an exception.\n\n#define EXPECT_THROW(statement, expected_exception) \\\n  GTEST_TEST_THROW_(statement, expected_exception, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_NO_THROW(statement) \\\n  GTEST_TEST_NO_THROW_(statement, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_ANY_THROW(statement) \\\n  GTEST_TEST_ANY_THROW_(statement, GTEST_NONFATAL_FAILURE_)\n#define ASSERT_THROW(statement, expected_exception) \\\n  GTEST_TEST_THROW_(statement, expected_exception, GTEST_FATAL_FAILURE_)\n#define ASSERT_NO_THROW(statement) \\\n  GTEST_TEST_NO_THROW_(statement, GTEST_FATAL_FAILURE_)\n#define ASSERT_ANY_THROW(statement) \\\n  GTEST_TEST_ANY_THROW_(statement, GTEST_FATAL_FAILURE_)\n\n// Boolean assertions. Condition can be either a Boolean expression or an\n// AssertionResult. For more information on how to use AssertionResult with\n// these macros see comments on that class.\n#define EXPECT_TRUE(condition) \\\n  GTEST_TEST_BOOLEAN_((condition), #condition, false, true, \\\n                      GTEST_NONFATAL_FAILURE_)\n#define EXPECT_FALSE(condition) \\\n  GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, \\\n                      GTEST_NONFATAL_FAILURE_)\n#define ASSERT_TRUE(condition) \\\n  GTEST_TEST_BOOLEAN_((condition), #condition, false, true, \\\n                      GTEST_FATAL_FAILURE_)\n#define ASSERT_FALSE(condition) \\\n  GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, \\\n                      GTEST_FATAL_FAILURE_)\n\n// Includes the auto-generated header that implements a family of\n// generic predicate assertion macros.\n#include \"gtest/gtest_pred_impl.h\"\n\n// Macros for testing equalities and inequalities.\n//\n//    * {ASSERT|EXPECT}_EQ(v1, v2): Tests that v1 == v2\n//    * {ASSERT|EXPECT}_NE(v1, v2): Tests that v1 != v2\n//    * {ASSERT|EXPECT}_LT(v1, v2): Tests that v1 < v2\n//    * {ASSERT|EXPECT}_LE(v1, v2): Tests that v1 <= v2\n//    * {ASSERT|EXPECT}_GT(v1, v2): Tests that v1 > v2\n//    * {ASSERT|EXPECT}_GE(v1, v2): Tests that v1 >= v2\n//\n// When they are not, Google Test prints both the tested expressions and\n// their actual values.  The values must be compatible built-in types,\n// or you will get a compiler error.  By \"compatible\" we mean that the\n// values can be compared by the respective operator.\n//\n// Note:\n//\n//   1. It is possible to make a user-defined type work with\n//   {ASSERT|EXPECT}_??(), but that requires overloading the\n//   comparison operators and is thus discouraged by the Google C++\n//   Usage Guide.  Therefore, you are advised to use the\n//   {ASSERT|EXPECT}_TRUE() macro to assert that two objects are\n//   equal.\n//\n//   2. The {ASSERT|EXPECT}_??() macros do pointer comparisons on\n//   pointers (in particular, C strings).  Therefore, if you use it\n//   with two C strings, you are testing how their locations in memory\n//   are related, not how their content is related.  To compare two C\n//   strings by content, use {ASSERT|EXPECT}_STR*().\n//\n//   3. {ASSERT|EXPECT}_EQ(v1, v2) is preferred to\n//   {ASSERT|EXPECT}_TRUE(v1 == v2), as the former tells you\n//   what the actual value is when it fails, and similarly for the\n//   other comparisons.\n//\n//   4. Do not depend on the order in which {ASSERT|EXPECT}_??()\n//   evaluate their arguments, which is undefined.\n//\n//   5. These macros evaluate their arguments exactly once.\n//\n// Examples:\n//\n//   EXPECT_NE(5, Foo());\n//   EXPECT_EQ(NULL, a_pointer);\n//   ASSERT_LT(i, array_size);\n//   ASSERT_GT(records.size(), 0) << \"There is no record left.\";\n\n#define EXPECT_EQ(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal:: \\\n                      EqHelper<GTEST_IS_NULL_LITERAL_(val1)>::Compare, \\\n                      val1, val2)\n#define EXPECT_NE(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperNE, val1, val2)\n#define EXPECT_LE(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperLE, val1, val2)\n#define EXPECT_LT(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperLT, val1, val2)\n#define EXPECT_GE(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperGE, val1, val2)\n#define EXPECT_GT(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperGT, val1, val2)\n\n#define GTEST_ASSERT_EQ(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal:: \\\n                      EqHelper<GTEST_IS_NULL_LITERAL_(val1)>::Compare, \\\n                      val1, val2)\n#define GTEST_ASSERT_NE(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperNE, val1, val2)\n#define GTEST_ASSERT_LE(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperLE, val1, val2)\n#define GTEST_ASSERT_LT(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperLT, val1, val2)\n#define GTEST_ASSERT_GE(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperGE, val1, val2)\n#define GTEST_ASSERT_GT(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperGT, val1, val2)\n\n// Define macro GTEST_DONT_DEFINE_ASSERT_XY to 1 to omit the definition of\n// ASSERT_XY(), which clashes with some users' own code.\n\n#if !GTEST_DONT_DEFINE_ASSERT_EQ\n# define ASSERT_EQ(val1, val2) GTEST_ASSERT_EQ(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_NE\n# define ASSERT_NE(val1, val2) GTEST_ASSERT_NE(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_LE\n# define ASSERT_LE(val1, val2) GTEST_ASSERT_LE(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_LT\n# define ASSERT_LT(val1, val2) GTEST_ASSERT_LT(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_GE\n# define ASSERT_GE(val1, val2) GTEST_ASSERT_GE(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_GT\n# define ASSERT_GT(val1, val2) GTEST_ASSERT_GT(val1, val2)\n#endif\n\n// C-string Comparisons.  All tests treat NULL and any non-NULL string\n// as different.  Two NULLs are equal.\n//\n//    * {ASSERT|EXPECT}_STREQ(s1, s2):     Tests that s1 == s2\n//    * {ASSERT|EXPECT}_STRNE(s1, s2):     Tests that s1 != s2\n//    * {ASSERT|EXPECT}_STRCASEEQ(s1, s2): Tests that s1 == s2, ignoring case\n//    * {ASSERT|EXPECT}_STRCASENE(s1, s2): Tests that s1 != s2, ignoring case\n//\n// For wide or narrow string objects, you can use the\n// {ASSERT|EXPECT}_??() macros.\n//\n// Don't depend on the order in which the arguments are evaluated,\n// which is undefined.\n//\n// These macros evaluate their arguments exactly once.\n\n#define EXPECT_STREQ(s1, s2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTREQ, s1, s2)\n#define EXPECT_STRNE(s1, s2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRNE, s1, s2)\n#define EXPECT_STRCASEEQ(s1, s2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASEEQ, s1, s2)\n#define EXPECT_STRCASENE(s1, s2)\\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASENE, s1, s2)\n\n#define ASSERT_STREQ(s1, s2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTREQ, s1, s2)\n#define ASSERT_STRNE(s1, s2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRNE, s1, s2)\n#define ASSERT_STRCASEEQ(s1, s2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASEEQ, s1, s2)\n#define ASSERT_STRCASENE(s1, s2)\\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASENE, s1, s2)\n\n// Macros for comparing floating-point numbers.\n//\n//    * {ASSERT|EXPECT}_FLOAT_EQ(val1, val2):\n//         Tests that two float values are almost equal.\n//    * {ASSERT|EXPECT}_DOUBLE_EQ(val1, val2):\n//         Tests that two double values are almost equal.\n//    * {ASSERT|EXPECT}_NEAR(v1, v2, abs_error):\n//         Tests that v1 and v2 are within the given distance to each other.\n//\n// Google Test uses ULP-based comparison to automatically pick a default\n// error bound that is appropriate for the operands.  See the\n// FloatingPoint template class in gtest-internal.h if you are\n// interested in the implementation details.\n\n#define EXPECT_FLOAT_EQ(val1, val2)\\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<float>, \\\n                      val1, val2)\n\n#define EXPECT_DOUBLE_EQ(val1, val2)\\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<double>, \\\n                      val1, val2)\n\n#define ASSERT_FLOAT_EQ(val1, val2)\\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<float>, \\\n                      val1, val2)\n\n#define ASSERT_DOUBLE_EQ(val1, val2)\\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<double>, \\\n                      val1, val2)\n\n#define EXPECT_NEAR(val1, val2, abs_error)\\\n  EXPECT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, \\\n                      val1, val2, abs_error)\n\n#define ASSERT_NEAR(val1, val2, abs_error)\\\n  ASSERT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, \\\n                      val1, val2, abs_error)\n\n// These predicate format functions work on floating-point values, and\n// can be used in {ASSERT|EXPECT}_PRED_FORMAT2*(), e.g.\n//\n//   EXPECT_PRED_FORMAT2(testing::DoubleLE, Foo(), 5.0);\n\n// Asserts that val1 is less than, or almost equal to, val2.  Fails\n// otherwise.  In particular, it fails if either val1 or val2 is NaN.\nGTEST_API_ AssertionResult FloatLE(const char* expr1, const char* expr2,\n                                   float val1, float val2);\nGTEST_API_ AssertionResult DoubleLE(const char* expr1, const char* expr2,\n                                    double val1, double val2);\n\n\n#if GTEST_OS_WINDOWS\n\n// Macros that test for HRESULT failure and success, these are only useful\n// on Windows, and rely on Windows SDK macros and APIs to compile.\n//\n//    * {ASSERT|EXPECT}_HRESULT_{SUCCEEDED|FAILED}(expr)\n//\n// When expr unexpectedly fails or succeeds, Google Test prints the\n// expected result and the actual result with both a human-readable\n// string representation of the error, if available, as well as the\n// hex result code.\n# define EXPECT_HRESULT_SUCCEEDED(expr) \\\n    EXPECT_PRED_FORMAT1(::testing::internal::IsHRESULTSuccess, (expr))\n\n# define ASSERT_HRESULT_SUCCEEDED(expr) \\\n    ASSERT_PRED_FORMAT1(::testing::internal::IsHRESULTSuccess, (expr))\n\n# define EXPECT_HRESULT_FAILED(expr) \\\n    EXPECT_PRED_FORMAT1(::testing::internal::IsHRESULTFailure, (expr))\n\n# define ASSERT_HRESULT_FAILED(expr) \\\n    ASSERT_PRED_FORMAT1(::testing::internal::IsHRESULTFailure, (expr))\n\n#endif  // GTEST_OS_WINDOWS\n\n// Macros that execute statement and check that it doesn't generate new fatal\n// failures in the current thread.\n//\n//   * {ASSERT|EXPECT}_NO_FATAL_FAILURE(statement);\n//\n// Examples:\n//\n//   EXPECT_NO_FATAL_FAILURE(Process());\n//   ASSERT_NO_FATAL_FAILURE(Process()) << \"Process() failed\";\n//\n#define ASSERT_NO_FATAL_FAILURE(statement) \\\n    GTEST_TEST_NO_FATAL_FAILURE_(statement, GTEST_FATAL_FAILURE_)\n#define EXPECT_NO_FATAL_FAILURE(statement) \\\n    GTEST_TEST_NO_FATAL_FAILURE_(statement, GTEST_NONFATAL_FAILURE_)\n\n// Causes a trace (including the source file path, the current line\n// number, and the given message) to be included in every test failure\n// message generated by code in the current scope.  The effect is\n// undone when the control leaves the current scope.\n//\n// The message argument can be anything streamable to std::ostream.\n//\n// In the implementation, we include the current line number as part\n// of the dummy variable name, thus allowing multiple SCOPED_TRACE()s\n// to appear in the same block - as long as they are on different\n// lines.\n#define SCOPED_TRACE(message) \\\n  ::testing::internal::ScopedTrace GTEST_CONCAT_TOKEN_(gtest_trace_, __LINE__)(\\\n    __FILE__, __LINE__, ::testing::Message() << (message))\n\n// Compile-time assertion for type equality.\n// StaticAssertTypeEq<type1, type2>() compiles iff type1 and type2 are\n// the same type.  The value it returns is not interesting.\n//\n// Instead of making StaticAssertTypeEq a class template, we make it a\n// function template that invokes a helper class template.  This\n// prevents a user from misusing StaticAssertTypeEq<T1, T2> by\n// defining objects of that type.\n//\n// CAVEAT:\n//\n// When used inside a method of a class template,\n// StaticAssertTypeEq<T1, T2>() is effective ONLY IF the method is\n// instantiated.  For example, given:\n//\n//   template <typename T> class Foo {\n//    public:\n//     void Bar() { testing::StaticAssertTypeEq<int, T>(); }\n//   };\n//\n// the code:\n//\n//   void Test1() { Foo<bool> foo; }\n//\n// will NOT generate a compiler error, as Foo<bool>::Bar() is never\n// actually instantiated.  Instead, you need:\n//\n//   void Test2() { Foo<bool> foo; foo.Bar(); }\n//\n// to cause a compiler error.\ntemplate <typename T1, typename T2>\nbool StaticAssertTypeEq() {\n  (void)internal::StaticAssertTypeEqHelper<T1, T2>();\n  return true;\n}\n\n// Defines a test.\n//\n// The first parameter is the name of the test case, and the second\n// parameter is the name of the test within the test case.\n//\n// The convention is to end the test case name with \"Test\".  For\n// example, a test case for the Foo class can be named FooTest.\n//\n// Test code should appear between braces after an invocation of\n// this macro.  Example:\n//\n//   TEST(FooTest, InitializesCorrectly) {\n//     Foo foo;\n//     EXPECT_TRUE(foo.StatusIsOK());\n//   }\n\n// Note that we call GetTestTypeId() instead of GetTypeId<\n// ::testing::Test>() here to get the type ID of testing::Test.  This\n// is to work around a suspected linker bug when using Google Test as\n// a framework on Mac OS X.  The bug causes GetTypeId<\n// ::testing::Test>() to return different values depending on whether\n// the call is from the Google Test framework itself or from user test\n// code.  GetTestTypeId() is guaranteed to always return the same\n// value, as it always calls GetTypeId<>() from the Google Test\n// framework.\n#define GTEST_TEST(test_case_name, test_name)\\\n  GTEST_TEST_(test_case_name, test_name, \\\n              ::testing::Test, ::testing::internal::GetTestTypeId())\n\n// Define this macro to 1 to omit the definition of TEST(), which\n// is a generic name and clashes with some other libraries.\n#if !GTEST_DONT_DEFINE_TEST\n# define TEST(test_case_name, test_name) GTEST_TEST(test_case_name, test_name)\n#endif\n\n// Defines a test that uses a test fixture.\n//\n// The first parameter is the name of the test fixture class, which\n// also doubles as the test case name.  The second parameter is the\n// name of the test within the test case.\n//\n// A test fixture class must be declared earlier.  The user should put\n// his test code between braces after using this macro.  Example:\n//\n//   class FooTest : public testing::Test {\n//    protected:\n//     virtual void SetUp() { b_.AddElement(3); }\n//\n//     Foo a_;\n//     Foo b_;\n//   };\n//\n//   TEST_F(FooTest, InitializesCorrectly) {\n//     EXPECT_TRUE(a_.StatusIsOK());\n//   }\n//\n//   TEST_F(FooTest, ReturnsElementCountCorrectly) {\n//     EXPECT_EQ(0, a_.size());\n//     EXPECT_EQ(1, b_.size());\n//   }\n\n#define TEST_F(test_fixture, test_name)\\\n  GTEST_TEST_(test_fixture, test_name, test_fixture, \\\n              ::testing::internal::GetTypeId<test_fixture>())\n\n}  // namespace testing\n\n// Use this function in main() to run all tests.  It returns 0 if all\n// tests are successful, or 1 otherwise.\n//\n// RUN_ALL_TESTS() should be invoked after the command line has been\n// parsed by InitGoogleTest().\n//\n// This function was formerly a macro; thus, it is in the global\n// namespace and has an all-caps name.\nint RUN_ALL_TESTS() GTEST_MUST_USE_RESULT_;\n\ninline int RUN_ALL_TESTS() {\n  return ::testing::UnitTest::GetInstance()->Run();\n}\n\n#endif  // GTEST_INCLUDE_GTEST_GTEST_H_\n"}, "54": {"id": 54, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest_pred_impl.h", "content": "// Copyright 2006, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// This file is AUTOMATICALLY GENERATED on 10/31/2011 by command\n// 'gen_gtest_pred_impl.py 5'.  DO NOT EDIT BY HAND!\n//\n// Implements a family of generic predicate assertion macros.\n\n#ifndef GTEST_INCLUDE_GTEST_GTEST_PRED_IMPL_H_\n#define GTEST_INCLUDE_GTEST_GTEST_PRED_IMPL_H_\n\n// Makes sure this header is not included before gtest.h.\n#ifndef GTEST_INCLUDE_GTEST_GTEST_H_\n# error Do not include gtest_pred_impl.h directly.  Include gtest.h instead.\n#endif  // GTEST_INCLUDE_GTEST_GTEST_H_\n\n// This header implements a family of generic predicate assertion\n// macros:\n//\n//   ASSERT_PRED_FORMAT1(pred_format, v1)\n//   ASSERT_PRED_FORMAT2(pred_format, v1, v2)\n//   ...\n//\n// where pred_format is a function or functor that takes n (in the\n// case of ASSERT_PRED_FORMATn) values and their source expression\n// text, and returns a testing::AssertionResult.  See the definition\n// of ASSERT_EQ in gtest.h for an example.\n//\n// If you don't care about formatting, you can use the more\n// restrictive version:\n//\n//   ASSERT_PRED1(pred, v1)\n//   ASSERT_PRED2(pred, v1, v2)\n//   ...\n//\n// where pred is an n-ary function or functor that returns bool,\n// and the values v1, v2, ..., must support the << operator for\n// streaming to std::ostream.\n//\n// We also define the EXPECT_* variations.\n//\n// For now we only support predicates whose arity is at most 5.\n// Please email googletestframework@googlegroups.com if you need\n// support for higher arities.\n\n// GTEST_ASSERT_ is the basic statement to which all of the assertions\n// in this file reduce.  Don't use this in your code.\n\n#define GTEST_ASSERT_(expression, on_failure) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (const ::testing::AssertionResult gtest_ar = (expression)) \\\n    ; \\\n  else \\\n    on_failure(gtest_ar.failure_message())\n\n\n// Helper function for implementing {EXPECT|ASSERT}_PRED1.  Don't use\n// this in your code.\ntemplate <typename Pred,\n          typename T1>\nAssertionResult AssertPred1Helper(const char* pred_text,\n                                  const char* e1,\n                                  Pred pred,\n                                  const T1& v1) {\n  if (pred(v1)) return AssertionSuccess();\n\n  return AssertionFailure() << pred_text << \"(\"\n                            << e1 << \") evaluates to false, where\"\n                            << \"\\n\" << e1 << \" evaluates to \" << v1;\n}\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED_FORMAT1.\n// Don't use this in your code.\n#define GTEST_PRED_FORMAT1_(pred_format, v1, on_failure)\\\n  GTEST_ASSERT_(pred_format(#v1, v1), \\\n                on_failure)\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED1.  Don't use\n// this in your code.\n#define GTEST_PRED1_(pred, v1, on_failure)\\\n  GTEST_ASSERT_(::testing::AssertPred1Helper(#pred, \\\n                                             #v1, \\\n                                             pred, \\\n                                             v1), on_failure)\n\n// Unary predicate assertion macros.\n#define EXPECT_PRED_FORMAT1(pred_format, v1) \\\n  GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_PRED1(pred, v1) \\\n  GTEST_PRED1_(pred, v1, GTEST_NONFATAL_FAILURE_)\n#define ASSERT_PRED_FORMAT1(pred_format, v1) \\\n  GTEST_PRED_FORMAT1_(pred_format, v1, GTEST_FATAL_FAILURE_)\n#define ASSERT_PRED1(pred, v1) \\\n  GTEST_PRED1_(pred, v1, GTEST_FATAL_FAILURE_)\n\n\n\n// Helper function for implementing {EXPECT|ASSERT}_PRED2.  Don't use\n// this in your code.\ntemplate <typename Pred,\n          typename T1,\n          typename T2>\nAssertionResult AssertPred2Helper(const char* pred_text,\n                                  const char* e1,\n                                  const char* e2,\n                                  Pred pred,\n                                  const T1& v1,\n                                  const T2& v2) {\n  if (pred(v1, v2)) return AssertionSuccess();\n\n  return AssertionFailure() << pred_text << \"(\"\n                            << e1 << \", \"\n                            << e2 << \") evaluates to false, where\"\n                            << \"\\n\" << e1 << \" evaluates to \" << v1\n                            << \"\\n\" << e2 << \" evaluates to \" << v2;\n}\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED_FORMAT2.\n// Don't use this in your code.\n#define GTEST_PRED_FORMAT2_(pred_format, v1, v2, on_failure)\\\n  GTEST_ASSERT_(pred_format(#v1, #v2, v1, v2), \\\n                on_failure)\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED2.  Don't use\n// this in your code.\n#define GTEST_PRED2_(pred, v1, v2, on_failure)\\\n  GTEST_ASSERT_(::testing::AssertPred2Helper(#pred, \\\n                                             #v1, \\\n                                             #v2, \\\n                                             pred, \\\n                                             v1, \\\n                                             v2), on_failure)\n\n// Binary predicate assertion macros.\n#define EXPECT_PRED_FORMAT2(pred_format, v1, v2) \\\n  GTEST_PRED_FORMAT2_(pred_format, v1, v2, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_PRED2(pred, v1, v2) \\\n  GTEST_PRED2_(pred, v1, v2, GTEST_NONFATAL_FAILURE_)\n#define ASSERT_PRED_FORMAT2(pred_format, v1, v2) \\\n  GTEST_PRED_FORMAT2_(pred_format, v1, v2, GTEST_FATAL_FAILURE_)\n#define ASSERT_PRED2(pred, v1, v2) \\\n  GTEST_PRED2_(pred, v1, v2, GTEST_FATAL_FAILURE_)\n\n\n\n// Helper function for implementing {EXPECT|ASSERT}_PRED3.  Don't use\n// this in your code.\ntemplate <typename Pred,\n          typename T1,\n          typename T2,\n          typename T3>\nAssertionResult AssertPred3Helper(const char* pred_text,\n                                  const char* e1,\n                                  const char* e2,\n                                  const char* e3,\n                                  Pred pred,\n                                  const T1& v1,\n                                  const T2& v2,\n                                  const T3& v3) {\n  if (pred(v1, v2, v3)) return AssertionSuccess();\n\n  return AssertionFailure() << pred_text << \"(\"\n                            << e1 << \", \"\n                            << e2 << \", \"\n                            << e3 << \") evaluates to false, where\"\n                            << \"\\n\" << e1 << \" evaluates to \" << v1\n                            << \"\\n\" << e2 << \" evaluates to \" << v2\n                            << \"\\n\" << e3 << \" evaluates to \" << v3;\n}\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED_FORMAT3.\n// Don't use this in your code.\n#define GTEST_PRED_FORMAT3_(pred_format, v1, v2, v3, on_failure)\\\n  GTEST_ASSERT_(pred_format(#v1, #v2, #v3, v1, v2, v3), \\\n                on_failure)\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED3.  Don't use\n// this in your code.\n#define GTEST_PRED3_(pred, v1, v2, v3, on_failure)\\\n  GTEST_ASSERT_(::testing::AssertPred3Helper(#pred, \\\n                                             #v1, \\\n                                             #v2, \\\n                                             #v3, \\\n                                             pred, \\\n                                             v1, \\\n                                             v2, \\\n                                             v3), on_failure)\n\n// Ternary predicate assertion macros.\n#define EXPECT_PRED_FORMAT3(pred_format, v1, v2, v3) \\\n  GTEST_PRED_FORMAT3_(pred_format, v1, v2, v3, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_PRED3(pred, v1, v2, v3) \\\n  GTEST_PRED3_(pred, v1, v2, v3, GTEST_NONFATAL_FAILURE_)\n#define ASSERT_PRED_FORMAT3(pred_format, v1, v2, v3) \\\n  GTEST_PRED_FORMAT3_(pred_format, v1, v2, v3, GTEST_FATAL_FAILURE_)\n#define ASSERT_PRED3(pred, v1, v2, v3) \\\n  GTEST_PRED3_(pred, v1, v2, v3, GTEST_FATAL_FAILURE_)\n\n\n\n// Helper function for implementing {EXPECT|ASSERT}_PRED4.  Don't use\n// this in your code.\ntemplate <typename Pred,\n          typename T1,\n          typename T2,\n          typename T3,\n          typename T4>\nAssertionResult AssertPred4Helper(const char* pred_text,\n                                  const char* e1,\n                                  const char* e2,\n                                  const char* e3,\n                                  const char* e4,\n                                  Pred pred,\n                                  const T1& v1,\n                                  const T2& v2,\n                                  const T3& v3,\n                                  const T4& v4) {\n  if (pred(v1, v2, v3, v4)) return AssertionSuccess();\n\n  return AssertionFailure() << pred_text << \"(\"\n                            << e1 << \", \"\n                            << e2 << \", \"\n                            << e3 << \", \"\n                            << e4 << \") evaluates to false, where\"\n                            << \"\\n\" << e1 << \" evaluates to \" << v1\n                            << \"\\n\" << e2 << \" evaluates to \" << v2\n                            << \"\\n\" << e3 << \" evaluates to \" << v3\n                            << \"\\n\" << e4 << \" evaluates to \" << v4;\n}\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED_FORMAT4.\n// Don't use this in your code.\n#define GTEST_PRED_FORMAT4_(pred_format, v1, v2, v3, v4, on_failure)\\\n  GTEST_ASSERT_(pred_format(#v1, #v2, #v3, #v4, v1, v2, v3, v4), \\\n                on_failure)\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED4.  Don't use\n// this in your code.\n#define GTEST_PRED4_(pred, v1, v2, v3, v4, on_failure)\\\n  GTEST_ASSERT_(::testing::AssertPred4Helper(#pred, \\\n                                             #v1, \\\n                                             #v2, \\\n                                             #v3, \\\n                                             #v4, \\\n                                             pred, \\\n                                             v1, \\\n                                             v2, \\\n                                             v3, \\\n                                             v4), on_failure)\n\n// 4-ary predicate assertion macros.\n#define EXPECT_PRED_FORMAT4(pred_format, v1, v2, v3, v4) \\\n  GTEST_PRED_FORMAT4_(pred_format, v1, v2, v3, v4, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_PRED4(pred, v1, v2, v3, v4) \\\n  GTEST_PRED4_(pred, v1, v2, v3, v4, GTEST_NONFATAL_FAILURE_)\n#define ASSERT_PRED_FORMAT4(pred_format, v1, v2, v3, v4) \\\n  GTEST_PRED_FORMAT4_(pred_format, v1, v2, v3, v4, GTEST_FATAL_FAILURE_)\n#define ASSERT_PRED4(pred, v1, v2, v3, v4) \\\n  GTEST_PRED4_(pred, v1, v2, v3, v4, GTEST_FATAL_FAILURE_)\n\n\n\n// Helper function for implementing {EXPECT|ASSERT}_PRED5.  Don't use\n// this in your code.\ntemplate <typename Pred,\n          typename T1,\n          typename T2,\n          typename T3,\n          typename T4,\n          typename T5>\nAssertionResult AssertPred5Helper(const char* pred_text,\n                                  const char* e1,\n                                  const char* e2,\n                                  const char* e3,\n                                  const char* e4,\n                                  const char* e5,\n                                  Pred pred,\n                                  const T1& v1,\n                                  const T2& v2,\n                                  const T3& v3,\n                                  const T4& v4,\n                                  const T5& v5) {\n  if (pred(v1, v2, v3, v4, v5)) return AssertionSuccess();\n\n  return AssertionFailure() << pred_text << \"(\"\n                            << e1 << \", \"\n                            << e2 << \", \"\n                            << e3 << \", \"\n                            << e4 << \", \"\n                            << e5 << \") evaluates to false, where\"\n                            << \"\\n\" << e1 << \" evaluates to \" << v1\n                            << \"\\n\" << e2 << \" evaluates to \" << v2\n                            << \"\\n\" << e3 << \" evaluates to \" << v3\n                            << \"\\n\" << e4 << \" evaluates to \" << v4\n                            << \"\\n\" << e5 << \" evaluates to \" << v5;\n}\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED_FORMAT5.\n// Don't use this in your code.\n#define GTEST_PRED_FORMAT5_(pred_format, v1, v2, v3, v4, v5, on_failure)\\\n  GTEST_ASSERT_(pred_format(#v1, #v2, #v3, #v4, #v5, v1, v2, v3, v4, v5), \\\n                on_failure)\n\n// Internal macro for implementing {EXPECT|ASSERT}_PRED5.  Don't use\n// this in your code.\n#define GTEST_PRED5_(pred, v1, v2, v3, v4, v5, on_failure)\\\n  GTEST_ASSERT_(::testing::AssertPred5Helper(#pred, \\\n                                             #v1, \\\n                                             #v2, \\\n                                             #v3, \\\n                                             #v4, \\\n                                             #v5, \\\n                                             pred, \\\n                                             v1, \\\n                                             v2, \\\n                                             v3, \\\n                                             v4, \\\n                                             v5), on_failure)\n\n// 5-ary predicate assertion macros.\n#define EXPECT_PRED_FORMAT5(pred_format, v1, v2, v3, v4, v5) \\\n  GTEST_PRED_FORMAT5_(pred_format, v1, v2, v3, v4, v5, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_PRED5(pred, v1, v2, v3, v4, v5) \\\n  GTEST_PRED5_(pred, v1, v2, v3, v4, v5, GTEST_NONFATAL_FAILURE_)\n#define ASSERT_PRED_FORMAT5(pred_format, v1, v2, v3, v4, v5) \\\n  GTEST_PRED_FORMAT5_(pred_format, v1, v2, v3, v4, v5, GTEST_FATAL_FAILURE_)\n#define ASSERT_PRED5(pred, v1, v2, v3, v4, v5) \\\n  GTEST_PRED5_(pred, v1, v2, v3, v4, v5, GTEST_FATAL_FAILURE_)\n\n\n\n#endif  // GTEST_INCLUDE_GTEST_GTEST_PRED_IMPL_H_\n"}, "55": {"id": 55, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest_prod.h", "content": "// Copyright 2006, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n//\n// Google C++ Testing Framework definitions useful in production code.\n\n#ifndef GTEST_INCLUDE_GTEST_GTEST_PROD_H_\n#define GTEST_INCLUDE_GTEST_GTEST_PROD_H_\n\n// When you need to test the private or protected members of a class,\n// use the FRIEND_TEST macro to declare your tests as friends of the\n// class.  For example:\n//\n// class MyClass {\n//  private:\n//   void MyMethod();\n//   FRIEND_TEST(MyClassTest, MyMethod);\n// };\n//\n// class MyClassTest : public testing::Test {\n//   // ...\n// };\n//\n// TEST_F(MyClassTest, MyMethod) {\n//   // Can call MyClass::MyMethod() here.\n// }\n\n#define FRIEND_TEST(test_case_name, test_name)\\\nfriend class test_case_name##_##test_name##_Test\n\n#endif  // GTEST_INCLUDE_GTEST_GTEST_PROD_H_\n"}, "56": {"id": 56, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/custom/gtest-port.h", "content": "// Copyright 2015, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Injection point for custom user configurations.\n// The following macros can be defined:\n//\n//   Flag related macros:\n//     GTEST_FLAG(flag_name)\n//     GTEST_USE_OWN_FLAGFILE_FLAG_  - Define to 0 when the system provides its\n//                                     own flagfile flag parsing.\n//     GTEST_DECLARE_bool_(name)\n//     GTEST_DECLARE_int32_(name)\n//     GTEST_DECLARE_string_(name)\n//     GTEST_DEFINE_bool_(name, default_val, doc)\n//     GTEST_DEFINE_int32_(name, default_val, doc)\n//     GTEST_DEFINE_string_(name, default_val, doc)\n//\n//   Test filtering:\n//     GTEST_TEST_FILTER_ENV_VAR_ - The name of an environment variable that\n//                                  will be used if --GTEST_FLAG(test_filter)\n//                                  is not provided.\n//\n//   Logging:\n//     GTEST_LOG_(severity)\n//     GTEST_CHECK_(condition)\n//     Functions LogToStderr() and FlushInfoLog() have to be provided too.\n//\n//   Threading:\n//     GTEST_HAS_NOTIFICATION_ - Enabled if Notification is already provided.\n//     GTEST_HAS_MUTEX_AND_THREAD_LOCAL_ - Enabled if Mutex and ThreadLocal are\n//                                         already provided.\n//     Must also provide GTEST_DECLARE_STATIC_MUTEX_(mutex) and\n//     GTEST_DEFINE_STATIC_MUTEX_(mutex)\n//\n//     GTEST_EXCLUSIVE_LOCK_REQUIRED_(locks)\n//     GTEST_LOCK_EXCLUDED_(locks)\n//\n// ** Custom implementation starts here **\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_CUSTOM_GTEST_PORT_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_CUSTOM_GTEST_PORT_H_\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_CUSTOM_GTEST_PORT_H_\n"}, "57": {"id": 57, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/custom/gtest-printers.h", "content": "// Copyright 2015, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// This file provides an injection point for custom printers in a local\n// installation of gTest.\n// It will be included from gtest-printers.h and the overrides in this file\n// will be visible to everyone.\n// See documentation at gtest/gtest-printers.h for details on how to define a\n// custom printer.\n//\n// ** Custom implementation starts here **\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_CUSTOM_GTEST_PRINTERS_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_CUSTOM_GTEST_PRINTERS_H_\n\n#if !GTEST_NO_LLVM_SUPPORT\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <ostream>\n// Printing of llvm String types.\n// gtest sees these as containers of char (they have nested iterator types),\n// so their operator<< is never considered unless we provide PrintTo().\n// PrintStringTo provides quotes and escaping, at the cost of a copy.\nnamespace llvm {\ninline void PrintTo(llvm::StringRef S, std::ostream *OS) {\n  *OS << ::testing::PrintToString(S.str());\n}\n// We need both SmallString<N> and SmallVectorImpl<char> overloads:\n//  - the SmallString<N> template is needed as overload resolution will\n//    instantiate generic PrintTo<T> rather than do derived-to-base conversion\n//  - but SmallVectorImpl<char> is sometimes the actual static type, in code\n//    that erases the small size\ntemplate <unsigned N>\ninline void PrintTo(const SmallString<N> &S, std::ostream *OS) {\n  *OS << ::testing::PrintToString(std::string(S.data(), S.size()));\n}\ninline void PrintTo(const SmallVectorImpl<char> &S, std::ostream *OS) {\n  *OS << ::testing::PrintToString(std::string(S.data(), S.size()));\n}\n} // namespace llvm\n#endif // !GTEST_NO_LLVM_SUPPORT\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_CUSTOM_GTEST_PRINTERS_H_\n"}, "58": {"id": 58, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/custom/raw-ostream.h", "content": "//===-- raw-ostream.h - Support for printing using raw_ostream --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n// This file is not part of gtest, but extends it to support LLVM libraries.\n// This is not a public API for testing - it's a detail of LLVM's gtest.\n//\n// gtest allows providing printers for custom types by defining operator<<.\n// In LLVM, operator<< usually takes llvm:raw_ostream& instead of std::ostream&.\n//\n// This file defines a template printable(V), which returns a version of V that\n// can be streamed into a std::ostream.\n//\n// This interface is chosen so that in the default case (printable(V) is V),\n// the main gtest code calls operator<<(OS, V) itself. gtest-printers carefully\n// controls the lookup to enable fallback printing (see testing::internal2).\n//===----------------------------------------------------------------------===//\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_CUSTOM_RAW_OSTREAM_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_CUSTOM_RAW_OSTREAM_H_\n\nnamespace llvm_gtest {\n// StreamSwitch is a trait that tells us how to stream a T into a std::ostream.\n// By default, we just stream the T directly. We'll specialize this later.\ntemplate <typename T, typename Enable = void> struct StreamSwitch {\n  static const T& printable(const T& V) { return V; }\n};\n\n// printable() returns a version of its argument that can be streamed into a\n// std::ostream. This may be the argument itself, or some other representation.\ntemplate <typename T> decltype(auto) printable(const T &V) {\n  // We delegate to the trait, to allow partial specialization.\n  return StreamSwitch<T>::printable(V);\n}\n} // namespace llvm_gtest\n\n// If raw_ostream support is enabled, we specialize for types with operator<<\n// that takes a raw_ostream.\n#if !GTEST_NO_LLVM_SUPPORT\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/Support/raw_os_ostream.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <ostream>\nnamespace llvm_gtest {\n\n// The printable() of a raw_ostream-enabled type T is a RawStreamProxy<T>.\n// It uses raw_os_ostream to write the wrapped value to a std::ostream.\ntemplate <typename T>\nstruct RawStreamProxy {\n  const T& V;\n  friend std::ostream &operator<<(std::ostream &S, const RawStreamProxy<T> &V) {\n    llvm::raw_os_ostream OS(S);\n    OS << V.V;\n    return S;\n  }\n};\n\n// We enable raw_ostream treatment if `(raw_ostream&) << (const T&)` is valid.\n// We don't want implicit conversions on the RHS (e.g. to bool!), so \"consume\"\n// the possible conversion by passing something convertible to const T& instead.\ntemplate <typename T> struct ConvertibleTo { operator T(); };\ntemplate <typename T>\nstruct StreamSwitch<T, decltype((void)(std::declval<llvm::raw_ostream &>()\n                                       << ConvertibleTo<const T &>()))> {\n  static const RawStreamProxy<T> printable(const T &V) { return {V}; }\n};\n\n// llvm::Optional has a template operator<<, which means it will not accept any\n// implicit conversions, so we need to special-case it here.\ntemplate <typename T>\nstruct StreamSwitch<llvm::Optional<T>,\n                    decltype((void)(std::declval<llvm::raw_ostream &>()\n                                    << std::declval<llvm::Optional<T>>()))> {\n  static const RawStreamProxy<llvm::Optional<T>>\n  printable(const llvm::Optional<T> &V) {\n    return {V};\n  }\n};\n} // namespace llvm_gtest\n#endif  // !GTEST_NO_LLVM_SUPPORT\n\n#endif // GTEST_INCLUDE_GTEST_INTERNAL_CUSTOM_RAW_OSTREAM_H_\n"}, "59": {"id": 59, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-death-test-internal.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Authors: wan@google.com (Zhanyong Wan), eefacm@gmail.com (Sean Mcafee)\n//\n// The Google C++ Testing Framework (Google Test)\n//\n// This header file defines internal utilities needed for implementing\n// death tests.  They are subject to change without notice.\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_DEATH_TEST_INTERNAL_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_DEATH_TEST_INTERNAL_H_\n\n#include \"gtest/internal/gtest-internal.h\"\n\n#include <stdio.h>\n\nnamespace testing {\nnamespace internal {\n\nGTEST_DECLARE_string_(internal_run_death_test);\n\n// Names of the flags (needed for parsing Google Test flags).\nconst char kDeathTestStyleFlag[] = \"death_test_style\";\nconst char kDeathTestUseFork[] = \"death_test_use_fork\";\nconst char kInternalRunDeathTestFlag[] = \"internal_run_death_test\";\n\n#if GTEST_HAS_DEATH_TEST\n\n// DeathTest is a class that hides much of the complexity of the\n// GTEST_DEATH_TEST_ macro.  It is abstract; its static Create method\n// returns a concrete class that depends on the prevailing death test\n// style, as defined by the --gtest_death_test_style and/or\n// --gtest_internal_run_death_test flags.\n\n// In describing the results of death tests, these terms are used with\n// the corresponding definitions:\n//\n// exit status:  The integer exit information in the format specified\n//               by wait(2)\n// exit code:    The integer code passed to exit(3), _exit(2), or\n//               returned from main()\nclass GTEST_API_ DeathTest {\n public:\n  // Create returns false if there was an error determining the\n  // appropriate action to take for the current death test; for example,\n  // if the gtest_death_test_style flag is set to an invalid value.\n  // The LastMessage method will return a more detailed message in that\n  // case.  Otherwise, the DeathTest pointer pointed to by the \"test\"\n  // argument is set.  If the death test should be skipped, the pointer\n  // is set to NULL; otherwise, it is set to the address of a new concrete\n  // DeathTest object that controls the execution of the current test.\n  static bool Create(const char* statement, const RE* regex,\n                     const char* file, int line, DeathTest** test);\n  DeathTest();\n  virtual ~DeathTest() { }\n\n  // A helper class that aborts a death test when it's deleted.\n  class ReturnSentinel {\n   public:\n    explicit ReturnSentinel(DeathTest* test) : test_(test) { }\n    ~ReturnSentinel() { test_->Abort(TEST_ENCOUNTERED_RETURN_STATEMENT); }\n   private:\n    DeathTest* const test_;\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(ReturnSentinel);\n  } GTEST_ATTRIBUTE_UNUSED_;\n\n  // An enumeration of possible roles that may be taken when a death\n  // test is encountered.  EXECUTE means that the death test logic should\n  // be executed immediately.  OVERSEE means that the program should prepare\n  // the appropriate environment for a child process to execute the death\n  // test, then wait for it to complete.\n  enum TestRole { OVERSEE_TEST, EXECUTE_TEST };\n\n  // An enumeration of the three reasons that a test might be aborted.\n  enum AbortReason {\n    TEST_ENCOUNTERED_RETURN_STATEMENT,\n    TEST_THREW_EXCEPTION,\n    TEST_DID_NOT_DIE\n  };\n\n  // Assumes one of the above roles.\n  virtual TestRole AssumeRole() = 0;\n\n  // Waits for the death test to finish and returns its status.\n  virtual int Wait() = 0;\n\n  // Returns true if the death test passed; that is, the test process\n  // exited during the test, its exit status matches a user-supplied\n  // predicate, and its stderr output matches a user-supplied regular\n  // expression.\n  // The user-supplied predicate may be a macro expression rather\n  // than a function pointer or functor, or else Wait and Passed could\n  // be combined.\n  virtual bool Passed(bool exit_status_ok) = 0;\n\n  // Signals that the death test did not die as expected.\n  virtual void Abort(AbortReason reason) = 0;\n\n  // Returns a human-readable outcome message regarding the outcome of\n  // the last death test.\n  static const char* LastMessage();\n\n  static void set_last_death_test_message(const std::string& message);\n\n private:\n  // A string containing a description of the outcome of the last death test.\n  static std::string last_death_test_message_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(DeathTest);\n};\n\n// Factory interface for death tests.  May be mocked out for testing.\nclass DeathTestFactory {\n public:\n  virtual ~DeathTestFactory() { }\n  virtual bool Create(const char* statement, const RE* regex,\n                      const char* file, int line, DeathTest** test) = 0;\n};\n\n// A concrete DeathTestFactory implementation for normal use.\nclass DefaultDeathTestFactory : public DeathTestFactory {\n public:\n  virtual bool Create(const char* statement, const RE* regex,\n                      const char* file, int line, DeathTest** test);\n};\n\n// Returns true if exit_status describes a process that was terminated\n// by a signal, or exited normally with a nonzero exit code.\nGTEST_API_ bool ExitedUnsuccessfully(int exit_status);\n\n// Traps C++ exceptions escaping statement and reports them as test\n// failures. Note that trapping SEH exceptions is not implemented here.\n# if GTEST_HAS_EXCEPTIONS\n#  define GTEST_EXECUTE_DEATH_TEST_STATEMENT_(statement, death_test) \\\n  try { \\\n    GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n  } catch (const ::std::exception& gtest_exception) { \\\n    fprintf(\\\n        stderr, \\\n        \"\\n%s: Caught std::exception-derived exception escaping the \" \\\n        \"death test statement. Exception message: %s\\n\", \\\n        ::testing::internal::FormatFileLocation(__FILE__, __LINE__).c_str(), \\\n        gtest_exception.what()); \\\n    fflush(stderr); \\\n    death_test->Abort(::testing::internal::DeathTest::TEST_THREW_EXCEPTION); \\\n  } catch (...) { \\\n    death_test->Abort(::testing::internal::DeathTest::TEST_THREW_EXCEPTION); \\\n  }\n\n# else\n#  define GTEST_EXECUTE_DEATH_TEST_STATEMENT_(statement, death_test) \\\n  GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement)\n\n# endif\n\n// This macro is for implementing ASSERT_DEATH*, EXPECT_DEATH*,\n// ASSERT_EXIT*, and EXPECT_EXIT*.\n# define GTEST_DEATH_TEST_(statement, predicate, regex, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::AlwaysTrue()) { \\\n    const ::testing::internal::RE& gtest_regex = (regex); \\\n    ::testing::internal::DeathTest* gtest_dt; \\\n    if (!::testing::internal::DeathTest::Create(#statement, &gtest_regex, \\\n        __FILE__, __LINE__, &gtest_dt)) { \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_, __LINE__); \\\n    } \\\n    if (gtest_dt != NULL) { \\\n      ::testing::internal::scoped_ptr< ::testing::internal::DeathTest> \\\n          gtest_dt_ptr(gtest_dt); \\\n      switch (gtest_dt->AssumeRole()) { \\\n        case ::testing::internal::DeathTest::OVERSEE_TEST: \\\n          if (!gtest_dt->Passed(predicate(gtest_dt->Wait()))) { \\\n            goto GTEST_CONCAT_TOKEN_(gtest_label_, __LINE__); \\\n          } \\\n          break; \\\n        case ::testing::internal::DeathTest::EXECUTE_TEST: { \\\n          ::testing::internal::DeathTest::ReturnSentinel \\\n              gtest_sentinel(gtest_dt); \\\n          GTEST_EXECUTE_DEATH_TEST_STATEMENT_(statement, gtest_dt); \\\n          gtest_dt->Abort(::testing::internal::DeathTest::TEST_DID_NOT_DIE); \\\n          break; \\\n        } \\\n      } \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_, __LINE__): \\\n      fail(::testing::internal::DeathTest::LastMessage())\n// The symbol \"fail\" here expands to something into which a message\n// can be streamed.\n\n// This macro is for implementing ASSERT/EXPECT_DEBUG_DEATH when compiled in\n// NDEBUG mode. In this case we need the statements to be executed, the regex is\n// ignored, and the macro must accept a streamed message even though the message\n// is never printed.\n# define GTEST_EXECUTE_STATEMENT_(statement, regex) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::AlwaysTrue()) { \\\n     GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n  } else \\\n    ::testing::Message()\n\n// A class representing the parsed contents of the\n// --gtest_internal_run_death_test flag, as it existed when\n// RUN_ALL_TESTS was called.\nclass InternalRunDeathTestFlag {\n public:\n  InternalRunDeathTestFlag(const std::string& a_file,\n                           int a_line,\n                           int an_index,\n                           int a_write_fd)\n      : file_(a_file), line_(a_line), index_(an_index),\n        write_fd_(a_write_fd) {}\n\n  ~InternalRunDeathTestFlag() {\n    if (write_fd_ >= 0)\n      posix::Close(write_fd_);\n  }\n\n  const std::string& file() const { return file_; }\n  int line() const { return line_; }\n  int index() const { return index_; }\n  int write_fd() const { return write_fd_; }\n\n private:\n  std::string file_;\n  int line_;\n  int index_;\n  int write_fd_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(InternalRunDeathTestFlag);\n};\n\n// Returns a newly created InternalRunDeathTestFlag object with fields\n// initialized from the GTEST_FLAG(internal_run_death_test) flag if\n// the flag is specified; otherwise returns NULL.\nInternalRunDeathTestFlag* ParseInternalRunDeathTestFlag();\n\n#else  // GTEST_HAS_DEATH_TEST\n\n// This macro is used for implementing macros such as\n// EXPECT_DEATH_IF_SUPPORTED and ASSERT_DEATH_IF_SUPPORTED on systems where\n// death tests are not supported. Those macros must compile on such systems\n// iff EXPECT_DEATH and ASSERT_DEATH compile with the same parameters on\n// systems that support death tests. This allows one to write such a macro\n// on a system that does not support death tests and be sure that it will\n// compile on a death-test supporting system.\n//\n// Parameters:\n//   statement -  A statement that a macro such as EXPECT_DEATH would test\n//                for program termination. This macro has to make sure this\n//                statement is compiled but not executed, to ensure that\n//                EXPECT_DEATH_IF_SUPPORTED compiles with a certain\n//                parameter iff EXPECT_DEATH compiles with it.\n//   regex     -  A regex that a macro such as EXPECT_DEATH would use to test\n//                the output of statement.  This parameter has to be\n//                compiled but not evaluated by this macro, to ensure that\n//                this macro only accepts expressions that a macro such as\n//                EXPECT_DEATH would accept.\n//   terminator - Must be an empty statement for EXPECT_DEATH_IF_SUPPORTED\n//                and a return statement for ASSERT_DEATH_IF_SUPPORTED.\n//                This ensures that ASSERT_DEATH_IF_SUPPORTED will not\n//                compile inside functions where ASSERT_DEATH doesn't\n//                compile.\n//\n//  The branch that has an always false condition is used to ensure that\n//  statement and regex are compiled (and thus syntactically correct) but\n//  never executed. The unreachable code macro protects the terminator\n//  statement from generating an 'unreachable code' warning in case\n//  statement unconditionally returns or throws. The Message constructor at\n//  the end allows the syntax of streaming additional messages into the\n//  macro, for compilational compatibility with EXPECT_DEATH/ASSERT_DEATH.\n# define GTEST_UNSUPPORTED_DEATH_TEST_(statement, regex, terminator) \\\n    GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n    if (::testing::internal::AlwaysTrue()) { \\\n      GTEST_LOG_(WARNING) \\\n          << \"Death tests are not supported on this platform.\\n\" \\\n          << \"Statement '\" #statement \"' cannot be verified.\"; \\\n    } else if (::testing::internal::AlwaysFalse()) { \\\n      ::testing::internal::RE::PartialMatch(\".*\", (regex)); \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n      terminator; \\\n    } else \\\n      ::testing::Message()\n\n#endif  // GTEST_HAS_DEATH_TEST\n\n}  // namespace internal\n}  // namespace testing\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_DEATH_TEST_INTERNAL_H_\n"}, "60": {"id": 60, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-filepath.h", "content": "// Copyright 2008, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: keith.ray@gmail.com (Keith Ray)\n//\n// Google Test filepath utilities\n//\n// This header file declares classes and functions used internally by\n// Google Test.  They are subject to change without notice.\n//\n// This file is #included in <gtest/internal/gtest-internal.h>.\n// Do not include this header file separately!\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_FILEPATH_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_FILEPATH_H_\n\n#include \"gtest/internal/gtest-string.h\"\n\nnamespace testing {\nnamespace internal {\n\n// FilePath - a class for file and directory pathname manipulation which\n// handles platform-specific conventions (like the pathname separator).\n// Used for helper functions for naming files in a directory for xml output.\n// Except for Set methods, all methods are const or static, which provides an\n// \"immutable value object\" -- useful for peace of mind.\n// A FilePath with a value ending in a path separator (\"like/this/\") represents\n// a directory, otherwise it is assumed to represent a file. In either case,\n// it may or may not represent an actual file or directory in the file system.\n// Names are NOT checked for syntax correctness -- no checking for illegal\n// characters, malformed paths, etc.\n\nclass GTEST_API_ FilePath {\n public:\n  FilePath() : pathname_(\"\") { }\n  FilePath(const FilePath& rhs) : pathname_(rhs.pathname_) { }\n\n  explicit FilePath(const std::string& pathname) : pathname_(pathname) {\n    Normalize();\n  }\n\n  FilePath& operator=(const FilePath& rhs) {\n    Set(rhs);\n    return *this;\n  }\n\n  void Set(const FilePath& rhs) {\n    pathname_ = rhs.pathname_;\n  }\n\n  const std::string& string() const { return pathname_; }\n  const char* c_str() const { return pathname_.c_str(); }\n\n  // Returns the current working directory, or \"\" if unsuccessful.\n  static FilePath GetCurrentDir();\n\n  // Given directory = \"dir\", base_name = \"test\", number = 0,\n  // extension = \"xml\", returns \"dir/test.xml\". If number is greater\n  // than zero (e.g., 12), returns \"dir/test_12.xml\".\n  // On Windows platform, uses \\ as the separator rather than /.\n  static FilePath MakeFileName(const FilePath& directory,\n                               const FilePath& base_name,\n                               int number,\n                               const char* extension);\n\n  // Given directory = \"dir\", relative_path = \"test.xml\",\n  // returns \"dir/test.xml\".\n  // On Windows, uses \\ as the separator rather than /.\n  static FilePath ConcatPaths(const FilePath& directory,\n                              const FilePath& relative_path);\n\n  // Returns a pathname for a file that does not currently exist. The pathname\n  // will be directory/base_name.extension or\n  // directory/base_name_<number>.extension if directory/base_name.extension\n  // already exists. The number will be incremented until a pathname is found\n  // that does not already exist.\n  // Examples: 'dir/foo_test.xml' or 'dir/foo_test_1.xml'.\n  // There could be a race condition if two or more processes are calling this\n  // function at the same time -- they could both pick the same filename.\n  static FilePath GenerateUniqueFileName(const FilePath& directory,\n                                         const FilePath& base_name,\n                                         const char* extension);\n\n  // Returns true iff the path is \"\".\n  bool IsEmpty() const { return pathname_.empty(); }\n\n  // If input name has a trailing separator character, removes it and returns\n  // the name, otherwise return the name string unmodified.\n  // On Windows platform, uses \\ as the separator, other platforms use /.\n  FilePath RemoveTrailingPathSeparator() const;\n\n  // Returns a copy of the FilePath with the directory part removed.\n  // Example: FilePath(\"path/to/file\").RemoveDirectoryName() returns\n  // FilePath(\"file\"). If there is no directory part (\"just_a_file\"), it returns\n  // the FilePath unmodified. If there is no file part (\"just_a_dir/\") it\n  // returns an empty FilePath (\"\").\n  // On Windows platform, '\\' is the path separator, otherwise it is '/'.\n  FilePath RemoveDirectoryName() const;\n\n  // RemoveFileName returns the directory path with the filename removed.\n  // Example: FilePath(\"path/to/file\").RemoveFileName() returns \"path/to/\".\n  // If the FilePath is \"a_file\" or \"/a_file\", RemoveFileName returns\n  // FilePath(\"./\") or, on Windows, FilePath(\".\\\\\"). If the filepath does\n  // not have a file, like \"just/a/dir/\", it returns the FilePath unmodified.\n  // On Windows platform, '\\' is the path separator, otherwise it is '/'.\n  FilePath RemoveFileName() const;\n\n  // Returns a copy of the FilePath with the case-insensitive extension removed.\n  // Example: FilePath(\"dir/file.exe\").RemoveExtension(\"EXE\") returns\n  // FilePath(\"dir/file\"). If a case-insensitive extension is not\n  // found, returns a copy of the original FilePath.\n  FilePath RemoveExtension(const char* extension) const;\n\n  // Creates directories so that path exists. Returns true if successful or if\n  // the directories already exist; returns false if unable to create\n  // directories for any reason. Will also return false if the FilePath does\n  // not represent a directory (that is, it doesn't end with a path separator).\n  bool CreateDirectoriesRecursively() const;\n\n  // Create the directory so that path exists. Returns true if successful or\n  // if the directory already exists; returns false if unable to create the\n  // directory for any reason, including if the parent directory does not\n  // exist. Not named \"CreateDirectory\" because that's a macro on Windows.\n  bool CreateFolder() const;\n\n  // Returns true if FilePath describes something in the file-system,\n  // either a file, directory, or whatever, and that something exists.\n  bool FileOrDirectoryExists() const;\n\n  // Returns true if pathname describes a directory in the file-system\n  // that exists.\n  bool DirectoryExists() const;\n\n  // Returns true if FilePath ends with a path separator, which indicates that\n  // it is intended to represent a directory. Returns false otherwise.\n  // This does NOT check that a directory (or file) actually exists.\n  bool IsDirectory() const;\n\n  // Returns true if pathname describes a root directory. (Windows has one\n  // root directory per disk drive.)\n  bool IsRootDirectory() const;\n\n  // Returns true if pathname describes an absolute path.\n  bool IsAbsolutePath() const;\n\n private:\n  // Replaces multiple consecutive separators with a single separator.\n  // For example, \"bar///foo\" becomes \"bar/foo\". Does not eliminate other\n  // redundancies that might be in a pathname involving \".\" or \"..\".\n  //\n  // A pathname with multiple consecutive separators may occur either through\n  // user error or as a result of some scripts or APIs that generate a pathname\n  // with a trailing separator. On other platforms the same API or script\n  // may NOT generate a pathname with a trailing \"/\". Then elsewhere that\n  // pathname may have another \"/\" and pathname components added to it,\n  // without checking for the separator already being there.\n  // The script language and operating system may allow paths like \"foo//bar\"\n  // but some of the functions in FilePath will not handle that correctly. In\n  // particular, RemoveTrailingPathSeparator() only removes one separator, and\n  // it is called in CreateDirectoriesRecursively() assuming that it will change\n  // a pathname from directory syntax (trailing separator) to filename syntax.\n  //\n  // On Windows this method also replaces the alternate path separator '/' with\n  // the primary path separator '\\\\', so that for example \"bar\\\\/\\\\foo\" becomes\n  // \"bar\\\\foo\".\n\n  void Normalize();\n\n  // Returns a pointer to the last occurrence of a valid path separator in\n  // the FilePath. On Windows, for example, both '/' and '\\' are valid path\n  // separators. Returns NULL if no path separator was found.\n  const char* FindLastPathSeparator() const;\n\n  std::string pathname_;\n};  // class FilePath\n\n}  // namespace internal\n}  // namespace testing\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_FILEPATH_H_\n"}, "61": {"id": 61, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-internal.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Authors: wan@google.com (Zhanyong Wan), eefacm@gmail.com (Sean Mcafee)\n//\n// The Google C++ Testing Framework (Google Test)\n//\n// This header file declares functions and macros used internally by\n// Google Test.  They are subject to change without notice.\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_\n\n#include \"gtest/internal/gtest-port.h\"\n\n#if GTEST_OS_LINUX\n# include <stdlib.h>\n# include <sys/types.h>\n# include <sys/wait.h>\n# include <unistd.h>\n#endif  // GTEST_OS_LINUX\n\n#if GTEST_HAS_EXCEPTIONS\n# include <stdexcept>\n#endif\n\n#include <ctype.h>\n#include <float.h>\n#include <string.h>\n#include <iomanip>\n#include <limits>\n#include <map>\n#include <set>\n#include <string>\n#include <vector>\n\n#include \"gtest/gtest-message.h\"\n#include \"gtest/internal/gtest-string.h\"\n#include \"gtest/internal/gtest-filepath.h\"\n#include \"gtest/internal/gtest-type-util.h\"\n\n// Due to C++ preprocessor weirdness, we need double indirection to\n// concatenate two tokens when one of them is __LINE__.  Writing\n//\n//   foo ## __LINE__\n//\n// will result in the token foo__LINE__, instead of foo followed by\n// the current line number.  For more details, see\n// http://www.parashift.com/c++-faq-lite/misc-technical-issues.html#faq-39.6\n#define GTEST_CONCAT_TOKEN_(foo, bar) GTEST_CONCAT_TOKEN_IMPL_(foo, bar)\n#define GTEST_CONCAT_TOKEN_IMPL_(foo, bar) foo ## bar\n\nclass ProtocolMessage;\nnamespace proto2 { class Message; }\n\nnamespace testing {\n\n// Forward declarations.\n\nclass AssertionResult;                 // Result of an assertion.\nclass Message;                         // Represents a failure message.\nclass Test;                            // Represents a test.\nclass TestInfo;                        // Information about a test.\nclass TestPartResult;                  // Result of a test part.\nclass UnitTest;                        // A collection of test cases.\n\ntemplate <typename T>\n::std::string PrintToString(const T& value);\n\nnamespace internal {\n\nstruct TraceInfo;                      // Information about a trace point.\nclass ScopedTrace;                     // Implements scoped trace.\nclass TestInfoImpl;                    // Opaque implementation of TestInfo\nclass UnitTestImpl;                    // Opaque implementation of UnitTest\n\n// The text used in failure messages to indicate the start of the\n// stack trace.\nGTEST_API_ extern const char kStackTraceMarker[];\n\n// Two overloaded helpers for checking at compile time whether an\n// expression is a null pointer literal (i.e. NULL or any 0-valued\n// compile-time integral constant).  Their return values have\n// different sizes, so we can use sizeof() to test which version is\n// picked by the compiler.  These helpers have no implementations, as\n// we only need their signatures.\n//\n// Given IsNullLiteralHelper(x), the compiler will pick the first\n// version if x can be implicitly converted to Secret*, and pick the\n// second version otherwise.  Since Secret is a secret and incomplete\n// type, the only expression a user can write that has type Secret* is\n// a null pointer literal.  Therefore, we know that x is a null\n// pointer literal if and only if the first version is picked by the\n// compiler.\nchar IsNullLiteralHelper(Secret* p);\nchar (&IsNullLiteralHelper(...))[2];  // NOLINT\n\n// A compile-time bool constant that is true if and only if x is a\n// null pointer literal (i.e. NULL or any 0-valued compile-time\n// integral constant).\n#ifdef GTEST_ELLIPSIS_NEEDS_POD_\n// We lose support for NULL detection where the compiler doesn't like\n// passing non-POD classes through ellipsis (...).\n# define GTEST_IS_NULL_LITERAL_(x) false\n#else\n# define GTEST_IS_NULL_LITERAL_(x) \\\n    (sizeof(::testing::internal::IsNullLiteralHelper(x)) == 1)\n#endif  // GTEST_ELLIPSIS_NEEDS_POD_\n\n// Appends the user-supplied message to the Google-Test-generated message.\nGTEST_API_ std::string AppendUserMessage(\n    const std::string& gtest_msg, const Message& user_msg);\n\n#if GTEST_HAS_EXCEPTIONS\n\n// This exception is thrown by (and only by) a failed Google Test\n// assertion when GTEST_FLAG(throw_on_failure) is true (if exceptions\n// are enabled).  We derive it from std::runtime_error, which is for\n// errors presumably detectable only at run time.  Since\n// std::runtime_error inherits from std::exception, many testing\n// frameworks know how to extract and print the message inside it.\nclass GTEST_API_ GoogleTestFailureException : public ::std::runtime_error {\n public:\n  explicit GoogleTestFailureException(const TestPartResult& failure);\n};\n\n#endif  // GTEST_HAS_EXCEPTIONS\n\n// A helper class for creating scoped traces in user programs.\nclass GTEST_API_ ScopedTrace {\n public:\n  // The c'tor pushes the given source file location and message onto\n  // a trace stack maintained by Google Test.\n  ScopedTrace(const char* file, int line, const Message& message);\n\n  // The d'tor pops the info pushed by the c'tor.\n  //\n  // Note that the d'tor is not virtual in order to be efficient.\n  // Don't inherit from ScopedTrace!\n  ~ScopedTrace();\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ScopedTrace);\n} GTEST_ATTRIBUTE_UNUSED_;  // A ScopedTrace object does its job in its\n                            // c'tor and d'tor.  Therefore it doesn't\n                            // need to be used otherwise.\n\nnamespace edit_distance {\n// Returns the optimal edits to go from 'left' to 'right'.\n// All edits cost the same, with replace having lower priority than\n// add/remove.\n// Simple implementation of the Wagner\u2013Fischer algorithm.\n// See http://en.wikipedia.org/wiki/Wagner-Fischer_algorithm\nenum EditType { kMatch, kAdd, kRemove, kReplace };\nGTEST_API_ std::vector<EditType> CalculateOptimalEdits(\n    const std::vector<size_t>& left, const std::vector<size_t>& right);\n\n// Same as above, but the input is represented as strings.\nGTEST_API_ std::vector<EditType> CalculateOptimalEdits(\n    const std::vector<std::string>& left,\n    const std::vector<std::string>& right);\n\n// Create a diff of the input strings in Unified diff format.\nGTEST_API_ std::string CreateUnifiedDiff(const std::vector<std::string>& left,\n                                         const std::vector<std::string>& right,\n                                         size_t context = 2);\n\n}  // namespace edit_distance\n\n// Calculate the diff between 'left' and 'right' and return it in unified diff\n// format.\n// If not null, stores in 'total_line_count' the total number of lines found\n// in left + right.\nGTEST_API_ std::string DiffStrings(const std::string& left,\n                                   const std::string& right,\n                                   size_t* total_line_count);\n\n// Constructs and returns the message for an equality assertion\n// (e.g. ASSERT_EQ, EXPECT_STREQ, etc) failure.\n//\n// The first four parameters are the expressions used in the assertion\n// and their values, as strings.  For example, for ASSERT_EQ(foo, bar)\n// where foo is 5 and bar is 6, we have:\n//\n//   expected_expression: \"foo\"\n//   actual_expression:   \"bar\"\n//   expected_value:      \"5\"\n//   actual_value:        \"6\"\n//\n// The ignoring_case parameter is true iff the assertion is a\n// *_STRCASEEQ*.  When it's true, the string \" (ignoring case)\" will\n// be inserted into the message.\nGTEST_API_ AssertionResult EqFailure(const char* expected_expression,\n                                     const char* actual_expression,\n                                     const std::string& expected_value,\n                                     const std::string& actual_value,\n                                     bool ignoring_case);\n\n// Constructs a failure message for Boolean assertions such as EXPECT_TRUE.\nGTEST_API_ std::string GetBoolAssertionFailureMessage(\n    const AssertionResult& assertion_result,\n    const char* expression_text,\n    const char* actual_predicate_value,\n    const char* expected_predicate_value);\n\n// This template class represents an IEEE floating-point number\n// (either single-precision or double-precision, depending on the\n// template parameters).\n//\n// The purpose of this class is to do more sophisticated number\n// comparison.  (Due to round-off error, etc, it's very unlikely that\n// two floating-points will be equal exactly.  Hence a naive\n// comparison by the == operation often doesn't work.)\n//\n// Format of IEEE floating-point:\n//\n//   The most-significant bit being the leftmost, an IEEE\n//   floating-point looks like\n//\n//     sign_bit exponent_bits fraction_bits\n//\n//   Here, sign_bit is a single bit that designates the sign of the\n//   number.\n//\n//   For float, there are 8 exponent bits and 23 fraction bits.\n//\n//   For double, there are 11 exponent bits and 52 fraction bits.\n//\n//   More details can be found at\n//   http://en.wikipedia.org/wiki/IEEE_floating-point_standard.\n//\n// Template parameter:\n//\n//   RawType: the raw floating-point type (either float or double)\ntemplate <typename RawType>\nclass FloatingPoint {\n public:\n  // Defines the unsigned integer type that has the same size as the\n  // floating point number.\n  typedef typename TypeWithSize<sizeof(RawType)>::UInt Bits;\n\n  // Constants.\n\n  // # of bits in a number.\n  static const size_t kBitCount = 8*sizeof(RawType);\n\n  // # of fraction bits in a number.\n  static const size_t kFractionBitCount =\n    std::numeric_limits<RawType>::digits - 1;\n\n  // # of exponent bits in a number.\n  static const size_t kExponentBitCount = kBitCount - 1 - kFractionBitCount;\n\n  // The mask for the sign bit.\n  static const Bits kSignBitMask = static_cast<Bits>(1) << (kBitCount - 1);\n\n  // The mask for the fraction bits.\n  static const Bits kFractionBitMask =\n    ~static_cast<Bits>(0) >> (kExponentBitCount + 1);\n\n  // The mask for the exponent bits.\n  static const Bits kExponentBitMask = ~(kSignBitMask | kFractionBitMask);\n\n  // How many ULP's (Units in the Last Place) we want to tolerate when\n  // comparing two numbers.  The larger the value, the more error we\n  // allow.  A 0 value means that two numbers must be exactly the same\n  // to be considered equal.\n  //\n  // The maximum error of a single floating-point operation is 0.5\n  // units in the last place.  On Intel CPU's, all floating-point\n  // calculations are done with 80-bit precision, while double has 64\n  // bits.  Therefore, 4 should be enough for ordinary use.\n  //\n  // See the following article for more details on ULP:\n  // http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\n  static const size_t kMaxUlps = 4;\n\n  // Constructs a FloatingPoint from a raw floating-point number.\n  //\n  // On an Intel CPU, passing a non-normalized NAN (Not a Number)\n  // around may change its bits, although the new value is guaranteed\n  // to be also a NAN.  Therefore, don't expect this constructor to\n  // preserve the bits in x when x is a NAN.\n  explicit FloatingPoint(const RawType& x) { u_.value_ = x; }\n\n  // Static methods\n\n  // Reinterprets a bit pattern as a floating-point number.\n  //\n  // This function is needed to test the AlmostEquals() method.\n  static RawType ReinterpretBits(const Bits bits) {\n    FloatingPoint fp(0);\n    fp.u_.bits_ = bits;\n    return fp.u_.value_;\n  }\n\n  // Returns the floating-point number that represent positive infinity.\n  static RawType Infinity() {\n    return ReinterpretBits(kExponentBitMask);\n  }\n\n  // Returns the maximum representable finite floating-point number.\n  static RawType Max();\n\n  // Non-static methods\n\n  // Returns the bits that represents this number.\n  const Bits &bits() const { return u_.bits_; }\n\n  // Returns the exponent bits of this number.\n  Bits exponent_bits() const { return kExponentBitMask & u_.bits_; }\n\n  // Returns the fraction bits of this number.\n  Bits fraction_bits() const { return kFractionBitMask & u_.bits_; }\n\n  // Returns the sign bit of this number.\n  Bits sign_bit() const { return kSignBitMask & u_.bits_; }\n\n  // Returns true iff this is NAN (not a number).\n  bool is_nan() const {\n    // It's a NAN if the exponent bits are all ones and the fraction\n    // bits are not entirely zeros.\n    return (exponent_bits() == kExponentBitMask) && (fraction_bits() != 0);\n  }\n\n  // Returns true iff this number is at most kMaxUlps ULP's away from\n  // rhs.  In particular, this function:\n  //\n  //   - returns false if either number is (or both are) NAN.\n  //   - treats really large numbers as almost equal to infinity.\n  //   - thinks +0.0 and -0.0 are 0 DLP's apart.\n  bool AlmostEquals(const FloatingPoint& rhs) const {\n    // The IEEE standard says that any comparison operation involving\n    // a NAN must return false.\n    if (is_nan() || rhs.is_nan()) return false;\n\n    return DistanceBetweenSignAndMagnitudeNumbers(u_.bits_, rhs.u_.bits_)\n        <= kMaxUlps;\n  }\n\n private:\n  // The data type used to store the actual floating-point number.\n  union FloatingPointUnion {\n    RawType value_;  // The raw floating-point number.\n    Bits bits_;      // The bits that represent the number.\n  };\n\n  // Converts an integer from the sign-and-magnitude representation to\n  // the biased representation.  More precisely, let N be 2 to the\n  // power of (kBitCount - 1), an integer x is represented by the\n  // unsigned number x + N.\n  //\n  // For instance,\n  //\n  //   -N + 1 (the most negative number representable using\n  //          sign-and-magnitude) is represented by 1;\n  //   0      is represented by N; and\n  //   N - 1  (the biggest number representable using\n  //          sign-and-magnitude) is represented by 2N - 1.\n  //\n  // Read http://en.wikipedia.org/wiki/Signed_number_representations\n  // for more details on signed number representations.\n  static Bits SignAndMagnitudeToBiased(const Bits &sam) {\n    if (kSignBitMask & sam) {\n      // sam represents a negative number.\n      return ~sam + 1;\n    } else {\n      // sam represents a positive number.\n      return kSignBitMask | sam;\n    }\n  }\n\n  // Given two numbers in the sign-and-magnitude representation,\n  // returns the distance between them as an unsigned number.\n  static Bits DistanceBetweenSignAndMagnitudeNumbers(const Bits &sam1,\n                                                     const Bits &sam2) {\n    const Bits biased1 = SignAndMagnitudeToBiased(sam1);\n    const Bits biased2 = SignAndMagnitudeToBiased(sam2);\n    return (biased1 >= biased2) ? (biased1 - biased2) : (biased2 - biased1);\n  }\n\n  FloatingPointUnion u_;\n};\n\n// We cannot use std::numeric_limits<T>::max() as it clashes with the max()\n// macro defined by <windows.h>.\ntemplate <>\ninline float FloatingPoint<float>::Max() { return FLT_MAX; }\ntemplate <>\ninline double FloatingPoint<double>::Max() { return DBL_MAX; }\n\n// Typedefs the instances of the FloatingPoint template class that we\n// care to use.\ntypedef FloatingPoint<float> Float;\ntypedef FloatingPoint<double> Double;\n\n// In order to catch the mistake of putting tests that use different\n// test fixture classes in the same test case, we need to assign\n// unique IDs to fixture classes and compare them.  The TypeId type is\n// used to hold such IDs.  The user should treat TypeId as an opaque\n// type: the only operation allowed on TypeId values is to compare\n// them for equality using the == operator.\ntypedef const void* TypeId;\n\ntemplate <typename T>\nclass TypeIdHelper {\n public:\n  // dummy_ must not have a const type.  Otherwise an overly eager\n  // compiler (e.g. MSVC 7.1 & 8.0) may try to merge\n  // TypeIdHelper<T>::dummy_ for different Ts as an \"optimization\".\n  static bool dummy_;\n};\n\ntemplate <typename T>\nbool TypeIdHelper<T>::dummy_ = false;\n\n// GetTypeId<T>() returns the ID of type T.  Different values will be\n// returned for different types.  Calling the function twice with the\n// same type argument is guaranteed to return the same ID.\ntemplate <typename T>\nTypeId GetTypeId() {\n  // The compiler is required to allocate a different\n  // TypeIdHelper<T>::dummy_ variable for each T used to instantiate\n  // the template.  Therefore, the address of dummy_ is guaranteed to\n  // be unique.\n  return &(TypeIdHelper<T>::dummy_);\n}\n\n// Returns the type ID of ::testing::Test.  Always call this instead\n// of GetTypeId< ::testing::Test>() to get the type ID of\n// ::testing::Test, as the latter may give the wrong result due to a\n// suspected linker bug when compiling Google Test as a Mac OS X\n// framework.\nGTEST_API_ TypeId GetTestTypeId();\n\n// Defines the abstract factory interface that creates instances\n// of a Test object.\nclass TestFactoryBase {\n public:\n  virtual ~TestFactoryBase() {}\n\n  // Creates a test instance to run. The instance is both created and destroyed\n  // within TestInfoImpl::Run()\n  virtual Test* CreateTest() = 0;\n\n protected:\n  TestFactoryBase() {}\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestFactoryBase);\n};\n\n// This class provides implementation of TeastFactoryBase interface.\n// It is used in TEST and TEST_F macros.\ntemplate <class TestClass>\nclass TestFactoryImpl : public TestFactoryBase {\n public:\n  virtual Test* CreateTest() { return new TestClass; }\n};\n\n#if GTEST_OS_WINDOWS\n\n// Predicate-formatters for implementing the HRESULT checking macros\n// {ASSERT|EXPECT}_HRESULT_{SUCCEEDED|FAILED}\n// We pass a long instead of HRESULT to avoid causing an\n// include dependency for the HRESULT type.\nGTEST_API_ AssertionResult IsHRESULTSuccess(const char* expr,\n                                            long hr);  // NOLINT\nGTEST_API_ AssertionResult IsHRESULTFailure(const char* expr,\n                                            long hr);  // NOLINT\n\n#endif  // GTEST_OS_WINDOWS\n\n// Types of SetUpTestCase() and TearDownTestCase() functions.\ntypedef void (*SetUpTestCaseFunc)();\ntypedef void (*TearDownTestCaseFunc)();\n\nstruct CodeLocation {\n  CodeLocation(const string& a_file, int a_line) : file(a_file), line(a_line) {}\n\n  string file;\n  int line;\n};\n\n// Creates a new TestInfo object and registers it with Google Test;\n// returns the created object.\n//\n// Arguments:\n//\n//   test_case_name:   name of the test case\n//   name:             name of the test\n//   type_param        the name of the test's type parameter, or NULL if\n//                     this is not a typed or a type-parameterized test.\n//   value_param       text representation of the test's value parameter,\n//                     or NULL if this is not a type-parameterized test.\n//   code_location:    code location where the test is defined\n//   fixture_class_id: ID of the test fixture class\n//   set_up_tc:        pointer to the function that sets up the test case\n//   tear_down_tc:     pointer to the function that tears down the test case\n//   factory:          pointer to the factory that creates a test object.\n//                     The newly created TestInfo instance will assume\n//                     ownership of the factory object.\nGTEST_API_ TestInfo* MakeAndRegisterTestInfo(\n    const char* test_case_name,\n    const char* name,\n    const char* type_param,\n    const char* value_param,\n    CodeLocation code_location,\n    TypeId fixture_class_id,\n    SetUpTestCaseFunc set_up_tc,\n    TearDownTestCaseFunc tear_down_tc,\n    TestFactoryBase* factory);\n\n// If *pstr starts with the given prefix, modifies *pstr to be right\n// past the prefix and returns true; otherwise leaves *pstr unchanged\n// and returns false.  None of pstr, *pstr, and prefix can be NULL.\nGTEST_API_ bool SkipPrefix(const char* prefix, const char** pstr);\n\n#if GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P\n\n// State of the definition of a type-parameterized test case.\nclass GTEST_API_ TypedTestCasePState {\n public:\n  TypedTestCasePState() : registered_(false) {}\n\n  // Adds the given test name to defined_test_names_ and return true\n  // if the test case hasn't been registered; otherwise aborts the\n  // program.\n  bool AddTestName(const char* file, int line, const char* case_name,\n                   const char* test_name) {\n    if (registered_) {\n      fprintf(stderr, \"%s Test %s must be defined before \"\n              \"REGISTER_TYPED_TEST_CASE_P(%s, ...).\\n\",\n              FormatFileLocation(file, line).c_str(), test_name, case_name);\n      fflush(stderr);\n      posix::Abort();\n    }\n    registered_tests_.insert(\n        ::std::make_pair(test_name, CodeLocation(file, line)));\n    return true;\n  }\n\n  bool TestExists(const std::string& test_name) const {\n    return registered_tests_.count(test_name) > 0;\n  }\n\n  const CodeLocation& GetCodeLocation(const std::string& test_name) const {\n    RegisteredTestsMap::const_iterator it = registered_tests_.find(test_name);\n    GTEST_CHECK_(it != registered_tests_.end());\n    return it->second;\n  }\n\n  // Verifies that registered_tests match the test names in\n  // defined_test_names_; returns registered_tests if successful, or\n  // aborts the program otherwise.\n  const char* VerifyRegisteredTestNames(\n      const char* file, int line, const char* registered_tests);\n\n private:\n  typedef ::std::map<std::string, CodeLocation> RegisteredTestsMap;\n\n  bool registered_;\n  RegisteredTestsMap registered_tests_;\n};\n\n// Skips to the first non-space char after the first comma in 'str';\n// returns NULL if no comma is found in 'str'.\ninline const char* SkipComma(const char* str) {\n  const char* comma = strchr(str, ',');\n  if (comma == NULL) {\n    return NULL;\n  }\n  while (IsSpace(*(++comma))) {}\n  return comma;\n}\n\n// Returns the prefix of 'str' before the first comma in it; returns\n// the entire string if it contains no comma.\ninline std::string GetPrefixUntilComma(const char* str) {\n  const char* comma = strchr(str, ',');\n  return comma == NULL ? str : std::string(str, comma);\n}\n\n// Splits a given string on a given delimiter, populating a given\n// vector with the fields.\nvoid SplitString(const ::std::string& str, char delimiter,\n                 ::std::vector< ::std::string>* dest);\n\n// TypeParameterizedTest<Fixture, TestSel, Types>::Register()\n// registers a list of type-parameterized tests with Google Test.  The\n// return value is insignificant - we just need to return something\n// such that we can call this function in a namespace scope.\n//\n// Implementation note: The GTEST_TEMPLATE_ macro declares a template\n// template parameter.  It's defined in gtest-type-util.h.\ntemplate <GTEST_TEMPLATE_ Fixture, class TestSel, typename Types>\nclass TypeParameterizedTest {\n public:\n  // 'index' is the index of the test in the type list 'Types'\n  // specified in INSTANTIATE_TYPED_TEST_CASE_P(Prefix, TestCase,\n  // Types).  Valid values for 'index' are [0, N - 1] where N is the\n  // length of Types.\n  static bool Register(const char* prefix,\n                       CodeLocation code_location,\n                       const char* case_name, const char* test_names,\n                       int index) {\n    typedef typename Types::Head Type;\n    typedef Fixture<Type> FixtureClass;\n    typedef typename GTEST_BIND_(TestSel, Type) TestClass;\n\n    // First, registers the first type-parameterized test in the type\n    // list.\n    MakeAndRegisterTestInfo(\n        (std::string(prefix) + (prefix[0] == '\\0' ? \"\" : \"/\") + case_name + \"/\"\n         + StreamableToString(index)).c_str(),\n        StripTrailingSpaces(GetPrefixUntilComma(test_names)).c_str(),\n        GetTypeName<Type>().c_str(),\n        NULL,  // No value parameter.\n        code_location,\n        GetTypeId<FixtureClass>(),\n        TestClass::SetUpTestCase,\n        TestClass::TearDownTestCase,\n        new TestFactoryImpl<TestClass>);\n\n    // Next, recurses (at compile time) with the tail of the type list.\n    return TypeParameterizedTest<Fixture, TestSel, typename Types::Tail>\n        ::Register(prefix, code_location, case_name, test_names, index + 1);\n  }\n};\n\n// The base case for the compile time recursion.\ntemplate <GTEST_TEMPLATE_ Fixture, class TestSel>\nclass TypeParameterizedTest<Fixture, TestSel, Types0> {\n public:\n  static bool Register(const char* /*prefix*/, CodeLocation,\n                       const char* /*case_name*/, const char* /*test_names*/,\n                       int /*index*/) {\n    return true;\n  }\n};\n\n// TypeParameterizedTestCase<Fixture, Tests, Types>::Register()\n// registers *all combinations* of 'Tests' and 'Types' with Google\n// Test.  The return value is insignificant - we just need to return\n// something such that we can call this function in a namespace scope.\ntemplate <GTEST_TEMPLATE_ Fixture, typename Tests, typename Types>\nclass TypeParameterizedTestCase {\n public:\n  static bool Register(const char* prefix, CodeLocation code_location,\n                       const TypedTestCasePState* state,\n                       const char* case_name, const char* test_names) {\n    std::string test_name = StripTrailingSpaces(\n        GetPrefixUntilComma(test_names));\n    if (!state->TestExists(test_name)) {\n      fprintf(stderr, \"Failed to get code location for test %s.%s at %s.\",\n              case_name, test_name.c_str(),\n              FormatFileLocation(code_location.file.c_str(),\n                                 code_location.line).c_str());\n      fflush(stderr);\n      posix::Abort();\n    }\n    const CodeLocation& test_location = state->GetCodeLocation(test_name);\n\n    typedef typename Tests::Head Head;\n\n    // First, register the first test in 'Test' for each type in 'Types'.\n    TypeParameterizedTest<Fixture, Head, Types>::Register(\n        prefix, test_location, case_name, test_names, 0);\n\n    // Next, recurses (at compile time) with the tail of the test list.\n    return TypeParameterizedTestCase<Fixture, typename Tests::Tail, Types>\n        ::Register(prefix, code_location, state,\n                   case_name, SkipComma(test_names));\n  }\n};\n\n// The base case for the compile time recursion.\ntemplate <GTEST_TEMPLATE_ Fixture, typename Types>\nclass TypeParameterizedTestCase<Fixture, Templates0, Types> {\n public:\n  static bool Register(const char* /*prefix*/, CodeLocation,\n                       const TypedTestCasePState* /*state*/,\n                       const char* /*case_name*/, const char* /*test_names*/) {\n    return true;\n  }\n};\n\n#endif  // GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P\n\n// Returns the current OS stack trace as an std::string.\n//\n// The maximum number of stack frames to be included is specified by\n// the gtest_stack_trace_depth flag.  The skip_count parameter\n// specifies the number of top frames to be skipped, which doesn't\n// count against the number of frames to be included.\n//\n// For example, if Foo() calls Bar(), which in turn calls\n// GetCurrentOsStackTraceExceptTop(..., 1), Foo() will be included in\n// the trace but Bar() and GetCurrentOsStackTraceExceptTop() won't.\nGTEST_API_ std::string GetCurrentOsStackTraceExceptTop(\n    UnitTest* unit_test, int skip_count);\n\n// Helpers for suppressing warnings on unreachable code or constant\n// condition.\n\n// Always returns true.\nGTEST_API_ bool AlwaysTrue();\n\n// Always returns false.\ninline bool AlwaysFalse() { return !AlwaysTrue(); }\n\n// Helper for suppressing false warning from Clang on a const char*\n// variable declared in a conditional expression always being NULL in\n// the else branch.\nstruct GTEST_API_ ConstCharPtr {\n  ConstCharPtr(const char* str) : value(str) {}\n  operator bool() const { return true; }\n  const char* value;\n};\n\n// A simple Linear Congruential Generator for generating random\n// numbers with a uniform distribution.  Unlike rand() and srand(), it\n// doesn't use global state (and therefore can't interfere with user\n// code).  Unlike rand_r(), it's portable.  An LCG isn't very random,\n// but it's good enough for our purposes.\nclass GTEST_API_ Random {\n public:\n  static const UInt32 kMaxRange = 1u << 31;\n\n  explicit Random(UInt32 seed) : state_(seed) {}\n\n  void Reseed(UInt32 seed) { state_ = seed; }\n\n  // Generates a random number from [0, range).  Crashes if 'range' is\n  // 0 or greater than kMaxRange.\n  UInt32 Generate(UInt32 range);\n\n private:\n  UInt32 state_;\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Random);\n};\n\n// Defining a variable of type CompileAssertTypesEqual<T1, T2> will cause a\n// compiler error iff T1 and T2 are different types.\ntemplate <typename T1, typename T2>\nstruct CompileAssertTypesEqual;\n\ntemplate <typename T>\nstruct CompileAssertTypesEqual<T, T> {\n};\n\n// Removes the reference from a type if it is a reference type,\n// otherwise leaves it unchanged.  This is the same as\n// tr1::remove_reference, which is not widely available yet.\ntemplate <typename T>\nstruct RemoveReference { typedef T type; };  // NOLINT\ntemplate <typename T>\nstruct RemoveReference<T&> { typedef T type; };  // NOLINT\n\n// A handy wrapper around RemoveReference that works when the argument\n// T depends on template parameters.\n#define GTEST_REMOVE_REFERENCE_(T) \\\n    typename ::testing::internal::RemoveReference<T>::type\n\n// Removes const from a type if it is a const type, otherwise leaves\n// it unchanged.  This is the same as tr1::remove_const, which is not\n// widely available yet.\ntemplate <typename T>\nstruct RemoveConst { typedef T type; };  // NOLINT\ntemplate <typename T>\nstruct RemoveConst<const T> { typedef T type; };  // NOLINT\n\n// MSVC 8.0, Sun C++, and IBM XL C++ have a bug which causes the above\n// definition to fail to remove the const in 'const int[3]' and 'const\n// char[3][4]'.  The following specialization works around the bug.\ntemplate <typename T, size_t N>\nstruct RemoveConst<const T[N]> {\n  typedef typename RemoveConst<T>::type type[N];\n};\n\n#if defined(_MSC_VER) && _MSC_VER < 1400\n// This is the only specialization that allows VC++ 7.1 to remove const in\n// 'const int[3] and 'const int[3][4]'.  However, it causes trouble with GCC\n// and thus needs to be conditionally compiled.\ntemplate <typename T, size_t N>\nstruct RemoveConst<T[N]> {\n  typedef typename RemoveConst<T>::type type[N];\n};\n#endif\n\n// A handy wrapper around RemoveConst that works when the argument\n// T depends on template parameters.\n#define GTEST_REMOVE_CONST_(T) \\\n    typename ::testing::internal::RemoveConst<T>::type\n\n// Turns const U&, U&, const U, and U all into U.\n#define GTEST_REMOVE_REFERENCE_AND_CONST_(T) \\\n    GTEST_REMOVE_CONST_(GTEST_REMOVE_REFERENCE_(T))\n\n// Adds reference to a type if it is not a reference type,\n// otherwise leaves it unchanged.  This is the same as\n// tr1::add_reference, which is not widely available yet.\ntemplate <typename T>\nstruct AddReference { typedef T& type; };  // NOLINT\ntemplate <typename T>\nstruct AddReference<T&> { typedef T& type; };  // NOLINT\n\n// A handy wrapper around AddReference that works when the argument T\n// depends on template parameters.\n#define GTEST_ADD_REFERENCE_(T) \\\n    typename ::testing::internal::AddReference<T>::type\n\n// Adds a reference to const on top of T as necessary.  For example,\n// it transforms\n//\n//   char         ==> const char&\n//   const char   ==> const char&\n//   char&        ==> const char&\n//   const char&  ==> const char&\n//\n// The argument T must depend on some template parameters.\n#define GTEST_REFERENCE_TO_CONST_(T) \\\n    GTEST_ADD_REFERENCE_(const GTEST_REMOVE_REFERENCE_(T))\n\n// ImplicitlyConvertible<From, To>::value is a compile-time bool\n// constant that's true iff type From can be implicitly converted to\n// type To.\ntemplate <typename From, typename To>\nclass ImplicitlyConvertible {\n private:\n  // We need the following helper functions only for their types.\n  // They have no implementations.\n\n  // MakeFrom() is an expression whose type is From.  We cannot simply\n  // use From(), as the type From may not have a public default\n  // constructor.\n  static typename AddReference<From>::type MakeFrom();\n\n  // These two functions are overloaded.  Given an expression\n  // Helper(x), the compiler will pick the first version if x can be\n  // implicitly converted to type To; otherwise it will pick the\n  // second version.\n  //\n  // The first version returns a value of size 1, and the second\n  // version returns a value of size 2.  Therefore, by checking the\n  // size of Helper(x), which can be done at compile time, we can tell\n  // which version of Helper() is used, and hence whether x can be\n  // implicitly converted to type To.\n  static char Helper(To);\n  static char (&Helper(...))[2];  // NOLINT\n\n  // We have to put the 'public' section after the 'private' section,\n  // or MSVC refuses to compile the code.\n public:\n#if defined(__BORLANDC__)\n  // C++Builder cannot use member overload resolution during template\n  // instantiation.  The simplest workaround is to use its C++0x type traits\n  // functions (C++Builder 2009 and above only).\n  static const bool value = __is_convertible(From, To);\n#else\n  // MSVC warns about implicitly converting from double to int for\n  // possible loss of data, so we need to temporarily disable the\n  // warning.\n  GTEST_DISABLE_MSC_WARNINGS_PUSH_(4244)\n  static const bool value =\n      sizeof(Helper(ImplicitlyConvertible::MakeFrom())) == 1;\n  GTEST_DISABLE_MSC_WARNINGS_POP_()\n#endif  // __BORLANDC__\n};\ntemplate <typename From, typename To>\nconst bool ImplicitlyConvertible<From, To>::value;\n\n// IsAProtocolMessage<T>::value is a compile-time bool constant that's\n// true iff T is type ProtocolMessage, proto2::Message, or a subclass\n// of those.\ntemplate <typename T>\nstruct IsAProtocolMessage\n    : public bool_constant<\n  ImplicitlyConvertible<const T*, const ::ProtocolMessage*>::value ||\n  ImplicitlyConvertible<const T*, const ::proto2::Message*>::value> {\n};\n\n// When the compiler sees expression IsContainerTest<C>(0), if C is an\n// STL-style container class, the first overload of IsContainerTest\n// will be viable (since both C::iterator* and C::const_iterator* are\n// valid types and NULL can be implicitly converted to them).  It will\n// be picked over the second overload as 'int' is a perfect match for\n// the type of argument 0.  If C::iterator or C::const_iterator is not\n// a valid type, the first overload is not viable, and the second\n// overload will be picked.  Therefore, we can determine whether C is\n// a container class by checking the type of IsContainerTest<C>(0).\n// The value of the expression is insignificant.\n//\n// Note that we look for both C::iterator and C::const_iterator.  The\n// reason is that C++ injects the name of a class as a member of the\n// class itself (e.g. you can refer to class iterator as either\n// 'iterator' or 'iterator::iterator').  If we look for C::iterator\n// only, for example, we would mistakenly think that a class named\n// iterator is an STL container.\n//\n// Also note that the simpler approach of overloading\n// IsContainerTest(typename C::const_iterator*) and\n// IsContainerTest(...) doesn't work with Visual Age C++ and Sun C++.\ntypedef int IsContainer;\ntemplate <class C>\nIsContainer IsContainerTest(int /* dummy */,\n                            typename C::iterator* /* it */ = NULL,\n                            typename C::const_iterator* /* const_it */ = NULL) {\n  return 0;\n}\n\ntypedef char IsNotContainer;\ntemplate <class C>\nIsNotContainer IsContainerTest(long /* dummy */) { return '\\0'; }\n\n// EnableIf<condition>::type is void when 'Cond' is true, and\n// undefined when 'Cond' is false.  To use SFINAE to make a function\n// overload only apply when a particular expression is true, add\n// \"typename EnableIf<expression>::type* = 0\" as the last parameter.\ntemplate<bool> struct EnableIf;\ntemplate<> struct EnableIf<true> { typedef void type; };  // NOLINT\n\n// Utilities for native arrays.\n\n// ArrayEq() compares two k-dimensional native arrays using the\n// elements' operator==, where k can be any integer >= 0.  When k is\n// 0, ArrayEq() degenerates into comparing a single pair of values.\n\ntemplate <typename T, typename U>\nbool ArrayEq(const T* lhs, size_t size, const U* rhs);\n\n// This generic version is used when k is 0.\ntemplate <typename T, typename U>\ninline bool ArrayEq(const T& lhs, const U& rhs) { return lhs == rhs; }\n\n// This overload is used when k >= 1.\ntemplate <typename T, typename U, size_t N>\ninline bool ArrayEq(const T(&lhs)[N], const U(&rhs)[N]) {\n  return internal::ArrayEq(lhs, N, rhs);\n}\n\n// This helper reduces code bloat.  If we instead put its logic inside\n// the previous ArrayEq() function, arrays with different sizes would\n// lead to different copies of the template code.\ntemplate <typename T, typename U>\nbool ArrayEq(const T* lhs, size_t size, const U* rhs) {\n  for (size_t i = 0; i != size; i++) {\n    if (!internal::ArrayEq(lhs[i], rhs[i]))\n      return false;\n  }\n  return true;\n}\n\n// Finds the first element in the iterator range [begin, end) that\n// equals elem.  Element may be a native array type itself.\ntemplate <typename Iter, typename Element>\nIter ArrayAwareFind(Iter begin, Iter end, const Element& elem) {\n  for (Iter it = begin; it != end; ++it) {\n    if (internal::ArrayEq(*it, elem))\n      return it;\n  }\n  return end;\n}\n\n// CopyArray() copies a k-dimensional native array using the elements'\n// operator=, where k can be any integer >= 0.  When k is 0,\n// CopyArray() degenerates into copying a single value.\n\ntemplate <typename T, typename U>\nvoid CopyArray(const T* from, size_t size, U* to);\n\n// This generic version is used when k is 0.\ntemplate <typename T, typename U>\ninline void CopyArray(const T& from, U* to) { *to = from; }\n\n// This overload is used when k >= 1.\ntemplate <typename T, typename U, size_t N>\ninline void CopyArray(const T(&from)[N], U(*to)[N]) {\n  internal::CopyArray(from, N, *to);\n}\n\n// This helper reduces code bloat.  If we instead put its logic inside\n// the previous CopyArray() function, arrays with different sizes\n// would lead to different copies of the template code.\ntemplate <typename T, typename U>\nvoid CopyArray(const T* from, size_t size, U* to) {\n  for (size_t i = 0; i != size; i++) {\n    internal::CopyArray(from[i], to + i);\n  }\n}\n\n// The relation between an NativeArray object (see below) and the\n// native array it represents.\n// We use 2 different structs to allow non-copyable types to be used, as long\n// as RelationToSourceReference() is passed.\nstruct RelationToSourceReference {};\nstruct RelationToSourceCopy {};\n\n// Adapts a native array to a read-only STL-style container.  Instead\n// of the complete STL container concept, this adaptor only implements\n// members useful for Google Mock's container matchers.  New members\n// should be added as needed.  To simplify the implementation, we only\n// support Element being a raw type (i.e. having no top-level const or\n// reference modifier).  It's the client's responsibility to satisfy\n// this requirement.  Element can be an array type itself (hence\n// multi-dimensional arrays are supported).\ntemplate <typename Element>\nclass NativeArray {\n public:\n  // STL-style container typedefs.\n  typedef Element value_type;\n  typedef Element* iterator;\n  typedef const Element* const_iterator;\n\n  // Constructs from a native array. References the source.\n  NativeArray(const Element* array, size_t count, RelationToSourceReference) {\n    InitRef(array, count);\n  }\n\n  // Constructs from a native array. Copies the source.\n  NativeArray(const Element* array, size_t count, RelationToSourceCopy) {\n    InitCopy(array, count);\n  }\n\n  // Copy constructor.\n  NativeArray(const NativeArray& rhs) {\n    (this->*rhs.clone_)(rhs.array_, rhs.size_);\n  }\n\n  ~NativeArray() {\n    if (clone_ != &NativeArray::InitRef)\n      delete[] array_;\n  }\n\n  // STL-style container methods.\n  size_t size() const { return size_; }\n  const_iterator begin() const { return array_; }\n  const_iterator end() const { return array_ + size_; }\n  bool operator==(const NativeArray& rhs) const {\n    return size() == rhs.size() &&\n        ArrayEq(begin(), size(), rhs.begin());\n  }\n\n private:\n  enum {\n    kCheckTypeIsNotConstOrAReference = StaticAssertTypeEqHelper<\n        Element, GTEST_REMOVE_REFERENCE_AND_CONST_(Element)>::value,\n  };\n\n  // Initializes this object with a copy of the input.\n  void InitCopy(const Element* array, size_t a_size) {\n    Element* const copy = new Element[a_size];\n    CopyArray(array, a_size, copy);\n    array_ = copy;\n    size_ = a_size;\n    clone_ = &NativeArray::InitCopy;\n  }\n\n  // Initializes this object with a reference of the input.\n  void InitRef(const Element* array, size_t a_size) {\n    array_ = array;\n    size_ = a_size;\n    clone_ = &NativeArray::InitRef;\n  }\n\n  const Element* array_;\n  size_t size_;\n  void (NativeArray::*clone_)(const Element*, size_t);\n\n  GTEST_DISALLOW_ASSIGN_(NativeArray);\n};\n\n}  // namespace internal\n}  // namespace testing\n\n#define GTEST_MESSAGE_AT_(file, line, message, result_type) \\\n  ::testing::internal::AssertHelper(result_type, file, line, message) \\\n    = ::testing::Message()\n\n#define GTEST_MESSAGE_(message, result_type) \\\n  GTEST_MESSAGE_AT_(__FILE__, __LINE__, message, result_type)\n\n#define GTEST_FATAL_FAILURE_(message) \\\n  return GTEST_MESSAGE_(message, ::testing::TestPartResult::kFatalFailure)\n\n#define GTEST_NONFATAL_FAILURE_(message) \\\n  GTEST_MESSAGE_(message, ::testing::TestPartResult::kNonFatalFailure)\n\n#define GTEST_SUCCESS_(message) \\\n  GTEST_MESSAGE_(message, ::testing::TestPartResult::kSuccess)\n\n// Suppresses MSVC warnings 4072 (unreachable code) for the code following\n// statement if it returns or throws (or doesn't return or throw in some\n// situations).\n#define GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement) \\\n  if (::testing::internal::AlwaysTrue()) { statement; }\n\n#define GTEST_TEST_THROW_(statement, expected_exception, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::ConstCharPtr gtest_msg = \"\") { \\\n    bool gtest_caught_expected = false; \\\n    try { \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    } \\\n    catch (expected_exception const&) { \\\n      gtest_caught_expected = true; \\\n    } \\\n    catch (...) { \\\n      gtest_msg.value = \\\n          \"Expected: \" #statement \" throws an exception of type \" \\\n          #expected_exception \".\\n  Actual: it throws a different type.\"; \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \\\n    } \\\n    if (!gtest_caught_expected) { \\\n      gtest_msg.value = \\\n          \"Expected: \" #statement \" throws an exception of type \" \\\n          #expected_exception \".\\n  Actual: it throws nothing.\"; \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__): \\\n      fail(gtest_msg.value)\n\n#define GTEST_TEST_NO_THROW_(statement, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::AlwaysTrue()) { \\\n    try { \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    } \\\n    catch (...) { \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__): \\\n      fail(\"Expected: \" #statement \" doesn't throw an exception.\\n\" \\\n           \"  Actual: it throws.\")\n\n#define GTEST_TEST_ANY_THROW_(statement, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::AlwaysTrue()) { \\\n    bool gtest_caught_any = false; \\\n    try { \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    } \\\n    catch (...) { \\\n      gtest_caught_any = true; \\\n    } \\\n    if (!gtest_caught_any) { \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__): \\\n      fail(\"Expected: \" #statement \" throws an exception.\\n\" \\\n           \"  Actual: it doesn't.\")\n\n\n// Implements Boolean test assertions such as EXPECT_TRUE. expression can be\n// either a boolean expression or an AssertionResult. text is a textual\n// represenation of expression as it was passed into the EXPECT_TRUE.\n#define GTEST_TEST_BOOLEAN_(expression, text, actual, expected, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (const ::testing::AssertionResult gtest_ar_ = \\\n      ::testing::AssertionResult(expression)) \\\n    ; \\\n  else \\\n    fail(::testing::internal::GetBoolAssertionFailureMessage(\\\n        gtest_ar_, text, #actual, #expected).c_str())\n\n#define GTEST_TEST_NO_FATAL_FAILURE_(statement, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::AlwaysTrue()) { \\\n    ::testing::internal::HasNewFatalFailureHelper gtest_fatal_failure_checker; \\\n    GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    if (gtest_fatal_failure_checker.has_new_fatal_failure()) { \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__): \\\n      fail(\"Expected: \" #statement \" doesn't generate new fatal \" \\\n           \"failures in the current thread.\\n\" \\\n           \"  Actual: it does.\")\n\n// Expands to the name of the class that implements the given test.\n#define GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \\\n  test_case_name##_##test_name##_Test\n\n// Helper macro for defining tests.\n#define GTEST_TEST_(test_case_name, test_name, parent_class, parent_id)\\\nclass GTEST_TEST_CLASS_NAME_(test_case_name, test_name) : public parent_class {\\\n public:\\\n  GTEST_TEST_CLASS_NAME_(test_case_name, test_name)() {}\\\n private:\\\n  virtual void TestBody();\\\n  static ::testing::TestInfo* const test_info_ GTEST_ATTRIBUTE_UNUSED_;\\\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(\\\n      GTEST_TEST_CLASS_NAME_(test_case_name, test_name));\\\n};\\\n\\\n::testing::TestInfo* const GTEST_TEST_CLASS_NAME_(test_case_name, test_name)\\\n  ::test_info_ =\\\n    ::testing::internal::MakeAndRegisterTestInfo(\\\n        #test_case_name, #test_name, NULL, NULL, \\\n        ::testing::internal::CodeLocation(__FILE__, __LINE__), \\\n        (parent_id), \\\n        parent_class::SetUpTestCase, \\\n        parent_class::TearDownTestCase, \\\n        new ::testing::internal::TestFactoryImpl<\\\n            GTEST_TEST_CLASS_NAME_(test_case_name, test_name)>);\\\nvoid GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_\n\n"}, "62": {"id": 62, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-linked_ptr.h", "content": "// Copyright 2003 Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Authors: Dan Egnor (egnor@google.com)\n//\n// A \"smart\" pointer type with reference tracking.  Every pointer to a\n// particular object is kept on a circular linked list.  When the last pointer\n// to an object is destroyed or reassigned, the object is deleted.\n//\n// Used properly, this deletes the object when the last reference goes away.\n// There are several caveats:\n// - Like all reference counting schemes, cycles lead to leaks.\n// - Each smart pointer is actually two pointers (8 bytes instead of 4).\n// - Every time a pointer is assigned, the entire list of pointers to that\n//   object is traversed.  This class is therefore NOT SUITABLE when there\n//   will often be more than two or three pointers to a particular object.\n// - References are only tracked as long as linked_ptr<> objects are copied.\n//   If a linked_ptr<> is converted to a raw pointer and back, BAD THINGS\n//   will happen (double deletion).\n//\n// A good use of this class is storing object references in STL containers.\n// You can safely put linked_ptr<> in a vector<>.\n// Other uses may not be as good.\n//\n// Note: If you use an incomplete type with linked_ptr<>, the class\n// *containing* linked_ptr<> must have a constructor and destructor (even\n// if they do nothing!).\n//\n// Bill Gibbons suggested we use something like this.\n//\n// Thread Safety:\n//   Unlike other linked_ptr implementations, in this implementation\n//   a linked_ptr object is thread-safe in the sense that:\n//     - it's safe to copy linked_ptr objects concurrently,\n//     - it's safe to copy *from* a linked_ptr and read its underlying\n//       raw pointer (e.g. via get()) concurrently, and\n//     - it's safe to write to two linked_ptrs that point to the same\n//       shared object concurrently.\n// TODO(wan@google.com): rename this to safe_linked_ptr to avoid\n// confusion with normal linked_ptr.\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_LINKED_PTR_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_LINKED_PTR_H_\n\n#include <stdlib.h>\n#include <assert.h>\n\n#include \"gtest/internal/gtest-port.h\"\n\nnamespace testing {\nnamespace internal {\n\n// Protects copying of all linked_ptr objects.\nGTEST_API_ GTEST_DECLARE_STATIC_MUTEX_(g_linked_ptr_mutex);\n\n// This is used internally by all instances of linked_ptr<>.  It needs to be\n// a non-template class because different types of linked_ptr<> can refer to\n// the same object (linked_ptr<Superclass>(obj) vs linked_ptr<Subclass>(obj)).\n// So, it needs to be possible for different types of linked_ptr to participate\n// in the same circular linked list, so we need a single class type here.\n//\n// DO NOT USE THIS CLASS DIRECTLY YOURSELF.  Use linked_ptr<T>.\nclass linked_ptr_internal {\n public:\n  // Create a new circle that includes only this instance.\n  void join_new() {\n    next_ = this;\n  }\n\n  // Many linked_ptr operations may change p.link_ for some linked_ptr\n  // variable p in the same circle as this object.  Therefore we need\n  // to prevent two such operations from occurring concurrently.\n  //\n  // Note that different types of linked_ptr objects can coexist in a\n  // circle (e.g. linked_ptr<Base>, linked_ptr<Derived1>, and\n  // linked_ptr<Derived2>).  Therefore we must use a single mutex to\n  // protect all linked_ptr objects.  This can create serious\n  // contention in production code, but is acceptable in a testing\n  // framework.\n\n  // Join an existing circle.\n  void join(linked_ptr_internal const* ptr)\n      GTEST_LOCK_EXCLUDED_(g_linked_ptr_mutex) {\n    MutexLock lock(&g_linked_ptr_mutex);\n\n    linked_ptr_internal const* p = ptr;\n    while (p->next_ != ptr) {\n      assert(p->next_ != this &&\n             \"Trying to join() a linked ring we are already in. \"\n             \"Is GMock thread safety enabled?\");\n      p = p->next_;\n    }\n    p->next_ = this;\n    next_ = ptr;\n  }\n\n  // Leave whatever circle we're part of.  Returns true if we were the\n  // last member of the circle.  Once this is done, you can join() another.\n  bool depart()\n      GTEST_LOCK_EXCLUDED_(g_linked_ptr_mutex) {\n    MutexLock lock(&g_linked_ptr_mutex);\n\n    if (next_ == this) return true;\n    linked_ptr_internal const* p = next_;\n    while (p->next_ != this) {\n      assert(p->next_ != next_ &&\n             \"Trying to depart() a linked ring we are not in. \"\n             \"Is GMock thread safety enabled?\");\n      p = p->next_;\n    }\n    p->next_ = next_;\n    return false;\n  }\n\n private:\n  mutable linked_ptr_internal const* next_;\n};\n\ntemplate <typename T>\nclass linked_ptr {\n public:\n  typedef T element_type;\n\n  // Take over ownership of a raw pointer.  This should happen as soon as\n  // possible after the object is created.\n  explicit linked_ptr(T* ptr = NULL) { capture(ptr); }\n  ~linked_ptr() { depart(); }\n\n  // Copy an existing linked_ptr<>, adding ourselves to the list of references.\n  template <typename U> linked_ptr(linked_ptr<U> const& ptr) { copy(&ptr); }\n  linked_ptr(linked_ptr const& ptr) {  // NOLINT\n    assert(&ptr != this);\n    copy(&ptr);\n  }\n\n  // Assignment releases the old value and acquires the new.\n  template <typename U> linked_ptr& operator=(linked_ptr<U> const& ptr) {\n    depart();\n    copy(&ptr);\n    return *this;\n  }\n\n  linked_ptr& operator=(linked_ptr const& ptr) {\n    if (&ptr != this) {\n      depart();\n      copy(&ptr);\n    }\n    return *this;\n  }\n\n  // Smart pointer members.\n  void reset(T* ptr = NULL) {\n    depart();\n    capture(ptr);\n  }\n  T* get() const { return value_; }\n  T* operator->() const { return value_; }\n  T& operator*() const { return *value_; }\n\n  bool operator==(T* p) const { return value_ == p; }\n  bool operator!=(T* p) const { return value_ != p; }\n  template <typename U>\n  bool operator==(linked_ptr<U> const& ptr) const {\n    return value_ == ptr.get();\n  }\n  template <typename U>\n  bool operator!=(linked_ptr<U> const& ptr) const {\n    return value_ != ptr.get();\n  }\n\n private:\n  template <typename U>\n  friend class linked_ptr;\n\n  T* value_;\n  linked_ptr_internal link_;\n\n  void depart() {\n    if (link_.depart()) delete value_;\n  }\n\n  void capture(T* ptr) {\n    value_ = ptr;\n    link_.join_new();\n  }\n\n  template <typename U> void copy(linked_ptr<U> const* ptr) {\n    value_ = ptr->get();\n    if (value_)\n      link_.join(&ptr->link_);\n    else\n      link_.join_new();\n  }\n};\n\ntemplate<typename T> inline\nbool operator==(T* ptr, const linked_ptr<T>& x) {\n  return ptr == x.get();\n}\n\ntemplate<typename T> inline\nbool operator!=(T* ptr, const linked_ptr<T>& x) {\n  return ptr != x.get();\n}\n\n// A function to convert T* into linked_ptr<T>\n// Doing e.g. make_linked_ptr(new FooBarBaz<type>(arg)) is a shorter notation\n// for linked_ptr<FooBarBaz<type> >(new FooBarBaz<type>(arg))\ntemplate <typename T>\nlinked_ptr<T> make_linked_ptr(T* ptr) {\n  return linked_ptr<T>(ptr);\n}\n\n}  // namespace internal\n}  // namespace testing\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_LINKED_PTR_H_\n"}, "63": {"id": 63, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-param-util-generated.h", "content": "// This file was GENERATED by command:\n//     pump.py gtest-param-util-generated.h.pump\n// DO NOT EDIT BY HAND!!!\n\n// Copyright 2008 Google Inc.\n// All Rights Reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: vladl@google.com (Vlad Losev)\n\n// Type and function utilities for implementing parameterized tests.\n// This file is generated by a SCRIPT.  DO NOT EDIT BY HAND!\n//\n// Currently Google Test supports at most 50 arguments in Values,\n// and at most 10 arguments in Combine. Please contact\n// googletestframework@googlegroups.com if you need more.\n// Please note that the number of arguments to Combine is limited\n// by the maximum arity of the implementation of tuple which is\n// currently set at 10.\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_GENERATED_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_GENERATED_H_\n\n// scripts/fuse_gtest.py depends on gtest's own header being #included\n// *unconditionally*.  Therefore these #includes cannot be moved\n// inside #if GTEST_HAS_PARAM_TEST.\n#include \"gtest/internal/gtest-param-util.h\"\n#include \"gtest/internal/gtest-port.h\"\n\n#if GTEST_HAS_PARAM_TEST\n\n#ifdef __clang__\n#if __has_warning(\"-Wdeprecated-copy\")\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wdeprecated-copy\"\n#endif\n#endif\n\nnamespace testing {\n\n// Forward declarations of ValuesIn(), which is implemented in\n// include/gtest/gtest-param-test.h.\ntemplate <typename ForwardIterator>\ninternal::ParamGenerator<\n  typename ::testing::internal::IteratorTraits<ForwardIterator>::value_type>\nValuesIn(ForwardIterator begin, ForwardIterator end);\n\ntemplate <typename T, size_t N>\ninternal::ParamGenerator<T> ValuesIn(const T (&array)[N]);\n\ntemplate <class Container>\ninternal::ParamGenerator<typename Container::value_type> ValuesIn(\n    const Container& container);\n\nnamespace internal {\n\n// Used in the Values() function to provide polymorphic capabilities.\ntemplate <typename T1>\nclass ValueArray1 {\n public:\n  explicit ValueArray1(T1 v1) : v1_(v1) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray1& other) = delete;\n\n  const T1 v1_;\n};\n\ntemplate <typename T1, typename T2>\nclass ValueArray2 {\n public:\n  ValueArray2(T1 v1, T2 v2) : v1_(v1), v2_(v2) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray2& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n};\n\ntemplate <typename T1, typename T2, typename T3>\nclass ValueArray3 {\n public:\n  ValueArray3(T1 v1, T2 v2, T3 v3) : v1_(v1), v2_(v2), v3_(v3) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray3& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4>\nclass ValueArray4 {\n public:\n  ValueArray4(T1 v1, T2 v2, T3 v3, T4 v4) : v1_(v1), v2_(v2), v3_(v3),\n      v4_(v4) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray4& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5>\nclass ValueArray5 {\n public:\n  ValueArray5(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5) : v1_(v1), v2_(v2), v3_(v3),\n      v4_(v4), v5_(v5) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray5& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6>\nclass ValueArray6 {\n public:\n  ValueArray6(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6) : v1_(v1), v2_(v2),\n      v3_(v3), v4_(v4), v5_(v5), v6_(v6) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray6& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7>\nclass ValueArray7 {\n public:\n  ValueArray7(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7) : v1_(v1),\n      v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray7& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8>\nclass ValueArray8 {\n public:\n  ValueArray8(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,\n      T8 v8) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\n      v8_(v8) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray8& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9>\nclass ValueArray9 {\n public:\n  ValueArray9(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8,\n      T9 v9) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\n      v8_(v8), v9_(v9) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray9& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10>\nclass ValueArray10 {\n public:\n  ValueArray10(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\n      v8_(v8), v9_(v9), v10_(v10) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray10& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11>\nclass ValueArray11 {\n public:\n  ValueArray11(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6),\n      v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray11& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12>\nclass ValueArray12 {\n public:\n  ValueArray12(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5),\n      v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray12& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13>\nclass ValueArray13 {\n public:\n  ValueArray13(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13) : v1_(v1), v2_(v2), v3_(v3), v4_(v4),\n      v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11),\n      v12_(v12), v13_(v13) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray13& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14>\nclass ValueArray14 {\n public:\n  ValueArray14(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14) : v1_(v1), v2_(v2), v3_(v3),\n      v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),\n      v11_(v11), v12_(v12), v13_(v13), v14_(v14) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray14& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15>\nclass ValueArray15 {\n public:\n  ValueArray15(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15) : v1_(v1), v2_(v2),\n      v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),\n      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray15& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16>\nclass ValueArray16 {\n public:\n  ValueArray16(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16) : v1_(v1),\n      v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9),\n      v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15),\n      v16_(v16) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray16& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17>\nclass ValueArray17 {\n public:\n  ValueArray17(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16,\n      T17 v17) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\n      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),\n      v15_(v15), v16_(v16), v17_(v17) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray17& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18>\nclass ValueArray18 {\n public:\n  ValueArray18(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\n      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),\n      v15_(v15), v16_(v16), v17_(v17), v18_(v18) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray18& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19>\nclass ValueArray19 {\n public:\n  ValueArray19(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6),\n      v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13),\n      v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray19& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20>\nclass ValueArray20 {\n public:\n  ValueArray20(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5),\n      v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12),\n      v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18),\n      v19_(v19), v20_(v20) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray20& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21>\nclass ValueArray21 {\n public:\n  ValueArray21(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21) : v1_(v1), v2_(v2), v3_(v3), v4_(v4),\n      v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11),\n      v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17),\n      v18_(v18), v19_(v19), v20_(v20), v21_(v21) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray21& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22>\nclass ValueArray22 {\n public:\n  ValueArray22(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22) : v1_(v1), v2_(v2), v3_(v3),\n      v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),\n      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),\n      v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray22& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23>\nclass ValueArray23 {\n public:\n  ValueArray23(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23) : v1_(v1), v2_(v2),\n      v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),\n      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),\n      v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22),\n      v23_(v23) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray23& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24>\nclass ValueArray24 {\n public:\n  ValueArray24(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24) : v1_(v1),\n      v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9),\n      v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15),\n      v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21),\n      v22_(v22), v23_(v23), v24_(v24) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray24& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25>\nclass ValueArray25 {\n public:\n  ValueArray25(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24,\n      T25 v25) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\n      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),\n      v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),\n      v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray25& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26>\nclass ValueArray26 {\n public:\n  ValueArray26(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\n      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),\n      v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),\n      v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray26& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27>\nclass ValueArray27 {\n public:\n  ValueArray27(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6),\n      v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13),\n      v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19),\n      v20_(v20), v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25),\n      v26_(v26), v27_(v27) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray27& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28>\nclass ValueArray28 {\n public:\n  ValueArray28(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5),\n      v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12),\n      v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18),\n      v19_(v19), v20_(v20), v21_(v21), v22_(v22), v23_(v23), v24_(v24),\n      v25_(v25), v26_(v26), v27_(v27), v28_(v28) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray28& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29>\nclass ValueArray29 {\n public:\n  ValueArray29(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29) : v1_(v1), v2_(v2), v3_(v3), v4_(v4),\n      v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11),\n      v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17),\n      v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22), v23_(v23),\n      v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28), v29_(v29) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray29& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30>\nclass ValueArray30 {\n public:\n  ValueArray30(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30) : v1_(v1), v2_(v2), v3_(v3),\n      v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),\n      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),\n      v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22),\n      v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28),\n      v29_(v29), v30_(v30) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray30& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31>\nclass ValueArray31 {\n public:\n  ValueArray31(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31) : v1_(v1), v2_(v2),\n      v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),\n      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),\n      v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22),\n      v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28),\n      v29_(v29), v30_(v30), v31_(v31) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray31& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32>\nclass ValueArray32 {\n public:\n  ValueArray32(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32) : v1_(v1),\n      v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9),\n      v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15),\n      v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21),\n      v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27),\n      v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray32& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33>\nclass ValueArray33 {\n public:\n  ValueArray33(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32,\n      T33 v33) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\n      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),\n      v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),\n      v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26),\n      v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32),\n      v33_(v33) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray33& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34>\nclass ValueArray34 {\n public:\n  ValueArray34(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n      T34 v34) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\n      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),\n      v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),\n      v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26),\n      v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32),\n      v33_(v33), v34_(v34) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_), static_cast<T>(v34_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray34& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n  const T34 v34_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35>\nclass ValueArray35 {\n public:\n  ValueArray35(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n      T34 v34, T35 v35) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6),\n      v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13),\n      v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19),\n      v20_(v20), v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25),\n      v26_(v26), v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31),\n      v32_(v32), v33_(v33), v34_(v34), v35_(v35) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray35& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n  const T34 v34_;\n  const T35 v35_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36>\nclass ValueArray36 {\n public:\n  ValueArray36(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n      T34 v34, T35 v35, T36 v36) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5),\n      v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12),\n      v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18),\n      v19_(v19), v20_(v20), v21_(v21), v22_(v22), v23_(v23), v24_(v24),\n      v25_(v25), v26_(v26), v27_(v27), v28_(v28), v29_(v29), v30_(v30),\n      v31_(v31), v32_(v32), v33_(v33), v34_(v34), v35_(v35), v36_(v36) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),\n        static_cast<T>(v36_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray36& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n  const T34 v34_;\n  const T35 v35_;\n  const T36 v36_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37>\nclass ValueArray37 {\n public:\n  ValueArray37(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n      T34 v34, T35 v35, T36 v36, T37 v37) : v1_(v1), v2_(v2), v3_(v3), v4_(v4),\n      v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11),\n      v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17),\n      v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22), v23_(v23),\n      v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28), v29_(v29),\n      v30_(v30), v31_(v31), v32_(v32), v33_(v33), v34_(v34), v35_(v35),\n      v36_(v36), v37_(v37) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),\n        static_cast<T>(v36_), static_cast<T>(v37_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray37& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n  const T34 v34_;\n  const T35 v35_;\n  const T36 v36_;\n  const T37 v37_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38>\nclass ValueArray38 {\n public:\n  ValueArray38(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38) : v1_(v1), v2_(v2), v3_(v3),\n      v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),\n      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),\n      v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22),\n      v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28),\n      v29_(v29), v30_(v30), v31_(v31), v32_(v32), v33_(v33), v34_(v34),\n      v35_(v35), v36_(v36), v37_(v37), v38_(v38) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),\n        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray38& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n  const T34 v34_;\n  const T35 v35_;\n  const T36 v36_;\n  const T37 v37_;\n  const T38 v38_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39>\nclass ValueArray39 {\n public:\n  ValueArray39(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39) : v1_(v1), v2_(v2),\n      v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),\n      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),\n      v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22),\n      v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28),\n      v29_(v29), v30_(v30), v31_(v31), v32_(v32), v33_(v33), v34_(v34),\n      v35_(v35), v36_(v36), v37_(v37), v38_(v38), v39_(v39) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),\n        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),\n        static_cast<T>(v39_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray39& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n  const T34 v34_;\n  const T35 v35_;\n  const T36 v36_;\n  const T37 v37_;\n  const T38 v38_;\n  const T39 v39_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40>\nclass ValueArray40 {\n public:\n  ValueArray40(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40) : v1_(v1),\n      v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9),\n      v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15),\n      v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21),\n      v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27),\n      v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32), v33_(v33),\n      v34_(v34), v35_(v35), v36_(v36), v37_(v37), v38_(v38), v39_(v39),\n      v40_(v40) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),\n        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),\n        static_cast<T>(v39_), static_cast<T>(v40_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray40& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n  const T34 v34_;\n  const T35 v35_;\n  const T36 v36_;\n  const T37 v37_;\n  const T38 v38_;\n  const T39 v39_;\n  const T40 v40_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41>\nclass ValueArray41 {\n public:\n  ValueArray41(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40,\n      T41 v41) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\n      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),\n      v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),\n      v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26),\n      v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32),\n      v33_(v33), v34_(v34), v35_(v35), v36_(v36), v37_(v37), v38_(v38),\n      v39_(v39), v40_(v40), v41_(v41) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),\n        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),\n        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray41& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n  const T34 v34_;\n  const T35 v35_;\n  const T36 v36_;\n  const T37 v37_;\n  const T38 v38_;\n  const T39 v39_;\n  const T40 v40_;\n  const T41 v41_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42>\nclass ValueArray42 {\n public:\n  ValueArray42(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\n      T42 v42) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\n      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),\n      v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),\n      v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26),\n      v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32),\n      v33_(v33), v34_(v34), v35_(v35), v36_(v36), v37_(v37), v38_(v38),\n      v39_(v39), v40_(v40), v41_(v41), v42_(v42) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),\n        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),\n        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),\n        static_cast<T>(v42_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray42& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n  const T34 v34_;\n  const T35 v35_;\n  const T36 v36_;\n  const T37 v37_;\n  const T38 v38_;\n  const T39 v39_;\n  const T40 v40_;\n  const T41 v41_;\n  const T42 v42_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43>\nclass ValueArray43 {\n public:\n  ValueArray43(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\n      T42 v42, T43 v43) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6),\n      v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13),\n      v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19),\n      v20_(v20), v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25),\n      v26_(v26), v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31),\n      v32_(v32), v33_(v33), v34_(v34), v35_(v35), v36_(v36), v37_(v37),\n      v38_(v38), v39_(v39), v40_(v40), v41_(v41), v42_(v42), v43_(v43) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),\n        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),\n        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),\n        static_cast<T>(v42_), static_cast<T>(v43_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray43& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n  const T34 v34_;\n  const T35 v35_;\n  const T36 v36_;\n  const T37 v37_;\n  const T38 v38_;\n  const T39 v39_;\n  const T40 v40_;\n  const T41 v41_;\n  const T42 v42_;\n  const T43 v43_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44>\nclass ValueArray44 {\n public:\n  ValueArray44(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\n      T42 v42, T43 v43, T44 v44) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5),\n      v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12),\n      v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18),\n      v19_(v19), v20_(v20), v21_(v21), v22_(v22), v23_(v23), v24_(v24),\n      v25_(v25), v26_(v26), v27_(v27), v28_(v28), v29_(v29), v30_(v30),\n      v31_(v31), v32_(v32), v33_(v33), v34_(v34), v35_(v35), v36_(v36),\n      v37_(v37), v38_(v38), v39_(v39), v40_(v40), v41_(v41), v42_(v42),\n      v43_(v43), v44_(v44) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),\n        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),\n        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),\n        static_cast<T>(v42_), static_cast<T>(v43_), static_cast<T>(v44_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray44& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n  const T34 v34_;\n  const T35 v35_;\n  const T36 v36_;\n  const T37 v37_;\n  const T38 v38_;\n  const T39 v39_;\n  const T40 v40_;\n  const T41 v41_;\n  const T42 v42_;\n  const T43 v43_;\n  const T44 v44_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45>\nclass ValueArray45 {\n public:\n  ValueArray45(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\n      T42 v42, T43 v43, T44 v44, T45 v45) : v1_(v1), v2_(v2), v3_(v3), v4_(v4),\n      v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11),\n      v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17),\n      v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22), v23_(v23),\n      v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28), v29_(v29),\n      v30_(v30), v31_(v31), v32_(v32), v33_(v33), v34_(v34), v35_(v35),\n      v36_(v36), v37_(v37), v38_(v38), v39_(v39), v40_(v40), v41_(v41),\n      v42_(v42), v43_(v43), v44_(v44), v45_(v45) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),\n        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),\n        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),\n        static_cast<T>(v42_), static_cast<T>(v43_), static_cast<T>(v44_),\n        static_cast<T>(v45_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray45& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n  const T34 v34_;\n  const T35 v35_;\n  const T36 v36_;\n  const T37 v37_;\n  const T38 v38_;\n  const T39 v39_;\n  const T40 v40_;\n  const T41 v41_;\n  const T42 v42_;\n  const T43 v43_;\n  const T44 v44_;\n  const T45 v45_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46>\nclass ValueArray46 {\n public:\n  ValueArray46(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\n      T42 v42, T43 v43, T44 v44, T45 v45, T46 v46) : v1_(v1), v2_(v2), v3_(v3),\n      v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),\n      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),\n      v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22),\n      v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28),\n      v29_(v29), v30_(v30), v31_(v31), v32_(v32), v33_(v33), v34_(v34),\n      v35_(v35), v36_(v36), v37_(v37), v38_(v38), v39_(v39), v40_(v40),\n      v41_(v41), v42_(v42), v43_(v43), v44_(v44), v45_(v45), v46_(v46) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),\n        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),\n        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),\n        static_cast<T>(v42_), static_cast<T>(v43_), static_cast<T>(v44_),\n        static_cast<T>(v45_), static_cast<T>(v46_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray46& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n  const T34 v34_;\n  const T35 v35_;\n  const T36 v36_;\n  const T37 v37_;\n  const T38 v38_;\n  const T39 v39_;\n  const T40 v40_;\n  const T41 v41_;\n  const T42 v42_;\n  const T43 v43_;\n  const T44 v44_;\n  const T45 v45_;\n  const T46 v46_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47>\nclass ValueArray47 {\n public:\n  ValueArray47(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\n      T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47) : v1_(v1), v2_(v2),\n      v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),\n      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),\n      v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22),\n      v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28),\n      v29_(v29), v30_(v30), v31_(v31), v32_(v32), v33_(v33), v34_(v34),\n      v35_(v35), v36_(v36), v37_(v37), v38_(v38), v39_(v39), v40_(v40),\n      v41_(v41), v42_(v42), v43_(v43), v44_(v44), v45_(v45), v46_(v46),\n      v47_(v47) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),\n        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),\n        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),\n        static_cast<T>(v42_), static_cast<T>(v43_), static_cast<T>(v44_),\n        static_cast<T>(v45_), static_cast<T>(v46_), static_cast<T>(v47_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray47& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n  const T34 v34_;\n  const T35 v35_;\n  const T36 v36_;\n  const T37 v37_;\n  const T38 v38_;\n  const T39 v39_;\n  const T40 v40_;\n  const T41 v41_;\n  const T42 v42_;\n  const T43 v43_;\n  const T44 v44_;\n  const T45 v45_;\n  const T46 v46_;\n  const T47 v47_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47, typename T48>\nclass ValueArray48 {\n public:\n  ValueArray48(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\n      T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47, T48 v48) : v1_(v1),\n      v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9),\n      v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15),\n      v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21),\n      v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27),\n      v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32), v33_(v33),\n      v34_(v34), v35_(v35), v36_(v36), v37_(v37), v38_(v38), v39_(v39),\n      v40_(v40), v41_(v41), v42_(v42), v43_(v43), v44_(v44), v45_(v45),\n      v46_(v46), v47_(v47), v48_(v48) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),\n        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),\n        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),\n        static_cast<T>(v42_), static_cast<T>(v43_), static_cast<T>(v44_),\n        static_cast<T>(v45_), static_cast<T>(v46_), static_cast<T>(v47_),\n        static_cast<T>(v48_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray48& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n  const T34 v34_;\n  const T35 v35_;\n  const T36 v36_;\n  const T37 v37_;\n  const T38 v38_;\n  const T39 v39_;\n  const T40 v40_;\n  const T41 v41_;\n  const T42 v42_;\n  const T43 v43_;\n  const T44 v44_;\n  const T45 v45_;\n  const T46 v46_;\n  const T47 v47_;\n  const T48 v48_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47, typename T48, typename T49>\nclass ValueArray49 {\n public:\n  ValueArray49(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\n      T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47, T48 v48,\n      T49 v49) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\n      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),\n      v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),\n      v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26),\n      v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32),\n      v33_(v33), v34_(v34), v35_(v35), v36_(v36), v37_(v37), v38_(v38),\n      v39_(v39), v40_(v40), v41_(v41), v42_(v42), v43_(v43), v44_(v44),\n      v45_(v45), v46_(v46), v47_(v47), v48_(v48), v49_(v49) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),\n        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),\n        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),\n        static_cast<T>(v42_), static_cast<T>(v43_), static_cast<T>(v44_),\n        static_cast<T>(v45_), static_cast<T>(v46_), static_cast<T>(v47_),\n        static_cast<T>(v48_), static_cast<T>(v49_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray49& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n  const T34 v34_;\n  const T35 v35_;\n  const T36 v36_;\n  const T37 v37_;\n  const T38 v38_;\n  const T39 v39_;\n  const T40 v40_;\n  const T41 v41_;\n  const T42 v42_;\n  const T43 v43_;\n  const T44 v44_;\n  const T45 v45_;\n  const T46 v46_;\n  const T47 v47_;\n  const T48 v48_;\n  const T49 v49_;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47, typename T48, typename T49, typename T50>\nclass ValueArray50 {\n public:\n  ValueArray50(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,\n      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,\n      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,\n      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,\n      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,\n      T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47, T48 v48, T49 v49,\n      T50 v50) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),\n      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),\n      v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),\n      v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26),\n      v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32),\n      v33_(v33), v34_(v34), v35_(v35), v36_(v36), v37_(v37), v38_(v38),\n      v39_(v39), v40_(v40), v41_(v41), v42_(v42), v43_(v43), v44_(v44),\n      v45_(v45), v46_(v46), v47_(v47), v48_(v48), v49_(v49), v50_(v50) {}\n\n  template <typename T>\n  operator ParamGenerator<T>() const {\n    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),\n        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),\n        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),\n        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),\n        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),\n        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),\n        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),\n        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),\n        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),\n        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),\n        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),\n        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),\n        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),\n        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),\n        static_cast<T>(v42_), static_cast<T>(v43_), static_cast<T>(v44_),\n        static_cast<T>(v45_), static_cast<T>(v46_), static_cast<T>(v47_),\n        static_cast<T>(v48_), static_cast<T>(v49_), static_cast<T>(v50_)};\n    return ValuesIn(array);\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const ValueArray50& other) = delete;\n\n  const T1 v1_;\n  const T2 v2_;\n  const T3 v3_;\n  const T4 v4_;\n  const T5 v5_;\n  const T6 v6_;\n  const T7 v7_;\n  const T8 v8_;\n  const T9 v9_;\n  const T10 v10_;\n  const T11 v11_;\n  const T12 v12_;\n  const T13 v13_;\n  const T14 v14_;\n  const T15 v15_;\n  const T16 v16_;\n  const T17 v17_;\n  const T18 v18_;\n  const T19 v19_;\n  const T20 v20_;\n  const T21 v21_;\n  const T22 v22_;\n  const T23 v23_;\n  const T24 v24_;\n  const T25 v25_;\n  const T26 v26_;\n  const T27 v27_;\n  const T28 v28_;\n  const T29 v29_;\n  const T30 v30_;\n  const T31 v31_;\n  const T32 v32_;\n  const T33 v33_;\n  const T34 v34_;\n  const T35 v35_;\n  const T36 v36_;\n  const T37 v37_;\n  const T38 v38_;\n  const T39 v39_;\n  const T40 v40_;\n  const T41 v41_;\n  const T42 v42_;\n  const T43 v43_;\n  const T44 v44_;\n  const T45 v45_;\n  const T46 v46_;\n  const T47 v47_;\n  const T48 v48_;\n  const T49 v49_;\n  const T50 v50_;\n};\n\n# if GTEST_HAS_COMBINE\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// Generates values from the Cartesian product of values produced\n// by the argument generators.\n//\ntemplate <typename T1, typename T2>\nclass CartesianProductGenerator2\n    : public ParamGeneratorInterface< ::testing::tuple<T1, T2> > {\n public:\n  typedef ::testing::tuple<T1, T2> ParamType;\n\n  CartesianProductGenerator2(const ParamGenerator<T1>& g1,\n      const ParamGenerator<T2>& g2)\n      : g1_(g1), g2_(g2) {}\n  virtual ~CartesianProductGenerator2() {}\n\n  virtual ParamIteratorInterface<ParamType>* Begin() const {\n    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin());\n  }\n  virtual ParamIteratorInterface<ParamType>* End() const {\n    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end());\n  }\n\n private:\n  class Iterator : public ParamIteratorInterface<ParamType> {\n   public:\n    Iterator(const ParamGeneratorInterface<ParamType>* base,\n      const ParamGenerator<T1>& g1,\n      const typename ParamGenerator<T1>::iterator& current1,\n      const ParamGenerator<T2>& g2,\n      const typename ParamGenerator<T2>::iterator& current2)\n        : base_(base),\n          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),\n          begin2_(g2.begin()), end2_(g2.end()), current2_(current2)    {\n      ComputeCurrentValue();\n    }\n    virtual ~Iterator() {}\n\n    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {\n      return base_;\n    }\n    // Advance should not be called on beyond-of-range iterators\n    // so no component iterators must be beyond end of range, either.\n    virtual void Advance() {\n      assert(!AtEnd());\n      ++current2_;\n      if (current2_ == end2_) {\n        current2_ = begin2_;\n        ++current1_;\n      }\n      ComputeCurrentValue();\n    }\n    virtual ParamIteratorInterface<ParamType>* Clone() const {\n      return new Iterator(*this);\n    }\n    virtual const ParamType* Current() const { return &current_value_; }\n    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {\n      // Having the same base generator guarantees that the other\n      // iterator is of the same type and we can downcast.\n      GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\n          << \"The program attempted to compare iterators \"\n          << \"from different generators.\" << std::endl;\n      const Iterator* typed_other =\n          CheckedDowncastToActualType<const Iterator>(&other);\n      // We must report iterators equal if they both point beyond their\n      // respective ranges. That can happen in a variety of fashions,\n      // so we have to consult AtEnd().\n      return (AtEnd() && typed_other->AtEnd()) ||\n         (\n          current1_ == typed_other->current1_ &&\n          current2_ == typed_other->current2_);\n    }\n\n   private:\n    Iterator(const Iterator& other)\n        : base_(other.base_),\n        begin1_(other.begin1_),\n        end1_(other.end1_),\n        current1_(other.current1_),\n        begin2_(other.begin2_),\n        end2_(other.end2_),\n        current2_(other.current2_) {\n      ComputeCurrentValue();\n    }\n\n    void ComputeCurrentValue() {\n      if (!AtEnd())\n        current_value_ = ParamType(*current1_, *current2_);\n    }\n    bool AtEnd() const {\n      // We must report iterator past the end of the range when either of the\n      // component iterators has reached the end of its range.\n      return\n          current1_ == end1_ ||\n          current2_ == end2_;\n    }\n\n    // No implementation - assignment is unsupported.\n    void operator=(const Iterator& other) = delete;\n\n    const ParamGeneratorInterface<ParamType>* const base_;\n    // begin[i]_ and end[i]_ define the i-th range that Iterator traverses.\n    // current[i]_ is the actual traversing iterator.\n    const typename ParamGenerator<T1>::iterator begin1_;\n    const typename ParamGenerator<T1>::iterator end1_;\n    typename ParamGenerator<T1>::iterator current1_;\n    const typename ParamGenerator<T2>::iterator begin2_;\n    const typename ParamGenerator<T2>::iterator end2_;\n    typename ParamGenerator<T2>::iterator current2_;\n    ParamType current_value_;\n  };  // class CartesianProductGenerator2::Iterator\n\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductGenerator2& other) = delete;\n\n  const ParamGenerator<T1> g1_;\n  const ParamGenerator<T2> g2_;\n};  // class CartesianProductGenerator2\n\n\ntemplate <typename T1, typename T2, typename T3>\nclass CartesianProductGenerator3\n    : public ParamGeneratorInterface< ::testing::tuple<T1, T2, T3> > {\n public:\n  typedef ::testing::tuple<T1, T2, T3> ParamType;\n\n  CartesianProductGenerator3(const ParamGenerator<T1>& g1,\n      const ParamGenerator<T2>& g2, const ParamGenerator<T3>& g3)\n      : g1_(g1), g2_(g2), g3_(g3) {}\n  virtual ~CartesianProductGenerator3() {}\n\n  virtual ParamIteratorInterface<ParamType>* Begin() const {\n    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin(), g3_,\n        g3_.begin());\n  }\n  virtual ParamIteratorInterface<ParamType>* End() const {\n    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end());\n  }\n\n private:\n  class Iterator : public ParamIteratorInterface<ParamType> {\n   public:\n    Iterator(const ParamGeneratorInterface<ParamType>* base,\n      const ParamGenerator<T1>& g1,\n      const typename ParamGenerator<T1>::iterator& current1,\n      const ParamGenerator<T2>& g2,\n      const typename ParamGenerator<T2>::iterator& current2,\n      const ParamGenerator<T3>& g3,\n      const typename ParamGenerator<T3>::iterator& current3)\n        : base_(base),\n          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),\n          begin2_(g2.begin()), end2_(g2.end()), current2_(current2),\n          begin3_(g3.begin()), end3_(g3.end()), current3_(current3)    {\n      ComputeCurrentValue();\n    }\n    virtual ~Iterator() {}\n\n    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {\n      return base_;\n    }\n    // Advance should not be called on beyond-of-range iterators\n    // so no component iterators must be beyond end of range, either.\n    virtual void Advance() {\n      assert(!AtEnd());\n      ++current3_;\n      if (current3_ == end3_) {\n        current3_ = begin3_;\n        ++current2_;\n      }\n      if (current2_ == end2_) {\n        current2_ = begin2_;\n        ++current1_;\n      }\n      ComputeCurrentValue();\n    }\n    virtual ParamIteratorInterface<ParamType>* Clone() const {\n      return new Iterator(*this);\n    }\n    virtual const ParamType* Current() const { return &current_value_; }\n    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {\n      // Having the same base generator guarantees that the other\n      // iterator is of the same type and we can downcast.\n      GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\n          << \"The program attempted to compare iterators \"\n          << \"from different generators.\" << std::endl;\n      const Iterator* typed_other =\n          CheckedDowncastToActualType<const Iterator>(&other);\n      // We must report iterators equal if they both point beyond their\n      // respective ranges. That can happen in a variety of fashions,\n      // so we have to consult AtEnd().\n      return (AtEnd() && typed_other->AtEnd()) ||\n         (\n          current1_ == typed_other->current1_ &&\n          current2_ == typed_other->current2_ &&\n          current3_ == typed_other->current3_);\n    }\n\n   private:\n    Iterator(const Iterator& other)\n        : base_(other.base_),\n        begin1_(other.begin1_),\n        end1_(other.end1_),\n        current1_(other.current1_),\n        begin2_(other.begin2_),\n        end2_(other.end2_),\n        current2_(other.current2_),\n        begin3_(other.begin3_),\n        end3_(other.end3_),\n        current3_(other.current3_) {\n      ComputeCurrentValue();\n    }\n\n    void ComputeCurrentValue() {\n      if (!AtEnd())\n        current_value_ = ParamType(*current1_, *current2_, *current3_);\n    }\n    bool AtEnd() const {\n      // We must report iterator past the end of the range when either of the\n      // component iterators has reached the end of its range.\n      return\n          current1_ == end1_ ||\n          current2_ == end2_ ||\n          current3_ == end3_;\n    }\n\n    // No implementation - assignment is unsupported.\n    void operator=(const Iterator& other) = delete;\n\n    const ParamGeneratorInterface<ParamType>* const base_;\n    // begin[i]_ and end[i]_ define the i-th range that Iterator traverses.\n    // current[i]_ is the actual traversing iterator.\n    const typename ParamGenerator<T1>::iterator begin1_;\n    const typename ParamGenerator<T1>::iterator end1_;\n    typename ParamGenerator<T1>::iterator current1_;\n    const typename ParamGenerator<T2>::iterator begin2_;\n    const typename ParamGenerator<T2>::iterator end2_;\n    typename ParamGenerator<T2>::iterator current2_;\n    const typename ParamGenerator<T3>::iterator begin3_;\n    const typename ParamGenerator<T3>::iterator end3_;\n    typename ParamGenerator<T3>::iterator current3_;\n    ParamType current_value_;\n  };  // class CartesianProductGenerator3::Iterator\n\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductGenerator3& other) = delete;\n\n  const ParamGenerator<T1> g1_;\n  const ParamGenerator<T2> g2_;\n  const ParamGenerator<T3> g3_;\n};  // class CartesianProductGenerator3\n\n\ntemplate <typename T1, typename T2, typename T3, typename T4>\nclass CartesianProductGenerator4\n    : public ParamGeneratorInterface< ::testing::tuple<T1, T2, T3, T4> > {\n public:\n  typedef ::testing::tuple<T1, T2, T3, T4> ParamType;\n\n  CartesianProductGenerator4(const ParamGenerator<T1>& g1,\n      const ParamGenerator<T2>& g2, const ParamGenerator<T3>& g3,\n      const ParamGenerator<T4>& g4)\n      : g1_(g1), g2_(g2), g3_(g3), g4_(g4) {}\n  virtual ~CartesianProductGenerator4() {}\n\n  virtual ParamIteratorInterface<ParamType>* Begin() const {\n    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin(), g3_,\n        g3_.begin(), g4_, g4_.begin());\n  }\n  virtual ParamIteratorInterface<ParamType>* End() const {\n    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end(),\n        g4_, g4_.end());\n  }\n\n private:\n  class Iterator : public ParamIteratorInterface<ParamType> {\n   public:\n    Iterator(const ParamGeneratorInterface<ParamType>* base,\n      const ParamGenerator<T1>& g1,\n      const typename ParamGenerator<T1>::iterator& current1,\n      const ParamGenerator<T2>& g2,\n      const typename ParamGenerator<T2>::iterator& current2,\n      const ParamGenerator<T3>& g3,\n      const typename ParamGenerator<T3>::iterator& current3,\n      const ParamGenerator<T4>& g4,\n      const typename ParamGenerator<T4>::iterator& current4)\n        : base_(base),\n          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),\n          begin2_(g2.begin()), end2_(g2.end()), current2_(current2),\n          begin3_(g3.begin()), end3_(g3.end()), current3_(current3),\n          begin4_(g4.begin()), end4_(g4.end()), current4_(current4)    {\n      ComputeCurrentValue();\n    }\n    virtual ~Iterator() {}\n\n    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {\n      return base_;\n    }\n    // Advance should not be called on beyond-of-range iterators\n    // so no component iterators must be beyond end of range, either.\n    virtual void Advance() {\n      assert(!AtEnd());\n      ++current4_;\n      if (current4_ == end4_) {\n        current4_ = begin4_;\n        ++current3_;\n      }\n      if (current3_ == end3_) {\n        current3_ = begin3_;\n        ++current2_;\n      }\n      if (current2_ == end2_) {\n        current2_ = begin2_;\n        ++current1_;\n      }\n      ComputeCurrentValue();\n    }\n    virtual ParamIteratorInterface<ParamType>* Clone() const {\n      return new Iterator(*this);\n    }\n    virtual const ParamType* Current() const { return &current_value_; }\n    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {\n      // Having the same base generator guarantees that the other\n      // iterator is of the same type and we can downcast.\n      GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\n          << \"The program attempted to compare iterators \"\n          << \"from different generators.\" << std::endl;\n      const Iterator* typed_other =\n          CheckedDowncastToActualType<const Iterator>(&other);\n      // We must report iterators equal if they both point beyond their\n      // respective ranges. That can happen in a variety of fashions,\n      // so we have to consult AtEnd().\n      return (AtEnd() && typed_other->AtEnd()) ||\n         (\n          current1_ == typed_other->current1_ &&\n          current2_ == typed_other->current2_ &&\n          current3_ == typed_other->current3_ &&\n          current4_ == typed_other->current4_);\n    }\n\n   private:\n    Iterator(const Iterator& other)\n        : base_(other.base_),\n        begin1_(other.begin1_),\n        end1_(other.end1_),\n        current1_(other.current1_),\n        begin2_(other.begin2_),\n        end2_(other.end2_),\n        current2_(other.current2_),\n        begin3_(other.begin3_),\n        end3_(other.end3_),\n        current3_(other.current3_),\n        begin4_(other.begin4_),\n        end4_(other.end4_),\n        current4_(other.current4_) {\n      ComputeCurrentValue();\n    }\n\n    void ComputeCurrentValue() {\n      if (!AtEnd())\n        current_value_ = ParamType(*current1_, *current2_, *current3_,\n            *current4_);\n    }\n    bool AtEnd() const {\n      // We must report iterator past the end of the range when either of the\n      // component iterators has reached the end of its range.\n      return\n          current1_ == end1_ ||\n          current2_ == end2_ ||\n          current3_ == end3_ ||\n          current4_ == end4_;\n    }\n\n    // No implementation - assignment is unsupported.\n    void operator=(const Iterator& other) = delete;\n\n    const ParamGeneratorInterface<ParamType>* const base_;\n    // begin[i]_ and end[i]_ define the i-th range that Iterator traverses.\n    // current[i]_ is the actual traversing iterator.\n    const typename ParamGenerator<T1>::iterator begin1_;\n    const typename ParamGenerator<T1>::iterator end1_;\n    typename ParamGenerator<T1>::iterator current1_;\n    const typename ParamGenerator<T2>::iterator begin2_;\n    const typename ParamGenerator<T2>::iterator end2_;\n    typename ParamGenerator<T2>::iterator current2_;\n    const typename ParamGenerator<T3>::iterator begin3_;\n    const typename ParamGenerator<T3>::iterator end3_;\n    typename ParamGenerator<T3>::iterator current3_;\n    const typename ParamGenerator<T4>::iterator begin4_;\n    const typename ParamGenerator<T4>::iterator end4_;\n    typename ParamGenerator<T4>::iterator current4_;\n    ParamType current_value_;\n  };  // class CartesianProductGenerator4::Iterator\n\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductGenerator4& other) = delete;\n\n  const ParamGenerator<T1> g1_;\n  const ParamGenerator<T2> g2_;\n  const ParamGenerator<T3> g3_;\n  const ParamGenerator<T4> g4_;\n};  // class CartesianProductGenerator4\n\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5>\nclass CartesianProductGenerator5\n    : public ParamGeneratorInterface< ::testing::tuple<T1, T2, T3, T4, T5> > {\n public:\n  typedef ::testing::tuple<T1, T2, T3, T4, T5> ParamType;\n\n  CartesianProductGenerator5(const ParamGenerator<T1>& g1,\n      const ParamGenerator<T2>& g2, const ParamGenerator<T3>& g3,\n      const ParamGenerator<T4>& g4, const ParamGenerator<T5>& g5)\n      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5) {}\n  virtual ~CartesianProductGenerator5() {}\n\n  virtual ParamIteratorInterface<ParamType>* Begin() const {\n    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin(), g3_,\n        g3_.begin(), g4_, g4_.begin(), g5_, g5_.begin());\n  }\n  virtual ParamIteratorInterface<ParamType>* End() const {\n    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end(),\n        g4_, g4_.end(), g5_, g5_.end());\n  }\n\n private:\n  class Iterator : public ParamIteratorInterface<ParamType> {\n   public:\n    Iterator(const ParamGeneratorInterface<ParamType>* base,\n      const ParamGenerator<T1>& g1,\n      const typename ParamGenerator<T1>::iterator& current1,\n      const ParamGenerator<T2>& g2,\n      const typename ParamGenerator<T2>::iterator& current2,\n      const ParamGenerator<T3>& g3,\n      const typename ParamGenerator<T3>::iterator& current3,\n      const ParamGenerator<T4>& g4,\n      const typename ParamGenerator<T4>::iterator& current4,\n      const ParamGenerator<T5>& g5,\n      const typename ParamGenerator<T5>::iterator& current5)\n        : base_(base),\n          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),\n          begin2_(g2.begin()), end2_(g2.end()), current2_(current2),\n          begin3_(g3.begin()), end3_(g3.end()), current3_(current3),\n          begin4_(g4.begin()), end4_(g4.end()), current4_(current4),\n          begin5_(g5.begin()), end5_(g5.end()), current5_(current5)    {\n      ComputeCurrentValue();\n    }\n    virtual ~Iterator() {}\n\n    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {\n      return base_;\n    }\n    // Advance should not be called on beyond-of-range iterators\n    // so no component iterators must be beyond end of range, either.\n    virtual void Advance() {\n      assert(!AtEnd());\n      ++current5_;\n      if (current5_ == end5_) {\n        current5_ = begin5_;\n        ++current4_;\n      }\n      if (current4_ == end4_) {\n        current4_ = begin4_;\n        ++current3_;\n      }\n      if (current3_ == end3_) {\n        current3_ = begin3_;\n        ++current2_;\n      }\n      if (current2_ == end2_) {\n        current2_ = begin2_;\n        ++current1_;\n      }\n      ComputeCurrentValue();\n    }\n    virtual ParamIteratorInterface<ParamType>* Clone() const {\n      return new Iterator(*this);\n    }\n    virtual const ParamType* Current() const { return &current_value_; }\n    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {\n      // Having the same base generator guarantees that the other\n      // iterator is of the same type and we can downcast.\n      GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\n          << \"The program attempted to compare iterators \"\n          << \"from different generators.\" << std::endl;\n      const Iterator* typed_other =\n          CheckedDowncastToActualType<const Iterator>(&other);\n      // We must report iterators equal if they both point beyond their\n      // respective ranges. That can happen in a variety of fashions,\n      // so we have to consult AtEnd().\n      return (AtEnd() && typed_other->AtEnd()) ||\n         (\n          current1_ == typed_other->current1_ &&\n          current2_ == typed_other->current2_ &&\n          current3_ == typed_other->current3_ &&\n          current4_ == typed_other->current4_ &&\n          current5_ == typed_other->current5_);\n    }\n\n   private:\n    Iterator(const Iterator& other)\n        : base_(other.base_),\n        begin1_(other.begin1_),\n        end1_(other.end1_),\n        current1_(other.current1_),\n        begin2_(other.begin2_),\n        end2_(other.end2_),\n        current2_(other.current2_),\n        begin3_(other.begin3_),\n        end3_(other.end3_),\n        current3_(other.current3_),\n        begin4_(other.begin4_),\n        end4_(other.end4_),\n        current4_(other.current4_),\n        begin5_(other.begin5_),\n        end5_(other.end5_),\n        current5_(other.current5_) {\n      ComputeCurrentValue();\n    }\n\n    void ComputeCurrentValue() {\n      if (!AtEnd())\n        current_value_ = ParamType(*current1_, *current2_, *current3_,\n            *current4_, *current5_);\n    }\n    bool AtEnd() const {\n      // We must report iterator past the end of the range when either of the\n      // component iterators has reached the end of its range.\n      return\n          current1_ == end1_ ||\n          current2_ == end2_ ||\n          current3_ == end3_ ||\n          current4_ == end4_ ||\n          current5_ == end5_;\n    }\n\n    // No implementation - assignment is unsupported.\n    void operator=(const Iterator& other) = delete;\n\n    const ParamGeneratorInterface<ParamType>* const base_;\n    // begin[i]_ and end[i]_ define the i-th range that Iterator traverses.\n    // current[i]_ is the actual traversing iterator.\n    const typename ParamGenerator<T1>::iterator begin1_;\n    const typename ParamGenerator<T1>::iterator end1_;\n    typename ParamGenerator<T1>::iterator current1_;\n    const typename ParamGenerator<T2>::iterator begin2_;\n    const typename ParamGenerator<T2>::iterator end2_;\n    typename ParamGenerator<T2>::iterator current2_;\n    const typename ParamGenerator<T3>::iterator begin3_;\n    const typename ParamGenerator<T3>::iterator end3_;\n    typename ParamGenerator<T3>::iterator current3_;\n    const typename ParamGenerator<T4>::iterator begin4_;\n    const typename ParamGenerator<T4>::iterator end4_;\n    typename ParamGenerator<T4>::iterator current4_;\n    const typename ParamGenerator<T5>::iterator begin5_;\n    const typename ParamGenerator<T5>::iterator end5_;\n    typename ParamGenerator<T5>::iterator current5_;\n    ParamType current_value_;\n  };  // class CartesianProductGenerator5::Iterator\n\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductGenerator5& other) = delete;\n\n  const ParamGenerator<T1> g1_;\n  const ParamGenerator<T2> g2_;\n  const ParamGenerator<T3> g3_;\n  const ParamGenerator<T4> g4_;\n  const ParamGenerator<T5> g5_;\n};  // class CartesianProductGenerator5\n\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6>\nclass CartesianProductGenerator6\n    : public ParamGeneratorInterface< ::testing::tuple<T1, T2, T3, T4, T5,\n        T6> > {\n public:\n  typedef ::testing::tuple<T1, T2, T3, T4, T5, T6> ParamType;\n\n  CartesianProductGenerator6(const ParamGenerator<T1>& g1,\n      const ParamGenerator<T2>& g2, const ParamGenerator<T3>& g3,\n      const ParamGenerator<T4>& g4, const ParamGenerator<T5>& g5,\n      const ParamGenerator<T6>& g6)\n      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6) {}\n  virtual ~CartesianProductGenerator6() {}\n\n  virtual ParamIteratorInterface<ParamType>* Begin() const {\n    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin(), g3_,\n        g3_.begin(), g4_, g4_.begin(), g5_, g5_.begin(), g6_, g6_.begin());\n  }\n  virtual ParamIteratorInterface<ParamType>* End() const {\n    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end(),\n        g4_, g4_.end(), g5_, g5_.end(), g6_, g6_.end());\n  }\n\n private:\n  class Iterator : public ParamIteratorInterface<ParamType> {\n   public:\n    Iterator(const ParamGeneratorInterface<ParamType>* base,\n      const ParamGenerator<T1>& g1,\n      const typename ParamGenerator<T1>::iterator& current1,\n      const ParamGenerator<T2>& g2,\n      const typename ParamGenerator<T2>::iterator& current2,\n      const ParamGenerator<T3>& g3,\n      const typename ParamGenerator<T3>::iterator& current3,\n      const ParamGenerator<T4>& g4,\n      const typename ParamGenerator<T4>::iterator& current4,\n      const ParamGenerator<T5>& g5,\n      const typename ParamGenerator<T5>::iterator& current5,\n      const ParamGenerator<T6>& g6,\n      const typename ParamGenerator<T6>::iterator& current6)\n        : base_(base),\n          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),\n          begin2_(g2.begin()), end2_(g2.end()), current2_(current2),\n          begin3_(g3.begin()), end3_(g3.end()), current3_(current3),\n          begin4_(g4.begin()), end4_(g4.end()), current4_(current4),\n          begin5_(g5.begin()), end5_(g5.end()), current5_(current5),\n          begin6_(g6.begin()), end6_(g6.end()), current6_(current6)    {\n      ComputeCurrentValue();\n    }\n    virtual ~Iterator() {}\n\n    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {\n      return base_;\n    }\n    // Advance should not be called on beyond-of-range iterators\n    // so no component iterators must be beyond end of range, either.\n    virtual void Advance() {\n      assert(!AtEnd());\n      ++current6_;\n      if (current6_ == end6_) {\n        current6_ = begin6_;\n        ++current5_;\n      }\n      if (current5_ == end5_) {\n        current5_ = begin5_;\n        ++current4_;\n      }\n      if (current4_ == end4_) {\n        current4_ = begin4_;\n        ++current3_;\n      }\n      if (current3_ == end3_) {\n        current3_ = begin3_;\n        ++current2_;\n      }\n      if (current2_ == end2_) {\n        current2_ = begin2_;\n        ++current1_;\n      }\n      ComputeCurrentValue();\n    }\n    virtual ParamIteratorInterface<ParamType>* Clone() const {\n      return new Iterator(*this);\n    }\n    virtual const ParamType* Current() const { return &current_value_; }\n    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {\n      // Having the same base generator guarantees that the other\n      // iterator is of the same type and we can downcast.\n      GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\n          << \"The program attempted to compare iterators \"\n          << \"from different generators.\" << std::endl;\n      const Iterator* typed_other =\n          CheckedDowncastToActualType<const Iterator>(&other);\n      // We must report iterators equal if they both point beyond their\n      // respective ranges. That can happen in a variety of fashions,\n      // so we have to consult AtEnd().\n      return (AtEnd() && typed_other->AtEnd()) ||\n         (\n          current1_ == typed_other->current1_ &&\n          current2_ == typed_other->current2_ &&\n          current3_ == typed_other->current3_ &&\n          current4_ == typed_other->current4_ &&\n          current5_ == typed_other->current5_ &&\n          current6_ == typed_other->current6_);\n    }\n\n   private:\n    Iterator(const Iterator& other)\n        : base_(other.base_),\n        begin1_(other.begin1_),\n        end1_(other.end1_),\n        current1_(other.current1_),\n        begin2_(other.begin2_),\n        end2_(other.end2_),\n        current2_(other.current2_),\n        begin3_(other.begin3_),\n        end3_(other.end3_),\n        current3_(other.current3_),\n        begin4_(other.begin4_),\n        end4_(other.end4_),\n        current4_(other.current4_),\n        begin5_(other.begin5_),\n        end5_(other.end5_),\n        current5_(other.current5_),\n        begin6_(other.begin6_),\n        end6_(other.end6_),\n        current6_(other.current6_) {\n      ComputeCurrentValue();\n    }\n\n    void ComputeCurrentValue() {\n      if (!AtEnd())\n        current_value_ = ParamType(*current1_, *current2_, *current3_,\n            *current4_, *current5_, *current6_);\n    }\n    bool AtEnd() const {\n      // We must report iterator past the end of the range when either of the\n      // component iterators has reached the end of its range.\n      return\n          current1_ == end1_ ||\n          current2_ == end2_ ||\n          current3_ == end3_ ||\n          current4_ == end4_ ||\n          current5_ == end5_ ||\n          current6_ == end6_;\n    }\n\n    // No implementation - assignment is unsupported.\n    void operator=(const Iterator& other) = delete;\n\n    const ParamGeneratorInterface<ParamType>* const base_;\n    // begin[i]_ and end[i]_ define the i-th range that Iterator traverses.\n    // current[i]_ is the actual traversing iterator.\n    const typename ParamGenerator<T1>::iterator begin1_;\n    const typename ParamGenerator<T1>::iterator end1_;\n    typename ParamGenerator<T1>::iterator current1_;\n    const typename ParamGenerator<T2>::iterator begin2_;\n    const typename ParamGenerator<T2>::iterator end2_;\n    typename ParamGenerator<T2>::iterator current2_;\n    const typename ParamGenerator<T3>::iterator begin3_;\n    const typename ParamGenerator<T3>::iterator end3_;\n    typename ParamGenerator<T3>::iterator current3_;\n    const typename ParamGenerator<T4>::iterator begin4_;\n    const typename ParamGenerator<T4>::iterator end4_;\n    typename ParamGenerator<T4>::iterator current4_;\n    const typename ParamGenerator<T5>::iterator begin5_;\n    const typename ParamGenerator<T5>::iterator end5_;\n    typename ParamGenerator<T5>::iterator current5_;\n    const typename ParamGenerator<T6>::iterator begin6_;\n    const typename ParamGenerator<T6>::iterator end6_;\n    typename ParamGenerator<T6>::iterator current6_;\n    ParamType current_value_;\n  };  // class CartesianProductGenerator6::Iterator\n\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductGenerator6& other) = delete;\n\n  const ParamGenerator<T1> g1_;\n  const ParamGenerator<T2> g2_;\n  const ParamGenerator<T3> g3_;\n  const ParamGenerator<T4> g4_;\n  const ParamGenerator<T5> g5_;\n  const ParamGenerator<T6> g6_;\n};  // class CartesianProductGenerator6\n\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7>\nclass CartesianProductGenerator7\n    : public ParamGeneratorInterface< ::testing::tuple<T1, T2, T3, T4, T5, T6,\n        T7> > {\n public:\n  typedef ::testing::tuple<T1, T2, T3, T4, T5, T6, T7> ParamType;\n\n  CartesianProductGenerator7(const ParamGenerator<T1>& g1,\n      const ParamGenerator<T2>& g2, const ParamGenerator<T3>& g3,\n      const ParamGenerator<T4>& g4, const ParamGenerator<T5>& g5,\n      const ParamGenerator<T6>& g6, const ParamGenerator<T7>& g7)\n      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7) {}\n  virtual ~CartesianProductGenerator7() {}\n\n  virtual ParamIteratorInterface<ParamType>* Begin() const {\n    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin(), g3_,\n        g3_.begin(), g4_, g4_.begin(), g5_, g5_.begin(), g6_, g6_.begin(), g7_,\n        g7_.begin());\n  }\n  virtual ParamIteratorInterface<ParamType>* End() const {\n    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end(),\n        g4_, g4_.end(), g5_, g5_.end(), g6_, g6_.end(), g7_, g7_.end());\n  }\n\n private:\n  class Iterator : public ParamIteratorInterface<ParamType> {\n   public:\n    Iterator(const ParamGeneratorInterface<ParamType>* base,\n      const ParamGenerator<T1>& g1,\n      const typename ParamGenerator<T1>::iterator& current1,\n      const ParamGenerator<T2>& g2,\n      const typename ParamGenerator<T2>::iterator& current2,\n      const ParamGenerator<T3>& g3,\n      const typename ParamGenerator<T3>::iterator& current3,\n      const ParamGenerator<T4>& g4,\n      const typename ParamGenerator<T4>::iterator& current4,\n      const ParamGenerator<T5>& g5,\n      const typename ParamGenerator<T5>::iterator& current5,\n      const ParamGenerator<T6>& g6,\n      const typename ParamGenerator<T6>::iterator& current6,\n      const ParamGenerator<T7>& g7,\n      const typename ParamGenerator<T7>::iterator& current7)\n        : base_(base),\n          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),\n          begin2_(g2.begin()), end2_(g2.end()), current2_(current2),\n          begin3_(g3.begin()), end3_(g3.end()), current3_(current3),\n          begin4_(g4.begin()), end4_(g4.end()), current4_(current4),\n          begin5_(g5.begin()), end5_(g5.end()), current5_(current5),\n          begin6_(g6.begin()), end6_(g6.end()), current6_(current6),\n          begin7_(g7.begin()), end7_(g7.end()), current7_(current7)    {\n      ComputeCurrentValue();\n    }\n    virtual ~Iterator() {}\n\n    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {\n      return base_;\n    }\n    // Advance should not be called on beyond-of-range iterators\n    // so no component iterators must be beyond end of range, either.\n    virtual void Advance() {\n      assert(!AtEnd());\n      ++current7_;\n      if (current7_ == end7_) {\n        current7_ = begin7_;\n        ++current6_;\n      }\n      if (current6_ == end6_) {\n        current6_ = begin6_;\n        ++current5_;\n      }\n      if (current5_ == end5_) {\n        current5_ = begin5_;\n        ++current4_;\n      }\n      if (current4_ == end4_) {\n        current4_ = begin4_;\n        ++current3_;\n      }\n      if (current3_ == end3_) {\n        current3_ = begin3_;\n        ++current2_;\n      }\n      if (current2_ == end2_) {\n        current2_ = begin2_;\n        ++current1_;\n      }\n      ComputeCurrentValue();\n    }\n    virtual ParamIteratorInterface<ParamType>* Clone() const {\n      return new Iterator(*this);\n    }\n    virtual const ParamType* Current() const { return &current_value_; }\n    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {\n      // Having the same base generator guarantees that the other\n      // iterator is of the same type and we can downcast.\n      GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\n          << \"The program attempted to compare iterators \"\n          << \"from different generators.\" << std::endl;\n      const Iterator* typed_other =\n          CheckedDowncastToActualType<const Iterator>(&other);\n      // We must report iterators equal if they both point beyond their\n      // respective ranges. That can happen in a variety of fashions,\n      // so we have to consult AtEnd().\n      return (AtEnd() && typed_other->AtEnd()) ||\n         (\n          current1_ == typed_other->current1_ &&\n          current2_ == typed_other->current2_ &&\n          current3_ == typed_other->current3_ &&\n          current4_ == typed_other->current4_ &&\n          current5_ == typed_other->current5_ &&\n          current6_ == typed_other->current6_ &&\n          current7_ == typed_other->current7_);\n    }\n\n   private:\n    Iterator(const Iterator& other)\n        : base_(other.base_),\n        begin1_(other.begin1_),\n        end1_(other.end1_),\n        current1_(other.current1_),\n        begin2_(other.begin2_),\n        end2_(other.end2_),\n        current2_(other.current2_),\n        begin3_(other.begin3_),\n        end3_(other.end3_),\n        current3_(other.current3_),\n        begin4_(other.begin4_),\n        end4_(other.end4_),\n        current4_(other.current4_),\n        begin5_(other.begin5_),\n        end5_(other.end5_),\n        current5_(other.current5_),\n        begin6_(other.begin6_),\n        end6_(other.end6_),\n        current6_(other.current6_),\n        begin7_(other.begin7_),\n        end7_(other.end7_),\n        current7_(other.current7_) {\n      ComputeCurrentValue();\n    }\n\n    void ComputeCurrentValue() {\n      if (!AtEnd())\n        current_value_ = ParamType(*current1_, *current2_, *current3_,\n            *current4_, *current5_, *current6_, *current7_);\n    }\n    bool AtEnd() const {\n      // We must report iterator past the end of the range when either of the\n      // component iterators has reached the end of its range.\n      return\n          current1_ == end1_ ||\n          current2_ == end2_ ||\n          current3_ == end3_ ||\n          current4_ == end4_ ||\n          current5_ == end5_ ||\n          current6_ == end6_ ||\n          current7_ == end7_;\n    }\n\n    // No implementation - assignment is unsupported.\n    void operator=(const Iterator& other) = delete;\n\n    const ParamGeneratorInterface<ParamType>* const base_;\n    // begin[i]_ and end[i]_ define the i-th range that Iterator traverses.\n    // current[i]_ is the actual traversing iterator.\n    const typename ParamGenerator<T1>::iterator begin1_;\n    const typename ParamGenerator<T1>::iterator end1_;\n    typename ParamGenerator<T1>::iterator current1_;\n    const typename ParamGenerator<T2>::iterator begin2_;\n    const typename ParamGenerator<T2>::iterator end2_;\n    typename ParamGenerator<T2>::iterator current2_;\n    const typename ParamGenerator<T3>::iterator begin3_;\n    const typename ParamGenerator<T3>::iterator end3_;\n    typename ParamGenerator<T3>::iterator current3_;\n    const typename ParamGenerator<T4>::iterator begin4_;\n    const typename ParamGenerator<T4>::iterator end4_;\n    typename ParamGenerator<T4>::iterator current4_;\n    const typename ParamGenerator<T5>::iterator begin5_;\n    const typename ParamGenerator<T5>::iterator end5_;\n    typename ParamGenerator<T5>::iterator current5_;\n    const typename ParamGenerator<T6>::iterator begin6_;\n    const typename ParamGenerator<T6>::iterator end6_;\n    typename ParamGenerator<T6>::iterator current6_;\n    const typename ParamGenerator<T7>::iterator begin7_;\n    const typename ParamGenerator<T7>::iterator end7_;\n    typename ParamGenerator<T7>::iterator current7_;\n    ParamType current_value_;\n  };  // class CartesianProductGenerator7::Iterator\n\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductGenerator7& other) = delete;\n\n  const ParamGenerator<T1> g1_;\n  const ParamGenerator<T2> g2_;\n  const ParamGenerator<T3> g3_;\n  const ParamGenerator<T4> g4_;\n  const ParamGenerator<T5> g5_;\n  const ParamGenerator<T6> g6_;\n  const ParamGenerator<T7> g7_;\n};  // class CartesianProductGenerator7\n\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8>\nclass CartesianProductGenerator8\n    : public ParamGeneratorInterface< ::testing::tuple<T1, T2, T3, T4, T5, T6,\n        T7, T8> > {\n public:\n  typedef ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8> ParamType;\n\n  CartesianProductGenerator8(const ParamGenerator<T1>& g1,\n      const ParamGenerator<T2>& g2, const ParamGenerator<T3>& g3,\n      const ParamGenerator<T4>& g4, const ParamGenerator<T5>& g5,\n      const ParamGenerator<T6>& g6, const ParamGenerator<T7>& g7,\n      const ParamGenerator<T8>& g8)\n      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7),\n          g8_(g8) {}\n  virtual ~CartesianProductGenerator8() {}\n\n  virtual ParamIteratorInterface<ParamType>* Begin() const {\n    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin(), g3_,\n        g3_.begin(), g4_, g4_.begin(), g5_, g5_.begin(), g6_, g6_.begin(), g7_,\n        g7_.begin(), g8_, g8_.begin());\n  }\n  virtual ParamIteratorInterface<ParamType>* End() const {\n    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end(),\n        g4_, g4_.end(), g5_, g5_.end(), g6_, g6_.end(), g7_, g7_.end(), g8_,\n        g8_.end());\n  }\n\n private:\n  class Iterator : public ParamIteratorInterface<ParamType> {\n   public:\n    Iterator(const ParamGeneratorInterface<ParamType>* base,\n      const ParamGenerator<T1>& g1,\n      const typename ParamGenerator<T1>::iterator& current1,\n      const ParamGenerator<T2>& g2,\n      const typename ParamGenerator<T2>::iterator& current2,\n      const ParamGenerator<T3>& g3,\n      const typename ParamGenerator<T3>::iterator& current3,\n      const ParamGenerator<T4>& g4,\n      const typename ParamGenerator<T4>::iterator& current4,\n      const ParamGenerator<T5>& g5,\n      const typename ParamGenerator<T5>::iterator& current5,\n      const ParamGenerator<T6>& g6,\n      const typename ParamGenerator<T6>::iterator& current6,\n      const ParamGenerator<T7>& g7,\n      const typename ParamGenerator<T7>::iterator& current7,\n      const ParamGenerator<T8>& g8,\n      const typename ParamGenerator<T8>::iterator& current8)\n        : base_(base),\n          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),\n          begin2_(g2.begin()), end2_(g2.end()), current2_(current2),\n          begin3_(g3.begin()), end3_(g3.end()), current3_(current3),\n          begin4_(g4.begin()), end4_(g4.end()), current4_(current4),\n          begin5_(g5.begin()), end5_(g5.end()), current5_(current5),\n          begin6_(g6.begin()), end6_(g6.end()), current6_(current6),\n          begin7_(g7.begin()), end7_(g7.end()), current7_(current7),\n          begin8_(g8.begin()), end8_(g8.end()), current8_(current8)    {\n      ComputeCurrentValue();\n    }\n    virtual ~Iterator() {}\n\n    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {\n      return base_;\n    }\n    // Advance should not be called on beyond-of-range iterators\n    // so no component iterators must be beyond end of range, either.\n    virtual void Advance() {\n      assert(!AtEnd());\n      ++current8_;\n      if (current8_ == end8_) {\n        current8_ = begin8_;\n        ++current7_;\n      }\n      if (current7_ == end7_) {\n        current7_ = begin7_;\n        ++current6_;\n      }\n      if (current6_ == end6_) {\n        current6_ = begin6_;\n        ++current5_;\n      }\n      if (current5_ == end5_) {\n        current5_ = begin5_;\n        ++current4_;\n      }\n      if (current4_ == end4_) {\n        current4_ = begin4_;\n        ++current3_;\n      }\n      if (current3_ == end3_) {\n        current3_ = begin3_;\n        ++current2_;\n      }\n      if (current2_ == end2_) {\n        current2_ = begin2_;\n        ++current1_;\n      }\n      ComputeCurrentValue();\n    }\n    virtual ParamIteratorInterface<ParamType>* Clone() const {\n      return new Iterator(*this);\n    }\n    virtual const ParamType* Current() const { return &current_value_; }\n    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {\n      // Having the same base generator guarantees that the other\n      // iterator is of the same type and we can downcast.\n      GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\n          << \"The program attempted to compare iterators \"\n          << \"from different generators.\" << std::endl;\n      const Iterator* typed_other =\n          CheckedDowncastToActualType<const Iterator>(&other);\n      // We must report iterators equal if they both point beyond their\n      // respective ranges. That can happen in a variety of fashions,\n      // so we have to consult AtEnd().\n      return (AtEnd() && typed_other->AtEnd()) ||\n         (\n          current1_ == typed_other->current1_ &&\n          current2_ == typed_other->current2_ &&\n          current3_ == typed_other->current3_ &&\n          current4_ == typed_other->current4_ &&\n          current5_ == typed_other->current5_ &&\n          current6_ == typed_other->current6_ &&\n          current7_ == typed_other->current7_ &&\n          current8_ == typed_other->current8_);\n    }\n\n   private:\n    Iterator(const Iterator& other)\n        : base_(other.base_),\n        begin1_(other.begin1_),\n        end1_(other.end1_),\n        current1_(other.current1_),\n        begin2_(other.begin2_),\n        end2_(other.end2_),\n        current2_(other.current2_),\n        begin3_(other.begin3_),\n        end3_(other.end3_),\n        current3_(other.current3_),\n        begin4_(other.begin4_),\n        end4_(other.end4_),\n        current4_(other.current4_),\n        begin5_(other.begin5_),\n        end5_(other.end5_),\n        current5_(other.current5_),\n        begin6_(other.begin6_),\n        end6_(other.end6_),\n        current6_(other.current6_),\n        begin7_(other.begin7_),\n        end7_(other.end7_),\n        current7_(other.current7_),\n        begin8_(other.begin8_),\n        end8_(other.end8_),\n        current8_(other.current8_) {\n      ComputeCurrentValue();\n    }\n\n    void ComputeCurrentValue() {\n      if (!AtEnd())\n        current_value_ = ParamType(*current1_, *current2_, *current3_,\n            *current4_, *current5_, *current6_, *current7_, *current8_);\n    }\n    bool AtEnd() const {\n      // We must report iterator past the end of the range when either of the\n      // component iterators has reached the end of its range.\n      return\n          current1_ == end1_ ||\n          current2_ == end2_ ||\n          current3_ == end3_ ||\n          current4_ == end4_ ||\n          current5_ == end5_ ||\n          current6_ == end6_ ||\n          current7_ == end7_ ||\n          current8_ == end8_;\n    }\n\n    // No implementation - assignment is unsupported.\n    void operator=(const Iterator& other) = delete;\n\n    const ParamGeneratorInterface<ParamType>* const base_;\n    // begin[i]_ and end[i]_ define the i-th range that Iterator traverses.\n    // current[i]_ is the actual traversing iterator.\n    const typename ParamGenerator<T1>::iterator begin1_;\n    const typename ParamGenerator<T1>::iterator end1_;\n    typename ParamGenerator<T1>::iterator current1_;\n    const typename ParamGenerator<T2>::iterator begin2_;\n    const typename ParamGenerator<T2>::iterator end2_;\n    typename ParamGenerator<T2>::iterator current2_;\n    const typename ParamGenerator<T3>::iterator begin3_;\n    const typename ParamGenerator<T3>::iterator end3_;\n    typename ParamGenerator<T3>::iterator current3_;\n    const typename ParamGenerator<T4>::iterator begin4_;\n    const typename ParamGenerator<T4>::iterator end4_;\n    typename ParamGenerator<T4>::iterator current4_;\n    const typename ParamGenerator<T5>::iterator begin5_;\n    const typename ParamGenerator<T5>::iterator end5_;\n    typename ParamGenerator<T5>::iterator current5_;\n    const typename ParamGenerator<T6>::iterator begin6_;\n    const typename ParamGenerator<T6>::iterator end6_;\n    typename ParamGenerator<T6>::iterator current6_;\n    const typename ParamGenerator<T7>::iterator begin7_;\n    const typename ParamGenerator<T7>::iterator end7_;\n    typename ParamGenerator<T7>::iterator current7_;\n    const typename ParamGenerator<T8>::iterator begin8_;\n    const typename ParamGenerator<T8>::iterator end8_;\n    typename ParamGenerator<T8>::iterator current8_;\n    ParamType current_value_;\n  };  // class CartesianProductGenerator8::Iterator\n\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductGenerator8& other) = delete;\n\n  const ParamGenerator<T1> g1_;\n  const ParamGenerator<T2> g2_;\n  const ParamGenerator<T3> g3_;\n  const ParamGenerator<T4> g4_;\n  const ParamGenerator<T5> g5_;\n  const ParamGenerator<T6> g6_;\n  const ParamGenerator<T7> g7_;\n  const ParamGenerator<T8> g8_;\n};  // class CartesianProductGenerator8\n\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9>\nclass CartesianProductGenerator9\n    : public ParamGeneratorInterface< ::testing::tuple<T1, T2, T3, T4, T5, T6,\n        T7, T8, T9> > {\n public:\n  typedef ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8, T9> ParamType;\n\n  CartesianProductGenerator9(const ParamGenerator<T1>& g1,\n      const ParamGenerator<T2>& g2, const ParamGenerator<T3>& g3,\n      const ParamGenerator<T4>& g4, const ParamGenerator<T5>& g5,\n      const ParamGenerator<T6>& g6, const ParamGenerator<T7>& g7,\n      const ParamGenerator<T8>& g8, const ParamGenerator<T9>& g9)\n      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7), g8_(g8),\n          g9_(g9) {}\n  virtual ~CartesianProductGenerator9() {}\n\n  virtual ParamIteratorInterface<ParamType>* Begin() const {\n    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin(), g3_,\n        g3_.begin(), g4_, g4_.begin(), g5_, g5_.begin(), g6_, g6_.begin(), g7_,\n        g7_.begin(), g8_, g8_.begin(), g9_, g9_.begin());\n  }\n  virtual ParamIteratorInterface<ParamType>* End() const {\n    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end(),\n        g4_, g4_.end(), g5_, g5_.end(), g6_, g6_.end(), g7_, g7_.end(), g8_,\n        g8_.end(), g9_, g9_.end());\n  }\n\n private:\n  class Iterator : public ParamIteratorInterface<ParamType> {\n   public:\n    Iterator(const ParamGeneratorInterface<ParamType>* base,\n      const ParamGenerator<T1>& g1,\n      const typename ParamGenerator<T1>::iterator& current1,\n      const ParamGenerator<T2>& g2,\n      const typename ParamGenerator<T2>::iterator& current2,\n      const ParamGenerator<T3>& g3,\n      const typename ParamGenerator<T3>::iterator& current3,\n      const ParamGenerator<T4>& g4,\n      const typename ParamGenerator<T4>::iterator& current4,\n      const ParamGenerator<T5>& g5,\n      const typename ParamGenerator<T5>::iterator& current5,\n      const ParamGenerator<T6>& g6,\n      const typename ParamGenerator<T6>::iterator& current6,\n      const ParamGenerator<T7>& g7,\n      const typename ParamGenerator<T7>::iterator& current7,\n      const ParamGenerator<T8>& g8,\n      const typename ParamGenerator<T8>::iterator& current8,\n      const ParamGenerator<T9>& g9,\n      const typename ParamGenerator<T9>::iterator& current9)\n        : base_(base),\n          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),\n          begin2_(g2.begin()), end2_(g2.end()), current2_(current2),\n          begin3_(g3.begin()), end3_(g3.end()), current3_(current3),\n          begin4_(g4.begin()), end4_(g4.end()), current4_(current4),\n          begin5_(g5.begin()), end5_(g5.end()), current5_(current5),\n          begin6_(g6.begin()), end6_(g6.end()), current6_(current6),\n          begin7_(g7.begin()), end7_(g7.end()), current7_(current7),\n          begin8_(g8.begin()), end8_(g8.end()), current8_(current8),\n          begin9_(g9.begin()), end9_(g9.end()), current9_(current9)    {\n      ComputeCurrentValue();\n    }\n    virtual ~Iterator() {}\n\n    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {\n      return base_;\n    }\n    // Advance should not be called on beyond-of-range iterators\n    // so no component iterators must be beyond end of range, either.\n    virtual void Advance() {\n      assert(!AtEnd());\n      ++current9_;\n      if (current9_ == end9_) {\n        current9_ = begin9_;\n        ++current8_;\n      }\n      if (current8_ == end8_) {\n        current8_ = begin8_;\n        ++current7_;\n      }\n      if (current7_ == end7_) {\n        current7_ = begin7_;\n        ++current6_;\n      }\n      if (current6_ == end6_) {\n        current6_ = begin6_;\n        ++current5_;\n      }\n      if (current5_ == end5_) {\n        current5_ = begin5_;\n        ++current4_;\n      }\n      if (current4_ == end4_) {\n        current4_ = begin4_;\n        ++current3_;\n      }\n      if (current3_ == end3_) {\n        current3_ = begin3_;\n        ++current2_;\n      }\n      if (current2_ == end2_) {\n        current2_ = begin2_;\n        ++current1_;\n      }\n      ComputeCurrentValue();\n    }\n    virtual ParamIteratorInterface<ParamType>* Clone() const {\n      return new Iterator(*this);\n    }\n    virtual const ParamType* Current() const { return &current_value_; }\n    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {\n      // Having the same base generator guarantees that the other\n      // iterator is of the same type and we can downcast.\n      GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\n          << \"The program attempted to compare iterators \"\n          << \"from different generators.\" << std::endl;\n      const Iterator* typed_other =\n          CheckedDowncastToActualType<const Iterator>(&other);\n      // We must report iterators equal if they both point beyond their\n      // respective ranges. That can happen in a variety of fashions,\n      // so we have to consult AtEnd().\n      return (AtEnd() && typed_other->AtEnd()) ||\n         (\n          current1_ == typed_other->current1_ &&\n          current2_ == typed_other->current2_ &&\n          current3_ == typed_other->current3_ &&\n          current4_ == typed_other->current4_ &&\n          current5_ == typed_other->current5_ &&\n          current6_ == typed_other->current6_ &&\n          current7_ == typed_other->current7_ &&\n          current8_ == typed_other->current8_ &&\n          current9_ == typed_other->current9_);\n    }\n\n   private:\n    Iterator(const Iterator& other)\n        : base_(other.base_),\n        begin1_(other.begin1_),\n        end1_(other.end1_),\n        current1_(other.current1_),\n        begin2_(other.begin2_),\n        end2_(other.end2_),\n        current2_(other.current2_),\n        begin3_(other.begin3_),\n        end3_(other.end3_),\n        current3_(other.current3_),\n        begin4_(other.begin4_),\n        end4_(other.end4_),\n        current4_(other.current4_),\n        begin5_(other.begin5_),\n        end5_(other.end5_),\n        current5_(other.current5_),\n        begin6_(other.begin6_),\n        end6_(other.end6_),\n        current6_(other.current6_),\n        begin7_(other.begin7_),\n        end7_(other.end7_),\n        current7_(other.current7_),\n        begin8_(other.begin8_),\n        end8_(other.end8_),\n        current8_(other.current8_),\n        begin9_(other.begin9_),\n        end9_(other.end9_),\n        current9_(other.current9_) {\n      ComputeCurrentValue();\n    }\n\n    void ComputeCurrentValue() {\n      if (!AtEnd())\n        current_value_ = ParamType(*current1_, *current2_, *current3_,\n            *current4_, *current5_, *current6_, *current7_, *current8_,\n            *current9_);\n    }\n    bool AtEnd() const {\n      // We must report iterator past the end of the range when either of the\n      // component iterators has reached the end of its range.\n      return\n          current1_ == end1_ ||\n          current2_ == end2_ ||\n          current3_ == end3_ ||\n          current4_ == end4_ ||\n          current5_ == end5_ ||\n          current6_ == end6_ ||\n          current7_ == end7_ ||\n          current8_ == end8_ ||\n          current9_ == end9_;\n    }\n\n    // No implementation - assignment is unsupported.\n    void operator=(const Iterator& other) = delete;\n\n    const ParamGeneratorInterface<ParamType>* const base_;\n    // begin[i]_ and end[i]_ define the i-th range that Iterator traverses.\n    // current[i]_ is the actual traversing iterator.\n    const typename ParamGenerator<T1>::iterator begin1_;\n    const typename ParamGenerator<T1>::iterator end1_;\n    typename ParamGenerator<T1>::iterator current1_;\n    const typename ParamGenerator<T2>::iterator begin2_;\n    const typename ParamGenerator<T2>::iterator end2_;\n    typename ParamGenerator<T2>::iterator current2_;\n    const typename ParamGenerator<T3>::iterator begin3_;\n    const typename ParamGenerator<T3>::iterator end3_;\n    typename ParamGenerator<T3>::iterator current3_;\n    const typename ParamGenerator<T4>::iterator begin4_;\n    const typename ParamGenerator<T4>::iterator end4_;\n    typename ParamGenerator<T4>::iterator current4_;\n    const typename ParamGenerator<T5>::iterator begin5_;\n    const typename ParamGenerator<T5>::iterator end5_;\n    typename ParamGenerator<T5>::iterator current5_;\n    const typename ParamGenerator<T6>::iterator begin6_;\n    const typename ParamGenerator<T6>::iterator end6_;\n    typename ParamGenerator<T6>::iterator current6_;\n    const typename ParamGenerator<T7>::iterator begin7_;\n    const typename ParamGenerator<T7>::iterator end7_;\n    typename ParamGenerator<T7>::iterator current7_;\n    const typename ParamGenerator<T8>::iterator begin8_;\n    const typename ParamGenerator<T8>::iterator end8_;\n    typename ParamGenerator<T8>::iterator current8_;\n    const typename ParamGenerator<T9>::iterator begin9_;\n    const typename ParamGenerator<T9>::iterator end9_;\n    typename ParamGenerator<T9>::iterator current9_;\n    ParamType current_value_;\n  };  // class CartesianProductGenerator9::Iterator\n\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductGenerator9& other) = delete;\n\n  const ParamGenerator<T1> g1_;\n  const ParamGenerator<T2> g2_;\n  const ParamGenerator<T3> g3_;\n  const ParamGenerator<T4> g4_;\n  const ParamGenerator<T5> g5_;\n  const ParamGenerator<T6> g6_;\n  const ParamGenerator<T7> g7_;\n  const ParamGenerator<T8> g8_;\n  const ParamGenerator<T9> g9_;\n};  // class CartesianProductGenerator9\n\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10>\nclass CartesianProductGenerator10\n    : public ParamGeneratorInterface< ::testing::tuple<T1, T2, T3, T4, T5, T6,\n        T7, T8, T9, T10> > {\n public:\n  typedef ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> ParamType;\n\n  CartesianProductGenerator10(const ParamGenerator<T1>& g1,\n      const ParamGenerator<T2>& g2, const ParamGenerator<T3>& g3,\n      const ParamGenerator<T4>& g4, const ParamGenerator<T5>& g5,\n      const ParamGenerator<T6>& g6, const ParamGenerator<T7>& g7,\n      const ParamGenerator<T8>& g8, const ParamGenerator<T9>& g9,\n      const ParamGenerator<T10>& g10)\n      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7), g8_(g8),\n          g9_(g9), g10_(g10) {}\n  virtual ~CartesianProductGenerator10() {}\n\n  virtual ParamIteratorInterface<ParamType>* Begin() const {\n    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin(), g3_,\n        g3_.begin(), g4_, g4_.begin(), g5_, g5_.begin(), g6_, g6_.begin(), g7_,\n        g7_.begin(), g8_, g8_.begin(), g9_, g9_.begin(), g10_, g10_.begin());\n  }\n  virtual ParamIteratorInterface<ParamType>* End() const {\n    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end(),\n        g4_, g4_.end(), g5_, g5_.end(), g6_, g6_.end(), g7_, g7_.end(), g8_,\n        g8_.end(), g9_, g9_.end(), g10_, g10_.end());\n  }\n\n private:\n  class Iterator : public ParamIteratorInterface<ParamType> {\n   public:\n    Iterator(const ParamGeneratorInterface<ParamType>* base,\n      const ParamGenerator<T1>& g1,\n      const typename ParamGenerator<T1>::iterator& current1,\n      const ParamGenerator<T2>& g2,\n      const typename ParamGenerator<T2>::iterator& current2,\n      const ParamGenerator<T3>& g3,\n      const typename ParamGenerator<T3>::iterator& current3,\n      const ParamGenerator<T4>& g4,\n      const typename ParamGenerator<T4>::iterator& current4,\n      const ParamGenerator<T5>& g5,\n      const typename ParamGenerator<T5>::iterator& current5,\n      const ParamGenerator<T6>& g6,\n      const typename ParamGenerator<T6>::iterator& current6,\n      const ParamGenerator<T7>& g7,\n      const typename ParamGenerator<T7>::iterator& current7,\n      const ParamGenerator<T8>& g8,\n      const typename ParamGenerator<T8>::iterator& current8,\n      const ParamGenerator<T9>& g9,\n      const typename ParamGenerator<T9>::iterator& current9,\n      const ParamGenerator<T10>& g10,\n      const typename ParamGenerator<T10>::iterator& current10)\n        : base_(base),\n          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),\n          begin2_(g2.begin()), end2_(g2.end()), current2_(current2),\n          begin3_(g3.begin()), end3_(g3.end()), current3_(current3),\n          begin4_(g4.begin()), end4_(g4.end()), current4_(current4),\n          begin5_(g5.begin()), end5_(g5.end()), current5_(current5),\n          begin6_(g6.begin()), end6_(g6.end()), current6_(current6),\n          begin7_(g7.begin()), end7_(g7.end()), current7_(current7),\n          begin8_(g8.begin()), end8_(g8.end()), current8_(current8),\n          begin9_(g9.begin()), end9_(g9.end()), current9_(current9),\n          begin10_(g10.begin()), end10_(g10.end()), current10_(current10)    {\n      ComputeCurrentValue();\n    }\n    virtual ~Iterator() {}\n\n    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {\n      return base_;\n    }\n    // Advance should not be called on beyond-of-range iterators\n    // so no component iterators must be beyond end of range, either.\n    virtual void Advance() {\n      assert(!AtEnd());\n      ++current10_;\n      if (current10_ == end10_) {\n        current10_ = begin10_;\n        ++current9_;\n      }\n      if (current9_ == end9_) {\n        current9_ = begin9_;\n        ++current8_;\n      }\n      if (current8_ == end8_) {\n        current8_ = begin8_;\n        ++current7_;\n      }\n      if (current7_ == end7_) {\n        current7_ = begin7_;\n        ++current6_;\n      }\n      if (current6_ == end6_) {\n        current6_ = begin6_;\n        ++current5_;\n      }\n      if (current5_ == end5_) {\n        current5_ = begin5_;\n        ++current4_;\n      }\n      if (current4_ == end4_) {\n        current4_ = begin4_;\n        ++current3_;\n      }\n      if (current3_ == end3_) {\n        current3_ = begin3_;\n        ++current2_;\n      }\n      if (current2_ == end2_) {\n        current2_ = begin2_;\n        ++current1_;\n      }\n      ComputeCurrentValue();\n    }\n    virtual ParamIteratorInterface<ParamType>* Clone() const {\n      return new Iterator(*this);\n    }\n    virtual const ParamType* Current() const { return &current_value_; }\n    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {\n      // Having the same base generator guarantees that the other\n      // iterator is of the same type and we can downcast.\n      GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\n          << \"The program attempted to compare iterators \"\n          << \"from different generators.\" << std::endl;\n      const Iterator* typed_other =\n          CheckedDowncastToActualType<const Iterator>(&other);\n      // We must report iterators equal if they both point beyond their\n      // respective ranges. That can happen in a variety of fashions,\n      // so we have to consult AtEnd().\n      return (AtEnd() && typed_other->AtEnd()) ||\n         (\n          current1_ == typed_other->current1_ &&\n          current2_ == typed_other->current2_ &&\n          current3_ == typed_other->current3_ &&\n          current4_ == typed_other->current4_ &&\n          current5_ == typed_other->current5_ &&\n          current6_ == typed_other->current6_ &&\n          current7_ == typed_other->current7_ &&\n          current8_ == typed_other->current8_ &&\n          current9_ == typed_other->current9_ &&\n          current10_ == typed_other->current10_);\n    }\n\n   private:\n    Iterator(const Iterator& other)\n        : base_(other.base_),\n        begin1_(other.begin1_),\n        end1_(other.end1_),\n        current1_(other.current1_),\n        begin2_(other.begin2_),\n        end2_(other.end2_),\n        current2_(other.current2_),\n        begin3_(other.begin3_),\n        end3_(other.end3_),\n        current3_(other.current3_),\n        begin4_(other.begin4_),\n        end4_(other.end4_),\n        current4_(other.current4_),\n        begin5_(other.begin5_),\n        end5_(other.end5_),\n        current5_(other.current5_),\n        begin6_(other.begin6_),\n        end6_(other.end6_),\n        current6_(other.current6_),\n        begin7_(other.begin7_),\n        end7_(other.end7_),\n        current7_(other.current7_),\n        begin8_(other.begin8_),\n        end8_(other.end8_),\n        current8_(other.current8_),\n        begin9_(other.begin9_),\n        end9_(other.end9_),\n        current9_(other.current9_),\n        begin10_(other.begin10_),\n        end10_(other.end10_),\n        current10_(other.current10_) {\n      ComputeCurrentValue();\n    }\n\n    void ComputeCurrentValue() {\n      if (!AtEnd())\n        current_value_ = ParamType(*current1_, *current2_, *current3_,\n            *current4_, *current5_, *current6_, *current7_, *current8_,\n            *current9_, *current10_);\n    }\n    bool AtEnd() const {\n      // We must report iterator past the end of the range when either of the\n      // component iterators has reached the end of its range.\n      return\n          current1_ == end1_ ||\n          current2_ == end2_ ||\n          current3_ == end3_ ||\n          current4_ == end4_ ||\n          current5_ == end5_ ||\n          current6_ == end6_ ||\n          current7_ == end7_ ||\n          current8_ == end8_ ||\n          current9_ == end9_ ||\n          current10_ == end10_;\n    }\n\n    // No implementation - assignment is unsupported.\n    void operator=(const Iterator& other) = delete;\n\n    const ParamGeneratorInterface<ParamType>* const base_;\n    // begin[i]_ and end[i]_ define the i-th range that Iterator traverses.\n    // current[i]_ is the actual traversing iterator.\n    const typename ParamGenerator<T1>::iterator begin1_;\n    const typename ParamGenerator<T1>::iterator end1_;\n    typename ParamGenerator<T1>::iterator current1_;\n    const typename ParamGenerator<T2>::iterator begin2_;\n    const typename ParamGenerator<T2>::iterator end2_;\n    typename ParamGenerator<T2>::iterator current2_;\n    const typename ParamGenerator<T3>::iterator begin3_;\n    const typename ParamGenerator<T3>::iterator end3_;\n    typename ParamGenerator<T3>::iterator current3_;\n    const typename ParamGenerator<T4>::iterator begin4_;\n    const typename ParamGenerator<T4>::iterator end4_;\n    typename ParamGenerator<T4>::iterator current4_;\n    const typename ParamGenerator<T5>::iterator begin5_;\n    const typename ParamGenerator<T5>::iterator end5_;\n    typename ParamGenerator<T5>::iterator current5_;\n    const typename ParamGenerator<T6>::iterator begin6_;\n    const typename ParamGenerator<T6>::iterator end6_;\n    typename ParamGenerator<T6>::iterator current6_;\n    const typename ParamGenerator<T7>::iterator begin7_;\n    const typename ParamGenerator<T7>::iterator end7_;\n    typename ParamGenerator<T7>::iterator current7_;\n    const typename ParamGenerator<T8>::iterator begin8_;\n    const typename ParamGenerator<T8>::iterator end8_;\n    typename ParamGenerator<T8>::iterator current8_;\n    const typename ParamGenerator<T9>::iterator begin9_;\n    const typename ParamGenerator<T9>::iterator end9_;\n    typename ParamGenerator<T9>::iterator current9_;\n    const typename ParamGenerator<T10>::iterator begin10_;\n    const typename ParamGenerator<T10>::iterator end10_;\n    typename ParamGenerator<T10>::iterator current10_;\n    ParamType current_value_;\n  };  // class CartesianProductGenerator10::Iterator\n\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductGenerator10& other) = delete;\n\n  const ParamGenerator<T1> g1_;\n  const ParamGenerator<T2> g2_;\n  const ParamGenerator<T3> g3_;\n  const ParamGenerator<T4> g4_;\n  const ParamGenerator<T5> g5_;\n  const ParamGenerator<T6> g6_;\n  const ParamGenerator<T7> g7_;\n  const ParamGenerator<T8> g8_;\n  const ParamGenerator<T9> g9_;\n  const ParamGenerator<T10> g10_;\n};  // class CartesianProductGenerator10\n\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// Helper classes providing Combine() with polymorphic features. They allow\n// casting CartesianProductGeneratorN<T> to ParamGenerator<U> if T is\n// convertible to U.\n//\ntemplate <class Generator1, class Generator2>\nclass CartesianProductHolder2 {\n public:\nCartesianProductHolder2(const Generator1& g1, const Generator2& g2)\n      : g1_(g1), g2_(g2) {}\n  template <typename T1, typename T2>\n  operator ParamGenerator< ::testing::tuple<T1, T2> >() const {\n    return ParamGenerator< ::testing::tuple<T1, T2> >(\n        new CartesianProductGenerator2<T1, T2>(\n        static_cast<ParamGenerator<T1> >(g1_),\n        static_cast<ParamGenerator<T2> >(g2_)));\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductHolder2& other) = delete;\n\n  const Generator1 g1_;\n  const Generator2 g2_;\n};  // class CartesianProductHolder2\n\ntemplate <class Generator1, class Generator2, class Generator3>\nclass CartesianProductHolder3 {\n public:\nCartesianProductHolder3(const Generator1& g1, const Generator2& g2,\n    const Generator3& g3)\n      : g1_(g1), g2_(g2), g3_(g3) {}\n  template <typename T1, typename T2, typename T3>\n  operator ParamGenerator< ::testing::tuple<T1, T2, T3> >() const {\n    return ParamGenerator< ::testing::tuple<T1, T2, T3> >(\n        new CartesianProductGenerator3<T1, T2, T3>(\n        static_cast<ParamGenerator<T1> >(g1_),\n        static_cast<ParamGenerator<T2> >(g2_),\n        static_cast<ParamGenerator<T3> >(g3_)));\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductHolder3& other) = delete;\n\n  const Generator1 g1_;\n  const Generator2 g2_;\n  const Generator3 g3_;\n};  // class CartesianProductHolder3\n\ntemplate <class Generator1, class Generator2, class Generator3,\n    class Generator4>\nclass CartesianProductHolder4 {\n public:\nCartesianProductHolder4(const Generator1& g1, const Generator2& g2,\n    const Generator3& g3, const Generator4& g4)\n      : g1_(g1), g2_(g2), g3_(g3), g4_(g4) {}\n  template <typename T1, typename T2, typename T3, typename T4>\n  operator ParamGenerator< ::testing::tuple<T1, T2, T3, T4> >() const {\n    return ParamGenerator< ::testing::tuple<T1, T2, T3, T4> >(\n        new CartesianProductGenerator4<T1, T2, T3, T4>(\n        static_cast<ParamGenerator<T1> >(g1_),\n        static_cast<ParamGenerator<T2> >(g2_),\n        static_cast<ParamGenerator<T3> >(g3_),\n        static_cast<ParamGenerator<T4> >(g4_)));\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductHolder4& other) = delete;\n\n  const Generator1 g1_;\n  const Generator2 g2_;\n  const Generator3 g3_;\n  const Generator4 g4_;\n};  // class CartesianProductHolder4\n\ntemplate <class Generator1, class Generator2, class Generator3,\n    class Generator4, class Generator5>\nclass CartesianProductHolder5 {\n public:\nCartesianProductHolder5(const Generator1& g1, const Generator2& g2,\n    const Generator3& g3, const Generator4& g4, const Generator5& g5)\n      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5) {}\n  template <typename T1, typename T2, typename T3, typename T4, typename T5>\n  operator ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5> >() const {\n    return ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5> >(\n        new CartesianProductGenerator5<T1, T2, T3, T4, T5>(\n        static_cast<ParamGenerator<T1> >(g1_),\n        static_cast<ParamGenerator<T2> >(g2_),\n        static_cast<ParamGenerator<T3> >(g3_),\n        static_cast<ParamGenerator<T4> >(g4_),\n        static_cast<ParamGenerator<T5> >(g5_)));\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductHolder5& other) = delete;\n\n  const Generator1 g1_;\n  const Generator2 g2_;\n  const Generator3 g3_;\n  const Generator4 g4_;\n  const Generator5 g5_;\n};  // class CartesianProductHolder5\n\ntemplate <class Generator1, class Generator2, class Generator3,\n    class Generator4, class Generator5, class Generator6>\nclass CartesianProductHolder6 {\n public:\nCartesianProductHolder6(const Generator1& g1, const Generator2& g2,\n    const Generator3& g3, const Generator4& g4, const Generator5& g5,\n    const Generator6& g6)\n      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6) {}\n  template <typename T1, typename T2, typename T3, typename T4, typename T5,\n      typename T6>\n  operator ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6> >() const {\n    return ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6> >(\n        new CartesianProductGenerator6<T1, T2, T3, T4, T5, T6>(\n        static_cast<ParamGenerator<T1> >(g1_),\n        static_cast<ParamGenerator<T2> >(g2_),\n        static_cast<ParamGenerator<T3> >(g3_),\n        static_cast<ParamGenerator<T4> >(g4_),\n        static_cast<ParamGenerator<T5> >(g5_),\n        static_cast<ParamGenerator<T6> >(g6_)));\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductHolder6& other) = delete;\n\n  const Generator1 g1_;\n  const Generator2 g2_;\n  const Generator3 g3_;\n  const Generator4 g4_;\n  const Generator5 g5_;\n  const Generator6 g6_;\n};  // class CartesianProductHolder6\n\ntemplate <class Generator1, class Generator2, class Generator3,\n    class Generator4, class Generator5, class Generator6, class Generator7>\nclass CartesianProductHolder7 {\n public:\nCartesianProductHolder7(const Generator1& g1, const Generator2& g2,\n    const Generator3& g3, const Generator4& g4, const Generator5& g5,\n    const Generator6& g6, const Generator7& g7)\n      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7) {}\n  template <typename T1, typename T2, typename T3, typename T4, typename T5,\n      typename T6, typename T7>\n  operator ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6,\n      T7> >() const {\n    return ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6, T7> >(\n        new CartesianProductGenerator7<T1, T2, T3, T4, T5, T6, T7>(\n        static_cast<ParamGenerator<T1> >(g1_),\n        static_cast<ParamGenerator<T2> >(g2_),\n        static_cast<ParamGenerator<T3> >(g3_),\n        static_cast<ParamGenerator<T4> >(g4_),\n        static_cast<ParamGenerator<T5> >(g5_),\n        static_cast<ParamGenerator<T6> >(g6_),\n        static_cast<ParamGenerator<T7> >(g7_)));\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductHolder7& other) = delete;\n\n  const Generator1 g1_;\n  const Generator2 g2_;\n  const Generator3 g3_;\n  const Generator4 g4_;\n  const Generator5 g5_;\n  const Generator6 g6_;\n  const Generator7 g7_;\n};  // class CartesianProductHolder7\n\ntemplate <class Generator1, class Generator2, class Generator3,\n    class Generator4, class Generator5, class Generator6, class Generator7,\n    class Generator8>\nclass CartesianProductHolder8 {\n public:\nCartesianProductHolder8(const Generator1& g1, const Generator2& g2,\n    const Generator3& g3, const Generator4& g4, const Generator5& g5,\n    const Generator6& g6, const Generator7& g7, const Generator8& g8)\n      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7),\n          g8_(g8) {}\n  template <typename T1, typename T2, typename T3, typename T4, typename T5,\n      typename T6, typename T7, typename T8>\n  operator ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6, T7,\n      T8> >() const {\n    return ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8> >(\n        new CartesianProductGenerator8<T1, T2, T3, T4, T5, T6, T7, T8>(\n        static_cast<ParamGenerator<T1> >(g1_),\n        static_cast<ParamGenerator<T2> >(g2_),\n        static_cast<ParamGenerator<T3> >(g3_),\n        static_cast<ParamGenerator<T4> >(g4_),\n        static_cast<ParamGenerator<T5> >(g5_),\n        static_cast<ParamGenerator<T6> >(g6_),\n        static_cast<ParamGenerator<T7> >(g7_),\n        static_cast<ParamGenerator<T8> >(g8_)));\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductHolder8& other) = delete;\n\n  const Generator1 g1_;\n  const Generator2 g2_;\n  const Generator3 g3_;\n  const Generator4 g4_;\n  const Generator5 g5_;\n  const Generator6 g6_;\n  const Generator7 g7_;\n  const Generator8 g8_;\n};  // class CartesianProductHolder8\n\ntemplate <class Generator1, class Generator2, class Generator3,\n    class Generator4, class Generator5, class Generator6, class Generator7,\n    class Generator8, class Generator9>\nclass CartesianProductHolder9 {\n public:\nCartesianProductHolder9(const Generator1& g1, const Generator2& g2,\n    const Generator3& g3, const Generator4& g4, const Generator5& g5,\n    const Generator6& g6, const Generator7& g7, const Generator8& g8,\n    const Generator9& g9)\n      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7), g8_(g8),\n          g9_(g9) {}\n  template <typename T1, typename T2, typename T3, typename T4, typename T5,\n      typename T6, typename T7, typename T8, typename T9>\n  operator ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8,\n      T9> >() const {\n    return ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8,\n        T9> >(\n        new CartesianProductGenerator9<T1, T2, T3, T4, T5, T6, T7, T8, T9>(\n        static_cast<ParamGenerator<T1> >(g1_),\n        static_cast<ParamGenerator<T2> >(g2_),\n        static_cast<ParamGenerator<T3> >(g3_),\n        static_cast<ParamGenerator<T4> >(g4_),\n        static_cast<ParamGenerator<T5> >(g5_),\n        static_cast<ParamGenerator<T6> >(g6_),\n        static_cast<ParamGenerator<T7> >(g7_),\n        static_cast<ParamGenerator<T8> >(g8_),\n        static_cast<ParamGenerator<T9> >(g9_)));\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductHolder9& other) = delete;\n\n  const Generator1 g1_;\n  const Generator2 g2_;\n  const Generator3 g3_;\n  const Generator4 g4_;\n  const Generator5 g5_;\n  const Generator6 g6_;\n  const Generator7 g7_;\n  const Generator8 g8_;\n  const Generator9 g9_;\n};  // class CartesianProductHolder9\n\ntemplate <class Generator1, class Generator2, class Generator3,\n    class Generator4, class Generator5, class Generator6, class Generator7,\n    class Generator8, class Generator9, class Generator10>\nclass CartesianProductHolder10 {\n public:\nCartesianProductHolder10(const Generator1& g1, const Generator2& g2,\n    const Generator3& g3, const Generator4& g4, const Generator5& g5,\n    const Generator6& g6, const Generator7& g7, const Generator8& g8,\n    const Generator9& g9, const Generator10& g10)\n      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7), g8_(g8),\n          g9_(g9), g10_(g10) {}\n  template <typename T1, typename T2, typename T3, typename T4, typename T5,\n      typename T6, typename T7, typename T8, typename T9, typename T10>\n  operator ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8, T9,\n      T10> >() const {\n    return ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8, T9,\n        T10> >(\n        new CartesianProductGenerator10<T1, T2, T3, T4, T5, T6, T7, T8, T9,\n            T10>(\n        static_cast<ParamGenerator<T1> >(g1_),\n        static_cast<ParamGenerator<T2> >(g2_),\n        static_cast<ParamGenerator<T3> >(g3_),\n        static_cast<ParamGenerator<T4> >(g4_),\n        static_cast<ParamGenerator<T5> >(g5_),\n        static_cast<ParamGenerator<T6> >(g6_),\n        static_cast<ParamGenerator<T7> >(g7_),\n        static_cast<ParamGenerator<T8> >(g8_),\n        static_cast<ParamGenerator<T9> >(g9_),\n        static_cast<ParamGenerator<T10> >(g10_)));\n  }\n\n private:\n  // No implementation - assignment is unsupported.\n  void operator=(const CartesianProductHolder10& other) = delete;\n\n  const Generator1 g1_;\n  const Generator2 g2_;\n  const Generator3 g3_;\n  const Generator4 g4_;\n  const Generator5 g5_;\n  const Generator6 g6_;\n  const Generator7 g7_;\n  const Generator8 g8_;\n  const Generator9 g9_;\n  const Generator10 g10_;\n};  // class CartesianProductHolder10\n\n# endif  // GTEST_HAS_COMBINE\n\n}  // namespace internal\n}  // namespace testing\n\n#ifdef __clang__\n#if __has_warning(\"-Wdeprecated-copy\")\n#pragma clang diagnostic pop\n#endif\n#endif\n\n#endif  //  GTEST_HAS_PARAM_TEST\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_GENERATED_H_\n"}, "64": {"id": 64, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-param-util.h", "content": "// Copyright 2008 Google Inc.\n// All Rights Reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: vladl@google.com (Vlad Losev)\n\n// Type and function utilities for implementing parameterized tests.\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_H_\n\n#include <ctype.h>\n\n#include <iterator>\n#include <set>\n#include <utility>\n#include <vector>\n\n// scripts/fuse_gtest.py depends on gtest's own header being #included\n// *unconditionally*.  Therefore these #includes cannot be moved\n// inside #if GTEST_HAS_PARAM_TEST.\n#include \"gtest/internal/gtest-internal.h\"\n#include \"gtest/internal/gtest-linked_ptr.h\"\n#include \"gtest/internal/gtest-port.h\"\n#include \"gtest/gtest-printers.h\"\n\n#if GTEST_HAS_PARAM_TEST\n\nnamespace testing {\n\n// Input to a parameterized test name generator, describing a test parameter.\n// Consists of the parameter value and the integer parameter index.\ntemplate <class ParamType>\nstruct TestParamInfo {\n  TestParamInfo(const ParamType& a_param, size_t an_index) :\n    param(a_param),\n    index(an_index) {}\n  ParamType param;\n  size_t index;\n};\n\n// A builtin parameterized test name generator which returns the result of\n// testing::PrintToString.\nstruct PrintToStringParamName {\n  template <class ParamType>\n  std::string operator()(const TestParamInfo<ParamType>& info) const {\n    return PrintToString(info.param);\n  }\n};\n\nnamespace internal {\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// Outputs a message explaining invalid registration of different\n// fixture class for the same test case. This may happen when\n// TEST_P macro is used to define two tests with the same name\n// but in different namespaces.\nGTEST_API_ void ReportInvalidTestCaseType(const char* test_case_name,\n                                          CodeLocation code_location);\n\ntemplate <typename> class ParamGeneratorInterface;\ntemplate <typename> class ParamGenerator;\n\n// Interface for iterating over elements provided by an implementation\n// of ParamGeneratorInterface<T>.\ntemplate <typename T>\nclass ParamIteratorInterface {\n public:\n  virtual ~ParamIteratorInterface() {}\n  // A pointer to the base generator instance.\n  // Used only for the purposes of iterator comparison\n  // to make sure that two iterators belong to the same generator.\n  virtual const ParamGeneratorInterface<T>* BaseGenerator() const = 0;\n  // Advances iterator to point to the next element\n  // provided by the generator. The caller is responsible\n  // for not calling Advance() on an iterator equal to\n  // BaseGenerator()->End().\n  virtual void Advance() = 0;\n  // Clones the iterator object. Used for implementing copy semantics\n  // of ParamIterator<T>.\n  virtual ParamIteratorInterface* Clone() const = 0;\n  // Dereferences the current iterator and provides (read-only) access\n  // to the pointed value. It is the caller's responsibility not to call\n  // Current() on an iterator equal to BaseGenerator()->End().\n  // Used for implementing ParamGenerator<T>::operator*().\n  virtual const T* Current() const = 0;\n  // Determines whether the given iterator and other point to the same\n  // element in the sequence generated by the generator.\n  // Used for implementing ParamGenerator<T>::operator==().\n  virtual bool Equals(const ParamIteratorInterface& other) const = 0;\n};\n\n// Class iterating over elements provided by an implementation of\n// ParamGeneratorInterface<T>. It wraps ParamIteratorInterface<T>\n// and implements the const forward iterator concept.\ntemplate <typename T>\nclass ParamIterator {\n public:\n  typedef T value_type;\n  typedef const T& reference;\n  typedef ptrdiff_t difference_type;\n\n  // ParamIterator assumes ownership of the impl_ pointer.\n  ParamIterator(const ParamIterator& other) : impl_(other.impl_->Clone()) {}\n  ParamIterator& operator=(const ParamIterator& other) {\n    if (this != &other)\n      impl_.reset(other.impl_->Clone());\n    return *this;\n  }\n\n  const T& operator*() const { return *impl_->Current(); }\n  const T* operator->() const { return impl_->Current(); }\n  // Prefix version of operator++.\n  ParamIterator& operator++() {\n    impl_->Advance();\n    return *this;\n  }\n  // Postfix version of operator++.\n  ParamIterator operator++(int /*unused*/) {\n    ParamIteratorInterface<T>* clone = impl_->Clone();\n    impl_->Advance();\n    return ParamIterator(clone);\n  }\n  bool operator==(const ParamIterator& other) const {\n    return impl_.get() == other.impl_.get() || impl_->Equals(*other.impl_);\n  }\n  bool operator!=(const ParamIterator& other) const {\n    return !(*this == other);\n  }\n\n private:\n  friend class ParamGenerator<T>;\n  explicit ParamIterator(ParamIteratorInterface<T>* impl) : impl_(impl) {}\n  scoped_ptr<ParamIteratorInterface<T> > impl_;\n};\n\n// ParamGeneratorInterface<T> is the binary interface to access generators\n// defined in other translation units.\ntemplate <typename T>\nclass ParamGeneratorInterface {\n public:\n  typedef T ParamType;\n\n  virtual ~ParamGeneratorInterface() {}\n\n  // Generator interface definition\n  virtual ParamIteratorInterface<T>* Begin() const = 0;\n  virtual ParamIteratorInterface<T>* End() const = 0;\n};\n\n// Wraps ParamGeneratorInterface<T> and provides general generator syntax\n// compatible with the STL Container concept.\n// This class implements copy initialization semantics and the contained\n// ParamGeneratorInterface<T> instance is shared among all copies\n// of the original object. This is possible because that instance is immutable.\ntemplate<typename T>\nclass ParamGenerator {\n public:\n  typedef ParamIterator<T> iterator;\n\n  explicit ParamGenerator(ParamGeneratorInterface<T>* impl) : impl_(impl) {}\n  ParamGenerator(const ParamGenerator& other) : impl_(other.impl_) {}\n\n  ParamGenerator& operator=(const ParamGenerator& other) {\n    impl_ = other.impl_;\n    return *this;\n  }\n\n  iterator begin() const { return iterator(impl_->Begin()); }\n  iterator end() const { return iterator(impl_->End()); }\n\n private:\n  linked_ptr<const ParamGeneratorInterface<T> > impl_;\n};\n\n// Generates values from a range of two comparable values. Can be used to\n// generate sequences of user-defined types that implement operator+() and\n// operator<().\n// This class is used in the Range() function.\ntemplate <typename T, typename IncrementT>\nclass RangeGenerator : public ParamGeneratorInterface<T> {\n public:\n  RangeGenerator(T begin, T end, IncrementT step)\n      : begin_(begin), end_(end),\n        step_(step), end_index_(CalculateEndIndex(begin, end, step)) {}\n  virtual ~RangeGenerator() {}\n\n  virtual ParamIteratorInterface<T>* Begin() const {\n    return new Iterator(this, begin_, 0, step_);\n  }\n  virtual ParamIteratorInterface<T>* End() const {\n    return new Iterator(this, end_, end_index_, step_);\n  }\n\n private:\n  class Iterator : public ParamIteratorInterface<T> {\n   public:\n    Iterator(const ParamGeneratorInterface<T>* base, T value, int index,\n             IncrementT step)\n        : base_(base), value_(value), index_(index), step_(step) {}\n    virtual ~Iterator() {}\n\n    virtual const ParamGeneratorInterface<T>* BaseGenerator() const {\n      return base_;\n    }\n    virtual void Advance() {\n      value_ = static_cast<T>(value_ + step_);\n      index_++;\n    }\n    virtual ParamIteratorInterface<T>* Clone() const {\n      return new Iterator(*this);\n    }\n    virtual const T* Current() const { return &value_; }\n    virtual bool Equals(const ParamIteratorInterface<T>& other) const {\n      // Having the same base generator guarantees that the other\n      // iterator is of the same type and we can downcast.\n      GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\n          << \"The program attempted to compare iterators \"\n          << \"from different generators.\" << std::endl;\n      const int other_index =\n          CheckedDowncastToActualType<const Iterator>(&other)->index_;\n      return index_ == other_index;\n    }\n\n   private:\n    Iterator(const Iterator& other)\n        : ParamIteratorInterface<T>(),\n          base_(other.base_), value_(other.value_), index_(other.index_),\n          step_(other.step_) {}\n\n    // No implementation - assignment is unsupported.\n    void operator=(const Iterator& other);\n\n    const ParamGeneratorInterface<T>* const base_;\n    T value_;\n    int index_;\n    const IncrementT step_;\n  };  // class RangeGenerator::Iterator\n\n  static int CalculateEndIndex(const T& begin,\n                               const T& end,\n                               const IncrementT& step) {\n    int end_index = 0;\n    for (T i = begin; i < end; i = static_cast<T>(i + step))\n      end_index++;\n    return end_index;\n  }\n\n  // No implementation - assignment is unsupported.\n  void operator=(const RangeGenerator& other);\n\n  const T begin_;\n  const T end_;\n  const IncrementT step_;\n  // The index for the end() iterator. All the elements in the generated\n  // sequence are indexed (0-based) to aid iterator comparison.\n  const int end_index_;\n};  // class RangeGenerator\n\n\n// Generates values from a pair of STL-style iterators. Used in the\n// ValuesIn() function. The elements are copied from the source range\n// since the source can be located on the stack, and the generator\n// is likely to persist beyond that stack frame.\ntemplate <typename T>\nclass ValuesInIteratorRangeGenerator : public ParamGeneratorInterface<T> {\n public:\n  template <typename ForwardIterator>\n  ValuesInIteratorRangeGenerator(ForwardIterator begin, ForwardIterator end)\n      : container_(begin, end) {}\n  virtual ~ValuesInIteratorRangeGenerator() {}\n\n  virtual ParamIteratorInterface<T>* Begin() const {\n    return new Iterator(this, container_.begin());\n  }\n  virtual ParamIteratorInterface<T>* End() const {\n    return new Iterator(this, container_.end());\n  }\n\n private:\n  typedef typename ::std::vector<T> ContainerType;\n\n  class Iterator : public ParamIteratorInterface<T> {\n   public:\n    Iterator(const ParamGeneratorInterface<T>* base,\n             typename ContainerType::const_iterator iterator)\n        : base_(base), iterator_(iterator) {}\n    virtual ~Iterator() {}\n\n    virtual const ParamGeneratorInterface<T>* BaseGenerator() const {\n      return base_;\n    }\n    virtual void Advance() {\n      ++iterator_;\n      value_.reset();\n    }\n    virtual ParamIteratorInterface<T>* Clone() const {\n      return new Iterator(*this);\n    }\n    // We need to use cached value referenced by iterator_ because *iterator_\n    // can return a temporary object (and of type other then T), so just\n    // having \"return &*iterator_;\" doesn't work.\n    // value_ is updated here and not in Advance() because Advance()\n    // can advance iterator_ beyond the end of the range, and we cannot\n    // detect that fact. The client code, on the other hand, is\n    // responsible for not calling Current() on an out-of-range iterator.\n    virtual const T* Current() const {\n      if (value_.get() == NULL)\n        value_.reset(new T(*iterator_));\n      return value_.get();\n    }\n    virtual bool Equals(const ParamIteratorInterface<T>& other) const {\n      // Having the same base generator guarantees that the other\n      // iterator is of the same type and we can downcast.\n      GTEST_CHECK_(BaseGenerator() == other.BaseGenerator())\n          << \"The program attempted to compare iterators \"\n          << \"from different generators.\" << std::endl;\n      return iterator_ ==\n          CheckedDowncastToActualType<const Iterator>(&other)->iterator_;\n    }\n\n   private:\n    Iterator(const Iterator& other)\n          // The explicit constructor call suppresses a false warning\n          // emitted by gcc when supplied with the -Wextra option.\n        : ParamIteratorInterface<T>(),\n          base_(other.base_),\n          iterator_(other.iterator_) {}\n\n    const ParamGeneratorInterface<T>* const base_;\n    typename ContainerType::const_iterator iterator_;\n    // A cached value of *iterator_. We keep it here to allow access by\n    // pointer in the wrapping iterator's operator->().\n    // value_ needs to be mutable to be accessed in Current().\n    // Use of scoped_ptr helps manage cached value's lifetime,\n    // which is bound by the lifespan of the iterator itself.\n    mutable scoped_ptr<const T> value_;\n  };  // class ValuesInIteratorRangeGenerator::Iterator\n\n  // No implementation - assignment is unsupported.\n  void operator=(const ValuesInIteratorRangeGenerator& other);\n\n  const ContainerType container_;\n};  // class ValuesInIteratorRangeGenerator\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// Default parameterized test name generator, returns a string containing the\n// integer test parameter index.\ntemplate <class ParamType>\nstd::string DefaultParamName(const TestParamInfo<ParamType>& info) {\n  Message name_stream;\n  name_stream << info.index;\n  return name_stream.GetString();\n}\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// Parameterized test name overload helpers, which help the\n// INSTANTIATE_TEST_CASE_P macro choose between the default parameterized\n// test name generator and user param name generator.\ntemplate <class ParamType, class ParamNameGenFunctor>\nParamNameGenFunctor GetParamNameGen(ParamNameGenFunctor func) {\n  return func;\n}\n\ntemplate <class ParamType>\nstruct ParamNameGenFunc {\n  typedef std::string Type(const TestParamInfo<ParamType>&);\n};\n\ntemplate <class ParamType>\ntypename ParamNameGenFunc<ParamType>::Type *GetParamNameGen() {\n  return DefaultParamName;\n}\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// Stores a parameter value and later creates tests parameterized with that\n// value.\ntemplate <class TestClass>\nclass ParameterizedTestFactory : public TestFactoryBase {\n public:\n  typedef typename TestClass::ParamType ParamType;\n  explicit ParameterizedTestFactory(ParamType parameter) :\n      parameter_(parameter) {}\n  virtual Test* CreateTest() {\n    TestClass::SetParam(&parameter_);\n    return new TestClass();\n  }\n\n private:\n  const ParamType parameter_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ParameterizedTestFactory);\n};\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// TestMetaFactoryBase is a base class for meta-factories that create\n// test factories for passing into MakeAndRegisterTestInfo function.\ntemplate <class ParamType>\nclass TestMetaFactoryBase {\n public:\n  virtual ~TestMetaFactoryBase() {}\n\n  virtual TestFactoryBase* CreateTestFactory(ParamType parameter) = 0;\n};\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// TestMetaFactory creates test factories for passing into\n// MakeAndRegisterTestInfo function. Since MakeAndRegisterTestInfo receives\n// ownership of test factory pointer, same factory object cannot be passed\n// into that method twice. But ParameterizedTestCaseInfo is going to call\n// it for each Test/Parameter value combination. Thus it needs meta factory\n// creator class.\ntemplate <class TestCase>\nclass TestMetaFactory\n    : public TestMetaFactoryBase<typename TestCase::ParamType> {\n public:\n  typedef typename TestCase::ParamType ParamType;\n\n  TestMetaFactory() {}\n\n  virtual TestFactoryBase* CreateTestFactory(ParamType parameter) {\n    return new ParameterizedTestFactory<TestCase>(parameter);\n  }\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestMetaFactory);\n};\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// ParameterizedTestCaseInfoBase is a generic interface\n// to ParameterizedTestCaseInfo classes. ParameterizedTestCaseInfoBase\n// accumulates test information provided by TEST_P macro invocations\n// and generators provided by INSTANTIATE_TEST_CASE_P macro invocations\n// and uses that information to register all resulting test instances\n// in RegisterTests method. The ParameterizeTestCaseRegistry class holds\n// a collection of pointers to the ParameterizedTestCaseInfo objects\n// and calls RegisterTests() on each of them when asked.\nclass ParameterizedTestCaseInfoBase {\n public:\n  virtual ~ParameterizedTestCaseInfoBase() {}\n\n  // Base part of test case name for display purposes.\n  virtual const string& GetTestCaseName() const = 0;\n  // Test case id to verify identity.\n  virtual TypeId GetTestCaseTypeId() const = 0;\n  // UnitTest class invokes this method to register tests in this\n  // test case right before running them in RUN_ALL_TESTS macro.\n  // This method should not be called more then once on any single\n  // instance of a ParameterizedTestCaseInfoBase derived class.\n  virtual void RegisterTests() = 0;\n\n protected:\n  ParameterizedTestCaseInfoBase() {}\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ParameterizedTestCaseInfoBase);\n};\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// ParameterizedTestCaseInfo accumulates tests obtained from TEST_P\n// macro invocations for a particular test case and generators\n// obtained from INSTANTIATE_TEST_CASE_P macro invocations for that\n// test case. It registers tests with all values generated by all\n// generators when asked.\ntemplate <class TestCase>\nclass ParameterizedTestCaseInfo : public ParameterizedTestCaseInfoBase {\n public:\n  // ParamType and GeneratorCreationFunc are private types but are required\n  // for declarations of public methods AddTestPattern() and\n  // AddTestCaseInstantiation().\n  typedef typename TestCase::ParamType ParamType;\n  // A function that returns an instance of appropriate generator type.\n  typedef ParamGenerator<ParamType>(GeneratorCreationFunc)();\n  typedef typename ParamNameGenFunc<ParamType>::Type ParamNameGeneratorFunc;\n\n  explicit ParameterizedTestCaseInfo(\n      const char* name, CodeLocation code_location)\n      : test_case_name_(name), code_location_(code_location) {}\n\n  // Test case base name for display purposes.\n  virtual const string& GetTestCaseName() const { return test_case_name_; }\n  // Test case id to verify identity.\n  virtual TypeId GetTestCaseTypeId() const { return GetTypeId<TestCase>(); }\n  // TEST_P macro uses AddTestPattern() to record information\n  // about a single test in a LocalTestInfo structure.\n  // test_case_name is the base name of the test case (without invocation\n  // prefix). test_base_name is the name of an individual test without\n  // parameter index. For the test SequenceA/FooTest.DoBar/1 FooTest is\n  // test case base name and DoBar is test base name.\n  void AddTestPattern(const char* test_case_name,\n                      const char* test_base_name,\n                      TestMetaFactoryBase<ParamType>* meta_factory) {\n    tests_.push_back(linked_ptr<TestInfo>(new TestInfo(test_case_name,\n                                                       test_base_name,\n                                                       meta_factory)));\n  }\n  // INSTANTIATE_TEST_CASE_P macro uses AddGenerator() to record information\n  // about a generator.\n  int AddTestCaseInstantiation(const string& instantiation_name,\n                               GeneratorCreationFunc* func,\n                               ParamNameGeneratorFunc* name_func,\n                               const char* file,\n                               int line) {\n    instantiations_.push_back(\n        InstantiationInfo(instantiation_name, func, name_func, file, line));\n    return 0;  // Return value used only to run this method in namespace scope.\n  }\n  // UnitTest class invokes this method to register tests in this test case\n  // test cases right before running tests in RUN_ALL_TESTS macro.\n  // This method should not be called more then once on any single\n  // instance of a ParameterizedTestCaseInfoBase derived class.\n  // UnitTest has a guard to prevent from calling this method more then once.\n  virtual void RegisterTests() {\n    for (typename TestInfoContainer::iterator test_it = tests_.begin();\n         test_it != tests_.end(); ++test_it) {\n      linked_ptr<TestInfo> test_info = *test_it;\n      for (typename InstantiationContainer::iterator gen_it =\n               instantiations_.begin(); gen_it != instantiations_.end();\n               ++gen_it) {\n        const string& instantiation_name = gen_it->name;\n        ParamGenerator<ParamType> generator((*gen_it->generator)());\n        ParamNameGeneratorFunc* name_func = gen_it->name_func;\n        const char* file = gen_it->file;\n        int line = gen_it->line;\n\n        string test_case_name;\n        if ( !instantiation_name.empty() )\n          test_case_name = instantiation_name + \"/\";\n        test_case_name += test_info->test_case_base_name;\n\n        size_t i = 0;\n        std::set<std::string> test_param_names;\n        for (typename ParamGenerator<ParamType>::iterator param_it =\n                 generator.begin();\n             param_it != generator.end(); ++param_it, ++i) {\n          Message test_name_stream;\n\n          std::string param_name = name_func(\n              TestParamInfo<ParamType>(*param_it, i));\n\n          GTEST_CHECK_(IsValidParamName(param_name))\n              << \"Parameterized test name '\" << param_name\n              << \"' is invalid, in \" << file\n              << \" line \" << line << std::endl;\n\n          GTEST_CHECK_(test_param_names.count(param_name) == 0)\n              << \"Duplicate parameterized test name '\" << param_name\n              << \"', in \" << file << \" line \" << line << std::endl;\n\n          test_param_names.insert(param_name);\n\n          test_name_stream << test_info->test_base_name << \"/\" << param_name;\n          MakeAndRegisterTestInfo(\n              test_case_name.c_str(),\n              test_name_stream.GetString().c_str(),\n              NULL,  // No type parameter.\n              PrintToString(*param_it).c_str(),\n              code_location_,\n              GetTestCaseTypeId(),\n              TestCase::SetUpTestCase,\n              TestCase::TearDownTestCase,\n              test_info->test_meta_factory->CreateTestFactory(*param_it));\n        }  // for param_it\n      }  // for gen_it\n    }  // for test_it\n  }  // RegisterTests\n\n private:\n  // LocalTestInfo structure keeps information about a single test registered\n  // with TEST_P macro.\n  struct TestInfo {\n    TestInfo(const char* a_test_case_base_name,\n             const char* a_test_base_name,\n             TestMetaFactoryBase<ParamType>* a_test_meta_factory) :\n        test_case_base_name(a_test_case_base_name),\n        test_base_name(a_test_base_name),\n        test_meta_factory(a_test_meta_factory) {}\n\n    const string test_case_base_name;\n    const string test_base_name;\n    const scoped_ptr<TestMetaFactoryBase<ParamType> > test_meta_factory;\n  };\n  typedef ::std::vector<linked_ptr<TestInfo> > TestInfoContainer;\n  // Records data received from INSTANTIATE_TEST_CASE_P macros:\n  //  <Instantiation name, Sequence generator creation function,\n  //     Name generator function, Source file, Source line>\n  struct InstantiationInfo {\n      InstantiationInfo(const std::string &name_in,\n                        GeneratorCreationFunc* generator_in,\n                        ParamNameGeneratorFunc* name_func_in,\n                        const char* file_in,\n                        int line_in)\n          : name(name_in),\n            generator(generator_in),\n            name_func(name_func_in),\n            file(file_in),\n            line(line_in) {}\n\n      std::string name;\n      GeneratorCreationFunc* generator;\n      ParamNameGeneratorFunc* name_func;\n      const char* file;\n      int line;\n  };\n  typedef ::std::vector<InstantiationInfo> InstantiationContainer;\n\n  static bool IsValidParamName(const std::string& name) {\n    // Check for empty string\n    if (name.empty())\n      return false;\n\n    // Check for invalid characters\n    for (std::string::size_type index = 0; index < name.size(); ++index) {\n      if (!isalnum(name[index]) && name[index] != '_')\n        return false;\n    }\n\n    return true;\n  }\n\n  const string test_case_name_;\n  CodeLocation code_location_;\n  TestInfoContainer tests_;\n  InstantiationContainer instantiations_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ParameterizedTestCaseInfo);\n};  // class ParameterizedTestCaseInfo\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// ParameterizedTestCaseRegistry contains a map of ParameterizedTestCaseInfoBase\n// classes accessed by test case names. TEST_P and INSTANTIATE_TEST_CASE_P\n// macros use it to locate their corresponding ParameterizedTestCaseInfo\n// descriptors.\nclass ParameterizedTestCaseRegistry {\n public:\n  ParameterizedTestCaseRegistry() {}\n  ~ParameterizedTestCaseRegistry() {\n    for (TestCaseInfoContainer::iterator it = test_case_infos_.begin();\n         it != test_case_infos_.end(); ++it) {\n      delete *it;\n    }\n  }\n\n  // Looks up or creates and returns a structure containing information about\n  // tests and instantiations of a particular test case.\n  template <class TestCase>\n  ParameterizedTestCaseInfo<TestCase>* GetTestCasePatternHolder(\n      const char* test_case_name,\n      CodeLocation code_location) {\n    ParameterizedTestCaseInfo<TestCase>* typed_test_info = NULL;\n    for (TestCaseInfoContainer::iterator it = test_case_infos_.begin();\n         it != test_case_infos_.end(); ++it) {\n      if ((*it)->GetTestCaseName() == test_case_name) {\n        if ((*it)->GetTestCaseTypeId() != GetTypeId<TestCase>()) {\n          // Complain about incorrect usage of Google Test facilities\n          // and terminate the program since we cannot guaranty correct\n          // test case setup and tear-down in this case.\n          ReportInvalidTestCaseType(test_case_name, code_location);\n          posix::Abort();\n        } else {\n          // At this point we are sure that the object we found is of the same\n          // type we are looking for, so we downcast it to that type\n          // without further checks.\n          typed_test_info = CheckedDowncastToActualType<\n              ParameterizedTestCaseInfo<TestCase> >(*it);\n        }\n        break;\n      }\n    }\n    if (typed_test_info == NULL) {\n      typed_test_info = new ParameterizedTestCaseInfo<TestCase>(\n          test_case_name, code_location);\n      test_case_infos_.push_back(typed_test_info);\n    }\n    return typed_test_info;\n  }\n  void RegisterTests() {\n    for (TestCaseInfoContainer::iterator it = test_case_infos_.begin();\n         it != test_case_infos_.end(); ++it) {\n      (*it)->RegisterTests();\n    }\n  }\n\n private:\n  typedef ::std::vector<ParameterizedTestCaseInfoBase*> TestCaseInfoContainer;\n\n  TestCaseInfoContainer test_case_infos_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ParameterizedTestCaseRegistry);\n};\n\n}  // namespace internal\n}  // namespace testing\n\n#endif  //  GTEST_HAS_PARAM_TEST\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_H_\n"}, "65": {"id": 65, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-port-arch.h", "content": "// Copyright 2015, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// The Google C++ Testing Framework (Google Test)\n//\n// This header file defines the GTEST_OS_* macro.\n// It is separate from gtest-port.h so that custom/gtest-port.h can include it.\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_ARCH_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_ARCH_H_\n\n// Determines the platform on which Google Test is compiled.\n#ifdef __CYGWIN__\n# define GTEST_OS_CYGWIN 1\n#elif defined __SYMBIAN32__\n# define GTEST_OS_SYMBIAN 1\n#elif defined _WIN32\n# define GTEST_OS_WINDOWS 1\n# ifdef _WIN32_WCE\n#  define GTEST_OS_WINDOWS_MOBILE 1\n# elif defined(__MINGW__) || defined(__MINGW32__)\n#  define GTEST_OS_WINDOWS_MINGW 1\n# elif defined(WINAPI_FAMILY)\n#  include <winapifamily.h>\n#  if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)\n#   define GTEST_OS_WINDOWS_DESKTOP 1\n#  elif WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_PHONE_APP)\n#   define GTEST_OS_WINDOWS_PHONE 1\n#  elif WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)\n#   define GTEST_OS_WINDOWS_RT 1\n#  else\n    // WINAPI_FAMILY defined but no known partition matched.\n    // Default to desktop.\n#   define GTEST_OS_WINDOWS_DESKTOP 1\n#  endif\n# else\n#  define GTEST_OS_WINDOWS_DESKTOP 1\n# endif  // _WIN32_WCE\n#elif defined __APPLE__\n# define GTEST_OS_MAC 1\n# if TARGET_OS_IPHONE\n#  define GTEST_OS_IOS 1\n# endif\n#elif defined __FreeBSD__\n# define GTEST_OS_FREEBSD 1\n#elif defined __linux__\n# define GTEST_OS_LINUX 1\n# if defined __ANDROID__\n#  define GTEST_OS_LINUX_ANDROID 1\n# endif\n#elif defined __MVS__\n# define GTEST_OS_ZOS 1\n#elif defined(__sun) && defined(__SVR4)\n# define GTEST_OS_SOLARIS 1\n#elif defined(_AIX)\n# define GTEST_OS_AIX 1\n#elif defined(__hpux)\n# define GTEST_OS_HPUX 1\n#elif defined __native_client__\n# define GTEST_OS_NACL 1\n#elif defined __NetBSD__\n# define GTEST_OS_NETBSD 1\n#elif defined __OpenBSD__\n# define GTEST_OS_OPENBSD 1\n#elif defined __QNX__\n# define GTEST_OS_QNX 1\n#elif defined(__HAIKU__)\n# define GTEST_OS_HAIKU 1\n#elif defined(_MINIX)\n# define GTEST_OS_MINIX 1\n#endif  // __CYGWIN__\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_ARCH_H_\n"}, "66": {"id": 66, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-port.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Authors: wan@google.com (Zhanyong Wan)\n//\n// Low-level types and utilities for porting Google Test to various\n// platforms.  All macros ending with _ and symbols defined in an\n// internal namespace are subject to change without notice.  Code\n// outside Google Test MUST NOT USE THEM DIRECTLY.  Macros that don't\n// end with _ are part of Google Test's public API and can be used by\n// code outside Google Test.\n//\n// This file is fundamental to Google Test.  All other Google Test source\n// files are expected to #include this.  Therefore, it cannot #include\n// any other Google Test header.\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_\n\n// Environment-describing macros\n// -----------------------------\n//\n// Google Test can be used in many different environments.  Macros in\n// this section tell Google Test what kind of environment it is being\n// used in, such that Google Test can provide environment-specific\n// features and implementations.\n//\n// Google Test tries to automatically detect the properties of its\n// environment, so users usually don't need to worry about these\n// macros.  However, the automatic detection is not perfect.\n// Sometimes it's necessary for a user to define some of the following\n// macros in the build script to override Google Test's decisions.\n//\n// If the user doesn't define a macro in the list, Google Test will\n// provide a default definition.  After this header is #included, all\n// macros in this list will be defined to either 1 or 0.\n//\n// Notes to maintainers:\n//   - Each macro here is a user-tweakable knob; do not grow the list\n//     lightly.\n//   - Use #if to key off these macros.  Don't use #ifdef or \"#if\n//     defined(...)\", which will not work as these macros are ALWAYS\n//     defined.\n//\n//   GTEST_HAS_CLONE          - Define it to 1/0 to indicate that clone(2)\n//                              is/isn't available.\n//   GTEST_HAS_EXCEPTIONS     - Define it to 1/0 to indicate that exceptions\n//                              are enabled.\n//   GTEST_HAS_GLOBAL_STRING  - Define it to 1/0 to indicate that ::string\n//                              is/isn't available (some systems define\n//                              ::string, which is different to std::string).\n//   GTEST_HAS_GLOBAL_WSTRING - Define it to 1/0 to indicate that ::string\n//                              is/isn't available (some systems define\n//                              ::wstring, which is different to std::wstring).\n//   GTEST_HAS_POSIX_RE       - Define it to 1/0 to indicate that POSIX regular\n//                              expressions are/aren't available.\n//   GTEST_HAS_PTHREAD        - Define it to 1/0 to indicate that <pthread.h>\n//                              is/isn't available.\n//   GTEST_HAS_RTTI           - Define it to 1/0 to indicate that RTTI is/isn't\n//                              enabled.\n//   GTEST_HAS_STD_WSTRING    - Define it to 1/0 to indicate that\n//                              std::wstring does/doesn't work (Google Test can\n//                              be used where std::wstring is unavailable).\n//   GTEST_HAS_TR1_TUPLE      - Define it to 1/0 to indicate tr1::tuple\n//                              is/isn't available.\n//   GTEST_HAS_SEH            - Define it to 1/0 to indicate whether the\n//                              compiler supports Microsoft's \"Structured\n//                              Exception Handling\".\n//   GTEST_HAS_STREAM_REDIRECTION\n//                            - Define it to 1/0 to indicate whether the\n//                              platform supports I/O stream redirection using\n//                              dup() and dup2().\n//   GTEST_USE_OWN_TR1_TUPLE  - Define it to 1/0 to indicate whether Google\n//                              Test's own tr1 tuple implementation should be\n//                              used.  Unused when the user sets\n//                              GTEST_HAS_TR1_TUPLE to 0.\n//   GTEST_LANG_CXX11         - Define it to 1/0 to indicate that Google Test\n//                              is building in C++11/C++98 mode.\n//   GTEST_LINKED_AS_SHARED_LIBRARY\n//                            - Define to 1 when compiling tests that use\n//                              Google Test as a shared library (known as\n//                              DLL on Windows).\n//   GTEST_CREATE_SHARED_LIBRARY\n//                            - Define to 1 when compiling Google Test itself\n//                              as a shared library.\n\n// Platform-indicating macros\n// --------------------------\n//\n// Macros indicating the platform on which Google Test is being used\n// (a macro is defined to 1 if compiled on the given platform;\n// otherwise UNDEFINED -- it's never defined to 0.).  Google Test\n// defines these macros automatically.  Code outside Google Test MUST\n// NOT define them.\n//\n//   GTEST_OS_AIX      - IBM AIX\n//   GTEST_OS_CYGWIN   - Cygwin\n//   GTEST_OS_FREEBSD  - FreeBSD\n//   GTEST_OS_HAIKU    - Haiku\n//   GTEST_OS_HPUX     - HP-UX\n//   GTEST_OS_LINUX    - Linux\n//     GTEST_OS_LINUX_ANDROID - Google Android\n//   GTEST_OS_MAC      - Mac OS X\n//     GTEST_OS_IOS    - iOS\n//   GTEST_OS_MINIX    - Minix\n//   GTEST_OS_NACL     - Google Native Client (NaCl)\n//   GTEST_OS_OPENBSD  - OpenBSD\n//   GTEST_OS_QNX      - QNX\n//   GTEST_OS_SOLARIS  - Sun Solaris\n//   GTEST_OS_SYMBIAN  - Symbian\n//   GTEST_OS_WINDOWS  - Windows (Desktop, MinGW, or Mobile)\n//     GTEST_OS_WINDOWS_DESKTOP  - Windows Desktop\n//     GTEST_OS_WINDOWS_MINGW    - MinGW\n//     GTEST_OS_WINDOWS_MOBILE   - Windows Mobile\n//     GTEST_OS_WINDOWS_PHONE    - Windows Phone\n//     GTEST_OS_WINDOWS_RT       - Windows Store App/WinRT\n//   GTEST_OS_ZOS      - z/OS\n//\n// Among the platforms, Cygwin, Linux, Max OS X, and Windows have the\n// most stable support.  Since core members of the Google Test project\n// don't have access to other platforms, support for them may be less\n// stable.  If you notice any problems on your platform, please notify\n// googletestframework@googlegroups.com (patches for fixing them are\n// even more welcome!).\n//\n// It is possible that none of the GTEST_OS_* macros are defined.\n\n// Feature-indicating macros\n// -------------------------\n//\n// Macros indicating which Google Test features are available (a macro\n// is defined to 1 if the corresponding feature is supported;\n// otherwise UNDEFINED -- it's never defined to 0.).  Google Test\n// defines these macros automatically.  Code outside Google Test MUST\n// NOT define them.\n//\n// These macros are public so that portable tests can be written.\n// Such tests typically surround code using a feature with an #if\n// which controls that code.  For example:\n//\n// #if GTEST_HAS_DEATH_TEST\n//   EXPECT_DEATH(DoSomethingDeadly());\n// #endif\n//\n//   GTEST_HAS_COMBINE      - the Combine() function (for value-parameterized\n//                            tests)\n//   GTEST_HAS_DEATH_TEST   - death tests\n//   GTEST_HAS_PARAM_TEST   - value-parameterized tests\n//   GTEST_HAS_TYPED_TEST   - typed tests\n//   GTEST_HAS_TYPED_TEST_P - type-parameterized tests\n//   GTEST_IS_THREADSAFE    - Google Test is thread-safe.\n//   GTEST_USES_POSIX_RE    - enhanced POSIX regex is used. Do not confuse with\n//                            GTEST_HAS_POSIX_RE (see above) which users can\n//                            define themselves.\n//   GTEST_USES_SIMPLE_RE   - our own simple regex is used;\n//                            the above two are mutually exclusive.\n//   GTEST_CAN_COMPARE_NULL - accepts untyped NULL in EXPECT_EQ().\n\n// Misc public macros\n// ------------------\n//\n//   GTEST_FLAG(flag_name)  - references the variable corresponding to\n//                            the given Google Test flag.\n\n// Internal utilities\n// ------------------\n//\n// The following macros and utilities are for Google Test's INTERNAL\n// use only.  Code outside Google Test MUST NOT USE THEM DIRECTLY.\n//\n// Macros for basic C++ coding:\n//   GTEST_AMBIGUOUS_ELSE_BLOCKER_ - for disabling a gcc warning.\n//   GTEST_ATTRIBUTE_UNUSED_  - declares that a class' instances or a\n//                              variable don't have to be used.\n//   GTEST_DISALLOW_ASSIGN_   - disables operator=.\n//   GTEST_DISALLOW_COPY_AND_ASSIGN_ - disables copy ctor and operator=.\n//   GTEST_MUST_USE_RESULT_   - declares that a function's result must be used.\n//   GTEST_INTENTIONAL_CONST_COND_PUSH_ - start code section where MSVC C4127 is\n//                                        suppressed (constant conditional).\n//   GTEST_INTENTIONAL_CONST_COND_POP_  - finish code section where MSVC C4127\n//                                        is suppressed.\n//\n// C++11 feature wrappers:\n//\n//   testing::internal::move  - portability wrapper for std::move.\n//\n// Synchronization:\n//   Mutex, MutexLock, ThreadLocal, GetThreadCount()\n//                            - synchronization primitives.\n//\n// Template meta programming:\n//   is_pointer     - as in TR1; needed on Symbian and IBM XL C/C++ only.\n//   IteratorTraits - partial implementation of std::iterator_traits, which\n//                    is not available in libCstd when compiled with Sun C++.\n//\n// Smart pointers:\n//   scoped_ptr     - as in TR2.\n//\n// Regular expressions:\n//   RE             - a simple regular expression class using the POSIX\n//                    Extended Regular Expression syntax on UNIX-like\n//                    platforms, or a reduced regular exception syntax on\n//                    other platforms, including Windows.\n//\n// Logging:\n//   GTEST_LOG_()   - logs messages at the specified severity level.\n//   LogToStderr()  - directs all log messages to stderr.\n//   FlushInfoLog() - flushes informational log messages.\n//\n// Stdout and stderr capturing:\n//   CaptureStdout()     - starts capturing stdout.\n//   GetCapturedStdout() - stops capturing stdout and returns the captured\n//                         string.\n//   CaptureStderr()     - starts capturing stderr.\n//   GetCapturedStderr() - stops capturing stderr and returns the captured\n//                         string.\n//\n// Integer types:\n//   TypeWithSize   - maps an integer to a int type.\n//   Int32, UInt32, Int64, UInt64, TimeInMillis\n//                  - integers of known sizes.\n//   BiggestInt     - the biggest signed integer type.\n//\n// Command-line utilities:\n//   GTEST_DECLARE_*()  - declares a flag.\n//   GTEST_DEFINE_*()   - defines a flag.\n//   GetInjectableArgvs() - returns the command line as a vector of strings.\n//\n// Environment variable utilities:\n//   GetEnv()             - gets the value of an environment variable.\n//   BoolFromGTestEnv()   - parses a bool environment variable.\n//   Int32FromGTestEnv()  - parses an Int32 environment variable.\n//   StringFromGTestEnv() - parses a string environment variable.\n\n#include <ctype.h>   // for isspace, etc\n#include <stddef.h>  // for ptrdiff_t\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#ifndef _WIN32_WCE\n# include <sys/types.h>\n# include <sys/stat.h>\n#endif  // !_WIN32_WCE\n\n#if defined __APPLE__\n# include <AvailabilityMacros.h>\n# include <TargetConditionals.h>\n#endif\n\n#include <algorithm>  // NOLINT\n#include <iostream>  // NOLINT\n#include <sstream>  // NOLINT\n#include <string>  // NOLINT\n#include <utility>\n#include <vector>  // NOLINT\n\n#include \"gtest/internal/gtest-port-arch.h\"\n#include \"gtest/internal/custom/gtest-port.h\"\n\n#if !defined(GTEST_DEV_EMAIL_)\n# define GTEST_DEV_EMAIL_ \"googletestframework@@googlegroups.com\"\n# define GTEST_FLAG_PREFIX_ \"gtest_\"\n# define GTEST_FLAG_PREFIX_DASH_ \"gtest-\"\n# define GTEST_FLAG_PREFIX_UPPER_ \"GTEST_\"\n# define GTEST_NAME_ \"Google Test\"\n# define GTEST_PROJECT_URL_ \"https://github.com/google/googletest/\"\n#endif  // !defined(GTEST_DEV_EMAIL_)\n\n#if !defined(GTEST_INIT_GOOGLE_TEST_NAME_)\n# define GTEST_INIT_GOOGLE_TEST_NAME_ \"testing::InitGoogleTest\"\n#endif  // !defined(GTEST_INIT_GOOGLE_TEST_NAME_)\n\n// Determines the version of gcc that is used to compile this.\n#ifdef __GNUC__\n// 40302 means version 4.3.2.\n# define GTEST_GCC_VER_ \\\n    (__GNUC__*10000 + __GNUC_MINOR__*100 + __GNUC_PATCHLEVEL__)\n#endif  // __GNUC__\n\n// Macros for disabling Microsoft Visual C++ warnings.\n//\n//   GTEST_DISABLE_MSC_WARNINGS_PUSH_(4800 4385)\n//   /* code that triggers warnings C4800 and C4385 */\n//   GTEST_DISABLE_MSC_WARNINGS_POP_()\n#if _MSC_VER >= 1500\n# define GTEST_DISABLE_MSC_WARNINGS_PUSH_(warnings) \\\n    __pragma(warning(push))                        \\\n    __pragma(warning(disable: warnings))\n# define GTEST_DISABLE_MSC_WARNINGS_POP_()          \\\n    __pragma(warning(pop))\n#else\n// Older versions of MSVC don't have __pragma.\n# define GTEST_DISABLE_MSC_WARNINGS_PUSH_(warnings)\n# define GTEST_DISABLE_MSC_WARNINGS_POP_()\n#endif\n\n#ifndef GTEST_LANG_CXX11\n// gcc and clang define __GXX_EXPERIMENTAL_CXX0X__ when\n// -std={c,gnu}++{0x,11} is passed.  The C++11 standard specifies a\n// value for __cplusplus, and recent versions of clang, gcc, and\n// probably other compilers set that too in C++11 mode.\n# if __GXX_EXPERIMENTAL_CXX0X__ || __cplusplus >= 201103L\n// Compiling in at least C++11 mode.\n#  define GTEST_LANG_CXX11 1\n# else\n#  define GTEST_LANG_CXX11 0\n# endif\n#endif\n\n// Distinct from C++11 language support, some environments don't provide\n// proper C++11 library support. Notably, it's possible to build in\n// C++11 mode when targeting Mac OS X 10.6, which has an old libstdc++\n// with no C++11 support.\n//\n// libstdc++ has sufficient C++11 support as of GCC 4.6.0, __GLIBCXX__\n// 20110325, but maintenance releases in the 4.4 and 4.5 series followed\n// this date, so check for those versions by their date stamps.\n// https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html#abi.versioning\n#if GTEST_LANG_CXX11 && \\\n    (!defined(__GLIBCXX__) || ( \\\n        __GLIBCXX__ >= 20110325ul &&  /* GCC >= 4.6.0 */ \\\n        /* Exclude patch releases of older branches: */ \\\n        __GLIBCXX__ != 20110416ul &&  /* GCC 4.4.6 */ \\\n        __GLIBCXX__ != 20120313ul &&  /* GCC 4.4.7 */ \\\n        __GLIBCXX__ != 20110428ul &&  /* GCC 4.5.3 */ \\\n        __GLIBCXX__ != 20120702ul))   /* GCC 4.5.4 */\n# define GTEST_STDLIB_CXX11 1\n#endif\n\n// Only use C++11 library features if the library provides them.\n#if GTEST_STDLIB_CXX11\n# define GTEST_HAS_STD_BEGIN_AND_END_ 1\n# define GTEST_HAS_STD_FORWARD_LIST_ 1\n# define GTEST_HAS_STD_FUNCTION_ 1\n# define GTEST_HAS_STD_INITIALIZER_LIST_ 1\n# define GTEST_HAS_STD_MOVE_ 1\n# define GTEST_HAS_STD_SHARED_PTR_ 1\n# define GTEST_HAS_STD_TYPE_TRAITS_ 1\n# define GTEST_HAS_STD_UNIQUE_PTR_ 1\n#endif\n\n// C++11 specifies that <tuple> provides std::tuple.\n// Some platforms still might not have it, however.\n#if GTEST_LANG_CXX11\n# define GTEST_HAS_STD_TUPLE_ 1\n# if defined(__clang__)\n// Inspired by http://clang.llvm.org/docs/LanguageExtensions.html#__has_include\n#  if defined(__has_include) && !__has_include(<tuple>)\n#   undef GTEST_HAS_STD_TUPLE_\n#  endif\n# elif defined(_MSC_VER)\n// Inspired by boost/config/stdlib/dinkumware.hpp\n#  if defined(_CPPLIB_VER) && _CPPLIB_VER < 520\n#   undef GTEST_HAS_STD_TUPLE_\n#  endif\n# elif defined(__GLIBCXX__)\n// Inspired by boost/config/stdlib/libstdcpp3.hpp,\n// http://gcc.gnu.org/gcc-4.2/changes.html and\n// http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt01ch01.html#manual.intro.status.standard.200x\n#  if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 2)\n#   undef GTEST_HAS_STD_TUPLE_\n#  endif\n# endif\n#endif\n\n// Brings in definitions for functions used in the testing::internal::posix\n// namespace (read, write, close, chdir, isatty, stat). We do not currently\n// use them on Windows Mobile.\n#if GTEST_OS_WINDOWS\n# if !GTEST_OS_WINDOWS_MOBILE\n#  include <direct.h>\n#  include <io.h>\n# endif\n// In order to avoid having to include <windows.h>, use forward declaration\n// assuming CRITICAL_SECTION is a typedef of _RTL_CRITICAL_SECTION.\n// This assumption is verified by\n// WindowsTypesTest.CRITICAL_SECTIONIs_RTL_CRITICAL_SECTION.\nstruct _RTL_CRITICAL_SECTION;\n#else\n// This assumes that non-Windows OSes provide unistd.h. For OSes where this\n// is not the case, we need to include headers that provide the functions\n// mentioned above.\n# include <unistd.h>\n# include <strings.h>\n#endif  // GTEST_OS_WINDOWS\n\n#if GTEST_OS_LINUX_ANDROID\n// Used to define __ANDROID_API__ matching the target NDK API level.\n#  include <android/api-level.h>  // NOLINT\n#endif\n\n// Defines this to true iff Google Test can use POSIX regular expressions.\n#ifndef GTEST_HAS_POSIX_RE\n# if GTEST_OS_LINUX_ANDROID\n// On Android, <regex.h> is only available starting with Gingerbread.\n#  define GTEST_HAS_POSIX_RE (__ANDROID_API__ >= 9)\n# else\n#  define GTEST_HAS_POSIX_RE (!GTEST_OS_WINDOWS)\n# endif\n#endif\n\n#if GTEST_USES_PCRE\n// The appropriate headers have already been included.\n\n#elif GTEST_HAS_POSIX_RE\n\n// On some platforms, <regex.h> needs someone to define size_t, and\n// won't compile otherwise.  We can #include it here as we already\n// included <stdlib.h>, which is guaranteed to define size_t through\n// <stddef.h>.\n# include <regex.h>  // NOLINT\n\n# define GTEST_USES_POSIX_RE 1\n\n#elif GTEST_OS_WINDOWS\n\n// <regex.h> is not available on Windows.  Use our own simple regex\n// implementation instead.\n# define GTEST_USES_SIMPLE_RE 1\n\n#else\n\n// <regex.h> may not be available on this platform.  Use our own\n// simple regex implementation instead.\n# define GTEST_USES_SIMPLE_RE 1\n\n#endif  // GTEST_USES_PCRE\n\n#ifndef GTEST_HAS_EXCEPTIONS\n// The user didn't tell us whether exceptions are enabled, so we need\n// to figure it out.\n# if defined(_MSC_VER) || defined(__BORLANDC__)\n// MSVC's and C++Builder's implementations of the STL use the _HAS_EXCEPTIONS\n// macro to enable exceptions, so we'll do the same.\n// Assumes that exceptions are enabled by default.\n#  ifndef _HAS_EXCEPTIONS\n#   define _HAS_EXCEPTIONS 1\n#  endif  // _HAS_EXCEPTIONS\n#  define GTEST_HAS_EXCEPTIONS _HAS_EXCEPTIONS\n# elif defined(__clang__)\n// clang defines __EXCEPTIONS iff exceptions are enabled before clang 220714,\n// but iff cleanups are enabled after that. In Obj-C++ files, there can be\n// cleanups for ObjC exceptions which also need cleanups, even if C++ exceptions\n// are disabled. clang has __has_feature(cxx_exceptions) which checks for C++\n// exceptions starting at clang r206352, but which checked for cleanups prior to\n// that. To reliably check for C++ exception availability with clang, check for\n// __EXCEPTIONS && __has_feature(cxx_exceptions).\n#  define GTEST_HAS_EXCEPTIONS (__EXCEPTIONS && __has_feature(cxx_exceptions))\n# elif defined(__GNUC__) && __EXCEPTIONS\n// gcc defines __EXCEPTIONS to 1 iff exceptions are enabled.\n#  define GTEST_HAS_EXCEPTIONS 1\n# elif defined(__SUNPRO_CC)\n// Sun Pro CC supports exceptions.  However, there is no compile-time way of\n// detecting whether they are enabled or not.  Therefore, we assume that\n// they are enabled unless the user tells us otherwise.\n#  define GTEST_HAS_EXCEPTIONS 1\n# elif defined(__IBMCPP__) && __EXCEPTIONS\n// xlC defines __EXCEPTIONS to 1 iff exceptions are enabled.\n#  define GTEST_HAS_EXCEPTIONS 1\n# elif defined(__HP_aCC)\n// Exception handling is in effect by default in HP aCC compiler. It has to\n// be turned of by +noeh compiler option if desired.\n#  define GTEST_HAS_EXCEPTIONS 1\n# else\n// For other compilers, we assume exceptions are disabled to be\n// conservative.\n#  define GTEST_HAS_EXCEPTIONS 0\n# endif  // defined(_MSC_VER) || defined(__BORLANDC__)\n#endif  // GTEST_HAS_EXCEPTIONS\n\n#if !defined(GTEST_HAS_STD_STRING)\n// Even though we don't use this macro any longer, we keep it in case\n// some clients still depend on it.\n# define GTEST_HAS_STD_STRING 1\n#elif !GTEST_HAS_STD_STRING\n// The user told us that ::std::string isn't available.\n# error \"Google Test cannot be used where ::std::string isn't available.\"\n#endif  // !defined(GTEST_HAS_STD_STRING)\n\n#ifndef GTEST_HAS_GLOBAL_STRING\n// The user didn't tell us whether ::string is available, so we need\n// to figure it out.\n\n# define GTEST_HAS_GLOBAL_STRING 0\n\n#endif  // GTEST_HAS_GLOBAL_STRING\n\n#ifndef GTEST_HAS_STD_WSTRING\n// The user didn't tell us whether ::std::wstring is available, so we need\n// to figure it out.\n// TODO(wan@google.com): uses autoconf to detect whether ::std::wstring\n//   is available.\n\n// Cygwin 1.7 and below doesn't support ::std::wstring.\n// Solaris' libc++ doesn't support it either.  Android has\n// no support for it at least as recent as Froyo (2.2).\n// Minix currently doesn't support it either.\n# define GTEST_HAS_STD_WSTRING \\\n    (!(GTEST_OS_LINUX_ANDROID || GTEST_OS_CYGWIN || GTEST_OS_SOLARIS || GTEST_OS_HAIKU || GTEST_OS_MINIX))\n\n#endif  // GTEST_HAS_STD_WSTRING\n\n#ifndef GTEST_HAS_GLOBAL_WSTRING\n// The user didn't tell us whether ::wstring is available, so we need\n// to figure it out.\n# define GTEST_HAS_GLOBAL_WSTRING \\\n    (GTEST_HAS_STD_WSTRING && GTEST_HAS_GLOBAL_STRING)\n#endif  // GTEST_HAS_GLOBAL_WSTRING\n\n// Determines whether RTTI is available.\n#ifndef GTEST_HAS_RTTI\n// The user didn't tell us whether RTTI is enabled, so we need to\n// figure it out.\n\n# ifdef _MSC_VER\n\n#  ifdef _CPPRTTI  // MSVC defines this macro iff RTTI is enabled.\n#   define GTEST_HAS_RTTI 1\n#  else\n#   define GTEST_HAS_RTTI 0\n#  endif\n\n// Starting with version 4.3.2, gcc defines __GXX_RTTI iff RTTI is enabled.\n# elif defined(__GNUC__) && (GTEST_GCC_VER_ >= 40302)\n\n#  ifdef __GXX_RTTI\n// When building against STLport with the Android NDK and with\n// -frtti -fno-exceptions, the build fails at link time with undefined\n// references to __cxa_bad_typeid. Note sure if STL or toolchain bug,\n// so disable RTTI when detected.\n#   if GTEST_OS_LINUX_ANDROID && defined(_STLPORT_MAJOR) && \\\n       !defined(__EXCEPTIONS)\n#    define GTEST_HAS_RTTI 0\n#   else\n#    define GTEST_HAS_RTTI 1\n#   endif  // GTEST_OS_LINUX_ANDROID && __STLPORT_MAJOR && !__EXCEPTIONS\n#  else\n#   define GTEST_HAS_RTTI 0\n#  endif  // __GXX_RTTI\n\n// Clang defines __GXX_RTTI starting with version 3.0, but its manual recommends\n// using has_feature instead. has_feature(cxx_rtti) is supported since 2.7, the\n// first version with C++ support.\n# elif defined(__clang__)\n\n#  define GTEST_HAS_RTTI __has_feature(cxx_rtti)\n\n// Starting with version 9.0 IBM Visual Age defines __RTTI_ALL__ to 1 if\n// both the typeid and dynamic_cast features are present.\n# elif defined(__IBMCPP__) && (__IBMCPP__ >= 900)\n\n#  ifdef __RTTI_ALL__\n#   define GTEST_HAS_RTTI 1\n#  else\n#   define GTEST_HAS_RTTI 0\n#  endif\n\n# else\n\n// For all other compilers, we assume RTTI is enabled.\n#  define GTEST_HAS_RTTI 1\n\n# endif  // _MSC_VER\n\n#endif  // GTEST_HAS_RTTI\n\n// It's this header's responsibility to #include <typeinfo> when RTTI\n// is enabled.\n#if GTEST_HAS_RTTI\n# include <typeinfo>\n#endif\n\n// Determines whether Google Test can use the pthreads library.\n#ifndef GTEST_HAS_PTHREAD\n// The user didn't tell us explicitly, so we make reasonable assumptions about\n// which platforms have pthreads support.\n//\n// To disable threading support in Google Test, add -DGTEST_HAS_PTHREAD=0\n// to your compiler flags.\n# define GTEST_HAS_PTHREAD (GTEST_OS_LINUX || GTEST_OS_MAC || GTEST_OS_HPUX \\\n    || GTEST_OS_QNX || GTEST_OS_FREEBSD || GTEST_OS_NACL)\n#endif  // GTEST_HAS_PTHREAD\n\n#if GTEST_HAS_PTHREAD\n// gtest-port.h guarantees to #include <pthread.h> when GTEST_HAS_PTHREAD is\n// true.\n# include <pthread.h>  // NOLINT\n\n// For timespec and nanosleep, used below.\n# include <time.h>  // NOLINT\n#endif\n\n// Determines if hash_map/hash_set are available.\n// Only used for testing against those containers.\n#if !defined(GTEST_HAS_HASH_MAP_)\n# if _MSC_VER\n#  define GTEST_HAS_HASH_MAP_ 1  // Indicates that hash_map is available.\n#  define GTEST_HAS_HASH_SET_ 1  // Indicates that hash_set is available.\n# endif  // _MSC_VER\n#endif  // !defined(GTEST_HAS_HASH_MAP_)\n\n// Determines whether Google Test can use tr1/tuple.  You can define\n// this macro to 0 to prevent Google Test from using tuple (any\n// feature depending on tuple with be disabled in this mode).\n#ifndef GTEST_HAS_TR1_TUPLE\n# if GTEST_OS_LINUX_ANDROID && defined(_STLPORT_MAJOR)\n// STLport, provided with the Android NDK, has neither <tr1/tuple> or <tuple>.\n#  define GTEST_HAS_TR1_TUPLE 0\n# else\n// The user didn't tell us not to do it, so we assume it's OK.\n#  define GTEST_HAS_TR1_TUPLE 1\n# endif\n#endif  // GTEST_HAS_TR1_TUPLE\n\n// Determines whether Google Test's own tr1 tuple implementation\n// should be used.\n#ifndef GTEST_USE_OWN_TR1_TUPLE\n// The user didn't tell us, so we need to figure it out.\n\n// We use our own TR1 tuple if we aren't sure the user has an\n// implementation of it already.  At this time, libstdc++ 4.0.0+ and\n// MSVC 2010 are the only mainstream standard libraries that come\n// with a TR1 tuple implementation.  NVIDIA's CUDA NVCC compiler\n// pretends to be GCC by defining __GNUC__ and friends, but cannot\n// compile GCC's tuple implementation.  MSVC 2008 (9.0) provides TR1\n// tuple in a 323 MB Feature Pack download, which we cannot assume the\n// user has.  QNX's QCC compiler is a modified GCC but it doesn't\n// support TR1 tuple.  libc++ only provides std::tuple, in C++11 mode,\n// and it can be used with some compilers that define __GNUC__.\n# if (defined(__GNUC__) && !defined(__CUDACC__) && (GTEST_GCC_VER_ >= 40000) \\\n      && !GTEST_OS_QNX && !defined(_LIBCPP_VERSION)) || _MSC_VER >= 1600\n#  define GTEST_ENV_HAS_TR1_TUPLE_ 1\n# endif\n\n// C++11 specifies that <tuple> provides std::tuple. Use that if gtest is used\n// in C++11 mode and libstdc++ isn't very old (binaries targeting OS X 10.6\n// can build with clang but need to use gcc4.2's libstdc++).\n# if GTEST_LANG_CXX11 && (!defined(__GLIBCXX__) || __GLIBCXX__ > 20110325)\n#  define GTEST_ENV_HAS_STD_TUPLE_ 1\n# endif\n\n# if GTEST_ENV_HAS_TR1_TUPLE_ || GTEST_ENV_HAS_STD_TUPLE_\n#  define GTEST_USE_OWN_TR1_TUPLE 0\n# else\n#  define GTEST_USE_OWN_TR1_TUPLE 1\n# endif\n\n#endif  // GTEST_USE_OWN_TR1_TUPLE\n\n// To avoid conditional compilation everywhere, we make it\n// gtest-port.h's responsibility to #include the header implementing\n// tuple.\n#if GTEST_HAS_STD_TUPLE_\n# include <tuple>  // IWYU pragma: export\n# define GTEST_TUPLE_NAMESPACE_ ::std\n#endif  // GTEST_HAS_STD_TUPLE_\n\n// We include tr1::tuple even if std::tuple is available to define printers for\n// them.\n#if GTEST_HAS_TR1_TUPLE\n# ifndef GTEST_TUPLE_NAMESPACE_\n#  define GTEST_TUPLE_NAMESPACE_ ::std::tr1\n# endif  // GTEST_TUPLE_NAMESPACE_\n\n# if GTEST_USE_OWN_TR1_TUPLE\n#  include \"gtest/internal/gtest-tuple.h\"  // IWYU pragma: export  // NOLINT\n# elif GTEST_ENV_HAS_STD_TUPLE_\n#  include <tuple>\n// C++11 puts its tuple into the ::std namespace rather than\n// ::std::tr1.  gtest expects tuple to live in ::std::tr1, so put it there.\n// This causes undefined behavior, but supported compilers react in\n// the way we intend.\nnamespace std {\nnamespace tr1 {\nusing ::std::get;\nusing ::std::make_tuple;\nusing ::std::tuple;\nusing ::std::tuple_element;\nusing ::std::tuple_size;\n}\n}\n\n# elif GTEST_OS_SYMBIAN\n\n// On Symbian, BOOST_HAS_TR1_TUPLE causes Boost's TR1 tuple library to\n// use STLport's tuple implementation, which unfortunately doesn't\n// work as the copy of STLport distributed with Symbian is incomplete.\n// By making sure BOOST_HAS_TR1_TUPLE is undefined, we force Boost to\n// use its own tuple implementation.\n#  ifdef BOOST_HAS_TR1_TUPLE\n#   undef BOOST_HAS_TR1_TUPLE\n#  endif  // BOOST_HAS_TR1_TUPLE\n\n// This prevents <boost/tr1/detail/config.hpp>, which defines\n// BOOST_HAS_TR1_TUPLE, from being #included by Boost's <tuple>.\n#  define BOOST_TR1_DETAIL_CONFIG_HPP_INCLUDED\n#  include <tuple>  // IWYU pragma: export  // NOLINT\n\n# elif defined(__GNUC__) && (GTEST_GCC_VER_ >= 40000)\n// GCC 4.0+ implements tr1/tuple in the <tr1/tuple> header.  This does\n// not conform to the TR1 spec, which requires the header to be <tuple>.\n\n#  if !GTEST_HAS_RTTI && GTEST_GCC_VER_ < 40302\n// Until version 4.3.2, gcc has a bug that causes <tr1/functional>,\n// which is #included by <tr1/tuple>, to not compile when RTTI is\n// disabled.  _TR1_FUNCTIONAL is the header guard for\n// <tr1/functional>.  Hence the following #define is a hack to prevent\n// <tr1/functional> from being included.\n#   define _TR1_FUNCTIONAL 1\n#   include <tr1/tuple>\n#   undef _TR1_FUNCTIONAL  // Allows the user to #include\n                        // <tr1/functional> if he chooses to.\n#  else\n#   include <tr1/tuple>  // NOLINT\n#  endif  // !GTEST_HAS_RTTI && GTEST_GCC_VER_ < 40302\n\n# else\n// If the compiler is not GCC 4.0+, we assume the user is using a\n// spec-conforming TR1 implementation.\n#  include <tuple>  // IWYU pragma: export  // NOLINT\n# endif  // GTEST_USE_OWN_TR1_TUPLE\n\n#endif  // GTEST_HAS_TR1_TUPLE\n\n// Determines whether clone(2) is supported.\n// Usually it will only be available on Linux, excluding\n// Linux on the Itanium architecture.\n// Also see http://linux.die.net/man/2/clone.\n#ifndef GTEST_HAS_CLONE\n// The user didn't tell us, so we need to figure it out.\n\n# if GTEST_OS_LINUX && !defined(__ia64__)\n#  if GTEST_OS_LINUX_ANDROID\n// On Android, clone() is only available on ARM starting with Gingerbread.\n#    if defined(__arm__) && __ANDROID_API__ >= 9\n#     define GTEST_HAS_CLONE 1\n#    else\n#     define GTEST_HAS_CLONE 0\n#    endif\n#  else\n#   define GTEST_HAS_CLONE 1\n#  endif\n# else\n#  define GTEST_HAS_CLONE 0\n# endif  // GTEST_OS_LINUX && !defined(__ia64__)\n\n#endif  // GTEST_HAS_CLONE\n\n// Determines whether to support stream redirection. This is used to test\n// output correctness and to implement death tests.\n#ifndef GTEST_HAS_STREAM_REDIRECTION\n// By default, we assume that stream redirection is supported on all\n// platforms except known mobile ones.\n# if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_SYMBIAN || \\\n    GTEST_OS_WINDOWS_PHONE || GTEST_OS_WINDOWS_RT\n#  define GTEST_HAS_STREAM_REDIRECTION 0\n# else\n#  define GTEST_HAS_STREAM_REDIRECTION 1\n# endif  // !GTEST_OS_WINDOWS_MOBILE && !GTEST_OS_SYMBIAN\n#endif  // GTEST_HAS_STREAM_REDIRECTION\n\n// Determines whether to support death tests.\n// Google Test does not support death tests for VC 7.1 and earlier as\n// abort() in a VC 7.1 application compiled as GUI in debug config\n// pops up a dialog window that cannot be suppressed programmatically.\n#if (GTEST_OS_LINUX || GTEST_OS_CYGWIN || GTEST_OS_SOLARIS || \\\n     (GTEST_OS_MAC && !GTEST_OS_IOS) || \\\n     (GTEST_OS_WINDOWS_DESKTOP && _MSC_VER >= 1400) || \\\n     GTEST_OS_WINDOWS_MINGW || GTEST_OS_AIX || GTEST_OS_HPUX || \\\n     GTEST_OS_OPENBSD || GTEST_OS_QNX || GTEST_OS_FREEBSD || GTEST_OS_NETBSD)\n# define GTEST_HAS_DEATH_TEST 1\n#endif\n\n// We don't support MSVC 7.1 with exceptions disabled now.  Therefore\n// all the compilers we care about are adequate for supporting\n// value-parameterized tests.\n#define GTEST_HAS_PARAM_TEST 1\n\n// Determines whether to support type-driven tests.\n\n// Typed tests need <typeinfo> and variadic macros, which GCC, VC++ 8.0,\n// Sun Pro CC, IBM Visual Age, and HP aCC support.\n#if defined(__GNUC__) || (_MSC_VER >= 1400) || defined(__SUNPRO_CC) || \\\n    defined(__IBMCPP__) || defined(__HP_aCC)\n# define GTEST_HAS_TYPED_TEST 1\n# define GTEST_HAS_TYPED_TEST_P 1\n#endif\n\n// Determines whether to support Combine(). This only makes sense when\n// value-parameterized tests are enabled.  The implementation doesn't\n// work on Sun Studio since it doesn't understand templated conversion\n// operators.\n#if GTEST_HAS_PARAM_TEST && GTEST_HAS_TR1_TUPLE && !defined(__SUNPRO_CC)\n# define GTEST_HAS_COMBINE 1\n#endif\n\n// Determines whether the system compiler uses UTF-16 for encoding wide strings.\n#define GTEST_WIDE_STRING_USES_UTF16_ \\\n    (GTEST_OS_WINDOWS || GTEST_OS_CYGWIN || GTEST_OS_SYMBIAN || GTEST_OS_AIX)\n\n// Determines whether test results can be streamed to a socket.\n#if GTEST_OS_LINUX\n# define GTEST_CAN_STREAM_RESULTS_ 1\n#endif\n\n// Defines some utility macros.\n\n// The GNU compiler emits a warning if nested \"if\" statements are followed by\n// an \"else\" statement and braces are not used to explicitly disambiguate the\n// \"else\" binding.  This leads to problems with code like:\n//\n//   if (gate)\n//     ASSERT_*(condition) << \"Some message\";\n//\n// The \"switch (0) case 0:\" idiom is used to suppress this.\n#ifdef __INTEL_COMPILER\n# define GTEST_AMBIGUOUS_ELSE_BLOCKER_\n#else\n# define GTEST_AMBIGUOUS_ELSE_BLOCKER_ switch (0) case 0: default:  // NOLINT\n#endif\n\n// Use this annotation at the end of a struct/class definition to\n// prevent the compiler from optimizing away instances that are never\n// used.  This is useful when all interesting logic happens inside the\n// c'tor and / or d'tor.  Example:\n//\n//   struct Foo {\n//     Foo() { ... }\n//   } GTEST_ATTRIBUTE_UNUSED_;\n//\n// Also use it after a variable or parameter declaration to tell the\n// compiler the variable/parameter does not have to be used.\n#if defined(__GNUC__) && !defined(COMPILER_ICC)\n# define GTEST_ATTRIBUTE_UNUSED_ __attribute__ ((unused))\n#elif defined(__clang__)\n# if __has_attribute(unused)\n#  define GTEST_ATTRIBUTE_UNUSED_ __attribute__ ((unused))\n# endif\n#endif\n#ifndef GTEST_ATTRIBUTE_UNUSED_\n# define GTEST_ATTRIBUTE_UNUSED_\n#endif\n\n// A macro to disallow operator=\n// This should be used in the private: declarations for a class.\n#define GTEST_DISALLOW_ASSIGN_(type)\\\n  void operator=(type const &) = delete\n\n// A macro to disallow copy constructor and operator=\n// This should be used in the private: declarations for a class.\n#define GTEST_DISALLOW_COPY_AND_ASSIGN_(type)\\\n  type(type const &) = delete;\\\n  GTEST_DISALLOW_ASSIGN_(type)\n\n// Tell the compiler to warn about unused return values for functions declared\n// with this macro.  The macro should be used on function declarations\n// following the argument list:\n//\n//   Sprocket* AllocateSprocket() GTEST_MUST_USE_RESULT_;\n#if defined(__GNUC__) && (GTEST_GCC_VER_ >= 30400) && !defined(COMPILER_ICC)\n# define GTEST_MUST_USE_RESULT_ __attribute__ ((warn_unused_result))\n#else\n# define GTEST_MUST_USE_RESULT_\n#endif  // __GNUC__ && (GTEST_GCC_VER_ >= 30400) && !COMPILER_ICC\n\n// MS C++ compiler emits warning when a conditional expression is compile time\n// constant. In some contexts this warning is false positive and needs to be\n// suppressed. Use the following two macros in such cases:\n//\n// GTEST_INTENTIONAL_CONST_COND_PUSH_()\n// while (true) {\n// GTEST_INTENTIONAL_CONST_COND_POP_()\n// }\n# define GTEST_INTENTIONAL_CONST_COND_PUSH_() \\\n    GTEST_DISABLE_MSC_WARNINGS_PUSH_(4127)\n# define GTEST_INTENTIONAL_CONST_COND_POP_() \\\n    GTEST_DISABLE_MSC_WARNINGS_POP_()\n\n// Determine whether the compiler supports Microsoft's Structured Exception\n// Handling.  This is supported by several Windows compilers but generally\n// does not exist on any other system.\n#ifndef GTEST_HAS_SEH\n// The user didn't tell us, so we need to figure it out.\n\n# if defined(_MSC_VER) || defined(__BORLANDC__)\n// These two compilers are known to support SEH.\n#  define GTEST_HAS_SEH 1\n# else\n// Assume no SEH.\n#  define GTEST_HAS_SEH 0\n# endif\n\n#endif  // GTEST_HAS_SEH\n\n#define GTEST_IS_THREADSAFE \\\n    (GTEST_HAS_MUTEX_AND_THREAD_LOCAL_ \\\n     || (GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT) \\\n     || GTEST_HAS_PTHREAD)\n\n#ifdef _MSC_VER\n# if GTEST_LINKED_AS_SHARED_LIBRARY\n#  define GTEST_API_ __declspec(dllimport)\n# elif GTEST_CREATE_SHARED_LIBRARY\n#  define GTEST_API_ __declspec(dllexport)\n# endif\n#elif __GNUC__ >= 4 || defined(__clang__)\n# define GTEST_API_ __attribute__((visibility (\"default\")))\n#endif // _MSC_VER\n\n#ifndef GTEST_API_\n# define GTEST_API_\n#endif\n\n#ifdef __GNUC__\n// Ask the compiler to never inline a given function.\n# define GTEST_NO_INLINE_ __attribute__((noinline))\n#else\n# define GTEST_NO_INLINE_\n#endif\n\n// _LIBCPP_VERSION is defined by the libc++ library from the LLVM project.\n#if defined(__has_include)\n# if __has_include(<cxxabi.h>)\n#  define GTEST_HAS_CXXABI_H_ 1\n# else\n#  define GTEST_HAS_CXXABI_H_ 0\n# endif\n#elif defined(__GLIBCXX__) || defined(_LIBCPP_VERSION)\n# define GTEST_HAS_CXXABI_H_ 1\n#else\n# define GTEST_HAS_CXXABI_H_ 0\n#endif\n\n// A function level attribute to disable checking for use of uninitialized\n// memory when built with MemorySanitizer.\n#if defined(__clang__)\n# if __has_feature(memory_sanitizer)\n#  define GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_ \\\n       __attribute__((no_sanitize_memory))\n# else\n#  define GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_\n# endif  // __has_feature(memory_sanitizer)\n#else\n# define GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_\n#endif  // __clang__\n\n// A function level attribute to disable AddressSanitizer instrumentation.\n#if defined(__clang__)\n# if __has_feature(address_sanitizer)\n#  define GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_ \\\n       __attribute__((no_sanitize_address))\n# else\n#  define GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_\n# endif  // __has_feature(address_sanitizer)\n#else\n# define GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_\n#endif  // __clang__\n\n// A function level attribute to disable ThreadSanitizer instrumentation.\n#if defined(__clang__)\n# if __has_feature(thread_sanitizer)\n#  define GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_ \\\n       __attribute__((no_sanitize_thread))\n# else\n#  define GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_\n# endif  // __has_feature(thread_sanitizer)\n#else\n# define GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_\n#endif  // __clang__\n\nnamespace testing {\n\nclass Message;\n\n#if defined(GTEST_TUPLE_NAMESPACE_)\n// Import tuple and friends into the ::testing namespace.\n// It is part of our interface, having them in ::testing allows us to change\n// their types as needed.\nusing GTEST_TUPLE_NAMESPACE_::get;\nusing GTEST_TUPLE_NAMESPACE_::make_tuple;\nusing GTEST_TUPLE_NAMESPACE_::tuple;\nusing GTEST_TUPLE_NAMESPACE_::tuple_size;\nusing GTEST_TUPLE_NAMESPACE_::tuple_element;\n#endif  // defined(GTEST_TUPLE_NAMESPACE_)\n\nnamespace internal {\n\n// A secret type that Google Test users don't know about.  It has no\n// definition on purpose.  Therefore it's impossible to create a\n// Secret object, which is what we want.\nclass Secret;\n\n// The GTEST_COMPILE_ASSERT_ macro can be used to verify that a compile time\n// expression is true. For example, you could use it to verify the\n// size of a static array:\n//\n//   GTEST_COMPILE_ASSERT_(GTEST_ARRAY_SIZE_(names) == NUM_NAMES,\n//                         names_incorrect_size);\n//\n// or to make sure a struct is smaller than a certain size:\n//\n//   GTEST_COMPILE_ASSERT_(sizeof(foo) < 128, foo_too_large);\n//\n// The second argument to the macro is the name of the variable. If\n// the expression is false, most compilers will issue a warning/error\n// containing the name of the variable.\n\n#if GTEST_LANG_CXX11\n# define GTEST_COMPILE_ASSERT_(expr, msg) static_assert(expr, #msg)\n#else  // !GTEST_LANG_CXX11\ntemplate <bool>\n  struct CompileAssert {\n};\n\n# define GTEST_COMPILE_ASSERT_(expr, msg) \\\n  typedef ::testing::internal::CompileAssert<(static_cast<bool>(expr))> \\\n      msg[static_cast<bool>(expr) ? 1 : -1] GTEST_ATTRIBUTE_UNUSED_\n#endif  // !GTEST_LANG_CXX11\n\n// Implementation details of GTEST_COMPILE_ASSERT_:\n//\n// (In C++11, we simply use static_assert instead of the following)\n//\n// - GTEST_COMPILE_ASSERT_ works by defining an array type that has -1\n//   elements (and thus is invalid) when the expression is false.\n//\n// - The simpler definition\n//\n//    #define GTEST_COMPILE_ASSERT_(expr, msg) typedef char msg[(expr) ? 1 : -1]\n//\n//   does not work, as gcc supports variable-length arrays whose sizes\n//   are determined at run-time (this is gcc's extension and not part\n//   of the C++ standard).  As a result, gcc fails to reject the\n//   following code with the simple definition:\n//\n//     int foo;\n//     GTEST_COMPILE_ASSERT_(foo, msg); // not supposed to compile as foo is\n//                                      // not a compile-time constant.\n//\n// - By using the type CompileAssert<(bool(expr))>, we ensures that\n//   expr is a compile-time constant.  (Template arguments must be\n//   determined at compile-time.)\n//\n// - The outter parentheses in CompileAssert<(bool(expr))> are necessary\n//   to work around a bug in gcc 3.4.4 and 4.0.1.  If we had written\n//\n//     CompileAssert<bool(expr)>\n//\n//   instead, these compilers will refuse to compile\n//\n//     GTEST_COMPILE_ASSERT_(5 > 0, some_message);\n//\n//   (They seem to think the \">\" in \"5 > 0\" marks the end of the\n//   template argument list.)\n//\n// - The array size is (bool(expr) ? 1 : -1), instead of simply\n//\n//     ((expr) ? 1 : -1).\n//\n//   This is to avoid running into a bug in MS VC 7.1, which\n//   causes ((0.0) ? 1 : -1) to incorrectly evaluate to 1.\n\n// StaticAssertTypeEqHelper is used by StaticAssertTypeEq defined in gtest.h.\n//\n// This template is declared, but intentionally undefined.\ntemplate <typename T1, typename T2>\nstruct StaticAssertTypeEqHelper;\n\ntemplate <typename T>\nstruct StaticAssertTypeEqHelper<T, T> {\n  enum { value = true };\n};\n\n// Evaluates to the number of elements in 'array'.\n#define GTEST_ARRAY_SIZE_(array) (sizeof(array) / sizeof(array[0]))\n\n#if GTEST_HAS_GLOBAL_STRING\ntypedef ::string string;\n#else\ntypedef ::std::string string;\n#endif  // GTEST_HAS_GLOBAL_STRING\n\n#if GTEST_HAS_GLOBAL_WSTRING\ntypedef ::wstring wstring;\n#elif GTEST_HAS_STD_WSTRING\ntypedef ::std::wstring wstring;\n#endif  // GTEST_HAS_GLOBAL_WSTRING\n\n// A helper for suppressing warnings on constant condition.  It just\n// returns 'condition'.\nGTEST_API_ bool IsTrue(bool condition);\n\n// Defines scoped_ptr.\n\n// This implementation of scoped_ptr is PARTIAL - it only contains\n// enough stuff to satisfy Google Test's need.\ntemplate <typename T>\nclass scoped_ptr {\n public:\n  typedef T element_type;\n\n  explicit scoped_ptr(T* p = NULL) : ptr_(p) {}\n  ~scoped_ptr() { reset(); }\n\n  T& operator*() const { return *ptr_; }\n  T* operator->() const { return ptr_; }\n  T* get() const { return ptr_; }\n\n  T* release() {\n    T* const ptr = ptr_;\n    ptr_ = NULL;\n    return ptr;\n  }\n\n  void reset(T* p = NULL) {\n    if (p != ptr_) {\n      if (IsTrue(sizeof(T) > 0)) {  // Makes sure T is a complete type.\n        delete ptr_;\n      }\n      ptr_ = p;\n    }\n  }\n\n  friend void swap(scoped_ptr& a, scoped_ptr& b) {\n    using std::swap;\n    swap(a.ptr_, b.ptr_);\n  }\n\n private:\n  T* ptr_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(scoped_ptr);\n};\n\n// Defines RE.\n\n// A simple C++ wrapper for <regex.h>.  It uses the POSIX Extended\n// Regular Expression syntax.\nclass GTEST_API_ RE {\n public:\n  // A copy constructor is required by the Standard to initialize object\n  // references from r-values.\n  RE(const RE& other) { Init(other.pattern()); }\n\n  // Constructs an RE from a string.\n  RE(const ::std::string& regex) { Init(regex.c_str()); }  // NOLINT\n\n#if GTEST_HAS_GLOBAL_STRING\n\n  RE(const ::string& regex) { Init(regex.c_str()); }  // NOLINT\n\n#endif  // GTEST_HAS_GLOBAL_STRING\n\n  RE(const char* regex) { Init(regex); }  // NOLINT\n  ~RE();\n\n  // Returns the string representation of the regex.\n  const char* pattern() const { return pattern_; }\n\n  // FullMatch(str, re) returns true iff regular expression re matches\n  // the entire str.\n  // PartialMatch(str, re) returns true iff regular expression re\n  // matches a substring of str (including str itself).\n  //\n  // TODO(wan@google.com): make FullMatch() and PartialMatch() work\n  // when str contains NUL characters.\n  static bool FullMatch(const ::std::string& str, const RE& re) {\n    return FullMatch(str.c_str(), re);\n  }\n  static bool PartialMatch(const ::std::string& str, const RE& re) {\n    return PartialMatch(str.c_str(), re);\n  }\n\n#if GTEST_HAS_GLOBAL_STRING\n\n  static bool FullMatch(const ::string& str, const RE& re) {\n    return FullMatch(str.c_str(), re);\n  }\n  static bool PartialMatch(const ::string& str, const RE& re) {\n    return PartialMatch(str.c_str(), re);\n  }\n\n#endif  // GTEST_HAS_GLOBAL_STRING\n\n  static bool FullMatch(const char* str, const RE& re);\n  static bool PartialMatch(const char* str, const RE& re);\n\n private:\n  void Init(const char* regex);\n\n  // We use a const char* instead of an std::string, as Google Test used to be\n  // used where std::string is not available.  TODO(wan@google.com): change to\n  // std::string.\n  const char* pattern_;\n  bool is_valid_;\n\n#if GTEST_USES_POSIX_RE\n\n  regex_t full_regex_;     // For FullMatch().\n  regex_t partial_regex_;  // For PartialMatch().\n\n#else  // GTEST_USES_SIMPLE_RE\n\n  const char* full_pattern_;  // For FullMatch();\n\n#endif\n\n  GTEST_DISALLOW_ASSIGN_(RE);\n};\n\n// Formats a source file path and a line number as they would appear\n// in an error message from the compiler used to compile this code.\nGTEST_API_ ::std::string FormatFileLocation(const char* file, int line);\n\n// Formats a file location for compiler-independent XML output.\n// Although this function is not platform dependent, we put it next to\n// FormatFileLocation in order to contrast the two functions.\nGTEST_API_ ::std::string FormatCompilerIndependentFileLocation(const char* file,\n                                                               int line);\n\n// Defines logging utilities:\n//   GTEST_LOG_(severity) - logs messages at the specified severity level. The\n//                          message itself is streamed into the macro.\n//   LogToStderr()  - directs all log messages to stderr.\n//   FlushInfoLog() - flushes informational log messages.\n\nenum GTestLogSeverity {\n  GTEST_INFO,\n  GTEST_WARNING,\n  GTEST_ERROR,\n  GTEST_FATAL\n};\n\n// Formats log entry severity, provides a stream object for streaming the\n// log message, and terminates the message with a newline when going out of\n// scope.\nclass GTEST_API_ GTestLog {\n public:\n  GTestLog(GTestLogSeverity severity, const char* file, int line);\n\n  // Flushes the buffers and, if severity is GTEST_FATAL, aborts the program.\n  ~GTestLog();\n\n  ::std::ostream& GetStream() { return ::std::cerr; }\n\n private:\n  const GTestLogSeverity severity_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(GTestLog);\n};\n\n#if !defined(GTEST_LOG_)\n\n# define GTEST_LOG_(severity) \\\n    ::testing::internal::GTestLog(::testing::internal::GTEST_##severity, \\\n                                  __FILE__, __LINE__).GetStream()\n\ninline void LogToStderr() {}\ninline void FlushInfoLog() { fflush(NULL); }\n\n#endif  // !defined(GTEST_LOG_)\n\n#if !defined(GTEST_CHECK_)\n// INTERNAL IMPLEMENTATION - DO NOT USE.\n//\n// GTEST_CHECK_ is an all-mode assert. It aborts the program if the condition\n// is not satisfied.\n//  Synopsys:\n//    GTEST_CHECK_(boolean_condition);\n//     or\n//    GTEST_CHECK_(boolean_condition) << \"Additional message\";\n//\n//    This checks the condition and if the condition is not satisfied\n//    it prints message about the condition violation, including the\n//    condition itself, plus additional message streamed into it, if any,\n//    and then it aborts the program. It aborts the program irrespective of\n//    whether it is built in the debug mode or not.\n# define GTEST_CHECK_(condition) \\\n    GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n    if (::testing::internal::IsTrue(condition)) \\\n      ; \\\n    else \\\n      GTEST_LOG_(FATAL) << \"Condition \" #condition \" failed. \"\n#endif  // !defined(GTEST_CHECK_)\n\n// An all-mode assert to verify that the given POSIX-style function\n// call returns 0 (indicating success).  Known limitation: this\n// doesn't expand to a balanced 'if' statement, so enclose the macro\n// in {} if you need to use it as the only statement in an 'if'\n// branch.\n#define GTEST_CHECK_POSIX_SUCCESS_(posix_call) \\\n  if (const int gtest_error = (posix_call)) \\\n    GTEST_LOG_(FATAL) << #posix_call << \"failed with error \" \\\n                      << gtest_error\n\n#if GTEST_HAS_STD_MOVE_\nusing std::move;\n#else  // GTEST_HAS_STD_MOVE_\ntemplate <typename T>\nconst T& move(const T& t) {\n  return t;\n}\n#endif  // GTEST_HAS_STD_MOVE_\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n//\n// Use ImplicitCast_ as a safe version of static_cast for upcasting in\n// the type hierarchy (e.g. casting a Foo* to a SuperclassOfFoo* or a\n// const Foo*).  When you use ImplicitCast_, the compiler checks that\n// the cast is safe.  Such explicit ImplicitCast_s are necessary in\n// surprisingly many situations where C++ demands an exact type match\n// instead of an argument type convertable to a target type.\n//\n// The syntax for using ImplicitCast_ is the same as for static_cast:\n//\n//   ImplicitCast_<ToType>(expr)\n//\n// ImplicitCast_ would have been part of the C++ standard library,\n// but the proposal was submitted too late.  It will probably make\n// its way into the language in the future.\n//\n// This relatively ugly name is intentional. It prevents clashes with\n// similar functions users may have (e.g., implicit_cast). The internal\n// namespace alone is not enough because the function can be found by ADL.\ntemplate<typename To>\ninline To ImplicitCast_(To x) { return x; }\n\n// When you upcast (that is, cast a pointer from type Foo to type\n// SuperclassOfFoo), it's fine to use ImplicitCast_<>, since upcasts\n// always succeed.  When you downcast (that is, cast a pointer from\n// type Foo to type SubclassOfFoo), static_cast<> isn't safe, because\n// how do you know the pointer is really of type SubclassOfFoo?  It\n// could be a bare Foo, or of type DifferentSubclassOfFoo.  Thus,\n// when you downcast, you should use this macro.  In debug mode, we\n// use dynamic_cast<> to double-check the downcast is legal (we die\n// if it's not).  In normal mode, we do the efficient static_cast<>\n// instead.  Thus, it's important to test in debug mode to make sure\n// the cast is legal!\n//    This is the only place in the code we should use dynamic_cast<>.\n// In particular, you SHOULDN'T be using dynamic_cast<> in order to\n// do RTTI (eg code like this:\n//    if (dynamic_cast<Subclass1>(foo)) HandleASubclass1Object(foo);\n//    if (dynamic_cast<Subclass2>(foo)) HandleASubclass2Object(foo);\n// You should design the code some other way not to need this.\n//\n// This relatively ugly name is intentional. It prevents clashes with\n// similar functions users may have (e.g., down_cast). The internal\n// namespace alone is not enough because the function can be found by ADL.\ntemplate<typename To, typename From>  // use like this: DownCast_<T*>(foo);\ninline To DownCast_(From* f) {  // so we only accept pointers\n  // Ensures that To is a sub-type of From *.  This test is here only\n  // for compile-time type checking, and has no overhead in an\n  // optimized build at run-time, as it will be optimized away\n  // completely.\n  GTEST_INTENTIONAL_CONST_COND_PUSH_()\n  if (false) {\n  GTEST_INTENTIONAL_CONST_COND_POP_()\n    const To to = NULL;\n    ::testing::internal::ImplicitCast_<From*>(to);\n  }\n\n#if GTEST_HAS_RTTI\n  // RTTI: debug mode only!\n  GTEST_CHECK_(f == NULL || dynamic_cast<To>(f) != NULL);\n#endif\n  return static_cast<To>(f);\n}\n\n// Downcasts the pointer of type Base to Derived.\n// Derived must be a subclass of Base. The parameter MUST\n// point to a class of type Derived, not any subclass of it.\n// When RTTI is available, the function performs a runtime\n// check to enforce this.\ntemplate <class Derived, class Base>\nDerived* CheckedDowncastToActualType(Base* base) {\n#if GTEST_HAS_RTTI\n  GTEST_CHECK_(typeid(*base) == typeid(Derived));\n#endif\n\n#if GTEST_HAS_DOWNCAST_\n  return ::down_cast<Derived*>(base);\n#elif GTEST_HAS_RTTI\n  return dynamic_cast<Derived*>(base);  // NOLINT\n#else\n  return static_cast<Derived*>(base);  // Poor man's downcast.\n#endif\n}\n\n#if GTEST_HAS_STREAM_REDIRECTION\n\n// Defines the stderr capturer:\n//   CaptureStdout     - starts capturing stdout.\n//   GetCapturedStdout - stops capturing stdout and returns the captured string.\n//   CaptureStderr     - starts capturing stderr.\n//   GetCapturedStderr - stops capturing stderr and returns the captured string.\n//\nGTEST_API_ void CaptureStdout();\nGTEST_API_ std::string GetCapturedStdout();\nGTEST_API_ void CaptureStderr();\nGTEST_API_ std::string GetCapturedStderr();\n\n#endif  // GTEST_HAS_STREAM_REDIRECTION\n\n// Returns a path to temporary directory.\nGTEST_API_ std::string TempDir();\n\n// Returns the size (in bytes) of a file.\nGTEST_API_ size_t GetFileSize(FILE* file);\n\n// Reads the entire content of a file as a string.\nGTEST_API_ std::string ReadEntireFile(FILE* file);\n\n// All command line arguments.\nGTEST_API_ const ::std::vector<testing::internal::string>& GetArgvs();\n\n#if GTEST_HAS_DEATH_TEST\n\nconst ::std::vector<testing::internal::string>& GetInjectableArgvs();\nvoid SetInjectableArgvs(const ::std::vector<testing::internal::string>*\n                             new_argvs);\n\n\n#endif  // GTEST_HAS_DEATH_TEST\n\n// Defines synchronization primitives.\n#if GTEST_IS_THREADSAFE\n# if GTEST_HAS_PTHREAD\n// Sleeps for (roughly) n milliseconds.  This function is only for testing\n// Google Test's own constructs.  Don't use it in user tests, either\n// directly or indirectly.\ninline void SleepMilliseconds(int n) {\n  const timespec time = {\n    0,                  // 0 seconds.\n    n * 1000L * 1000L,  // And n ms.\n  };\n  nanosleep(&time, NULL);\n}\n# endif  // GTEST_HAS_PTHREAD\n\n# if GTEST_HAS_NOTIFICATION_\n// Notification has already been imported into the namespace.\n// Nothing to do here.\n\n# elif GTEST_HAS_PTHREAD\n// Allows a controller thread to pause execution of newly created\n// threads until notified.  Instances of this class must be created\n// and destroyed in the controller thread.\n//\n// This class is only for testing Google Test's own constructs. Do not\n// use it in user tests, either directly or indirectly.\nclass Notification {\n public:\n  Notification() : notified_(false) {\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_init(&mutex_, NULL));\n  }\n  ~Notification() {\n    pthread_mutex_destroy(&mutex_);\n  }\n\n  // Notifies all threads created with this notification to start. Must\n  // be called from the controller thread.\n  void Notify() {\n    pthread_mutex_lock(&mutex_);\n    notified_ = true;\n    pthread_mutex_unlock(&mutex_);\n  }\n\n  // Blocks until the controller thread notifies. Must be called from a test\n  // thread.\n  void WaitForNotification() {\n    for (;;) {\n      pthread_mutex_lock(&mutex_);\n      const bool notified = notified_;\n      pthread_mutex_unlock(&mutex_);\n      if (notified)\n        break;\n      SleepMilliseconds(10);\n    }\n  }\n\n private:\n  pthread_mutex_t mutex_;\n  bool notified_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Notification);\n};\n\n# elif GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT\n\nGTEST_API_ void SleepMilliseconds(int n);\n\n// Provides leak-safe Windows kernel handle ownership.\n// Used in death tests and in threading support.\nclass GTEST_API_ AutoHandle {\n public:\n  // Assume that Win32 HANDLE type is equivalent to void*. Doing so allows us to\n  // avoid including <windows.h> in this header file. Including <windows.h> is\n  // undesirable because it defines a lot of symbols and macros that tend to\n  // conflict with client code. This assumption is verified by\n  // WindowsTypesTest.HANDLEIsVoidStar.\n  typedef void* Handle;\n  AutoHandle();\n  explicit AutoHandle(Handle handle);\n\n  ~AutoHandle();\n\n  Handle Get() const;\n  void Reset();\n  void Reset(Handle handle);\n\n private:\n  // Returns true iff the handle is a valid handle object that can be closed.\n  bool IsCloseable() const;\n\n  Handle handle_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(AutoHandle);\n};\n\n// Allows a controller thread to pause execution of newly created\n// threads until notified.  Instances of this class must be created\n// and destroyed in the controller thread.\n//\n// This class is only for testing Google Test's own constructs. Do not\n// use it in user tests, either directly or indirectly.\nclass GTEST_API_ Notification {\n public:\n  Notification();\n  void Notify();\n  void WaitForNotification();\n\n private:\n  AutoHandle event_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Notification);\n};\n# endif  // GTEST_HAS_NOTIFICATION_\n\n// On MinGW, we can have both GTEST_OS_WINDOWS and GTEST_HAS_PTHREAD\n// defined, but we don't want to use MinGW's pthreads implementation, which\n// has conformance problems with some versions of the POSIX standard.\n# if GTEST_HAS_PTHREAD && !GTEST_OS_WINDOWS_MINGW\n\n// As a C-function, ThreadFuncWithCLinkage cannot be templated itself.\n// Consequently, it cannot select a correct instantiation of ThreadWithParam\n// in order to call its Run(). Introducing ThreadWithParamBase as a\n// non-templated base class for ThreadWithParam allows us to bypass this\n// problem.\nclass ThreadWithParamBase {\n public:\n  virtual ~ThreadWithParamBase() {}\n  virtual void Run() = 0;\n};\n\n// pthread_create() accepts a pointer to a function type with the C linkage.\n// According to the Standard (7.5/1), function types with different linkages\n// are different even if they are otherwise identical.  Some compilers (for\n// example, SunStudio) treat them as different types.  Since class methods\n// cannot be defined with C-linkage we need to define a free C-function to\n// pass into pthread_create().\nextern \"C\" inline void* ThreadFuncWithCLinkage(void* thread) {\n  static_cast<ThreadWithParamBase*>(thread)->Run();\n  return NULL;\n}\n\n// Helper class for testing Google Test's multi-threading constructs.\n// To use it, write:\n//\n//   void ThreadFunc(int param) { /* Do things with param */ }\n//   Notification thread_can_start;\n//   ...\n//   // The thread_can_start parameter is optional; you can supply NULL.\n//   ThreadWithParam<int> thread(&ThreadFunc, 5, &thread_can_start);\n//   thread_can_start.Notify();\n//\n// These classes are only for testing Google Test's own constructs. Do\n// not use them in user tests, either directly or indirectly.\ntemplate <typename T>\nclass ThreadWithParam : public ThreadWithParamBase {\n public:\n  typedef void UserThreadFunc(T);\n\n  ThreadWithParam(UserThreadFunc* func, T param, Notification* thread_can_start)\n      : func_(func),\n        param_(param),\n        thread_can_start_(thread_can_start),\n        finished_(false) {\n    ThreadWithParamBase* const base = this;\n    // The thread can be created only after all fields except thread_\n    // have been initialized.\n    GTEST_CHECK_POSIX_SUCCESS_(\n        pthread_create(&thread_, 0, &ThreadFuncWithCLinkage, base));\n  }\n  ~ThreadWithParam() { Join(); }\n\n  void Join() {\n    if (!finished_) {\n      GTEST_CHECK_POSIX_SUCCESS_(pthread_join(thread_, 0));\n      finished_ = true;\n    }\n  }\n\n  virtual void Run() {\n    if (thread_can_start_ != NULL)\n      thread_can_start_->WaitForNotification();\n    func_(param_);\n  }\n\n private:\n  UserThreadFunc* const func_;  // User-supplied thread function.\n  const T param_;  // User-supplied parameter to the thread function.\n  // When non-NULL, used to block execution until the controller thread\n  // notifies.\n  Notification* const thread_can_start_;\n  bool finished_;  // true iff we know that the thread function has finished.\n  pthread_t thread_;  // The native thread object.\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadWithParam);\n};\n# endif  // !GTEST_OS_WINDOWS && GTEST_HAS_PTHREAD ||\n         // GTEST_HAS_MUTEX_AND_THREAD_LOCAL_\n\n# if GTEST_HAS_MUTEX_AND_THREAD_LOCAL_\n// Mutex and ThreadLocal have already been imported into the namespace.\n// Nothing to do here.\n\n# elif GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT\n\n// Mutex implements mutex on Windows platforms.  It is used in conjunction\n// with class MutexLock:\n//\n//   Mutex mutex;\n//   ...\n//   MutexLock lock(&mutex);  // Acquires the mutex and releases it at the\n//                            // end of the current scope.\n//\n// A static Mutex *must* be defined or declared using one of the following\n// macros:\n//   GTEST_DEFINE_STATIC_MUTEX_(g_some_mutex);\n//   GTEST_DECLARE_STATIC_MUTEX_(g_some_mutex);\n//\n// (A non-static Mutex is defined/declared in the usual way).\nclass GTEST_API_ Mutex {\n public:\n  enum MutexType { kStatic = 0, kDynamic = 1 };\n  // We rely on kStaticMutex being 0 as it is to what the linker initializes\n  // type_ in static mutexes.  critical_section_ will be initialized lazily\n  // in ThreadSafeLazyInit().\n  enum StaticConstructorSelector { kStaticMutex = 0 };\n\n  // This constructor intentionally does nothing.  It relies on type_ being\n  // statically initialized to 0 (effectively setting it to kStatic) and on\n  // ThreadSafeLazyInit() to lazily initialize the rest of the members.\n  explicit Mutex(StaticConstructorSelector /*dummy*/) {}\n\n  Mutex();\n  ~Mutex();\n\n  void Lock();\n\n  void Unlock();\n\n  // Does nothing if the current thread holds the mutex. Otherwise, crashes\n  // with high probability.\n  void AssertHeld();\n\n private:\n  // Initializes owner_thread_id_ and critical_section_ in static mutexes.\n  void ThreadSafeLazyInit();\n\n  // Per http://blogs.msdn.com/b/oldnewthing/archive/2004/02/23/78395.aspx,\n  // we assume that 0 is an invalid value for thread IDs.\n  unsigned int owner_thread_id_;\n\n  // For static mutexes, we rely on these members being initialized to zeros\n  // by the linker.\n  MutexType type_;\n  long critical_section_init_phase_;  // NOLINT\n  _RTL_CRITICAL_SECTION* critical_section_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Mutex);\n};\n\n# define GTEST_DECLARE_STATIC_MUTEX_(mutex) \\\n    extern ::testing::internal::Mutex mutex\n\n# define GTEST_DEFINE_STATIC_MUTEX_(mutex) \\\n    ::testing::internal::Mutex mutex(::testing::internal::Mutex::kStaticMutex)\n\n// We cannot name this class MutexLock because the ctor declaration would\n// conflict with a macro named MutexLock, which is defined on some\n// platforms. That macro is used as a defensive measure to prevent against\n// inadvertent misuses of MutexLock like \"MutexLock(&mu)\" rather than\n// \"MutexLock l(&mu)\".  Hence the typedef trick below.\nclass GTestMutexLock {\n public:\n  explicit GTestMutexLock(Mutex* mutex)\n      : mutex_(mutex) { mutex_->Lock(); }\n\n  ~GTestMutexLock() { mutex_->Unlock(); }\n\n private:\n  Mutex* const mutex_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(GTestMutexLock);\n};\n\ntypedef GTestMutexLock MutexLock;\n\n// Base class for ValueHolder<T>.  Allows a caller to hold and delete a value\n// without knowing its type.\nclass ThreadLocalValueHolderBase {\n public:\n  virtual ~ThreadLocalValueHolderBase() {}\n};\n\n// Provides a way for a thread to send notifications to a ThreadLocal\n// regardless of its parameter type.\nclass ThreadLocalBase {\n public:\n  // Creates a new ValueHolder<T> object holding a default value passed to\n  // this ThreadLocal<T>'s constructor and returns it.  It is the caller's\n  // responsibility not to call this when the ThreadLocal<T> instance already\n  // has a value on the current thread.\n  virtual ThreadLocalValueHolderBase* NewValueForCurrentThread() const = 0;\n\n protected:\n  ThreadLocalBase() {}\n  virtual ~ThreadLocalBase() {}\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadLocalBase);\n};\n\n// Maps a thread to a set of ThreadLocals that have values instantiated on that\n// thread and notifies them when the thread exits.  A ThreadLocal instance is\n// expected to persist until all threads it has values on have terminated.\nclass GTEST_API_ ThreadLocalRegistry {\n public:\n  // Registers thread_local_instance as having value on the current thread.\n  // Returns a value that can be used to identify the thread from other threads.\n  static ThreadLocalValueHolderBase* GetValueOnCurrentThread(\n      const ThreadLocalBase* thread_local_instance);\n\n  // Invoked when a ThreadLocal instance is destroyed.\n  static void OnThreadLocalDestroyed(\n      const ThreadLocalBase* thread_local_instance);\n};\n\nclass GTEST_API_ ThreadWithParamBase {\n public:\n  void Join();\n\n protected:\n  class Runnable {\n   public:\n    virtual ~Runnable() {}\n    virtual void Run() = 0;\n  };\n\n  ThreadWithParamBase(Runnable *runnable, Notification* thread_can_start);\n  virtual ~ThreadWithParamBase();\n\n private:\n  AutoHandle thread_;\n};\n\n// Helper class for testing Google Test's multi-threading constructs.\ntemplate <typename T>\nclass ThreadWithParam : public ThreadWithParamBase {\n public:\n  typedef void UserThreadFunc(T);\n\n  ThreadWithParam(UserThreadFunc* func, T param, Notification* thread_can_start)\n      : ThreadWithParamBase(new RunnableImpl(func, param), thread_can_start) {\n  }\n  virtual ~ThreadWithParam() {}\n\n private:\n  class RunnableImpl : public Runnable {\n   public:\n    RunnableImpl(UserThreadFunc* func, T param)\n        : func_(func),\n          param_(param) {\n    }\n    virtual ~RunnableImpl() {}\n    virtual void Run() {\n      func_(param_);\n    }\n\n   private:\n    UserThreadFunc* const func_;\n    const T param_;\n\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(RunnableImpl);\n  };\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadWithParam);\n};\n\n// Implements thread-local storage on Windows systems.\n//\n//   // Thread 1\n//   ThreadLocal<int> tl(100);  // 100 is the default value for each thread.\n//\n//   // Thread 2\n//   tl.set(150);  // Changes the value for thread 2 only.\n//   EXPECT_EQ(150, tl.get());\n//\n//   // Thread 1\n//   EXPECT_EQ(100, tl.get());  // In thread 1, tl has the original value.\n//   tl.set(200);\n//   EXPECT_EQ(200, tl.get());\n//\n// The template type argument T must have a public copy constructor.\n// In addition, the default ThreadLocal constructor requires T to have\n// a public default constructor.\n//\n// The users of a TheadLocal instance have to make sure that all but one\n// threads (including the main one) using that instance have exited before\n// destroying it. Otherwise, the per-thread objects managed for them by the\n// ThreadLocal instance are not guaranteed to be destroyed on all platforms.\n//\n// Google Test only uses global ThreadLocal objects.  That means they\n// will die after main() has returned.  Therefore, no per-thread\n// object managed by Google Test will be leaked as long as all threads\n// using Google Test have exited when main() returns.\ntemplate <typename T>\nclass ThreadLocal : public ThreadLocalBase {\n public:\n  ThreadLocal() : default_factory_(new DefaultValueHolderFactory()) {}\n  explicit ThreadLocal(const T& value)\n      : default_factory_(new InstanceValueHolderFactory(value)) {}\n\n  ~ThreadLocal() { ThreadLocalRegistry::OnThreadLocalDestroyed(this); }\n\n  T* pointer() { return GetOrCreateValue(); }\n  const T* pointer() const { return GetOrCreateValue(); }\n  const T& get() const { return *pointer(); }\n  void set(const T& value) { *pointer() = value; }\n\n private:\n  // Holds a value of T.  Can be deleted via its base class without the caller\n  // knowing the type of T.\n  class ValueHolder : public ThreadLocalValueHolderBase {\n   public:\n    ValueHolder() : value_() {}\n    explicit ValueHolder(const T& value) : value_(value) {}\n\n    T* pointer() { return &value_; }\n\n   private:\n    T value_;\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(ValueHolder);\n  };\n\n\n  T* GetOrCreateValue() const {\n    return static_cast<ValueHolder*>(\n        ThreadLocalRegistry::GetValueOnCurrentThread(this))->pointer();\n  }\n\n  virtual ThreadLocalValueHolderBase* NewValueForCurrentThread() const {\n    return default_factory_->MakeNewHolder();\n  }\n\n  class ValueHolderFactory {\n   public:\n    ValueHolderFactory() {}\n    virtual ~ValueHolderFactory() {}\n    virtual ValueHolder* MakeNewHolder() const = 0;\n\n   private:\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(ValueHolderFactory);\n  };\n\n  class DefaultValueHolderFactory : public ValueHolderFactory {\n   public:\n    DefaultValueHolderFactory() {}\n    virtual ValueHolder* MakeNewHolder() const { return new ValueHolder(); }\n\n   private:\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(DefaultValueHolderFactory);\n  };\n\n  class InstanceValueHolderFactory : public ValueHolderFactory {\n   public:\n    explicit InstanceValueHolderFactory(const T& value) : value_(value) {}\n    virtual ValueHolder* MakeNewHolder() const {\n      return new ValueHolder(value_);\n    }\n\n   private:\n    const T value_;  // The value for each thread.\n\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(InstanceValueHolderFactory);\n  };\n\n  scoped_ptr<ValueHolderFactory> default_factory_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadLocal);\n};\n\n# elif GTEST_HAS_PTHREAD\n\n// MutexBase and Mutex implement mutex on pthreads-based platforms.\nclass MutexBase {\n public:\n  // Acquires this mutex.\n  void Lock() {\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_lock(&mutex_));\n    owner_ = pthread_self();\n    has_owner_ = true;\n  }\n\n  // Releases this mutex.\n  void Unlock() {\n    // Since the lock is being released the owner_ field should no longer be\n    // considered valid. We don't protect writing to has_owner_ here, as it's\n    // the caller's responsibility to ensure that the current thread holds the\n    // mutex when this is called.\n    has_owner_ = false;\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_unlock(&mutex_));\n  }\n\n  // Does nothing if the current thread holds the mutex. Otherwise, crashes\n  // with high probability.\n  void AssertHeld() const {\n    GTEST_CHECK_(has_owner_ && pthread_equal(owner_, pthread_self()))\n        << \"The current thread is not holding the mutex @\" << this;\n  }\n\n  // A static mutex may be used before main() is entered.  It may even\n  // be used before the dynamic initialization stage.  Therefore we\n  // must be able to initialize a static mutex object at link time.\n  // This means MutexBase has to be a POD and its member variables\n  // have to be public.\n public:\n  pthread_mutex_t mutex_;  // The underlying pthread mutex.\n  // has_owner_ indicates whether the owner_ field below contains a valid thread\n  // ID and is therefore safe to inspect (e.g., to use in pthread_equal()). All\n  // accesses to the owner_ field should be protected by a check of this field.\n  // An alternative might be to memset() owner_ to all zeros, but there's no\n  // guarantee that a zero'd pthread_t is necessarily invalid or even different\n  // from pthread_self().\n  bool has_owner_;\n  pthread_t owner_;  // The thread holding the mutex.\n};\n\n// Forward-declares a static mutex.\n#  define GTEST_DECLARE_STATIC_MUTEX_(mutex) \\\n     extern ::testing::internal::MutexBase mutex\n\n// Defines and statically (i.e. at link time) initializes a static mutex.\n#  define GTEST_DEFINE_STATIC_MUTEX_(mutex) \\\n     ::testing::internal::MutexBase mutex = { PTHREAD_MUTEX_INITIALIZER, false, pthread_t() }\n\n// The Mutex class can only be used for mutexes created at runtime. It\n// shares its API with MutexBase otherwise.\nclass Mutex : public MutexBase {\n public:\n  Mutex() {\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_init(&mutex_, NULL));\n    has_owner_ = false;\n  }\n  ~Mutex() {\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_destroy(&mutex_));\n  }\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Mutex);\n};\n\n// We cannot name this class MutexLock because the ctor declaration would\n// conflict with a macro named MutexLock, which is defined on some\n// platforms. That macro is used as a defensive measure to prevent against\n// inadvertent misuses of MutexLock like \"MutexLock(&mu)\" rather than\n// \"MutexLock l(&mu)\".  Hence the typedef trick below.\nclass GTestMutexLock {\n public:\n  explicit GTestMutexLock(MutexBase* mutex)\n      : mutex_(mutex) { mutex_->Lock(); }\n\n  ~GTestMutexLock() { mutex_->Unlock(); }\n\n private:\n  MutexBase* const mutex_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(GTestMutexLock);\n};\n\ntypedef GTestMutexLock MutexLock;\n\n// Helpers for ThreadLocal.\n\n// pthread_key_create() requires DeleteThreadLocalValue() to have\n// C-linkage.  Therefore it cannot be templatized to access\n// ThreadLocal<T>.  Hence the need for class\n// ThreadLocalValueHolderBase.\nclass ThreadLocalValueHolderBase {\n public:\n  virtual ~ThreadLocalValueHolderBase() {}\n};\n\n// Called by pthread to delete thread-local data stored by\n// pthread_setspecific().\nextern \"C\" inline void DeleteThreadLocalValue(void* value_holder) {\n  delete static_cast<ThreadLocalValueHolderBase*>(value_holder);\n}\n\n// Implements thread-local storage on pthreads-based systems.\ntemplate <typename T>\nclass ThreadLocal {\n public:\n  ThreadLocal()\n      : key_(CreateKey()), default_factory_(new DefaultValueHolderFactory()) {}\n  explicit ThreadLocal(const T& value)\n      : key_(CreateKey()),\n        default_factory_(new InstanceValueHolderFactory(value)) {}\n\n  ~ThreadLocal() {\n    // Destroys the managed object for the current thread, if any.\n    DeleteThreadLocalValue(pthread_getspecific(key_));\n\n    // Releases resources associated with the key.  This will *not*\n    // delete managed objects for other threads.\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_key_delete(key_));\n  }\n\n  T* pointer() { return GetOrCreateValue(); }\n  const T* pointer() const { return GetOrCreateValue(); }\n  const T& get() const { return *pointer(); }\n  void set(const T& value) { *pointer() = value; }\n\n private:\n  // Holds a value of type T.\n  class ValueHolder : public ThreadLocalValueHolderBase {\n   public:\n    ValueHolder() : value_() {}\n    explicit ValueHolder(const T& value) : value_(value) {}\n\n    T* pointer() { return &value_; }\n\n   private:\n    T value_;\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(ValueHolder);\n  };\n\n  static pthread_key_t CreateKey() {\n    pthread_key_t key;\n    // When a thread exits, DeleteThreadLocalValue() will be called on\n    // the object managed for that thread.\n    GTEST_CHECK_POSIX_SUCCESS_(\n        pthread_key_create(&key, &DeleteThreadLocalValue));\n    return key;\n  }\n\n  T* GetOrCreateValue() const {\n    ThreadLocalValueHolderBase* const holder =\n        static_cast<ThreadLocalValueHolderBase*>(pthread_getspecific(key_));\n    if (holder != NULL) {\n      return CheckedDowncastToActualType<ValueHolder>(holder)->pointer();\n    }\n\n    ValueHolder* const new_holder = default_factory_->MakeNewHolder();\n    ThreadLocalValueHolderBase* const holder_base = new_holder;\n    GTEST_CHECK_POSIX_SUCCESS_(pthread_setspecific(key_, holder_base));\n    return new_holder->pointer();\n  }\n\n  class ValueHolderFactory {\n   public:\n    ValueHolderFactory() {}\n    virtual ~ValueHolderFactory() {}\n    virtual ValueHolder* MakeNewHolder() const = 0;\n\n   private:\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(ValueHolderFactory);\n  };\n\n  class DefaultValueHolderFactory : public ValueHolderFactory {\n   public:\n    DefaultValueHolderFactory() {}\n    virtual ValueHolder* MakeNewHolder() const { return new ValueHolder(); }\n\n   private:\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(DefaultValueHolderFactory);\n  };\n\n  class InstanceValueHolderFactory : public ValueHolderFactory {\n   public:\n    explicit InstanceValueHolderFactory(const T& value) : value_(value) {}\n    virtual ValueHolder* MakeNewHolder() const {\n      return new ValueHolder(value_);\n    }\n\n   private:\n    const T value_;  // The value for each thread.\n\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(InstanceValueHolderFactory);\n  };\n\n  // A key pthreads uses for looking up per-thread values.\n  const pthread_key_t key_;\n  scoped_ptr<ValueHolderFactory> default_factory_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadLocal);\n};\n\n# endif  // GTEST_HAS_MUTEX_AND_THREAD_LOCAL_\n\n#else  // GTEST_IS_THREADSAFE\n\n// A dummy implementation of synchronization primitives (mutex, lock,\n// and thread-local variable).  Necessary for compiling Google Test where\n// mutex is not supported - using Google Test in multiple threads is not\n// supported on such platforms.\n\nclass Mutex {\n public:\n  Mutex() {}\n  void Lock() {}\n  void Unlock() {}\n  void AssertHeld() const {}\n};\n\n# define GTEST_DECLARE_STATIC_MUTEX_(mutex) \\\n  extern ::testing::internal::Mutex mutex\n\n# define GTEST_DEFINE_STATIC_MUTEX_(mutex) ::testing::internal::Mutex mutex\n\n// We cannot name this class MutexLock because the ctor declaration would\n// conflict with a macro named MutexLock, which is defined on some\n// platforms. That macro is used as a defensive measure to prevent against\n// inadvertent misuses of MutexLock like \"MutexLock(&mu)\" rather than\n// \"MutexLock l(&mu)\".  Hence the typedef trick below.\nclass GTestMutexLock {\n public:\n  explicit GTestMutexLock(Mutex*) {}  // NOLINT\n};\n\ntypedef GTestMutexLock MutexLock;\n\ntemplate <typename T>\nclass ThreadLocal {\n public:\n  ThreadLocal() : value_() {}\n  explicit ThreadLocal(const T& value) : value_(value) {}\n  T* pointer() { return &value_; }\n  const T* pointer() const { return &value_; }\n  const T& get() const { return value_; }\n  void set(const T& value) { value_ = value; }\n private:\n  T value_;\n};\n\n#endif  // GTEST_IS_THREADSAFE\n\n// Returns the number of threads running in the process, or 0 to indicate that\n// we cannot detect it.\nGTEST_API_ size_t GetThreadCount();\n\n// Passing non-POD classes through ellipsis (...) crashes the ARM\n// compiler and generates a warning in Sun Studio.  The Nokia Symbian\n// and the IBM XL C/C++ compiler try to instantiate a copy constructor\n// for objects passed through ellipsis (...), failing for uncopyable\n// objects.  We define this to ensure that only POD is passed through\n// ellipsis on these systems.\n#if defined(__SYMBIAN32__) || defined(__IBMCPP__) || defined(__SUNPRO_CC)\n// We lose support for NULL detection where the compiler doesn't like\n// passing non-POD classes through ellipsis (...).\n# define GTEST_ELLIPSIS_NEEDS_POD_ 1\n#else\n# define GTEST_CAN_COMPARE_NULL 1\n#endif\n\n// The Nokia Symbian and IBM XL C/C++ compilers cannot decide between\n// const T& and const T* in a function template.  These compilers\n// _can_ decide between class template specializations for T and T*,\n// so a tr1::type_traits-like is_pointer works.\n#if defined(__SYMBIAN32__) || defined(__IBMCPP__)\n# define GTEST_NEEDS_IS_POINTER_ 1\n#endif\n\ntemplate <bool bool_value>\nstruct bool_constant {\n  typedef bool_constant<bool_value> type;\n  static const bool value = bool_value;\n};\ntemplate <bool bool_value> const bool bool_constant<bool_value>::value;\n\ntypedef bool_constant<false> false_type;\ntypedef bool_constant<true> true_type;\n\ntemplate <typename T>\nstruct is_pointer : public false_type {};\n\ntemplate <typename T>\nstruct is_pointer<T*> : public true_type {};\n\ntemplate <typename Iterator>\nstruct IteratorTraits {\n  typedef typename Iterator::value_type value_type;\n};\n\ntemplate <typename T>\nstruct IteratorTraits<T*> {\n  typedef T value_type;\n};\n\ntemplate <typename T>\nstruct IteratorTraits<const T*> {\n  typedef T value_type;\n};\n\n#if GTEST_OS_WINDOWS\n# define GTEST_PATH_SEP_ \"\\\\\"\n# define GTEST_HAS_ALT_PATH_SEP_ 1\n// The biggest signed integer type the compiler supports.\ntypedef __int64 BiggestInt;\n#else\n# define GTEST_PATH_SEP_ \"/\"\n# define GTEST_HAS_ALT_PATH_SEP_ 0\ntypedef long long BiggestInt;  // NOLINT\n#endif  // GTEST_OS_WINDOWS\n\n// Utilities for char.\n\n// isspace(int ch) and friends accept an unsigned char or EOF.  char\n// may be signed, depending on the compiler (or compiler flags).\n// Therefore we need to cast a char to unsigned char before calling\n// isspace(), etc.\n\ninline bool IsAlpha(char ch) {\n  return isalpha(static_cast<unsigned char>(ch)) != 0;\n}\ninline bool IsAlNum(char ch) {\n  return isalnum(static_cast<unsigned char>(ch)) != 0;\n}\ninline bool IsDigit(char ch) {\n  return isdigit(static_cast<unsigned char>(ch)) != 0;\n}\ninline bool IsLower(char ch) {\n  return islower(static_cast<unsigned char>(ch)) != 0;\n}\ninline bool IsSpace(char ch) {\n  return isspace(static_cast<unsigned char>(ch)) != 0;\n}\ninline bool IsUpper(char ch) {\n  return isupper(static_cast<unsigned char>(ch)) != 0;\n}\ninline bool IsXDigit(char ch) {\n  return isxdigit(static_cast<unsigned char>(ch)) != 0;\n}\ninline bool IsXDigit(wchar_t ch) {\n  const unsigned char low_byte = static_cast<unsigned char>(ch);\n  return ch == low_byte && isxdigit(low_byte) != 0;\n}\n\ninline char ToLower(char ch) {\n  return static_cast<char>(tolower(static_cast<unsigned char>(ch)));\n}\ninline char ToUpper(char ch) {\n  return static_cast<char>(toupper(static_cast<unsigned char>(ch)));\n}\n\ninline std::string StripTrailingSpaces(std::string str) {\n  std::string::iterator it = str.end();\n  while (it != str.begin() && IsSpace(*--it))\n    it = str.erase(it);\n  return str;\n}\n\n// The testing::internal::posix namespace holds wrappers for common\n// POSIX functions.  These wrappers hide the differences between\n// Windows/MSVC and POSIX systems.  Since some compilers define these\n// standard functions as macros, the wrapper cannot have the same name\n// as the wrapped function.\n\nnamespace posix {\n\n// Functions with a different name on Windows.\n\n#if GTEST_OS_WINDOWS\n\ntypedef struct _stat StatStruct;\n\n# ifdef __BORLANDC__\ninline int IsATTY(int fd) { return isatty(fd); }\ninline int StrCaseCmp(const char* s1, const char* s2) {\n  return stricmp(s1, s2);\n}\ninline char* StrDup(const char* src) { return strdup(src); }\n# else  // !__BORLANDC__\n#  if GTEST_OS_WINDOWS_MOBILE\ninline int IsATTY(int /* fd */) { return 0; }\n#  else\ninline int IsATTY(int fd) { return _isatty(fd); }\n#  endif  // GTEST_OS_WINDOWS_MOBILE\ninline int StrCaseCmp(const char* s1, const char* s2) {\n  return _stricmp(s1, s2);\n}\ninline char* StrDup(const char* src) { return _strdup(src); }\n# endif  // __BORLANDC__\n\n# if GTEST_OS_WINDOWS_MOBILE\ninline int FileNo(FILE* file) { return reinterpret_cast<int>(_fileno(file)); }\n// Stat(), RmDir(), and IsDir() are not needed on Windows CE at this\n// time and thus not defined there.\n# else\ninline int FileNo(FILE* file) { return _fileno(file); }\ninline int Stat(const char* path, StatStruct* buf) { return _stat(path, buf); }\ninline int RmDir(const char* dir) { return _rmdir(dir); }\ninline bool IsDir(const StatStruct& st) {\n  return (_S_IFDIR & st.st_mode) != 0;\n}\n# endif  // GTEST_OS_WINDOWS_MOBILE\n\n#else\n\ntypedef struct stat StatStruct;\n\ninline int FileNo(FILE* file) { return fileno(file); }\ninline int IsATTY(int fd) { return isatty(fd); }\ninline int Stat(const char* path, StatStruct* buf) { return stat(path, buf); }\ninline int StrCaseCmp(const char* s1, const char* s2) {\n  return strcasecmp(s1, s2);\n}\ninline char* StrDup(const char* src) { return strdup(src); }\ninline int RmDir(const char* dir) { return rmdir(dir); }\ninline bool IsDir(const StatStruct& st) { return S_ISDIR(st.st_mode); }\n\n#endif  // GTEST_OS_WINDOWS\n\n// Functions deprecated by MSVC 8.0.\n\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(4996 /* deprecated function */)\n\ninline const char* StrNCpy(char* dest, const char* src, size_t n) {\n  return strncpy(dest, src, n);\n}\n\n// ChDir(), FReopen(), FDOpen(), Read(), Write(), Close(), and\n// StrError() aren't needed on Windows CE at this time and thus not\n// defined there.\n\n#if !GTEST_OS_WINDOWS_MOBILE && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT\ninline int ChDir(const char* dir) { return chdir(dir); }\n#endif\ninline FILE* FOpen(const char* path, const char* mode) {\n  return fopen(path, mode);\n}\n#if !GTEST_OS_WINDOWS_MOBILE\ninline FILE *FReopen(const char* path, const char* mode, FILE* stream) {\n  return freopen(path, mode, stream);\n}\ninline FILE* FDOpen(int fd, const char* mode) { return fdopen(fd, mode); }\n#endif\ninline int FClose(FILE* fp) { return fclose(fp); }\n#if !GTEST_OS_WINDOWS_MOBILE\ninline int Read(int fd, void* buf, unsigned int count) {\n  return static_cast<int>(read(fd, buf, count));\n}\ninline int Write(int fd, const void* buf, unsigned int count) {\n  return static_cast<int>(write(fd, buf, count));\n}\ninline int Close(int fd) { return close(fd); }\ninline const char* StrError(int errnum) { return strerror(errnum); }\n#endif\ninline const char* GetEnv(const char* name) {\n#if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_WINDOWS_PHONE | GTEST_OS_WINDOWS_RT\n  // We are on Windows CE, which has no environment variables.\n  static_cast<void>(name);  // To prevent 'unused argument' warning.\n  return NULL;\n#elif defined(__BORLANDC__) || defined(__SunOS_5_8) || defined(__SunOS_5_9)\n  // Environment variables which we programmatically clear will be set to the\n  // empty string rather than unset (NULL).  Handle that case.\n  const char* const env = getenv(name);\n  return (env != NULL && env[0] != '\\0') ? env : NULL;\n#else\n  return getenv(name);\n#endif\n}\n\nGTEST_DISABLE_MSC_WARNINGS_POP_()\n\n#if GTEST_OS_WINDOWS_MOBILE\n// Windows CE has no C library. The abort() function is used in\n// several places in Google Test. This implementation provides a reasonable\n// imitation of standard behaviour.\nvoid Abort();\n#else\ninline void Abort() { abort(); }\n#endif  // GTEST_OS_WINDOWS_MOBILE\n\n}  // namespace posix\n\n// MSVC \"deprecates\" snprintf and issues warnings wherever it is used.  In\n// order to avoid these warnings, we need to use _snprintf or _snprintf_s on\n// MSVC-based platforms.  We map the GTEST_SNPRINTF_ macro to the appropriate\n// function in order to achieve that.  We use macro definition here because\n// snprintf is a variadic function.\n#if _MSC_VER >= 1400 && !GTEST_OS_WINDOWS_MOBILE\n// MSVC 2005 and above support variadic macros.\n# define GTEST_SNPRINTF_(buffer, size, format, ...) \\\n     _snprintf_s(buffer, size, size, format, __VA_ARGS__)\n#elif defined(_MSC_VER)\n// Windows CE does not define _snprintf_s and MSVC prior to 2005 doesn't\n// complain about _snprintf.\n# define GTEST_SNPRINTF_ _snprintf\n#else\n# define GTEST_SNPRINTF_ snprintf\n#endif\n\n// The maximum number a BiggestInt can represent.  This definition\n// works no matter BiggestInt is represented in one's complement or\n// two's complement.\n//\n// We cannot rely on numeric_limits in STL, as __int64 and long long\n// are not part of standard C++ and numeric_limits doesn't need to be\n// defined for them.\nconst BiggestInt kMaxBiggestInt =\n    ~(static_cast<BiggestInt>(1) << (8*sizeof(BiggestInt) - 1));\n\n// This template class serves as a compile-time function from size to\n// type.  It maps a size in bytes to a primitive type with that\n// size. e.g.\n//\n//   TypeWithSize<4>::UInt\n//\n// is typedef-ed to be unsigned int (unsigned integer made up of 4\n// bytes).\n//\n// Such functionality should belong to STL, but I cannot find it\n// there.\n//\n// Google Test uses this class in the implementation of floating-point\n// comparison.\n//\n// For now it only handles UInt (unsigned int) as that's all Google Test\n// needs.  Other types can be easily added in the future if need\n// arises.\ntemplate <size_t size>\nclass TypeWithSize {\n public:\n  // This prevents the user from using TypeWithSize<N> with incorrect\n  // values of N.\n  typedef void UInt;\n};\n\n// The specialization for size 4.\ntemplate <>\nclass TypeWithSize<4> {\n public:\n  // unsigned int has size 4 in both gcc and MSVC.\n  //\n  // As base/basictypes.h doesn't compile on Windows, we cannot use\n  // uint32, uint64, and etc here.\n  typedef int Int;\n  typedef unsigned int UInt;\n};\n\n// The specialization for size 8.\ntemplate <>\nclass TypeWithSize<8> {\n public:\n#if GTEST_OS_WINDOWS\n  typedef __int64 Int;\n  typedef unsigned __int64 UInt;\n#else\n  typedef long long Int;  // NOLINT\n  typedef unsigned long long UInt;  // NOLINT\n#endif  // GTEST_OS_WINDOWS\n};\n\n// Integer types of known sizes.\ntypedef TypeWithSize<4>::Int Int32;\ntypedef TypeWithSize<4>::UInt UInt32;\ntypedef TypeWithSize<8>::Int Int64;\ntypedef TypeWithSize<8>::UInt UInt64;\ntypedef TypeWithSize<8>::Int TimeInMillis;  // Represents time in milliseconds.\n\n// Utilities for command line flags and environment variables.\n\n// Macro for referencing flags.\n#if !defined(GTEST_FLAG)\n# define GTEST_FLAG(name) FLAGS_gtest_##name\n#endif  // !defined(GTEST_FLAG)\n\n#if !defined(GTEST_USE_OWN_FLAGFILE_FLAG_)\n# define GTEST_USE_OWN_FLAGFILE_FLAG_ 1\n#endif  // !defined(GTEST_USE_OWN_FLAGFILE_FLAG_)\n\n#if !defined(GTEST_DECLARE_bool_)\n# define GTEST_FLAG_SAVER_ ::testing::internal::GTestFlagSaver\n\n// Macros for declaring flags.\n# define GTEST_DECLARE_bool_(name) GTEST_API_ extern bool GTEST_FLAG(name)\n# define GTEST_DECLARE_int32_(name) \\\n    GTEST_API_ extern ::testing::internal::Int32 GTEST_FLAG(name)\n#define GTEST_DECLARE_string_(name) \\\n    GTEST_API_ extern ::std::string GTEST_FLAG(name)\n\n// Macros for defining flags.\n#define GTEST_DEFINE_bool_(name, default_val, doc) \\\n    GTEST_API_ bool GTEST_FLAG(name) = (default_val)\n#define GTEST_DEFINE_int32_(name, default_val, doc) \\\n    GTEST_API_ ::testing::internal::Int32 GTEST_FLAG(name) = (default_val)\n#define GTEST_DEFINE_string_(name, default_val, doc) \\\n    GTEST_API_ ::std::string GTEST_FLAG(name) = (default_val)\n\n#endif  // !defined(GTEST_DECLARE_bool_)\n\n// Thread annotations\n#if !defined(GTEST_EXCLUSIVE_LOCK_REQUIRED_)\n# define GTEST_EXCLUSIVE_LOCK_REQUIRED_(locks)\n# define GTEST_LOCK_EXCLUDED_(locks)\n#endif  // !defined(GTEST_EXCLUSIVE_LOCK_REQUIRED_)\n\n// Parses 'str' for a 32-bit signed integer.  If successful, writes the result\n// to *value and returns true; otherwise leaves *value unchanged and returns\n// false.\n// TODO(chandlerc): Find a better way to refactor flag and environment parsing\n// out of both gtest-port.cc and gtest.cc to avoid exporting this utility\n// function.\nbool ParseInt32(const Message& src_text, const char* str, Int32* value);\n\n// Parses a bool/Int32/string from the environment variable\n// corresponding to the given Google Test flag.\nbool BoolFromGTestEnv(const char* flag, bool default_val);\nGTEST_API_ Int32 Int32FromGTestEnv(const char* flag, Int32 default_val);\nstd::string StringFromGTestEnv(const char* flag, const char* default_val);\n\n}  // namespace internal\n}  // namespace testing\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_\n"}, "67": {"id": 67, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-string.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Authors: wan@google.com (Zhanyong Wan), eefacm@gmail.com (Sean Mcafee)\n//\n// The Google C++ Testing Framework (Google Test)\n//\n// This header file declares the String class and functions used internally by\n// Google Test.  They are subject to change without notice. They should not used\n// by code external to Google Test.\n//\n// This header file is #included by <gtest/internal/gtest-internal.h>.\n// It should not be #included by other files.\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_STRING_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_STRING_H_\n\n#ifdef __BORLANDC__\n// string.h is not guaranteed to provide strcpy on C++ Builder.\n# include <mem.h>\n#endif\n\n#include <string.h>\n#include <string>\n\n#include \"gtest/internal/gtest-port.h\"\n\nnamespace testing {\nnamespace internal {\n\n// String - an abstract class holding static string utilities.\nclass GTEST_API_ String {\n public:\n  // Static utility methods\n\n  // Clones a 0-terminated C string, allocating memory using new.  The\n  // caller is responsible for deleting the return value using\n  // delete[].  Returns the cloned string, or NULL if the input is\n  // NULL.\n  //\n  // This is different from strdup() in string.h, which allocates\n  // memory using malloc().\n  static const char* CloneCString(const char* c_str);\n\n#if GTEST_OS_WINDOWS_MOBILE\n  // Windows CE does not have the 'ANSI' versions of Win32 APIs. To be\n  // able to pass strings to Win32 APIs on CE we need to convert them\n  // to 'Unicode', UTF-16.\n\n  // Creates a UTF-16 wide string from the given ANSI string, allocating\n  // memory using new. The caller is responsible for deleting the return\n  // value using delete[]. Returns the wide string, or NULL if the\n  // input is NULL.\n  //\n  // The wide string is created using the ANSI codepage (CP_ACP) to\n  // match the behaviour of the ANSI versions of Win32 calls and the\n  // C runtime.\n  static LPCWSTR AnsiToUtf16(const char* c_str);\n\n  // Creates an ANSI string from the given wide string, allocating\n  // memory using new. The caller is responsible for deleting the return\n  // value using delete[]. Returns the ANSI string, or NULL if the\n  // input is NULL.\n  //\n  // The returned string is created using the ANSI codepage (CP_ACP) to\n  // match the behaviour of the ANSI versions of Win32 calls and the\n  // C runtime.\n  static const char* Utf16ToAnsi(LPCWSTR utf16_str);\n#endif\n\n  // Compares two C strings.  Returns true iff they have the same content.\n  //\n  // Unlike strcmp(), this function can handle NULL argument(s).  A\n  // NULL C string is considered different to any non-NULL C string,\n  // including the empty string.\n  static bool CStringEquals(const char* lhs, const char* rhs);\n\n  // Converts a wide C string to a String using the UTF-8 encoding.\n  // NULL will be converted to \"(null)\".  If an error occurred during\n  // the conversion, \"(failed to convert from wide string)\" is\n  // returned.\n  static std::string ShowWideCString(const wchar_t* wide_c_str);\n\n  // Compares two wide C strings.  Returns true iff they have the same\n  // content.\n  //\n  // Unlike wcscmp(), this function can handle NULL argument(s).  A\n  // NULL C string is considered different to any non-NULL C string,\n  // including the empty string.\n  static bool WideCStringEquals(const wchar_t* lhs, const wchar_t* rhs);\n\n  // Compares two C strings, ignoring case.  Returns true iff they\n  // have the same content.\n  //\n  // Unlike strcasecmp(), this function can handle NULL argument(s).\n  // A NULL C string is considered different to any non-NULL C string,\n  // including the empty string.\n  static bool CaseInsensitiveCStringEquals(const char* lhs,\n                                           const char* rhs);\n\n  // Compares two wide C strings, ignoring case.  Returns true iff they\n  // have the same content.\n  //\n  // Unlike wcscasecmp(), this function can handle NULL argument(s).\n  // A NULL C string is considered different to any non-NULL wide C string,\n  // including the empty string.\n  // NB: The implementations on different platforms slightly differ.\n  // On windows, this method uses _wcsicmp which compares according to LC_CTYPE\n  // environment variable. On GNU platform this method uses wcscasecmp\n  // which compares according to LC_CTYPE category of the current locale.\n  // On MacOS X, it uses towlower, which also uses LC_CTYPE category of the\n  // current locale.\n  static bool CaseInsensitiveWideCStringEquals(const wchar_t* lhs,\n                                               const wchar_t* rhs);\n\n  // Returns true iff the given string ends with the given suffix, ignoring\n  // case. Any string is considered to end with an empty suffix.\n  static bool EndsWithCaseInsensitive(\n      const std::string& str, const std::string& suffix);\n\n  // Formats an int value as \"%02d\".\n  static std::string FormatIntWidth2(int value);  // \"%02d\" for width == 2\n\n  // Formats an int value as \"%X\".\n  static std::string FormatHexInt(int value);\n\n  // Formats a byte as \"%02X\".\n  static std::string FormatByte(unsigned char value);\n\n private:\n  String();  // Not meant to be instantiated.\n};  // class String\n\n// Gets the content of the stringstream's buffer as an std::string.  Each '\\0'\n// character in the buffer is replaced with \"\\\\0\".\nGTEST_API_ std::string StringStreamToString(::std::stringstream* stream);\n\n}  // namespace internal\n}  // namespace testing\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_STRING_H_\n"}, "68": {"id": 68, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-type-util.h", "content": "// This file was GENERATED by command:\n//     pump.py gtest-type-util.h.pump\n// DO NOT EDIT BY HAND!!!\n\n// Copyright 2008 Google Inc.\n// All Rights Reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n// Type utilities needed for implementing typed and type-parameterized\n// tests.  This file is generated by a SCRIPT.  DO NOT EDIT BY HAND!\n//\n// Currently we support at most 50 types in a list, and at most 50\n// type-parameterized tests in one type-parameterized test case.\n// Please contact googletestframework@googlegroups.com if you need\n// more.\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TYPE_UTIL_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TYPE_UTIL_H_\n\n#include \"gtest/internal/gtest-port.h\"\n\n// #ifdef __GNUC__ is too general here.  It is possible to use gcc without using\n// libstdc++ (which is where cxxabi.h comes from).\n# if GTEST_HAS_CXXABI_H_\n#  include <cxxabi.h>\n# elif defined(__HP_aCC)\n#  include <acxx_demangle.h>\n# endif  // GTEST_HASH_CXXABI_H_\n\nnamespace testing {\nnamespace internal {\n\n// GetTypeName<T>() returns a human-readable name of type T.\n// NB: This function is also used in Google Mock, so don't move it inside of\n// the typed-test-only section below.\ntemplate <typename T>\nstd::string GetTypeName() {\n# if GTEST_HAS_RTTI\n\n  const char* const name = typeid(T).name();\n#  if GTEST_HAS_CXXABI_H_ || defined(__HP_aCC)\n  int status = 0;\n  // gcc's implementation of typeid(T).name() mangles the type name,\n  // so we have to demangle it.\n#   if GTEST_HAS_CXXABI_H_\n  using abi::__cxa_demangle;\n#   endif  // GTEST_HAS_CXXABI_H_\n  char* const readable_name = __cxa_demangle(name, 0, 0, &status);\n  const std::string name_str(status == 0 ? readable_name : name);\n  free(readable_name);\n  return name_str;\n#  else\n  return name;\n#  endif  // GTEST_HAS_CXXABI_H_ || __HP_aCC\n\n# else\n\n  return \"<type>\";\n\n# endif  // GTEST_HAS_RTTI\n}\n\n#if GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P\n\n// AssertyTypeEq<T1, T2>::type is defined iff T1 and T2 are the same\n// type.  This can be used as a compile-time assertion to ensure that\n// two types are equal.\n\ntemplate <typename T1, typename T2>\nstruct AssertTypeEq;\n\ntemplate <typename T>\nstruct AssertTypeEq<T, T> {\n  typedef bool type;\n};\n\n// A unique type used as the default value for the arguments of class\n// template Types.  This allows us to simulate variadic templates\n// (e.g. Types<int>, Type<int, double>, and etc), which C++ doesn't\n// support directly.\nstruct None {};\n\n// The following family of struct and struct templates are used to\n// represent type lists.  In particular, TypesN<T1, T2, ..., TN>\n// represents a type list with N types (T1, T2, ..., and TN) in it.\n// Except for Types0, every struct in the family has two member types:\n// Head for the first type in the list, and Tail for the rest of the\n// list.\n\n// The empty type list.\nstruct Types0 {};\n\n// Type lists of length 1, 2, 3, and so on.\n\ntemplate <typename T1>\nstruct Types1 {\n  typedef T1 Head;\n  typedef Types0 Tail;\n};\ntemplate <typename T1, typename T2>\nstruct Types2 {\n  typedef T1 Head;\n  typedef Types1<T2> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3>\nstruct Types3 {\n  typedef T1 Head;\n  typedef Types2<T2, T3> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4>\nstruct Types4 {\n  typedef T1 Head;\n  typedef Types3<T2, T3, T4> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5>\nstruct Types5 {\n  typedef T1 Head;\n  typedef Types4<T2, T3, T4, T5> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6>\nstruct Types6 {\n  typedef T1 Head;\n  typedef Types5<T2, T3, T4, T5, T6> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7>\nstruct Types7 {\n  typedef T1 Head;\n  typedef Types6<T2, T3, T4, T5, T6, T7> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8>\nstruct Types8 {\n  typedef T1 Head;\n  typedef Types7<T2, T3, T4, T5, T6, T7, T8> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9>\nstruct Types9 {\n  typedef T1 Head;\n  typedef Types8<T2, T3, T4, T5, T6, T7, T8, T9> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10>\nstruct Types10 {\n  typedef T1 Head;\n  typedef Types9<T2, T3, T4, T5, T6, T7, T8, T9, T10> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11>\nstruct Types11 {\n  typedef T1 Head;\n  typedef Types10<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12>\nstruct Types12 {\n  typedef T1 Head;\n  typedef Types11<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13>\nstruct Types13 {\n  typedef T1 Head;\n  typedef Types12<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14>\nstruct Types14 {\n  typedef T1 Head;\n  typedef Types13<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15>\nstruct Types15 {\n  typedef T1 Head;\n  typedef Types14<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16>\nstruct Types16 {\n  typedef T1 Head;\n  typedef Types15<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17>\nstruct Types17 {\n  typedef T1 Head;\n  typedef Types16<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18>\nstruct Types18 {\n  typedef T1 Head;\n  typedef Types17<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19>\nstruct Types19 {\n  typedef T1 Head;\n  typedef Types18<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20>\nstruct Types20 {\n  typedef T1 Head;\n  typedef Types19<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21>\nstruct Types21 {\n  typedef T1 Head;\n  typedef Types20<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22>\nstruct Types22 {\n  typedef T1 Head;\n  typedef Types21<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23>\nstruct Types23 {\n  typedef T1 Head;\n  typedef Types22<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24>\nstruct Types24 {\n  typedef T1 Head;\n  typedef Types23<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25>\nstruct Types25 {\n  typedef T1 Head;\n  typedef Types24<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26>\nstruct Types26 {\n  typedef T1 Head;\n  typedef Types25<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27>\nstruct Types27 {\n  typedef T1 Head;\n  typedef Types26<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28>\nstruct Types28 {\n  typedef T1 Head;\n  typedef Types27<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29>\nstruct Types29 {\n  typedef T1 Head;\n  typedef Types28<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30>\nstruct Types30 {\n  typedef T1 Head;\n  typedef Types29<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31>\nstruct Types31 {\n  typedef T1 Head;\n  typedef Types30<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32>\nstruct Types32 {\n  typedef T1 Head;\n  typedef Types31<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33>\nstruct Types33 {\n  typedef T1 Head;\n  typedef Types32<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34>\nstruct Types34 {\n  typedef T1 Head;\n  typedef Types33<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33, T34> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35>\nstruct Types35 {\n  typedef T1 Head;\n  typedef Types34<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33, T34, T35> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36>\nstruct Types36 {\n  typedef T1 Head;\n  typedef Types35<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33, T34, T35, T36> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37>\nstruct Types37 {\n  typedef T1 Head;\n  typedef Types36<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33, T34, T35, T36, T37> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38>\nstruct Types38 {\n  typedef T1 Head;\n  typedef Types37<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33, T34, T35, T36, T37, T38> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39>\nstruct Types39 {\n  typedef T1 Head;\n  typedef Types38<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40>\nstruct Types40 {\n  typedef T1 Head;\n  typedef Types39<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41>\nstruct Types41 {\n  typedef T1 Head;\n  typedef Types40<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42>\nstruct Types42 {\n  typedef T1 Head;\n  typedef Types41<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43>\nstruct Types43 {\n  typedef T1 Head;\n  typedef Types42<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,\n      T43> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44>\nstruct Types44 {\n  typedef T1 Head;\n  typedef Types43<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n      T44> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45>\nstruct Types45 {\n  typedef T1 Head;\n  typedef Types44<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n      T44, T45> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46>\nstruct Types46 {\n  typedef T1 Head;\n  typedef Types45<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n      T44, T45, T46> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47>\nstruct Types47 {\n  typedef T1 Head;\n  typedef Types46<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n      T44, T45, T46, T47> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47, typename T48>\nstruct Types48 {\n  typedef T1 Head;\n  typedef Types47<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n      T44, T45, T46, T47, T48> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47, typename T48, typename T49>\nstruct Types49 {\n  typedef T1 Head;\n  typedef Types48<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n      T44, T45, T46, T47, T48, T49> Tail;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47, typename T48, typename T49, typename T50>\nstruct Types50 {\n  typedef T1 Head;\n  typedef Types49<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n      T44, T45, T46, T47, T48, T49, T50> Tail;\n};\n\n\n}  // namespace internal\n\n// We don't want to require the users to write TypesN<...> directly,\n// as that would require them to count the length.  Types<...> is much\n// easier to write, but generates horrible messages when there is a\n// compiler error, as gcc insists on printing out each template\n// argument, even if it has the default value (this means Types<int>\n// will appear as Types<int, None, None, ..., None> in the compiler\n// errors).\n//\n// Our solution is to combine the best part of the two approaches: a\n// user would write Types<T1, ..., TN>, and Google Test will translate\n// that to TypesN<T1, ..., TN> internally to make error messages\n// readable.  The translation is done by the 'type' member of the\n// Types template.\ntemplate <typename T1 = internal::None, typename T2 = internal::None,\n    typename T3 = internal::None, typename T4 = internal::None,\n    typename T5 = internal::None, typename T6 = internal::None,\n    typename T7 = internal::None, typename T8 = internal::None,\n    typename T9 = internal::None, typename T10 = internal::None,\n    typename T11 = internal::None, typename T12 = internal::None,\n    typename T13 = internal::None, typename T14 = internal::None,\n    typename T15 = internal::None, typename T16 = internal::None,\n    typename T17 = internal::None, typename T18 = internal::None,\n    typename T19 = internal::None, typename T20 = internal::None,\n    typename T21 = internal::None, typename T22 = internal::None,\n    typename T23 = internal::None, typename T24 = internal::None,\n    typename T25 = internal::None, typename T26 = internal::None,\n    typename T27 = internal::None, typename T28 = internal::None,\n    typename T29 = internal::None, typename T30 = internal::None,\n    typename T31 = internal::None, typename T32 = internal::None,\n    typename T33 = internal::None, typename T34 = internal::None,\n    typename T35 = internal::None, typename T36 = internal::None,\n    typename T37 = internal::None, typename T38 = internal::None,\n    typename T39 = internal::None, typename T40 = internal::None,\n    typename T41 = internal::None, typename T42 = internal::None,\n    typename T43 = internal::None, typename T44 = internal::None,\n    typename T45 = internal::None, typename T46 = internal::None,\n    typename T47 = internal::None, typename T48 = internal::None,\n    typename T49 = internal::None, typename T50 = internal::None>\nstruct Types {\n  typedef internal::Types50<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\n      T41, T42, T43, T44, T45, T46, T47, T48, T49, T50> type;\n};\n\ntemplate <>\nstruct Types<internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None> {\n  typedef internal::Types0 type;\n};\ntemplate <typename T1>\nstruct Types<T1, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None> {\n  typedef internal::Types1<T1> type;\n};\ntemplate <typename T1, typename T2>\nstruct Types<T1, T2, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None> {\n  typedef internal::Types2<T1, T2> type;\n};\ntemplate <typename T1, typename T2, typename T3>\nstruct Types<T1, T2, T3, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None> {\n  typedef internal::Types3<T1, T2, T3> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4>\nstruct Types<T1, T2, T3, T4, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None> {\n  typedef internal::Types4<T1, T2, T3, T4> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5>\nstruct Types<T1, T2, T3, T4, T5, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None> {\n  typedef internal::Types5<T1, T2, T3, T4, T5> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6>\nstruct Types<T1, T2, T3, T4, T5, T6, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None> {\n  typedef internal::Types6<T1, T2, T3, T4, T5, T6> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None> {\n  typedef internal::Types7<T1, T2, T3, T4, T5, T6, T7> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None> {\n  typedef internal::Types8<T1, T2, T3, T4, T5, T6, T7, T8> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None> {\n  typedef internal::Types9<T1, T2, T3, T4, T5, T6, T7, T8, T9> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None> {\n  typedef internal::Types10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None> {\n  typedef internal::Types11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None> {\n  typedef internal::Types12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,\n      T12> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None> {\n  typedef internal::Types13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None> {\n  typedef internal::Types14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None> {\n  typedef internal::Types15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None> {\n  typedef internal::Types16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None> {\n  typedef internal::Types17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None> {\n  typedef internal::Types18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None> {\n  typedef internal::Types19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None> {\n  typedef internal::Types20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None> {\n  typedef internal::Types21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None> {\n  typedef internal::Types22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None> {\n  typedef internal::Types23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None> {\n  typedef internal::Types24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None> {\n  typedef internal::Types25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None> {\n  typedef internal::Types26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,\n      T26> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None> {\n  typedef internal::Types27<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None> {\n  typedef internal::Types28<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None> {\n  typedef internal::Types29<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None> {\n  typedef internal::Types30<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None> {\n  typedef internal::Types31<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None> {\n  typedef internal::Types32<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, T33, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None> {\n  typedef internal::Types33<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, T33, T34, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None> {\n  typedef internal::Types34<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, T33, T34, T35, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None> {\n  typedef internal::Types35<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34, T35> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, T33, T34, T35, T36, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None> {\n  typedef internal::Types36<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, T33, T34, T35, T36, T37, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None> {\n  typedef internal::Types37<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, T33, T34, T35, T36, T37, T38, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None> {\n  typedef internal::Types38<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, T33, T34, T35, T36, T37, T38, T39, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None> {\n  typedef internal::Types39<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None> {\n  typedef internal::Types40<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,\n      T40> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None, internal::None> {\n  typedef internal::Types41<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\n      T41> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, internal::None,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None> {\n  typedef internal::Types42<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\n      T41, T42> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None, internal::None> {\n  typedef internal::Types43<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\n      T41, T42, T43> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None, internal::None> {\n  typedef internal::Types44<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\n      T41, T42, T43, T44> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45,\n    internal::None, internal::None, internal::None, internal::None,\n    internal::None> {\n  typedef internal::Types45<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\n      T41, T42, T43, T44, T45> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45,\n    T46, internal::None, internal::None, internal::None, internal::None> {\n  typedef internal::Types46<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\n      T41, T42, T43, T44, T45, T46> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45,\n    T46, T47, internal::None, internal::None, internal::None> {\n  typedef internal::Types47<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\n      T41, T42, T43, T44, T45, T46, T47> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47, typename T48>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45,\n    T46, T47, T48, internal::None, internal::None> {\n  typedef internal::Types48<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\n      T41, T42, T43, T44, T45, T46, T47, T48> type;\n};\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47, typename T48, typename T49>\nstruct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,\n    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,\n    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45,\n    T46, T47, T48, T49, internal::None> {\n  typedef internal::Types49<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\n      T41, T42, T43, T44, T45, T46, T47, T48, T49> type;\n};\n\nnamespace internal {\n\n# define GTEST_TEMPLATE_ template <typename T> class\n\n// The template \"selector\" struct TemplateSel<Tmpl> is used to\n// represent Tmpl, which must be a class template with one type\n// parameter, as a type.  TemplateSel<Tmpl>::Bind<T>::type is defined\n// as the type Tmpl<T>.  This allows us to actually instantiate the\n// template \"selected\" by TemplateSel<Tmpl>.\n//\n// This trick is necessary for simulating typedef for class templates,\n// which C++ doesn't support directly.\ntemplate <GTEST_TEMPLATE_ Tmpl>\nstruct TemplateSel {\n  template <typename T>\n  struct Bind {\n    typedef Tmpl<T> type;\n  };\n};\n\n# define GTEST_BIND_(TmplSel, T) \\\n  TmplSel::template Bind<T>::type\n\n// A unique struct template used as the default value for the\n// arguments of class template Templates.  This allows us to simulate\n// variadic templates (e.g. Templates<int>, Templates<int, double>,\n// and etc), which C++ doesn't support directly.\ntemplate <typename T>\nstruct NoneT {};\n\n// The following family of struct and struct templates are used to\n// represent template lists.  In particular, TemplatesN<T1, T2, ...,\n// TN> represents a list of N templates (T1, T2, ..., and TN).  Except\n// for Templates0, every struct in the family has two member types:\n// Head for the selector of the first template in the list, and Tail\n// for the rest of the list.\n\n// The empty template list.\nstruct Templates0 {};\n\n// Template lists of length 1, 2, 3, and so on.\n\ntemplate <GTEST_TEMPLATE_ T1>\nstruct Templates1 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates0 Tail;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2>\nstruct Templates2 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates1<T2> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3>\nstruct Templates3 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates2<T2, T3> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4>\nstruct Templates4 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates3<T2, T3, T4> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5>\nstruct Templates5 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates4<T2, T3, T4, T5> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6>\nstruct Templates6 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates5<T2, T3, T4, T5, T6> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7>\nstruct Templates7 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates6<T2, T3, T4, T5, T6, T7> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8>\nstruct Templates8 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates7<T2, T3, T4, T5, T6, T7, T8> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9>\nstruct Templates9 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates8<T2, T3, T4, T5, T6, T7, T8, T9> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10>\nstruct Templates10 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates9<T2, T3, T4, T5, T6, T7, T8, T9, T10> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11>\nstruct Templates11 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates10<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12>\nstruct Templates12 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates11<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13>\nstruct Templates13 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates12<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14>\nstruct Templates14 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates13<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15>\nstruct Templates15 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates14<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16>\nstruct Templates16 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates15<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17>\nstruct Templates17 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates16<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18>\nstruct Templates18 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates17<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19>\nstruct Templates19 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates18<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20>\nstruct Templates20 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates19<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21>\nstruct Templates21 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates20<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22>\nstruct Templates22 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates21<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23>\nstruct Templates23 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates22<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24>\nstruct Templates24 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates23<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25>\nstruct Templates25 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates24<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26>\nstruct Templates26 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates25<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27>\nstruct Templates27 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates26<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28>\nstruct Templates28 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates27<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29>\nstruct Templates29 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates28<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30>\nstruct Templates30 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates29<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31>\nstruct Templates31 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates30<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32>\nstruct Templates32 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates31<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33>\nstruct Templates33 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates32<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34>\nstruct Templates34 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates33<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33, T34> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35>\nstruct Templates35 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates34<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33, T34, T35> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36>\nstruct Templates36 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates35<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33, T34, T35, T36> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37>\nstruct Templates37 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates36<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33, T34, T35, T36, T37> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38>\nstruct Templates38 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates37<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39>\nstruct Templates39 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates38<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40>\nstruct Templates40 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates39<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41>\nstruct Templates41 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates40<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42>\nstruct Templates42 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates41<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,\n      T42> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\n    GTEST_TEMPLATE_ T43>\nstruct Templates43 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates42<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,\n      T43> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\n    GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44>\nstruct Templates44 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates43<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,\n      T43, T44> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\n    GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44, GTEST_TEMPLATE_ T45>\nstruct Templates45 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates44<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,\n      T43, T44, T45> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\n    GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44, GTEST_TEMPLATE_ T45,\n    GTEST_TEMPLATE_ T46>\nstruct Templates46 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates45<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,\n      T43, T44, T45, T46> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\n    GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44, GTEST_TEMPLATE_ T45,\n    GTEST_TEMPLATE_ T46, GTEST_TEMPLATE_ T47>\nstruct Templates47 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates46<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,\n      T43, T44, T45, T46, T47> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\n    GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44, GTEST_TEMPLATE_ T45,\n    GTEST_TEMPLATE_ T46, GTEST_TEMPLATE_ T47, GTEST_TEMPLATE_ T48>\nstruct Templates48 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates47<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,\n      T43, T44, T45, T46, T47, T48> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\n    GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44, GTEST_TEMPLATE_ T45,\n    GTEST_TEMPLATE_ T46, GTEST_TEMPLATE_ T47, GTEST_TEMPLATE_ T48,\n    GTEST_TEMPLATE_ T49>\nstruct Templates49 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates48<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,\n      T43, T44, T45, T46, T47, T48, T49> Tail;\n};\n\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\n    GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44, GTEST_TEMPLATE_ T45,\n    GTEST_TEMPLATE_ T46, GTEST_TEMPLATE_ T47, GTEST_TEMPLATE_ T48,\n    GTEST_TEMPLATE_ T49, GTEST_TEMPLATE_ T50>\nstruct Templates50 {\n  typedef TemplateSel<T1> Head;\n  typedef Templates49<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,\n      T43, T44, T45, T46, T47, T48, T49, T50> Tail;\n};\n\n\n// We don't want to require the users to write TemplatesN<...> directly,\n// as that would require them to count the length.  Templates<...> is much\n// easier to write, but generates horrible messages when there is a\n// compiler error, as gcc insists on printing out each template\n// argument, even if it has the default value (this means Templates<list>\n// will appear as Templates<list, NoneT, NoneT, ..., NoneT> in the compiler\n// errors).\n//\n// Our solution is to combine the best part of the two approaches: a\n// user would write Templates<T1, ..., TN>, and Google Test will translate\n// that to TemplatesN<T1, ..., TN> internally to make error messages\n// readable.  The translation is done by the 'type' member of the\n// Templates template.\ntemplate <GTEST_TEMPLATE_ T1 = NoneT, GTEST_TEMPLATE_ T2 = NoneT,\n    GTEST_TEMPLATE_ T3 = NoneT, GTEST_TEMPLATE_ T4 = NoneT,\n    GTEST_TEMPLATE_ T5 = NoneT, GTEST_TEMPLATE_ T6 = NoneT,\n    GTEST_TEMPLATE_ T7 = NoneT, GTEST_TEMPLATE_ T8 = NoneT,\n    GTEST_TEMPLATE_ T9 = NoneT, GTEST_TEMPLATE_ T10 = NoneT,\n    GTEST_TEMPLATE_ T11 = NoneT, GTEST_TEMPLATE_ T12 = NoneT,\n    GTEST_TEMPLATE_ T13 = NoneT, GTEST_TEMPLATE_ T14 = NoneT,\n    GTEST_TEMPLATE_ T15 = NoneT, GTEST_TEMPLATE_ T16 = NoneT,\n    GTEST_TEMPLATE_ T17 = NoneT, GTEST_TEMPLATE_ T18 = NoneT,\n    GTEST_TEMPLATE_ T19 = NoneT, GTEST_TEMPLATE_ T20 = NoneT,\n    GTEST_TEMPLATE_ T21 = NoneT, GTEST_TEMPLATE_ T22 = NoneT,\n    GTEST_TEMPLATE_ T23 = NoneT, GTEST_TEMPLATE_ T24 = NoneT,\n    GTEST_TEMPLATE_ T25 = NoneT, GTEST_TEMPLATE_ T26 = NoneT,\n    GTEST_TEMPLATE_ T27 = NoneT, GTEST_TEMPLATE_ T28 = NoneT,\n    GTEST_TEMPLATE_ T29 = NoneT, GTEST_TEMPLATE_ T30 = NoneT,\n    GTEST_TEMPLATE_ T31 = NoneT, GTEST_TEMPLATE_ T32 = NoneT,\n    GTEST_TEMPLATE_ T33 = NoneT, GTEST_TEMPLATE_ T34 = NoneT,\n    GTEST_TEMPLATE_ T35 = NoneT, GTEST_TEMPLATE_ T36 = NoneT,\n    GTEST_TEMPLATE_ T37 = NoneT, GTEST_TEMPLATE_ T38 = NoneT,\n    GTEST_TEMPLATE_ T39 = NoneT, GTEST_TEMPLATE_ T40 = NoneT,\n    GTEST_TEMPLATE_ T41 = NoneT, GTEST_TEMPLATE_ T42 = NoneT,\n    GTEST_TEMPLATE_ T43 = NoneT, GTEST_TEMPLATE_ T44 = NoneT,\n    GTEST_TEMPLATE_ T45 = NoneT, GTEST_TEMPLATE_ T46 = NoneT,\n    GTEST_TEMPLATE_ T47 = NoneT, GTEST_TEMPLATE_ T48 = NoneT,\n    GTEST_TEMPLATE_ T49 = NoneT, GTEST_TEMPLATE_ T50 = NoneT>\nstruct Templates {\n  typedef Templates50<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,\n      T42, T43, T44, T45, T46, T47, T48, T49, T50> type;\n};\n\ntemplate <>\nstruct Templates<NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT> {\n  typedef Templates0 type;\n};\ntemplate <GTEST_TEMPLATE_ T1>\nstruct Templates<T1, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT> {\n  typedef Templates1<T1> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2>\nstruct Templates<T1, T2, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT> {\n  typedef Templates2<T1, T2> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3>\nstruct Templates<T1, T2, T3, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates3<T1, T2, T3> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4>\nstruct Templates<T1, T2, T3, T4, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates4<T1, T2, T3, T4> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5>\nstruct Templates<T1, T2, T3, T4, T5, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates5<T1, T2, T3, T4, T5> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6>\nstruct Templates<T1, T2, T3, T4, T5, T6, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates6<T1, T2, T3, T4, T5, T6> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates7<T1, T2, T3, T4, T5, T6, T7> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates8<T1, T2, T3, T4, T5, T6, T7, T8> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates9<T1, T2, T3, T4, T5, T6, T7, T8, T9> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT> {\n  typedef Templates22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT> {\n  typedef Templates23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT> {\n  typedef Templates24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT> {\n  typedef Templates25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT> {\n  typedef Templates26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT> {\n  typedef Templates27<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT> {\n  typedef Templates28<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT> {\n  typedef Templates29<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates30<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates31<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates32<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, T33, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates33<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, T33, T34, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates34<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33, T34> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, T33, T34, T35, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates35<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33, T34, T35> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, T33, T34, T35, T36, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates36<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33, T34, T35, T36> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, T33, T34, T35, T36, T37, NoneT, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates37<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, T33, T34, T35, T36, T37, T38, NoneT, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates38<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates39<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, NoneT, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates40<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, NoneT, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates41<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\n      T41> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, NoneT,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates42<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,\n      T42> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\n    GTEST_TEMPLATE_ T43>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates43<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,\n      T42, T43> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\n    GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44,\n    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates44<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,\n      T42, T43, T44> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\n    GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44, GTEST_TEMPLATE_ T45>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44,\n    T45, NoneT, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates45<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,\n      T42, T43, T44, T45> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\n    GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44, GTEST_TEMPLATE_ T45,\n    GTEST_TEMPLATE_ T46>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44,\n    T45, T46, NoneT, NoneT, NoneT, NoneT> {\n  typedef Templates46<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,\n      T42, T43, T44, T45, T46> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\n    GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44, GTEST_TEMPLATE_ T45,\n    GTEST_TEMPLATE_ T46, GTEST_TEMPLATE_ T47>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44,\n    T45, T46, T47, NoneT, NoneT, NoneT> {\n  typedef Templates47<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,\n      T42, T43, T44, T45, T46, T47> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\n    GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44, GTEST_TEMPLATE_ T45,\n    GTEST_TEMPLATE_ T46, GTEST_TEMPLATE_ T47, GTEST_TEMPLATE_ T48>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44,\n    T45, T46, T47, T48, NoneT, NoneT> {\n  typedef Templates48<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,\n      T42, T43, T44, T45, T46, T47, T48> type;\n};\ntemplate <GTEST_TEMPLATE_ T1, GTEST_TEMPLATE_ T2, GTEST_TEMPLATE_ T3,\n    GTEST_TEMPLATE_ T4, GTEST_TEMPLATE_ T5, GTEST_TEMPLATE_ T6,\n    GTEST_TEMPLATE_ T7, GTEST_TEMPLATE_ T8, GTEST_TEMPLATE_ T9,\n    GTEST_TEMPLATE_ T10, GTEST_TEMPLATE_ T11, GTEST_TEMPLATE_ T12,\n    GTEST_TEMPLATE_ T13, GTEST_TEMPLATE_ T14, GTEST_TEMPLATE_ T15,\n    GTEST_TEMPLATE_ T16, GTEST_TEMPLATE_ T17, GTEST_TEMPLATE_ T18,\n    GTEST_TEMPLATE_ T19, GTEST_TEMPLATE_ T20, GTEST_TEMPLATE_ T21,\n    GTEST_TEMPLATE_ T22, GTEST_TEMPLATE_ T23, GTEST_TEMPLATE_ T24,\n    GTEST_TEMPLATE_ T25, GTEST_TEMPLATE_ T26, GTEST_TEMPLATE_ T27,\n    GTEST_TEMPLATE_ T28, GTEST_TEMPLATE_ T29, GTEST_TEMPLATE_ T30,\n    GTEST_TEMPLATE_ T31, GTEST_TEMPLATE_ T32, GTEST_TEMPLATE_ T33,\n    GTEST_TEMPLATE_ T34, GTEST_TEMPLATE_ T35, GTEST_TEMPLATE_ T36,\n    GTEST_TEMPLATE_ T37, GTEST_TEMPLATE_ T38, GTEST_TEMPLATE_ T39,\n    GTEST_TEMPLATE_ T40, GTEST_TEMPLATE_ T41, GTEST_TEMPLATE_ T42,\n    GTEST_TEMPLATE_ T43, GTEST_TEMPLATE_ T44, GTEST_TEMPLATE_ T45,\n    GTEST_TEMPLATE_ T46, GTEST_TEMPLATE_ T47, GTEST_TEMPLATE_ T48,\n    GTEST_TEMPLATE_ T49>\nstruct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,\n    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,\n    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44,\n    T45, T46, T47, T48, T49, NoneT> {\n  typedef Templates49<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,\n      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,\n      T42, T43, T44, T45, T46, T47, T48, T49> type;\n};\n\n// The TypeList template makes it possible to use either a single type\n// or a Types<...> list in TYPED_TEST_CASE() and\n// INSTANTIATE_TYPED_TEST_CASE_P().\n\ntemplate <typename T>\nstruct TypeList {\n  typedef Types1<T> type;\n};\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10,\n    typename T11, typename T12, typename T13, typename T14, typename T15,\n    typename T16, typename T17, typename T18, typename T19, typename T20,\n    typename T21, typename T22, typename T23, typename T24, typename T25,\n    typename T26, typename T27, typename T28, typename T29, typename T30,\n    typename T31, typename T32, typename T33, typename T34, typename T35,\n    typename T36, typename T37, typename T38, typename T39, typename T40,\n    typename T41, typename T42, typename T43, typename T44, typename T45,\n    typename T46, typename T47, typename T48, typename T49, typename T50>\nstruct TypeList<Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,\n    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,\n    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,\n    T44, T45, T46, T47, T48, T49, T50> > {\n  typedef typename Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,\n      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,\n      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,\n      T41, T42, T43, T44, T45, T46, T47, T48, T49, T50>::type type;\n};\n\n#endif  // GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P\n\n}  // namespace internal\n}  // namespace testing\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_TYPE_UTIL_H_\n"}}, "reports": [{"events": [{"location": {"col": 9, "file": 0, "line": 12}, "message": "LLVM_CONFIG_ABI_BREAKING_H (fixit)"}, {"location": {"col": 9, "file": 0, "line": 12}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/build/include/llvm/Config/abi-breaking.h", "reportHash": "dcd0bfe3f0f210f7888a55f47c957f81", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 1, "line": 14}, "message": "LLVM_CONFIG_LLVM_CONFIG_H (fixit)"}, {"location": {"col": 9, "file": 1, "line": 14}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/build/include/llvm/Config/llvm-config.h", "reportHash": "98f65c4ad0c87858b0a342fb96bb5140", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 2, "line": 9}, "message": "LLVM_CLANG_TOOLS_EXTRA_CLANGD_COLLECTMACROS_H (fixit)"}, {"location": {"col": 9, "file": 2, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/CollectMacros.h", "reportHash": "21ef43118b583d5fa1eacd3d427ed212", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 3, "line": 18}, "message": "LLVM_CLANG_TOOLS_EXTRA_CLANGD_EXPECTEDTYPES_H (fixit)"}, {"location": {"col": 9, "file": 3, "line": 18}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/ExpectedTypes.h", "reportHash": "07b3e66ed4971710af27136439d92dc7", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 4, "line": 9}, "message": "LLVM_CLANG_TOOLS_EXTRA_CLANGD_HEURISTICRESOLVER_H (fixit)"}, {"location": {"col": 9, "file": 4, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/HeuristicResolver.h", "reportHash": "29fddabc8d8a21afe4fe76fe8ca10f4c", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 5, "line": 9}, "message": "LLVM_CLANG_TOOLS_EXTRA_CLANGD_URI_H (fixit)"}, {"location": {"col": 9, "file": 5, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/URI.h", "reportHash": "fd9082cbff4c88e8ae7c6f47d379ce77", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 6, "line": 14}, "message": "LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_BACKGROUNDREBUILD_H (fixit)"}, {"location": {"col": 9, "file": 6, "line": 14}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/BackgroundRebuild.h", "reportHash": "c1e794ebbb65d699576f02324de2bc9a", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 2, "file": 7, "line": 95}, "message": "endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_CANONICALINCLUDES_H (fixit)"}, {"location": {"col": 2, "file": 7, "line": 95}, "message": "#endif for a header guard should reference the guard macro in a comment"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/CanonicalIncludes.h", "reportHash": "c7483aeb5868f58c5229cb8f8277ecc2", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 8, "line": 24}, "message": "LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SERIALIZATION_H (fixit)"}, {"location": {"col": 9, "file": 8, "line": 24}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/Serialization.h", "reportHash": "501f813469f96b7a178770b09c082287", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 9, "line": 9}, "message": "LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOLLOCATION_H (fixit)"}, {"location": {"col": 9, "file": 9, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolLocation.h", "reportHash": "d97d833a1768b13cd883e9b69354ca59", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 10, "line": 9}, "message": "LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOLORIGIN_H (fixit)"}, {"location": {"col": 9, "file": 10, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolOrigin.h", "reportHash": "312cca1a410edb20d422f691227bd899", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 11, "line": 19}, "message": "LLVM_CLANG_TOOLS_EXTRA_CLANGD_REFACTOR_TWEAK_H (fixit)"}, {"location": {"col": 9, "file": 11, "line": 19}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/refactor/Tweak.h", "reportHash": "09f040d2738007a5bd9f23313611081d", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 12, "line": 15}, "message": "LLVM_CLANG_TOOLS_EXTRA_CLANGD_UNITTESTS_SYNCAPI_H (fixit)"}, {"location": {"col": 9, "file": 12, "line": 15}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/SyncAPI.h", "reportHash": "e15e3fb085b9c8e9fbd773d3012e6c73", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 13, "line": 12}, "message": "LLVM_CLANG_TOOLS_EXTRA_CLANGD_UNITTESTS_TESTFS_H (fixit)"}, {"location": {"col": 9, "file": 13, "line": 12}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/TestFS.h", "reportHash": "37bddab0b9dc4513d7b384dbb107fb60", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 14, "line": 9}, "message": "LLVM_CLANG_TOOLS_EXTRA_CLANGD_UNITTESTS_TESTINDEX_H (fixit)"}, {"location": {"col": 9, "file": 14, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/TestIndex.h", "reportHash": "83ba87a1fd7737edf2b1d66632263ade", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 15, "line": 17}, "message": "LLVM_CLANG_TOOLS_EXTRA_CLANGD_UNITTESTS_TESTTU_H (fixit)"}, {"location": {"col": 9, "file": 15, "line": 17}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/TestTU.h", "reportHash": "40166c6eb0a145dffc3bb0261bf3a0bf", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 2, "file": 16, "line": 152}, "message": "endif // LLVM_CLANG_C_BUILDSYSTEM_H (fixit)"}, {"location": {"col": 2, "file": 16, "line": 152}, "message": "#endif for a header guard should reference the guard macro in a comment"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang-c/BuildSystem.h", "reportHash": "12a2d32ebeeb367f8f9ef970ca0241d3", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 17, "line": 14}, "message": "LLVM_CLANG_C_EXTERNC_H (fixit)"}, {"location": {"col": 9, "file": 17, "line": 14}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang-c/ExternC.h", "reportHash": "c34df1a0462a9190dbcf9d48ff17ca47", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 18, "line": 13}, "message": "LLVM_CLANG_AST_COMPUTEDEPENDENCE_H (fixit)"}, {"location": {"col": 9, "file": 18, "line": 13}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ComputeDependence.h", "reportHash": "0db00063ef8e8d705909aa5fed3cd0b5", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 19, "line": 14}, "message": "LLVM_CLANG_AST_DECLOBJCCOMMON_H (fixit)"}, {"location": {"col": 9, "file": 19, "line": 14}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclObjCCommon.h", "reportHash": "f12b241182da40915f165cefbc3c9184", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 20, "line": 14}, "message": "LLVM_CLANG_ANALYSIS_BODYFARM_H (fixit)"}, {"location": {"col": 9, "file": 20, "line": 14}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/BodyFarm.h", "reportHash": "38d1915f79e10c948cf593a7e70b34fd", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 21, "line": 13}, "message": "LLVM_CLANG_ANALYSIS_PATHDIAGNOSTIC_H (fixit)"}, {"location": {"col": 9, "file": 21, "line": 13}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/PathDiagnostic.h", "reportHash": "252165277339c0d2700b8ecb3d6cd4c9", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 22, "line": 9}, "message": "LLVM_CLANG_BASIC_ATTRSUBJECTMATCHRULES_H (fixit)"}, {"location": {"col": 9, "file": 22, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/AttrSubjectMatchRules.h", "reportHash": "06544e11e7cae76976410aee8e04307c", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 23, "line": 71}, "message": "'clang/Basic/DiagnosticCommonKinds.inc' file not found"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h", "reportHash": "0212dcde1e4a793396a6f1f45b22be74", "checkerName": "clang-diagnostic-error", "reviewStatus": null, "severity": "CRITICAL"}, {"events": [{"location": {"col": 9, "file": 24, "line": 9}, "message": "LLVM_CLANG_BASIC_PRAGMAKINDS_H (fixit)"}, {"location": {"col": 9, "file": 24, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/PragmaKinds.h", "reportHash": "ef6b7f49c30fe1567341600932b6338f", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 25, "line": 13}, "message": "LLVM_CLANG_BASIC_PROFILELIST_H (fixit)"}, {"location": {"col": 9, "file": 25, "line": 13}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/ProfileList.h", "reportHash": "ad163c8604a8c5aa7f83d3e9d9d0e56b", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 26, "line": 9}, "message": "LLVM_CLANG_FRONTEND_PCHCONTAINEROPERATIONS_H (fixit)"}, {"location": {"col": 9, "file": 26, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/PCHContainerOperations.h", "reportHash": "f0e52a1348c3a1d65c64a1e1f75b2e72", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 27, "line": 13}, "message": "LLVM_CLANG_FRONTEND_PRECOMPILEDPREAMBLE_H (fixit)"}, {"location": {"col": 9, "file": 27, "line": 13}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Frontend/PrecompiledPreamble.h", "reportHash": "0c5e562717fef483e859d1cdf83773b9", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 28, "line": 9}, "message": "LLVM_CLANG_LEX_PREPROCESSOREXCLUDEDCONDITIONALDIRECTIVESKIPMAPPING_H (fixit)"}, {"location": {"col": 9, "file": 28, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/PreprocessorExcludedConditionalDirectiveSkipMapping.h", "reportHash": "d27d6de98cc05e20c80aedbedc4d0186", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 29, "line": 14}, "message": "LLVM_CLANG_SEMA_PARSEDATTR_H (fixit)"}, {"location": {"col": 9, "file": 29, "line": 14}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/ParsedAttr.h", "reportHash": "462f68bd264a7854ae12a3487b9022e3", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 2, "file": 30, "line": 155}, "message": "endif // LLVM_CLANG_SERIALIZATION_MODULEFILEEXTENSION_H (fixit)"}, {"location": {"col": 2, "file": 30, "line": 155}, "message": "#endif for a header guard should reference the guard macro in a comment"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ModuleFileExtension.h", "reportHash": "442d3a9b661653b63f00e66d09682050", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 31, "line": 38}, "message": "GMOCK_GMOCK_ACTIONS_H (fixit)"}, {"location": {"col": 9, "file": 31, "line": 38}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-actions.h", "reportHash": "bdf6ab7978c8b2afd1baf6e23e086d91", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 32, "line": 40}, "message": "GMOCK_GMOCK_CARDINALITIES_H (fixit)"}, {"location": {"col": 9, "file": 32, "line": 40}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-cardinalities.h", "reportHash": "8c950eba6313d34175f6cd5269c91939", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 33, "line": 40}, "message": "GMOCK_GMOCK_GENERATED_ACTIONS_H (fixit)"}, {"location": {"col": 9, "file": 33, "line": 40}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-generated-actions.h", "reportHash": "1c089cb2222d549136c939f5021afc0a", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 34, "line": 42}, "message": "GMOCK_GMOCK_GENERATED_FUNCTION_MOCKERS_H (fixit)"}, {"location": {"col": 9, "file": 34, "line": 42}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-generated-function-mockers.h", "reportHash": "d82c2db2facbd0f7652d2c3021196cf8", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 35, "line": 40}, "message": "GMOCK_GMOCK_GENERATED_MATCHERS_H (fixit)"}, {"location": {"col": 9, "file": 35, "line": 40}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-generated-matchers.h", "reportHash": "d8e7a27d2a5f53b02e4853c130943dfb", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 36, "line": 73}, "message": "GMOCK_GMOCK_GENERATED_NICE_STRICT_H (fixit)"}, {"location": {"col": 9, "file": 36, "line": 73}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-generated-nice-strict.h", "reportHash": "efa3882ca9a56817c4155599ff84a176", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 37, "line": 40}, "message": "GMOCK_GMOCK_MATCHERS_H (fixit)"}, {"location": {"col": 9, "file": 37, "line": 40}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-matchers.h", "reportHash": "a45d957dc682b82bf60b035ee7c65661", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 38, "line": 38}, "message": "GMOCK_GMOCK_MORE_ACTIONS_H (fixit)"}, {"location": {"col": 9, "file": 38, "line": 38}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-more-actions.h", "reportHash": "288740dce5d562a6a2b3530e7af06237", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 39, "line": 62}, "message": "GMOCK_GMOCK_SPEC_BUILDERS_H (fixit)"}, {"location": {"col": 9, "file": 39, "line": 62}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-spec-builders.h", "reportHash": "62305c8da491a836cb48549df43cff1c", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 40, "line": 36}, "message": "GMOCK_GMOCK_H (fixit)"}, {"location": {"col": 9, "file": 40, "line": 36}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock.h", "reportHash": "4283368660c67bd5c56f7ee89933bb78", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 41, "line": 5}, "message": "GMOCK_INTERNAL_CUSTOM_GMOCK_GENERATED_ACTIONS_H (fixit)"}, {"location": {"col": 9, "file": 41, "line": 5}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/internal/custom/gmock-generated-actions.h", "reportHash": "85fc4c5ce248070140a655e8b6b4df01", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 42, "line": 36}, "message": "GMOCK_INTERNAL_CUSTOM_GMOCK_MATCHERS_H (fixit)"}, {"location": {"col": 9, "file": 42, "line": 36}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/internal/custom/gmock-matchers.h", "reportHash": "66dcd17c5e096de4a3a2ef0b5978d189", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 43, "line": 43}, "message": "GMOCK_INTERNAL_CUSTOM_GMOCK_PORT_H (fixit)"}, {"location": {"col": 9, "file": 43, "line": 43}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/internal/custom/gmock-port.h", "reportHash": "a3d6dd74aad6915740b96e40d11993c6", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 44, "line": 43}, "message": "GMOCK_INTERNAL_GMOCK_GENERATED_INTERNAL_UTILS_H (fixit)"}, {"location": {"col": 9, "file": 44, "line": 43}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/internal/gmock-generated-internal-utils.h", "reportHash": "6b65bc7b971f6c97f77481bbd16307ee", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 45, "line": 40}, "message": "GMOCK_INTERNAL_GMOCK_INTERNAL_UTILS_H (fixit)"}, {"location": {"col": 9, "file": 45, "line": 40}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/internal/gmock-internal-utils.h", "reportHash": "699ce007fb3aa86fdaccc0b5e2d8743b", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 46, "line": 41}, "message": "GMOCK_INTERNAL_GMOCK_PORT_H (fixit)"}, {"location": {"col": 9, "file": 46, "line": 41}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/internal/gmock-port.h", "reportHash": "b4e1e4c0f5794994ee6b55f3dce95885", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 47, "line": 38}, "message": "GTEST_GTEST_DEATH_TEST_H (fixit)"}, {"location": {"col": 9, "file": 47, "line": 38}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest-death-test.h", "reportHash": "0f9c8fef16fd26978d8461339aafb709", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 48, "line": 46}, "message": "GTEST_GTEST_MESSAGE_H (fixit)"}, {"location": {"col": 9, "file": 48, "line": 46}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest-message.h", "reportHash": "22ff5011ed1b84cff7b34299096cd9bc", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 49, "line": 41}, "message": "GTEST_GTEST_PARAM_TEST_H (fixit)"}, {"location": {"col": 9, "file": 49, "line": 41}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest-param-test.h", "reportHash": "5708912d5f0135a86e364ddbef1d5182", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 50, "line": 95}, "message": "GTEST_GTEST_PRINTERS_H (fixit)"}, {"location": {"col": 9, "file": 50, "line": 95}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest-printers.h", "reportHash": "81e8bac70d7630d861551e9f2ebe82c2", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 51, "line": 33}, "message": "GTEST_GTEST_TEST_PART_H (fixit)"}, {"location": {"col": 9, "file": 51, "line": 33}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest-test-part.h", "reportHash": "e8afeb0b70a4464b8efecf7375972d1e", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 52, "line": 32}, "message": "GTEST_GTEST_TYPED_TEST_H (fixit)"}, {"location": {"col": 9, "file": 52, "line": 32}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest-typed-test.h", "reportHash": "166970ab85742833822957013de61bfa", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 53, "line": 51}, "message": "GTEST_GTEST_H (fixit)"}, {"location": {"col": 9, "file": 53, "line": 51}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest.h", "reportHash": "299868b061d8cfa1aa5f548263d243a5", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 54, "line": 35}, "message": "GTEST_GTEST_PRED_IMPL_H (fixit)"}, {"location": {"col": 9, "file": 54, "line": 35}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest_pred_impl.h", "reportHash": "c2044d357748af8686991a7c2af71183", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 55, "line": 34}, "message": "GTEST_GTEST_PROD_H (fixit)"}, {"location": {"col": 9, "file": 55, "line": 34}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest_prod.h", "reportHash": "f4c6dba233ddd0a5ac5717511d062351", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 56, "line": 66}, "message": "GTEST_INTERNAL_CUSTOM_GTEST_PORT_H (fixit)"}, {"location": {"col": 9, "file": 56, "line": 66}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/custom/gtest-port.h", "reportHash": "a5a0aa944e677addf3c0d81fc492e6a1", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 57, "line": 39}, "message": "GTEST_INTERNAL_CUSTOM_GTEST_PRINTERS_H (fixit)"}, {"location": {"col": 9, "file": 57, "line": 39}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/custom/gtest-printers.h", "reportHash": "608191229ff6290e963a244f7ff2c115", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 58, "line": 22}, "message": "GTEST_INTERNAL_CUSTOM_RAW_OSTREAM_H (fixit)"}, {"location": {"col": 9, "file": 58, "line": 22}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/custom/raw-ostream.h", "reportHash": "0d32f0413d9e8d41a5d1014dfd435c2f", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 59, "line": 37}, "message": "GTEST_INTERNAL_GTEST_DEATH_TEST_INTERNAL_H (fixit)"}, {"location": {"col": 9, "file": 59, "line": 37}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-death-test-internal.h", "reportHash": "0a2f2a83f2165ab67b3751bab3b043f5", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 60, "line": 40}, "message": "GTEST_INTERNAL_GTEST_FILEPATH_H (fixit)"}, {"location": {"col": 9, "file": 60, "line": 40}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-filepath.h", "reportHash": "047f91a0b9435e12b0a8e6614143d05b", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 61, "line": 37}, "message": "GTEST_INTERNAL_GTEST_INTERNAL_H (fixit)"}, {"location": {"col": 9, "file": 61, "line": 37}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-internal.h", "reportHash": "7ea79cd4129edb8574d251ddddaaf548", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 62, "line": 68}, "message": "GTEST_INTERNAL_GTEST_LINKED_PTR_H (fixit)"}, {"location": {"col": 9, "file": 62, "line": 68}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-linked_ptr.h", "reportHash": "ef6eb26fa783c73c00b31b58f6767165", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 63, "line": 46}, "message": "GTEST_INTERNAL_GTEST_PARAM_UTIL_GENERATED_H (fixit)"}, {"location": {"col": 9, "file": 63, "line": 46}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-param-util-generated.h", "reportHash": "412c0e17fa03a230a3a8fbc8f2bded23", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 64, "line": 34}, "message": "GTEST_INTERNAL_GTEST_PARAM_UTIL_H (fixit)"}, {"location": {"col": 9, "file": 64, "line": 34}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-param-util.h", "reportHash": "7b733f5fa62cf074a277d1a828582abd", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 65, "line": 35}, "message": "GTEST_INTERNAL_GTEST_PORT_ARCH_H (fixit)"}, {"location": {"col": 9, "file": 65, "line": 35}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-port-arch.h", "reportHash": "826520d67760ee4eb212377f2ec5e0f3", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 66, "line": 43}, "message": "GTEST_INTERNAL_GTEST_PORT_H (fixit)"}, {"location": {"col": 9, "file": 66, "line": 43}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-port.h", "reportHash": "7583ff9565b7178acd246bfe7cf23401", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 67, "line": 41}, "message": "GTEST_INTERNAL_GTEST_STRING_H (fixit)"}, {"location": {"col": 9, "file": 67, "line": 41}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-string.h", "reportHash": "46d88a3a98b4b07b676c0aa20b2c7dea", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 68, "line": 44}, "message": "GTEST_INTERNAL_GTEST_TYPE_UTIL_H (fixit)"}, {"location": {"col": 9, "file": 68, "line": 44}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-type-util.h", "reportHash": "658954e9e2a2953373515d7e6970101a", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
