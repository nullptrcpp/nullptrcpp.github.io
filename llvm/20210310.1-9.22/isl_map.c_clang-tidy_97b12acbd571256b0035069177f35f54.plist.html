<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "content": "/*\n * Copyright 2008-2009 Katholieke Universiteit Leuven\n * Copyright 2010      INRIA Saclay\n * Copyright 2012-2014 Ecole Normale Superieure\n * Copyright 2014      INRIA Rocquencourt\n * Copyright 2016      INRIA Paris\n * Copyright 2016      Sven Verdoolaege\n * Copyright 2018-2019 Cerebras Systems\n *\n * Use of this software is governed by the MIT license\n *\n * Written by Sven Verdoolaege, K.U.Leuven, Departement\n * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium\n * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,\n * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France \n * and Ecole Normale Superieure, 45 rue d\u2019Ulm, 75230 Paris, France\n * and Inria Paris - Rocquencourt, Domaine de Voluceau - Rocquencourt,\n * B.P. 105 - 78153 Le Chesnay, France\n * and Centre de Recherche Inria de Paris, 2 rue Simone Iff - Voie DQ12,\n * CS 42112, 75589 Paris Cedex 12, France\n * and Cerebras Systems, 175 S San Antonio Rd, Los Altos, CA, USA\n */\n\n#include <string.h>\n#include <isl_ctx_private.h>\n#include <isl_map_private.h>\n#include <isl_blk.h>\n#include <isl_id_private.h>\n#include <isl/constraint.h>\n#include \"isl_space_private.h\"\n#include \"isl_equalities.h\"\n#include <isl_lp_private.h>\n#include <isl_seq.h>\n#include <isl/set.h>\n#include <isl/map.h>\n#include <isl_reordering.h>\n#include \"isl_sample.h\"\n#include <isl_sort.h>\n#include \"isl_tab.h\"\n#include <isl/vec.h>\n#include <isl_mat_private.h>\n#include <isl_vec_private.h>\n#include <isl_dim_map.h>\n#include <isl_local_space_private.h>\n#include <isl_aff_private.h>\n#include <isl_options_private.h>\n#include <isl_morph.h>\n#include <isl_val_private.h>\n#include <isl_printer_private.h>\n\n#include <bset_to_bmap.c>\n#include <bset_from_bmap.c>\n#include <set_to_map.c>\n#include <set_from_map.c>\n\n/* Treat \"bset\" as a basic map.\n * Internally, isl_basic_set is defined to isl_basic_map, so in practice,\n * this function performs a redundant cast.\n */\nstatic __isl_keep const isl_basic_map *const_bset_to_bmap(\n\t__isl_keep const isl_basic_set *bset)\n{\n\treturn (const isl_basic_map *) bset;\n}\n\n#undef TYPE\n#define TYPE\tisl_basic_map\n#include \"has_single_reference_templ.c\"\n\nstatic unsigned pos(__isl_keep isl_space *space, enum isl_dim_type type)\n{\n\tswitch (type) {\n\tcase isl_dim_param:\treturn 1;\n\tcase isl_dim_in:\treturn 1 + space->nparam;\n\tcase isl_dim_out:\treturn 1 + space->nparam + space->n_in;\n\tdefault:\t\treturn 0;\n\t}\n}\n\nisl_size isl_basic_map_dim(__isl_keep isl_basic_map *bmap,\n\t\t\t\tenum isl_dim_type type)\n{\n\tif (!bmap)\n\t\treturn isl_size_error;\n\tswitch (type) {\n\tcase isl_dim_cst:\treturn 1;\n\tcase isl_dim_param:\n\tcase isl_dim_in:\n\tcase isl_dim_out:\treturn isl_space_dim(bmap->dim, type);\n\tcase isl_dim_div:\treturn bmap->n_div;\n\tcase isl_dim_all:\treturn isl_basic_map_total_dim(bmap);\n\tdefault:\t\treturn 0;\n\t}\n}\n\n/* Return the space of \"map\".\n */\n__isl_keep isl_space *isl_map_peek_space(__isl_keep const isl_map *map)\n{\n\treturn map ? map->dim : NULL;\n}\n\n/* Return the space of \"set\".\n */\n__isl_keep isl_space *isl_set_peek_space(__isl_keep isl_set *set)\n{\n\treturn isl_map_peek_space(set_to_map(set));\n}\n\nisl_size isl_map_dim(__isl_keep isl_map *map, enum isl_dim_type type)\n{\n\treturn isl_space_dim(isl_map_peek_space(map), type);\n}\n\nisl_size isl_set_dim(__isl_keep isl_set *set, enum isl_dim_type type)\n{\n\treturn isl_map_dim(set_to_map(set), type);\n}\n\n/* Return the position of the variables of the given type\n * within the sequence of variables of \"bmap\".\n */\nisl_size isl_basic_map_var_offset(__isl_keep isl_basic_map *bmap,\n\tenum isl_dim_type type)\n{\n\tisl_space *space;\n\n\tspace = isl_basic_map_peek_space(bmap);\n\tif (!space)\n\t\treturn isl_size_error;\n\n\tswitch (type) {\n\tcase isl_dim_param:\n\tcase isl_dim_in:\n\tcase isl_dim_out:\treturn isl_space_offset(space, type);\n\tcase isl_dim_div:\treturn isl_space_dim(space, isl_dim_all);\n\tcase isl_dim_cst:\n\tdefault:\n\t\tisl_die(isl_basic_map_get_ctx(bmap), isl_error_invalid,\n\t\t\t\"invalid dimension type\", return isl_size_error);\n\t}\n}\n\n/* Return the position of the variables of the given type\n * within the sequence of variables of \"bset\".\n */\nisl_size isl_basic_set_var_offset(__isl_keep isl_basic_set *bset,\n\tenum isl_dim_type type)\n{\n\treturn isl_basic_map_var_offset(bset_to_bmap(bset), type);\n}\n\n/* Return the position of the coefficients of the variables of the given type\n * within the sequence of coefficients of \"bmap\".\n */\nunsigned isl_basic_map_offset(__isl_keep isl_basic_map *bmap,\n\tenum isl_dim_type type)\n{\n\tswitch (type) {\n\tcase isl_dim_cst:\treturn 0;\n\tcase isl_dim_param:\n\tcase isl_dim_in:\n\tcase isl_dim_out:\n\tcase isl_dim_div:\treturn 1 + isl_basic_map_var_offset(bmap, type);\n\tdefault:\t\treturn 0;\n\t}\n}\n\nunsigned isl_basic_set_offset(__isl_keep isl_basic_set *bset,\n\t\t\t\t\tenum isl_dim_type type)\n{\n\treturn isl_basic_map_offset(bset, type);\n}\n\nstatic unsigned map_offset(__isl_keep isl_map *map, enum isl_dim_type type)\n{\n\treturn pos(map->dim, type);\n}\n\nisl_size isl_basic_set_dim(__isl_keep isl_basic_set *bset,\n\t\t\t\tenum isl_dim_type type)\n{\n\treturn isl_basic_map_dim(bset, type);\n}\n\nisl_size isl_basic_set_n_dim(__isl_keep isl_basic_set *bset)\n{\n\treturn isl_basic_set_dim(bset, isl_dim_set);\n}\n\nisl_size isl_basic_set_n_param(__isl_keep isl_basic_set *bset)\n{\n\treturn isl_basic_set_dim(bset, isl_dim_param);\n}\n\nisl_size isl_basic_set_total_dim(__isl_keep const isl_basic_set *bset)\n{\n\treturn isl_basic_map_total_dim(const_bset_to_bmap(bset));\n}\n\nisl_size isl_set_n_dim(__isl_keep isl_set *set)\n{\n\treturn isl_set_dim(set, isl_dim_set);\n}\n\nisl_size isl_set_n_param(__isl_keep isl_set *set)\n{\n\treturn isl_set_dim(set, isl_dim_param);\n}\n\nisl_size isl_basic_map_total_dim(__isl_keep const isl_basic_map *bmap)\n{\n\tisl_size dim;\n\n\tif (!bmap)\n\t\treturn isl_size_error;\n\tdim = isl_space_dim(bmap->dim, isl_dim_all);\n\tif (dim < 0)\n\t\treturn isl_size_error;\n\treturn dim + bmap->n_div;\n}\n\n/* Return the number of equality constraints in the description of \"bmap\".\n * Return isl_size_error on error.\n */\nisl_size isl_basic_map_n_equality(__isl_keep isl_basic_map *bmap)\n{\n\tif (!bmap)\n\t\treturn isl_size_error;\n\treturn bmap->n_eq;\n}\n\n/* Return the number of equality constraints in the description of \"bset\".\n * Return isl_size_error on error.\n */\nisl_size isl_basic_set_n_equality(__isl_keep isl_basic_set *bset)\n{\n\treturn isl_basic_map_n_equality(bset_to_bmap(bset));\n}\n\n/* Return the number of inequality constraints in the description of \"bmap\".\n * Return isl_size_error on error.\n */\nisl_size isl_basic_map_n_inequality(__isl_keep isl_basic_map *bmap)\n{\n\tif (!bmap)\n\t\treturn isl_size_error;\n\treturn bmap->n_ineq;\n}\n\n/* Return the number of inequality constraints in the description of \"bset\".\n * Return isl_size_error on error.\n */\nisl_size isl_basic_set_n_inequality(__isl_keep isl_basic_set *bset)\n{\n\treturn isl_basic_map_n_inequality(bset_to_bmap(bset));\n}\n\n/* Do \"bmap1\" and \"bmap2\" have the same parameters?\n */\nstatic isl_bool isl_basic_map_has_equal_params(__isl_keep isl_basic_map *bmap1,\n\t__isl_keep isl_basic_map *bmap2)\n{\n\tisl_space *space1, *space2;\n\n\tspace1 = isl_basic_map_peek_space(bmap1);\n\tspace2 = isl_basic_map_peek_space(bmap2);\n\treturn isl_space_has_equal_params(space1, space2);\n}\n\n/* Do \"map1\" and \"map2\" have the same parameters?\n */\nisl_bool isl_map_has_equal_params(__isl_keep isl_map *map1,\n\t__isl_keep isl_map *map2)\n{\n\tisl_space *space1, *space2;\n\n\tspace1 = isl_map_peek_space(map1);\n\tspace2 = isl_map_peek_space(map2);\n\treturn isl_space_has_equal_params(space1, space2);\n}\n\n/* Do \"map\" and \"set\" have the same parameters?\n */\nstatic isl_bool isl_map_set_has_equal_params(__isl_keep isl_map *map,\n\t__isl_keep isl_set *set)\n{\n\treturn isl_map_has_equal_params(map, set_to_map(set));\n}\n\n/* Is the tuple of type \"type\" of \"bmap\" the same as the single tuple of \"bset\"?\n */\nstatic isl_bool isl_basic_map_set_tuple_is_equal(__isl_keep isl_basic_map *bmap,\n\tenum isl_dim_type type, __isl_keep isl_basic_set *bset)\n{\n\tisl_space *bmap_space, *bset_space;\n\n\tbmap_space = isl_basic_map_peek_space(bmap);\n\tbset_space = isl_basic_set_peek_space(bset);\n\treturn isl_space_tuple_is_equal(bmap_space, type,\n\t\t\t\t\tbset_space, isl_dim_set);\n}\n\n/* Is the tuple of type \"type\" of \"map\" the same as the single tuple of \"set\"?\n */\nstatic isl_bool isl_map_set_tuple_is_equal(__isl_keep isl_map *map,\n\tenum isl_dim_type type, __isl_keep isl_set *set)\n{\n\treturn isl_map_tuple_is_equal(map, type, set_to_map(set), isl_dim_set);\n}\n\nisl_bool isl_map_compatible_domain(__isl_keep isl_map *map,\n\t__isl_keep isl_set *set)\n{\n\tisl_bool m;\n\tif (!map || !set)\n\t\treturn isl_bool_error;\n\tm = isl_map_has_equal_params(map, set_to_map(set));\n\tif (m < 0 || !m)\n\t\treturn m;\n\treturn isl_map_set_tuple_is_equal(map, isl_dim_in, set);\n}\n\nisl_bool isl_basic_map_compatible_domain(__isl_keep isl_basic_map *bmap,\n\t__isl_keep isl_basic_set *bset)\n{\n\tisl_bool m;\n\tif (!bmap || !bset)\n\t\treturn isl_bool_error;\n\tm = isl_basic_map_has_equal_params(bmap, bset_to_bmap(bset));\n\tif (m < 0 || !m)\n\t\treturn m;\n\treturn isl_basic_map_set_tuple_is_equal(bmap, isl_dim_in, bset);\n}\n\nisl_bool isl_map_compatible_range(__isl_keep isl_map *map,\n\t__isl_keep isl_set *set)\n{\n\tisl_bool m;\n\tif (!map || !set)\n\t\treturn isl_bool_error;\n\tm = isl_map_has_equal_params(map, set_to_map(set));\n\tif (m < 0 || !m)\n\t\treturn m;\n\treturn isl_map_set_tuple_is_equal(map, isl_dim_out, set);\n}\n\nisl_bool isl_basic_map_compatible_range(__isl_keep isl_basic_map *bmap,\n\t__isl_keep isl_basic_set *bset)\n{\n\tisl_bool m;\n\tif (!bmap || !bset)\n\t\treturn isl_bool_error;\n\tm = isl_basic_map_has_equal_params(bmap, bset_to_bmap(bset));\n\tif (m < 0 || !m)\n\t\treturn m;\n\treturn isl_basic_map_set_tuple_is_equal(bmap, isl_dim_out, bset);\n}\n\nisl_ctx *isl_basic_map_get_ctx(__isl_keep isl_basic_map *bmap)\n{\n\treturn bmap ? bmap->ctx : NULL;\n}\n\nisl_ctx *isl_basic_set_get_ctx(__isl_keep isl_basic_set *bset)\n{\n\treturn bset ? bset->ctx : NULL;\n}\n\nisl_ctx *isl_map_get_ctx(__isl_keep isl_map *map)\n{\n\treturn map ? map->ctx : NULL;\n}\n\nisl_ctx *isl_set_get_ctx(__isl_keep isl_set *set)\n{\n\treturn set ? set->ctx : NULL;\n}\n\n/* Return the space of \"bmap\".\n */\n__isl_keep isl_space *isl_basic_map_peek_space(\n\t__isl_keep const isl_basic_map *bmap)\n{\n\treturn bmap ? bmap->dim : NULL;\n}\n\n/* Return the space of \"bset\".\n */\n__isl_keep isl_space *isl_basic_set_peek_space(__isl_keep isl_basic_set *bset)\n{\n\treturn isl_basic_map_peek_space(bset_to_bmap(bset));\n}\n\n__isl_give isl_space *isl_basic_map_get_space(__isl_keep isl_basic_map *bmap)\n{\n\treturn isl_space_copy(isl_basic_map_peek_space(bmap));\n}\n\n__isl_give isl_space *isl_basic_set_get_space(__isl_keep isl_basic_set *bset)\n{\n\treturn isl_basic_map_get_space(bset_to_bmap(bset));\n}\n\n/* Return the space of \"bmap\".\n * This may be either a copy or the space itself\n * if there is only one reference to \"bmap\".\n * This allows the space to be modified inplace\n * if both the basic map and its space have only a single reference.\n * The caller is not allowed to modify \"bmap\" between this call and\n * a subsequent call to isl_basic_map_restore_space.\n * The only exception is that isl_basic_map_free can be called instead.\n */\nstatic __isl_give isl_space *isl_basic_map_take_space(\n\t__isl_keep isl_basic_map *bmap)\n{\n\tisl_space *space;\n\n\tif (!bmap)\n\t\treturn NULL;\n\tif (bmap->ref != 1)\n\t\treturn isl_basic_map_get_space(bmap);\n\tspace = bmap->dim;\n\tbmap->dim = NULL;\n\treturn space;\n}\n\n/* Set the space of \"bmap\" to \"space\", where the space of \"bmap\" may be missing\n * due to a preceding call to isl_basic_map_take_space.\n * However, in this case, \"bmap\" only has a single reference and\n * then the call to isl_basic_map_cow has no effect.\n */\nstatic __isl_give isl_basic_map *isl_basic_map_restore_space(\n\t__isl_take isl_basic_map *bmap, __isl_take isl_space *space)\n{\n\tif (!bmap || !space)\n\t\tgoto error;\n\n\tif (bmap->dim == space) {\n\t\tisl_space_free(space);\n\t\treturn bmap;\n\t}\n\n\tbmap = isl_basic_map_cow(bmap);\n\tif (!bmap)\n\t\tgoto error;\n\tisl_space_free(bmap->dim);\n\tbmap->dim = space;\n\n\treturn bmap;\nerror:\n\tisl_basic_map_free(bmap);\n\tisl_space_free(space);\n\treturn NULL;\n}\n\n/* Extract the divs in \"bmap\" as a matrix.\n */\n__isl_give isl_mat *isl_basic_map_get_divs(__isl_keep isl_basic_map *bmap)\n{\n\tint i;\n\tisl_ctx *ctx;\n\tisl_mat *div;\n\tisl_size v_div;\n\tunsigned cols;\n\n\tv_div = isl_basic_map_var_offset(bmap, isl_dim_div);\n\tif (v_div < 0)\n\t\treturn NULL;\n\n\tctx = isl_basic_map_get_ctx(bmap);\n\tcols = 1 + 1 + v_div + bmap->n_div;\n\tdiv = isl_mat_alloc(ctx, bmap->n_div, cols);\n\tif (!div)\n\t\treturn NULL;\n\n\tfor (i = 0; i < bmap->n_div; ++i)\n\t\tisl_seq_cpy(div->row[i], bmap->div[i], cols);\n\n\treturn div;\n}\n\n/* Extract the divs in \"bset\" as a matrix.\n */\n__isl_give isl_mat *isl_basic_set_get_divs(__isl_keep isl_basic_set *bset)\n{\n\treturn isl_basic_map_get_divs(bset);\n}\n\n__isl_give isl_local_space *isl_basic_map_get_local_space(\n\t__isl_keep isl_basic_map *bmap)\n{\n\tisl_mat *div;\n\n\tif (!bmap)\n\t\treturn NULL;\n\n\tdiv = isl_basic_map_get_divs(bmap);\n\treturn isl_local_space_alloc_div(isl_space_copy(bmap->dim), div);\n}\n\n__isl_give isl_local_space *isl_basic_set_get_local_space(\n\t__isl_keep isl_basic_set *bset)\n{\n\treturn isl_basic_map_get_local_space(bset);\n}\n\n/* For each known div d = floor(f/m), add the constraints\n *\n *\t\tf - m d >= 0\n *\t\t-(f-(m-1)) + m d >= 0\n *\n * Do not finalize the result.\n */\nstatic __isl_give isl_basic_map *add_known_div_constraints(\n\t__isl_take isl_basic_map *bmap)\n{\n\tint i;\n\tisl_size n_div;\n\n\tn_div = isl_basic_map_dim(bmap, isl_dim_div);\n\tif (n_div < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tif (n_div == 0)\n\t\treturn bmap;\n\tbmap = isl_basic_map_cow(bmap);\n\tbmap = isl_basic_map_extend_constraints(bmap, 0, 2 * n_div);\n\tif (!bmap)\n\t\treturn NULL;\n\tfor (i = 0; i < n_div; ++i) {\n\t\tif (isl_int_is_zero(bmap->div[i][0]))\n\t\t\tcontinue;\n\t\tbmap = isl_basic_map_add_div_constraints(bmap, i);\n\t}\n\n\treturn bmap;\n}\n\n__isl_give isl_basic_map *isl_basic_map_from_local_space(\n\t__isl_take isl_local_space *ls)\n{\n\tint i;\n\tisl_size n_div;\n\tisl_basic_map *bmap;\n\n\tn_div = isl_local_space_dim(ls, isl_dim_div);\n\tif (n_div < 0)\n\t\tls = isl_local_space_free(ls);\n\tif (!ls)\n\t\treturn NULL;\n\n\tbmap = isl_basic_map_alloc_space(isl_local_space_get_space(ls),\n\t\t\t\t\tn_div, 0, 2 * n_div);\n\n\tfor (i = 0; i < n_div; ++i)\n\t\tif (isl_basic_map_alloc_div(bmap) < 0)\n\t\t\tgoto error;\n\n\tfor (i = 0; i < n_div; ++i)\n\t\tisl_seq_cpy(bmap->div[i], ls->div->row[i], ls->div->n_col);\n\tbmap = add_known_div_constraints(bmap);\n\t\t\t\t\t\n\tisl_local_space_free(ls);\n\treturn bmap;\nerror:\n\tisl_local_space_free(ls);\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n__isl_give isl_basic_set *isl_basic_set_from_local_space(\n\t__isl_take isl_local_space *ls)\n{\n\treturn isl_basic_map_from_local_space(ls);\n}\n\n__isl_give isl_space *isl_map_get_space(__isl_keep isl_map *map)\n{\n\treturn isl_space_copy(isl_map_peek_space(map));\n}\n\n__isl_give isl_space *isl_set_get_space(__isl_keep isl_set *set)\n{\n\tif (!set)\n\t\treturn NULL;\n\treturn isl_space_copy(set->dim);\n}\n\n/* Return the space of \"map\".\n * This may be either a copy or the space itself\n * if there is only one reference to \"map\".\n * This allows the space to be modified inplace\n * if both the map and its space have only a single reference.\n * The caller is not allowed to modify \"map\" between this call and\n * a subsequent call to isl_map_restore_space.\n * The only exception is that isl_map_free can be called instead.\n */\nstatic __isl_give isl_space *isl_map_take_space(__isl_keep isl_map *map)\n{\n\tisl_space *space;\n\n\tif (!map)\n\t\treturn NULL;\n\tif (map->ref != 1)\n\t\treturn isl_map_get_space(map);\n\tspace = map->dim;\n\tmap->dim = NULL;\n\treturn space;\n}\n\n/* Set the space of \"map\" to \"space\", where the space of \"map\" may be missing\n * due to a preceding call to isl_map_take_space.\n * However, in this case, \"map\" only has a single reference and\n * then the call to isl_map_cow has no effect.\n */\nstatic __isl_give isl_map *isl_map_restore_space(__isl_take isl_map *map,\n\t__isl_take isl_space *space)\n{\n\tif (!map || !space)\n\t\tgoto error;\n\n\tif (map->dim == space) {\n\t\tisl_space_free(space);\n\t\treturn map;\n\t}\n\n\tmap = isl_map_cow(map);\n\tif (!map)\n\t\tgoto error;\n\tisl_space_free(map->dim);\n\tmap->dim = space;\n\n\treturn map;\nerror:\n\tisl_map_free(map);\n\tisl_space_free(space);\n\treturn NULL;\n}\n\n__isl_give isl_basic_map *isl_basic_map_set_tuple_name(\n\t__isl_take isl_basic_map *bmap, enum isl_dim_type type, const char *s)\n{\n\tisl_space *space;\n\n\tspace = isl_basic_map_take_space(bmap);\n\tspace = isl_space_set_tuple_name(space, type, s);\n\tbmap = isl_basic_map_restore_space(bmap, space);\n\tbmap = isl_basic_map_finalize(bmap);\n\treturn bmap;\n}\n\n__isl_give isl_basic_set *isl_basic_set_set_tuple_name(\n\t__isl_take isl_basic_set *bset, const char *s)\n{\n\treturn isl_basic_map_set_tuple_name(bset, isl_dim_set, s);\n}\n\nconst char *isl_basic_map_get_tuple_name(__isl_keep isl_basic_map *bmap,\n\tenum isl_dim_type type)\n{\n\treturn bmap ? isl_space_get_tuple_name(bmap->dim, type) : NULL;\n}\n\n__isl_give isl_map *isl_map_set_tuple_name(__isl_take isl_map *map,\n\tenum isl_dim_type type, const char *s)\n{\n\tint i;\n\tisl_space *space;\n\n\tmap = isl_map_cow(map);\n\tif (!map)\n\t\treturn NULL;\n\n\tfor (i = 0; i < map->n; ++i) {\n\t\tmap->p[i] = isl_basic_map_set_tuple_name(map->p[i], type, s);\n\t\tif (!map->p[i])\n\t\t\tgoto error;\n\t}\n\n\tspace = isl_map_take_space(map);\n\tspace = isl_space_set_tuple_name(space, type, s);\n\tmap = isl_map_restore_space(map, space);\n\n\treturn map;\nerror:\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n/* Replace the identifier of the tuple of type \"type\" by \"id\".\n */\n__isl_give isl_basic_map *isl_basic_map_set_tuple_id(\n\t__isl_take isl_basic_map *bmap,\n\tenum isl_dim_type type, __isl_take isl_id *id)\n{\n\tisl_space *space;\n\n\tspace = isl_basic_map_take_space(bmap);\n\tspace = isl_space_set_tuple_id(space, type, id);\n\tbmap = isl_basic_map_restore_space(bmap, space);\n\tbmap = isl_basic_map_finalize(bmap);\n\treturn bmap;\n}\n\n/* Replace the identifier of the tuple by \"id\".\n */\n__isl_give isl_basic_set *isl_basic_set_set_tuple_id(\n\t__isl_take isl_basic_set *bset, __isl_take isl_id *id)\n{\n\treturn isl_basic_map_set_tuple_id(bset, isl_dim_set, id);\n}\n\n/* Does the input or output tuple have a name?\n */\nisl_bool isl_map_has_tuple_name(__isl_keep isl_map *map, enum isl_dim_type type)\n{\n\treturn map ? isl_space_has_tuple_name(map->dim, type) : isl_bool_error;\n}\n\nconst char *isl_map_get_tuple_name(__isl_keep isl_map *map,\n\tenum isl_dim_type type)\n{\n\treturn map ? isl_space_get_tuple_name(map->dim, type) : NULL;\n}\n\n__isl_give isl_set *isl_set_set_tuple_name(__isl_take isl_set *set,\n\tconst char *s)\n{\n\treturn set_from_map(isl_map_set_tuple_name(set_to_map(set),\n\t\t\t\t\t\tisl_dim_set, s));\n}\n\n__isl_give isl_map *isl_map_set_tuple_id(__isl_take isl_map *map,\n\tenum isl_dim_type type, __isl_take isl_id *id)\n{\n\tisl_space *space;\n\n\tspace = isl_map_take_space(map);\n\tspace = isl_space_set_tuple_id(space, type, id);\n\tmap = isl_map_restore_space(map, space);\n\n\treturn isl_map_reset_space(map, isl_map_get_space(map));\n}\n\n__isl_give isl_set *isl_set_set_tuple_id(__isl_take isl_set *set,\n\t__isl_take isl_id *id)\n{\n\treturn isl_map_set_tuple_id(set, isl_dim_set, id);\n}\n\n__isl_give isl_map *isl_map_reset_tuple_id(__isl_take isl_map *map,\n\tenum isl_dim_type type)\n{\n\tisl_space *space;\n\n\tspace = isl_map_take_space(map);\n\tspace = isl_space_reset_tuple_id(space, type);\n\tmap = isl_map_restore_space(map, space);\n\n\treturn isl_map_reset_space(map, isl_map_get_space(map));\n}\n\n__isl_give isl_set *isl_set_reset_tuple_id(__isl_take isl_set *set)\n{\n\treturn isl_map_reset_tuple_id(set, isl_dim_set);\n}\n\nisl_bool isl_map_has_tuple_id(__isl_keep isl_map *map, enum isl_dim_type type)\n{\n\treturn map ? isl_space_has_tuple_id(map->dim, type) : isl_bool_error;\n}\n\n__isl_give isl_id *isl_map_get_tuple_id(__isl_keep isl_map *map,\n\tenum isl_dim_type type)\n{\n\treturn map ? isl_space_get_tuple_id(map->dim, type) : NULL;\n}\n\nisl_bool isl_set_has_tuple_id(__isl_keep isl_set *set)\n{\n\treturn isl_map_has_tuple_id(set, isl_dim_set);\n}\n\n__isl_give isl_id *isl_set_get_tuple_id(__isl_keep isl_set *set)\n{\n\treturn isl_map_get_tuple_id(set, isl_dim_set);\n}\n\n/* Does the set tuple have a name?\n */\nisl_bool isl_set_has_tuple_name(__isl_keep isl_set *set)\n{\n\tif (!set)\n\t\treturn isl_bool_error;\n\treturn isl_space_has_tuple_name(set->dim, isl_dim_set);\n}\n\n\nconst char *isl_basic_set_get_tuple_name(__isl_keep isl_basic_set *bset)\n{\n\treturn bset ? isl_space_get_tuple_name(bset->dim, isl_dim_set) : NULL;\n}\n\nconst char *isl_set_get_tuple_name(__isl_keep isl_set *set)\n{\n\treturn set ? isl_space_get_tuple_name(set->dim, isl_dim_set) : NULL;\n}\n\nconst char *isl_basic_map_get_dim_name(__isl_keep isl_basic_map *bmap,\n\tenum isl_dim_type type, unsigned pos)\n{\n\treturn bmap ? isl_space_get_dim_name(bmap->dim, type, pos) : NULL;\n}\n\nconst char *isl_basic_set_get_dim_name(__isl_keep isl_basic_set *bset,\n\tenum isl_dim_type type, unsigned pos)\n{\n\treturn bset ? isl_space_get_dim_name(bset->dim, type, pos) : NULL;\n}\n\n/* Does the given dimension have a name?\n */\nisl_bool isl_map_has_dim_name(__isl_keep isl_map *map,\n\tenum isl_dim_type type, unsigned pos)\n{\n\tif (!map)\n\t\treturn isl_bool_error;\n\treturn isl_space_has_dim_name(map->dim, type, pos);\n}\n\nconst char *isl_map_get_dim_name(__isl_keep isl_map *map,\n\tenum isl_dim_type type, unsigned pos)\n{\n\treturn map ? isl_space_get_dim_name(map->dim, type, pos) : NULL;\n}\n\nconst char *isl_set_get_dim_name(__isl_keep isl_set *set,\n\tenum isl_dim_type type, unsigned pos)\n{\n\treturn set ? isl_space_get_dim_name(set->dim, type, pos) : NULL;\n}\n\n/* Does the given dimension have a name?\n */\nisl_bool isl_set_has_dim_name(__isl_keep isl_set *set,\n\tenum isl_dim_type type, unsigned pos)\n{\n\tif (!set)\n\t\treturn isl_bool_error;\n\treturn isl_space_has_dim_name(set->dim, type, pos);\n}\n\n__isl_give isl_basic_map *isl_basic_map_set_dim_name(\n\t__isl_take isl_basic_map *bmap,\n\tenum isl_dim_type type, unsigned pos, const char *s)\n{\n\tisl_space *space;\n\n\tspace = isl_basic_map_take_space(bmap);\n\tspace = isl_space_set_dim_name(space, type, pos, s);\n\tbmap = isl_basic_map_restore_space(bmap, space);\n\treturn isl_basic_map_finalize(bmap);\n}\n\n__isl_give isl_map *isl_map_set_dim_name(__isl_take isl_map *map,\n\tenum isl_dim_type type, unsigned pos, const char *s)\n{\n\tint i;\n\tisl_space *space;\n\n\tmap = isl_map_cow(map);\n\tif (!map)\n\t\treturn NULL;\n\n\tfor (i = 0; i < map->n; ++i) {\n\t\tmap->p[i] = isl_basic_map_set_dim_name(map->p[i], type, pos, s);\n\t\tif (!map->p[i])\n\t\t\tgoto error;\n\t}\n\n\tspace = isl_map_take_space(map);\n\tspace = isl_space_set_dim_name(space, type, pos, s);\n\tmap = isl_map_restore_space(map, space);\n\n\treturn map;\nerror:\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n__isl_give isl_basic_set *isl_basic_set_set_dim_name(\n\t__isl_take isl_basic_set *bset,\n\tenum isl_dim_type type, unsigned pos, const char *s)\n{\n\treturn bset_from_bmap(isl_basic_map_set_dim_name(bset_to_bmap(bset),\n\t\t\t\t\t\t\ttype, pos, s));\n}\n\n__isl_give isl_set *isl_set_set_dim_name(__isl_take isl_set *set,\n\tenum isl_dim_type type, unsigned pos, const char *s)\n{\n\treturn set_from_map(isl_map_set_dim_name(set_to_map(set),\n\t\t\t\t\t\t\ttype, pos, s));\n}\n\nisl_bool isl_basic_map_has_dim_id(__isl_keep isl_basic_map *bmap,\n\tenum isl_dim_type type, unsigned pos)\n{\n\tif (!bmap)\n\t\treturn isl_bool_error;\n\treturn isl_space_has_dim_id(bmap->dim, type, pos);\n}\n\n__isl_give isl_id *isl_basic_set_get_dim_id(__isl_keep isl_basic_set *bset,\n\tenum isl_dim_type type, unsigned pos)\n{\n\treturn bset ? isl_space_get_dim_id(bset->dim, type, pos) : NULL;\n}\n\nisl_bool isl_map_has_dim_id(__isl_keep isl_map *map,\n\tenum isl_dim_type type, unsigned pos)\n{\n\treturn map ? isl_space_has_dim_id(map->dim, type, pos) : isl_bool_error;\n}\n\n__isl_give isl_id *isl_map_get_dim_id(__isl_keep isl_map *map,\n\tenum isl_dim_type type, unsigned pos)\n{\n\treturn map ? isl_space_get_dim_id(map->dim, type, pos) : NULL;\n}\n\nisl_bool isl_set_has_dim_id(__isl_keep isl_set *set,\n\tenum isl_dim_type type, unsigned pos)\n{\n\treturn isl_map_has_dim_id(set, type, pos);\n}\n\n__isl_give isl_id *isl_set_get_dim_id(__isl_keep isl_set *set,\n\tenum isl_dim_type type, unsigned pos)\n{\n\treturn isl_map_get_dim_id(set, type, pos);\n}\n\n__isl_give isl_map *isl_map_set_dim_id(__isl_take isl_map *map,\n\tenum isl_dim_type type, unsigned pos, __isl_take isl_id *id)\n{\n\tisl_space *space;\n\n\tspace = isl_map_take_space(map);\n\tspace = isl_space_set_dim_id(space, type, pos, id);\n\tmap = isl_map_restore_space(map, space);\n\n\treturn isl_map_reset_space(map, isl_map_get_space(map));\n}\n\n__isl_give isl_set *isl_set_set_dim_id(__isl_take isl_set *set,\n\tenum isl_dim_type type, unsigned pos, __isl_take isl_id *id)\n{\n\treturn isl_map_set_dim_id(set, type, pos, id);\n}\n\nint isl_map_find_dim_by_id(__isl_keep isl_map *map, enum isl_dim_type type,\n\t__isl_keep isl_id *id)\n{\n\tif (!map)\n\t\treturn -1;\n\treturn isl_space_find_dim_by_id(map->dim, type, id);\n}\n\nint isl_set_find_dim_by_id(__isl_keep isl_set *set, enum isl_dim_type type,\n\t__isl_keep isl_id *id)\n{\n\treturn isl_map_find_dim_by_id(set, type, id);\n}\n\n/* Return the position of the dimension of the given type and name\n * in \"bmap\".\n * Return -1 if no such dimension can be found.\n */\nint isl_basic_map_find_dim_by_name(__isl_keep isl_basic_map *bmap,\n\tenum isl_dim_type type, const char *name)\n{\n\tif (!bmap)\n\t\treturn -1;\n\treturn isl_space_find_dim_by_name(bmap->dim, type, name);\n}\n\nint isl_map_find_dim_by_name(__isl_keep isl_map *map, enum isl_dim_type type,\n\tconst char *name)\n{\n\tif (!map)\n\t\treturn -1;\n\treturn isl_space_find_dim_by_name(map->dim, type, name);\n}\n\nint isl_set_find_dim_by_name(__isl_keep isl_set *set, enum isl_dim_type type,\n\tconst char *name)\n{\n\treturn isl_map_find_dim_by_name(set, type, name);\n}\n\n/* Check whether equality i of bset is a pure stride constraint\n * on a single dimension, i.e., of the form\n *\n *\tv = k e\n *\n * with k a constant and e an existentially quantified variable.\n */\nisl_bool isl_basic_set_eq_is_stride(__isl_keep isl_basic_set *bset, int i)\n{\n\tisl_size nparam;\n\tisl_size d;\n\tisl_size n_div;\n\tint pos1;\n\tint pos2;\n\n\tnparam = isl_basic_set_dim(bset, isl_dim_param);\n\td = isl_basic_set_dim(bset, isl_dim_set);\n\tn_div = isl_basic_set_dim(bset, isl_dim_div);\n\tif (nparam < 0 || d < 0 || n_div < 0)\n\t\treturn isl_bool_error;\n\n\tif (!isl_int_is_zero(bset->eq[i][0]))\n\t\treturn isl_bool_false;\n\n\tif (isl_seq_first_non_zero(bset->eq[i] + 1, nparam) != -1)\n\t\treturn isl_bool_false;\n\tpos1 = isl_seq_first_non_zero(bset->eq[i] + 1 + nparam, d);\n\tif (pos1 == -1)\n\t\treturn isl_bool_false;\n\tif (isl_seq_first_non_zero(bset->eq[i] + 1 + nparam + pos1 + 1,\n\t\t\t\t\td - pos1 - 1) != -1)\n\t\treturn isl_bool_false;\n\n\tpos2 = isl_seq_first_non_zero(bset->eq[i] + 1 + nparam + d, n_div);\n\tif (pos2 == -1)\n\t\treturn isl_bool_false;\n\tif (isl_seq_first_non_zero(bset->eq[i] + 1 + nparam + d  + pos2 + 1,\n\t\t\t\t   n_div - pos2 - 1) != -1)\n\t\treturn isl_bool_false;\n\tif (!isl_int_is_one(bset->eq[i][1 + nparam + pos1]) &&\n\t    !isl_int_is_negone(bset->eq[i][1 + nparam + pos1]))\n\t\treturn isl_bool_false;\n\n\treturn isl_bool_true;\n}\n\n/* Reset the user pointer on all identifiers of parameters and tuples\n * of the space of \"map\".\n */\n__isl_give isl_map *isl_map_reset_user(__isl_take isl_map *map)\n{\n\tisl_space *space;\n\n\tspace = isl_map_get_space(map);\n\tspace = isl_space_reset_user(space);\n\tmap = isl_map_reset_space(map, space);\n\n\treturn map;\n}\n\n/* Reset the user pointer on all identifiers of parameters and tuples\n * of the space of \"set\".\n */\n__isl_give isl_set *isl_set_reset_user(__isl_take isl_set *set)\n{\n\treturn isl_map_reset_user(set);\n}\n\nisl_bool isl_basic_map_is_rational(__isl_keep isl_basic_map *bmap)\n{\n\tif (!bmap)\n\t\treturn isl_bool_error;\n\treturn ISL_F_ISSET(bmap, ISL_BASIC_MAP_RATIONAL);\n}\n\n/* Has \"map\" been marked as a rational map?\n * In particular, have all basic maps in \"map\" been marked this way?\n * An empty map is not considered to be rational.\n * Maps where only some of the basic maps are marked rational\n * are not allowed.\n */\nisl_bool isl_map_is_rational(__isl_keep isl_map *map)\n{\n\tint i;\n\tisl_bool rational;\n\n\tif (!map)\n\t\treturn isl_bool_error;\n\tif (map->n == 0)\n\t\treturn isl_bool_false;\n\trational = isl_basic_map_is_rational(map->p[0]);\n\tif (rational < 0)\n\t\treturn rational;\n\tfor (i = 1; i < map->n; ++i) {\n\t\tisl_bool rational_i;\n\n\t\trational_i = isl_basic_map_is_rational(map->p[i]);\n\t\tif (rational_i < 0)\n\t\t\treturn rational_i;\n\t\tif (rational != rational_i)\n\t\t\tisl_die(isl_map_get_ctx(map), isl_error_unsupported,\n\t\t\t\t\"mixed rational and integer basic maps \"\n\t\t\t\t\"not supported\", return isl_bool_error);\n\t}\n\n\treturn rational;\n}\n\n/* Has \"set\" been marked as a rational set?\n * In particular, have all basic set in \"set\" been marked this way?\n * An empty set is not considered to be rational.\n * Sets where only some of the basic sets are marked rational\n * are not allowed.\n */\nisl_bool isl_set_is_rational(__isl_keep isl_set *set)\n{\n\treturn isl_map_is_rational(set);\n}\n\nint isl_basic_set_is_rational(__isl_keep isl_basic_set *bset)\n{\n\treturn isl_basic_map_is_rational(bset);\n}\n\n/* Does \"bmap\" contain any rational points?\n *\n * If \"bmap\" has an equality for each dimension, equating the dimension\n * to an integer constant, then it has no rational points, even if it\n * is marked as rational.\n */\nisl_bool isl_basic_map_has_rational(__isl_keep isl_basic_map *bmap)\n{\n\tisl_bool has_rational = isl_bool_true;\n\tisl_size total;\n\n\tif (!bmap)\n\t\treturn isl_bool_error;\n\tif (isl_basic_map_plain_is_empty(bmap))\n\t\treturn isl_bool_false;\n\tif (!isl_basic_map_is_rational(bmap))\n\t\treturn isl_bool_false;\n\tbmap = isl_basic_map_copy(bmap);\n\tbmap = isl_basic_map_implicit_equalities(bmap);\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tif (total < 0)\n\t\treturn isl_bool_error;\n\tif (bmap->n_eq == total) {\n\t\tint i, j;\n\t\tfor (i = 0; i < bmap->n_eq; ++i) {\n\t\t\tj = isl_seq_first_non_zero(bmap->eq[i] + 1, total);\n\t\t\tif (j < 0)\n\t\t\t\tbreak;\n\t\t\tif (!isl_int_is_one(bmap->eq[i][1 + j]) &&\n\t\t\t    !isl_int_is_negone(bmap->eq[i][1 + j]))\n\t\t\t\tbreak;\n\t\t\tj = isl_seq_first_non_zero(bmap->eq[i] + 1 + j + 1,\n\t\t\t\t\t\t    total - j - 1);\n\t\t\tif (j >= 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == bmap->n_eq)\n\t\t\thas_rational = isl_bool_false;\n\t}\n\tisl_basic_map_free(bmap);\n\n\treturn has_rational;\n}\n\n/* Does \"map\" contain any rational points?\n */\nisl_bool isl_map_has_rational(__isl_keep isl_map *map)\n{\n\tint i;\n\tisl_bool has_rational;\n\n\tif (!map)\n\t\treturn isl_bool_error;\n\tfor (i = 0; i < map->n; ++i) {\n\t\thas_rational = isl_basic_map_has_rational(map->p[i]);\n\t\tif (has_rational < 0 || has_rational)\n\t\t\treturn has_rational;\n\t}\n\treturn isl_bool_false;\n}\n\n/* Does \"set\" contain any rational points?\n */\nisl_bool isl_set_has_rational(__isl_keep isl_set *set)\n{\n\treturn isl_map_has_rational(set);\n}\n\n/* Is this basic set a parameter domain?\n */\nisl_bool isl_basic_set_is_params(__isl_keep isl_basic_set *bset)\n{\n\tif (!bset)\n\t\treturn isl_bool_error;\n\treturn isl_space_is_params(bset->dim);\n}\n\n/* Is this set a parameter domain?\n */\nisl_bool isl_set_is_params(__isl_keep isl_set *set)\n{\n\tif (!set)\n\t\treturn isl_bool_error;\n\treturn isl_space_is_params(set->dim);\n}\n\n/* Is this map actually a parameter domain?\n * Users should never call this function.  Outside of isl,\n * a map can never be a parameter domain.\n */\nisl_bool isl_map_is_params(__isl_keep isl_map *map)\n{\n\tif (!map)\n\t\treturn isl_bool_error;\n\treturn isl_space_is_params(map->dim);\n}\n\nstatic __isl_give isl_basic_map *basic_map_init(isl_ctx *ctx,\n\t__isl_take isl_basic_map *bmap, unsigned extra,\n\tunsigned n_eq, unsigned n_ineq)\n{\n\tint i;\n\tisl_space *space = isl_basic_map_peek_space(bmap);\n\tisl_size n_var = isl_space_dim(space, isl_dim_all);\n\tsize_t row_size = 1 + n_var + extra;\n\n\tbmap->ctx = ctx;\n\tisl_ctx_ref(ctx);\n\n\tif (n_var < 0)\n\t\treturn isl_basic_map_free(bmap);\n\n\tbmap->block = isl_blk_alloc(ctx, (n_ineq + n_eq) * row_size);\n\tif (isl_blk_is_error(bmap->block))\n\t\tgoto error;\n\n\tbmap->ineq = isl_alloc_array(ctx, isl_int *, n_ineq + n_eq);\n\tif ((n_ineq + n_eq) && !bmap->ineq)\n\t\tgoto error;\n\n\tif (extra == 0) {\n\t\tbmap->block2 = isl_blk_empty();\n\t\tbmap->div = NULL;\n\t} else {\n\t\tbmap->block2 = isl_blk_alloc(ctx, extra * (1 + row_size));\n\t\tif (isl_blk_is_error(bmap->block2))\n\t\t\tgoto error;\n\n\t\tbmap->div = isl_alloc_array(ctx, isl_int *, extra);\n\t\tif (!bmap->div)\n\t\t\tgoto error;\n\t}\n\n\tfor (i = 0; i < n_ineq + n_eq; ++i)\n\t\tbmap->ineq[i] = bmap->block.data + i * row_size;\n\n\tfor (i = 0; i < extra; ++i)\n\t\tbmap->div[i] = bmap->block2.data + i * (1 + row_size);\n\n\tbmap->ref = 1;\n\tbmap->flags = 0;\n\tbmap->c_size = n_eq + n_ineq;\n\tbmap->eq = bmap->ineq + n_ineq;\n\tbmap->extra = extra;\n\tbmap->n_eq = 0;\n\tbmap->n_ineq = 0;\n\tbmap->n_div = 0;\n\tbmap->sample = NULL;\n\n\treturn bmap;\nerror:\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n__isl_give isl_basic_set *isl_basic_set_alloc(isl_ctx *ctx,\n\t\tunsigned nparam, unsigned dim, unsigned extra,\n\t\tunsigned n_eq, unsigned n_ineq)\n{\n\tstruct isl_basic_map *bmap;\n\tisl_space *space;\n\n\tspace = isl_space_set_alloc(ctx, nparam, dim);\n\tif (!space)\n\t\treturn NULL;\n\n\tbmap = isl_basic_map_alloc_space(space, extra, n_eq, n_ineq);\n\treturn bset_from_bmap(bmap);\n}\n\n__isl_give isl_basic_set *isl_basic_set_alloc_space(__isl_take isl_space *space,\n\t\tunsigned extra, unsigned n_eq, unsigned n_ineq)\n{\n\tstruct isl_basic_map *bmap;\n\tif (!space)\n\t\treturn NULL;\n\tisl_assert(space->ctx, space->n_in == 0, goto error);\n\tbmap = isl_basic_map_alloc_space(space, extra, n_eq, n_ineq);\n\treturn bset_from_bmap(bmap);\nerror:\n\tisl_space_free(space);\n\treturn NULL;\n}\n\n__isl_give isl_basic_map *isl_basic_map_alloc_space(__isl_take isl_space *space,\n\t\tunsigned extra, unsigned n_eq, unsigned n_ineq)\n{\n\tstruct isl_basic_map *bmap;\n\n\tif (!space)\n\t\treturn NULL;\n\tbmap = isl_calloc_type(space->ctx, struct isl_basic_map);\n\tif (!bmap)\n\t\tgoto error;\n\tbmap->dim = space;\n\n\treturn basic_map_init(space->ctx, bmap, extra, n_eq, n_ineq);\nerror:\n\tisl_space_free(space);\n\treturn NULL;\n}\n\n__isl_give isl_basic_map *isl_basic_map_alloc(isl_ctx *ctx,\n\t\tunsigned nparam, unsigned in, unsigned out, unsigned extra,\n\t\tunsigned n_eq, unsigned n_ineq)\n{\n\tstruct isl_basic_map *bmap;\n\tisl_space *space;\n\n\tspace = isl_space_alloc(ctx, nparam, in, out);\n\tif (!space)\n\t\treturn NULL;\n\n\tbmap = isl_basic_map_alloc_space(space, extra, n_eq, n_ineq);\n\treturn bmap;\n}\n\nstatic __isl_give isl_basic_map *dup_constraints(__isl_take isl_basic_map *dst,\n\t__isl_keep isl_basic_map *src)\n{\n\tint i;\n\tisl_size total = isl_basic_map_dim(src, isl_dim_all);\n\n\tif (!dst || total < 0)\n\t\treturn isl_basic_map_free(dst);\n\n\tfor (i = 0; i < src->n_eq; ++i) {\n\t\tint j = isl_basic_map_alloc_equality(dst);\n\t\tif (j < 0)\n\t\t\treturn isl_basic_map_free(dst);\n\t\tisl_seq_cpy(dst->eq[j], src->eq[i], 1+total);\n\t}\n\n\tfor (i = 0; i < src->n_ineq; ++i) {\n\t\tint j = isl_basic_map_alloc_inequality(dst);\n\t\tif (j < 0)\n\t\t\treturn isl_basic_map_free(dst);\n\t\tisl_seq_cpy(dst->ineq[j], src->ineq[i], 1+total);\n\t}\n\n\tfor (i = 0; i < src->n_div; ++i) {\n\t\tint j = isl_basic_map_alloc_div(dst);\n\t\tif (j < 0)\n\t\t\treturn isl_basic_map_free(dst);\n\t\tisl_seq_cpy(dst->div[j], src->div[i], 1+1+total);\n\t}\n\tISL_F_SET(dst, ISL_BASIC_SET_FINAL);\n\treturn dst;\n}\n\n__isl_give isl_basic_map *isl_basic_map_dup(__isl_keep isl_basic_map *bmap)\n{\n\tstruct isl_basic_map *dup;\n\n\tif (!bmap)\n\t\treturn NULL;\n\tdup = isl_basic_map_alloc_space(isl_space_copy(bmap->dim),\n\t\t\tbmap->n_div, bmap->n_eq, bmap->n_ineq);\n\tdup = dup_constraints(dup, bmap);\n\tif (!dup)\n\t\treturn NULL;\n\tdup->flags = bmap->flags;\n\tdup->sample = isl_vec_copy(bmap->sample);\n\treturn dup;\n}\n\n__isl_give isl_basic_set *isl_basic_set_dup(__isl_keep isl_basic_set *bset)\n{\n\tstruct isl_basic_map *dup;\n\n\tdup = isl_basic_map_dup(bset_to_bmap(bset));\n\treturn bset_from_bmap(dup);\n}\n\n__isl_give isl_basic_set *isl_basic_set_copy(__isl_keep isl_basic_set *bset)\n{\n\tif (!bset)\n\t\treturn NULL;\n\n\tif (ISL_F_ISSET(bset, ISL_BASIC_SET_FINAL)) {\n\t\tbset->ref++;\n\t\treturn bset;\n\t}\n\treturn isl_basic_set_dup(bset);\n}\n\n__isl_give isl_set *isl_set_copy(__isl_keep isl_set *set)\n{\n\tif (!set)\n\t\treturn NULL;\n\n\tset->ref++;\n\treturn set;\n}\n\n__isl_give isl_basic_map *isl_basic_map_copy(__isl_keep isl_basic_map *bmap)\n{\n\tif (!bmap)\n\t\treturn NULL;\n\n\tif (ISL_F_ISSET(bmap, ISL_BASIC_SET_FINAL)) {\n\t\tbmap->ref++;\n\t\treturn bmap;\n\t}\n\tbmap = isl_basic_map_dup(bmap);\n\tif (bmap)\n\t\tISL_F_SET(bmap, ISL_BASIC_SET_FINAL);\n\treturn bmap;\n}\n\n__isl_give isl_map *isl_map_copy(__isl_keep isl_map *map)\n{\n\tif (!map)\n\t\treturn NULL;\n\n\tmap->ref++;\n\treturn map;\n}\n\n__isl_null isl_basic_map *isl_basic_map_free(__isl_take isl_basic_map *bmap)\n{\n\tif (!bmap)\n\t\treturn NULL;\n\n\tif (--bmap->ref > 0)\n\t\treturn NULL;\n\n\tisl_ctx_deref(bmap->ctx);\n\tfree(bmap->div);\n\tisl_blk_free(bmap->ctx, bmap->block2);\n\tfree(bmap->ineq);\n\tisl_blk_free(bmap->ctx, bmap->block);\n\tisl_vec_free(bmap->sample);\n\tisl_space_free(bmap->dim);\n\tfree(bmap);\n\n\treturn NULL;\n}\n\n__isl_null isl_basic_set *isl_basic_set_free(__isl_take isl_basic_set *bset)\n{\n\treturn isl_basic_map_free(bset_to_bmap(bset));\n}\n\nstatic int room_for_con(__isl_keep isl_basic_map *bmap, unsigned n)\n{\n\treturn bmap->n_eq + bmap->n_ineq + n <= bmap->c_size;\n}\n\n/* Check that \"bset\" does not involve any parameters.\n */\nisl_stat isl_basic_set_check_no_params(__isl_keep isl_basic_set *bset)\n{\n\tisl_size nparam;\n\n\tnparam = isl_basic_set_dim(bset, isl_dim_param);\n\tif (nparam < 0)\n\t\treturn isl_stat_error;\n\tif (nparam != 0)\n\t\tisl_die(isl_basic_set_get_ctx(bset), isl_error_invalid,\n\t\t\t\"basic set should not have any parameters\",\n\t\t\treturn isl_stat_error);\n\treturn isl_stat_ok;\n}\n\n/* Check that \"bset\" does not involve any local variables.\n */\nisl_stat isl_basic_set_check_no_locals(__isl_keep isl_basic_set *bset)\n{\n\tisl_size n_div;\n\n\tn_div = isl_basic_set_dim(bset, isl_dim_div);\n\tif (n_div < 0)\n\t\treturn isl_stat_error;\n\tif (n_div != 0)\n\t\tisl_die(isl_basic_set_get_ctx(bset), isl_error_invalid,\n\t\t\t\"basic set should not have any local variables\",\n\t\t\treturn isl_stat_error);\n\treturn isl_stat_ok;\n}\n\n#undef TYPE\n#define TYPE isl_map\n\n#include \"isl_check_named_params_templ.c\"\n\n#undef TYPE\n#define TYPE isl_basic_map\n\nstatic\n#include \"isl_check_named_params_templ.c\"\n\n/* Check that \"bmap1\" and \"bmap2\" have the same parameters,\n * reporting an error if they do not.\n */\nstatic isl_stat isl_basic_map_check_equal_params(\n\t__isl_keep isl_basic_map *bmap1, __isl_keep isl_basic_map *bmap2)\n{\n\tisl_bool match;\n\n\tmatch = isl_basic_map_has_equal_params(bmap1, bmap2);\n\tif (match < 0)\n\t\treturn isl_stat_error;\n\tif (!match)\n\t\tisl_die(isl_basic_map_get_ctx(bmap1), isl_error_invalid,\n\t\t\t\"parameters don't match\", return isl_stat_error);\n\treturn isl_stat_ok;\n}\n\n#undef TYPE\n#define TYPE\tisl_map\n\n#include \"isl_align_params_bin_templ.c\"\n\n#undef SUFFIX\n#define SUFFIX\tset\n#undef ARG1\n#define ARG1\tisl_map\n#undef ARG2\n#define ARG2\tisl_set\n\n#include \"isl_align_params_templ.c\"\n\nisl_bool isl_map_align_params_map_map_and_test(__isl_keep isl_map *map1,\n\t__isl_keep isl_map *map2,\n\tisl_bool (*fn)(__isl_keep isl_map *map1, __isl_keep isl_map *map2))\n{\n\tisl_bool r;\n\n\tif (!map1 || !map2)\n\t\treturn isl_bool_error;\n\tif (isl_map_has_equal_params(map1, map2))\n\t\treturn fn(map1, map2);\n\tif (isl_map_check_named_params(map1) < 0)\n\t\treturn isl_bool_error;\n\tif (isl_map_check_named_params(map2) < 0)\n\t\treturn isl_bool_error;\n\tmap1 = isl_map_copy(map1);\n\tmap2 = isl_map_copy(map2);\n\tmap1 = isl_map_align_params(map1, isl_map_get_space(map2));\n\tmap2 = isl_map_align_params(map2, isl_map_get_space(map1));\n\tr = fn(map1, map2);\n\tisl_map_free(map1);\n\tisl_map_free(map2);\n\treturn r;\n}\n\nint isl_basic_map_alloc_equality(__isl_keep isl_basic_map *bmap)\n{\n\tisl_size total;\n\tstruct isl_ctx *ctx;\n\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tif (total < 0)\n\t\treturn -1;\n\tctx = bmap->ctx;\n\tisl_assert(ctx, room_for_con(bmap, 1), return -1);\n\tisl_assert(ctx, (bmap->eq - bmap->ineq) + bmap->n_eq <= bmap->c_size,\n\t\t\treturn -1);\n\tISL_F_CLR(bmap, ISL_BASIC_MAP_NO_REDUNDANT);\n\tISL_F_CLR(bmap, ISL_BASIC_MAP_NO_IMPLICIT);\n\tISL_F_CLR(bmap, ISL_BASIC_MAP_ALL_EQUALITIES);\n\tISL_F_CLR(bmap, ISL_BASIC_MAP_NORMALIZED_DIVS);\n\tif ((bmap->eq - bmap->ineq) + bmap->n_eq == bmap->c_size) {\n\t\tisl_int *t;\n\t\tint j = isl_basic_map_alloc_inequality(bmap);\n\t\tif (j < 0)\n\t\t\treturn -1;\n\t\tt = bmap->ineq[j];\n\t\tbmap->ineq[j] = bmap->ineq[bmap->n_ineq - 1];\n\t\tbmap->ineq[bmap->n_ineq - 1] = bmap->eq[-1];\n\t\tbmap->eq[-1] = t;\n\t\tbmap->n_eq++;\n\t\tbmap->n_ineq--;\n\t\tbmap->eq--;\n\t\treturn 0;\n\t}\n\tisl_seq_clr(bmap->eq[bmap->n_eq] + 1 + total,\n\t\t      bmap->extra - bmap->n_div);\n\treturn bmap->n_eq++;\n}\n\nint isl_basic_set_alloc_equality(__isl_keep isl_basic_set *bset)\n{\n\treturn isl_basic_map_alloc_equality(bset_to_bmap(bset));\n}\n\n__isl_give isl_basic_map *isl_basic_map_free_equality(\n\t__isl_take isl_basic_map *bmap, unsigned n)\n{\n\tif (!bmap)\n\t\treturn NULL;\n\tif (n > bmap->n_eq)\n\t\tisl_die(isl_basic_map_get_ctx(bmap), isl_error_invalid,\n\t\t\t\"invalid number of equalities\",\n\t\t\tisl_basic_map_free(bmap));\n\tbmap->n_eq -= n;\n\treturn bmap;\n}\n\n__isl_give isl_basic_set *isl_basic_set_free_equality(\n\t__isl_take isl_basic_set *bset, unsigned n)\n{\n\treturn bset_from_bmap(isl_basic_map_free_equality(bset_to_bmap(bset),\n\t\t\t\t\t\t\t    n));\n}\n\n/* Drop the equality constraint at position \"pos\",\n * preserving the order of the other equality constraints.\n */\nint isl_basic_map_drop_equality(__isl_keep isl_basic_map *bmap, unsigned pos)\n{\n\tisl_int *t;\n\tint r;\n\n\tif (!bmap)\n\t\treturn -1;\n\tisl_assert(bmap->ctx, pos < bmap->n_eq, return -1);\n\n\tt = bmap->eq[pos];\n\tbmap->n_eq--;\n\tfor (r = pos; r < bmap->n_eq; ++r)\n\t\tbmap->eq[r] = bmap->eq[r + 1];\n\tbmap->eq[bmap->n_eq] = t;\n\n\treturn 0;\n}\n\n/* Turn inequality \"pos\" of \"bmap\" into an equality.\n *\n * In particular, we move the inequality in front of the equalities\n * and move the last inequality in the position of the moved inequality.\n * Note that isl_tab_make_equalities_explicit depends on this particular\n * change in the ordering of the constraints.\n */\nvoid isl_basic_map_inequality_to_equality(\n\t\t__isl_keep isl_basic_map *bmap, unsigned pos)\n{\n\tisl_int *t;\n\n\tt = bmap->ineq[pos];\n\tbmap->ineq[pos] = bmap->ineq[bmap->n_ineq - 1];\n\tbmap->ineq[bmap->n_ineq - 1] = bmap->eq[-1];\n\tbmap->eq[-1] = t;\n\tbmap->n_eq++;\n\tbmap->n_ineq--;\n\tbmap->eq--;\n\tISL_F_CLR(bmap, ISL_BASIC_MAP_NO_REDUNDANT);\n\tISL_F_CLR(bmap, ISL_BASIC_MAP_SORTED);\n\tISL_F_CLR(bmap, ISL_BASIC_MAP_NORMALIZED_DIVS);\n\tISL_F_CLR(bmap, ISL_BASIC_MAP_ALL_EQUALITIES);\n}\n\nstatic int room_for_ineq(__isl_keep isl_basic_map *bmap, unsigned n)\n{\n\treturn bmap->n_ineq + n <= bmap->eq - bmap->ineq;\n}\n\nint isl_basic_map_alloc_inequality(__isl_keep isl_basic_map *bmap)\n{\n\tisl_size total;\n\tstruct isl_ctx *ctx;\n\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tif (total < 0)\n\t\treturn -1;\n\tctx = bmap->ctx;\n\tisl_assert(ctx, room_for_ineq(bmap, 1), return -1);\n\tISL_F_CLR(bmap, ISL_BASIC_MAP_NO_IMPLICIT);\n\tISL_F_CLR(bmap, ISL_BASIC_MAP_NO_REDUNDANT);\n\tISL_F_CLR(bmap, ISL_BASIC_MAP_SORTED);\n\tISL_F_CLR(bmap, ISL_BASIC_MAP_ALL_EQUALITIES);\n\tisl_seq_clr(bmap->ineq[bmap->n_ineq] + 1 + total,\n\t\t      bmap->extra - bmap->n_div);\n\treturn bmap->n_ineq++;\n}\n\nint isl_basic_set_alloc_inequality(__isl_keep isl_basic_set *bset)\n{\n\treturn isl_basic_map_alloc_inequality(bset_to_bmap(bset));\n}\n\n__isl_give isl_basic_map *isl_basic_map_free_inequality(\n\t__isl_take isl_basic_map *bmap, unsigned n)\n{\n\tif (!bmap)\n\t\treturn NULL;\n\tif (n > bmap->n_ineq)\n\t\tisl_die(isl_basic_map_get_ctx(bmap), isl_error_invalid,\n\t\t\t\"invalid number of inequalities\",\n\t\t\treturn isl_basic_map_free(bmap));\n\tbmap->n_ineq -= n;\n\treturn bmap;\n}\n\n__isl_give isl_basic_set *isl_basic_set_free_inequality(\n\t__isl_take isl_basic_set *bset, unsigned n)\n{\n\treturn bset_from_bmap(isl_basic_map_free_inequality(bset_to_bmap(bset),\n\t\t\t\t\t\t\t    n));\n}\n\nint isl_basic_map_drop_inequality(__isl_keep isl_basic_map *bmap, unsigned pos)\n{\n\tisl_int *t;\n\tif (!bmap)\n\t\treturn -1;\n\tisl_assert(bmap->ctx, pos < bmap->n_ineq, return -1);\n\n\tif (pos != bmap->n_ineq - 1) {\n\t\tt = bmap->ineq[pos];\n\t\tbmap->ineq[pos] = bmap->ineq[bmap->n_ineq - 1];\n\t\tbmap->ineq[bmap->n_ineq - 1] = t;\n\t\tISL_F_CLR(bmap, ISL_BASIC_MAP_SORTED);\n\t}\n\tbmap->n_ineq--;\n\treturn 0;\n}\n\nint isl_basic_set_drop_inequality(__isl_keep isl_basic_set *bset, unsigned pos)\n{\n\treturn isl_basic_map_drop_inequality(bset_to_bmap(bset), pos);\n}\n\n__isl_give isl_basic_map *isl_basic_map_add_eq(__isl_take isl_basic_map *bmap,\n\tisl_int *eq)\n{\n\tisl_bool empty;\n\tisl_size total;\n\tint k;\n\n\tempty = isl_basic_map_plain_is_empty(bmap);\n\tif (empty < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tif (empty)\n\t\treturn bmap;\n\n\tbmap = isl_basic_map_cow(bmap);\n\tbmap = isl_basic_map_extend_constraints(bmap, 1, 0);\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tif (total < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tk = isl_basic_map_alloc_equality(bmap);\n\tif (k < 0)\n\t\tgoto error;\n\tisl_seq_cpy(bmap->eq[k], eq, 1 + total);\n\treturn bmap;\nerror:\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n__isl_give isl_basic_set *isl_basic_set_add_eq(__isl_take isl_basic_set *bset,\n\tisl_int *eq)\n{\n\treturn bset_from_bmap(isl_basic_map_add_eq(bset_to_bmap(bset), eq));\n}\n\n__isl_give isl_basic_map *isl_basic_map_add_ineq(__isl_take isl_basic_map *bmap,\n\tisl_int *ineq)\n{\n\tisl_size total;\n\tint k;\n\n\tbmap = isl_basic_map_cow(bmap);\n\tbmap = isl_basic_map_extend_constraints(bmap, 0, 1);\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tif (total < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tk = isl_basic_map_alloc_inequality(bmap);\n\tif (k < 0)\n\t\tgoto error;\n\tisl_seq_cpy(bmap->ineq[k], ineq, 1 + total);\n\treturn bmap;\nerror:\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n__isl_give isl_basic_set *isl_basic_set_add_ineq(__isl_take isl_basic_set *bset,\n\tisl_int *ineq)\n{\n\treturn bset_from_bmap(isl_basic_map_add_ineq(bset_to_bmap(bset), ineq));\n}\n\nint isl_basic_map_alloc_div(__isl_keep isl_basic_map *bmap)\n{\n\tisl_size total;\n\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tif (total < 0)\n\t\treturn -1;\n\tisl_assert(bmap->ctx, bmap->n_div < bmap->extra, return -1);\n\tisl_seq_clr(bmap->div[bmap->n_div] + 1 + 1 + total,\n\t\t      bmap->extra - bmap->n_div);\n\tISL_F_CLR(bmap, ISL_BASIC_MAP_NORMALIZED_DIVS);\n\treturn bmap->n_div++;\n}\n\nint isl_basic_set_alloc_div(__isl_keep isl_basic_set *bset)\n{\n\treturn isl_basic_map_alloc_div(bset_to_bmap(bset));\n}\n\n#undef TYPE\n#define TYPE\tisl_basic_map\n#include \"check_type_range_templ.c\"\n\n/* Check that there are \"n\" dimensions of type \"type\" starting at \"first\"\n * in \"bset\".\n */\nisl_stat isl_basic_set_check_range(__isl_keep isl_basic_set *bset,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\treturn isl_basic_map_check_range(bset_to_bmap(bset),\n\t\t\t\t\ttype, first, n);\n}\n\n/* Insert an extra integer division, prescribed by \"div\", to \"bmap\"\n * at (integer division) position \"pos\".\n *\n * The integer division is first added at the end and then moved\n * into the right position.\n */\n__isl_give isl_basic_map *isl_basic_map_insert_div(\n\t__isl_take isl_basic_map *bmap, int pos, __isl_keep isl_vec *div)\n{\n\tint i, k;\n\tisl_size total;\n\n\tbmap = isl_basic_map_cow(bmap);\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tif (total < 0 || !div)\n\t\treturn isl_basic_map_free(bmap);\n\n\tif (div->size != 1 + 1 + total)\n\t\tisl_die(isl_basic_map_get_ctx(bmap), isl_error_invalid,\n\t\t\t\"unexpected size\", return isl_basic_map_free(bmap));\n\tif (isl_basic_map_check_range(bmap, isl_dim_div, pos, 0) < 0)\n\t\treturn isl_basic_map_free(bmap);\n\n\tbmap = isl_basic_map_extend(bmap, 1, 0, 2);\n\tk = isl_basic_map_alloc_div(bmap);\n\tif (k < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tisl_seq_cpy(bmap->div[k], div->el, div->size);\n\tisl_int_set_si(bmap->div[k][div->size], 0);\n\n\tfor (i = k; i > pos; --i)\n\t\tbmap = isl_basic_map_swap_div(bmap, i, i - 1);\n\n\treturn bmap;\n}\n\nisl_stat isl_basic_map_free_div(__isl_keep isl_basic_map *bmap, unsigned n)\n{\n\tif (!bmap)\n\t\treturn isl_stat_error;\n\tisl_assert(bmap->ctx, n <= bmap->n_div, return isl_stat_error);\n\tbmap->n_div -= n;\n\treturn isl_stat_ok;\n}\n\nstatic __isl_give isl_basic_map *add_constraints(\n\t__isl_take isl_basic_map *bmap1, __isl_take isl_basic_map *bmap2,\n\tunsigned i_pos, unsigned o_pos)\n{\n\tisl_size total, n_param, n_in, n_out, n_div;\n\tunsigned o_in, o_out;\n\tisl_ctx *ctx;\n\tisl_space *space;\n\tstruct isl_dim_map *dim_map;\n\n\tspace = isl_basic_map_peek_space(bmap2);\n\tif (!bmap1 || !space)\n\t\tgoto error;\n\n\ttotal = isl_basic_map_dim(bmap1, isl_dim_all);\n\tn_param = isl_basic_map_dim(bmap2, isl_dim_param);\n\tn_in = isl_basic_map_dim(bmap2, isl_dim_in);\n\to_in = isl_basic_map_offset(bmap1, isl_dim_in) - 1 + i_pos;\n\tn_out = isl_basic_map_dim(bmap2, isl_dim_out);\n\to_out = isl_basic_map_offset(bmap1, isl_dim_out) - 1 + o_pos;\n\tn_div = isl_basic_map_dim(bmap2, isl_dim_div);\n\tif (total < 0 || n_param < 0 || n_in < 0 || n_out < 0 || n_div < 0)\n\t\tgoto error;\n\tctx = isl_basic_map_get_ctx(bmap1);\n\tdim_map = isl_dim_map_alloc(ctx, total + n_div);\n\tisl_dim_map_dim_range(dim_map, space, isl_dim_param, 0, n_param, 0);\n\tisl_dim_map_dim_range(dim_map, space, isl_dim_in, 0, n_in, o_in);\n\tisl_dim_map_dim_range(dim_map, space, isl_dim_out, 0, n_out, o_out);\n\tisl_dim_map_div(dim_map, bmap2, total);\n\n\treturn isl_basic_map_add_constraints_dim_map(bmap1, bmap2, dim_map);\nerror:\n\tisl_basic_map_free(bmap1);\n\tisl_basic_map_free(bmap2);\n\treturn NULL;\n}\n\n__isl_give isl_basic_map *isl_basic_map_extend(__isl_take isl_basic_map *base,\n\tunsigned extra, unsigned n_eq, unsigned n_ineq)\n{\n\tisl_space *space;\n\tstruct isl_basic_map *ext;\n\tunsigned flags;\n\tint dims_ok;\n\n\tif (!base)\n\t\tgoto error;\n\n\tdims_ok = base->extra >= base->n_div + extra;\n\n\tif (dims_ok && room_for_con(base, n_eq + n_ineq) &&\n\t\t       room_for_ineq(base, n_ineq))\n\t\treturn base;\n\n\textra += base->extra;\n\tn_eq += base->n_eq;\n\tn_ineq += base->n_ineq;\n\n\tspace = isl_basic_map_get_space(base);\n\text = isl_basic_map_alloc_space(space, extra, n_eq, n_ineq);\n\tif (!ext)\n\t\tgoto error;\n\n\tif (dims_ok)\n\t\text->sample = isl_vec_copy(base->sample);\n\tflags = base->flags;\n\text = add_constraints(ext, base, 0, 0);\n\tif (ext) {\n\t\text->flags = flags;\n\t\tISL_F_CLR(ext, ISL_BASIC_SET_FINAL);\n\t}\n\n\treturn ext;\n\nerror:\n\tisl_basic_map_free(base);\n\treturn NULL;\n}\n\n__isl_give isl_basic_set *isl_basic_set_extend(__isl_take isl_basic_set *base,\n\tunsigned extra, unsigned n_eq, unsigned n_ineq)\n{\n\treturn bset_from_bmap(isl_basic_map_extend(bset_to_bmap(base),\n\t\t\t\t\t\t    extra, n_eq, n_ineq));\n}\n\n__isl_give isl_basic_map *isl_basic_map_extend_constraints(\n\t__isl_take isl_basic_map *base, unsigned n_eq, unsigned n_ineq)\n{\n\treturn isl_basic_map_extend(base, 0, n_eq, n_ineq);\n}\n\n__isl_give isl_basic_set *isl_basic_set_extend_constraints(\n\t__isl_take isl_basic_set *base, unsigned n_eq, unsigned n_ineq)\n{\n\tisl_basic_map *bmap = bset_to_bmap(base);\n\tbmap = isl_basic_map_extend_constraints(bmap, n_eq, n_ineq);\n\treturn bset_from_bmap(bmap);\n}\n\n__isl_give isl_basic_set *isl_basic_set_cow(__isl_take isl_basic_set *bset)\n{\n\treturn bset_from_bmap(isl_basic_map_cow(bset_to_bmap(bset)));\n}\n\n__isl_give isl_basic_map *isl_basic_map_cow(__isl_take isl_basic_map *bmap)\n{\n\tif (!bmap)\n\t\treturn NULL;\n\n\tif (bmap->ref > 1) {\n\t\tbmap->ref--;\n\t\tbmap = isl_basic_map_dup(bmap);\n\t}\n\tif (bmap) {\n\t\tISL_F_CLR(bmap, ISL_BASIC_SET_FINAL);\n\t\tISL_F_CLR(bmap, ISL_BASIC_MAP_REDUCED_COEFFICIENTS);\n\t}\n\treturn bmap;\n}\n\n/* Clear all cached information in \"map\", either because it is about\n * to be modified or because it is being freed.\n * Always return the same pointer that is passed in.\n * This is needed for the use in isl_map_free.\n */\nstatic __isl_give isl_map *clear_caches(__isl_take isl_map *map)\n{\n\tisl_basic_map_free(map->cached_simple_hull[0]);\n\tisl_basic_map_free(map->cached_simple_hull[1]);\n\tmap->cached_simple_hull[0] = NULL;\n\tmap->cached_simple_hull[1] = NULL;\n\treturn map;\n}\n\n__isl_give isl_set *isl_set_cow(__isl_take isl_set *set)\n{\n\treturn isl_map_cow(set);\n}\n\n/* Return an isl_map that is equal to \"map\" and that has only\n * a single reference.\n *\n * If the original input already has only one reference, then\n * simply return it, but clear all cached information, since\n * it may be rendered invalid by the operations that will be\n * performed on the result.\n *\n * Otherwise, create a duplicate (without any cached information).\n */\n__isl_give isl_map *isl_map_cow(__isl_take isl_map *map)\n{\n\tif (!map)\n\t\treturn NULL;\n\n\tif (map->ref == 1)\n\t\treturn clear_caches(map);\n\tmap->ref--;\n\treturn isl_map_dup(map);\n}\n\nstatic void swap_vars(struct isl_blk blk, isl_int *a,\n\t\t\tunsigned a_len, unsigned b_len)\n{\n\tisl_seq_cpy(blk.data, a+a_len, b_len);\n\tisl_seq_cpy(blk.data+b_len, a, a_len);\n\tisl_seq_cpy(a, blk.data, b_len+a_len);\n}\n\nstatic __isl_give isl_basic_map *isl_basic_map_swap_vars(\n\t__isl_take isl_basic_map *bmap, unsigned pos, unsigned n1, unsigned n2)\n{\n\tint i;\n\tstruct isl_blk blk;\n\n\tif (isl_basic_map_check_range(bmap, isl_dim_all, pos - 1, n1 + n2) < 0)\n\t\tgoto error;\n\n\tif (n1 == 0 || n2 == 0)\n\t\treturn bmap;\n\n\tbmap = isl_basic_map_cow(bmap);\n\tif (!bmap)\n\t\treturn NULL;\n\n\tblk = isl_blk_alloc(bmap->ctx, n1 + n2);\n\tif (isl_blk_is_error(blk))\n\t\tgoto error;\n\n\tfor (i = 0; i < bmap->n_eq; ++i)\n\t\tswap_vars(blk,\n\t\t\t  bmap->eq[i] + pos, n1, n2);\n\n\tfor (i = 0; i < bmap->n_ineq; ++i)\n\t\tswap_vars(blk,\n\t\t\t  bmap->ineq[i] + pos, n1, n2);\n\n\tfor (i = 0; i < bmap->n_div; ++i)\n\t\tswap_vars(blk,\n\t\t\t  bmap->div[i]+1 + pos, n1, n2);\n\n\tisl_blk_free(bmap->ctx, blk);\n\n\tISL_F_CLR(bmap, ISL_BASIC_SET_SORTED);\n\tbmap = isl_basic_map_gauss(bmap, NULL);\n\treturn isl_basic_map_finalize(bmap);\nerror:\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n/* The given basic map has turned out to be empty.\n * Explicitly mark it as such and change the representation\n * to a canonical representation of the empty basic map.\n * Since the basic map has conflicting constraints,\n * it must have at least one constraint, except perhaps\n * if it was already explicitly marked as being empty.\n * Do nothing in the latter case.\n */\n__isl_give isl_basic_map *isl_basic_map_set_to_empty(\n\t__isl_take isl_basic_map *bmap)\n{\n\tint i = 0;\n\tisl_bool empty;\n\tisl_size total;\n\n\tempty = isl_basic_map_plain_is_empty(bmap);\n\tif (empty < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tif (empty)\n\t\treturn bmap;\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tif (total < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tif (isl_basic_map_free_div(bmap, bmap->n_div) < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tbmap = isl_basic_map_free_inequality(bmap, bmap->n_ineq);\n\tif (!bmap)\n\t\treturn NULL;\n\tif (bmap->n_eq > 0) {\n\t\tbmap = isl_basic_map_free_equality(bmap, bmap->n_eq - 1);\n\t\tif (!bmap)\n\t\t\treturn NULL;\n\t} else {\n\t\ti = isl_basic_map_alloc_equality(bmap);\n\t\tif (i < 0)\n\t\t\tgoto error;\n\t}\n\tisl_int_set_si(bmap->eq[i][0], 1);\n\tisl_seq_clr(bmap->eq[i]+1, total);\n\tISL_F_SET(bmap, ISL_BASIC_MAP_EMPTY);\n\tisl_vec_free(bmap->sample);\n\tbmap->sample = NULL;\n\treturn isl_basic_map_finalize(bmap);\nerror:\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n__isl_give isl_basic_set *isl_basic_set_set_to_empty(\n\t__isl_take isl_basic_set *bset)\n{\n\treturn bset_from_bmap(isl_basic_map_set_to_empty(bset_to_bmap(bset)));\n}\n\n__isl_give isl_basic_map *isl_basic_map_set_rational(\n\t__isl_take isl_basic_map *bmap)\n{\n\tif (!bmap)\n\t\treturn NULL;\n\n\tif (ISL_F_ISSET(bmap, ISL_BASIC_MAP_RATIONAL))\n\t\treturn bmap;\n\n\tbmap = isl_basic_map_cow(bmap);\n\tif (!bmap)\n\t\treturn NULL;\n\n\tISL_F_SET(bmap, ISL_BASIC_MAP_RATIONAL);\n\n\treturn isl_basic_map_finalize(bmap);\n}\n\n__isl_give isl_basic_set *isl_basic_set_set_rational(\n\t__isl_take isl_basic_set *bset)\n{\n\treturn isl_basic_map_set_rational(bset);\n}\n\n__isl_give isl_basic_set *isl_basic_set_set_integral(\n\t__isl_take isl_basic_set *bset)\n{\n\tif (!bset)\n\t\treturn NULL;\n\n\tif (!ISL_F_ISSET(bset, ISL_BASIC_MAP_RATIONAL))\n\t\treturn bset;\n\n\tbset = isl_basic_set_cow(bset);\n\tif (!bset)\n\t\treturn NULL;\n\n\tISL_F_CLR(bset, ISL_BASIC_MAP_RATIONAL);\n\n\treturn isl_basic_set_finalize(bset);\n}\n\n__isl_give isl_map *isl_map_set_rational(__isl_take isl_map *map)\n{\n\tint i;\n\n\tmap = isl_map_cow(map);\n\tif (!map)\n\t\treturn NULL;\n\tfor (i = 0; i < map->n; ++i) {\n\t\tmap->p[i] = isl_basic_map_set_rational(map->p[i]);\n\t\tif (!map->p[i])\n\t\t\tgoto error;\n\t}\n\treturn map;\nerror:\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n__isl_give isl_set *isl_set_set_rational(__isl_take isl_set *set)\n{\n\treturn isl_map_set_rational(set);\n}\n\n/* Swap divs \"a\" and \"b\" in \"bmap\" (without modifying any of the constraints\n * of \"bmap\").\n */\nstatic void swap_div(__isl_keep isl_basic_map *bmap, int a, int b)\n{\n\tisl_int *t = bmap->div[a];\n\tbmap->div[a] = bmap->div[b];\n\tbmap->div[b] = t;\n}\n\n/* Swap divs \"a\" and \"b\" in \"bmap\" and adjust the constraints and\n * div definitions accordingly.\n */\n__isl_give isl_basic_map *isl_basic_map_swap_div(__isl_take isl_basic_map *bmap,\n\tint a, int b)\n{\n\tint i;\n\tisl_size off;\n\n\toff = isl_basic_map_var_offset(bmap, isl_dim_div);\n\tif (off < 0)\n\t\treturn isl_basic_map_free(bmap);\n\n\tswap_div(bmap, a, b);\n\n\tfor (i = 0; i < bmap->n_eq; ++i)\n\t\tisl_int_swap(bmap->eq[i][1+off+a], bmap->eq[i][1+off+b]);\n\n\tfor (i = 0; i < bmap->n_ineq; ++i)\n\t\tisl_int_swap(bmap->ineq[i][1+off+a], bmap->ineq[i][1+off+b]);\n\n\tfor (i = 0; i < bmap->n_div; ++i)\n\t\tisl_int_swap(bmap->div[i][1+1+off+a], bmap->div[i][1+1+off+b]);\n\tISL_F_CLR(bmap, ISL_BASIC_MAP_SORTED);\n\n\treturn bmap;\n}\n\nstatic void constraint_drop_vars(isl_int *c, unsigned n, unsigned rem)\n{\n\tisl_seq_cpy(c, c + n, rem);\n\tisl_seq_clr(c + rem, n);\n}\n\n/* Drop n dimensions starting at first.\n *\n * In principle, this frees up some extra variables as the number\n * of columns remains constant, but we would have to extend\n * the div array too as the number of rows in this array is assumed\n * to be equal to extra.\n */\n__isl_give isl_basic_set *isl_basic_set_drop_dims(\n\t__isl_take isl_basic_set *bset, unsigned first, unsigned n)\n{\n\treturn isl_basic_map_drop(bset_to_bmap(bset), isl_dim_set, first, n);\n}\n\n/* Move \"n\" divs starting at \"first\" to the end of the list of divs.\n */\nstatic __isl_give isl_basic_map *move_divs_last(__isl_take isl_basic_map *bmap,\n\tunsigned first, unsigned n)\n{\n\tisl_int **div;\n\tint i;\n\n\tif (first + n == bmap->n_div)\n\t\treturn bmap;\n\n\tdiv = isl_alloc_array(bmap->ctx, isl_int *, n);\n\tif (!div)\n\t\tgoto error;\n\tfor (i = 0; i < n; ++i)\n\t\tdiv[i] = bmap->div[first + i];\n\tfor (i = 0; i < bmap->n_div - first - n; ++i)\n\t\tbmap->div[first + i] = bmap->div[first + n + i];\n\tfor (i = 0; i < n; ++i)\n\t\tbmap->div[bmap->n_div - n + i] = div[i];\n\tfree(div);\n\treturn bmap;\nerror:\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n#undef TYPE\n#define TYPE\tisl_map\nstatic\n#include \"check_type_range_templ.c\"\n\n/* Check that there are \"n\" dimensions of type \"type\" starting at \"first\"\n * in \"set\".\n */\nisl_stat isl_set_check_range(__isl_keep isl_set *set,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\treturn isl_map_check_range(set_to_map(set), type, first, n);\n}\n\n/* Drop \"n\" dimensions of type \"type\" starting at \"first\".\n * Perform the core computation, without cowing or\n * simplifying and finalizing the result.\n *\n * In principle, this frees up some extra variables as the number\n * of columns remains constant, but we would have to extend\n * the div array too as the number of rows in this array is assumed\n * to be equal to extra.\n */\n__isl_give isl_basic_map *isl_basic_map_drop_core(\n\t__isl_take isl_basic_map *bmap, enum isl_dim_type type,\n\tunsigned first, unsigned n)\n{\n\tint i;\n\tunsigned offset;\n\tunsigned left;\n\tisl_size total;\n\n\tif (isl_basic_map_check_range(bmap, type, first, n) < 0)\n\t\treturn isl_basic_map_free(bmap);\n\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tif (total < 0)\n\t\treturn isl_basic_map_free(bmap);\n\n\toffset = isl_basic_map_offset(bmap, type) + first;\n\tleft = total - (offset - 1) - n;\n\tfor (i = 0; i < bmap->n_eq; ++i)\n\t\tconstraint_drop_vars(bmap->eq[i]+offset, n, left);\n\n\tfor (i = 0; i < bmap->n_ineq; ++i)\n\t\tconstraint_drop_vars(bmap->ineq[i]+offset, n, left);\n\n\tfor (i = 0; i < bmap->n_div; ++i)\n\t\tconstraint_drop_vars(bmap->div[i]+1+offset, n, left);\n\n\tif (type == isl_dim_div) {\n\t\tbmap = move_divs_last(bmap, first, n);\n\t\tif (!bmap)\n\t\t\treturn NULL;\n\t\tif (isl_basic_map_free_div(bmap, n) < 0)\n\t\t\treturn isl_basic_map_free(bmap);\n\t} else\n\t\tbmap->dim = isl_space_drop_dims(bmap->dim, type, first, n);\n\tif (!bmap->dim)\n\t\treturn isl_basic_map_free(bmap);\n\n\tISL_F_CLR(bmap, ISL_BASIC_MAP_NO_REDUNDANT);\n\tISL_F_CLR(bmap, ISL_BASIC_MAP_SORTED);\n\treturn bmap;\n}\n\n/* Drop \"n\" dimensions of type \"type\" starting at \"first\".\n *\n * In principle, this frees up some extra variables as the number\n * of columns remains constant, but we would have to extend\n * the div array too as the number of rows in this array is assumed\n * to be equal to extra.\n */\n__isl_give isl_basic_map *isl_basic_map_drop(__isl_take isl_basic_map *bmap,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\tif (!bmap)\n\t\treturn NULL;\n\tif (n == 0 && !isl_space_is_named_or_nested(bmap->dim, type))\n\t\treturn bmap;\n\n\tbmap = isl_basic_map_cow(bmap);\n\tif (!bmap)\n\t\treturn NULL;\n\n\tbmap = isl_basic_map_drop_core(bmap, type, first, n);\n\n\tbmap = isl_basic_map_simplify(bmap);\n\treturn isl_basic_map_finalize(bmap);\n}\n\n__isl_give isl_basic_set *isl_basic_set_drop(__isl_take isl_basic_set *bset,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\treturn bset_from_bmap(isl_basic_map_drop(bset_to_bmap(bset),\n\t\t\t\t\t\t\ttype, first, n));\n}\n\n/* No longer consider \"map\" to be normalized.\n */\nstatic __isl_give isl_map *isl_map_unmark_normalized(__isl_take isl_map *map)\n{\n\tif (!map)\n\t\treturn NULL;\n\tISL_F_CLR(map, ISL_MAP_NORMALIZED);\n\treturn map;\n}\n\n__isl_give isl_map *isl_map_drop(__isl_take isl_map *map,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\tint i;\n\tisl_space *space;\n\n\tif (isl_map_check_range(map, type, first, n) < 0)\n\t\treturn isl_map_free(map);\n\n\tif (n == 0 && !isl_space_is_named_or_nested(map->dim, type))\n\t\treturn map;\n\tmap = isl_map_cow(map);\n\tif (!map)\n\t\tgoto error;\n\n\tfor (i = 0; i < map->n; ++i) {\n\t\tmap->p[i] = isl_basic_map_drop(map->p[i], type, first, n);\n\t\tif (!map->p[i])\n\t\t\tgoto error;\n\t}\n\tmap = isl_map_unmark_normalized(map);\n\n\tspace = isl_map_take_space(map);\n\tspace = isl_space_drop_dims(space, type, first, n);\n\tmap = isl_map_restore_space(map, space);\n\n\treturn map;\nerror:\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n__isl_give isl_set *isl_set_drop(__isl_take isl_set *set,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\treturn set_from_map(isl_map_drop(set_to_map(set), type, first, n));\n}\n\n/* Drop the integer division at position \"div\", which is assumed\n * not to appear in any of the constraints or\n * in any of the other integer divisions.\n *\n * Since the integer division is redundant, there is no need to cow.\n */\n__isl_give isl_basic_map *isl_basic_map_drop_div(\n\t__isl_take isl_basic_map *bmap, unsigned div)\n{\n\treturn isl_basic_map_drop_core(bmap, isl_dim_div, div, 1);\n}\n\n/* Eliminate the specified n dimensions starting at first from the\n * constraints, without removing the dimensions from the space.\n * If the set is rational, the dimensions are eliminated using Fourier-Motzkin.\n */\n__isl_give isl_map *isl_map_eliminate(__isl_take isl_map *map,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\tint i;\n\n\tif (n == 0)\n\t\treturn map;\n\n\tif (isl_map_check_range(map, type, first, n) < 0)\n\t\treturn isl_map_free(map);\n\n\tmap = isl_map_cow(map);\n\tif (!map)\n\t\treturn NULL;\n\n\tfor (i = 0; i < map->n; ++i) {\n\t\tmap->p[i] = isl_basic_map_eliminate(map->p[i], type, first, n);\n\t\tif (!map->p[i])\n\t\t\tgoto error;\n\t}\n\treturn map;\nerror:\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n/* Eliminate the specified n dimensions starting at first from the\n * constraints, without removing the dimensions from the space.\n * If the set is rational, the dimensions are eliminated using Fourier-Motzkin.\n */\n__isl_give isl_set *isl_set_eliminate(__isl_take isl_set *set,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\treturn set_from_map(isl_map_eliminate(set_to_map(set), type, first, n));\n}\n\n/* Eliminate the specified n dimensions starting at first from the\n * constraints, without removing the dimensions from the space.\n * If the set is rational, the dimensions are eliminated using Fourier-Motzkin.\n */\n__isl_give isl_set *isl_set_eliminate_dims(__isl_take isl_set *set,\n\tunsigned first, unsigned n)\n{\n\treturn isl_set_eliminate(set, isl_dim_set, first, n);\n}\n\n__isl_give isl_basic_map *isl_basic_map_remove_divs(\n\t__isl_take isl_basic_map *bmap)\n{\n\tisl_size v_div;\n\n\tv_div = isl_basic_map_var_offset(bmap, isl_dim_div);\n\tif (v_div < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tbmap = isl_basic_map_eliminate_vars(bmap, v_div, bmap->n_div);\n\tif (!bmap)\n\t\treturn NULL;\n\tbmap->n_div = 0;\n\treturn isl_basic_map_finalize(bmap);\n}\n\n__isl_give isl_basic_set *isl_basic_set_remove_divs(\n\t__isl_take isl_basic_set *bset)\n{\n\treturn bset_from_bmap(isl_basic_map_remove_divs(bset_to_bmap(bset)));\n}\n\n__isl_give isl_map *isl_map_remove_divs(__isl_take isl_map *map)\n{\n\tint i;\n\n\tif (!map)\n\t\treturn NULL;\n\tif (map->n == 0)\n\t\treturn map;\n\n\tmap = isl_map_cow(map);\n\tif (!map)\n\t\treturn NULL;\n\t\n\tfor (i = 0; i < map->n; ++i) {\n\t\tmap->p[i] = isl_basic_map_remove_divs(map->p[i]);\n\t\tif (!map->p[i])\n\t\t\tgoto error;\n\t}\n\treturn map;\nerror:\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n__isl_give isl_set *isl_set_remove_divs(__isl_take isl_set *set)\n{\n\treturn isl_map_remove_divs(set);\n}\n\n__isl_give isl_basic_map *isl_basic_map_remove_dims(\n\t__isl_take isl_basic_map *bmap, enum isl_dim_type type,\n\tunsigned first, unsigned n)\n{\n\tif (isl_basic_map_check_range(bmap, type, first, n) < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tif (n == 0 && !isl_space_is_named_or_nested(bmap->dim, type))\n\t\treturn bmap;\n\tbmap = isl_basic_map_eliminate_vars(bmap,\n\t\t\tisl_basic_map_offset(bmap, type) - 1 + first, n);\n\tif (!bmap)\n\t\treturn bmap;\n\tif (ISL_F_ISSET(bmap, ISL_BASIC_MAP_EMPTY) && type == isl_dim_div)\n\t\treturn bmap;\n\tbmap = isl_basic_map_drop(bmap, type, first, n);\n\treturn bmap;\n}\n\n/* Return true if the definition of the given div (recursively) involves\n * any of the given variables.\n */\nstatic isl_bool div_involves_vars(__isl_keep isl_basic_map *bmap, int div,\n\tunsigned first, unsigned n)\n{\n\tint i;\n\tunsigned div_offset = isl_basic_map_offset(bmap, isl_dim_div);\n\n\tif (isl_int_is_zero(bmap->div[div][0]))\n\t\treturn isl_bool_false;\n\tif (isl_seq_first_non_zero(bmap->div[div] + 1 + first, n) >= 0)\n\t\treturn isl_bool_true;\n\n\tfor (i = bmap->n_div - 1; i >= 0; --i) {\n\t\tisl_bool involves;\n\n\t\tif (isl_int_is_zero(bmap->div[div][1 + div_offset + i]))\n\t\t\tcontinue;\n\t\tinvolves = div_involves_vars(bmap, i, first, n);\n\t\tif (involves < 0 || involves)\n\t\t\treturn involves;\n\t}\n\n\treturn isl_bool_false;\n}\n\n/* Try and add a lower and/or upper bound on \"div\" to \"bmap\"\n * based on inequality \"i\".\n * \"total\" is the total number of variables (excluding the divs).\n * \"v\" is a temporary object that can be used during the calculations.\n * If \"lb\" is set, then a lower bound should be constructed.\n * If \"ub\" is set, then an upper bound should be constructed.\n *\n * The calling function has already checked that the inequality does not\n * reference \"div\", but we still need to check that the inequality is\n * of the right form.  We'll consider the case where we want to construct\n * a lower bound.  The construction of upper bounds is similar.\n *\n * Let \"div\" be of the form\n *\n *\tq = floor((a + f(x))/d)\n *\n * We essentially check if constraint \"i\" is of the form\n *\n *\tb + f(x) >= 0\n *\n * so that we can use it to derive a lower bound on \"div\".\n * However, we allow a slightly more general form\n *\n *\tb + g(x) >= 0\n *\n * with the condition that the coefficients of g(x) - f(x) are all\n * divisible by d.\n * Rewriting this constraint as\n *\n *\t0 >= -b - g(x)\n *\n * adding a + f(x) to both sides and dividing by d, we obtain\n *\n *\t(a + f(x))/d >= (a-b)/d + (f(x)-g(x))/d\n *\n * Taking the floor on both sides, we obtain\n *\n *\tq >= floor((a-b)/d) + (f(x)-g(x))/d\n *\n * or\n *\n *\t(g(x)-f(x))/d + ceil((b-a)/d) + q >= 0\n *\n * In the case of an upper bound, we construct the constraint\n *\n *\t(g(x)+f(x))/d + floor((b+a)/d) - q >= 0\n *\n */\nstatic __isl_give isl_basic_map *insert_bounds_on_div_from_ineq(\n\t__isl_take isl_basic_map *bmap, int div, int i,\n\tunsigned total, isl_int v, int lb, int ub)\n{\n\tint j;\n\n\tfor (j = 0; (lb || ub) && j < total + bmap->n_div; ++j) {\n\t\tif (lb) {\n\t\t\tisl_int_sub(v, bmap->ineq[i][1 + j],\n\t\t\t\t\tbmap->div[div][1 + 1 + j]);\n\t\t\tlb = isl_int_is_divisible_by(v, bmap->div[div][0]);\n\t\t}\n\t\tif (ub) {\n\t\t\tisl_int_add(v, bmap->ineq[i][1 + j],\n\t\t\t\t\tbmap->div[div][1 + 1 + j]);\n\t\t\tub = isl_int_is_divisible_by(v, bmap->div[div][0]);\n\t\t}\n\t}\n\tif (!lb && !ub)\n\t\treturn bmap;\n\n\tbmap = isl_basic_map_cow(bmap);\n\tbmap = isl_basic_map_extend_constraints(bmap, 0, lb + ub);\n\tif (lb) {\n\t\tint k = isl_basic_map_alloc_inequality(bmap);\n\t\tif (k < 0)\n\t\t\tgoto error;\n\t\tfor (j = 0; j < 1 + total + bmap->n_div; ++j) {\n\t\t\tisl_int_sub(bmap->ineq[k][j], bmap->ineq[i][j],\n\t\t\t\t\tbmap->div[div][1 + j]);\n\t\t\tisl_int_cdiv_q(bmap->ineq[k][j],\n\t\t\t\t\tbmap->ineq[k][j], bmap->div[div][0]);\n\t\t}\n\t\tisl_int_set_si(bmap->ineq[k][1 + total + div], 1);\n\t}\n\tif (ub) {\n\t\tint k = isl_basic_map_alloc_inequality(bmap);\n\t\tif (k < 0)\n\t\t\tgoto error;\n\t\tfor (j = 0; j < 1 + total + bmap->n_div; ++j) {\n\t\t\tisl_int_add(bmap->ineq[k][j], bmap->ineq[i][j],\n\t\t\t\t\tbmap->div[div][1 + j]);\n\t\t\tisl_int_fdiv_q(bmap->ineq[k][j],\n\t\t\t\t\tbmap->ineq[k][j], bmap->div[div][0]);\n\t\t}\n\t\tisl_int_set_si(bmap->ineq[k][1 + total + div], -1);\n\t}\n\n\treturn bmap;\nerror:\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n/* This function is called right before \"div\" is eliminated from \"bmap\"\n * using Fourier-Motzkin.\n * Look through the constraints of \"bmap\" for constraints on the argument\n * of the integer division and use them to construct constraints on the\n * integer division itself.  These constraints can then be combined\n * during the Fourier-Motzkin elimination.\n * Note that it is only useful to introduce lower bounds on \"div\"\n * if \"bmap\" already contains upper bounds on \"div\" as the newly\n * introduce lower bounds can then be combined with the pre-existing\n * upper bounds.  Similarly for upper bounds.\n * We therefore first check if \"bmap\" contains any lower and/or upper bounds\n * on \"div\".\n *\n * It is interesting to note that the introduction of these constraints\n * can indeed lead to more accurate results, even when compared to\n * deriving constraints on the argument of \"div\" from constraints on \"div\".\n * Consider, for example, the set\n *\n *\t{ [i,j,k] : 3 + i + 2j >= 0 and 2 * [(i+2j)/4] <= k }\n *\n * The second constraint can be rewritten as\n *\n *\t2 * [(-i-2j+3)/4] + k >= 0\n *\n * from which we can derive\n *\n *\t-i - 2j + 3 >= -2k\n *\n * or\n *\n *\ti + 2j <= 3 + 2k\n *\n * Combined with the first constraint, we obtain\n *\n *\t-3 <= 3 + 2k\tor\tk >= -3\n *\n * If, on the other hand we derive a constraint on [(i+2j)/4] from\n * the first constraint, we obtain\n *\n *\t[(i + 2j)/4] >= [-3/4] = -1\n *\n * Combining this constraint with the second constraint, we obtain\n *\n *\tk >= -2\n */\nstatic __isl_give isl_basic_map *insert_bounds_on_div(\n\t__isl_take isl_basic_map *bmap, int div)\n{\n\tint i;\n\tint check_lb, check_ub;\n\tisl_int v;\n\tisl_size v_div;\n\n\tif (!bmap)\n\t\treturn NULL;\n\n\tif (isl_int_is_zero(bmap->div[div][0]))\n\t\treturn bmap;\n\n\tv_div = isl_basic_map_var_offset(bmap, isl_dim_div);\n\tif (v_div < 0)\n\t\treturn isl_basic_map_free(bmap);\n\n\tcheck_lb = 0;\n\tcheck_ub = 0;\n\tfor (i = 0; (!check_lb || !check_ub) && i < bmap->n_ineq; ++i) {\n\t\tint s = isl_int_sgn(bmap->ineq[i][1 + v_div + div]);\n\t\tif (s > 0)\n\t\t\tcheck_ub = 1;\n\t\tif (s < 0)\n\t\t\tcheck_lb = 1;\n\t}\n\n\tif (!check_lb && !check_ub)\n\t\treturn bmap;\n\n\tisl_int_init(v);\n\n\tfor (i = 0; bmap && i < bmap->n_ineq; ++i) {\n\t\tif (!isl_int_is_zero(bmap->ineq[i][1 + v_div + div]))\n\t\t\tcontinue;\n\n\t\tbmap = insert_bounds_on_div_from_ineq(bmap, div, i, v_div, v,\n\t\t\t\t\t\t\tcheck_lb, check_ub);\n\t}\n\n\tisl_int_clear(v);\n\n\treturn bmap;\n}\n\n/* Remove all divs (recursively) involving any of the given dimensions\n * in their definitions.\n */\n__isl_give isl_basic_map *isl_basic_map_remove_divs_involving_dims(\n\t__isl_take isl_basic_map *bmap,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\tint i;\n\n\tif (isl_basic_map_check_range(bmap, type, first, n) < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tfirst += isl_basic_map_offset(bmap, type);\n\n\tfor (i = bmap->n_div - 1; i >= 0; --i) {\n\t\tisl_bool involves;\n\n\t\tinvolves = div_involves_vars(bmap, i, first, n);\n\t\tif (involves < 0)\n\t\t\treturn isl_basic_map_free(bmap);\n\t\tif (!involves)\n\t\t\tcontinue;\n\t\tbmap = insert_bounds_on_div(bmap, i);\n\t\tbmap = isl_basic_map_remove_dims(bmap, isl_dim_div, i, 1);\n\t\tif (!bmap)\n\t\t\treturn NULL;\n\t\ti = bmap->n_div;\n\t}\n\n\treturn bmap;\n}\n\n__isl_give isl_basic_set *isl_basic_set_remove_divs_involving_dims(\n\t__isl_take isl_basic_set *bset,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\treturn isl_basic_map_remove_divs_involving_dims(bset, type, first, n);\n}\n\n__isl_give isl_map *isl_map_remove_divs_involving_dims(__isl_take isl_map *map,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\tint i;\n\n\tif (!map)\n\t\treturn NULL;\n\tif (map->n == 0)\n\t\treturn map;\n\n\tmap = isl_map_cow(map);\n\tif (!map)\n\t\treturn NULL;\n\n\tfor (i = 0; i < map->n; ++i) {\n\t\tmap->p[i] = isl_basic_map_remove_divs_involving_dims(map->p[i],\n\t\t\t\t\t\t\t\ttype, first, n);\n\t\tif (!map->p[i])\n\t\t\tgoto error;\n\t}\n\treturn map;\nerror:\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n__isl_give isl_set *isl_set_remove_divs_involving_dims(__isl_take isl_set *set,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\treturn set_from_map(isl_map_remove_divs_involving_dims(set_to_map(set),\n\t\t\t\t\t\t\t      type, first, n));\n}\n\n/* Does the description of \"bmap\" depend on the specified dimensions?\n * We also check whether the dimensions appear in any of the div definitions.\n * In principle there is no need for this check.  If the dimensions appear\n * in a div definition, they also appear in the defining constraints of that\n * div.\n */\nisl_bool isl_basic_map_involves_dims(__isl_keep isl_basic_map *bmap,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\tint i;\n\n\tif (isl_basic_map_check_range(bmap, type, first, n) < 0)\n\t\treturn isl_bool_error;\n\n\tfirst += isl_basic_map_offset(bmap, type);\n\tfor (i = 0; i < bmap->n_eq; ++i)\n\t\tif (isl_seq_first_non_zero(bmap->eq[i] + first, n) >= 0)\n\t\t\treturn isl_bool_true;\n\tfor (i = 0; i < bmap->n_ineq; ++i)\n\t\tif (isl_seq_first_non_zero(bmap->ineq[i] + first, n) >= 0)\n\t\t\treturn isl_bool_true;\n\tfor (i = 0; i < bmap->n_div; ++i) {\n\t\tif (isl_int_is_zero(bmap->div[i][0]))\n\t\t\tcontinue;\n\t\tif (isl_seq_first_non_zero(bmap->div[i] + 1 + first, n) >= 0)\n\t\t\treturn isl_bool_true;\n\t}\n\n\treturn isl_bool_false;\n}\n\nisl_bool isl_map_involves_dims(__isl_keep isl_map *map,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\tint i;\n\n\tif (isl_map_check_range(map, type, first, n) < 0)\n\t\treturn isl_bool_error;\n\n\tfor (i = 0; i < map->n; ++i) {\n\t\tisl_bool involves = isl_basic_map_involves_dims(map->p[i],\n\t\t\t\t\t\t\t    type, first, n);\n\t\tif (involves < 0 || involves)\n\t\t\treturn involves;\n\t}\n\n\treturn isl_bool_false;\n}\n\nisl_bool isl_basic_set_involves_dims(__isl_keep isl_basic_set *bset,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\treturn isl_basic_map_involves_dims(bset, type, first, n);\n}\n\nisl_bool isl_set_involves_dims(__isl_keep isl_set *set,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\treturn isl_map_involves_dims(set, type, first, n);\n}\n\n/* Does \"bset\" involve any local variables, i.e., integer divisions?\n */\nstatic isl_bool isl_basic_set_involves_locals(__isl_keep isl_basic_set *bset)\n{\n\tisl_size n;\n\n\tn = isl_basic_set_dim(bset, isl_dim_div);\n\tif (n < 0)\n\t\treturn isl_bool_error;\n\treturn isl_bool_ok(n > 0);\n}\n\n/* isl_set_every_basic_set callback that checks whether \"bset\"\n * is free of local variables.\n */\nstatic isl_bool basic_set_no_locals(__isl_keep isl_basic_set *bset, void *user)\n{\n\treturn isl_bool_not(isl_basic_set_involves_locals(bset));\n}\n\n/* Does \"set\" involve any local variables, i.e., integer divisions?\n */\nisl_bool isl_set_involves_locals(__isl_keep isl_set *set)\n{\n\tisl_bool no_locals;\n\n\tno_locals = isl_set_every_basic_set(set, &basic_set_no_locals, NULL);\n\treturn isl_bool_not(no_locals);\n}\n\n/* Drop all constraints in bmap that involve any of the dimensions\n * first to first+n-1.\n * This function only performs the actual removal of constraints.\n *\n * This function should not call finalize since it is used by\n * remove_redundant_divs, which in turn is called by isl_basic_map_finalize.\n */\n__isl_give isl_basic_map *isl_basic_map_drop_constraints_involving(\n\t__isl_take isl_basic_map *bmap, unsigned first, unsigned n)\n{\n\tint i;\n\n\tif (n == 0)\n\t\treturn bmap;\n\n\tbmap = isl_basic_map_cow(bmap);\n\n\tif (!bmap)\n\t\treturn NULL;\n\n\tfor (i = bmap->n_eq - 1; i >= 0; --i) {\n\t\tif (isl_seq_first_non_zero(bmap->eq[i] + 1 + first, n) == -1)\n\t\t\tcontinue;\n\t\tif (isl_basic_map_drop_equality(bmap, i) < 0)\n\t\t\treturn isl_basic_map_free(bmap);\n\t}\n\n\tfor (i = bmap->n_ineq - 1; i >= 0; --i) {\n\t\tif (isl_seq_first_non_zero(bmap->ineq[i] + 1 + first, n) == -1)\n\t\t\tcontinue;\n\t\tif (isl_basic_map_drop_inequality(bmap, i) < 0)\n\t\t\treturn isl_basic_map_free(bmap);\n\t}\n\n\treturn bmap;\n}\n\n/* Drop all constraints in bset that involve any of the dimensions\n * first to first+n-1.\n * This function only performs the actual removal of constraints.\n */\n__isl_give isl_basic_set *isl_basic_set_drop_constraints_involving(\n\t__isl_take isl_basic_set *bset, unsigned first, unsigned n)\n{\n\treturn isl_basic_map_drop_constraints_involving(bset, first, n);\n}\n\n/* Drop all constraints in bmap that do not involve any of the dimensions\n * first to first + n - 1 of the given type.\n */\n__isl_give isl_basic_map *isl_basic_map_drop_constraints_not_involving_dims(\n\t__isl_take isl_basic_map *bmap,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\tint i;\n\n\tif (n == 0) {\n\t\tisl_space *space = isl_basic_map_get_space(bmap);\n\t\tisl_basic_map_free(bmap);\n\t\treturn isl_basic_map_universe(space);\n\t}\n\tbmap = isl_basic_map_cow(bmap);\n\tif (!bmap)\n\t\treturn NULL;\n\n\tif (isl_basic_map_check_range(bmap, type, first, n) < 0)\n\t\treturn isl_basic_map_free(bmap);\n\n\tfirst += isl_basic_map_offset(bmap, type) - 1;\n\n\tfor (i = bmap->n_eq - 1; i >= 0; --i) {\n\t\tif (isl_seq_first_non_zero(bmap->eq[i] + 1 + first, n) != -1)\n\t\t\tcontinue;\n\t\tif (isl_basic_map_drop_equality(bmap, i) < 0)\n\t\t\treturn isl_basic_map_free(bmap);\n\t}\n\n\tfor (i = bmap->n_ineq - 1; i >= 0; --i) {\n\t\tif (isl_seq_first_non_zero(bmap->ineq[i] + 1 + first, n) != -1)\n\t\t\tcontinue;\n\t\tif (isl_basic_map_drop_inequality(bmap, i) < 0)\n\t\t\treturn isl_basic_map_free(bmap);\n\t}\n\n\tbmap = isl_basic_map_add_known_div_constraints(bmap);\n\treturn bmap;\n}\n\n/* Drop all constraints in bset that do not involve any of the dimensions\n * first to first + n - 1 of the given type.\n */\n__isl_give isl_basic_set *isl_basic_set_drop_constraints_not_involving_dims(\n\t__isl_take isl_basic_set *bset,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\treturn isl_basic_map_drop_constraints_not_involving_dims(bset,\n\t\t\t\t\t\t\t    type, first, n);\n}\n\n/* Drop all constraints in bmap that involve any of the dimensions\n * first to first + n - 1 of the given type.\n */\n__isl_give isl_basic_map *isl_basic_map_drop_constraints_involving_dims(\n\t__isl_take isl_basic_map *bmap,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\tif (!bmap)\n\t\treturn NULL;\n\tif (n == 0)\n\t\treturn bmap;\n\n\tif (isl_basic_map_check_range(bmap, type, first, n) < 0)\n\t\treturn isl_basic_map_free(bmap);\n\n\tbmap = isl_basic_map_remove_divs_involving_dims(bmap, type, first, n);\n\tfirst += isl_basic_map_offset(bmap, type) - 1;\n\tbmap = isl_basic_map_drop_constraints_involving(bmap, first, n);\n\tbmap = isl_basic_map_add_known_div_constraints(bmap);\n\treturn bmap;\n}\n\n/* Drop all constraints in bset that involve any of the dimensions\n * first to first + n - 1 of the given type.\n */\n__isl_give isl_basic_set *isl_basic_set_drop_constraints_involving_dims(\n\t__isl_take isl_basic_set *bset,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\treturn isl_basic_map_drop_constraints_involving_dims(bset,\n\t\t\t\t\t\t\t    type, first, n);\n}\n\n/* Drop constraints from \"map\" by applying \"drop\" to each basic map.\n */\nstatic __isl_give isl_map *drop_constraints(__isl_take isl_map *map,\n\tenum isl_dim_type type, unsigned first, unsigned n,\n\t__isl_give isl_basic_map *(*drop)(__isl_take isl_basic_map *bmap,\n\t\tenum isl_dim_type type, unsigned first, unsigned n))\n{\n\tint i;\n\n\tif (isl_map_check_range(map, type, first, n) < 0)\n\t\treturn isl_map_free(map);\n\n\tmap = isl_map_cow(map);\n\tif (!map)\n\t\treturn NULL;\n\n\tfor (i = 0; i < map->n; ++i) {\n\t\tmap->p[i] = drop(map->p[i], type, first, n);\n\t\tif (!map->p[i])\n\t\t\treturn isl_map_free(map);\n\t}\n\n\tif (map->n > 1)\n\t\tISL_F_CLR(map, ISL_MAP_DISJOINT);\n\n\treturn map;\n}\n\n/* Drop all constraints in map that involve any of the dimensions\n * first to first + n - 1 of the given type.\n */\n__isl_give isl_map *isl_map_drop_constraints_involving_dims(\n\t__isl_take isl_map *map,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\tif (n == 0)\n\t\treturn map;\n\treturn drop_constraints(map, type, first, n,\n\t\t\t\t&isl_basic_map_drop_constraints_involving_dims);\n}\n\n/* Drop all constraints in \"map\" that do not involve any of the dimensions\n * first to first + n - 1 of the given type.\n */\n__isl_give isl_map *isl_map_drop_constraints_not_involving_dims(\n\t__isl_take isl_map *map,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\tif (n == 0) {\n\t\tisl_space *space = isl_map_get_space(map);\n\t\tisl_map_free(map);\n\t\treturn isl_map_universe(space);\n\t}\n\treturn drop_constraints(map, type, first, n,\n\t\t\t    &isl_basic_map_drop_constraints_not_involving_dims);\n}\n\n/* Drop all constraints in set that involve any of the dimensions\n * first to first + n - 1 of the given type.\n */\n__isl_give isl_set *isl_set_drop_constraints_involving_dims(\n\t__isl_take isl_set *set,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\treturn isl_map_drop_constraints_involving_dims(set, type, first, n);\n}\n\n/* Drop all constraints in \"set\" that do not involve any of the dimensions\n * first to first + n - 1 of the given type.\n */\n__isl_give isl_set *isl_set_drop_constraints_not_involving_dims(\n\t__isl_take isl_set *set,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\treturn isl_map_drop_constraints_not_involving_dims(set, type, first, n);\n}\n\n/* Does local variable \"div\" of \"bmap\" have a complete explicit representation?\n * Having a complete explicit representation requires not only\n * an explicit representation, but also that all local variables\n * that appear in this explicit representation in turn have\n * a complete explicit representation.\n */\nisl_bool isl_basic_map_div_is_known(__isl_keep isl_basic_map *bmap, int div)\n{\n\tint i;\n\tunsigned div_offset = isl_basic_map_offset(bmap, isl_dim_div);\n\tisl_bool marked;\n\n\tmarked = isl_basic_map_div_is_marked_unknown(bmap, div);\n\tif (marked < 0 || marked)\n\t\treturn isl_bool_not(marked);\n\n\tfor (i = bmap->n_div - 1; i >= 0; --i) {\n\t\tisl_bool known;\n\n\t\tif (isl_int_is_zero(bmap->div[div][1 + div_offset + i]))\n\t\t\tcontinue;\n\t\tknown = isl_basic_map_div_is_known(bmap, i);\n\t\tif (known < 0 || !known)\n\t\t\treturn known;\n\t}\n\n\treturn isl_bool_true;\n}\n\n/* Remove all divs that are unknown or defined in terms of unknown divs.\n */\n__isl_give isl_basic_map *isl_basic_map_remove_unknown_divs(\n\t__isl_take isl_basic_map *bmap)\n{\n\tint i;\n\n\tif (!bmap)\n\t\treturn NULL;\n\n\tfor (i = bmap->n_div - 1; i >= 0; --i) {\n\t\tif (isl_basic_map_div_is_known(bmap, i))\n\t\t\tcontinue;\n\t\tbmap = isl_basic_map_remove_dims(bmap, isl_dim_div, i, 1);\n\t\tif (!bmap)\n\t\t\treturn NULL;\n\t\ti = bmap->n_div;\n\t}\n\n\treturn bmap;\n}\n\n/* Remove all divs that are unknown or defined in terms of unknown divs.\n */\n__isl_give isl_basic_set *isl_basic_set_remove_unknown_divs(\n\t__isl_take isl_basic_set *bset)\n{\n\treturn isl_basic_map_remove_unknown_divs(bset);\n}\n\n__isl_give isl_map *isl_map_remove_unknown_divs(__isl_take isl_map *map)\n{\n\tint i;\n\n\tif (!map)\n\t\treturn NULL;\n\tif (map->n == 0)\n\t\treturn map;\n\n\tmap = isl_map_cow(map);\n\tif (!map)\n\t\treturn NULL;\n\n\tfor (i = 0; i < map->n; ++i) {\n\t\tmap->p[i] = isl_basic_map_remove_unknown_divs(map->p[i]);\n\t\tif (!map->p[i])\n\t\t\tgoto error;\n\t}\n\treturn map;\nerror:\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n__isl_give isl_set *isl_set_remove_unknown_divs(__isl_take isl_set *set)\n{\n\treturn set_from_map(isl_map_remove_unknown_divs(set_to_map(set)));\n}\n\n__isl_give isl_basic_set *isl_basic_set_remove_dims(\n\t__isl_take isl_basic_set *bset,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\tisl_basic_map *bmap = bset_to_bmap(bset);\n\tbmap = isl_basic_map_remove_dims(bmap, type, first, n);\n\treturn bset_from_bmap(bmap);\n}\n\n__isl_give isl_map *isl_map_remove_dims(__isl_take isl_map *map,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\tint i;\n\n\tif (n == 0)\n\t\treturn map;\n\n\tmap = isl_map_cow(map);\n\tif (isl_map_check_range(map, type, first, n) < 0)\n\t\treturn isl_map_free(map);\n\t\n\tfor (i = 0; i < map->n; ++i) {\n\t\tmap->p[i] = isl_basic_map_eliminate_vars(map->p[i],\n\t\t\tisl_basic_map_offset(map->p[i], type) - 1 + first, n);\n\t\tif (!map->p[i])\n\t\t\tgoto error;\n\t}\n\tmap = isl_map_drop(map, type, first, n);\n\treturn map;\nerror:\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n__isl_give isl_set *isl_set_remove_dims(__isl_take isl_set *bset,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\treturn set_from_map(isl_map_remove_dims(set_to_map(bset),\n\t\t\t\t\t\ttype, first, n));\n}\n\n/* Project out n inputs starting at first using Fourier-Motzkin */\n__isl_give isl_map *isl_map_remove_inputs(__isl_take isl_map *map,\n\tunsigned first, unsigned n)\n{\n\treturn isl_map_remove_dims(map, isl_dim_in, first, n);\n}\n\nvoid isl_basic_set_print_internal(__isl_keep isl_basic_set *bset,\n\tFILE *out, int indent)\n{\n\tisl_printer *p;\n\n\tif (!bset) {\n\t\tfprintf(out, \"null basic set\\n\");\n\t\treturn;\n\t}\n\n\tfprintf(out, \"%*s\", indent, \"\");\n\tfprintf(out, \"ref: %d, nparam: %d, dim: %d, extra: %d, flags: %x\\n\",\n\t\t\tbset->ref, bset->dim->nparam, bset->dim->n_out,\n\t\t\tbset->extra, bset->flags);\n\n\tp = isl_printer_to_file(isl_basic_set_get_ctx(bset), out);\n\tp = isl_printer_set_dump(p, 1);\n\tp = isl_printer_set_indent(p, indent);\n\tp = isl_printer_start_line(p);\n\tp = isl_printer_print_basic_set(p, bset);\n\tp = isl_printer_end_line(p);\n\tisl_printer_free(p);\n}\n\nvoid isl_basic_map_print_internal(__isl_keep isl_basic_map *bmap,\n\tFILE *out, int indent)\n{\n\tisl_printer *p;\n\n\tif (!bmap) {\n\t\tfprintf(out, \"null basic map\\n\");\n\t\treturn;\n\t}\n\n\tfprintf(out, \"%*s\", indent, \"\");\n\tfprintf(out, \"ref: %d, nparam: %d, in: %d, out: %d, extra: %d, \"\n\t\t\t\"flags: %x, n_name: %d\\n\",\n\t\tbmap->ref,\n\t\tbmap->dim->nparam, bmap->dim->n_in, bmap->dim->n_out,\n\t\tbmap->extra, bmap->flags, bmap->dim->n_id);\n\n\tp = isl_printer_to_file(isl_basic_map_get_ctx(bmap), out);\n\tp = isl_printer_set_dump(p, 1);\n\tp = isl_printer_set_indent(p, indent);\n\tp = isl_printer_start_line(p);\n\tp = isl_printer_print_basic_map(p, bmap);\n\tp = isl_printer_end_line(p);\n\tisl_printer_free(p);\n}\n\n__isl_give isl_basic_map *isl_inequality_negate(__isl_take isl_basic_map *bmap,\n\tunsigned pos)\n{\n\tisl_size total;\n\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tif (total < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tif (pos >= bmap->n_ineq)\n\t\tisl_die(isl_basic_map_get_ctx(bmap), isl_error_invalid,\n\t\t\t\"invalid position\", return isl_basic_map_free(bmap));\n\tisl_seq_neg(bmap->ineq[pos], bmap->ineq[pos], 1 + total);\n\tisl_int_sub_ui(bmap->ineq[pos][0], bmap->ineq[pos][0], 1);\n\tISL_F_CLR(bmap, ISL_BASIC_MAP_NO_REDUNDANT);\n\tISL_F_CLR(bmap, ISL_BASIC_MAP_SORTED);\n\treturn bmap;\n}\n\n__isl_give isl_set *isl_set_alloc_space(__isl_take isl_space *space, int n,\n\tunsigned flags)\n{\n\tif (isl_space_check_is_set(space) < 0)\n\t\tgoto error;\n\treturn isl_map_alloc_space(space, n, flags);\nerror:\n\tisl_space_free(space);\n\treturn NULL;\n}\n\n/* Make sure \"map\" has room for at least \"n\" more basic maps.\n */\n__isl_give isl_map *isl_map_grow(__isl_take isl_map *map, int n)\n{\n\tint i;\n\tstruct isl_map *grown = NULL;\n\n\tif (!map)\n\t\treturn NULL;\n\tisl_assert(map->ctx, n >= 0, goto error);\n\tif (map->n + n <= map->size)\n\t\treturn map;\n\tgrown = isl_map_alloc_space(isl_map_get_space(map), map->n + n, map->flags);\n\tif (!grown)\n\t\tgoto error;\n\tfor (i = 0; i < map->n; ++i) {\n\t\tgrown->p[i] = isl_basic_map_copy(map->p[i]);\n\t\tif (!grown->p[i])\n\t\t\tgoto error;\n\t\tgrown->n++;\n\t}\n\tisl_map_free(map);\n\treturn grown;\nerror:\n\tisl_map_free(grown);\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n/* Make sure \"set\" has room for at least \"n\" more basic sets.\n */\n__isl_give isl_set *isl_set_grow(__isl_take isl_set *set, int n)\n{\n\treturn set_from_map(isl_map_grow(set_to_map(set), n));\n}\n\n__isl_give isl_set *isl_set_from_basic_set(__isl_take isl_basic_set *bset)\n{\n\treturn isl_map_from_basic_map(bset);\n}\n\n__isl_give isl_map *isl_map_from_basic_map(__isl_take isl_basic_map *bmap)\n{\n\tstruct isl_map *map;\n\n\tif (!bmap)\n\t\treturn NULL;\n\n\tmap = isl_map_alloc_space(isl_space_copy(bmap->dim), 1, ISL_MAP_DISJOINT);\n\treturn isl_map_add_basic_map(map, bmap);\n}\n\n__isl_give isl_set *isl_set_add_basic_set(__isl_take isl_set *set,\n\t\t\t\t\t\t__isl_take isl_basic_set *bset)\n{\n\treturn set_from_map(isl_map_add_basic_map(set_to_map(set),\n\t\t\t\t\t\tbset_to_bmap(bset)));\n}\n\n__isl_null isl_set *isl_set_free(__isl_take isl_set *set)\n{\n\treturn isl_map_free(set);\n}\n\nvoid isl_set_print_internal(__isl_keep isl_set *set, FILE *out, int indent)\n{\n\tint i;\n\n\tif (!set) {\n\t\tfprintf(out, \"null set\\n\");\n\t\treturn;\n\t}\n\n\tfprintf(out, \"%*s\", indent, \"\");\n\tfprintf(out, \"ref: %d, n: %d, nparam: %d, dim: %d, flags: %x\\n\",\n\t\t\tset->ref, set->n, set->dim->nparam, set->dim->n_out,\n\t\t\tset->flags);\n\tfor (i = 0; i < set->n; ++i) {\n\t\tfprintf(out, \"%*s\", indent, \"\");\n\t\tfprintf(out, \"basic set %d:\\n\", i);\n\t\tisl_basic_set_print_internal(set->p[i], out, indent+4);\n\t}\n}\n\nvoid isl_map_print_internal(__isl_keep isl_map *map, FILE *out, int indent)\n{\n\tint i;\n\n\tif (!map) {\n\t\tfprintf(out, \"null map\\n\");\n\t\treturn;\n\t}\n\n\tfprintf(out, \"%*s\", indent, \"\");\n\tfprintf(out, \"ref: %d, n: %d, nparam: %d, in: %d, out: %d, \"\n\t\t     \"flags: %x, n_name: %d\\n\",\n\t\t\tmap->ref, map->n, map->dim->nparam, map->dim->n_in,\n\t\t\tmap->dim->n_out, map->flags, map->dim->n_id);\n\tfor (i = 0; i < map->n; ++i) {\n\t\tfprintf(out, \"%*s\", indent, \"\");\n\t\tfprintf(out, \"basic map %d:\\n\", i);\n\t\tisl_basic_map_print_internal(map->p[i], out, indent+4);\n\t}\n}\n\n/* Check that the space of \"bset\" is the same as that of the domain of \"bmap\".\n */\nstatic isl_stat isl_basic_map_check_compatible_domain(\n\t__isl_keep isl_basic_map *bmap, __isl_keep isl_basic_set *bset)\n{\n\tisl_bool ok;\n\n\tok = isl_basic_map_compatible_domain(bmap, bset);\n\tif (ok < 0)\n\t\treturn isl_stat_error;\n\tif (!ok)\n\t\tisl_die(isl_basic_set_get_ctx(bset), isl_error_invalid,\n\t\t\t\"incompatible spaces\", return isl_stat_error);\n\n\treturn isl_stat_ok;\n}\n\n__isl_give isl_basic_map *isl_basic_map_intersect_domain(\n\t__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *bset)\n{\n\tstruct isl_basic_map *bmap_domain;\n\tisl_size dim;\n\n\tif (isl_basic_map_check_equal_params(bmap, bset_to_bmap(bset)) < 0)\n\t\tgoto error;\n\n\tdim = isl_basic_set_dim(bset, isl_dim_set);\n\tif (dim < 0)\n\t\tgoto error;\n\tif (dim != 0 &&\n\t    isl_basic_map_check_compatible_domain(bmap, bset) < 0)\n\t\tgoto error;\n\n\tbmap = isl_basic_map_cow(bmap);\n\tif (!bmap)\n\t\tgoto error;\n\tbmap = isl_basic_map_extend(bmap,\n\t\t\tbset->n_div, bset->n_eq, bset->n_ineq);\n\tbmap_domain = isl_basic_map_from_domain(bset);\n\tbmap = add_constraints(bmap, bmap_domain, 0, 0);\n\n\tbmap = isl_basic_map_simplify(bmap);\n\treturn isl_basic_map_finalize(bmap);\nerror:\n\tisl_basic_map_free(bmap);\n\tisl_basic_set_free(bset);\n\treturn NULL;\n}\n\n/* Check that the space of \"bset\" is the same as that of the range of \"bmap\".\n */\nstatic isl_stat isl_basic_map_check_compatible_range(\n\t__isl_keep isl_basic_map *bmap, __isl_keep isl_basic_set *bset)\n{\n\tisl_bool ok;\n\n\tok = isl_basic_map_compatible_range(bmap, bset);\n\tif (ok < 0)\n\t\treturn isl_stat_error;\n\tif (!ok)\n\t\tisl_die(isl_basic_set_get_ctx(bset), isl_error_invalid,\n\t\t\t\"incompatible spaces\", return isl_stat_error);\n\n\treturn isl_stat_ok;\n}\n\n__isl_give isl_basic_map *isl_basic_map_intersect_range(\n\t__isl_take isl_basic_map *bmap, __isl_take isl_basic_set *bset)\n{\n\tstruct isl_basic_map *bmap_range;\n\tisl_size dim;\n\n\tif (isl_basic_map_check_equal_params(bmap, bset_to_bmap(bset)) < 0)\n\t\tgoto error;\n\n\tdim = isl_basic_set_dim(bset, isl_dim_set);\n\tif (dim < 0)\n\t\tgoto error;\n\tif (dim != 0 && isl_basic_map_check_compatible_range(bmap, bset) < 0)\n\t\tgoto error;\n\n\tif (isl_basic_set_plain_is_universe(bset)) {\n\t\tisl_basic_set_free(bset);\n\t\treturn bmap;\n\t}\n\n\tbmap = isl_basic_map_cow(bmap);\n\tif (!bmap)\n\t\tgoto error;\n\tbmap = isl_basic_map_extend(bmap,\n\t\t\tbset->n_div, bset->n_eq, bset->n_ineq);\n\tbmap_range = bset_to_bmap(bset);\n\tbmap = add_constraints(bmap, bmap_range, 0, 0);\n\n\tbmap = isl_basic_map_simplify(bmap);\n\treturn isl_basic_map_finalize(bmap);\nerror:\n\tisl_basic_map_free(bmap);\n\tisl_basic_set_free(bset);\n\treturn NULL;\n}\n\nisl_bool isl_basic_map_contains(__isl_keep isl_basic_map *bmap,\n\t__isl_keep isl_vec *vec)\n{\n\tint i;\n\tisl_size total;\n\tisl_int s;\n\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tif (total < 0 || !vec)\n\t\treturn isl_bool_error;\n\n\tif (1 + total != vec->size)\n\t\treturn isl_bool_false;\n\n\tisl_int_init(s);\n\n\tfor (i = 0; i < bmap->n_eq; ++i) {\n\t\tisl_seq_inner_product(vec->el, bmap->eq[i], 1 + total, &s);\n\t\tif (!isl_int_is_zero(s)) {\n\t\t\tisl_int_clear(s);\n\t\t\treturn isl_bool_false;\n\t\t}\n\t}\n\n\tfor (i = 0; i < bmap->n_ineq; ++i) {\n\t\tisl_seq_inner_product(vec->el, bmap->ineq[i], 1 + total, &s);\n\t\tif (isl_int_is_neg(s)) {\n\t\t\tisl_int_clear(s);\n\t\t\treturn isl_bool_false;\n\t\t}\n\t}\n\n\tisl_int_clear(s);\n\n\treturn isl_bool_true;\n}\n\nisl_bool isl_basic_set_contains(__isl_keep isl_basic_set *bset,\n\t__isl_keep isl_vec *vec)\n{\n\treturn isl_basic_map_contains(bset_to_bmap(bset), vec);\n}\n\n__isl_give isl_basic_map *isl_basic_map_intersect(\n\t__isl_take isl_basic_map *bmap1, __isl_take isl_basic_map *bmap2)\n{\n\tstruct isl_vec *sample = NULL;\n\tisl_space *space1, *space2;\n\tisl_size dim1, dim2, nparam1, nparam2;\n\n\tif (isl_basic_map_check_equal_params(bmap1, bmap2) < 0)\n\t\tgoto error;\n\tspace1 = isl_basic_map_peek_space(bmap1);\n\tspace2 = isl_basic_map_peek_space(bmap2);\n\tdim1 = isl_space_dim(space1, isl_dim_all);\n\tdim2 = isl_space_dim(space2, isl_dim_all);\n\tnparam1 = isl_space_dim(space1, isl_dim_param);\n\tnparam2 = isl_space_dim(space2, isl_dim_param);\n\tif (dim1 < 0 || dim2 < 0 || nparam1 < 0 || nparam2 < 0)\n\t\tgoto error;\n\tif (dim1 == nparam1 && dim2 != nparam2)\n\t\treturn isl_basic_map_intersect(bmap2, bmap1);\n\n\tif (dim2 != nparam2 &&\n\t    isl_basic_map_check_equal_space(bmap1, bmap2) < 0)\n\t\tgoto error;\n\n\tif (isl_basic_map_plain_is_empty(bmap1)) {\n\t\tisl_basic_map_free(bmap2);\n\t\treturn bmap1;\n\t}\n\tif (isl_basic_map_plain_is_empty(bmap2)) {\n\t\tisl_basic_map_free(bmap1);\n\t\treturn bmap2;\n\t}\n\n\tif (bmap1->sample &&\n\t    isl_basic_map_contains(bmap1, bmap1->sample) > 0 &&\n\t    isl_basic_map_contains(bmap2, bmap1->sample) > 0)\n\t\tsample = isl_vec_copy(bmap1->sample);\n\telse if (bmap2->sample &&\n\t    isl_basic_map_contains(bmap1, bmap2->sample) > 0 &&\n\t    isl_basic_map_contains(bmap2, bmap2->sample) > 0)\n\t\tsample = isl_vec_copy(bmap2->sample);\n\n\tbmap1 = isl_basic_map_cow(bmap1);\n\tif (!bmap1)\n\t\tgoto error;\n\tbmap1 = isl_basic_map_extend(bmap1,\n\t\t\tbmap2->n_div, bmap2->n_eq, bmap2->n_ineq);\n\tbmap1 = add_constraints(bmap1, bmap2, 0, 0);\n\n\tif (!bmap1)\n\t\tisl_vec_free(sample);\n\telse if (sample) {\n\t\tisl_vec_free(bmap1->sample);\n\t\tbmap1->sample = sample;\n\t}\n\n\tbmap1 = isl_basic_map_simplify(bmap1);\n\treturn isl_basic_map_finalize(bmap1);\nerror:\n\tif (sample)\n\t\tisl_vec_free(sample);\n\tisl_basic_map_free(bmap1);\n\tisl_basic_map_free(bmap2);\n\treturn NULL;\n}\n\n__isl_give isl_basic_set *isl_basic_set_intersect(\n\t__isl_take isl_basic_set *bset1, __isl_take isl_basic_set *bset2)\n{\n\treturn bset_from_bmap(isl_basic_map_intersect(bset_to_bmap(bset1),\n\t\t\t\t\t\t\tbset_to_bmap(bset2)));\n}\n\n__isl_give isl_basic_set *isl_basic_set_intersect_params(\n\t__isl_take isl_basic_set *bset1, __isl_take isl_basic_set *bset2)\n{\n\treturn isl_basic_set_intersect(bset1, bset2);\n}\n\n/* Special case of isl_map_intersect, where both map1 and map2\n * are convex, without any divs and such that either map1 or map2\n * contains a single constraint.  This constraint is then simply\n * added to the other map.\n */\nstatic __isl_give isl_map *map_intersect_add_constraint(\n\t__isl_take isl_map *map1, __isl_take isl_map *map2)\n{\n\tisl_assert(map1->ctx, map1->n == 1, goto error);\n\tisl_assert(map2->ctx, map1->n == 1, goto error);\n\tisl_assert(map1->ctx, map1->p[0]->n_div == 0, goto error);\n\tisl_assert(map2->ctx, map1->p[0]->n_div == 0, goto error);\n\n\tif (map2->p[0]->n_eq + map2->p[0]->n_ineq != 1)\n\t\treturn isl_map_intersect(map2, map1);\n\n\tmap1 = isl_map_cow(map1);\n\tif (!map1)\n\t\tgoto error;\n\tif (isl_map_plain_is_empty(map1)) {\n\t\tisl_map_free(map2);\n\t\treturn map1;\n\t}\n\tif (map2->p[0]->n_eq == 1)\n\t\tmap1->p[0] = isl_basic_map_add_eq(map1->p[0], map2->p[0]->eq[0]);\n\telse\n\t\tmap1->p[0] = isl_basic_map_add_ineq(map1->p[0],\n\t\t\t\t\t\t\tmap2->p[0]->ineq[0]);\n\n\tmap1->p[0] = isl_basic_map_simplify(map1->p[0]);\n\tmap1->p[0] = isl_basic_map_finalize(map1->p[0]);\n\tif (!map1->p[0])\n\t\tgoto error;\n\n\tif (isl_basic_map_plain_is_empty(map1->p[0])) {\n\t\tisl_basic_map_free(map1->p[0]);\n\t\tmap1->n = 0;\n\t}\n\n\tisl_map_free(map2);\n\n\tmap1 = isl_map_unmark_normalized(map1);\n\treturn map1;\nerror:\n\tisl_map_free(map1);\n\tisl_map_free(map2);\n\treturn NULL;\n}\n\n/* map2 may be either a parameter domain or a map living in the same\n * space as map1.\n */\nstatic __isl_give isl_map *map_intersect_internal(__isl_take isl_map *map1,\n\t__isl_take isl_map *map2)\n{\n\tunsigned flags = 0;\n\tisl_bool equal;\n\tisl_map *result;\n\tint i, j;\n\tisl_size dim2, nparam2;\n\n\tif (!map1 || !map2)\n\t\tgoto error;\n\n\tif ((isl_map_plain_is_empty(map1) ||\n\t     isl_map_plain_is_universe(map2)) &&\n\t    isl_space_is_equal(map1->dim, map2->dim)) {\n\t\tisl_map_free(map2);\n\t\treturn map1;\n\t}\n\tif ((isl_map_plain_is_empty(map2) ||\n\t     isl_map_plain_is_universe(map1)) &&\n\t    isl_space_is_equal(map1->dim, map2->dim)) {\n\t\tisl_map_free(map1);\n\t\treturn map2;\n\t}\n\n\tif (map1->n == 1 && map2->n == 1 &&\n\t    map1->p[0]->n_div == 0 && map2->p[0]->n_div == 0 &&\n\t    isl_space_is_equal(map1->dim, map2->dim) &&\n\t    (map1->p[0]->n_eq + map1->p[0]->n_ineq == 1 ||\n\t     map2->p[0]->n_eq + map2->p[0]->n_ineq == 1))\n\t\treturn map_intersect_add_constraint(map1, map2);\n\n\tequal = isl_map_plain_is_equal(map1, map2);\n\tif (equal < 0)\n\t\tgoto error;\n\tif (equal) {\n\t\tisl_map_free(map2);\n\t\treturn map1;\n\t}\n\n\tdim2 = isl_map_dim(map2, isl_dim_all);\n\tnparam2 = isl_map_dim(map2, isl_dim_param);\n\tif (dim2 < 0 || nparam2 < 0)\n\t\tgoto error;\n\tif (dim2 != nparam2)\n\t\tisl_assert(map1->ctx,\n\t\t\t    isl_space_is_equal(map1->dim, map2->dim), goto error);\n\n\tif (ISL_F_ISSET(map1, ISL_MAP_DISJOINT) &&\n\t    ISL_F_ISSET(map2, ISL_MAP_DISJOINT))\n\t\tISL_FL_SET(flags, ISL_MAP_DISJOINT);\n\n\tresult = isl_map_alloc_space(isl_space_copy(map1->dim),\n\t\t\t\tmap1->n * map2->n, flags);\n\tif (!result)\n\t\tgoto error;\n\tfor (i = 0; i < map1->n; ++i)\n\t\tfor (j = 0; j < map2->n; ++j) {\n\t\t\tstruct isl_basic_map *part;\n\t\t\tpart = isl_basic_map_intersect(\n\t\t\t\t    isl_basic_map_copy(map1->p[i]),\n\t\t\t\t    isl_basic_map_copy(map2->p[j]));\n\t\t\tif (isl_basic_map_is_empty(part) < 0)\n\t\t\t\tpart = isl_basic_map_free(part);\n\t\t\tresult = isl_map_add_basic_map(result, part);\n\t\t\tif (!result)\n\t\t\t\tgoto error;\n\t\t}\n\tisl_map_free(map1);\n\tisl_map_free(map2);\n\treturn result;\nerror:\n\tisl_map_free(map1);\n\tisl_map_free(map2);\n\treturn NULL;\n}\n\nstatic __isl_give isl_map *map_intersect(__isl_take isl_map *map1,\n\t__isl_take isl_map *map2)\n{\n\tif (isl_map_check_equal_space(map1, map2) < 0)\n\t\tgoto error;\n\treturn map_intersect_internal(map1, map2);\nerror:\n\tisl_map_free(map1);\n\tisl_map_free(map2);\n\treturn NULL;\n}\n\n__isl_give isl_map *isl_map_intersect(__isl_take isl_map *map1,\n\t__isl_take isl_map *map2)\n{\n\tisl_map_align_params_bin(&map1, &map2);\n\treturn map_intersect(map1, map2);\n}\n\n__isl_give isl_set *isl_set_intersect(__isl_take isl_set *set1,\n\t__isl_take isl_set *set2)\n{\n\treturn set_from_map(isl_map_intersect(set_to_map(set1),\n\t\t\t\t\t      set_to_map(set2)));\n}\n\n/* map_intersect_internal accepts intersections\n * with parameter domains, so we can just call that function.\n */\n__isl_give isl_map *isl_map_intersect_params(__isl_take isl_map *map,\n\t__isl_take isl_set *params)\n{\n\tisl_map_align_params_set(&map, &params);\n\treturn map_intersect_internal(map, params);\n}\n\n__isl_give isl_set *isl_set_intersect_params(__isl_take isl_set *set,\n\t\t__isl_take isl_set *params)\n{\n\treturn isl_map_intersect_params(set, params);\n}\n\n__isl_give isl_basic_map *isl_basic_map_reverse(__isl_take isl_basic_map *bmap)\n{\n\tisl_space *space;\n\tunsigned pos;\n\tisl_size n1, n2;\n\n\tif (!bmap)\n\t\treturn NULL;\n\tbmap = isl_basic_map_cow(bmap);\n\tif (!bmap)\n\t\treturn NULL;\n\tspace = isl_space_reverse(isl_space_copy(bmap->dim));\n\tpos = isl_basic_map_offset(bmap, isl_dim_in);\n\tn1 = isl_basic_map_dim(bmap, isl_dim_in);\n\tn2 = isl_basic_map_dim(bmap, isl_dim_out);\n\tif (n1 < 0 || n2 < 0)\n\t\tbmap = isl_basic_map_free(bmap);\n\tbmap = isl_basic_map_swap_vars(bmap, pos, n1, n2);\n\treturn isl_basic_map_reset_space(bmap, space);\n}\n\n/* Given a basic map A -> (B -> C), return the corresponding basic map\n * A -> (C -> B).\n */\nstatic __isl_give isl_basic_map *isl_basic_map_range_reverse(\n\t__isl_take isl_basic_map *bmap)\n{\n\tisl_space *space;\n\tisl_size offset, n1, n2;\n\n\tspace = isl_basic_map_peek_space(bmap);\n\tif (isl_space_check_range_is_wrapping(space) < 0)\n\t\treturn isl_basic_map_free(bmap);\n\toffset = isl_basic_map_var_offset(bmap, isl_dim_out);\n\tn1 = isl_space_wrapped_dim(space, isl_dim_out, isl_dim_in);\n\tn2 = isl_space_wrapped_dim(space, isl_dim_out, isl_dim_out);\n\tif (offset < 0 || n1 < 0 || n2 < 0)\n\t\treturn isl_basic_map_free(bmap);\n\n\tbmap = isl_basic_map_swap_vars(bmap, 1 + offset, n1, n2);\n\n\tspace = isl_basic_map_take_space(bmap);\n\tspace = isl_space_range_reverse(space);\n\tbmap = isl_basic_map_restore_space(bmap, space);\n\n\treturn bmap;\n}\n\nstatic __isl_give isl_basic_map *basic_map_space_reset(\n\t__isl_take isl_basic_map *bmap, enum isl_dim_type type)\n{\n\tisl_space *space;\n\n\tif (!bmap)\n\t\treturn NULL;\n\tif (!isl_space_is_named_or_nested(bmap->dim, type))\n\t\treturn bmap;\n\n\tspace = isl_basic_map_get_space(bmap);\n\tspace = isl_space_reset(space, type);\n\tbmap = isl_basic_map_reset_space(bmap, space);\n\treturn bmap;\n}\n\n__isl_give isl_basic_map *isl_basic_map_insert_dims(\n\t__isl_take isl_basic_map *bmap, enum isl_dim_type type,\n\tunsigned pos, unsigned n)\n{\n\tisl_bool rational, is_empty;\n\tisl_space *res_space;\n\tstruct isl_basic_map *res;\n\tstruct isl_dim_map *dim_map;\n\tisl_size total;\n\tunsigned off;\n\tenum isl_dim_type t;\n\n\tif (n == 0)\n\t\treturn basic_map_space_reset(bmap, type);\n\n\tis_empty = isl_basic_map_plain_is_empty(bmap);\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tif (is_empty < 0 || total < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tres_space = isl_space_insert_dims(isl_basic_map_get_space(bmap),\n\t\t\t\t\ttype, pos, n);\n\tif (!res_space)\n\t\treturn isl_basic_map_free(bmap);\n\tif (is_empty) {\n\t\tisl_basic_map_free(bmap);\n\t\treturn isl_basic_map_empty(res_space);\n\t}\n\n\tdim_map = isl_dim_map_alloc(bmap->ctx, total + n);\n\toff = 0;\n\tfor (t = isl_dim_param; t <= isl_dim_out; ++t) {\n\t\tisl_size dim;\n\n\t\tif (t != type) {\n\t\t\tisl_dim_map_dim(dim_map, bmap->dim, t, off);\n\t\t} else {\n\t\t\tisl_size size = isl_basic_map_dim(bmap, t);\n\t\t\tif (size < 0)\n\t\t\t\tdim_map = isl_dim_map_free(dim_map);\n\t\t\tisl_dim_map_dim_range(dim_map, bmap->dim, t,\n\t\t\t\t\t\t0, pos, off);\n\t\t\tisl_dim_map_dim_range(dim_map, bmap->dim, t,\n\t\t\t\t\t\tpos, size - pos, off + pos + n);\n\t\t}\n\t\tdim = isl_space_dim(res_space, t);\n\t\tif (dim < 0)\n\t\t\tdim_map = isl_dim_map_free(dim_map);\n\t\toff += dim;\n\t}\n\tisl_dim_map_div(dim_map, bmap, off);\n\n\tres = isl_basic_map_alloc_space(res_space,\n\t\t\tbmap->n_div, bmap->n_eq, bmap->n_ineq);\n\trational = isl_basic_map_is_rational(bmap);\n\tif (rational < 0)\n\t\tres = isl_basic_map_free(res);\n\tif (rational)\n\t\tres = isl_basic_map_set_rational(res);\n\tres = isl_basic_map_add_constraints_dim_map(res, bmap, dim_map);\n\treturn isl_basic_map_finalize(res);\n}\n\n__isl_give isl_basic_set *isl_basic_set_insert_dims(\n\t__isl_take isl_basic_set *bset,\n\tenum isl_dim_type type, unsigned pos, unsigned n)\n{\n\treturn isl_basic_map_insert_dims(bset, type, pos, n);\n}\n\n__isl_give isl_basic_map *isl_basic_map_add_dims(__isl_take isl_basic_map *bmap,\n\t\tenum isl_dim_type type, unsigned n)\n{\n\tisl_size dim;\n\n\tdim = isl_basic_map_dim(bmap, type);\n\tif (dim < 0)\n\t\treturn isl_basic_map_free(bmap);\n\treturn isl_basic_map_insert_dims(bmap, type, dim, n);\n}\n\n__isl_give isl_basic_set *isl_basic_set_add_dims(__isl_take isl_basic_set *bset,\n\t\tenum isl_dim_type type, unsigned n)\n{\n\tif (!bset)\n\t\treturn NULL;\n\tisl_assert(bset->ctx, type != isl_dim_in, goto error);\n\treturn isl_basic_map_add_dims(bset, type, n);\nerror:\n\tisl_basic_set_free(bset);\n\treturn NULL;\n}\n\nstatic __isl_give isl_map *map_space_reset(__isl_take isl_map *map,\n\tenum isl_dim_type type)\n{\n\tisl_space *space;\n\n\tif (!map || !isl_space_is_named_or_nested(map->dim, type))\n\t\treturn map;\n\n\tspace = isl_map_get_space(map);\n\tspace = isl_space_reset(space, type);\n\tmap = isl_map_reset_space(map, space);\n\treturn map;\n}\n\n__isl_give isl_map *isl_map_insert_dims(__isl_take isl_map *map,\n\t\tenum isl_dim_type type, unsigned pos, unsigned n)\n{\n\tint i;\n\tisl_space *space;\n\n\tif (n == 0)\n\t\treturn map_space_reset(map, type);\n\n\tmap = isl_map_cow(map);\n\tif (!map)\n\t\treturn NULL;\n\n\tfor (i = 0; i < map->n; ++i) {\n\t\tmap->p[i] = isl_basic_map_insert_dims(map->p[i], type, pos, n);\n\t\tif (!map->p[i])\n\t\t\tgoto error;\n\t}\n\n\tspace = isl_map_take_space(map);\n\tspace = isl_space_insert_dims(space, type, pos, n);\n\tmap = isl_map_restore_space(map, space);\n\n\treturn map;\nerror:\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n__isl_give isl_set *isl_set_insert_dims(__isl_take isl_set *set,\n\t\tenum isl_dim_type type, unsigned pos, unsigned n)\n{\n\treturn isl_map_insert_dims(set, type, pos, n);\n}\n\n__isl_give isl_map *isl_map_add_dims(__isl_take isl_map *map,\n\t\tenum isl_dim_type type, unsigned n)\n{\n\tisl_size dim;\n\n\tdim = isl_map_dim(map, type);\n\tif (dim < 0)\n\t\treturn isl_map_free(map);\n\treturn isl_map_insert_dims(map, type, dim, n);\n}\n\n__isl_give isl_set *isl_set_add_dims(__isl_take isl_set *set,\n\t\tenum isl_dim_type type, unsigned n)\n{\n\tif (!set)\n\t\treturn NULL;\n\tisl_assert(set->ctx, type != isl_dim_in, goto error);\n\treturn set_from_map(isl_map_add_dims(set_to_map(set), type, n));\nerror:\n\tisl_set_free(set);\n\treturn NULL;\n}\n\n__isl_give isl_basic_map *isl_basic_map_move_dims(\n\t__isl_take isl_basic_map *bmap,\n\tenum isl_dim_type dst_type, unsigned dst_pos,\n\tenum isl_dim_type src_type, unsigned src_pos, unsigned n)\n{\n\tisl_space *space;\n\tstruct isl_dim_map *dim_map;\n\tstruct isl_basic_map *res;\n\tenum isl_dim_type t;\n\tisl_size total;\n\tunsigned off;\n\n\tif (!bmap)\n\t\treturn NULL;\n\tif (n == 0) {\n\t\tbmap = isl_basic_map_reset(bmap, src_type);\n\t\tbmap = isl_basic_map_reset(bmap, dst_type);\n\t\treturn bmap;\n\t}\n\n\tif (isl_basic_map_check_range(bmap, src_type, src_pos, n) < 0)\n\t\treturn isl_basic_map_free(bmap);\n\n\tif (dst_type == src_type && dst_pos == src_pos)\n\t\treturn bmap;\n\n\tisl_assert(bmap->ctx, dst_type != src_type, goto error);\n\n\tif (pos(bmap->dim, dst_type) + dst_pos ==\n\t    pos(bmap->dim, src_type) + src_pos +\n\t\t\t\t\t    ((src_type < dst_type) ? n : 0)) {\n\t\tspace = isl_basic_map_take_space(bmap);\n\t\tspace = isl_space_move_dims(space, dst_type, dst_pos,\n\t\t\t\t\t\tsrc_type, src_pos, n);\n\t\tbmap = isl_basic_map_restore_space(bmap, space);\n\t\tbmap = isl_basic_map_finalize(bmap);\n\n\t\treturn bmap;\n\t}\n\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tif (total < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tdim_map = isl_dim_map_alloc(bmap->ctx, total);\n\n\toff = 0;\n\tspace = isl_basic_map_peek_space(bmap);\n\tfor (t = isl_dim_param; t <= isl_dim_out; ++t) {\n\t\tisl_size size = isl_space_dim(space, t);\n\t\tif (size < 0)\n\t\t\tdim_map = isl_dim_map_free(dim_map);\n\t\tif (t == dst_type) {\n\t\t\tisl_dim_map_dim_range(dim_map, space, t,\n\t\t\t\t\t    0, dst_pos, off);\n\t\t\toff += dst_pos;\n\t\t\tisl_dim_map_dim_range(dim_map, space, src_type,\n\t\t\t\t\t    src_pos, n, off);\n\t\t\toff += n;\n\t\t\tisl_dim_map_dim_range(dim_map, space, t,\n\t\t\t\t\t    dst_pos, size - dst_pos, off);\n\t\t\toff += size - dst_pos;\n\t\t} else if (t == src_type) {\n\t\t\tisl_dim_map_dim_range(dim_map, space, t,\n\t\t\t\t\t    0, src_pos, off);\n\t\t\toff += src_pos;\n\t\t\tisl_dim_map_dim_range(dim_map, space, t,\n\t\t\t\t\tsrc_pos + n, size - src_pos - n, off);\n\t\t\toff += size - src_pos - n;\n\t\t} else {\n\t\t\tisl_dim_map_dim(dim_map, space, t, off);\n\t\t\toff += size;\n\t\t}\n\t}\n\tisl_dim_map_div(dim_map, bmap, off);\n\n\tres = isl_basic_map_alloc_space(isl_basic_map_get_space(bmap),\n\t\t\tbmap->n_div, bmap->n_eq, bmap->n_ineq);\n\tbmap = isl_basic_map_add_constraints_dim_map(res, bmap, dim_map);\n\tspace = isl_basic_map_take_space(bmap);\n\tspace = isl_space_move_dims(space, dst_type, dst_pos,\n\t\t\t\t\tsrc_type, src_pos, n);\n\tbmap = isl_basic_map_restore_space(bmap, space);\n\tif (!bmap)\n\t\tgoto error;\n\n\tISL_F_CLR(bmap, ISL_BASIC_MAP_SORTED);\n\tbmap = isl_basic_map_gauss(bmap, NULL);\n\tbmap = isl_basic_map_finalize(bmap);\n\n\treturn bmap;\nerror:\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n__isl_give isl_basic_set *isl_basic_set_move_dims(__isl_take isl_basic_set *bset,\n\tenum isl_dim_type dst_type, unsigned dst_pos,\n\tenum isl_dim_type src_type, unsigned src_pos, unsigned n)\n{\n\tisl_basic_map *bmap = bset_to_bmap(bset);\n\tbmap = isl_basic_map_move_dims(bmap, dst_type, dst_pos,\n\t\t\t\t\tsrc_type, src_pos, n);\n\treturn bset_from_bmap(bmap);\n}\n\n__isl_give isl_set *isl_set_move_dims(__isl_take isl_set *set,\n\tenum isl_dim_type dst_type, unsigned dst_pos,\n\tenum isl_dim_type src_type, unsigned src_pos, unsigned n)\n{\n\tif (!set)\n\t\treturn NULL;\n\tisl_assert(set->ctx, dst_type != isl_dim_in, goto error);\n\treturn set_from_map(isl_map_move_dims(set_to_map(set),\n\t\t\t\t    dst_type, dst_pos, src_type, src_pos, n));\nerror:\n\tisl_set_free(set);\n\treturn NULL;\n}\n\n__isl_give isl_map *isl_map_move_dims(__isl_take isl_map *map,\n\tenum isl_dim_type dst_type, unsigned dst_pos,\n\tenum isl_dim_type src_type, unsigned src_pos, unsigned n)\n{\n\tint i;\n\tisl_space *space;\n\n\tif (n == 0) {\n\t\tmap = isl_map_reset(map, src_type);\n\t\tmap = isl_map_reset(map, dst_type);\n\t\treturn map;\n\t}\n\n\tif (isl_map_check_range(map, src_type, src_pos, n))\n\t\treturn isl_map_free(map);\n\n\tif (dst_type == src_type && dst_pos == src_pos)\n\t\treturn map;\n\n\tisl_assert(map->ctx, dst_type != src_type, goto error);\n\n\tmap = isl_map_cow(map);\n\tif (!map)\n\t\treturn NULL;\n\n\tfor (i = 0; i < map->n; ++i) {\n\t\tmap->p[i] = isl_basic_map_move_dims(map->p[i],\n\t\t\t\t\t\tdst_type, dst_pos,\n\t\t\t\t\t\tsrc_type, src_pos, n);\n\t\tif (!map->p[i])\n\t\t\tgoto error;\n\t}\n\n\tspace = isl_map_take_space(map);\n\tspace = isl_space_move_dims(space, dst_type, dst_pos,\n\t\t\t\t\t    src_type, src_pos, n);\n\tmap = isl_map_restore_space(map, space);\n\n\treturn map;\nerror:\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n/* Move the specified dimensions to the last columns right before\n * the divs.  Don't change the dimension specification of bmap.\n * That's the responsibility of the caller.\n */\nstatic __isl_give isl_basic_map *move_last(__isl_take isl_basic_map *bmap,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\tisl_space *space;\n\tstruct isl_dim_map *dim_map;\n\tstruct isl_basic_map *res;\n\tenum isl_dim_type t;\n\tisl_size total;\n\tunsigned off;\n\n\tif (!bmap)\n\t\treturn NULL;\n\tif (isl_basic_map_offset(bmap, type) + first + n ==\n\t\t\t\tisl_basic_map_offset(bmap, isl_dim_div))\n\t\treturn bmap;\n\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tif (total < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tdim_map = isl_dim_map_alloc(bmap->ctx, total);\n\n\toff = 0;\n\tspace = isl_basic_map_peek_space(bmap);\n\tfor (t = isl_dim_param; t <= isl_dim_out; ++t) {\n\t\tisl_size size = isl_space_dim(space, t);\n\t\tif (size < 0)\n\t\t\tdim_map = isl_dim_map_free(dim_map);\n\t\tif (t == type) {\n\t\t\tisl_dim_map_dim_range(dim_map, space, t,\n\t\t\t\t\t    0, first, off);\n\t\t\toff += first;\n\t\t\tisl_dim_map_dim_range(dim_map, space, t,\n\t\t\t\t\t    first, n, total - bmap->n_div - n);\n\t\t\tisl_dim_map_dim_range(dim_map, space, t,\n\t\t\t\t\t    first + n, size - (first + n), off);\n\t\t\toff += size - (first + n);\n\t\t} else {\n\t\t\tisl_dim_map_dim(dim_map, space, t, off);\n\t\t\toff += size;\n\t\t}\n\t}\n\tisl_dim_map_div(dim_map, bmap, off + n);\n\n\tres = isl_basic_map_alloc_space(isl_basic_map_get_space(bmap),\n\t\t\tbmap->n_div, bmap->n_eq, bmap->n_ineq);\n\tres = isl_basic_map_add_constraints_dim_map(res, bmap, dim_map);\n\treturn res;\n}\n\n/* Insert \"n\" rows in the divs of \"bmap\".\n *\n * The number of columns is not changed, which means that the last\n * dimensions of \"bmap\" are being reintepreted as the new divs.\n * The space of \"bmap\" is not adjusted, however, which means\n * that \"bmap\" is left in an inconsistent state.  Removing \"n\" dimensions\n * from the space of \"bmap\" is the responsibility of the caller.\n */\nstatic __isl_give isl_basic_map *insert_div_rows(__isl_take isl_basic_map *bmap,\n\tint n)\n{\n\tint i;\n\tsize_t row_size;\n\tisl_int **new_div;\n\tisl_int *old;\n\n\tbmap = isl_basic_map_cow(bmap);\n\tif (!bmap)\n\t\treturn NULL;\n\n\trow_size = isl_basic_map_offset(bmap, isl_dim_div) + bmap->extra;\n\told = bmap->block2.data;\n\tbmap->block2 = isl_blk_extend(bmap->ctx, bmap->block2,\n\t\t\t\t\t(bmap->extra + n) * (1 + row_size));\n\tif (!bmap->block2.data)\n\t\treturn isl_basic_map_free(bmap);\n\tnew_div = isl_alloc_array(bmap->ctx, isl_int *, bmap->extra + n);\n\tif (!new_div)\n\t\treturn isl_basic_map_free(bmap);\n\tfor (i = 0; i < n; ++i) {\n\t\tnew_div[i] = bmap->block2.data +\n\t\t\t\t(bmap->extra + i) * (1 + row_size);\n\t\tisl_seq_clr(new_div[i], 1 + row_size);\n\t}\n\tfor (i = 0; i < bmap->extra; ++i)\n\t\tnew_div[n + i] = bmap->block2.data + (bmap->div[i] - old);\n\tfree(bmap->div);\n\tbmap->div = new_div;\n\tbmap->n_div += n;\n\tbmap->extra += n;\n\n\treturn bmap;\n}\n\n/* Drop constraints from \"bmap\" that only involve the variables\n * of \"type\" in the range [first, first + n] that are not related\n * to any of the variables outside that interval.\n * These constraints cannot influence the values for the variables\n * outside the interval, except in case they cause \"bmap\" to be empty.\n * Only drop the constraints if \"bmap\" is known to be non-empty.\n */\nstatic __isl_give isl_basic_map *drop_irrelevant_constraints(\n\t__isl_take isl_basic_map *bmap, enum isl_dim_type type,\n\tunsigned first, unsigned n)\n{\n\tint i;\n\tint *groups;\n\tisl_size dim, n_div;\n\tisl_bool non_empty;\n\n\tnon_empty = isl_basic_map_plain_is_non_empty(bmap);\n\tif (non_empty < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tif (!non_empty)\n\t\treturn bmap;\n\n\tdim = isl_basic_map_dim(bmap, isl_dim_all);\n\tn_div = isl_basic_map_dim(bmap, isl_dim_div);\n\tif (dim < 0 || n_div < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tgroups = isl_calloc_array(isl_basic_map_get_ctx(bmap), int, dim);\n\tif (!groups)\n\t\treturn isl_basic_map_free(bmap);\n\tfirst += isl_basic_map_offset(bmap, type) - 1;\n\tfor (i = 0; i < first; ++i)\n\t\tgroups[i] = -1;\n\tfor (i = first + n; i < dim - n_div; ++i)\n\t\tgroups[i] = -1;\n\n\tbmap = isl_basic_map_drop_unrelated_constraints(bmap, groups);\n\n\treturn bmap;\n}\n\n/* Turn the n dimensions of type type, starting at first\n * into existentially quantified variables.\n *\n * If a subset of the projected out variables are unrelated\n * to any of the variables that remain, then the constraints\n * involving this subset are simply dropped first.\n */\n__isl_give isl_basic_map *isl_basic_map_project_out(\n\t\t__isl_take isl_basic_map *bmap,\n\t\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\tisl_bool empty;\n\tisl_space *space;\n\n\tif (n == 0)\n\t\treturn basic_map_space_reset(bmap, type);\n\tif (type == isl_dim_div)\n\t\tisl_die(isl_basic_map_get_ctx(bmap), isl_error_invalid,\n\t\t\t\"cannot project out existentially quantified variables\",\n\t\t\treturn isl_basic_map_free(bmap));\n\n\tempty = isl_basic_map_plain_is_empty(bmap);\n\tif (empty < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tif (empty)\n\t\tbmap = isl_basic_map_set_to_empty(bmap);\n\n\tbmap = drop_irrelevant_constraints(bmap, type, first, n);\n\tif (!bmap)\n\t\treturn NULL;\n\n\tif (ISL_F_ISSET(bmap, ISL_BASIC_MAP_RATIONAL))\n\t\treturn isl_basic_map_remove_dims(bmap, type, first, n);\n\n\tif (isl_basic_map_check_range(bmap, type, first, n) < 0)\n\t\treturn isl_basic_map_free(bmap);\n\n\tbmap = move_last(bmap, type, first, n);\n\tbmap = isl_basic_map_cow(bmap);\n\tbmap = insert_div_rows(bmap, n);\n\n\tspace = isl_basic_map_take_space(bmap);\n\tspace = isl_space_drop_dims(space, type, first, n);\n\tbmap = isl_basic_map_restore_space(bmap, space);\n\tbmap = isl_basic_map_simplify(bmap);\n\tbmap = isl_basic_map_drop_redundant_divs(bmap);\n\treturn isl_basic_map_finalize(bmap);\n}\n\n/* Turn the n dimensions of type type, starting at first\n * into existentially quantified variables.\n */\n__isl_give isl_basic_set *isl_basic_set_project_out(\n\t__isl_take isl_basic_set *bset, enum isl_dim_type type,\n\tunsigned first, unsigned n)\n{\n\treturn bset_from_bmap(isl_basic_map_project_out(bset_to_bmap(bset),\n\t\t\t\t\t\t\ttype, first, n));\n}\n\n/* Turn the n dimensions of type type, starting at first\n * into existentially quantified variables.\n */\n__isl_give isl_map *isl_map_project_out(__isl_take isl_map *map,\n\t\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\tint i;\n\tisl_space *space;\n\n\tif (n == 0)\n\t\treturn map_space_reset(map, type);\n\n\tif (isl_map_check_range(map, type, first, n) < 0)\n\t\treturn isl_map_free(map);\n\n\tmap = isl_map_cow(map);\n\tif (!map)\n\t\treturn NULL;\n\n\tfor (i = 0; i < map->n; ++i) {\n\t\tmap->p[i] = isl_basic_map_project_out(map->p[i], type, first, n);\n\t\tif (!map->p[i])\n\t\t\tgoto error;\n\t}\n\n\tif (map->n > 1)\n\t\tISL_F_CLR(map, ISL_MAP_DISJOINT);\n\tmap = isl_map_unmark_normalized(map);\n\n\tspace = isl_map_take_space(map);\n\tspace = isl_space_drop_dims(space, type, first, n);\n\tmap = isl_map_restore_space(map, space);\n\n\treturn map;\nerror:\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n#undef TYPE\n#define TYPE\tisl_map\n#include \"isl_project_out_all_params_templ.c\"\n\n/* Turn all the dimensions of type \"type\", except the \"n\" starting at \"first\"\n * into existentially quantified variables.\n */\n__isl_give isl_map *isl_map_project_onto(__isl_take isl_map *map,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\tisl_size dim;\n\n\tdim = isl_map_dim(map, type);\n\tif (isl_map_check_range(map, type, first, n) < 0 || dim < 0)\n\t\treturn isl_map_free(map);\n\tmap = isl_map_project_out(map, type, first + n, dim - (first + n));\n\tmap = isl_map_project_out(map, type, 0, first);\n\treturn map;\n}\n\n/* Turn the n dimensions of type type, starting at first\n * into existentially quantified variables.\n */\n__isl_give isl_set *isl_set_project_out(__isl_take isl_set *set,\n\t\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\treturn set_from_map(isl_map_project_out(set_to_map(set),\n\t\t\t\t\t\ttype, first, n));\n}\n\n/* If \"set\" involves a parameter with identifier \"id\",\n * then turn it into an existentially quantified variable.\n */\n__isl_give isl_set *isl_set_project_out_param_id(__isl_take isl_set *set,\n\t__isl_take isl_id *id)\n{\n\tint pos;\n\n\tif (!set || !id)\n\t\tgoto error;\n\tpos = isl_set_find_dim_by_id(set, isl_dim_param, id);\n\tisl_id_free(id);\n\tif (pos < 0)\n\t\treturn set;\n\treturn isl_set_project_out(set, isl_dim_param, pos, 1);\nerror:\n\tisl_set_free(set);\n\tisl_id_free(id);\n\treturn NULL;\n}\n\n/* If \"set\" involves any of the parameters with identifiers in \"list\",\n * then turn them into existentially quantified variables.\n */\n__isl_give isl_set *isl_set_project_out_param_id_list(__isl_take isl_set *set,\n\t__isl_take isl_id_list *list)\n{\n\tint i;\n\tisl_size n;\n\n\tn = isl_id_list_size(list);\n\tif (n < 0)\n\t\tgoto error;\n\tfor (i = 0; i < n; ++i) {\n\t\tisl_id *id;\n\n\t\tid = isl_id_list_get_at(list, i);\n\t\tset = isl_set_project_out_param_id(set, id);\n\t}\n\n\tisl_id_list_free(list);\n\treturn set;\nerror:\n\tisl_id_list_free(list);\n\tisl_set_free(set);\n\treturn NULL;\n}\n\n/* Project out all parameters from \"set\" by existentially quantifying\n * over them.\n */\n__isl_give isl_set *isl_set_project_out_all_params(__isl_take isl_set *set)\n{\n\treturn set_from_map(isl_map_project_out_all_params(set_to_map(set)));\n}\n\n/* Return a map that projects the elements in \"set\" onto their\n * \"n\" set dimensions starting at \"first\".\n * \"type\" should be equal to isl_dim_set.\n */\n__isl_give isl_map *isl_set_project_onto_map(__isl_take isl_set *set,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\tint i;\n\tisl_map *map;\n\n\tif (type != isl_dim_set)\n\t\tisl_die(isl_set_get_ctx(set), isl_error_invalid,\n\t\t\t\"only set dimensions can be projected out\", goto error);\n\tif (isl_set_check_range(set, type, first, n) < 0)\n\t\treturn isl_set_free(set);\n\n\tmap = isl_map_from_domain(set);\n\tmap = isl_map_add_dims(map, isl_dim_out, n);\n\tfor (i = 0; i < n; ++i)\n\t\tmap = isl_map_equate(map, isl_dim_in, first + i,\n\t\t\t\t\tisl_dim_out, i);\n\treturn map;\nerror:\n\tisl_set_free(set);\n\treturn NULL;\n}\n\nstatic __isl_give isl_basic_map *add_divs(__isl_take isl_basic_map *bmap,\n\tunsigned n)\n{\n\tint i, j;\n\tisl_size total;\n\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tif (total < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tfor (i = 0; i < n; ++i) {\n\t\tj = isl_basic_map_alloc_div(bmap);\n\t\tif (j < 0)\n\t\t\tgoto error;\n\t\tisl_seq_clr(bmap->div[j], 1 + 1 + total);\n\t}\n\treturn bmap;\nerror:\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n/* Does \"bmap2\" apply to the range of \"bmap1\" (ignoring parameters)?\n */\nisl_bool isl_basic_map_applies_range(__isl_keep isl_basic_map *bmap1,\n\t__isl_keep isl_basic_map *bmap2)\n{\n\tisl_space *space1, *space2;\n\n\tspace1 = isl_basic_map_peek_space(bmap1);\n\tspace2 = isl_basic_map_peek_space(bmap2);\n\treturn isl_space_tuple_is_equal(space1, isl_dim_out,\n\t\t\t\t\tspace2, isl_dim_in);\n}\n\n/* Check that \"bmap2\" applies to the range of \"bmap1\" (ignoring parameters).\n */\nstatic isl_stat isl_basic_map_check_applies_range(\n\t__isl_keep isl_basic_map *bmap1, __isl_keep isl_basic_map *bmap2)\n{\n\tisl_bool equal;\n\n\tequal = isl_basic_map_applies_range(bmap1, bmap2);\n\tif (equal < 0)\n\t\treturn isl_stat_error;\n\tif (!equal)\n\t\tisl_die(isl_basic_map_get_ctx(bmap1), isl_error_invalid,\n\t\t\t\"spaces don't match\", return isl_stat_error);\n\treturn isl_stat_ok;\n}\n\n__isl_give isl_basic_map *isl_basic_map_apply_range(\n\t__isl_take isl_basic_map *bmap1, __isl_take isl_basic_map *bmap2)\n{\n\tisl_space *space_result = NULL;\n\tstruct isl_basic_map *bmap;\n\tisl_size n_in, n_out, n, nparam;\n\tunsigned total, pos;\n\tstruct isl_dim_map *dim_map1, *dim_map2;\n\n\tif (isl_basic_map_check_equal_params(bmap1, bmap2) < 0)\n\t\tgoto error;\n\tif (isl_basic_map_check_applies_range(bmap1, bmap2) < 0)\n\t\tgoto error;\n\n\tn_in = isl_basic_map_dim(bmap1, isl_dim_in);\n\tn_out = isl_basic_map_dim(bmap2, isl_dim_out);\n\tn = isl_basic_map_dim(bmap1, isl_dim_out);\n\tnparam = isl_basic_map_dim(bmap1, isl_dim_param);\n\tif (n_in < 0 || n_out < 0 || n < 0 || nparam < 0)\n\t\tgoto error;\n\n\tspace_result = isl_space_join(isl_basic_map_get_space(bmap1),\n\t\t\t\t  isl_basic_map_get_space(bmap2));\n\n\ttotal = nparam + n_in + n_out + bmap1->n_div + bmap2->n_div + n;\n\tdim_map1 = isl_dim_map_alloc(bmap1->ctx, total);\n\tdim_map2 = isl_dim_map_alloc(bmap1->ctx, total);\n\tisl_dim_map_dim(dim_map1, bmap1->dim, isl_dim_param, pos = 0);\n\tisl_dim_map_dim(dim_map2, bmap2->dim, isl_dim_param, pos = 0);\n\tisl_dim_map_dim(dim_map1, bmap1->dim, isl_dim_in, pos += nparam);\n\tisl_dim_map_dim(dim_map2, bmap2->dim, isl_dim_out, pos += n_in);\n\tisl_dim_map_div(dim_map1, bmap1, pos += n_out);\n\tisl_dim_map_div(dim_map2, bmap2, pos += bmap1->n_div);\n\tisl_dim_map_dim(dim_map1, bmap1->dim, isl_dim_out, pos += bmap2->n_div);\n\tisl_dim_map_dim(dim_map2, bmap2->dim, isl_dim_in, pos);\n\n\tbmap = isl_basic_map_alloc_space(space_result,\n\t\t\tbmap1->n_div + bmap2->n_div + n,\n\t\t\tbmap1->n_eq + bmap2->n_eq,\n\t\t\tbmap1->n_ineq + bmap2->n_ineq);\n\tbmap = isl_basic_map_add_constraints_dim_map(bmap, bmap1, dim_map1);\n\tbmap = isl_basic_map_add_constraints_dim_map(bmap, bmap2, dim_map2);\n\tbmap = add_divs(bmap, n);\n\tbmap = isl_basic_map_simplify(bmap);\n\tbmap = isl_basic_map_drop_redundant_divs(bmap);\n\treturn isl_basic_map_finalize(bmap);\nerror:\n\tisl_basic_map_free(bmap1);\n\tisl_basic_map_free(bmap2);\n\treturn NULL;\n}\n\n__isl_give isl_basic_set *isl_basic_set_apply(__isl_take isl_basic_set *bset,\n\t__isl_take isl_basic_map *bmap)\n{\n\tif (isl_basic_map_check_compatible_domain(bmap, bset) < 0)\n\t\tgoto error;\n\n\treturn bset_from_bmap(isl_basic_map_apply_range(bset_to_bmap(bset),\n\t\t\t\t\t\t\tbmap));\nerror:\n\tisl_basic_set_free(bset);\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n__isl_give isl_basic_map *isl_basic_map_apply_domain(\n\t__isl_take isl_basic_map *bmap1, __isl_take isl_basic_map *bmap2)\n{\n\tif (isl_basic_map_check_equal_params(bmap1, bmap2) < 0)\n\t\tgoto error;\n\tif (!isl_space_tuple_is_equal(bmap1->dim, isl_dim_in,\n\t\t\t\t\tbmap2->dim, isl_dim_in))\n\t\tisl_die(isl_basic_map_get_ctx(bmap1), isl_error_invalid,\n\t\t\t\"spaces don't match\", goto error);\n\n\tbmap1 = isl_basic_map_reverse(bmap1);\n\tbmap1 = isl_basic_map_apply_range(bmap1, bmap2);\n\treturn isl_basic_map_reverse(bmap1);\nerror:\n\tisl_basic_map_free(bmap1);\n\tisl_basic_map_free(bmap2);\n\treturn NULL;\n}\n\n/* Given two basic maps A -> f(A) and B -> g(B), construct a basic map\n * A \\cap B -> f(A) + f(B)\n */\n__isl_give isl_basic_map *isl_basic_map_sum(__isl_take isl_basic_map *bmap1,\n\t__isl_take isl_basic_map *bmap2)\n{\n\tisl_size n_in, n_out, nparam;\n\tunsigned total, pos;\n\tstruct isl_basic_map *bmap = NULL;\n\tstruct isl_dim_map *dim_map1, *dim_map2;\n\tint i;\n\n\tif (isl_basic_map_check_equal_space(bmap1, bmap2) < 0)\n\t\tgoto error;\n\n\tnparam = isl_basic_map_dim(bmap1, isl_dim_param);\n\tn_in = isl_basic_map_dim(bmap1, isl_dim_in);\n\tn_out = isl_basic_map_dim(bmap1, isl_dim_out);\n\tif (nparam < 0 || n_in < 0 || n_out < 0)\n\t\tgoto error;\n\n\ttotal = nparam + n_in + n_out + bmap1->n_div + bmap2->n_div + 2 * n_out;\n\tdim_map1 = isl_dim_map_alloc(bmap1->ctx, total);\n\tdim_map2 = isl_dim_map_alloc(bmap2->ctx, total);\n\tisl_dim_map_dim(dim_map1, bmap1->dim, isl_dim_param, pos = 0);\n\tisl_dim_map_dim(dim_map2, bmap2->dim, isl_dim_param, pos);\n\tisl_dim_map_dim(dim_map1, bmap1->dim, isl_dim_in, pos += nparam);\n\tisl_dim_map_dim(dim_map2, bmap2->dim, isl_dim_in, pos);\n\tisl_dim_map_div(dim_map1, bmap1, pos += n_in + n_out);\n\tisl_dim_map_div(dim_map2, bmap2, pos += bmap1->n_div);\n\tisl_dim_map_dim(dim_map1, bmap1->dim, isl_dim_out, pos += bmap2->n_div);\n\tisl_dim_map_dim(dim_map2, bmap2->dim, isl_dim_out, pos += n_out);\n\n\tbmap = isl_basic_map_alloc_space(isl_space_copy(bmap1->dim),\n\t\t\tbmap1->n_div + bmap2->n_div + 2 * n_out,\n\t\t\tbmap1->n_eq + bmap2->n_eq + n_out,\n\t\t\tbmap1->n_ineq + bmap2->n_ineq);\n\tfor (i = 0; i < n_out; ++i) {\n\t\tint j = isl_basic_map_alloc_equality(bmap);\n\t\tif (j < 0)\n\t\t\tgoto error;\n\t\tisl_seq_clr(bmap->eq[j], 1+total);\n\t\tisl_int_set_si(bmap->eq[j][1+nparam+n_in+i], -1);\n\t\tisl_int_set_si(bmap->eq[j][1+pos+i], 1);\n\t\tisl_int_set_si(bmap->eq[j][1+pos-n_out+i], 1);\n\t}\n\tbmap = isl_basic_map_add_constraints_dim_map(bmap, bmap1, dim_map1);\n\tbmap = isl_basic_map_add_constraints_dim_map(bmap, bmap2, dim_map2);\n\tbmap = add_divs(bmap, 2 * n_out);\n\n\tbmap = isl_basic_map_simplify(bmap);\n\treturn isl_basic_map_finalize(bmap);\nerror:\n\tisl_basic_map_free(bmap);\n\tisl_basic_map_free(bmap1);\n\tisl_basic_map_free(bmap2);\n\treturn NULL;\n}\n\n/* Given two maps A -> f(A) and B -> g(B), construct a map\n * A \\cap B -> f(A) + f(B)\n */\n__isl_give isl_map *isl_map_sum(__isl_take isl_map *map1,\n\t__isl_take isl_map *map2)\n{\n\tstruct isl_map *result;\n\tint i, j;\n\n\tif (isl_map_check_equal_space(map1, map2) < 0)\n\t\tgoto error;\n\n\tresult = isl_map_alloc_space(isl_space_copy(map1->dim),\n\t\t\t\tmap1->n * map2->n, 0);\n\tif (!result)\n\t\tgoto error;\n\tfor (i = 0; i < map1->n; ++i)\n\t\tfor (j = 0; j < map2->n; ++j) {\n\t\t\tstruct isl_basic_map *part;\n\t\t\tpart = isl_basic_map_sum(\n\t\t\t\t    isl_basic_map_copy(map1->p[i]),\n\t\t\t\t    isl_basic_map_copy(map2->p[j]));\n\t\t\tif (isl_basic_map_is_empty(part))\n\t\t\t\tisl_basic_map_free(part);\n\t\t\telse\n\t\t\t\tresult = isl_map_add_basic_map(result, part);\n\t\t\tif (!result)\n\t\t\t\tgoto error;\n\t\t}\n\tisl_map_free(map1);\n\tisl_map_free(map2);\n\treturn result;\nerror:\n\tisl_map_free(map1);\n\tisl_map_free(map2);\n\treturn NULL;\n}\n\n__isl_give isl_set *isl_set_sum(__isl_take isl_set *set1,\n\t__isl_take isl_set *set2)\n{\n\treturn set_from_map(isl_map_sum(set_to_map(set1), set_to_map(set2)));\n}\n\n/* Given a basic map A -> f(A), construct A -> -f(A).\n */\n__isl_give isl_basic_map *isl_basic_map_neg(__isl_take isl_basic_map *bmap)\n{\n\tint i, j;\n\tunsigned off;\n\tisl_size n;\n\n\tbmap = isl_basic_map_cow(bmap);\n\tn = isl_basic_map_dim(bmap, isl_dim_out);\n\tif (n < 0)\n\t\treturn isl_basic_map_free(bmap);\n\n\toff = isl_basic_map_offset(bmap, isl_dim_out);\n\tfor (i = 0; i < bmap->n_eq; ++i)\n\t\tfor (j = 0; j < n; ++j)\n\t\t\tisl_int_neg(bmap->eq[i][off+j], bmap->eq[i][off+j]);\n\tfor (i = 0; i < bmap->n_ineq; ++i)\n\t\tfor (j = 0; j < n; ++j)\n\t\t\tisl_int_neg(bmap->ineq[i][off+j], bmap->ineq[i][off+j]);\n\tfor (i = 0; i < bmap->n_div; ++i)\n\t\tfor (j = 0; j < n; ++j)\n\t\t\tisl_int_neg(bmap->div[i][1+off+j], bmap->div[i][1+off+j]);\n\tbmap = isl_basic_map_gauss(bmap, NULL);\n\treturn isl_basic_map_finalize(bmap);\n}\n\n__isl_give isl_basic_set *isl_basic_set_neg(__isl_take isl_basic_set *bset)\n{\n\treturn isl_basic_map_neg(bset);\n}\n\n/* Given a map A -> f(A), construct A -> -f(A).\n */\n__isl_give isl_map *isl_map_neg(__isl_take isl_map *map)\n{\n\tint i;\n\n\tmap = isl_map_cow(map);\n\tif (!map)\n\t\treturn NULL;\n\n\tfor (i = 0; i < map->n; ++i) {\n\t\tmap->p[i] = isl_basic_map_neg(map->p[i]);\n\t\tif (!map->p[i])\n\t\t\tgoto error;\n\t}\n\n\treturn map;\nerror:\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n__isl_give isl_set *isl_set_neg(__isl_take isl_set *set)\n{\n\treturn set_from_map(isl_map_neg(set_to_map(set)));\n}\n\n/* Given a basic map A -> f(A) and an integer d, construct a basic map\n * A -> floor(f(A)/d).\n */\n__isl_give isl_basic_map *isl_basic_map_floordiv(__isl_take isl_basic_map *bmap,\n\t\tisl_int d)\n{\n\tisl_size n_in, n_out, nparam;\n\tunsigned total, pos;\n\tstruct isl_basic_map *result = NULL;\n\tstruct isl_dim_map *dim_map;\n\tint i;\n\n\tnparam = isl_basic_map_dim(bmap, isl_dim_param);\n\tn_in = isl_basic_map_dim(bmap, isl_dim_in);\n\tn_out = isl_basic_map_dim(bmap, isl_dim_out);\n\tif (nparam < 0 || n_in < 0 || n_out < 0)\n\t\treturn isl_basic_map_free(bmap);\n\n\ttotal = nparam + n_in + n_out + bmap->n_div + n_out;\n\tdim_map = isl_dim_map_alloc(bmap->ctx, total);\n\tisl_dim_map_dim(dim_map, bmap->dim, isl_dim_param, pos = 0);\n\tisl_dim_map_dim(dim_map, bmap->dim, isl_dim_in, pos += nparam);\n\tisl_dim_map_div(dim_map, bmap, pos += n_in + n_out);\n\tisl_dim_map_dim(dim_map, bmap->dim, isl_dim_out, pos += bmap->n_div);\n\n\tresult = isl_basic_map_alloc_space(isl_space_copy(bmap->dim),\n\t\t\tbmap->n_div + n_out,\n\t\t\tbmap->n_eq, bmap->n_ineq + 2 * n_out);\n\tresult = isl_basic_map_add_constraints_dim_map(result, bmap, dim_map);\n\tresult = add_divs(result, n_out);\n\tfor (i = 0; i < n_out; ++i) {\n\t\tint j;\n\t\tj = isl_basic_map_alloc_inequality(result);\n\t\tif (j < 0)\n\t\t\tgoto error;\n\t\tisl_seq_clr(result->ineq[j], 1+total);\n\t\tisl_int_neg(result->ineq[j][1+nparam+n_in+i], d);\n\t\tisl_int_set_si(result->ineq[j][1+pos+i], 1);\n\t\tj = isl_basic_map_alloc_inequality(result);\n\t\tif (j < 0)\n\t\t\tgoto error;\n\t\tisl_seq_clr(result->ineq[j], 1+total);\n\t\tisl_int_set(result->ineq[j][1+nparam+n_in+i], d);\n\t\tisl_int_set_si(result->ineq[j][1+pos+i], -1);\n\t\tisl_int_sub_ui(result->ineq[j][0], d, 1);\n\t}\n\n\tresult = isl_basic_map_simplify(result);\n\treturn isl_basic_map_finalize(result);\nerror:\n\tisl_basic_map_free(result);\n\treturn NULL;\n}\n\n/* Given a map A -> f(A) and an integer d, construct a map\n * A -> floor(f(A)/d).\n */\n__isl_give isl_map *isl_map_floordiv(__isl_take isl_map *map, isl_int d)\n{\n\tint i;\n\n\tmap = isl_map_cow(map);\n\tif (!map)\n\t\treturn NULL;\n\n\tISL_F_CLR(map, ISL_MAP_DISJOINT);\n\tfor (i = 0; i < map->n; ++i) {\n\t\tmap->p[i] = isl_basic_map_floordiv(map->p[i], d);\n\t\tif (!map->p[i])\n\t\t\tgoto error;\n\t}\n\tmap = isl_map_unmark_normalized(map);\n\n\treturn map;\nerror:\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n/* Given a map A -> f(A) and an integer d, construct a map\n * A -> floor(f(A)/d).\n */\n__isl_give isl_map *isl_map_floordiv_val(__isl_take isl_map *map,\n\t__isl_take isl_val *d)\n{\n\tif (!map || !d)\n\t\tgoto error;\n\tif (!isl_val_is_int(d))\n\t\tisl_die(isl_val_get_ctx(d), isl_error_invalid,\n\t\t\t\"expecting integer denominator\", goto error);\n\tmap = isl_map_floordiv(map, d->n);\n\tisl_val_free(d);\n\treturn map;\nerror:\n\tisl_map_free(map);\n\tisl_val_free(d);\n\treturn NULL;\n}\n\nstatic __isl_give isl_basic_map *var_equal(__isl_take isl_basic_map *bmap,\n\tunsigned pos)\n{\n\tint i;\n\tisl_size nparam;\n\tisl_size n_in;\n\tisl_size total;\n\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tnparam = isl_basic_map_dim(bmap, isl_dim_param);\n\tn_in = isl_basic_map_dim(bmap, isl_dim_in);\n\tif (total < 0 || nparam < 0 || n_in < 0)\n\t\treturn isl_basic_map_free(bmap);\n\ti = isl_basic_map_alloc_equality(bmap);\n\tif (i < 0)\n\t\tgoto error;\n\tisl_seq_clr(bmap->eq[i], 1 + total);\n\tisl_int_set_si(bmap->eq[i][1+nparam+pos], -1);\n\tisl_int_set_si(bmap->eq[i][1+nparam+n_in+pos], 1);\n\treturn isl_basic_map_finalize(bmap);\nerror:\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n/* Add a constraint to \"bmap\" expressing i_pos < o_pos\n */\nstatic __isl_give isl_basic_map *var_less(__isl_take isl_basic_map *bmap,\n\tunsigned pos)\n{\n\tint i;\n\tisl_size nparam;\n\tisl_size n_in;\n\tisl_size total;\n\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tnparam = isl_basic_map_dim(bmap, isl_dim_param);\n\tn_in = isl_basic_map_dim(bmap, isl_dim_in);\n\tif (total < 0 || nparam < 0 || n_in < 0)\n\t\treturn isl_basic_map_free(bmap);\n\ti = isl_basic_map_alloc_inequality(bmap);\n\tif (i < 0)\n\t\tgoto error;\n\tisl_seq_clr(bmap->ineq[i], 1 + total);\n\tisl_int_set_si(bmap->ineq[i][0], -1);\n\tisl_int_set_si(bmap->ineq[i][1+nparam+pos], -1);\n\tisl_int_set_si(bmap->ineq[i][1+nparam+n_in+pos], 1);\n\treturn isl_basic_map_finalize(bmap);\nerror:\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n/* Add a constraint to \"bmap\" expressing i_pos <= o_pos\n */\nstatic __isl_give isl_basic_map *var_less_or_equal(\n\t__isl_take isl_basic_map *bmap, unsigned pos)\n{\n\tint i;\n\tisl_size nparam;\n\tisl_size n_in;\n\tisl_size total;\n\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tnparam = isl_basic_map_dim(bmap, isl_dim_param);\n\tn_in = isl_basic_map_dim(bmap, isl_dim_in);\n\tif (total < 0 || nparam < 0 || n_in < 0)\n\t\treturn isl_basic_map_free(bmap);\n\ti = isl_basic_map_alloc_inequality(bmap);\n\tif (i < 0)\n\t\tgoto error;\n\tisl_seq_clr(bmap->ineq[i], 1 + total);\n\tisl_int_set_si(bmap->ineq[i][1+nparam+pos], -1);\n\tisl_int_set_si(bmap->ineq[i][1+nparam+n_in+pos], 1);\n\treturn isl_basic_map_finalize(bmap);\nerror:\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n/* Add a constraint to \"bmap\" expressing i_pos > o_pos\n */\nstatic __isl_give isl_basic_map *var_more(__isl_take isl_basic_map *bmap,\n\tunsigned pos)\n{\n\tint i;\n\tisl_size nparam;\n\tisl_size n_in;\n\tisl_size total;\n\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tnparam = isl_basic_map_dim(bmap, isl_dim_param);\n\tn_in = isl_basic_map_dim(bmap, isl_dim_in);\n\tif (total < 0 || nparam < 0 || n_in < 0)\n\t\treturn isl_basic_map_free(bmap);\n\ti = isl_basic_map_alloc_inequality(bmap);\n\tif (i < 0)\n\t\tgoto error;\n\tisl_seq_clr(bmap->ineq[i], 1 + total);\n\tisl_int_set_si(bmap->ineq[i][0], -1);\n\tisl_int_set_si(bmap->ineq[i][1+nparam+pos], 1);\n\tisl_int_set_si(bmap->ineq[i][1+nparam+n_in+pos], -1);\n\treturn isl_basic_map_finalize(bmap);\nerror:\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n/* Add a constraint to \"bmap\" expressing i_pos >= o_pos\n */\nstatic __isl_give isl_basic_map *var_more_or_equal(\n\t__isl_take isl_basic_map *bmap, unsigned pos)\n{\n\tint i;\n\tisl_size nparam;\n\tisl_size n_in;\n\tisl_size total;\n\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tnparam = isl_basic_map_dim(bmap, isl_dim_param);\n\tn_in = isl_basic_map_dim(bmap, isl_dim_in);\n\tif (total < 0 || nparam < 0 || n_in < 0)\n\t\treturn isl_basic_map_free(bmap);\n\ti = isl_basic_map_alloc_inequality(bmap);\n\tif (i < 0)\n\t\tgoto error;\n\tisl_seq_clr(bmap->ineq[i], 1 + total);\n\tisl_int_set_si(bmap->ineq[i][1+nparam+pos], 1);\n\tisl_int_set_si(bmap->ineq[i][1+nparam+n_in+pos], -1);\n\treturn isl_basic_map_finalize(bmap);\nerror:\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n__isl_give isl_basic_map *isl_basic_map_equal(\n\t__isl_take isl_space *space, unsigned n_equal)\n{\n\tint i;\n\tstruct isl_basic_map *bmap;\n\tbmap = isl_basic_map_alloc_space(space, 0, n_equal, 0);\n\tif (!bmap)\n\t\treturn NULL;\n\tfor (i = 0; i < n_equal && bmap; ++i)\n\t\tbmap = var_equal(bmap, i);\n\treturn isl_basic_map_finalize(bmap);\n}\n\n/* Return a relation on of dimension \"space\" expressing i_[0..pos] << o_[0..pos]\n */\n__isl_give isl_basic_map *isl_basic_map_less_at(__isl_take isl_space *space,\n\tunsigned pos)\n{\n\tint i;\n\tstruct isl_basic_map *bmap;\n\tbmap = isl_basic_map_alloc_space(space, 0, pos, 1);\n\tif (!bmap)\n\t\treturn NULL;\n\tfor (i = 0; i < pos && bmap; ++i)\n\t\tbmap = var_equal(bmap, i);\n\tif (bmap)\n\t\tbmap = var_less(bmap, pos);\n\treturn isl_basic_map_finalize(bmap);\n}\n\n/* Return a relation on \"space\" expressing i_[0..pos] <<= o_[0..pos]\n */\n__isl_give isl_basic_map *isl_basic_map_less_or_equal_at(\n\t__isl_take isl_space *space, unsigned pos)\n{\n\tint i;\n\tisl_basic_map *bmap;\n\n\tbmap = isl_basic_map_alloc_space(space, 0, pos, 1);\n\tfor (i = 0; i < pos; ++i)\n\t\tbmap = var_equal(bmap, i);\n\tbmap = var_less_or_equal(bmap, pos);\n\treturn isl_basic_map_finalize(bmap);\n}\n\n/* Return a relation on \"space\" expressing i_pos > o_pos\n */\n__isl_give isl_basic_map *isl_basic_map_more_at(__isl_take isl_space *space,\n\tunsigned pos)\n{\n\tint i;\n\tstruct isl_basic_map *bmap;\n\tbmap = isl_basic_map_alloc_space(space, 0, pos, 1);\n\tif (!bmap)\n\t\treturn NULL;\n\tfor (i = 0; i < pos && bmap; ++i)\n\t\tbmap = var_equal(bmap, i);\n\tif (bmap)\n\t\tbmap = var_more(bmap, pos);\n\treturn isl_basic_map_finalize(bmap);\n}\n\n/* Return a relation on \"space\" expressing i_[0..pos] >>= o_[0..pos]\n */\n__isl_give isl_basic_map *isl_basic_map_more_or_equal_at(\n\t__isl_take isl_space *space, unsigned pos)\n{\n\tint i;\n\tisl_basic_map *bmap;\n\n\tbmap = isl_basic_map_alloc_space(space, 0, pos, 1);\n\tfor (i = 0; i < pos; ++i)\n\t\tbmap = var_equal(bmap, i);\n\tbmap = var_more_or_equal(bmap, pos);\n\treturn isl_basic_map_finalize(bmap);\n}\n\nstatic __isl_give isl_map *map_lex_lte_first(__isl_take isl_space *space,\n\tunsigned n, int equal)\n{\n\tstruct isl_map *map;\n\tint i;\n\n\tif (n == 0 && equal)\n\t\treturn isl_map_universe(space);\n\n\tmap = isl_map_alloc_space(isl_space_copy(space), n, ISL_MAP_DISJOINT);\n\n\tfor (i = 0; i + 1 < n; ++i)\n\t\tmap = isl_map_add_basic_map(map,\n\t\t\t\t  isl_basic_map_less_at(isl_space_copy(space), i));\n\tif (n > 0) {\n\t\tif (equal)\n\t\t\tmap = isl_map_add_basic_map(map,\n\t\t\t      isl_basic_map_less_or_equal_at(space, n - 1));\n\t\telse\n\t\t\tmap = isl_map_add_basic_map(map,\n\t\t\t      isl_basic_map_less_at(space, n - 1));\n\t} else\n\t\tisl_space_free(space);\n\n\treturn map;\n}\n\nstatic __isl_give isl_map *map_lex_lte(__isl_take isl_space *space, int equal)\n{\n\tif (!space)\n\t\treturn NULL;\n\treturn map_lex_lte_first(space, space->n_out, equal);\n}\n\n__isl_give isl_map *isl_map_lex_lt_first(__isl_take isl_space *space,\n\tunsigned n)\n{\n\treturn map_lex_lte_first(space, n, 0);\n}\n\n__isl_give isl_map *isl_map_lex_le_first(__isl_take isl_space *space,\n\tunsigned n)\n{\n\treturn map_lex_lte_first(space, n, 1);\n}\n\n__isl_give isl_map *isl_map_lex_lt(__isl_take isl_space *set_space)\n{\n\treturn map_lex_lte(isl_space_map_from_set(set_space), 0);\n}\n\n__isl_give isl_map *isl_map_lex_le(__isl_take isl_space *set_space)\n{\n\treturn map_lex_lte(isl_space_map_from_set(set_space), 1);\n}\n\nstatic __isl_give isl_map *map_lex_gte_first(__isl_take isl_space *space,\n\tunsigned n, int equal)\n{\n\tstruct isl_map *map;\n\tint i;\n\n\tif (n == 0 && equal)\n\t\treturn isl_map_universe(space);\n\n\tmap = isl_map_alloc_space(isl_space_copy(space), n, ISL_MAP_DISJOINT);\n\n\tfor (i = 0; i + 1 < n; ++i)\n\t\tmap = isl_map_add_basic_map(map,\n\t\t\t\t  isl_basic_map_more_at(isl_space_copy(space), i));\n\tif (n > 0) {\n\t\tif (equal)\n\t\t\tmap = isl_map_add_basic_map(map,\n\t\t\t      isl_basic_map_more_or_equal_at(space, n - 1));\n\t\telse\n\t\t\tmap = isl_map_add_basic_map(map,\n\t\t\t      isl_basic_map_more_at(space, n - 1));\n\t} else\n\t\tisl_space_free(space);\n\n\treturn map;\n}\n\nstatic __isl_give isl_map *map_lex_gte(__isl_take isl_space *space, int equal)\n{\n\tif (!space)\n\t\treturn NULL;\n\treturn map_lex_gte_first(space, space->n_out, equal);\n}\n\n__isl_give isl_map *isl_map_lex_gt_first(__isl_take isl_space *space,\n\tunsigned n)\n{\n\treturn map_lex_gte_first(space, n, 0);\n}\n\n__isl_give isl_map *isl_map_lex_ge_first(__isl_take isl_space *space,\n\tunsigned n)\n{\n\treturn map_lex_gte_first(space, n, 1);\n}\n\n__isl_give isl_map *isl_map_lex_gt(__isl_take isl_space *set_space)\n{\n\treturn map_lex_gte(isl_space_map_from_set(set_space), 0);\n}\n\n__isl_give isl_map *isl_map_lex_ge(__isl_take isl_space *set_space)\n{\n\treturn map_lex_gte(isl_space_map_from_set(set_space), 1);\n}\n\n__isl_give isl_map *isl_set_lex_le_set(__isl_take isl_set *set1,\n\t__isl_take isl_set *set2)\n{\n\tisl_map *map;\n\tmap = isl_map_lex_le(isl_set_get_space(set1));\n\tmap = isl_map_intersect_domain(map, set1);\n\tmap = isl_map_intersect_range(map, set2);\n\treturn map;\n}\n\n__isl_give isl_map *isl_set_lex_lt_set(__isl_take isl_set *set1,\n\t__isl_take isl_set *set2)\n{\n\tisl_map *map;\n\tmap = isl_map_lex_lt(isl_set_get_space(set1));\n\tmap = isl_map_intersect_domain(map, set1);\n\tmap = isl_map_intersect_range(map, set2);\n\treturn map;\n}\n\n__isl_give isl_map *isl_set_lex_ge_set(__isl_take isl_set *set1,\n\t__isl_take isl_set *set2)\n{\n\tisl_map *map;\n\tmap = isl_map_lex_ge(isl_set_get_space(set1));\n\tmap = isl_map_intersect_domain(map, set1);\n\tmap = isl_map_intersect_range(map, set2);\n\treturn map;\n}\n\n__isl_give isl_map *isl_set_lex_gt_set(__isl_take isl_set *set1,\n\t__isl_take isl_set *set2)\n{\n\tisl_map *map;\n\tmap = isl_map_lex_gt(isl_set_get_space(set1));\n\tmap = isl_map_intersect_domain(map, set1);\n\tmap = isl_map_intersect_range(map, set2);\n\treturn map;\n}\n\n__isl_give isl_map *isl_map_lex_le_map(__isl_take isl_map *map1,\n\t__isl_take isl_map *map2)\n{\n\tisl_map *map;\n\tmap = isl_map_lex_le(isl_space_range(isl_map_get_space(map1)));\n\tmap = isl_map_apply_domain(map, isl_map_reverse(map1));\n\tmap = isl_map_apply_range(map, isl_map_reverse(map2));\n\treturn map;\n}\n\n__isl_give isl_map *isl_map_lex_lt_map(__isl_take isl_map *map1,\n\t__isl_take isl_map *map2)\n{\n\tisl_map *map;\n\tmap = isl_map_lex_lt(isl_space_range(isl_map_get_space(map1)));\n\tmap = isl_map_apply_domain(map, isl_map_reverse(map1));\n\tmap = isl_map_apply_range(map, isl_map_reverse(map2));\n\treturn map;\n}\n\n__isl_give isl_map *isl_map_lex_ge_map(__isl_take isl_map *map1,\n\t__isl_take isl_map *map2)\n{\n\tisl_map *map;\n\tmap = isl_map_lex_ge(isl_space_range(isl_map_get_space(map1)));\n\tmap = isl_map_apply_domain(map, isl_map_reverse(map1));\n\tmap = isl_map_apply_range(map, isl_map_reverse(map2));\n\treturn map;\n}\n\n__isl_give isl_map *isl_map_lex_gt_map(__isl_take isl_map *map1,\n\t__isl_take isl_map *map2)\n{\n\tisl_map *map;\n\tmap = isl_map_lex_gt(isl_space_range(isl_map_get_space(map1)));\n\tmap = isl_map_apply_domain(map, isl_map_reverse(map1));\n\tmap = isl_map_apply_range(map, isl_map_reverse(map2));\n\treturn map;\n}\n\n/* For the div d = floor(f/m) at position \"div\", add the constraint\n *\n *\t\tf - m d >= 0\n */\nstatic __isl_give isl_basic_map *add_upper_div_constraint(\n\t__isl_take isl_basic_map *bmap, unsigned div)\n{\n\tint i;\n\tisl_size v_div = isl_basic_map_var_offset(bmap, isl_dim_div);\n\tisl_size n_div;\n\tunsigned pos;\n\n\tn_div = isl_basic_map_dim(bmap, isl_dim_div);\n\tif (v_div < 0 || n_div < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tpos = v_div + div;\n\ti = isl_basic_map_alloc_inequality(bmap);\n\tif (i < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tisl_seq_cpy(bmap->ineq[i], bmap->div[div] + 1, 1 + v_div + n_div);\n\tisl_int_neg(bmap->ineq[i][1 + pos], bmap->div[div][0]);\n\n\treturn bmap;\n}\n\n/* For the div d = floor(f/m) at position \"div\", add the constraint\n *\n *\t\t-(f-(m-1)) + m d >= 0\n */\nstatic __isl_give isl_basic_map *add_lower_div_constraint(\n\t__isl_take isl_basic_map *bmap, unsigned div)\n{\n\tint i;\n\tisl_size v_div = isl_basic_map_var_offset(bmap, isl_dim_div);\n\tisl_size n_div;\n\tunsigned pos;\n\n\tn_div = isl_basic_map_dim(bmap, isl_dim_div);\n\tif (v_div < 0 || n_div < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tpos = v_div + div;\n\ti = isl_basic_map_alloc_inequality(bmap);\n\tif (i < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tisl_seq_neg(bmap->ineq[i], bmap->div[div] + 1, 1 + v_div + n_div);\n\tisl_int_set(bmap->ineq[i][1 + pos], bmap->div[div][0]);\n\tisl_int_add(bmap->ineq[i][0], bmap->ineq[i][0], bmap->ineq[i][1 + pos]);\n\tisl_int_sub_ui(bmap->ineq[i][0], bmap->ineq[i][0], 1);\n\n\treturn bmap;\n}\n\n/* For the div d = floor(f/m) at position \"pos\", add the constraints\n *\n *\t\tf - m d >= 0\n *\t\t-(f-(m-1)) + m d >= 0\n *\n * Note that the second constraint is the negation of\n *\n *\t\tf - m d >= m\n */\n__isl_give isl_basic_map *isl_basic_map_add_div_constraints(\n\t__isl_take isl_basic_map *bmap, unsigned pos)\n{\n\tbmap = add_upper_div_constraint(bmap, pos);\n\tbmap = add_lower_div_constraint(bmap, pos);\n\treturn bmap;\n}\n\n/* For each known div d = floor(f/m), add the constraints\n *\n *\t\tf - m d >= 0\n *\t\t-(f-(m-1)) + m d >= 0\n *\n * Remove duplicate constraints in case of some these div constraints\n * already appear in \"bmap\".\n */\n__isl_give isl_basic_map *isl_basic_map_add_known_div_constraints(\n\t__isl_take isl_basic_map *bmap)\n{\n\tisl_size n_div;\n\n\tn_div = isl_basic_map_dim(bmap, isl_dim_div);\n\tif (n_div < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tif (n_div == 0)\n\t\treturn bmap;\n\n\tbmap = add_known_div_constraints(bmap);\n\tbmap = isl_basic_map_remove_duplicate_constraints(bmap, NULL, 0);\n\tbmap = isl_basic_map_finalize(bmap);\n\treturn bmap;\n}\n\n/* Add the div constraint of sign \"sign\" for div \"div\" of \"bmap\".\n *\n * In particular, if this div is of the form d = floor(f/m),\n * then add the constraint\n *\n *\t\tf - m d >= 0\n *\n * if sign < 0 or the constraint\n *\n *\t\t-(f-(m-1)) + m d >= 0\n *\n * if sign > 0.\n */\n__isl_give isl_basic_map *isl_basic_map_add_div_constraint(\n\t__isl_take isl_basic_map *bmap, unsigned div, int sign)\n{\n\tif (sign < 0)\n\t\treturn add_upper_div_constraint(bmap, div);\n\telse\n\t\treturn add_lower_div_constraint(bmap, div);\n}\n\n__isl_give isl_basic_set *isl_basic_map_underlying_set(\n\t__isl_take isl_basic_map *bmap)\n{\n\tisl_space *space;\n\n\tif (!bmap)\n\t\tgoto error;\n\tif (bmap->dim->nparam == 0 && bmap->dim->n_in == 0 &&\n\t    bmap->n_div == 0 &&\n\t    !isl_space_is_named_or_nested(bmap->dim, isl_dim_in) &&\n\t    !isl_space_is_named_or_nested(bmap->dim, isl_dim_out))\n\t\treturn bset_from_bmap(bmap);\n\tbmap = isl_basic_map_cow(bmap);\n\tif (!bmap)\n\t\treturn NULL;\n\tspace = isl_basic_map_take_space(bmap);\n\tspace = isl_space_underlying(space, bmap->n_div);\n\tbmap = isl_basic_map_restore_space(bmap, space);\n\tif (!bmap)\n\t\treturn NULL;\n\tbmap->extra -= bmap->n_div;\n\tbmap->n_div = 0;\n\tbmap = isl_basic_map_finalize(bmap);\n\treturn bset_from_bmap(bmap);\nerror:\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n__isl_give isl_basic_set *isl_basic_set_underlying_set(\n\t\t__isl_take isl_basic_set *bset)\n{\n\treturn isl_basic_map_underlying_set(bset_to_bmap(bset));\n}\n\n/* Replace each element in \"list\" by the result of applying\n * isl_basic_map_underlying_set to the element.\n */\n__isl_give isl_basic_set_list *isl_basic_map_list_underlying_set(\n\t__isl_take isl_basic_map_list *list)\n{\n\tint i;\n\tisl_size n;\n\n\tn = isl_basic_map_list_n_basic_map(list);\n\tif (n < 0)\n\t\tgoto error;\n\n\tfor (i = 0; i < n; ++i) {\n\t\tisl_basic_map *bmap;\n\t\tisl_basic_set *bset;\n\n\t\tbmap = isl_basic_map_list_get_basic_map(list, i);\n\t\tbset = isl_basic_set_underlying_set(bmap);\n\t\tlist = isl_basic_set_list_set_basic_set(list, i, bset);\n\t}\n\n\treturn list;\nerror:\n\tisl_basic_map_list_free(list);\n\treturn NULL;\n}\n\n__isl_give isl_basic_map *isl_basic_map_overlying_set(\n\t__isl_take isl_basic_set *bset, __isl_take isl_basic_map *like)\n{\n\tstruct isl_basic_map *bmap;\n\tstruct isl_ctx *ctx;\n\tisl_size dim, bmap_total;\n\tunsigned total;\n\tint i;\n\n\tif (!bset || !like)\n\t\tgoto error;\n\tctx = bset->ctx;\n\tif (isl_basic_set_check_no_params(bset) < 0 ||\n\t    isl_basic_set_check_no_locals(bset) < 0)\n\t\tgoto error;\n\tdim = isl_basic_set_dim(bset, isl_dim_set);\n\tbmap_total = isl_basic_map_dim(like, isl_dim_all);\n\tif (dim < 0 || bmap_total < 0)\n\t\tgoto error;\n\tisl_assert(ctx, dim == bmap_total, goto error);\n\tif (like->n_div == 0) {\n\t\tisl_space *space = isl_basic_map_get_space(like);\n\t\tisl_basic_map_free(like);\n\t\treturn isl_basic_map_reset_space(bset, space);\n\t}\n\tbset = isl_basic_set_cow(bset);\n\tif (!bset)\n\t\tgoto error;\n\ttotal = dim + bset->extra;\n\tbmap = bset_to_bmap(bset);\n\tisl_space_free(isl_basic_map_take_space(bmap));\n\tbmap = isl_basic_map_restore_space(bmap, isl_basic_map_get_space(like));\n\tif (!bmap)\n\t\tgoto error;\n\tbmap->n_div = like->n_div;\n\tbmap->extra += like->n_div;\n\tif (bmap->extra) {\n\t\tunsigned ltotal;\n\t\tisl_int **div;\n\t\tltotal = total - bmap->extra + like->extra;\n\t\tif (ltotal > total)\n\t\t\tltotal = total;\n\t\tbmap->block2 = isl_blk_extend(ctx, bmap->block2,\n\t\t\t\t\tbmap->extra * (1 + 1 + total));\n\t\tif (isl_blk_is_error(bmap->block2))\n\t\t\tgoto error;\n\t\tdiv = isl_realloc_array(ctx, bmap->div, isl_int *, bmap->extra);\n\t\tif (!div)\n\t\t\tgoto error;\n\t\tbmap->div = div;\n\t\tfor (i = 0; i < bmap->extra; ++i)\n\t\t\tbmap->div[i] = bmap->block2.data + i * (1 + 1 + total);\n\t\tfor (i = 0; i < like->n_div; ++i) {\n\t\t\tisl_seq_cpy(bmap->div[i], like->div[i], 1 + 1 + ltotal);\n\t\t\tisl_seq_clr(bmap->div[i]+1+1+ltotal, total - ltotal);\n\t\t}\n\t\tbmap = isl_basic_map_add_known_div_constraints(bmap);\n\t}\n\tisl_basic_map_free(like);\n\tbmap = isl_basic_map_simplify(bmap);\n\tbmap = isl_basic_map_finalize(bmap);\n\treturn bmap;\nerror:\n\tisl_basic_map_free(like);\n\tisl_basic_set_free(bset);\n\treturn NULL;\n}\n\n__isl_give isl_basic_set *isl_basic_set_from_underlying_set(\n\t__isl_take isl_basic_set *bset, __isl_take isl_basic_set *like)\n{\n\treturn bset_from_bmap(isl_basic_map_overlying_set(bset,\n\t\t\t\t\t\t\tbset_to_bmap(like)));\n}\n\n__isl_give isl_set *isl_map_underlying_set(__isl_take isl_map *map)\n{\n\tint i;\n\n\tmap = isl_map_cow(map);\n\tif (!map)\n\t\treturn NULL;\n\tmap->dim = isl_space_cow(map->dim);\n\tif (!map->dim)\n\t\tgoto error;\n\n\tfor (i = 1; i < map->n; ++i)\n\t\tisl_assert(map->ctx, map->p[0]->n_div == map->p[i]->n_div,\n\t\t\t\tgoto error);\n\tfor (i = 0; i < map->n; ++i) {\n\t\tmap->p[i] = bset_to_bmap(\n\t\t\t\tisl_basic_map_underlying_set(map->p[i]));\n\t\tif (!map->p[i])\n\t\t\tgoto error;\n\t}\n\tif (map->n == 0)\n\t\tmap->dim = isl_space_underlying(map->dim, 0);\n\telse {\n\t\tisl_space_free(map->dim);\n\t\tmap->dim = isl_space_copy(map->p[0]->dim);\n\t}\n\tif (!map->dim)\n\t\tgoto error;\n\treturn set_from_map(map);\nerror:\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n/* Replace the space of \"bmap\" by \"space\".\n *\n * If the space of \"bmap\" is identical to \"space\" (including the identifiers\n * of the input and output dimensions), then simply return the original input.\n */\n__isl_give isl_basic_map *isl_basic_map_reset_space(\n\t__isl_take isl_basic_map *bmap, __isl_take isl_space *space)\n{\n\tisl_bool equal;\n\tisl_space *bmap_space;\n\n\tbmap_space = isl_basic_map_peek_space(bmap);\n\tequal = isl_space_is_equal(bmap_space, space);\n\tif (equal >= 0 && equal)\n\t\tequal = isl_space_has_equal_ids(bmap_space, space);\n\tif (equal < 0)\n\t\tgoto error;\n\tif (equal) {\n\t\tisl_space_free(space);\n\t\treturn bmap;\n\t}\n\tisl_space_free(isl_basic_map_take_space(bmap));\n\tbmap = isl_basic_map_restore_space(bmap, space);\n\n\tbmap = isl_basic_map_finalize(bmap);\n\n\treturn bmap;\nerror:\n\tisl_basic_map_free(bmap);\n\tisl_space_free(space);\n\treturn NULL;\n}\n\n__isl_give isl_basic_set *isl_basic_set_reset_space(\n\t__isl_take isl_basic_set *bset, __isl_take isl_space *space)\n{\n\treturn bset_from_bmap(isl_basic_map_reset_space(bset_to_bmap(bset),\n\t\t\t\t\t\t\tspace));\n}\n\n/* Check that the total dimensions of \"map\" and \"space\" are the same.\n */\nstatic isl_stat check_map_space_equal_total_dim(__isl_keep isl_map *map,\n\t__isl_keep isl_space *space)\n{\n\tisl_size dim1, dim2;\n\n\tdim1 = isl_map_dim(map, isl_dim_all);\n\tdim2 = isl_space_dim(space, isl_dim_all);\n\tif (dim1 < 0 || dim2 < 0)\n\t\treturn isl_stat_error;\n\tif (dim1 == dim2)\n\t\treturn isl_stat_ok;\n\tisl_die(isl_map_get_ctx(map), isl_error_invalid,\n\t\t\"total dimensions do not match\", return isl_stat_error);\n}\n\n__isl_give isl_map *isl_map_reset_space(__isl_take isl_map *map,\n\t__isl_take isl_space *space)\n{\n\tint i;\n\n\tmap = isl_map_cow(map);\n\tif (!map || !space)\n\t\tgoto error;\n\n\tfor (i = 0; i < map->n; ++i) {\n\t\tmap->p[i] = isl_basic_map_reset_space(map->p[i],\n\t\t\t\t\t\t    isl_space_copy(space));\n\t\tif (!map->p[i])\n\t\t\tgoto error;\n\t}\n\tisl_space_free(isl_map_take_space(map));\n\tmap = isl_map_restore_space(map, space);\n\n\treturn map;\nerror:\n\tisl_map_free(map);\n\tisl_space_free(space);\n\treturn NULL;\n}\n\n/* Replace the space of \"map\" by \"space\", without modifying\n * the dimension of \"map\".\n *\n * If the space of \"map\" is identical to \"space\" (including the identifiers\n * of the input and output dimensions), then simply return the original input.\n */\n__isl_give isl_map *isl_map_reset_equal_dim_space(__isl_take isl_map *map,\n\t__isl_take isl_space *space)\n{\n\tisl_bool equal;\n\tisl_space *map_space;\n\n\tmap_space = isl_map_peek_space(map);\n\tequal = isl_space_is_equal(map_space, space);\n\tif (equal >= 0 && equal)\n\t\tequal = isl_space_has_equal_ids(map_space, space);\n\tif (equal < 0)\n\t\tgoto error;\n\tif (equal) {\n\t\tisl_space_free(space);\n\t\treturn map;\n\t}\n\tif (check_map_space_equal_total_dim(map, space) < 0)\n\t\tgoto error;\n\treturn isl_map_reset_space(map, space);\nerror:\n\tisl_map_free(map);\n\tisl_space_free(space);\n\treturn NULL;\n}\n\n__isl_give isl_set *isl_set_reset_space(__isl_take isl_set *set,\n\t__isl_take isl_space *space)\n{\n\treturn set_from_map(isl_map_reset_space(set_to_map(set), space));\n}\n\n/* Compute the parameter domain of the given basic set.\n */\n__isl_give isl_basic_set *isl_basic_set_params(__isl_take isl_basic_set *bset)\n{\n\tisl_bool is_params;\n\tisl_space *space;\n\tisl_size n;\n\n\tis_params = isl_basic_set_is_params(bset);\n\tif (is_params < 0)\n\t\treturn isl_basic_set_free(bset);\n\tif (is_params)\n\t\treturn bset;\n\n\tn = isl_basic_set_dim(bset, isl_dim_set);\n\tif (n < 0)\n\t\treturn isl_basic_set_free(bset);\n\tbset = isl_basic_set_project_out(bset, isl_dim_set, 0, n);\n\tspace = isl_basic_set_get_space(bset);\n\tspace = isl_space_params(space);\n\tbset = isl_basic_set_reset_space(bset, space);\n\treturn bset;\n}\n\n/* Construct a zero-dimensional basic set with the given parameter domain.\n */\n__isl_give isl_basic_set *isl_basic_set_from_params(\n\t__isl_take isl_basic_set *bset)\n{\n\tisl_space *space;\n\tspace = isl_basic_set_get_space(bset);\n\tspace = isl_space_set_from_params(space);\n\tbset = isl_basic_set_reset_space(bset, space);\n\treturn bset;\n}\n\n/* Compute the parameter domain of the given set.\n */\n__isl_give isl_set *isl_set_params(__isl_take isl_set *set)\n{\n\treturn isl_map_params(set_to_map(set));\n}\n\n/* Construct a zero-dimensional set with the given parameter domain.\n */\n__isl_give isl_set *isl_set_from_params(__isl_take isl_set *set)\n{\n\tisl_space *space;\n\tspace = isl_set_get_space(set);\n\tspace = isl_space_set_from_params(space);\n\tset = isl_set_reset_space(set, space);\n\treturn set;\n}\n\n/* Compute the parameter domain of the given map.\n */\n__isl_give isl_set *isl_map_params(__isl_take isl_map *map)\n{\n\tisl_space *space;\n\tisl_size n_in, n_out;\n\n\tn_in = isl_map_dim(map, isl_dim_in);\n\tn_out = isl_map_dim(map, isl_dim_out);\n\tif (n_in < 0 || n_out < 0)\n\t\treturn isl_map_free(map);\n\tmap = isl_map_project_out(map, isl_dim_in, 0, n_in);\n\tmap = isl_map_project_out(map, isl_dim_out, 0, n_out);\n\tspace = isl_map_get_space(map);\n\tspace = isl_space_params(space);\n\tmap = isl_map_reset_space(map, space);\n\treturn map;\n}\n\n__isl_give isl_basic_set *isl_basic_map_domain(__isl_take isl_basic_map *bmap)\n{\n\tisl_space *space;\n\tisl_size n_out;\n\n\tn_out = isl_basic_map_dim(bmap, isl_dim_out);\n\tif (n_out < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tspace = isl_space_domain(isl_basic_map_get_space(bmap));\n\n\tbmap = isl_basic_map_project_out(bmap, isl_dim_out, 0, n_out);\n\n\treturn isl_basic_map_reset_space(bmap, space);\n}\n\nisl_bool isl_basic_map_may_be_set(__isl_keep isl_basic_map *bmap)\n{\n\tif (!bmap)\n\t\treturn isl_bool_error;\n\treturn isl_space_may_be_set(bmap->dim);\n}\n\n/* Is this basic map actually a set?\n * Users should never call this function.  Outside of isl,\n * the type should indicate whether something is a set or a map.\n */\nisl_bool isl_basic_map_is_set(__isl_keep isl_basic_map *bmap)\n{\n\tif (!bmap)\n\t\treturn isl_bool_error;\n\treturn isl_space_is_set(bmap->dim);\n}\n\n__isl_give isl_basic_set *isl_basic_map_range(__isl_take isl_basic_map *bmap)\n{\n\tisl_bool is_set;\n\n\tis_set = isl_basic_map_is_set(bmap);\n\tif (is_set < 0)\n\t\tgoto error;\n\tif (is_set)\n\t\treturn bmap;\n\treturn isl_basic_map_domain(isl_basic_map_reverse(bmap));\nerror:\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n__isl_give isl_basic_map *isl_basic_map_domain_map(\n\t__isl_take isl_basic_map *bmap)\n{\n\tint i;\n\tisl_space *space;\n\tisl_basic_map *domain;\n\tisl_size nparam, n_in, n_out;\n\n\tnparam = isl_basic_map_dim(bmap, isl_dim_param);\n\tn_in = isl_basic_map_dim(bmap, isl_dim_in);\n\tn_out = isl_basic_map_dim(bmap, isl_dim_out);\n\tif (nparam < 0 || n_in < 0 || n_out < 0)\n\t\treturn isl_basic_map_free(bmap);\n\n\tspace = isl_basic_map_get_space(bmap);\n\tspace = isl_space_from_range(isl_space_domain(space));\n\tdomain = isl_basic_map_universe(space);\n\n\tbmap = isl_basic_map_from_domain(isl_basic_map_wrap(bmap));\n\tbmap = isl_basic_map_apply_range(bmap, domain);\n\tbmap = isl_basic_map_extend_constraints(bmap, n_in, 0);\n\n\tfor (i = 0; i < n_in; ++i)\n\t\tbmap = isl_basic_map_equate(bmap, isl_dim_in, i,\n\t\t\t\t\t\t    isl_dim_out, i);\n\n\tbmap = isl_basic_map_gauss(bmap, NULL);\n\treturn isl_basic_map_finalize(bmap);\n}\n\n__isl_give isl_basic_map *isl_basic_map_range_map(\n\t__isl_take isl_basic_map *bmap)\n{\n\tint i;\n\tisl_space *space;\n\tisl_basic_map *range;\n\tisl_size nparam, n_in, n_out;\n\n\tnparam = isl_basic_map_dim(bmap, isl_dim_param);\n\tn_in = isl_basic_map_dim(bmap, isl_dim_in);\n\tn_out = isl_basic_map_dim(bmap, isl_dim_out);\n\tif (nparam < 0 || n_in < 0 || n_out < 0)\n\t\treturn isl_basic_map_free(bmap);\n\n\tspace = isl_basic_map_get_space(bmap);\n\tspace = isl_space_from_range(isl_space_range(space));\n\trange = isl_basic_map_universe(space);\n\n\tbmap = isl_basic_map_from_domain(isl_basic_map_wrap(bmap));\n\tbmap = isl_basic_map_apply_range(bmap, range);\n\tbmap = isl_basic_map_extend_constraints(bmap, n_out, 0);\n\n\tfor (i = 0; i < n_out; ++i)\n\t\tbmap = isl_basic_map_equate(bmap, isl_dim_in, n_in + i,\n\t\t\t\t\t\t    isl_dim_out, i);\n\n\tbmap = isl_basic_map_gauss(bmap, NULL);\n\treturn isl_basic_map_finalize(bmap);\n}\n\nint isl_map_may_be_set(__isl_keep isl_map *map)\n{\n\tif (!map)\n\t\treturn -1;\n\treturn isl_space_may_be_set(map->dim);\n}\n\n/* Is this map actually a set?\n * Users should never call this function.  Outside of isl,\n * the type should indicate whether something is a set or a map.\n */\nisl_bool isl_map_is_set(__isl_keep isl_map *map)\n{\n\tif (!map)\n\t\treturn isl_bool_error;\n\treturn isl_space_is_set(map->dim);\n}\n\n__isl_give isl_set *isl_map_range(__isl_take isl_map *map)\n{\n\tisl_space *space;\n\tisl_size n_in;\n\n\tn_in = isl_map_dim(map, isl_dim_in);\n\tif (n_in < 0)\n\t\treturn set_from_map(isl_map_free(map));\n\tspace = isl_space_range(isl_map_get_space(map));\n\n\tmap = isl_map_project_out(map, isl_dim_in, 0, n_in);\n\n\treturn set_from_map(isl_map_reset_space(map, space));\n}\n\n/* Transform \"map\" by applying \"fn_space\" to its space and \"fn_bmap\"\n * to each of its basic maps.\n */\nstatic __isl_give isl_map *isl_map_transform(__isl_take isl_map *map,\n\t__isl_give isl_space *(*fn_space)(__isl_take isl_space *space),\n\t__isl_give isl_basic_map *(*fn_bmap)(__isl_take isl_basic_map *bmap))\n{\n\tint i;\n\tisl_space *space;\n\n\tmap = isl_map_cow(map);\n\tif (!map)\n\t\treturn NULL;\n\n\tfor (i = 0; i < map->n; ++i) {\n\t\tmap->p[i] = fn_bmap(map->p[i]);\n\t\tif (!map->p[i])\n\t\t\treturn isl_map_free(map);\n\t}\n\tmap = isl_map_unmark_normalized(map);\n\n\tspace = isl_map_take_space(map);\n\tspace = fn_space(space);\n\tmap = isl_map_restore_space(map, space);\n\n\treturn map;\n}\n\n__isl_give isl_map *isl_map_domain_map(__isl_take isl_map *map)\n{\n\treturn isl_map_transform(map, &isl_space_domain_map,\n\t\t\t\t\t&isl_basic_map_domain_map);\n}\n\n__isl_give isl_map *isl_map_range_map(__isl_take isl_map *map)\n{\n\treturn isl_map_transform(map, &isl_space_range_map,\n\t\t\t\t\t&isl_basic_map_range_map);\n}\n\n/* Given a wrapped map of the form A[B -> C],\n * return the map A[B -> C] -> B.\n */\n__isl_give isl_map *isl_set_wrapped_domain_map(__isl_take isl_set *set)\n{\n\tisl_id *id;\n\tisl_map *map;\n\n\tif (!set)\n\t\treturn NULL;\n\tif (!isl_set_has_tuple_id(set))\n\t\treturn isl_map_domain_map(isl_set_unwrap(set));\n\n\tid = isl_set_get_tuple_id(set);\n\tmap = isl_map_domain_map(isl_set_unwrap(set));\n\tmap = isl_map_set_tuple_id(map, isl_dim_in, id);\n\n\treturn map;\n}\n\n__isl_give isl_basic_map *isl_basic_map_from_domain(\n\t__isl_take isl_basic_set *bset)\n{\n\treturn isl_basic_map_reverse(isl_basic_map_from_range(bset));\n}\n\n__isl_give isl_basic_map *isl_basic_map_from_range(\n\t__isl_take isl_basic_set *bset)\n{\n\tisl_space *space;\n\tspace = isl_basic_set_get_space(bset);\n\tspace = isl_space_from_range(space);\n\tbset = isl_basic_set_reset_space(bset, space);\n\treturn bset_to_bmap(bset);\n}\n\n/* Create a relation with the given set as range.\n * The domain of the created relation is a zero-dimensional\n * flat anonymous space.\n */\n__isl_give isl_map *isl_map_from_range(__isl_take isl_set *set)\n{\n\tisl_space *space;\n\tspace = isl_set_get_space(set);\n\tspace = isl_space_from_range(space);\n\tset = isl_set_reset_space(set, space);\n\treturn set_to_map(set);\n}\n\n/* Create a relation with the given set as domain.\n * The range of the created relation is a zero-dimensional\n * flat anonymous space.\n */\n__isl_give isl_map *isl_map_from_domain(__isl_take isl_set *set)\n{\n\treturn isl_map_reverse(isl_map_from_range(set));\n}\n\n__isl_give isl_basic_map *isl_basic_map_from_domain_and_range(\n\t__isl_take isl_basic_set *domain, __isl_take isl_basic_set *range)\n{\n\treturn isl_basic_map_apply_range(isl_basic_map_reverse(domain), range);\n}\n\n__isl_give isl_map *isl_map_from_domain_and_range(__isl_take isl_set *domain,\n\t__isl_take isl_set *range)\n{\n\treturn isl_map_apply_range(isl_map_reverse(domain), range);\n}\n\n/* Return a newly allocated isl_map with given space and flags and\n * room for \"n\" basic maps.\n * Make sure that all cached information is cleared.\n */\n__isl_give isl_map *isl_map_alloc_space(__isl_take isl_space *space, int n,\n\tunsigned flags)\n{\n\tstruct isl_map *map;\n\n\tif (!space)\n\t\treturn NULL;\n\tif (n < 0)\n\t\tisl_die(space->ctx, isl_error_internal,\n\t\t\t\"negative number of basic maps\", goto error);\n\tmap = isl_calloc(space->ctx, struct isl_map,\n\t\t\tsizeof(struct isl_map) +\n\t\t\t(n - 1) * sizeof(struct isl_basic_map *));\n\tif (!map)\n\t\tgoto error;\n\n\tmap->ctx = space->ctx;\n\tisl_ctx_ref(map->ctx);\n\tmap->ref = 1;\n\tmap->size = n;\n\tmap->n = 0;\n\tmap->dim = space;\n\tmap->flags = flags;\n\treturn map;\nerror:\n\tisl_space_free(space);\n\treturn NULL;\n}\n\n__isl_give isl_basic_map *isl_basic_map_empty(__isl_take isl_space *space)\n{\n\tstruct isl_basic_map *bmap;\n\tbmap = isl_basic_map_alloc_space(space, 0, 1, 0);\n\tbmap = isl_basic_map_set_to_empty(bmap);\n\treturn bmap;\n}\n\n__isl_give isl_basic_set *isl_basic_set_empty(__isl_take isl_space *space)\n{\n\tstruct isl_basic_set *bset;\n\tbset = isl_basic_set_alloc_space(space, 0, 1, 0);\n\tbset = isl_basic_set_set_to_empty(bset);\n\treturn bset;\n}\n\n__isl_give isl_basic_map *isl_basic_map_universe(__isl_take isl_space *space)\n{\n\tstruct isl_basic_map *bmap;\n\tbmap = isl_basic_map_alloc_space(space, 0, 0, 0);\n\tbmap = isl_basic_map_finalize(bmap);\n\treturn bmap;\n}\n\n__isl_give isl_basic_set *isl_basic_set_universe(__isl_take isl_space *space)\n{\n\tstruct isl_basic_set *bset;\n\tbset = isl_basic_set_alloc_space(space, 0, 0, 0);\n\tbset = isl_basic_set_finalize(bset);\n\treturn bset;\n}\n\n__isl_give isl_basic_map *isl_basic_map_nat_universe(\n\t__isl_take isl_space *space)\n{\n\tint i;\n\tisl_size total = isl_space_dim(space, isl_dim_all);\n\tisl_basic_map *bmap;\n\n\tif (total < 0)\n\t\tspace = isl_space_free(space);\n\tbmap = isl_basic_map_alloc_space(space, 0, 0, total);\n\tfor (i = 0; i < total; ++i) {\n\t\tint k = isl_basic_map_alloc_inequality(bmap);\n\t\tif (k < 0)\n\t\t\tgoto error;\n\t\tisl_seq_clr(bmap->ineq[k], 1 + total);\n\t\tisl_int_set_si(bmap->ineq[k][1 + i], 1);\n\t}\n\treturn bmap;\nerror:\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n__isl_give isl_basic_set *isl_basic_set_nat_universe(\n\t__isl_take isl_space *space)\n{\n\treturn isl_basic_map_nat_universe(space);\n}\n\n__isl_give isl_map *isl_map_nat_universe(__isl_take isl_space *space)\n{\n\treturn isl_map_from_basic_map(isl_basic_map_nat_universe(space));\n}\n\n__isl_give isl_set *isl_set_nat_universe(__isl_take isl_space *space)\n{\n\treturn isl_map_nat_universe(space);\n}\n\n__isl_give isl_map *isl_map_empty(__isl_take isl_space *space)\n{\n\treturn isl_map_alloc_space(space, 0, ISL_MAP_DISJOINT);\n}\n\n__isl_give isl_set *isl_set_empty(__isl_take isl_space *space)\n{\n\treturn isl_set_alloc_space(space, 0, ISL_MAP_DISJOINT);\n}\n\n__isl_give isl_map *isl_map_universe(__isl_take isl_space *space)\n{\n\tstruct isl_map *map;\n\tif (!space)\n\t\treturn NULL;\n\tmap = isl_map_alloc_space(isl_space_copy(space), 1, ISL_MAP_DISJOINT);\n\tmap = isl_map_add_basic_map(map, isl_basic_map_universe(space));\n\treturn map;\n}\n\n__isl_give isl_set *isl_set_universe(__isl_take isl_space *space)\n{\n\tstruct isl_set *set;\n\tif (!space)\n\t\treturn NULL;\n\tset = isl_set_alloc_space(isl_space_copy(space), 1, ISL_MAP_DISJOINT);\n\tset = isl_set_add_basic_set(set, isl_basic_set_universe(space));\n\treturn set;\n}\n\n__isl_give isl_map *isl_map_dup(__isl_keep isl_map *map)\n{\n\tint i;\n\tstruct isl_map *dup;\n\n\tif (!map)\n\t\treturn NULL;\n\tdup = isl_map_alloc_space(isl_space_copy(map->dim), map->n, map->flags);\n\tfor (i = 0; i < map->n; ++i)\n\t\tdup = isl_map_add_basic_map(dup, isl_basic_map_copy(map->p[i]));\n\treturn dup;\n}\n\n__isl_give isl_map *isl_map_add_basic_map(__isl_take isl_map *map,\n\t\t\t\t\t\t__isl_take isl_basic_map *bmap)\n{\n\tif (!bmap || !map)\n\t\tgoto error;\n\tif (isl_basic_map_plain_is_empty(bmap)) {\n\t\tisl_basic_map_free(bmap);\n\t\treturn map;\n\t}\n\tif (isl_map_basic_map_check_equal_space(map, bmap) < 0)\n\t\tgoto error;\n\tisl_assert(map->ctx, map->n < map->size, goto error);\n\tmap->p[map->n] = bmap;\n\tmap->n++;\n\tmap = isl_map_unmark_normalized(map);\n\treturn map;\nerror:\n\tif (map)\n\t\tisl_map_free(map);\n\tif (bmap)\n\t\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n__isl_null isl_map *isl_map_free(__isl_take isl_map *map)\n{\n\tint i;\n\n\tif (!map)\n\t\treturn NULL;\n\n\tif (--map->ref > 0)\n\t\treturn NULL;\n\n\tclear_caches(map);\n\tisl_ctx_deref(map->ctx);\n\tfor (i = 0; i < map->n; ++i)\n\t\tisl_basic_map_free(map->p[i]);\n\tisl_space_free(map->dim);\n\tfree(map);\n\n\treturn NULL;\n}\n\nstatic __isl_give isl_basic_map *isl_basic_map_fix_pos_si(\n\t__isl_take isl_basic_map *bmap, unsigned pos, int value)\n{\n\tint j;\n\tisl_size total;\n\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tif (total < 0)\n\t\treturn isl_basic_map_free(bmap);\n\n\tbmap = isl_basic_map_cow(bmap);\n\tbmap = isl_basic_map_extend_constraints(bmap, 1, 0);\n\tj = isl_basic_map_alloc_equality(bmap);\n\tif (j < 0)\n\t\tgoto error;\n\tisl_seq_clr(bmap->eq[j] + 1, total);\n\tisl_int_set_si(bmap->eq[j][pos], -1);\n\tisl_int_set_si(bmap->eq[j][0], value);\n\tbmap = isl_basic_map_simplify(bmap);\n\treturn isl_basic_map_finalize(bmap);\nerror:\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\nstatic __isl_give isl_basic_map *isl_basic_map_fix_pos(\n\t__isl_take isl_basic_map *bmap, unsigned pos, isl_int value)\n{\n\tint j;\n\tisl_size total;\n\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tif (total < 0)\n\t\treturn isl_basic_map_free(bmap);\n\n\tbmap = isl_basic_map_cow(bmap);\n\tbmap = isl_basic_map_extend_constraints(bmap, 1, 0);\n\tj = isl_basic_map_alloc_equality(bmap);\n\tif (j < 0)\n\t\tgoto error;\n\tisl_seq_clr(bmap->eq[j] + 1, total);\n\tisl_int_set_si(bmap->eq[j][pos], -1);\n\tisl_int_set(bmap->eq[j][0], value);\n\tbmap = isl_basic_map_simplify(bmap);\n\treturn isl_basic_map_finalize(bmap);\nerror:\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n__isl_give isl_basic_map *isl_basic_map_fix_si(__isl_take isl_basic_map *bmap,\n\t\tenum isl_dim_type type, unsigned pos, int value)\n{\n\tif (isl_basic_map_check_range(bmap, type, pos, 1) < 0)\n\t\treturn isl_basic_map_free(bmap);\n\treturn isl_basic_map_fix_pos_si(bmap,\n\t\tisl_basic_map_offset(bmap, type) + pos, value);\n}\n\n__isl_give isl_basic_map *isl_basic_map_fix(__isl_take isl_basic_map *bmap,\n\t\tenum isl_dim_type type, unsigned pos, isl_int value)\n{\n\tif (isl_basic_map_check_range(bmap, type, pos, 1) < 0)\n\t\treturn isl_basic_map_free(bmap);\n\treturn isl_basic_map_fix_pos(bmap,\n\t\tisl_basic_map_offset(bmap, type) + pos, value);\n}\n\n/* Fix the value of the variable at position \"pos\" of type \"type\" of \"bmap\"\n * to be equal to \"v\".\n */\n__isl_give isl_basic_map *isl_basic_map_fix_val(__isl_take isl_basic_map *bmap,\n\tenum isl_dim_type type, unsigned pos, __isl_take isl_val *v)\n{\n\tif (!bmap || !v)\n\t\tgoto error;\n\tif (!isl_val_is_int(v))\n\t\tisl_die(isl_basic_map_get_ctx(bmap), isl_error_invalid,\n\t\t\t\"expecting integer value\", goto error);\n\tif (isl_basic_map_check_range(bmap, type, pos, 1) < 0)\n\t\tgoto error;\n\tpos += isl_basic_map_offset(bmap, type);\n\tbmap = isl_basic_map_fix_pos(bmap, pos, v->n);\n\tisl_val_free(v);\n\treturn bmap;\nerror:\n\tisl_basic_map_free(bmap);\n\tisl_val_free(v);\n\treturn NULL;\n}\n\n/* Fix the value of the variable at position \"pos\" of type \"type\" of \"bset\"\n * to be equal to \"v\".\n */\n__isl_give isl_basic_set *isl_basic_set_fix_val(__isl_take isl_basic_set *bset,\n\tenum isl_dim_type type, unsigned pos, __isl_take isl_val *v)\n{\n\treturn isl_basic_map_fix_val(bset, type, pos, v);\n}\n\n__isl_give isl_basic_set *isl_basic_set_fix_si(__isl_take isl_basic_set *bset,\n\t\tenum isl_dim_type type, unsigned pos, int value)\n{\n\treturn bset_from_bmap(isl_basic_map_fix_si(bset_to_bmap(bset),\n\t\t\t\t\t\t    type, pos, value));\n}\n\n__isl_give isl_basic_set *isl_basic_set_fix(__isl_take isl_basic_set *bset,\n\t\tenum isl_dim_type type, unsigned pos, isl_int value)\n{\n\treturn bset_from_bmap(isl_basic_map_fix(bset_to_bmap(bset),\n\t\t\t\t\t\t    type, pos, value));\n}\n\n/* Remove the basic map at position \"i\" from \"map\" if this basic map\n * is (obviously) empty.\n */\nstatic __isl_give isl_map *remove_if_empty(__isl_take isl_map *map, int i)\n{\n\tisl_bool empty;\n\n\tif (!map)\n\t\treturn NULL;\n\n\tempty = isl_basic_map_plain_is_empty(map->p[i]);\n\tif (empty < 0)\n\t\treturn isl_map_free(map);\n\tif (!empty)\n\t\treturn map;\n\n\tisl_basic_map_free(map->p[i]);\n\tmap->n--;\n\tif (i != map->n) {\n\t\tmap->p[i] = map->p[map->n];\n\t\tmap = isl_map_unmark_normalized(map);\n\n\t}\n\n\treturn map;\n}\n\n/* Perform \"fn\" on each basic map of \"map\", where we may not be holding\n * the only reference to \"map\".\n * In particular, \"fn\" should be a semantics preserving operation\n * that we want to apply to all copies of \"map\".  We therefore need\n * to be careful not to modify \"map\" in a way that breaks \"map\"\n * in case anything goes wrong.\n */\n__isl_give isl_map *isl_map_inline_foreach_basic_map(__isl_take isl_map *map,\n\t__isl_give isl_basic_map *(*fn)(__isl_take isl_basic_map *bmap))\n{\n\tstruct isl_basic_map *bmap;\n\tint i;\n\n\tif (!map)\n\t\treturn NULL;\n\n\tfor (i = map->n - 1; i >= 0; --i) {\n\t\tbmap = isl_basic_map_copy(map->p[i]);\n\t\tbmap = fn(bmap);\n\t\tif (!bmap)\n\t\t\tgoto error;\n\t\tisl_basic_map_free(map->p[i]);\n\t\tmap->p[i] = bmap;\n\t\tmap = remove_if_empty(map, i);\n\t\tif (!map)\n\t\t\treturn NULL;\n\t}\n\n\treturn map;\nerror:\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n__isl_give isl_map *isl_map_fix_si(__isl_take isl_map *map,\n\t\tenum isl_dim_type type, unsigned pos, int value)\n{\n\tint i;\n\n\tmap = isl_map_cow(map);\n\tif (isl_map_check_range(map, type, pos, 1) < 0)\n\t\treturn isl_map_free(map);\n\tfor (i = map->n - 1; i >= 0; --i) {\n\t\tmap->p[i] = isl_basic_map_fix_si(map->p[i], type, pos, value);\n\t\tmap = remove_if_empty(map, i);\n\t\tif (!map)\n\t\t\treturn NULL;\n\t}\n\tmap = isl_map_unmark_normalized(map);\n\treturn map;\n}\n\n__isl_give isl_set *isl_set_fix_si(__isl_take isl_set *set,\n\t\tenum isl_dim_type type, unsigned pos, int value)\n{\n\treturn set_from_map(isl_map_fix_si(set_to_map(set), type, pos, value));\n}\n\n__isl_give isl_map *isl_map_fix(__isl_take isl_map *map,\n\t\tenum isl_dim_type type, unsigned pos, isl_int value)\n{\n\tint i;\n\n\tmap = isl_map_cow(map);\n\tif (isl_map_check_range(map, type, pos, 1) < 0)\n\t\treturn isl_map_free(map);\n\tfor (i = 0; i < map->n; ++i) {\n\t\tmap->p[i] = isl_basic_map_fix(map->p[i], type, pos, value);\n\t\tif (!map->p[i])\n\t\t\tgoto error;\n\t}\n\tmap = isl_map_unmark_normalized(map);\n\treturn map;\nerror:\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n__isl_give isl_set *isl_set_fix(__isl_take isl_set *set,\n\t\tenum isl_dim_type type, unsigned pos, isl_int value)\n{\n\treturn set_from_map(isl_map_fix(set_to_map(set), type, pos, value));\n}\n\n/* Fix the value of the variable at position \"pos\" of type \"type\" of \"map\"\n * to be equal to \"v\".\n */\n__isl_give isl_map *isl_map_fix_val(__isl_take isl_map *map,\n\tenum isl_dim_type type, unsigned pos, __isl_take isl_val *v)\n{\n\tint i;\n\n\tmap = isl_map_cow(map);\n\tif (!map || !v)\n\t\tgoto error;\n\n\tif (!isl_val_is_int(v))\n\t\tisl_die(isl_map_get_ctx(map), isl_error_invalid,\n\t\t\t\"expecting integer value\", goto error);\n\tif (isl_map_check_range(map, type, pos, 1) < 0)\n\t\tgoto error;\n\tfor (i = map->n - 1; i >= 0; --i) {\n\t\tmap->p[i] = isl_basic_map_fix_val(map->p[i], type, pos,\n\t\t\t\t\t\t\tisl_val_copy(v));\n\t\tmap = remove_if_empty(map, i);\n\t\tif (!map)\n\t\t\tgoto error;\n\t}\n\tmap = isl_map_unmark_normalized(map);\n\tisl_val_free(v);\n\treturn map;\nerror:\n\tisl_map_free(map);\n\tisl_val_free(v);\n\treturn NULL;\n}\n\n/* Fix the value of the variable at position \"pos\" of type \"type\" of \"set\"\n * to be equal to \"v\".\n */\n__isl_give isl_set *isl_set_fix_val(__isl_take isl_set *set,\n\tenum isl_dim_type type, unsigned pos, __isl_take isl_val *v)\n{\n\treturn isl_map_fix_val(set, type, pos, v);\n}\n\n__isl_give isl_map *isl_map_fix_input_si(__isl_take isl_map *map,\n\t\tunsigned input, int value)\n{\n\treturn isl_map_fix_si(map, isl_dim_in, input, value);\n}\n\n__isl_give isl_set *isl_set_fix_dim_si(__isl_take isl_set *set, unsigned dim,\n\tint value)\n{\n\treturn set_from_map(isl_map_fix_si(set_to_map(set),\n\t\t\t\t\t\tisl_dim_set, dim, value));\n}\n\nstatic __isl_give isl_basic_map *basic_map_bound_si(\n\t__isl_take isl_basic_map *bmap,\n\tenum isl_dim_type type, unsigned pos, int value, int upper)\n{\n\tint j;\n\tisl_size total;\n\n\tif (isl_basic_map_check_range(bmap, type, pos, 1) < 0)\n\t\treturn isl_basic_map_free(bmap);\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tif (total < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tpos += isl_basic_map_offset(bmap, type);\n\tbmap = isl_basic_map_cow(bmap);\n\tbmap = isl_basic_map_extend_constraints(bmap, 0, 1);\n\tj = isl_basic_map_alloc_inequality(bmap);\n\tif (j < 0)\n\t\tgoto error;\n\tisl_seq_clr(bmap->ineq[j], 1 + total);\n\tif (upper) {\n\t\tisl_int_set_si(bmap->ineq[j][pos], -1);\n\t\tisl_int_set_si(bmap->ineq[j][0], value);\n\t} else {\n\t\tisl_int_set_si(bmap->ineq[j][pos], 1);\n\t\tisl_int_set_si(bmap->ineq[j][0], -value);\n\t}\n\tbmap = isl_basic_map_simplify(bmap);\n\treturn isl_basic_map_finalize(bmap);\nerror:\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n__isl_give isl_basic_map *isl_basic_map_lower_bound_si(\n\t__isl_take isl_basic_map *bmap,\n\tenum isl_dim_type type, unsigned pos, int value)\n{\n\treturn basic_map_bound_si(bmap, type, pos, value, 0);\n}\n\n/* Constrain the values of the given dimension to be no greater than \"value\".\n */\n__isl_give isl_basic_map *isl_basic_map_upper_bound_si(\n\t__isl_take isl_basic_map *bmap,\n\tenum isl_dim_type type, unsigned pos, int value)\n{\n\treturn basic_map_bound_si(bmap, type, pos, value, 1);\n}\n\nstatic __isl_give isl_map *map_bound_si(__isl_take isl_map *map,\n\tenum isl_dim_type type, unsigned pos, int value, int upper)\n{\n\tint i;\n\n\tmap = isl_map_cow(map);\n\tif (isl_map_check_range(map, type, pos, 1) < 0)\n\t\treturn isl_map_free(map);\n\tfor (i = 0; i < map->n; ++i) {\n\t\tmap->p[i] = basic_map_bound_si(map->p[i],\n\t\t\t\t\t\t type, pos, value, upper);\n\t\tif (!map->p[i])\n\t\t\tgoto error;\n\t}\n\tmap = isl_map_unmark_normalized(map);\n\treturn map;\nerror:\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n__isl_give isl_map *isl_map_lower_bound_si(__isl_take isl_map *map,\n\tenum isl_dim_type type, unsigned pos, int value)\n{\n\treturn map_bound_si(map, type, pos, value, 0);\n}\n\n__isl_give isl_map *isl_map_upper_bound_si(__isl_take isl_map *map,\n\tenum isl_dim_type type, unsigned pos, int value)\n{\n\treturn map_bound_si(map, type, pos, value, 1);\n}\n\n__isl_give isl_set *isl_set_lower_bound_si(__isl_take isl_set *set,\n\t\tenum isl_dim_type type, unsigned pos, int value)\n{\n\treturn set_from_map(isl_map_lower_bound_si(set_to_map(set),\n\t\t\t\t\t\t\ttype, pos, value));\n}\n\n__isl_give isl_set *isl_set_upper_bound_si(__isl_take isl_set *set,\n\tenum isl_dim_type type, unsigned pos, int value)\n{\n\treturn isl_map_upper_bound_si(set, type, pos, value);\n}\n\n/* Bound the given variable of \"bmap\" from below (or above is \"upper\"\n * is set) to \"value\".\n */\nstatic __isl_give isl_basic_map *basic_map_bound(\n\t__isl_take isl_basic_map *bmap,\n\tenum isl_dim_type type, unsigned pos, isl_int value, int upper)\n{\n\tint j;\n\tisl_size total;\n\n\tif (isl_basic_map_check_range(bmap, type, pos, 1) < 0)\n\t\treturn isl_basic_map_free(bmap);\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tif (total < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tpos += isl_basic_map_offset(bmap, type);\n\tbmap = isl_basic_map_cow(bmap);\n\tbmap = isl_basic_map_extend_constraints(bmap, 0, 1);\n\tj = isl_basic_map_alloc_inequality(bmap);\n\tif (j < 0)\n\t\tgoto error;\n\tisl_seq_clr(bmap->ineq[j], 1 + total);\n\tif (upper) {\n\t\tisl_int_set_si(bmap->ineq[j][pos], -1);\n\t\tisl_int_set(bmap->ineq[j][0], value);\n\t} else {\n\t\tisl_int_set_si(bmap->ineq[j][pos], 1);\n\t\tisl_int_neg(bmap->ineq[j][0], value);\n\t}\n\tbmap = isl_basic_map_simplify(bmap);\n\treturn isl_basic_map_finalize(bmap);\nerror:\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n/* Bound the given variable of \"map\" from below (or above is \"upper\"\n * is set) to \"value\".\n */\nstatic __isl_give isl_map *map_bound(__isl_take isl_map *map,\n\tenum isl_dim_type type, unsigned pos, isl_int value, int upper)\n{\n\tint i;\n\n\tmap = isl_map_cow(map);\n\tif (isl_map_check_range(map, type, pos, 1) < 0)\n\t\treturn isl_map_free(map);\n\tfor (i = map->n - 1; i >= 0; --i) {\n\t\tmap->p[i] = basic_map_bound(map->p[i], type, pos, value, upper);\n\t\tmap = remove_if_empty(map, i);\n\t\tif (!map)\n\t\t\treturn NULL;\n\t}\n\tmap = isl_map_unmark_normalized(map);\n\treturn map;\n}\n\n__isl_give isl_map *isl_map_lower_bound(__isl_take isl_map *map,\n\tenum isl_dim_type type, unsigned pos, isl_int value)\n{\n\treturn map_bound(map, type, pos, value, 0);\n}\n\n__isl_give isl_map *isl_map_upper_bound(__isl_take isl_map *map,\n\tenum isl_dim_type type, unsigned pos, isl_int value)\n{\n\treturn map_bound(map, type, pos, value, 1);\n}\n\n__isl_give isl_set *isl_set_lower_bound(__isl_take isl_set *set,\n\tenum isl_dim_type type, unsigned pos, isl_int value)\n{\n\treturn isl_map_lower_bound(set, type, pos, value);\n}\n\n__isl_give isl_set *isl_set_upper_bound(__isl_take isl_set *set,\n\tenum isl_dim_type type, unsigned pos, isl_int value)\n{\n\treturn isl_map_upper_bound(set, type, pos, value);\n}\n\n/* Force the values of the variable at position \"pos\" of type \"type\" of \"map\"\n * to be no smaller than \"value\".\n */\n__isl_give isl_map *isl_map_lower_bound_val(__isl_take isl_map *map,\n\tenum isl_dim_type type, unsigned pos, __isl_take isl_val *value)\n{\n\tif (!value)\n\t\tgoto error;\n\tif (!isl_val_is_int(value))\n\t\tisl_die(isl_map_get_ctx(map), isl_error_invalid,\n\t\t\t\"expecting integer value\", goto error);\n\tmap = isl_map_lower_bound(map, type, pos, value->n);\n\tisl_val_free(value);\n\treturn map;\nerror:\n\tisl_val_free(value);\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n/* Force the values of the variable at position \"pos\" of type \"type\" of \"set\"\n * to be no smaller than \"value\".\n */\n__isl_give isl_set *isl_set_lower_bound_val(__isl_take isl_set *set,\n\tenum isl_dim_type type, unsigned pos, __isl_take isl_val *value)\n{\n\tisl_map *map;\n\n\tmap = set_to_map(set);\n\treturn set_from_map(isl_map_lower_bound_val(map, type, pos, value));\n}\n\n/* Force the values of the variable at position \"pos\" of type \"type\" of \"map\"\n * to be no greater than \"value\".\n */\n__isl_give isl_map *isl_map_upper_bound_val(__isl_take isl_map *map,\n\tenum isl_dim_type type, unsigned pos, __isl_take isl_val *value)\n{\n\tif (!value)\n\t\tgoto error;\n\tif (!isl_val_is_int(value))\n\t\tisl_die(isl_map_get_ctx(map), isl_error_invalid,\n\t\t\t\"expecting integer value\", goto error);\n\tmap = isl_map_upper_bound(map, type, pos, value->n);\n\tisl_val_free(value);\n\treturn map;\nerror:\n\tisl_val_free(value);\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n/* Force the values of the variable at position \"pos\" of type \"type\" of \"set\"\n * to be no greater than \"value\".\n */\n__isl_give isl_set *isl_set_upper_bound_val(__isl_take isl_set *set,\n\tenum isl_dim_type type, unsigned pos, __isl_take isl_val *value)\n{\n\tisl_map *map;\n\n\tmap = set_to_map(set);\n\treturn set_from_map(isl_map_upper_bound_val(map, type, pos, value));\n}\n\n/* If \"mv\" has an explicit domain, then intersect the domain of \"map\"\n * with this explicit domain.\n *\n * An isl_multi_val object never has an explicit domain,\n * so simply return \"map\".\n */\nstatic __isl_give isl_map *isl_map_intersect_multi_val_explicit_domain(\n\t__isl_take isl_map *map, __isl_keep isl_multi_val *mv)\n{\n\treturn map;\n}\n\n#undef BASE\n#define BASE\tval\n#include \"isl_map_bound_templ.c\"\n\n/* Apply \"map_bound\" to \"set\" with the corresponding value in \"bound\"\n * for each set dimension, by treating the set as a map.\n */\nstatic __isl_give isl_set *set_bound_multi_val(__isl_take isl_set *set,\n\t__isl_take isl_multi_val *bound,\n\t__isl_give isl_map *map_bound(__isl_take isl_map *map,\n\t\tunsigned pos, __isl_take isl_val *value))\n{\n\tisl_map *map;\n\n\tmap = set_to_map(set);\n\treturn set_from_map(map_bound_multi_val(map, bound, map_bound));\n}\n\n#undef BASE\n#define BASE\tpw_aff\n#include \"isl_map_bound_templ.c\"\n\n/* Apply \"map_bound\" to \"set\" with the corresponding value in \"bound\"\n * for each set dimension, by converting the set and the bound\n * to objects living in a map space.\n */\nstatic __isl_give isl_set *set_bound_multi_pw_aff(__isl_take isl_set *set,\n\t__isl_take isl_multi_pw_aff *bound,\n\t__isl_give isl_map *set_bound(__isl_take isl_map *map,\n\t\tunsigned pos, __isl_take TYPE *value))\n{\n\tisl_map *map;\n\n\tmap = isl_map_from_range(set);\n\tbound = isl_multi_pw_aff_from_range(bound);\n\tmap = map_bound_multi_pw_aff(map, bound, set_bound);\n\treturn isl_map_range(map);\n}\n\n/* Wrapper around isl_map_lower_bound_val for use in map_bound_multi_val,\n * setting a bound on the given output dimension.\n */\nstatic __isl_give isl_map *map_lower_bound_val(__isl_take isl_map *map,\n\tunsigned pos, __isl_take isl_val *v)\n{\n\treturn isl_map_lower_bound_val(map, isl_dim_out, pos, v);\n}\n\n/* Force the values of the set dimensions of \"set\"\n * to be no smaller than the corresponding values in \"lower\".\n */\n__isl_give isl_set *isl_set_lower_bound_multi_val(__isl_take isl_set *set,\n\t__isl_take isl_multi_val *lower)\n{\n\treturn set_bound_multi_val(set, lower, &map_lower_bound_val);\n}\n\n/* Wrapper around isl_map_upper_bound_val for use in map_bound_multi_val,\n * setting a bound on the given output dimension.\n */\nstatic __isl_give isl_map *map_upper_bound_val(__isl_take isl_map *map,\n\tunsigned pos, __isl_take isl_val *v)\n{\n\treturn isl_map_upper_bound_val(map, isl_dim_out, pos, v);\n}\n\n/* Force the values of the set dimensions of \"set\"\n * to be no greater than the corresponding values in \"upper\".\n */\n__isl_give isl_set *isl_set_upper_bound_multi_val(__isl_take isl_set *set,\n\t__isl_take isl_multi_val *upper)\n{\n\treturn set_bound_multi_val(set, upper, &map_upper_bound_val);\n}\n\n/* Force the symbolic constant expression \"bound\"\n * to satisfy the relation \"order\" with respect to\n * the output variable at position \"pos\" of \"map\".\n *\n * Create an affine expression representing the output variable\n * in terms of the range and\n * compare it using \"order\" to \"bound\" (defined on the domain).\n * The result is a relation between elements in domain and range that\n * can be intersected with \"map\".\n */\nstatic __isl_give isl_map *map_bound_pw_aff(__isl_take isl_map *map,\n\tunsigned pos, __isl_take isl_pw_aff *bound,\n\t__isl_give isl_map *(*order)(__isl_take isl_pw_aff *pa1,\n\t\t__isl_take isl_pw_aff *pa2))\n{\n\tisl_space *space;\n\tisl_local_space *ls;\n\tisl_pw_aff *var;\n\n\tspace = isl_space_range(isl_map_get_space(map));\n\tls = isl_local_space_from_space(space);\n\tvar = isl_pw_aff_var_on_domain(ls, isl_dim_set, pos);\n\tmap = isl_map_intersect(map, order(bound, var));\n\treturn map;\n}\n\n/* Force the values of the output variable at position \"pos\" of \"map\"\n * to be no smaller than the symbolic constant expression \"lower\".\n */\nstatic __isl_give isl_map *map_lower_bound_pw_aff(__isl_take isl_map *map,\n\tunsigned pos, __isl_take isl_pw_aff *lower)\n{\n\treturn map_bound_pw_aff(map, pos, lower, &isl_pw_aff_le_map);\n}\n\n/* Force the values of the output variable at position \"pos\" of \"map\"\n * to be no greater than the symbolic constant expression \"upper\".\n */\nstatic __isl_give isl_map *map_upper_bound_pw_aff(__isl_take isl_map *map,\n\tunsigned pos, __isl_take isl_pw_aff *upper)\n{\n\treturn map_bound_pw_aff(map, pos, upper, &isl_pw_aff_ge_map);\n}\n\n/* Force the values of the set dimensions of \"set\"\n * to be no smaller than the corresponding constant symbolic expressions\n * in \"lower\".\n */\n__isl_give isl_set *isl_set_lower_bound_multi_pw_aff(__isl_take isl_set *set,\n\t__isl_take isl_multi_pw_aff *lower)\n{\n\treturn set_bound_multi_pw_aff(set, lower, &map_lower_bound_pw_aff);\n}\n\n/* Force the values of the set dimensions of \"set\"\n * to be no greater than the corresponding constant symbolic expressions\n * in \"upper\".\n */\n__isl_give isl_set *isl_set_upper_bound_multi_pw_aff(__isl_take isl_set *set,\n\t__isl_take isl_multi_pw_aff *upper)\n{\n\treturn set_bound_multi_pw_aff(set, upper, &map_upper_bound_pw_aff);\n}\n\n/* Force the values of the output dimensions of \"map\"\n * to be no smaller than the corresponding constant symbolic expressions\n * in \"lower\".\n */\n__isl_give isl_map *isl_map_lower_bound_multi_pw_aff(__isl_take isl_map *map,\n\t__isl_take isl_multi_pw_aff *lower)\n{\n\treturn map_bound_multi_pw_aff(map, lower, &map_lower_bound_pw_aff);\n}\n\n/* Force the values of the output dimensions of \"map\"\n * to be no greater than the corresponding constant symbolic expressions\n * in \"upper\".\n */\n__isl_give isl_map *isl_map_upper_bound_multi_pw_aff(__isl_take isl_map *map,\n\t__isl_take isl_multi_pw_aff *upper)\n{\n\treturn map_bound_multi_pw_aff(map, upper, &map_upper_bound_pw_aff);\n}\n\n/* Bound the given variable of \"bset\" from below (or above is \"upper\"\n * is set) to \"value\".\n */\nstatic __isl_give isl_basic_set *isl_basic_set_bound(\n\t__isl_take isl_basic_set *bset, enum isl_dim_type type, unsigned pos,\n\tisl_int value, int upper)\n{\n\treturn bset_from_bmap(basic_map_bound(bset_to_bmap(bset),\n\t\t\t\t\t\ttype, pos, value, upper));\n}\n\n/* Bound the given variable of \"bset\" from below (or above is \"upper\"\n * is set) to \"value\".\n */\nstatic __isl_give isl_basic_set *isl_basic_set_bound_val(\n\t__isl_take isl_basic_set *bset, enum isl_dim_type type, unsigned pos,\n\t__isl_take isl_val *value, int upper)\n{\n\tif (!value)\n\t\tgoto error;\n\tif (!isl_val_is_int(value))\n\t\tisl_die(isl_basic_set_get_ctx(bset), isl_error_invalid,\n\t\t\t\"expecting integer value\", goto error);\n\tbset = isl_basic_set_bound(bset, type, pos, value->n, upper);\n\tisl_val_free(value);\n\treturn bset;\nerror:\n\tisl_val_free(value);\n\tisl_basic_set_free(bset);\n\treturn NULL;\n}\n\n/* Bound the given variable of \"bset\" from below to \"value\".\n */\n__isl_give isl_basic_set *isl_basic_set_lower_bound_val(\n\t__isl_take isl_basic_set *bset, enum isl_dim_type type, unsigned pos,\n\t__isl_take isl_val *value)\n{\n\treturn isl_basic_set_bound_val(bset, type, pos, value, 0);\n}\n\n/* Bound the given variable of \"bset\" from above to \"value\".\n */\n__isl_give isl_basic_set *isl_basic_set_upper_bound_val(\n\t__isl_take isl_basic_set *bset, enum isl_dim_type type, unsigned pos,\n\t__isl_take isl_val *value)\n{\n\treturn isl_basic_set_bound_val(bset, type, pos, value, 1);\n}\n\n__isl_give isl_map *isl_map_reverse(__isl_take isl_map *map)\n{\n\treturn isl_map_transform(map, &isl_space_reverse,\n\t\t\t\t\t&isl_basic_map_reverse);\n}\n\n/* Given a map A -> (B -> C), return the corresponding map A -> (C -> B).\n */\n__isl_give isl_map *isl_map_range_reverse(__isl_take isl_map *map)\n{\n\treturn isl_map_transform(map, &isl_space_range_reverse,\n\t\t\t\t\t&isl_basic_map_range_reverse);\n}\n\n#undef TYPE\n#define TYPE\tisl_pw_multi_aff\n#undef SUFFIX\n#define SUFFIX\t_pw_multi_aff\n#undef EMPTY\n#define EMPTY\tisl_pw_multi_aff_empty\n#undef ADD\n#define ADD\tisl_pw_multi_aff_union_add\n#include \"isl_map_lexopt_templ.c\"\n\n/* Given a map \"map\", compute the lexicographically minimal\n * (or maximal) image element for each domain element in dom,\n * in the form of an isl_pw_multi_aff.\n * If \"empty\" is not NULL, then set *empty to those elements in dom that\n * do not have an image element.\n * If \"flags\" includes ISL_OPT_FULL, then \"dom\" is NULL and the optimum\n * should be computed over the domain of \"map\".  \"empty\" is also NULL\n * in this case.\n *\n * We first compute the lexicographically minimal or maximal element\n * in the first basic map.  This results in a partial solution \"res\"\n * and a subset \"todo\" of dom that still need to be handled.\n * We then consider each of the remaining maps in \"map\" and successively\n * update both \"res\" and \"todo\".\n * If \"empty\" is NULL, then the todo sets are not needed and therefore\n * also not computed.\n */\nstatic __isl_give isl_pw_multi_aff *isl_map_partial_lexopt_aligned_pw_multi_aff(\n\t__isl_take isl_map *map, __isl_take isl_set *dom,\n\t__isl_give isl_set **empty, unsigned flags)\n{\n\tint i;\n\tint full;\n\tisl_pw_multi_aff *res;\n\tisl_set *todo;\n\n\tfull = ISL_FL_ISSET(flags, ISL_OPT_FULL);\n\tif (!map || (!full && !dom))\n\t\tgoto error;\n\n\tif (isl_map_plain_is_empty(map)) {\n\t\tif (empty)\n\t\t\t*empty = dom;\n\t\telse\n\t\t\tisl_set_free(dom);\n\t\treturn isl_pw_multi_aff_from_map(map);\n\t}\n\n\tres = basic_map_partial_lexopt_pw_multi_aff(\n\t\t\t\t\t    isl_basic_map_copy(map->p[0]),\n\t\t\t\t\t    isl_set_copy(dom), empty, flags);\n\n\tif (empty)\n\t\ttodo = *empty;\n\tfor (i = 1; i < map->n; ++i) {\n\t\tisl_pw_multi_aff *res_i;\n\n\t\tres_i = basic_map_partial_lexopt_pw_multi_aff(\n\t\t\t\t\t    isl_basic_map_copy(map->p[i]),\n\t\t\t\t\t    isl_set_copy(dom), empty, flags);\n\n\t\tif (ISL_FL_ISSET(flags, ISL_OPT_MAX))\n\t\t\tres = isl_pw_multi_aff_union_lexmax(res, res_i);\n\t\telse\n\t\t\tres = isl_pw_multi_aff_union_lexmin(res, res_i);\n\n\t\tif (empty)\n\t\t\ttodo = isl_set_intersect(todo, *empty);\n\t}\n\n\tisl_set_free(dom);\n\tisl_map_free(map);\n\n\tif (empty)\n\t\t*empty = todo;\n\n\treturn res;\nerror:\n\tif (empty)\n\t\t*empty = NULL;\n\tisl_set_free(dom);\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n#undef TYPE\n#define TYPE\tisl_map\n#undef SUFFIX\n#define SUFFIX\n#undef EMPTY\n#define EMPTY\tisl_map_empty\n#undef ADD\n#define ADD\tisl_map_union_disjoint\n#include \"isl_map_lexopt_templ.c\"\n\n/* Given a map \"map\", compute the lexicographically minimal\n * (or maximal) image element for each domain element in \"dom\",\n * in the form of an isl_map.\n * If \"empty\" is not NULL, then set *empty to those elements in \"dom\" that\n * do not have an image element.\n * If \"flags\" includes ISL_OPT_FULL, then \"dom\" is NULL and the optimum\n * should be computed over the domain of \"map\".  \"empty\" is also NULL\n * in this case.\n *\n * If the input consists of more than one disjunct, then first\n * compute the desired result in the form of an isl_pw_multi_aff and\n * then convert that into an isl_map.\n *\n * This function used to have an explicit implementation in terms\n * of isl_maps, but it would continually intersect the domains of\n * partial results with the complement of the domain of the next\n * partial solution, potentially leading to an explosion in the number\n * of disjuncts if there are several disjuncts in the input.\n * An even earlier implementation of this function would look for\n * better results in the domain of the partial result and for extra\n * results in the complement of this domain, which would lead to\n * even more splintering.\n */\nstatic __isl_give isl_map *isl_map_partial_lexopt_aligned(\n\t__isl_take isl_map *map, __isl_take isl_set *dom,\n\t__isl_give isl_set **empty, unsigned flags)\n{\n\tint full;\n\tstruct isl_map *res;\n\tisl_pw_multi_aff *pma;\n\n\tfull = ISL_FL_ISSET(flags, ISL_OPT_FULL);\n\tif (!map || (!full && !dom))\n\t\tgoto error;\n\n\tif (isl_map_plain_is_empty(map)) {\n\t\tif (empty)\n\t\t\t*empty = dom;\n\t\telse\n\t\t\tisl_set_free(dom);\n\t\treturn map;\n\t}\n\n\tif (map->n == 1) {\n\t\tres = basic_map_partial_lexopt(isl_basic_map_copy(map->p[0]),\n\t\t\t\t\t\tdom, empty, flags);\n\t\tisl_map_free(map);\n\t\treturn res;\n\t}\n\n\tpma = isl_map_partial_lexopt_aligned_pw_multi_aff(map, dom, empty,\n\t\t\t\t\t\t\tflags);\n\treturn isl_map_from_pw_multi_aff_internal(pma);\nerror:\n\tif (empty)\n\t\t*empty = NULL;\n\tisl_set_free(dom);\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n__isl_give isl_map *isl_map_partial_lexmax(\n\t\t__isl_take isl_map *map, __isl_take isl_set *dom,\n\t\t__isl_give isl_set **empty)\n{\n\treturn isl_map_partial_lexopt(map, dom, empty, ISL_OPT_MAX);\n}\n\n__isl_give isl_map *isl_map_partial_lexmin(\n\t\t__isl_take isl_map *map, __isl_take isl_set *dom,\n\t\t__isl_give isl_set **empty)\n{\n\treturn isl_map_partial_lexopt(map, dom, empty, 0);\n}\n\n__isl_give isl_set *isl_set_partial_lexmin(\n\t\t__isl_take isl_set *set, __isl_take isl_set *dom,\n\t\t__isl_give isl_set **empty)\n{\n\treturn set_from_map(isl_map_partial_lexmin(set_to_map(set),\n\t\t\t\t\t\t    dom, empty));\n}\n\n__isl_give isl_set *isl_set_partial_lexmax(\n\t\t__isl_take isl_set *set, __isl_take isl_set *dom,\n\t\t__isl_give isl_set **empty)\n{\n\treturn set_from_map(isl_map_partial_lexmax(set_to_map(set),\n\t\t\t\t\t\t    dom, empty));\n}\n\n/* Compute the lexicographic minimum (or maximum if \"flags\" includes\n * ISL_OPT_MAX) of \"bset\" over its parametric domain.\n */\n__isl_give isl_set *isl_basic_set_lexopt(__isl_take isl_basic_set *bset,\n\tunsigned flags)\n{\n\treturn isl_basic_map_lexopt(bset, flags);\n}\n\n__isl_give isl_map *isl_basic_map_lexmax(__isl_take isl_basic_map *bmap)\n{\n\treturn isl_basic_map_lexopt(bmap, ISL_OPT_MAX);\n}\n\n__isl_give isl_set *isl_basic_set_lexmin(__isl_take isl_basic_set *bset)\n{\n\treturn set_from_map(isl_basic_map_lexmin(bset_to_bmap(bset)));\n}\n\n__isl_give isl_set *isl_basic_set_lexmax(__isl_take isl_basic_set *bset)\n{\n\treturn set_from_map(isl_basic_map_lexmax(bset_to_bmap(bset)));\n}\n\n/* Compute the lexicographic minimum of \"bset\" over its parametric domain\n * for the purpose of quantifier elimination.\n * That is, find an explicit representation for all the existentially\n * quantified variables in \"bset\" by computing their lexicographic\n * minimum.\n */\nstatic __isl_give isl_set *isl_basic_set_lexmin_compute_divs(\n\t__isl_take isl_basic_set *bset)\n{\n\treturn isl_basic_set_lexopt(bset, ISL_OPT_QE);\n}\n\n/* Given a basic map with one output dimension, compute the minimum or\n * maximum of that dimension as an isl_pw_aff.\n *\n * Compute the optimum as a lexicographic optimum over the single\n * output dimension and extract the single isl_pw_aff from the result.\n */\nstatic __isl_give isl_pw_aff *basic_map_dim_opt(__isl_keep isl_basic_map *bmap,\n\tint max)\n{\n\tisl_pw_multi_aff *pma;\n\tisl_pw_aff *pwaff;\n\n\tbmap = isl_basic_map_copy(bmap);\n\tpma = isl_basic_map_lexopt_pw_multi_aff(bmap, max ? ISL_OPT_MAX : 0);\n\tpwaff = isl_pw_multi_aff_get_pw_aff(pma, 0);\n\tisl_pw_multi_aff_free(pma);\n\n\treturn pwaff;\n}\n\n/* Compute the minimum or maximum of the given output dimension\n * as a function of the parameters and the input dimensions,\n * but independently of the other output dimensions.\n *\n * We first project out the other output dimension and then compute\n * the \"lexicographic\" maximum in each basic map, combining the results\n * using isl_pw_aff_union_max.\n */\nstatic __isl_give isl_pw_aff *map_dim_opt(__isl_take isl_map *map, int pos,\n\tint max)\n{\n\tint i;\n\tisl_pw_aff *pwaff;\n\tisl_size n_out;\n\n\tn_out = isl_map_dim(map, isl_dim_out);\n\tif (n_out < 0)\n\t\tmap = isl_map_free(map);\n\tmap = isl_map_project_out(map, isl_dim_out, pos + 1, n_out - (pos + 1));\n\tmap = isl_map_project_out(map, isl_dim_out, 0, pos);\n\tif (!map)\n\t\treturn NULL;\n\n\tif (map->n == 0) {\n\t\tisl_space *space = isl_map_get_space(map);\n\t\tisl_map_free(map);\n\t\treturn isl_pw_aff_empty(space);\n\t}\n\n\tpwaff = basic_map_dim_opt(map->p[0], max);\n\tfor (i = 1; i < map->n; ++i) {\n\t\tisl_pw_aff *pwaff_i;\n\n\t\tpwaff_i = basic_map_dim_opt(map->p[i], max);\n\t\tpwaff = isl_pw_aff_union_opt(pwaff, pwaff_i, max);\n\t}\n\n\tisl_map_free(map);\n\n\treturn pwaff;\n}\n\n/* Compute the minimum of the given output dimension as a function of the\n * parameters and input dimensions, but independently of\n * the other output dimensions.\n */\n__isl_give isl_pw_aff *isl_map_dim_min(__isl_take isl_map *map, int pos)\n{\n\treturn map_dim_opt(map, pos, 0);\n}\n\n/* Compute the maximum of the given output dimension as a function of the\n * parameters and input dimensions, but independently of\n * the other output dimensions.\n */\n__isl_give isl_pw_aff *isl_map_dim_max(__isl_take isl_map *map, int pos)\n{\n\treturn map_dim_opt(map, pos, 1);\n}\n\n/* Compute the minimum or maximum of the given set dimension\n * as a function of the parameters,\n * but independently of the other set dimensions.\n */\nstatic __isl_give isl_pw_aff *set_dim_opt(__isl_take isl_set *set, int pos,\n\tint max)\n{\n\treturn map_dim_opt(set, pos, max);\n}\n\n/* Compute the maximum of the given set dimension as a function of the\n * parameters, but independently of the other set dimensions.\n */\n__isl_give isl_pw_aff *isl_set_dim_max(__isl_take isl_set *set, int pos)\n{\n\treturn set_dim_opt(set, pos, 1);\n}\n\n/* Compute the minimum of the given set dimension as a function of the\n * parameters, but independently of the other set dimensions.\n */\n__isl_give isl_pw_aff *isl_set_dim_min(__isl_take isl_set *set, int pos)\n{\n\treturn set_dim_opt(set, pos, 0);\n}\n\n/* Apply a preimage specified by \"mat\" on the parameters of \"bset\".\n * bset is assumed to have only parameters and divs.\n */\nstatic __isl_give isl_basic_set *basic_set_parameter_preimage(\n\t__isl_take isl_basic_set *bset, __isl_take isl_mat *mat)\n{\n\tisl_size nparam;\n\n\tnparam = isl_basic_set_dim(bset, isl_dim_param);\n\tif (nparam < 0 || !mat)\n\t\tgoto error;\n\n\tbset->dim = isl_space_cow(bset->dim);\n\tif (!bset->dim)\n\t\tgoto error;\n\n\tisl_assert(bset->ctx, mat->n_row == 1 + nparam, goto error);\n\n\tbset->dim->nparam = 0;\n\tbset->dim->n_out = nparam;\n\tbset = isl_basic_set_preimage(bset, mat);\n\tif (bset) {\n\t\tbset->dim->nparam = bset->dim->n_out;\n\t\tbset->dim->n_out = 0;\n\t}\n\treturn bset;\nerror:\n\tisl_mat_free(mat);\n\tisl_basic_set_free(bset);\n\treturn NULL;\n}\n\n/* Apply a preimage specified by \"mat\" on the parameters of \"set\".\n * set is assumed to have only parameters and divs.\n */\nstatic __isl_give isl_set *set_parameter_preimage(__isl_take isl_set *set,\n\t__isl_take isl_mat *mat)\n{\n\tisl_space *space;\n\tisl_size nparam;\n\n\tnparam = isl_set_dim(set, isl_dim_param);\n\tif (nparam < 0 || !mat)\n\t\tgoto error;\n\n\tif (mat->n_row != 1 + nparam)\n\t\tisl_die(isl_set_get_ctx(set), isl_error_internal,\n\t\t\t\"unexpected number of rows\", goto error);\n\n\tspace = isl_set_get_space(set);\n\tspace = isl_space_move_dims(space, isl_dim_set, 0,\n\t\t\t\t    isl_dim_param, 0, nparam);\n\tset = isl_set_reset_space(set, space);\n\tset = isl_set_preimage(set, mat);\n\tnparam = isl_set_dim(set, isl_dim_out);\n\tif (nparam < 0)\n\t\tset = isl_set_free(set);\n\tspace = isl_set_get_space(set);\n\tspace = isl_space_move_dims(space, isl_dim_param, 0,\n\t\t\t\t    isl_dim_out, 0, nparam);\n\tset = isl_set_reset_space(set, space);\n\treturn set;\nerror:\n\tisl_mat_free(mat);\n\tisl_set_free(set);\n\treturn NULL;\n}\n\n/* Intersect the basic set \"bset\" with the affine space specified by the\n * equalities in \"eq\".\n */\nstatic __isl_give isl_basic_set *basic_set_append_equalities(\n\t__isl_take isl_basic_set *bset, __isl_take isl_mat *eq)\n{\n\tint i, k;\n\tunsigned len;\n\n\tif (!bset || !eq)\n\t\tgoto error;\n\n\tbset = isl_basic_set_extend(bset, 0, eq->n_row, 0);\n\tif (!bset)\n\t\tgoto error;\n\n\tlen = isl_basic_set_offset(bset, isl_dim_div) + bset->extra;\n\tfor (i = 0; i < eq->n_row; ++i) {\n\t\tk = isl_basic_set_alloc_equality(bset);\n\t\tif (k < 0)\n\t\t\tgoto error;\n\t\tisl_seq_cpy(bset->eq[k], eq->row[i], eq->n_col);\n\t\tisl_seq_clr(bset->eq[k] + eq->n_col, len - eq->n_col);\n\t}\n\tisl_mat_free(eq);\n\n\tbset = isl_basic_set_gauss(bset, NULL);\n\tbset = isl_basic_set_finalize(bset);\n\n\treturn bset;\nerror:\n\tisl_mat_free(eq);\n\tisl_basic_set_free(bset);\n\treturn NULL;\n}\n\n/* Intersect the set \"set\" with the affine space specified by the\n * equalities in \"eq\".\n */\nstatic __isl_give isl_set *set_append_equalities(__isl_take isl_set *set,\n\t__isl_take isl_mat *eq)\n{\n\tint i;\n\n\tif (!set || !eq)\n\t\tgoto error;\n\n\tfor (i = 0; i < set->n; ++i) {\n\t\tset->p[i] = basic_set_append_equalities(set->p[i],\n\t\t\t\t\tisl_mat_copy(eq));\n\t\tif (!set->p[i])\n\t\t\tgoto error;\n\t}\n\tisl_mat_free(eq);\n\treturn set;\nerror:\n\tisl_mat_free(eq);\n\tisl_set_free(set);\n\treturn NULL;\n}\n\n/* Given a basic set \"bset\" that only involves parameters and existentially\n * quantified variables, return the index of the first equality\n * that only involves parameters.  If there is no such equality then\n * return bset->n_eq.\n *\n * This function assumes that isl_basic_set_gauss has been called on \"bset\".\n */\nstatic int first_parameter_equality(__isl_keep isl_basic_set *bset)\n{\n\tint i, j;\n\tisl_size nparam, n_div;\n\n\tnparam = isl_basic_set_dim(bset, isl_dim_param);\n\tn_div = isl_basic_set_dim(bset, isl_dim_div);\n\tif (nparam < 0 || n_div < 0)\n\t\treturn -1;\n\n\tfor (i = 0, j = n_div - 1; i < bset->n_eq && j >= 0; --j) {\n\t\tif (!isl_int_is_zero(bset->eq[i][1 + nparam + j]))\n\t\t\t++i;\n\t}\n\n\treturn i;\n}\n\n/* Compute an explicit representation for the existentially quantified\n * variables in \"bset\" by computing the \"minimal value\" of the set\n * variables.  Since there are no set variables, the computation of\n * the minimal value essentially computes an explicit representation\n * of the non-empty part(s) of \"bset\".\n *\n * The input only involves parameters and existentially quantified variables.\n * All equalities among parameters have been removed.\n *\n * Since the existentially quantified variables in the result are in general\n * going to be different from those in the input, we first replace\n * them by the minimal number of variables based on their equalities.\n * This should simplify the parametric integer programming.\n */\nstatic __isl_give isl_set *base_compute_divs(__isl_take isl_basic_set *bset)\n{\n\tisl_morph *morph1, *morph2;\n\tisl_set *set;\n\tisl_size n;\n\n\tif (!bset)\n\t\treturn NULL;\n\tif (bset->n_eq == 0)\n\t\treturn isl_basic_set_lexmin_compute_divs(bset);\n\n\tmorph1 = isl_basic_set_parameter_compression(bset);\n\tbset = isl_morph_basic_set(isl_morph_copy(morph1), bset);\n\tbset = isl_basic_set_lift(bset);\n\tmorph2 = isl_basic_set_variable_compression(bset, isl_dim_set);\n\tbset = isl_morph_basic_set(morph2, bset);\n\tn = isl_basic_set_dim(bset, isl_dim_set);\n\tif (n < 0)\n\t\tbset = isl_basic_set_free(bset);\n\tbset = isl_basic_set_project_out(bset, isl_dim_set, 0, n);\n\n\tset = isl_basic_set_lexmin_compute_divs(bset);\n\n\tset = isl_morph_set(isl_morph_inverse(morph1), set);\n\n\treturn set;\n}\n\n/* Project the given basic set onto its parameter domain, possibly introducing\n * new, explicit, existential variables in the constraints.\n * The input has parameters and (possibly implicit) existential variables.\n * The output has the same parameters, but only\n * explicit existentially quantified variables.\n *\n * The actual projection is performed by pip, but pip doesn't seem\n * to like equalities very much, so we first remove the equalities\n * among the parameters by performing a variable compression on\n * the parameters.  Afterward, an inverse transformation is performed\n * and the equalities among the parameters are inserted back in.\n *\n * The variable compression on the parameters may uncover additional\n * equalities that were only implicit before.  We therefore check\n * if there are any new parameter equalities in the result and\n * if so recurse.  The removal of parameter equalities is required\n * for the parameter compression performed by base_compute_divs.\n */\nstatic __isl_give isl_set *parameter_compute_divs(\n\t__isl_take isl_basic_set *bset)\n{\n\tint i;\n\tstruct isl_mat *eq;\n\tstruct isl_mat *T, *T2;\n\tstruct isl_set *set;\n\tisl_size nparam;\n\n\tbset = isl_basic_set_cow(bset);\n\tif (!bset)\n\t\treturn NULL;\n\n\tif (bset->n_eq == 0)\n\t\treturn base_compute_divs(bset);\n\n\tbset = isl_basic_set_gauss(bset, NULL);\n\tif (!bset)\n\t\treturn NULL;\n\tif (isl_basic_set_plain_is_empty(bset))\n\t\treturn isl_set_from_basic_set(bset);\n\n\ti = first_parameter_equality(bset);\n\tif (i == bset->n_eq)\n\t\treturn base_compute_divs(bset);\n\n\tnparam = isl_basic_set_dim(bset, isl_dim_param);\n\tif (nparam < 0)\n\t\treturn isl_set_from_basic_set(isl_basic_set_free(bset));\n\teq = isl_mat_sub_alloc6(bset->ctx, bset->eq, i, bset->n_eq - i,\n\t\t0, 1 + nparam);\n\teq = isl_mat_cow(eq);\n\tT = isl_mat_variable_compression(isl_mat_copy(eq), &T2);\n\tif (T && T->n_col == 0) {\n\t\tisl_mat_free(T);\n\t\tisl_mat_free(T2);\n\t\tisl_mat_free(eq);\n\t\tbset = isl_basic_set_set_to_empty(bset);\n\t\treturn isl_set_from_basic_set(bset);\n\t}\n\tbset = basic_set_parameter_preimage(bset, T);\n\n\ti = first_parameter_equality(bset);\n\tif (!bset)\n\t\tset = NULL;\n\telse if (i == bset->n_eq)\n\t\tset = base_compute_divs(bset);\n\telse\n\t\tset = parameter_compute_divs(bset);\n\tset = set_parameter_preimage(set, T2);\n\tset = set_append_equalities(set, eq);\n\treturn set;\n}\n\n/* Insert the divs from \"ls\" before those of \"bmap\".\n *\n * The number of columns is not changed, which means that the last\n * dimensions of \"bmap\" are being reintepreted as the divs from \"ls\".\n * The caller is responsible for removing the same number of dimensions\n * from the space of \"bmap\".\n */\nstatic __isl_give isl_basic_map *insert_divs_from_local_space(\n\t__isl_take isl_basic_map *bmap, __isl_keep isl_local_space *ls)\n{\n\tint i;\n\tisl_size n_div;\n\tint old_n_div;\n\n\tn_div = isl_local_space_dim(ls, isl_dim_div);\n\tif (n_div < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tif (n_div == 0)\n\t\treturn bmap;\n\n\told_n_div = bmap->n_div;\n\tbmap = insert_div_rows(bmap, n_div);\n\tif (!bmap)\n\t\treturn NULL;\n\n\tfor (i = 0; i < n_div; ++i) {\n\t\tisl_seq_cpy(bmap->div[i], ls->div->row[i], ls->div->n_col);\n\t\tisl_seq_clr(bmap->div[i] + ls->div->n_col, old_n_div);\n\t}\n\n\treturn bmap;\n}\n\n/* Replace the space of \"bmap\" by the space and divs of \"ls\".\n *\n * If \"ls\" has any divs, then we simplify the result since we may\n * have discovered some additional equalities that could simplify\n * the div expressions.\n */\nstatic __isl_give isl_basic_map *basic_replace_space_by_local_space(\n\t__isl_take isl_basic_map *bmap, __isl_take isl_local_space *ls)\n{\n\tisl_size n_div;\n\n\tbmap = isl_basic_map_cow(bmap);\n\tn_div = isl_local_space_dim(ls, isl_dim_div);\n\tif (!bmap || n_div < 0)\n\t\tgoto error;\n\n\tbmap = insert_divs_from_local_space(bmap, ls);\n\tif (!bmap)\n\t\tgoto error;\n\n\tisl_space_free(bmap->dim);\n\tbmap->dim = isl_local_space_get_space(ls);\n\tif (!bmap->dim)\n\t\tgoto error;\n\n\tisl_local_space_free(ls);\n\tif (n_div > 0)\n\t\tbmap = isl_basic_map_simplify(bmap);\n\tbmap = isl_basic_map_finalize(bmap);\n\treturn bmap;\nerror:\n\tisl_basic_map_free(bmap);\n\tisl_local_space_free(ls);\n\treturn NULL;\n}\n\n/* Replace the space of \"map\" by the space and divs of \"ls\".\n */\nstatic __isl_give isl_map *replace_space_by_local_space(__isl_take isl_map *map,\n\t__isl_take isl_local_space *ls)\n{\n\tint i;\n\n\tmap = isl_map_cow(map);\n\tif (!map || !ls)\n\t\tgoto error;\n\n\tfor (i = 0; i < map->n; ++i) {\n\t\tmap->p[i] = basic_replace_space_by_local_space(map->p[i],\n\t\t\t\t\t\t    isl_local_space_copy(ls));\n\t\tif (!map->p[i])\n\t\t\tgoto error;\n\t}\n\tisl_space_free(isl_map_take_space(map));\n\tmap = isl_map_restore_space(map, isl_local_space_get_space(ls));\n\n\tisl_local_space_free(ls);\n\treturn map;\nerror:\n\tisl_local_space_free(ls);\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n/* Compute an explicit representation for the existentially\n * quantified variables for which do not know any explicit representation yet.\n *\n * We first sort the existentially quantified variables so that the\n * existentially quantified variables for which we already have an explicit\n * representation are placed before those for which we do not.\n * The input dimensions, the output dimensions and the existentially\n * quantified variables for which we already have an explicit\n * representation are then turned into parameters.\n * compute_divs returns a map with the same parameters and\n * no input or output dimensions and the dimension specification\n * is reset to that of the input, including the existentially quantified\n * variables for which we already had an explicit representation.\n */\nstatic __isl_give isl_map *compute_divs(__isl_take isl_basic_map *bmap)\n{\n\tstruct isl_basic_set *bset;\n\tstruct isl_set *set;\n\tstruct isl_map *map;\n\tisl_space *space;\n\tisl_local_space *ls;\n\tisl_size nparam;\n\tisl_size n_in;\n\tisl_size n_out;\n\tint n_known;\n\tint i;\n\n\tbmap = isl_basic_map_sort_divs(bmap);\n\tbmap = isl_basic_map_cow(bmap);\n\tif (!bmap)\n\t\treturn NULL;\n\n\tn_known = isl_basic_map_first_unknown_div(bmap);\n\tnparam = isl_basic_map_dim(bmap, isl_dim_param);\n\tn_in = isl_basic_map_dim(bmap, isl_dim_in);\n\tn_out = isl_basic_map_dim(bmap, isl_dim_out);\n\tif (n_known < 0 || nparam < 0 || n_in < 0 || n_out < 0)\n\t\treturn isl_map_from_basic_map(isl_basic_map_free(bmap));\n\n\tspace = isl_space_set_alloc(bmap->ctx,\n\t\t\t\t    nparam + n_in + n_out + n_known, 0);\n\tif (!space)\n\t\tgoto error;\n\n\tls = isl_basic_map_get_local_space(bmap);\n\tls = isl_local_space_drop_dims(ls, isl_dim_div,\n\t\t\t\t\tn_known, bmap->n_div - n_known);\n\tif (n_known > 0) {\n\t\tfor (i = n_known; i < bmap->n_div; ++i)\n\t\t\tswap_div(bmap, i - n_known, i);\n\t\tbmap->n_div -= n_known;\n\t\tbmap->extra -= n_known;\n\t}\n\tbmap = isl_basic_map_reset_space(bmap, space);\n\tbset = bset_from_bmap(bmap);\n\n\tset = parameter_compute_divs(bset);\n\tmap = set_to_map(set);\n\tmap = replace_space_by_local_space(map, ls);\n\n\treturn map;\nerror:\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n/* Remove the explicit representation of local variable \"div\",\n * if there is any.\n */\n__isl_give isl_basic_map *isl_basic_map_mark_div_unknown(\n\t__isl_take isl_basic_map *bmap, int div)\n{\n\tisl_bool unknown;\n\n\tunknown = isl_basic_map_div_is_marked_unknown(bmap, div);\n\tif (unknown < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tif (unknown)\n\t\treturn bmap;\n\n\tbmap = isl_basic_map_cow(bmap);\n\tif (!bmap)\n\t\treturn NULL;\n\tisl_int_set_si(bmap->div[div][0], 0);\n\treturn bmap;\n}\n\n/* Is local variable \"div\" of \"bmap\" marked as not having an explicit\n * representation?\n * Note that even if \"div\" is not marked in this way and therefore\n * has an explicit representation, this representation may still\n * depend (indirectly) on other local variables that do not\n * have an explicit representation.\n */\nisl_bool isl_basic_map_div_is_marked_unknown(__isl_keep isl_basic_map *bmap,\n\tint div)\n{\n\tif (isl_basic_map_check_range(bmap, isl_dim_div, div, 1) < 0)\n\t\treturn isl_bool_error;\n\treturn isl_int_is_zero(bmap->div[div][0]);\n}\n\n/* Return the position of the first local variable that does not\n * have an explicit representation.\n * Return the total number of local variables if they all have\n * an explicit representation.\n * Return -1 on error.\n */\nint isl_basic_map_first_unknown_div(__isl_keep isl_basic_map *bmap)\n{\n\tint i;\n\n\tif (!bmap)\n\t\treturn -1;\n\n\tfor (i = 0; i < bmap->n_div; ++i) {\n\t\tif (!isl_basic_map_div_is_known(bmap, i))\n\t\t\treturn i;\n\t}\n\treturn bmap->n_div;\n}\n\n/* Return the position of the first local variable that does not\n * have an explicit representation.\n * Return the total number of local variables if they all have\n * an explicit representation.\n * Return -1 on error.\n */\nint isl_basic_set_first_unknown_div(__isl_keep isl_basic_set *bset)\n{\n\treturn isl_basic_map_first_unknown_div(bset);\n}\n\n/* Does \"bmap\" have an explicit representation for all local variables?\n */\nisl_bool isl_basic_map_divs_known(__isl_keep isl_basic_map *bmap)\n{\n\tint first;\n\tisl_size n;\n\n\tn = isl_basic_map_dim(bmap, isl_dim_div);\n\tfirst = isl_basic_map_first_unknown_div(bmap);\n\tif (n < 0 || first < 0)\n\t\treturn isl_bool_error;\n\treturn first == n;\n}\n\n/* Do all basic maps in \"map\" have an explicit representation\n * for all local variables?\n */\nisl_bool isl_map_divs_known(__isl_keep isl_map *map)\n{\n\tint i;\n\n\tif (!map)\n\t\treturn isl_bool_error;\n\n\tfor (i = 0; i < map->n; ++i) {\n\t\tint known = isl_basic_map_divs_known(map->p[i]);\n\t\tif (known <= 0)\n\t\t\treturn known;\n\t}\n\n\treturn isl_bool_true;\n}\n\n/* If bmap contains any unknown divs, then compute explicit\n * expressions for them.  However, this computation may be\n * quite expensive, so first try to remove divs that aren't\n * strictly needed.\n */\n__isl_give isl_map *isl_basic_map_compute_divs(__isl_take isl_basic_map *bmap)\n{\n\tint known;\n\tstruct isl_map *map;\n\n\tknown = isl_basic_map_divs_known(bmap);\n\tif (known < 0)\n\t\tgoto error;\n\tif (known)\n\t\treturn isl_map_from_basic_map(bmap);\n\n\tbmap = isl_basic_map_drop_redundant_divs(bmap);\n\n\tknown = isl_basic_map_divs_known(bmap);\n\tif (known < 0)\n\t\tgoto error;\n\tif (known)\n\t\treturn isl_map_from_basic_map(bmap);\n\n\tmap = compute_divs(bmap);\n\treturn map;\nerror:\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n__isl_give isl_map *isl_map_compute_divs(__isl_take isl_map *map)\n{\n\tint i;\n\tint known;\n\tstruct isl_map *res;\n\n\tif (!map)\n\t\treturn NULL;\n\tif (map->n == 0)\n\t\treturn map;\n\n\tknown = isl_map_divs_known(map);\n\tif (known < 0) {\n\t\tisl_map_free(map);\n\t\treturn NULL;\n\t}\n\tif (known)\n\t\treturn map;\n\n\tres = isl_basic_map_compute_divs(isl_basic_map_copy(map->p[0]));\n\tfor (i = 1 ; i < map->n; ++i) {\n\t\tstruct isl_map *r2;\n\t\tr2 = isl_basic_map_compute_divs(isl_basic_map_copy(map->p[i]));\n\t\tif (ISL_F_ISSET(map, ISL_MAP_DISJOINT))\n\t\t\tres = isl_map_union_disjoint(res, r2);\n\t\telse\n\t\t\tres = isl_map_union(res, r2);\n\t}\n\tisl_map_free(map);\n\n\treturn res;\n}\n\n__isl_give isl_set *isl_basic_set_compute_divs(__isl_take isl_basic_set *bset)\n{\n\treturn set_from_map(isl_basic_map_compute_divs(bset_to_bmap(bset)));\n}\n\n__isl_give isl_set *isl_set_compute_divs(__isl_take isl_set *set)\n{\n\treturn set_from_map(isl_map_compute_divs(set_to_map(set)));\n}\n\n__isl_give isl_set *isl_map_domain(__isl_take isl_map *map)\n{\n\tisl_space *space;\n\tisl_size n_out;\n\n\tn_out = isl_map_dim(map, isl_dim_out);\n\tif (n_out < 0)\n\t\treturn set_from_map(isl_map_free(map));\n\tspace = isl_space_domain(isl_map_get_space(map));\n\n\tmap = isl_map_project_out(map, isl_dim_out, 0, n_out);\n\n\treturn set_from_map(isl_map_reset_space(map, space));\n}\n\n/* Return the union of \"map1\" and \"map2\", where we assume for now that\n * \"map1\" and \"map2\" are disjoint.  Note that the basic maps inside\n * \"map1\" or \"map2\" may not be disjoint from each other.\n * Also note that this function is also called from isl_map_union,\n * which takes care of handling the situation where \"map1\" and \"map2\"\n * may not be disjoint.\n *\n * If one of the inputs is empty, we can simply return the other input.\n * Similarly, if one of the inputs is universal, then it is equal to the union.\n */\nstatic __isl_give isl_map *map_union_disjoint(__isl_take isl_map *map1,\n\t__isl_take isl_map *map2)\n{\n\tint i;\n\tunsigned flags = 0;\n\tstruct isl_map *map = NULL;\n\tint is_universe;\n\n\tif (isl_map_check_equal_space(map1, map2) < 0)\n\t\tgoto error;\n\n\tif (map1->n == 0) {\n\t\tisl_map_free(map1);\n\t\treturn map2;\n\t}\n\tif (map2->n == 0) {\n\t\tisl_map_free(map2);\n\t\treturn map1;\n\t}\n\n\tis_universe = isl_map_plain_is_universe(map1);\n\tif (is_universe < 0)\n\t\tgoto error;\n\tif (is_universe) {\n\t\tisl_map_free(map2);\n\t\treturn map1;\n\t}\n\n\tis_universe = isl_map_plain_is_universe(map2);\n\tif (is_universe < 0)\n\t\tgoto error;\n\tif (is_universe) {\n\t\tisl_map_free(map1);\n\t\treturn map2;\n\t}\n\n\tif (ISL_F_ISSET(map1, ISL_MAP_DISJOINT) &&\n\t    ISL_F_ISSET(map2, ISL_MAP_DISJOINT))\n\t\tISL_FL_SET(flags, ISL_MAP_DISJOINT);\n\n\tmap = isl_map_alloc_space(isl_space_copy(map1->dim),\n\t\t\t\tmap1->n + map2->n, flags);\n\tif (!map)\n\t\tgoto error;\n\tfor (i = 0; i < map1->n; ++i) {\n\t\tmap = isl_map_add_basic_map(map,\n\t\t\t\t  isl_basic_map_copy(map1->p[i]));\n\t\tif (!map)\n\t\t\tgoto error;\n\t}\n\tfor (i = 0; i < map2->n; ++i) {\n\t\tmap = isl_map_add_basic_map(map,\n\t\t\t\t  isl_basic_map_copy(map2->p[i]));\n\t\tif (!map)\n\t\t\tgoto error;\n\t}\n\tisl_map_free(map1);\n\tisl_map_free(map2);\n\treturn map;\nerror:\n\tisl_map_free(map);\n\tisl_map_free(map1);\n\tisl_map_free(map2);\n\treturn NULL;\n}\n\n/* Return the union of \"map1\" and \"map2\", where \"map1\" and \"map2\" are\n * guaranteed to be disjoint by the caller.\n *\n * Note that this functions is called from within isl_map_make_disjoint,\n * so we have to be careful not to touch the constraints of the inputs\n * in any way.\n */\n__isl_give isl_map *isl_map_union_disjoint(__isl_take isl_map *map1,\n\t__isl_take isl_map *map2)\n{\n\tisl_map_align_params_bin(&map1, &map2);\n\treturn map_union_disjoint(map1, map2);\n}\n\n/* Return the union of \"map1\" and \"map2\", where \"map1\" and \"map2\" may\n * not be disjoint.\n *\n * We currently simply call map_union_disjoint, the internal operation\n * of which does not really depend on the inputs being disjoint.\n * If the result contains more than one basic map, then we clear\n * the disjoint flag since the result may contain basic maps from\n * both inputs and these are not guaranteed to be disjoint.\n *\n * As a special case, if \"map1\" and \"map2\" are obviously equal,\n * then we simply return \"map1\".\n */\n__isl_give isl_map *isl_map_union(__isl_take isl_map *map1,\n\t__isl_take isl_map *map2)\n{\n\tint equal;\n\n\tif (isl_map_align_params_bin(&map1, &map2) < 0)\n\t\tgoto error;\n\n\tequal = isl_map_plain_is_equal(map1, map2);\n\tif (equal < 0)\n\t\tgoto error;\n\tif (equal) {\n\t\tisl_map_free(map2);\n\t\treturn map1;\n\t}\n\n\tmap1 = map_union_disjoint(map1, map2);\n\tif (!map1)\n\t\treturn NULL;\n\tif (map1->n > 1)\n\t\tISL_F_CLR(map1, ISL_MAP_DISJOINT);\n\treturn map1;\nerror:\n\tisl_map_free(map1);\n\tisl_map_free(map2);\n\treturn NULL;\n}\n\n__isl_give isl_set *isl_set_union_disjoint(\n\t__isl_take isl_set *set1, __isl_take isl_set *set2)\n{\n\treturn set_from_map(isl_map_union_disjoint(set_to_map(set1),\n\t\t\t\t\t\t    set_to_map(set2)));\n}\n\n__isl_give isl_set *isl_set_union(__isl_take isl_set *set1,\n\t__isl_take isl_set *set2)\n{\n\treturn set_from_map(isl_map_union(set_to_map(set1), set_to_map(set2)));\n}\n\n/* Apply \"fn\" to pairs of elements from \"map\" and \"set\" and collect\n * the results in a map living in \"space\".\n *\n * \"map\" and \"set\" are assumed to be compatible and non-NULL.\n */\nstatic __isl_give isl_map *map_intersect_set(__isl_take isl_map *map,\n\t__isl_take isl_space *space, __isl_take isl_set *set,\n\t__isl_give isl_basic_map *fn(__isl_take isl_basic_map *bmap,\n\t\t__isl_take isl_basic_set *bset))\n{\n\tunsigned flags = 0;\n\tstruct isl_map *result;\n\tint i, j;\n\n\tif (isl_set_plain_is_universe(set)) {\n\t\tisl_set_free(set);\n\t\treturn isl_map_reset_equal_dim_space(map, space);\n\t}\n\n\tif (ISL_F_ISSET(map, ISL_MAP_DISJOINT) &&\n\t    ISL_F_ISSET(set, ISL_MAP_DISJOINT))\n\t\tISL_FL_SET(flags, ISL_MAP_DISJOINT);\n\n\tresult = isl_map_alloc_space(space, map->n * set->n, flags);\n\tfor (i = 0; result && i < map->n; ++i)\n\t\tfor (j = 0; j < set->n; ++j) {\n\t\t\tresult = isl_map_add_basic_map(result,\n\t\t\t\t\tfn(isl_basic_map_copy(map->p[i]),\n\t\t\t\t\t    isl_basic_set_copy(set->p[j])));\n\t\t\tif (!result)\n\t\t\t\tbreak;\n\t\t}\n\n\tisl_map_free(map);\n\tisl_set_free(set);\n\treturn result;\n}\n\n__isl_give isl_map *isl_map_intersect_range(__isl_take isl_map *map,\n\t__isl_take isl_set *set)\n{\n\tisl_bool ok;\n\tisl_space *space;\n\n\tisl_map_align_params_set(&map, &set);\n\tok = isl_map_compatible_range(map, set);\n\tif (ok < 0)\n\t\tgoto error;\n\tif (!ok)\n\t\tisl_die(set->ctx, isl_error_invalid,\n\t\t\t\"incompatible spaces\", goto error);\n\n\tspace = isl_map_get_space(map);\n\treturn map_intersect_set(map, space, set,\n\t\t\t\t&isl_basic_map_intersect_range);\nerror:\n\tisl_map_free(map);\n\tisl_set_free(set);\n\treturn NULL;\n}\n\n/* Intersect the domain of \"map\" with \"set\".\n *\n * If the domain dimensions of \"map\" do not have any identifiers,\n * then copy them over from \"set\".\n */\n__isl_give isl_map *isl_map_intersect_domain(__isl_take isl_map *map,\n\t__isl_take isl_set *set)\n{\n\tisl_bool ok;\n\tisl_space *space;\n\n\tisl_map_align_params_set(&map, &set);\n\tok = isl_map_compatible_domain(map, set);\n\tif (ok < 0)\n\t\tgoto error;\n\tif (!ok)\n\t\tisl_die(set->ctx, isl_error_invalid,\n\t\t\t\"incompatible spaces\", goto error);\n\n\tspace = isl_map_get_space(map);\n\tspace = isl_space_copy_ids_if_unset(space, isl_dim_in,\n\t\t\t\t\tisl_set_peek_space(set), isl_dim_set);\n\treturn map_intersect_set(map, space, set,\n\t\t\t\t&isl_basic_map_intersect_domain);\nerror:\n\tisl_map_free(map);\n\tisl_set_free(set);\n\treturn NULL;\n}\n\n#undef TYPE\n#define TYPE isl_map\nstatic\n#include \"isl_copy_tuple_id_templ.c\"\n\n/* Data structure that specifies how isl_map_intersect_factor\n * should operate.\n *\n * \"preserve_type\" is the tuple where the factor differs from\n * the input map and of which the identifiers needs\n * to be preserved explicitly.\n * \"other_factor\" is used to extract the space of the other factor\n * from the space of the product (\"map\").\n * \"product\" is used to combine the given factor and a universe map\n * in the space returned by \"other_factor\" to produce a map\n * that lives in the same space as the input map.\n */\nstruct isl_intersect_factor_control {\n\tenum isl_dim_type preserve_type;\n\t__isl_give isl_space *(*other_factor)(__isl_take isl_space *space);\n\t__isl_give isl_map *(*product)(__isl_take isl_map *factor,\n\t\t__isl_take isl_map *other);\n};\n\n/* Given a map \"map\" in some product space and a map \"factor\"\n * living in some factor space, return the intersection.\n *\n * After aligning the parameters,\n * the map \"factor\" is first extended to a map living in the same space\n * as \"map\" and then a regular intersection is computed.\n *\n * Note that the extension is computed as a product, which is anonymous\n * by default.  If \"map\" has an identifier on the corresponding tuple,\n * then this identifier needs to be set on the product\n * before the intersection is computed.\n */\nstatic __isl_give isl_map *isl_map_intersect_factor(\n\t__isl_take isl_map *map, __isl_take isl_map *factor,\n\tstruct isl_intersect_factor_control *control)\n{\n\tisl_bool equal;\n\tisl_space *space;\n\tisl_map *other, *product;\n\n\tequal = isl_map_has_equal_params(map, factor);\n\tif (equal < 0)\n\t\tgoto error;\n\tif (!equal) {\n\t\tmap = isl_map_align_params(map, isl_map_get_space(factor));\n\t\tfactor = isl_map_align_params(factor, isl_map_get_space(map));\n\t}\n\n\tspace = isl_map_get_space(map);\n\tother = isl_map_universe(control->other_factor(space));\n\tproduct = control->product(factor, other);\n\n\tspace = isl_map_peek_space(map);\n\tproduct = isl_map_copy_tuple_id(product, control->preserve_type,\n\t\t\t\t\tspace, control->preserve_type);\n\treturn map_intersect(map, product);\nerror:\n\tisl_map_free(map);\n\tisl_map_free(factor);\n\treturn NULL;\n}\n\n/* Return the domain product of \"map2\" and \"map1\".\n */\nstatic __isl_give isl_map *isl_map_reverse_domain_product(\n\t__isl_take isl_map *map1, __isl_take isl_map *map2)\n{\n\treturn isl_map_domain_product(map2, map1);\n}\n\n/* Return the range product of \"map2\" and \"map1\".\n */\nstatic __isl_give isl_map *isl_map_reverse_range_product(\n\t__isl_take isl_map *map1, __isl_take isl_map *map2)\n{\n\treturn isl_map_range_product(map2, map1);\n}\n\n/* Given a map \"map\" in a space [A -> B] -> C and a map \"factor\"\n * in the space A -> C, return the intersection.\n */\n__isl_give isl_map *isl_map_intersect_domain_factor_domain(\n\t__isl_take isl_map *map, __isl_take isl_map *factor)\n{\n\tstruct isl_intersect_factor_control control = {\n\t\t.preserve_type = isl_dim_in,\n\t\t.other_factor = isl_space_domain_factor_range,\n\t\t.product = isl_map_domain_product,\n\t};\n\n\treturn isl_map_intersect_factor(map, factor, &control);\n}\n\n/* Given a map \"map\" in a space [A -> B] -> C and a map \"factor\"\n * in the space B -> C, return the intersection.\n */\n__isl_give isl_map *isl_map_intersect_domain_factor_range(\n\t__isl_take isl_map *map, __isl_take isl_map *factor)\n{\n\tstruct isl_intersect_factor_control control = {\n\t\t.preserve_type = isl_dim_in,\n\t\t.other_factor = isl_space_domain_factor_domain,\n\t\t.product = isl_map_reverse_domain_product,\n\t};\n\n\treturn isl_map_intersect_factor(map, factor, &control);\n}\n\n/* Given a map \"map\" in a space A -> [B -> C] and a map \"factor\"\n * in the space A -> B, return the intersection.\n */\n__isl_give isl_map *isl_map_intersect_range_factor_domain(\n\t__isl_take isl_map *map, __isl_take isl_map *factor)\n{\n\tstruct isl_intersect_factor_control control = {\n\t\t.preserve_type = isl_dim_out,\n\t\t.other_factor = isl_space_range_factor_range,\n\t\t.product = isl_map_range_product,\n\t};\n\n\treturn isl_map_intersect_factor(map, factor, &control);\n}\n\n/* Given a map \"map\" in a space A -> [B -> C] and a map \"factor\"\n * in the space A -> C, return the intersection.\n */\n__isl_give isl_map *isl_map_intersect_range_factor_range(\n\t__isl_take isl_map *map, __isl_take isl_map *factor)\n{\n\tstruct isl_intersect_factor_control control = {\n\t\t.preserve_type = isl_dim_out,\n\t\t.other_factor = isl_space_range_factor_domain,\n\t\t.product = isl_map_reverse_range_product,\n\t};\n\n\treturn isl_map_intersect_factor(map, factor, &control);\n}\n\n/* Given a set \"set\" in a space [A -> B] and a set \"domain\"\n * in the space A, return the intersection.\n *\n * The set \"domain\" is first extended to a set living in the space\n * [A -> B] and then a regular intersection is computed.\n */\n__isl_give isl_set *isl_set_intersect_factor_domain(__isl_take isl_set *set,\n\t__isl_take isl_set *domain)\n{\n\tstruct isl_intersect_factor_control control = {\n\t\t.preserve_type = isl_dim_set,\n\t\t.other_factor = isl_space_factor_range,\n\t\t.product = isl_map_range_product,\n\t};\n\n\treturn set_from_map(isl_map_intersect_factor(set_to_map(set),\n\t\t\t\t\t\tset_to_map(domain), &control));\n}\n\n/* Given a set \"set\" in a space [A -> B] and a set \"range\"\n * in the space B, return the intersection.\n *\n * The set \"range\" is first extended to a set living in the space\n * [A -> B] and then a regular intersection is computed.\n */\n__isl_give isl_set *isl_set_intersect_factor_range(__isl_take isl_set *set,\n\t__isl_take isl_set *range)\n{\n\tstruct isl_intersect_factor_control control = {\n\t\t.preserve_type = isl_dim_set,\n\t\t.other_factor = isl_space_factor_domain,\n\t\t.product = isl_map_reverse_range_product,\n\t};\n\n\treturn set_from_map(isl_map_intersect_factor(set_to_map(set),\n\t\t\t\t\t\tset_to_map(range), &control));\n}\n\n__isl_give isl_map *isl_map_apply_domain(__isl_take isl_map *map1,\n\t__isl_take isl_map *map2)\n{\n\tif (isl_map_align_params_bin(&map1, &map2) < 0)\n\t\tgoto error;\n\tmap1 = isl_map_reverse(map1);\n\tmap1 = isl_map_apply_range(map1, map2);\n\treturn isl_map_reverse(map1);\nerror:\n\tisl_map_free(map1);\n\tisl_map_free(map2);\n\treturn NULL;\n}\n\n__isl_give isl_map *isl_map_apply_range(__isl_take isl_map *map1,\n\t__isl_take isl_map *map2)\n{\n\tisl_space *space;\n\tstruct isl_map *result;\n\tint i, j;\n\n\tif (isl_map_align_params_bin(&map1, &map2) < 0)\n\t\tgoto error;\n\n\tspace = isl_space_join(isl_space_copy(map1->dim),\n\t\t\t\t  isl_space_copy(map2->dim));\n\n\tresult = isl_map_alloc_space(space, map1->n * map2->n, 0);\n\tif (!result)\n\t\tgoto error;\n\tfor (i = 0; i < map1->n; ++i)\n\t\tfor (j = 0; j < map2->n; ++j) {\n\t\t\tresult = isl_map_add_basic_map(result,\n\t\t\t    isl_basic_map_apply_range(\n\t\t\t\tisl_basic_map_copy(map1->p[i]),\n\t\t\t\tisl_basic_map_copy(map2->p[j])));\n\t\t\tif (!result)\n\t\t\t\tgoto error;\n\t\t}\n\tisl_map_free(map1);\n\tisl_map_free(map2);\n\tif (result && result->n <= 1)\n\t\tISL_F_SET(result, ISL_MAP_DISJOINT);\n\treturn result;\nerror:\n\tisl_map_free(map1);\n\tisl_map_free(map2);\n\treturn NULL;\n}\n\n/* Is \"bmap\" a transformation, i.e.,\n * does it relate elements from the same space.\n */\nisl_bool isl_basic_map_is_transformation(__isl_keep isl_basic_map *bmap)\n{\n\tisl_space *space;\n\n\tspace = isl_basic_map_peek_space(bmap);\n\treturn isl_space_tuple_is_equal(space, isl_dim_in, space, isl_dim_out);\n}\n\n/* Check that \"bmap\" is a transformation, i.e.,\n * that it relates elements from the same space.\n */\nstatic isl_stat isl_basic_map_check_transformation(\n\t__isl_keep isl_basic_map *bmap)\n{\n\tisl_bool equal;\n\n\tequal = isl_basic_map_is_transformation(bmap);\n\tif (equal < 0)\n\t\treturn isl_stat_error;\n\tif (!equal)\n\t\tisl_die(isl_basic_map_get_ctx(bmap), isl_error_invalid,\n\t\t\t\"domain and range don't match\", return isl_stat_error);\n\treturn isl_stat_ok;\n}\n\n/*\n * returns range - domain\n */\n__isl_give isl_basic_set *isl_basic_map_deltas(__isl_take isl_basic_map *bmap)\n{\n\tisl_space *target_space;\n\tstruct isl_basic_set *bset;\n\tisl_size dim;\n\tisl_size nparam;\n\tisl_size total;\n\tint i;\n\n\tif (isl_basic_map_check_transformation(bmap) < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tdim = isl_basic_map_dim(bmap, isl_dim_in);\n\tnparam = isl_basic_map_dim(bmap, isl_dim_param);\n\tif (dim < 0 || nparam < 0)\n\t\tgoto error;\n\ttarget_space = isl_space_domain(isl_basic_map_get_space(bmap));\n\tbmap = isl_basic_map_from_range(isl_basic_map_wrap(bmap));\n\tbmap = isl_basic_map_add_dims(bmap, isl_dim_in, dim);\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tif (total < 0)\n\t\tbmap = isl_basic_map_free(bmap);\n\tbmap = isl_basic_map_extend_constraints(bmap, dim, 0);\n\tfor (i = 0; i < dim; ++i) {\n\t\tint j = isl_basic_map_alloc_equality(bmap);\n\t\tif (j < 0) {\n\t\t\tbmap = isl_basic_map_free(bmap);\n\t\t\tbreak;\n\t\t}\n\t\tisl_seq_clr(bmap->eq[j], 1 + total);\n\t\tisl_int_set_si(bmap->eq[j][1+nparam+i], 1);\n\t\tisl_int_set_si(bmap->eq[j][1+nparam+dim+i], 1);\n\t\tisl_int_set_si(bmap->eq[j][1+nparam+2*dim+i], -1);\n\t}\n\tbset = isl_basic_map_domain(bmap);\n\tbset = isl_basic_set_reset_space(bset, target_space);\n\treturn bset;\nerror:\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n/* Is the tuple of type \"type1\" of \"map\" the same as\n * the tuple of type \"type2\" of \"space\"?\n */\nisl_bool isl_map_space_tuple_is_equal(__isl_keep isl_map *map,\n\tenum isl_dim_type type1, __isl_keep isl_space *space,\n\tenum isl_dim_type type2)\n{\n\tisl_space *map_space;\n\n\tmap_space = isl_map_peek_space(map);\n\treturn isl_space_tuple_is_equal(map_space, type1, space, type2);\n}\n\n/* Is the tuple of type \"type1\" of \"map1\" the same as\n * the tuple of type \"type2\" of \"map2\"?\n */\nisl_bool isl_map_tuple_is_equal(__isl_keep isl_map *map1,\n\tenum isl_dim_type type1, __isl_keep isl_map *map2,\n\tenum isl_dim_type type2)\n{\n\tisl_space *space1, *space2;\n\n\tspace1 = isl_map_peek_space(map1);\n\tspace2 = isl_map_peek_space(map2);\n\treturn isl_space_tuple_is_equal(space1, type1, space2, type2);\n}\n\n/* Is the space of \"obj\" equal to \"space\", ignoring parameters?\n */\nisl_bool isl_map_has_space_tuples(__isl_keep isl_map *map,\n\t__isl_keep isl_space *space)\n{\n\tisl_space *map_space;\n\n\tmap_space = isl_map_peek_space(map);\n\treturn isl_space_has_equal_tuples(map_space, space);\n}\n\n/* Check that \"map\" is a transformation, i.e.,\n * that it relates elements from the same space.\n */\nisl_stat isl_map_check_transformation(__isl_keep isl_map *map)\n{\n\tisl_bool equal;\n\n\tequal = isl_map_tuple_is_equal(map, isl_dim_in, map, isl_dim_out);\n\tif (equal < 0)\n\t\treturn isl_stat_error;\n\tif (!equal)\n\t\tisl_die(isl_map_get_ctx(map), isl_error_invalid,\n\t\t\t\"domain and range don't match\", return isl_stat_error);\n\treturn isl_stat_ok;\n}\n\n/*\n * returns range - domain\n */\n__isl_give isl_set *isl_map_deltas(__isl_take isl_map *map)\n{\n\tint i;\n\tisl_space *space;\n\tstruct isl_set *result;\n\n\tif (isl_map_check_transformation(map) < 0)\n\t\tgoto error;\n\tspace = isl_map_get_space(map);\n\tspace = isl_space_domain(space);\n\tresult = isl_set_alloc_space(space, map->n, 0);\n\tif (!result)\n\t\tgoto error;\n\tfor (i = 0; i < map->n; ++i)\n\t\tresult = isl_set_add_basic_set(result,\n\t\t\t  isl_basic_map_deltas(isl_basic_map_copy(map->p[i])));\n\tisl_map_free(map);\n\treturn result;\nerror:\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n/*\n * returns [domain -> range] -> range - domain\n */\n__isl_give isl_basic_map *isl_basic_map_deltas_map(\n\t__isl_take isl_basic_map *bmap)\n{\n\tint i, k;\n\tisl_space *space;\n\tisl_basic_map *domain;\n\tisl_size nparam, n;\n\tisl_size total;\n\n\tif (isl_basic_map_check_transformation(bmap) < 0)\n\t\treturn isl_basic_map_free(bmap);\n\n\tnparam = isl_basic_map_dim(bmap, isl_dim_param);\n\tn = isl_basic_map_dim(bmap, isl_dim_in);\n\tif (nparam < 0 || n < 0)\n\t\treturn isl_basic_map_free(bmap);\n\n\tspace = isl_basic_map_get_space(bmap);\n\tspace = isl_space_from_range(isl_space_domain(space));\n\tdomain = isl_basic_map_universe(space);\n\n\tbmap = isl_basic_map_from_domain(isl_basic_map_wrap(bmap));\n\tbmap = isl_basic_map_apply_range(bmap, domain);\n\tbmap = isl_basic_map_extend_constraints(bmap, n, 0);\n\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tif (total < 0)\n\t\treturn isl_basic_map_free(bmap);\n\n\tfor (i = 0; i < n; ++i) {\n\t\tk = isl_basic_map_alloc_equality(bmap);\n\t\tif (k < 0)\n\t\t\tgoto error;\n\t\tisl_seq_clr(bmap->eq[k], 1 + total);\n\t\tisl_int_set_si(bmap->eq[k][1 + nparam + i], 1);\n\t\tisl_int_set_si(bmap->eq[k][1 + nparam + n + i], -1);\n\t\tisl_int_set_si(bmap->eq[k][1 + nparam + n + n + i], 1);\n\t}\n\n\tbmap = isl_basic_map_gauss(bmap, NULL);\n\treturn isl_basic_map_finalize(bmap);\nerror:\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n/*\n * returns [domain -> range] -> range - domain\n */\n__isl_give isl_map *isl_map_deltas_map(__isl_take isl_map *map)\n{\n\tif (isl_map_check_transformation(map) < 0)\n\t\treturn isl_map_free(map);\n\n\treturn isl_map_transform(map, &isl_space_range_map,\n\t\t\t\t\t&isl_basic_map_deltas_map);\n}\n\n/* Return pairs of elements { x -> y } such that y - x is in \"deltas\".\n */\n__isl_give isl_map *isl_set_translation(__isl_take isl_set *deltas)\n{\n\tisl_space *space;\n\tisl_map *map;\n\n\tspace = isl_space_map_from_set(isl_set_get_space(deltas));\n\tmap = isl_map_deltas_map(isl_map_universe(space));\n\tmap = isl_map_intersect_range(map, deltas);\n\n\treturn isl_set_unwrap(isl_map_domain(map));\n}\n\n__isl_give isl_basic_map *isl_basic_map_identity(__isl_take isl_space *space)\n{\n\tisl_size n_in, n_out;\n\n\tn_in = isl_space_dim(space, isl_dim_in);\n\tn_out = isl_space_dim(space, isl_dim_out);\n\tif (n_in < 0 || n_out < 0)\n\t\tgoto error;\n\tif (n_in != n_out)\n\t\tisl_die(space->ctx, isl_error_invalid,\n\t\t\t\"number of input and output dimensions needs to be \"\n\t\t\t\"the same\", goto error);\n\treturn isl_basic_map_equal(space, n_in);\nerror:\n\tisl_space_free(space);\n\treturn NULL;\n}\n\n__isl_give isl_map *isl_map_identity(__isl_take isl_space *space)\n{\n\treturn isl_map_from_basic_map(isl_basic_map_identity(space));\n}\n\n__isl_give isl_map *isl_set_identity(__isl_take isl_set *set)\n{\n\tisl_space *space = isl_set_get_space(set);\n\tisl_map *id;\n\tid = isl_map_identity(isl_space_map_from_set(space));\n\treturn isl_map_intersect_range(id, set);\n}\n\n/* Construct a basic set with all set dimensions having only non-negative\n * values.\n */\n__isl_give isl_basic_set *isl_basic_set_positive_orthant(\n\t__isl_take isl_space *space)\n{\n\tint i;\n\tisl_size nparam;\n\tisl_size dim;\n\tisl_size total;\n\tstruct isl_basic_set *bset;\n\n\tnparam = isl_space_dim(space, isl_dim_param);\n\tdim = isl_space_dim(space, isl_dim_set);\n\ttotal = isl_space_dim(space, isl_dim_all);\n\tif (nparam < 0 || dim < 0 || total < 0)\n\t\tspace = isl_space_free(space);\n\tbset = isl_basic_set_alloc_space(space, 0, 0, dim);\n\tif (!bset)\n\t\treturn NULL;\n\tfor (i = 0; i < dim; ++i) {\n\t\tint k = isl_basic_set_alloc_inequality(bset);\n\t\tif (k < 0)\n\t\t\tgoto error;\n\t\tisl_seq_clr(bset->ineq[k], 1 + total);\n\t\tisl_int_set_si(bset->ineq[k][1 + nparam + i], 1);\n\t}\n\treturn bset;\nerror:\n\tisl_basic_set_free(bset);\n\treturn NULL;\n}\n\n/* Construct the half-space x_pos >= 0.\n */\nstatic __isl_give isl_basic_set *nonneg_halfspace(__isl_take isl_space *space,\n\tint pos)\n{\n\tint k;\n\tisl_size total;\n\tisl_basic_set *nonneg;\n\n\ttotal = isl_space_dim(space, isl_dim_all);\n\tif (total < 0)\n\t\tspace = isl_space_free(space);\n\tnonneg = isl_basic_set_alloc_space(space, 0, 0, 1);\n\tk = isl_basic_set_alloc_inequality(nonneg);\n\tif (k < 0)\n\t\tgoto error;\n\tisl_seq_clr(nonneg->ineq[k], 1 + total);\n\tisl_int_set_si(nonneg->ineq[k][pos], 1);\n\n\treturn isl_basic_set_finalize(nonneg);\nerror:\n\tisl_basic_set_free(nonneg);\n\treturn NULL;\n}\n\n/* Construct the half-space x_pos <= -1.\n */\nstatic __isl_give isl_basic_set *neg_halfspace(__isl_take isl_space *space,\n\tint pos)\n{\n\tint k;\n\tisl_size total;\n\tisl_basic_set *neg;\n\n\ttotal = isl_space_dim(space, isl_dim_all);\n\tif (total < 0)\n\t\tspace = isl_space_free(space);\n\tneg = isl_basic_set_alloc_space(space, 0, 0, 1);\n\tk = isl_basic_set_alloc_inequality(neg);\n\tif (k < 0)\n\t\tgoto error;\n\tisl_seq_clr(neg->ineq[k], 1 + total);\n\tisl_int_set_si(neg->ineq[k][0], -1);\n\tisl_int_set_si(neg->ineq[k][pos], -1);\n\n\treturn isl_basic_set_finalize(neg);\nerror:\n\tisl_basic_set_free(neg);\n\treturn NULL;\n}\n\n__isl_give isl_set *isl_set_split_dims(__isl_take isl_set *set,\n\tenum isl_dim_type type, unsigned first, unsigned n)\n{\n\tint i;\n\tunsigned offset;\n\tisl_basic_set *nonneg;\n\tisl_basic_set *neg;\n\n\tif (n == 0)\n\t\treturn set;\n\n\tif (isl_set_check_range(set, type, first, n) < 0)\n\t\treturn isl_set_free(set);\n\n\toffset = pos(set->dim, type);\n\tfor (i = 0; i < n; ++i) {\n\t\tnonneg = nonneg_halfspace(isl_set_get_space(set),\n\t\t\t\t\t  offset + first + i);\n\t\tneg = neg_halfspace(isl_set_get_space(set), offset + first + i);\n\n\t\tset = isl_set_intersect(set, isl_basic_set_union(nonneg, neg));\n\t}\n\n\treturn set;\n}\n\nstatic isl_stat foreach_orthant(__isl_take isl_set *set, int *signs, int first,\n\tint len,\n\tisl_stat (*fn)(__isl_take isl_set *orthant, int *signs, void *user),\n\tvoid *user)\n{\n\tisl_set *half;\n\n\tif (!set)\n\t\treturn isl_stat_error;\n\tif (isl_set_plain_is_empty(set)) {\n\t\tisl_set_free(set);\n\t\treturn isl_stat_ok;\n\t}\n\tif (first == len)\n\t\treturn fn(set, signs, user);\n\n\tsigns[first] = 1;\n\thalf = isl_set_from_basic_set(nonneg_halfspace(isl_set_get_space(set),\n\t\t\t\t\t\t\t1 + first));\n\thalf = isl_set_intersect(half, isl_set_copy(set));\n\tif (foreach_orthant(half, signs, first + 1, len, fn, user) < 0)\n\t\tgoto error;\n\n\tsigns[first] = -1;\n\thalf = isl_set_from_basic_set(neg_halfspace(isl_set_get_space(set),\n\t\t\t\t\t\t\t1 + first));\n\thalf = isl_set_intersect(half, set);\n\treturn foreach_orthant(half, signs, first + 1, len, fn, user);\nerror:\n\tisl_set_free(set);\n\treturn isl_stat_error;\n}\n\n/* Call \"fn\" on the intersections of \"set\" with each of the orthants\n * (except for obviously empty intersections).  The orthant is identified\n * by the signs array, with each entry having value 1 or -1 according\n * to the sign of the corresponding variable.\n */\nisl_stat isl_set_foreach_orthant(__isl_keep isl_set *set,\n\tisl_stat (*fn)(__isl_take isl_set *orthant, int *signs, void *user),\n\tvoid *user)\n{\n\tisl_size nparam;\n\tisl_size nvar;\n\tint *signs;\n\tisl_stat r;\n\n\tif (!set)\n\t\treturn isl_stat_error;\n\tif (isl_set_plain_is_empty(set))\n\t\treturn isl_stat_ok;\n\n\tnparam = isl_set_dim(set, isl_dim_param);\n\tnvar = isl_set_dim(set, isl_dim_set);\n\tif (nparam < 0 || nvar < 0)\n\t\treturn isl_stat_error;\n\n\tsigns = isl_alloc_array(set->ctx, int, nparam + nvar);\n\n\tr = foreach_orthant(isl_set_copy(set), signs, 0, nparam + nvar,\n\t\t\t    fn, user);\n\n\tfree(signs);\n\n\treturn r;\n}\n\nisl_bool isl_set_is_equal(__isl_keep isl_set *set1, __isl_keep isl_set *set2)\n{\n\treturn isl_map_is_equal(set_to_map(set1), set_to_map(set2));\n}\n\nisl_bool isl_basic_map_is_subset(__isl_keep isl_basic_map *bmap1,\n\t__isl_keep isl_basic_map *bmap2)\n{\n\tisl_bool is_subset;\n\tstruct isl_map *map1;\n\tstruct isl_map *map2;\n\n\tif (!bmap1 || !bmap2)\n\t\treturn isl_bool_error;\n\n\tmap1 = isl_map_from_basic_map(isl_basic_map_copy(bmap1));\n\tmap2 = isl_map_from_basic_map(isl_basic_map_copy(bmap2));\n\n\tis_subset = isl_map_is_subset(map1, map2);\n\n\tisl_map_free(map1);\n\tisl_map_free(map2);\n\n\treturn is_subset;\n}\n\nisl_bool isl_basic_set_is_subset(__isl_keep isl_basic_set *bset1,\n\t__isl_keep isl_basic_set *bset2)\n{\n\treturn isl_basic_map_is_subset(bset1, bset2);\n}\n\nisl_bool isl_basic_map_is_equal(__isl_keep isl_basic_map *bmap1,\n\t__isl_keep isl_basic_map *bmap2)\n{\n\tisl_bool is_subset;\n\n\tif (!bmap1 || !bmap2)\n\t\treturn isl_bool_error;\n\tis_subset = isl_basic_map_is_subset(bmap1, bmap2);\n\tif (is_subset != isl_bool_true)\n\t\treturn is_subset;\n\tis_subset = isl_basic_map_is_subset(bmap2, bmap1);\n\treturn is_subset;\n}\n\nisl_bool isl_basic_set_is_equal(__isl_keep isl_basic_set *bset1,\n\t__isl_keep isl_basic_set *bset2)\n{\n\treturn isl_basic_map_is_equal(\n\t\tbset_to_bmap(bset1), bset_to_bmap(bset2));\n}\n\nisl_bool isl_map_is_empty(__isl_keep isl_map *map)\n{\n\tint i;\n\tint is_empty;\n\n\tif (!map)\n\t\treturn isl_bool_error;\n\tfor (i = 0; i < map->n; ++i) {\n\t\tis_empty = isl_basic_map_is_empty(map->p[i]);\n\t\tif (is_empty < 0)\n\t\t\treturn isl_bool_error;\n\t\tif (!is_empty)\n\t\t\treturn isl_bool_false;\n\t}\n\treturn isl_bool_true;\n}\n\nisl_bool isl_map_plain_is_empty(__isl_keep isl_map *map)\n{\n\treturn map ? map->n == 0 : isl_bool_error;\n}\n\nisl_bool isl_set_plain_is_empty(__isl_keep isl_set *set)\n{\n\treturn set ? set->n == 0 : isl_bool_error;\n}\n\nisl_bool isl_set_is_empty(__isl_keep isl_set *set)\n{\n\treturn isl_map_is_empty(set_to_map(set));\n}\n\n#undef TYPE\n#define TYPE\tisl_basic_map\n\nstatic\n#include \"isl_type_has_equal_space_bin_templ.c\"\n#include \"isl_type_check_equal_space_templ.c\"\n\n/* Check that \"bset1\" and \"bset2\" live in the same space,\n * reporting an error if they do not.\n */\nisl_stat isl_basic_set_check_equal_space(__isl_keep isl_basic_set *bset1,\n\t__isl_keep isl_basic_set *bset2)\n{\n\treturn isl_basic_map_check_equal_space(bset_to_bmap(bset1),\n\t\t\t\t\t\tbset_to_bmap(bset1));\n}\n\n#undef TYPE\n#define TYPE\tisl_map\n\n#include \"isl_type_has_equal_space_bin_templ.c\"\n#include \"isl_type_check_equal_space_templ.c\"\n#include \"isl_type_has_space_templ.c\"\n\nisl_bool isl_set_has_equal_space(__isl_keep isl_set *set1,\n\t__isl_keep isl_set *set2)\n{\n\treturn isl_map_has_equal_space(set_to_map(set1), set_to_map(set2));\n}\n\n#undef TYPE1\n#define TYPE1\t\tisl_map\n#undef TYPE2\n#define TYPE2\t\tisl_basic_map\n#undef TYPE_PAIR\n#define TYPE_PAIR\tisl_map_basic_map\n\nstatic\n#include \"isl_type_has_equal_space_templ.c\"\n#include \"isl_type_check_equal_space_templ.c\"\n\n/* Check that \"set\" and \"bset\" live in the same space,\n * reporting an error if they do not.\n */\nisl_stat isl_set_basic_set_check_equal_space(__isl_keep isl_set *set,\n\t__isl_keep isl_basic_set *bset)\n{\n\treturn isl_map_basic_map_check_equal_space(set_to_map(set),\n\t\t\t\t\t\t    bset_to_bmap(bset));\n}\n\nstatic isl_bool map_is_equal(__isl_keep isl_map *map1, __isl_keep isl_map *map2)\n{\n\tisl_bool is_subset;\n\n\tif (!map1 || !map2)\n\t\treturn isl_bool_error;\n\tis_subset = isl_map_is_subset(map1, map2);\n\tif (is_subset != isl_bool_true)\n\t\treturn is_subset;\n\tis_subset = isl_map_is_subset(map2, map1);\n\treturn is_subset;\n}\n\n/* Is \"map1\" equal to \"map2\"?\n *\n * First check if they are obviously equal.\n * If not, then perform a more detailed analysis.\n */\nisl_bool isl_map_is_equal(__isl_keep isl_map *map1, __isl_keep isl_map *map2)\n{\n\tisl_bool equal;\n\n\tequal = isl_map_plain_is_equal(map1, map2);\n\tif (equal < 0 || equal)\n\t\treturn equal;\n\treturn isl_map_align_params_map_map_and_test(map1, map2, &map_is_equal);\n}\n\nisl_bool isl_basic_map_is_strict_subset(__isl_keep isl_basic_map *bmap1,\n\t__isl_keep isl_basic_map *bmap2)\n{\n\tisl_bool is_subset;\n\n\tif (!bmap1 || !bmap2)\n\t\treturn isl_bool_error;\n\tis_subset = isl_basic_map_is_subset(bmap1, bmap2);\n\tif (is_subset != isl_bool_true)\n\t\treturn is_subset;\n\tis_subset = isl_basic_map_is_subset(bmap2, bmap1);\n\treturn isl_bool_not(is_subset);\n}\n\nisl_bool isl_map_is_strict_subset(__isl_keep isl_map *map1,\n\t__isl_keep isl_map *map2)\n{\n\tisl_bool is_subset;\n\n\tif (!map1 || !map2)\n\t\treturn isl_bool_error;\n\tis_subset = isl_map_is_subset(map1, map2);\n\tif (is_subset != isl_bool_true)\n\t\treturn is_subset;\n\tis_subset = isl_map_is_subset(map2, map1);\n\treturn isl_bool_not(is_subset);\n}\n\nisl_bool isl_set_is_strict_subset(__isl_keep isl_set *set1,\n\t__isl_keep isl_set *set2)\n{\n\treturn isl_map_is_strict_subset(set_to_map(set1), set_to_map(set2));\n}\n\n/* Is \"bmap\" obviously equal to the universe with the same space?\n *\n * That is, does it not have any constraints?\n */\nisl_bool isl_basic_map_plain_is_universe(__isl_keep isl_basic_map *bmap)\n{\n\tif (!bmap)\n\t\treturn isl_bool_error;\n\treturn bmap->n_eq == 0 && bmap->n_ineq == 0;\n}\n\n/* Is \"bset\" obviously equal to the universe with the same space?\n */\nisl_bool isl_basic_set_plain_is_universe(__isl_keep isl_basic_set *bset)\n{\n\treturn isl_basic_map_plain_is_universe(bset);\n}\n\n/* If \"c\" does not involve any existentially quantified variables,\n * then set *univ to false and abort\n */\nstatic isl_stat involves_divs(__isl_take isl_constraint *c, void *user)\n{\n\tisl_bool *univ = user;\n\tisl_size n;\n\n\tn = isl_constraint_dim(c, isl_dim_div);\n\tif (n < 0)\n\t\tc = isl_constraint_free(c);\n\t*univ = isl_constraint_involves_dims(c, isl_dim_div, 0, n);\n\tisl_constraint_free(c);\n\tif (*univ < 0 || !*univ)\n\t\treturn isl_stat_error;\n\treturn isl_stat_ok;\n}\n\n/* Is \"bmap\" equal to the universe with the same space?\n *\n * First check if it is obviously equal to the universe.\n * If not and if there are any constraints not involving\n * existentially quantified variables, then it is certainly\n * not equal to the universe.\n * Otherwise, check if the universe is a subset of \"bmap\".\n */\nisl_bool isl_basic_map_is_universe(__isl_keep isl_basic_map *bmap)\n{\n\tisl_size n_div;\n\tisl_bool univ;\n\tisl_basic_map *test;\n\n\tuniv = isl_basic_map_plain_is_universe(bmap);\n\tif (univ < 0 || univ)\n\t\treturn univ;\n\tn_div = isl_basic_map_dim(bmap, isl_dim_div);\n\tif (n_div < 0)\n\t\treturn isl_bool_error;\n\tif (n_div == 0)\n\t\treturn isl_bool_false;\n\tuniv = isl_bool_true;\n\tif (isl_basic_map_foreach_constraint(bmap, &involves_divs, &univ) < 0 &&\n\t    univ)\n\t\treturn isl_bool_error;\n\tif (univ < 0 || !univ)\n\t\treturn univ;\n\ttest = isl_basic_map_universe(isl_basic_map_get_space(bmap));\n\tuniv = isl_basic_map_is_subset(test, bmap);\n\tisl_basic_map_free(test);\n\treturn univ;\n}\n\n/* Is \"bset\" equal to the universe with the same space?\n */\nisl_bool isl_basic_set_is_universe(__isl_keep isl_basic_set *bset)\n{\n\treturn isl_basic_map_is_universe(bset);\n}\n\nisl_bool isl_map_plain_is_universe(__isl_keep isl_map *map)\n{\n\tint i;\n\n\tif (!map)\n\t\treturn isl_bool_error;\n\n\tfor (i = 0; i < map->n; ++i) {\n\t\tisl_bool r = isl_basic_map_plain_is_universe(map->p[i]);\n\t\tif (r < 0 || r)\n\t\t\treturn r;\n\t}\n\n\treturn isl_bool_false;\n}\n\nisl_bool isl_set_plain_is_universe(__isl_keep isl_set *set)\n{\n\treturn isl_map_plain_is_universe(set_to_map(set));\n}\n\nisl_bool isl_basic_map_is_empty(__isl_keep isl_basic_map *bmap)\n{\n\tstruct isl_basic_set *bset = NULL;\n\tstruct isl_vec *sample = NULL;\n\tisl_bool empty, non_empty;\n\n\tif (!bmap)\n\t\treturn isl_bool_error;\n\n\tif (ISL_F_ISSET(bmap, ISL_BASIC_MAP_EMPTY))\n\t\treturn isl_bool_true;\n\n\tif (isl_basic_map_plain_is_universe(bmap))\n\t\treturn isl_bool_false;\n\n\tif (ISL_F_ISSET(bmap, ISL_BASIC_MAP_RATIONAL)) {\n\t\tstruct isl_basic_map *copy = isl_basic_map_copy(bmap);\n\t\tcopy = isl_basic_map_remove_redundancies(copy);\n\t\tempty = isl_basic_map_plain_is_empty(copy);\n\t\tisl_basic_map_free(copy);\n\t\treturn empty;\n\t}\n\n\tnon_empty = isl_basic_map_plain_is_non_empty(bmap);\n\tif (non_empty < 0)\n\t\treturn isl_bool_error;\n\tif (non_empty)\n\t\treturn isl_bool_false;\n\tisl_vec_free(bmap->sample);\n\tbmap->sample = NULL;\n\tbset = isl_basic_map_underlying_set(isl_basic_map_copy(bmap));\n\tif (!bset)\n\t\treturn isl_bool_error;\n\tsample = isl_basic_set_sample_vec(bset);\n\tif (!sample)\n\t\treturn isl_bool_error;\n\tempty = sample->size == 0;\n\tisl_vec_free(bmap->sample);\n\tbmap->sample = sample;\n\tif (empty)\n\t\tISL_F_SET(bmap, ISL_BASIC_MAP_EMPTY);\n\n\treturn empty;\n}\n\nisl_bool isl_basic_map_plain_is_empty(__isl_keep isl_basic_map *bmap)\n{\n\tif (!bmap)\n\t\treturn isl_bool_error;\n\treturn ISL_F_ISSET(bmap, ISL_BASIC_MAP_EMPTY);\n}\n\nisl_bool isl_basic_set_plain_is_empty(__isl_keep isl_basic_set *bset)\n{\n\tif (!bset)\n\t\treturn isl_bool_error;\n\treturn ISL_F_ISSET(bset, ISL_BASIC_SET_EMPTY);\n}\n\n/* Is \"bmap\" known to be non-empty?\n *\n * That is, is the cached sample still valid?\n */\nisl_bool isl_basic_map_plain_is_non_empty(__isl_keep isl_basic_map *bmap)\n{\n\tisl_size total;\n\n\tif (!bmap)\n\t\treturn isl_bool_error;\n\tif (!bmap->sample)\n\t\treturn isl_bool_false;\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tif (total < 0)\n\t\treturn isl_bool_error;\n\tif (bmap->sample->size != 1 + total)\n\t\treturn isl_bool_false;\n\treturn isl_basic_map_contains(bmap, bmap->sample);\n}\n\nisl_bool isl_basic_set_is_empty(__isl_keep isl_basic_set *bset)\n{\n\treturn isl_basic_map_is_empty(bset_to_bmap(bset));\n}\n\n__isl_give isl_map *isl_basic_map_union(__isl_take isl_basic_map *bmap1,\n\t__isl_take isl_basic_map *bmap2)\n{\n\tstruct isl_map *map;\n\n\tif (isl_basic_map_check_equal_space(bmap1, bmap2) < 0)\n\t\tgoto error;\n\n\tmap = isl_map_alloc_space(isl_space_copy(bmap1->dim), 2, 0);\n\tif (!map)\n\t\tgoto error;\n\tmap = isl_map_add_basic_map(map, bmap1);\n\tmap = isl_map_add_basic_map(map, bmap2);\n\treturn map;\nerror:\n\tisl_basic_map_free(bmap1);\n\tisl_basic_map_free(bmap2);\n\treturn NULL;\n}\n\n__isl_give isl_set *isl_basic_set_union(__isl_take isl_basic_set *bset1,\n\t__isl_take isl_basic_set *bset2)\n{\n\treturn set_from_map(isl_basic_map_union(bset_to_bmap(bset1),\n\t\t\t\t\t\tbset_to_bmap(bset2)));\n}\n\n/* Order divs such that any div only depends on previous divs */\n__isl_give isl_basic_map *isl_basic_map_order_divs(\n\t__isl_take isl_basic_map *bmap)\n{\n\tint i;\n\tisl_size off;\n\n\toff = isl_basic_map_var_offset(bmap, isl_dim_div);\n\tif (off < 0)\n\t\treturn isl_basic_map_free(bmap);\n\n\tfor (i = 0; i < bmap->n_div; ++i) {\n\t\tint pos;\n\t\tif (isl_int_is_zero(bmap->div[i][0]))\n\t\t\tcontinue;\n\t\tpos = isl_seq_first_non_zero(bmap->div[i]+1+1+off+i,\n\t\t\t\t\t\t\t    bmap->n_div-i);\n\t\tif (pos == -1)\n\t\t\tcontinue;\n\t\tif (pos == 0)\n\t\t\tisl_die(isl_basic_map_get_ctx(bmap), isl_error_internal,\n\t\t\t\t\"integer division depends on itself\",\n\t\t\t\treturn isl_basic_map_free(bmap));\n\t\tbmap = isl_basic_map_swap_div(bmap, i, i + pos);\n\t\tif (!bmap)\n\t\t\treturn NULL;\n\t\t--i;\n\t}\n\treturn bmap;\n}\n\n__isl_give isl_map *isl_map_order_divs(__isl_take isl_map *map)\n{\n\tint i;\n\n\tif (!map)\n\t\treturn 0;\n\n\tfor (i = 0; i < map->n; ++i) {\n\t\tmap->p[i] = isl_basic_map_order_divs(map->p[i]);\n\t\tif (!map->p[i])\n\t\t\tgoto error;\n\t}\n\n\treturn map;\nerror:\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n/* Sort the local variables of \"bset\".\n */\n__isl_give isl_basic_set *isl_basic_set_sort_divs(\n\t__isl_take isl_basic_set *bset)\n{\n\treturn bset_from_bmap(isl_basic_map_sort_divs(bset_to_bmap(bset)));\n}\n\n/* Apply the expansion computed by isl_merge_divs.\n * The expansion itself is given by \"exp\" while the resulting\n * list of divs is given by \"div\".\n *\n * Move the integer divisions of \"bmap\" into the right position\n * according to \"exp\" and then introduce the additional integer\n * divisions, adding div constraints.\n * The moving should be done first to avoid moving coefficients\n * in the definitions of the extra integer divisions.\n */\n__isl_give isl_basic_map *isl_basic_map_expand_divs(\n\t__isl_take isl_basic_map *bmap, __isl_take isl_mat *div, int *exp)\n{\n\tint i, j;\n\tint n_div;\n\n\tbmap = isl_basic_map_cow(bmap);\n\tif (!bmap || !div)\n\t\tgoto error;\n\n\tif (div->n_row < bmap->n_div)\n\t\tisl_die(isl_mat_get_ctx(div), isl_error_invalid,\n\t\t\t\"not an expansion\", goto error);\n\n\tn_div = bmap->n_div;\n\tbmap = isl_basic_map_extend(bmap, div->n_row - n_div, 0,\n\t\t\t\t\t    2 * (div->n_row - n_div));\n\n\tfor (i = n_div; i < div->n_row; ++i)\n\t\tif (isl_basic_map_alloc_div(bmap) < 0)\n\t\t\tgoto error;\n\n\tfor (j = n_div - 1; j >= 0; --j) {\n\t\tif (exp[j] == j)\n\t\t\tbreak;\n\t\tbmap = isl_basic_map_swap_div(bmap, j, exp[j]);\n\t\tif (!bmap)\n\t\t\tgoto error;\n\t}\n\tj = 0;\n\tfor (i = 0; i < div->n_row; ++i) {\n\t\tif (j < n_div && exp[j] == i) {\n\t\t\tj++;\n\t\t} else {\n\t\t\tisl_seq_cpy(bmap->div[i], div->row[i], div->n_col);\n\t\t\tif (isl_basic_map_div_is_marked_unknown(bmap, i))\n\t\t\t\tcontinue;\n\t\t\tbmap = isl_basic_map_add_div_constraints(bmap, i);\n\t\t\tif (!bmap)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\n\tisl_mat_free(div);\n\treturn bmap;\nerror:\n\tisl_basic_map_free(bmap);\n\tisl_mat_free(div);\n\treturn NULL;\n}\n\n/* Apply the expansion computed by isl_merge_divs.\n * The expansion itself is given by \"exp\" while the resulting\n * list of divs is given by \"div\".\n */\n__isl_give isl_basic_set *isl_basic_set_expand_divs(\n\t__isl_take isl_basic_set *bset, __isl_take isl_mat *div, int *exp)\n{\n\treturn isl_basic_map_expand_divs(bset, div, exp);\n}\n\n/* Look for a div in dst that corresponds to the div \"div\" in src.\n * The divs before \"div\" in src and dst are assumed to be the same.\n * \n * Return the position of the corresponding div in dst\n * if there is one.  Otherwise, return a position beyond the integer divisions.\n * Return -1 on error.\n */\nstatic int find_div(__isl_keep isl_basic_map *dst,\n\t__isl_keep isl_basic_map *src, unsigned div)\n{\n\tint i;\n\tisl_size n_div;\n\tisl_size v_div;\n\n\tv_div = isl_basic_map_var_offset(src, isl_dim_div);\n\tn_div = isl_basic_map_dim(dst, isl_dim_div);\n\tif (n_div < 0 || v_div < 0)\n\t\treturn -1;\n\tisl_assert(dst->ctx, div <= n_div, return -1);\n\tfor (i = div; i < n_div; ++i)\n\t\tif (isl_seq_eq(dst->div[i], src->div[div], 1+1+v_div+div) &&\n\t\t    isl_seq_first_non_zero(dst->div[i] + 1 + 1 + v_div + div,\n\t\t\t\t\t\tn_div - div) == -1)\n\t\t\treturn i;\n\treturn n_div;\n}\n\n/* Align the divs of \"dst\" to those of \"src\", adding divs from \"src\"\n * if needed.  That is, make sure that the first src->n_div divs\n * of the result are equal to those of src.\n * The integer division of \"src\" are assumed to be ordered.\n *\n * The integer divisions are swapped into the right position\n * (possibly after adding them first).  This may result\n * in the remaining integer divisions appearing in the wrong order,\n * i.e., with some integer division appearing before\n * some other integer division on which it depends.\n * The integer divisions therefore need to be ordered.\n * This will not affect the integer divisions aligned to those of \"src\",\n * since \"src\" is assumed to have ordered integer divisions.\n *\n * The result is not finalized as by design it will have redundant\n * divs if any divs from \"src\" were copied.\n */\n__isl_give isl_basic_map *isl_basic_map_align_divs(\n\t__isl_take isl_basic_map *dst, __isl_keep isl_basic_map *src)\n{\n\tint i;\n\tisl_bool known;\n\tint extended;\n\tisl_size v_div;\n\tisl_size dst_n_div;\n\n\tif (!dst || !src)\n\t\treturn isl_basic_map_free(dst);\n\n\tif (src->n_div == 0)\n\t\treturn dst;\n\n\tknown = isl_basic_map_divs_known(src);\n\tif (known < 0)\n\t\treturn isl_basic_map_free(dst);\n\tif (!known)\n\t\tisl_die(isl_basic_map_get_ctx(src), isl_error_invalid,\n\t\t\t\"some src divs are unknown\",\n\t\t\treturn isl_basic_map_free(dst));\n\n\tv_div = isl_basic_map_var_offset(src, isl_dim_div);\n\tif (v_div < 0)\n\t\treturn isl_basic_map_free(dst);\n\n\textended = 0;\n\tdst_n_div = isl_basic_map_dim(dst, isl_dim_div);\n\tif (dst_n_div < 0)\n\t\tdst = isl_basic_map_free(dst);\n\tfor (i = 0; i < src->n_div; ++i) {\n\t\tint j = find_div(dst, src, i);\n\t\tif (j < 0)\n\t\t\tdst = isl_basic_map_free(dst);\n\t\tif (j == dst_n_div) {\n\t\t\tif (!extended) {\n\t\t\t\tint extra = src->n_div - i;\n\t\t\t\tdst = isl_basic_map_cow(dst);\n\t\t\t\tif (!dst)\n\t\t\t\t\treturn isl_basic_map_free(dst);\n\t\t\t\tdst = isl_basic_map_extend(dst,\n\t\t\t\t\t\textra, 0, 2 * extra);\n\t\t\t\textended = 1;\n\t\t\t}\n\t\t\tj = isl_basic_map_alloc_div(dst);\n\t\t\tif (j < 0)\n\t\t\t\treturn isl_basic_map_free(dst);\n\t\t\tisl_seq_cpy(dst->div[j], src->div[i], 1+1+v_div+i);\n\t\t\tisl_seq_clr(dst->div[j]+1+1+v_div+i, dst->n_div - i);\n\t\t\tdst_n_div++;\n\t\t\tdst = isl_basic_map_add_div_constraints(dst, j);\n\t\t\tif (!dst)\n\t\t\t\treturn isl_basic_map_free(dst);\n\t\t}\n\t\tif (j != i)\n\t\t\tdst = isl_basic_map_swap_div(dst, i, j);\n\t\tif (!dst)\n\t\t\treturn isl_basic_map_free(dst);\n\t}\n\treturn isl_basic_map_order_divs(dst);\n}\n\n__isl_give isl_map *isl_map_align_divs_internal(__isl_take isl_map *map)\n{\n\tint i;\n\n\tif (!map)\n\t\treturn NULL;\n\tif (map->n == 0)\n\t\treturn map;\n\tmap = isl_map_compute_divs(map);\n\tmap = isl_map_order_divs(map);\n\tmap = isl_map_cow(map);\n\tif (!map)\n\t\treturn NULL;\n\n\tfor (i = 1; i < map->n; ++i)\n\t\tmap->p[0] = isl_basic_map_align_divs(map->p[0], map->p[i]);\n\tfor (i = 1; i < map->n; ++i) {\n\t\tmap->p[i] = isl_basic_map_align_divs(map->p[i], map->p[0]);\n\t\tif (!map->p[i])\n\t\t\treturn isl_map_free(map);\n\t}\n\n\tmap = isl_map_unmark_normalized(map);\n\treturn map;\n}\n\n__isl_give isl_map *isl_map_align_divs(__isl_take isl_map *map)\n{\n\treturn isl_map_align_divs_internal(map);\n}\n\n__isl_give isl_set *isl_set_align_divs(__isl_take isl_set *set)\n{\n\treturn set_from_map(isl_map_align_divs_internal(set_to_map(set)));\n}\n\n/* Align the divs of the basic maps in \"map\" to those\n * of the basic maps in \"list\", as well as to the other basic maps in \"map\".\n * The elements in \"list\" are assumed to have known divs.\n */\n__isl_give isl_map *isl_map_align_divs_to_basic_map_list(\n\t__isl_take isl_map *map, __isl_keep isl_basic_map_list *list)\n{\n\tint i;\n\tisl_size n;\n\n\tn = isl_basic_map_list_n_basic_map(list);\n\tmap = isl_map_compute_divs(map);\n\tmap = isl_map_cow(map);\n\tif (!map || n < 0)\n\t\treturn isl_map_free(map);\n\tif (map->n == 0)\n\t\treturn map;\n\n\tfor (i = 0; i < n; ++i) {\n\t\tisl_basic_map *bmap;\n\n\t\tbmap = isl_basic_map_list_get_basic_map(list, i);\n\t\tbmap = isl_basic_map_order_divs(bmap);\n\t\tmap->p[0] = isl_basic_map_align_divs(map->p[0], bmap);\n\t\tisl_basic_map_free(bmap);\n\t}\n\tif (!map->p[0])\n\t\treturn isl_map_free(map);\n\n\treturn isl_map_align_divs_internal(map);\n}\n\n/* Align the divs of each element of \"list\" to those of \"bmap\".\n * Both \"bmap\" and the elements of \"list\" are assumed to have known divs.\n */\n__isl_give isl_basic_map_list *isl_basic_map_list_align_divs_to_basic_map(\n\t__isl_take isl_basic_map_list *list, __isl_keep isl_basic_map *bmap)\n{\n\tint i;\n\tisl_size n;\n\n\tn = isl_basic_map_list_n_basic_map(list);\n\tif (n < 0 || !bmap)\n\t\treturn isl_basic_map_list_free(list);\n\n\tfor (i = 0; i < n; ++i) {\n\t\tisl_basic_map *bmap_i;\n\n\t\tbmap_i = isl_basic_map_list_get_basic_map(list, i);\n\t\tbmap_i = isl_basic_map_align_divs(bmap_i, bmap);\n\t\tlist = isl_basic_map_list_set_basic_map(list, i, bmap_i);\n\t}\n\n\treturn list;\n}\n\n__isl_give isl_set *isl_set_apply( __isl_take isl_set *set,\n\t__isl_take isl_map *map)\n{\n\tisl_bool ok;\n\n\tisl_map_align_params_set(&map, &set);\n\tok = isl_map_compatible_domain(map, set);\n\tif (ok < 0)\n\t\tgoto error;\n\tif (!ok)\n\t\tisl_die(isl_set_get_ctx(set), isl_error_invalid,\n\t\t\t\"incompatible spaces\", goto error);\n\tmap = isl_map_intersect_domain(map, set);\n\tset = isl_map_range(map);\n\treturn set;\nerror:\n\tisl_set_free(set);\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n/* There is no need to cow as removing empty parts doesn't change\n * the meaning of the set.\n */\n__isl_give isl_map *isl_map_remove_empty_parts(__isl_take isl_map *map)\n{\n\tint i;\n\n\tif (!map)\n\t\treturn NULL;\n\n\tfor (i = map->n - 1; i >= 0; --i)\n\t\tmap = remove_if_empty(map, i);\n\n\treturn map;\n}\n\n__isl_give isl_set *isl_set_remove_empty_parts(__isl_take isl_set *set)\n{\n\treturn set_from_map(isl_map_remove_empty_parts(set_to_map(set)));\n}\n\n/* Create a binary relation that maps the shared initial \"pos\" dimensions\n * of \"bset1\" and \"bset2\" to the remaining dimensions of \"bset1\" and \"bset2\".\n */\nstatic __isl_give isl_basic_map *join_initial(__isl_keep isl_basic_set *bset1,\n\t__isl_keep isl_basic_set *bset2, int pos)\n{\n\tisl_basic_map *bmap1;\n\tisl_basic_map *bmap2;\n\n\tbmap1 = isl_basic_map_from_range(isl_basic_set_copy(bset1));\n\tbmap2 = isl_basic_map_from_range(isl_basic_set_copy(bset2));\n\tbmap1 = isl_basic_map_move_dims(bmap1, isl_dim_in, 0,\n\t\t\t\t\tisl_dim_out, 0, pos);\n\tbmap2 = isl_basic_map_move_dims(bmap2, isl_dim_in, 0,\n\t\t\t\t\tisl_dim_out, 0, pos);\n\treturn isl_basic_map_range_product(bmap1, bmap2);\n}\n\n/* Given two basic sets bset1 and bset2, compute the maximal difference\n * between the values of dimension pos in bset1 and those in bset2\n * for any common value of the parameters and dimensions preceding pos.\n */\nstatic enum isl_lp_result basic_set_maximal_difference_at(\n\t__isl_keep isl_basic_set *bset1, __isl_keep isl_basic_set *bset2,\n\tint pos, isl_int *opt)\n{\n\tisl_basic_map *bmap1;\n\tstruct isl_ctx *ctx;\n\tstruct isl_vec *obj;\n\tisl_size total;\n\tisl_size nparam;\n\tisl_size dim1;\n\tenum isl_lp_result res;\n\n\tnparam = isl_basic_set_dim(bset1, isl_dim_param);\n\tdim1 = isl_basic_set_dim(bset1, isl_dim_set);\n\tif (nparam < 0 || dim1 < 0 || !bset2)\n\t\treturn isl_lp_error;\n\n\tbmap1 = join_initial(bset1, bset2, pos);\n\ttotal = isl_basic_map_dim(bmap1, isl_dim_all);\n\tif (total < 0)\n\t\treturn isl_lp_error;\n\n\tctx = bmap1->ctx;\n\tobj = isl_vec_alloc(ctx, 1 + total);\n\tif (!obj)\n\t\tgoto error;\n\tisl_seq_clr(obj->block.data, 1 + total);\n\tisl_int_set_si(obj->block.data[1+nparam+pos], 1);\n\tisl_int_set_si(obj->block.data[1+nparam+pos+(dim1-pos)], -1);\n\tres = isl_basic_map_solve_lp(bmap1, 1, obj->block.data, ctx->one,\n\t\t\t\t\topt, NULL, NULL);\n\tisl_basic_map_free(bmap1);\n\tisl_vec_free(obj);\n\treturn res;\nerror:\n\tisl_basic_map_free(bmap1);\n\treturn isl_lp_error;\n}\n\n/* Given two _disjoint_ basic sets bset1 and bset2, check whether\n * for any common value of the parameters and dimensions preceding pos\n * in both basic sets, the values of dimension pos in bset1 are\n * smaller or larger than those in bset2.\n *\n * Returns\n *\t 1 if bset1 follows bset2\n *\t-1 if bset1 precedes bset2\n *\t 0 if bset1 and bset2 are incomparable\n *\t-2 if some error occurred.\n */\nint isl_basic_set_compare_at(__isl_keep isl_basic_set *bset1,\n\t__isl_keep isl_basic_set *bset2, int pos)\n{\n\tisl_int opt;\n\tenum isl_lp_result res;\n\tint cmp;\n\n\tisl_int_init(opt);\n\n\tres = basic_set_maximal_difference_at(bset1, bset2, pos, &opt);\n\n\tif (res == isl_lp_empty)\n\t\tcmp = 0;\n\telse if ((res == isl_lp_ok && isl_int_is_pos(opt)) ||\n\t\t  res == isl_lp_unbounded)\n\t\tcmp = 1;\n\telse if (res == isl_lp_ok && isl_int_is_neg(opt))\n\t\tcmp = -1;\n\telse\n\t\tcmp = -2;\n\n\tisl_int_clear(opt);\n\treturn cmp;\n}\n\n/* Given two basic sets bset1 and bset2, check whether\n * for any common value of the parameters and dimensions preceding pos\n * there is a value of dimension pos in bset1 that is larger\n * than a value of the same dimension in bset2.\n *\n * Return\n *\t 1 if there exists such a pair\n *\t 0 if there is no such pair, but there is a pair of equal values\n *\t-1 otherwise\n *\t-2 if some error occurred.\n */\nint isl_basic_set_follows_at(__isl_keep isl_basic_set *bset1,\n\t__isl_keep isl_basic_set *bset2, int pos)\n{\n\tisl_bool empty;\n\tisl_basic_map *bmap;\n\tisl_size dim1;\n\n\tdim1 = isl_basic_set_dim(bset1, isl_dim_set);\n\tif (dim1 < 0)\n\t\treturn -2;\n\tbmap = join_initial(bset1, bset2, pos);\n\tbmap = isl_basic_map_order_ge(bmap, isl_dim_out, 0,\n\t\t\t\t\t    isl_dim_out, dim1 - pos);\n\tempty = isl_basic_map_is_empty(bmap);\n\tif (empty < 0)\n\t\tgoto error;\n\tif (empty) {\n\t\tisl_basic_map_free(bmap);\n\t\treturn -1;\n\t}\n\tbmap = isl_basic_map_order_gt(bmap, isl_dim_out, 0,\n\t\t\t\t\t    isl_dim_out, dim1 - pos);\n\tempty = isl_basic_map_is_empty(bmap);\n\tif (empty < 0)\n\t\tgoto error;\n\tisl_basic_map_free(bmap);\n\tif (empty)\n\t\treturn 0;\n\treturn 1;\nerror:\n\tisl_basic_map_free(bmap);\n\treturn -2;\n}\n\n/* Given two sets set1 and set2, check whether\n * for any common value of the parameters and dimensions preceding pos\n * there is a value of dimension pos in set1 that is larger\n * than a value of the same dimension in set2.\n *\n * Return\n *\t 1 if there exists such a pair\n *\t 0 if there is no such pair, but there is a pair of equal values\n *\t-1 otherwise\n *\t-2 if some error occurred.\n */\nint isl_set_follows_at(__isl_keep isl_set *set1,\n\t__isl_keep isl_set *set2, int pos)\n{\n\tint i, j;\n\tint follows = -1;\n\n\tif (!set1 || !set2)\n\t\treturn -2;\n\n\tfor (i = 0; i < set1->n; ++i)\n\t\tfor (j = 0; j < set2->n; ++j) {\n\t\t\tint f;\n\t\t\tf = isl_basic_set_follows_at(set1->p[i], set2->p[j], pos);\n\t\t\tif (f == 1 || f == -2)\n\t\t\t\treturn f;\n\t\t\tif (f > follows)\n\t\t\t\tfollows = f;\n\t\t}\n\n\treturn follows;\n}\n\nstatic isl_bool isl_basic_map_plain_has_fixed_var(\n\t__isl_keep isl_basic_map *bmap, unsigned pos, isl_int *val)\n{\n\tint i;\n\tint d;\n\tisl_size total;\n\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tif (total < 0)\n\t\treturn isl_bool_error;\n\tfor (i = 0, d = total-1; i < bmap->n_eq && d+1 > pos; ++i) {\n\t\tfor (; d+1 > pos; --d)\n\t\t\tif (!isl_int_is_zero(bmap->eq[i][1+d]))\n\t\t\t\tbreak;\n\t\tif (d != pos)\n\t\t\tcontinue;\n\t\tif (isl_seq_first_non_zero(bmap->eq[i]+1, d) != -1)\n\t\t\treturn isl_bool_false;\n\t\tif (isl_seq_first_non_zero(bmap->eq[i]+1+d+1, total-d-1) != -1)\n\t\t\treturn isl_bool_false;\n\t\tif (!isl_int_is_one(bmap->eq[i][1+d]))\n\t\t\treturn isl_bool_false;\n\t\tif (val)\n\t\t\tisl_int_neg(*val, bmap->eq[i][0]);\n\t\treturn isl_bool_true;\n\t}\n\treturn isl_bool_false;\n}\n\nstatic isl_bool isl_map_plain_has_fixed_var(__isl_keep isl_map *map,\n\tunsigned pos, isl_int *val)\n{\n\tint i;\n\tisl_int v;\n\tisl_int tmp;\n\tisl_bool fixed;\n\n\tif (!map)\n\t\treturn isl_bool_error;\n\tif (map->n == 0)\n\t\treturn isl_bool_false;\n\tif (map->n == 1)\n\t\treturn isl_basic_map_plain_has_fixed_var(map->p[0], pos, val); \n\tisl_int_init(v);\n\tisl_int_init(tmp);\n\tfixed = isl_basic_map_plain_has_fixed_var(map->p[0], pos, &v); \n\tfor (i = 1; fixed == isl_bool_true && i < map->n; ++i) {\n\t\tfixed = isl_basic_map_plain_has_fixed_var(map->p[i], pos, &tmp); \n\t\tif (fixed == isl_bool_true && isl_int_ne(tmp, v))\n\t\t\tfixed = isl_bool_false;\n\t}\n\tif (val)\n\t\tisl_int_set(*val, v);\n\tisl_int_clear(tmp);\n\tisl_int_clear(v);\n\treturn fixed;\n}\n\nstatic isl_bool isl_basic_set_plain_has_fixed_var(\n\t__isl_keep isl_basic_set *bset, unsigned pos, isl_int *val)\n{\n\treturn isl_basic_map_plain_has_fixed_var(bset_to_bmap(bset),\n\t\t\t\t\t\tpos, val);\n}\n\nisl_bool isl_basic_map_plain_is_fixed(__isl_keep isl_basic_map *bmap,\n\tenum isl_dim_type type, unsigned pos, isl_int *val)\n{\n\tif (isl_basic_map_check_range(bmap, type, pos, 1) < 0)\n\t\treturn isl_bool_error;\n\treturn isl_basic_map_plain_has_fixed_var(bmap,\n\t\tisl_basic_map_offset(bmap, type) - 1 + pos, val);\n}\n\n/* If \"bmap\" obviously lies on a hyperplane where the given dimension\n * has a fixed value, then return that value.\n * Otherwise return NaN.\n */\n__isl_give isl_val *isl_basic_map_plain_get_val_if_fixed(\n\t__isl_keep isl_basic_map *bmap,\n\tenum isl_dim_type type, unsigned pos)\n{\n\tisl_ctx *ctx;\n\tisl_val *v;\n\tisl_bool fixed;\n\n\tif (!bmap)\n\t\treturn NULL;\n\tctx = isl_basic_map_get_ctx(bmap);\n\tv = isl_val_alloc(ctx);\n\tif (!v)\n\t\treturn NULL;\n\tfixed = isl_basic_map_plain_is_fixed(bmap, type, pos, &v->n);\n\tif (fixed < 0)\n\t\treturn isl_val_free(v);\n\tif (fixed) {\n\t\tisl_int_set_si(v->d, 1);\n\t\treturn v;\n\t}\n\tisl_val_free(v);\n\treturn isl_val_nan(ctx);\n}\n\nisl_bool isl_map_plain_is_fixed(__isl_keep isl_map *map,\n\tenum isl_dim_type type, unsigned pos, isl_int *val)\n{\n\tif (isl_map_check_range(map, type, pos, 1) < 0)\n\t\treturn isl_bool_error;\n\treturn isl_map_plain_has_fixed_var(map,\n\t\tmap_offset(map, type) - 1 + pos, val);\n}\n\n/* If \"map\" obviously lies on a hyperplane where the given dimension\n * has a fixed value, then return that value.\n * Otherwise return NaN.\n */\n__isl_give isl_val *isl_map_plain_get_val_if_fixed(__isl_keep isl_map *map,\n\tenum isl_dim_type type, unsigned pos)\n{\n\tisl_ctx *ctx;\n\tisl_val *v;\n\tisl_bool fixed;\n\n\tif (!map)\n\t\treturn NULL;\n\tctx = isl_map_get_ctx(map);\n\tv = isl_val_alloc(ctx);\n\tif (!v)\n\t\treturn NULL;\n\tfixed = isl_map_plain_is_fixed(map, type, pos, &v->n);\n\tif (fixed < 0)\n\t\treturn isl_val_free(v);\n\tif (fixed) {\n\t\tisl_int_set_si(v->d, 1);\n\t\treturn v;\n\t}\n\tisl_val_free(v);\n\treturn isl_val_nan(ctx);\n}\n\n/* If \"set\" obviously lies on a hyperplane where the given dimension\n * has a fixed value, then return that value.\n * Otherwise return NaN.\n */\n__isl_give isl_val *isl_set_plain_get_val_if_fixed(__isl_keep isl_set *set,\n\tenum isl_dim_type type, unsigned pos)\n{\n\treturn isl_map_plain_get_val_if_fixed(set, type, pos);\n}\n\n/* Return a sequence of values in the same space as \"set\"\n * that are equal to the corresponding set dimensions of \"set\"\n * for those set dimensions that obviously lie on a hyperplane\n * where the dimension has a fixed value.\n * The other elements are set to NaN.\n */\n__isl_give isl_multi_val *isl_set_get_plain_multi_val_if_fixed(\n\t__isl_keep isl_set *set)\n{\n\tint i;\n\tisl_size n;\n\tisl_space *space;\n\tisl_multi_val *mv;\n\n\tspace = isl_space_drop_all_params(isl_set_get_space(set));\n\tmv = isl_multi_val_alloc(space);\n\tn = isl_multi_val_size(mv);\n\tif (n < 0)\n\t\treturn isl_multi_val_free(mv);\n\n\tfor (i = 0; i < n; ++i) {\n\t\tisl_val *v;\n\n\t\tv = isl_set_plain_get_val_if_fixed(set, isl_dim_set, i);\n\t\tmv = isl_multi_val_set_val(mv, i, v);\n\t}\n\n\treturn mv;\n}\n\n/* Check if dimension dim has fixed value and if so and if val is not NULL,\n * then return this fixed value in *val.\n */\nisl_bool isl_basic_set_plain_dim_is_fixed(__isl_keep isl_basic_set *bset,\n\tunsigned dim, isl_int *val)\n{\n\tisl_size nparam;\n\n\tnparam = isl_basic_set_dim(bset, isl_dim_param);\n\tif (nparam < 0)\n\t\treturn isl_bool_error;\n\treturn isl_basic_set_plain_has_fixed_var(bset, nparam + dim, val);\n}\n\n/* Return -1 if the constraint \"c1\" should be sorted before \"c2\"\n * and 1 if it should be sorted after \"c2\".\n * Return 0 if the two constraints are the same (up to the constant term).\n *\n * In particular, if a constraint involves later variables than another\n * then it is sorted after this other constraint.\n * uset_gist depends on constraints without existentially quantified\n * variables sorting first.\n *\n * For constraints that have the same latest variable, those\n * with the same coefficient for this latest variable (first in absolute value\n * and then in actual value) are grouped together.\n * This is useful for detecting pairs of constraints that can\n * be chained in their printed representation.\n *\n * Finally, within a group, constraints are sorted according to\n * their coefficients (excluding the constant term).\n */\nstatic int sort_constraint_cmp(const void *p1, const void *p2, void *arg)\n{\n\tisl_int **c1 = (isl_int **) p1;\n\tisl_int **c2 = (isl_int **) p2;\n\tint l1, l2;\n\tunsigned size = *(unsigned *) arg;\n\tint cmp;\n\n\tl1 = isl_seq_last_non_zero(*c1 + 1, size);\n\tl2 = isl_seq_last_non_zero(*c2 + 1, size);\n\n\tif (l1 != l2)\n\t\treturn l1 - l2;\n\n\tcmp = isl_int_abs_cmp((*c1)[1 + l1], (*c2)[1 + l1]);\n\tif (cmp != 0)\n\t\treturn cmp;\n\tcmp = isl_int_cmp((*c1)[1 + l1], (*c2)[1 + l1]);\n\tif (cmp != 0)\n\t\treturn -cmp;\n\n\treturn isl_seq_cmp(*c1 + 1, *c2 + 1, size);\n}\n\n/* Return -1 if the constraint \"c1\" of \"bmap\" is sorted before \"c2\"\n * by isl_basic_map_sort_constraints, 1 if it is sorted after \"c2\"\n * and 0 if the two constraints are the same (up to the constant term).\n */\nint isl_basic_map_constraint_cmp(__isl_keep isl_basic_map *bmap,\n\tisl_int *c1, isl_int *c2)\n{\n\tisl_size total;\n\tunsigned size;\n\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tif (total < 0)\n\t\treturn -2;\n\tsize = total;\n\treturn sort_constraint_cmp(&c1, &c2, &size);\n}\n\n__isl_give isl_basic_map *isl_basic_map_sort_constraints(\n\t__isl_take isl_basic_map *bmap)\n{\n\tisl_size total;\n\tunsigned size;\n\n\tif (!bmap)\n\t\treturn NULL;\n\tif (bmap->n_ineq == 0)\n\t\treturn bmap;\n\tif (ISL_F_ISSET(bmap, ISL_BASIC_MAP_SORTED))\n\t\treturn bmap;\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tif (total < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tsize = total;\n\tif (isl_sort(bmap->ineq, bmap->n_ineq, sizeof(isl_int *),\n\t\t    &sort_constraint_cmp, &size) < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tISL_F_SET(bmap, ISL_BASIC_MAP_SORTED);\n\treturn bmap;\n}\n\n__isl_give isl_basic_set *isl_basic_set_sort_constraints(\n\t__isl_take isl_basic_set *bset)\n{\n\tisl_basic_map *bmap = bset_to_bmap(bset);\n\treturn bset_from_bmap(isl_basic_map_sort_constraints(bmap));\n}\n\n__isl_give isl_basic_map *isl_basic_map_normalize(\n\t__isl_take isl_basic_map *bmap)\n{\n\tbmap = isl_basic_map_remove_redundancies(bmap);\n\tbmap = isl_basic_map_sort_constraints(bmap);\n\treturn bmap;\n}\nint isl_basic_map_plain_cmp(__isl_keep isl_basic_map *bmap1,\n\t__isl_keep isl_basic_map *bmap2)\n{\n\tint i, cmp;\n\tisl_size total;\n\tisl_space *space1, *space2;\n\n\tif (!bmap1 || !bmap2)\n\t\treturn -1;\n\n\tif (bmap1 == bmap2)\n\t\treturn 0;\n\tspace1 = isl_basic_map_peek_space(bmap1);\n\tspace2 = isl_basic_map_peek_space(bmap2);\n\tcmp = isl_space_cmp(space1, space2);\n\tif (cmp)\n\t\treturn cmp;\n\tif (ISL_F_ISSET(bmap1, ISL_BASIC_MAP_RATIONAL) !=\n\t    ISL_F_ISSET(bmap2, ISL_BASIC_MAP_RATIONAL))\n\t\treturn ISL_F_ISSET(bmap1, ISL_BASIC_MAP_RATIONAL) ? -1 : 1;\n\tif (ISL_F_ISSET(bmap1, ISL_BASIC_MAP_EMPTY) &&\n\t    ISL_F_ISSET(bmap2, ISL_BASIC_MAP_EMPTY))\n\t\treturn 0;\n\tif (ISL_F_ISSET(bmap1, ISL_BASIC_MAP_EMPTY))\n\t\treturn 1;\n\tif (ISL_F_ISSET(bmap2, ISL_BASIC_MAP_EMPTY))\n\t\treturn -1;\n\tif (bmap1->n_eq != bmap2->n_eq)\n\t\treturn bmap1->n_eq - bmap2->n_eq;\n\tif (bmap1->n_ineq != bmap2->n_ineq)\n\t\treturn bmap1->n_ineq - bmap2->n_ineq;\n\tif (bmap1->n_div != bmap2->n_div)\n\t\treturn bmap1->n_div - bmap2->n_div;\n\ttotal = isl_basic_map_dim(bmap1, isl_dim_all);\n\tif (total < 0)\n\t\treturn -1;\n\tfor (i = 0; i < bmap1->n_eq; ++i) {\n\t\tcmp = isl_seq_cmp(bmap1->eq[i], bmap2->eq[i], 1+total);\n\t\tif (cmp)\n\t\t\treturn cmp;\n\t}\n\tfor (i = 0; i < bmap1->n_ineq; ++i) {\n\t\tcmp = isl_seq_cmp(bmap1->ineq[i], bmap2->ineq[i], 1+total);\n\t\tif (cmp)\n\t\t\treturn cmp;\n\t}\n\tfor (i = 0; i < bmap1->n_div; ++i) {\n\t\tcmp = isl_seq_cmp(bmap1->div[i], bmap2->div[i], 1+1+total);\n\t\tif (cmp)\n\t\t\treturn cmp;\n\t}\n\treturn 0;\n}\n\nint isl_basic_set_plain_cmp(__isl_keep isl_basic_set *bset1,\n\t__isl_keep isl_basic_set *bset2)\n{\n\treturn isl_basic_map_plain_cmp(bset1, bset2);\n}\n\nint isl_set_plain_cmp(__isl_keep isl_set *set1, __isl_keep isl_set *set2)\n{\n\tint i, cmp;\n\n\tif (set1 == set2)\n\t\treturn 0;\n\tif (set1->n != set2->n)\n\t\treturn set1->n - set2->n;\n\n\tfor (i = 0; i < set1->n; ++i) {\n\t\tcmp = isl_basic_set_plain_cmp(set1->p[i], set2->p[i]);\n\t\tif (cmp)\n\t\t\treturn cmp;\n\t}\n\n\treturn 0;\n}\n\nisl_bool isl_basic_map_plain_is_equal(__isl_keep isl_basic_map *bmap1,\n\t__isl_keep isl_basic_map *bmap2)\n{\n\tif (!bmap1 || !bmap2)\n\t\treturn isl_bool_error;\n\treturn isl_basic_map_plain_cmp(bmap1, bmap2) == 0;\n}\n\nisl_bool isl_basic_set_plain_is_equal(__isl_keep isl_basic_set *bset1,\n\t__isl_keep isl_basic_set *bset2)\n{\n\treturn isl_basic_map_plain_is_equal(bset_to_bmap(bset1),\n\t\t\t\t\t    bset_to_bmap(bset2));\n}\n\nstatic int qsort_bmap_cmp(const void *p1, const void *p2)\n{\n\tisl_basic_map *bmap1 = *(isl_basic_map **) p1;\n\tisl_basic_map *bmap2 = *(isl_basic_map **) p2;\n\n\treturn isl_basic_map_plain_cmp(bmap1, bmap2);\n}\n\n/* Sort the basic maps of \"map\" and remove duplicate basic maps.\n *\n * While removing basic maps, we make sure that the basic maps remain\n * sorted because isl_map_normalize expects the basic maps of the result\n * to be sorted.\n */\nstatic __isl_give isl_map *sort_and_remove_duplicates(__isl_take isl_map *map)\n{\n\tint i, j;\n\n\tmap = isl_map_remove_empty_parts(map);\n\tif (!map)\n\t\treturn NULL;\n\tqsort(map->p, map->n, sizeof(struct isl_basic_map *), qsort_bmap_cmp);\n\tfor (i = map->n - 1; i >= 1; --i) {\n\t\tif (!isl_basic_map_plain_is_equal(map->p[i - 1], map->p[i]))\n\t\t\tcontinue;\n\t\tisl_basic_map_free(map->p[i-1]);\n\t\tfor (j = i; j < map->n; ++j)\n\t\t\tmap->p[j - 1] = map->p[j];\n\t\tmap->n--;\n\t}\n\n\treturn map;\n}\n\n/* Remove obvious duplicates among the basic maps of \"map\".\n *\n * Unlike isl_map_normalize, this function does not remove redundant\n * constraints and only removes duplicates that have exactly the same\n * constraints in the input.  It does sort the constraints and\n * the basic maps to ease the detection of duplicates.\n *\n * If \"map\" has already been normalized or if the basic maps are\n * disjoint, then there can be no duplicates.\n */\n__isl_give isl_map *isl_map_remove_obvious_duplicates(__isl_take isl_map *map)\n{\n\tint i;\n\tisl_basic_map *bmap;\n\n\tif (!map)\n\t\treturn NULL;\n\tif (map->n <= 1)\n\t\treturn map;\n\tif (ISL_F_ISSET(map, ISL_MAP_NORMALIZED | ISL_MAP_DISJOINT))\n\t\treturn map;\n\tfor (i = 0; i < map->n; ++i) {\n\t\tbmap = isl_basic_map_copy(map->p[i]);\n\t\tbmap = isl_basic_map_sort_constraints(bmap);\n\t\tif (!bmap)\n\t\t\treturn isl_map_free(map);\n\t\tisl_basic_map_free(map->p[i]);\n\t\tmap->p[i] = bmap;\n\t}\n\n\tmap = sort_and_remove_duplicates(map);\n\treturn map;\n}\n\n/* We normalize in place, but if anything goes wrong we need\n * to return NULL, so we need to make sure we don't change the\n * meaning of any possible other copies of map.\n */\n__isl_give isl_map *isl_map_normalize(__isl_take isl_map *map)\n{\n\tint i;\n\tstruct isl_basic_map *bmap;\n\n\tif (!map)\n\t\treturn NULL;\n\tif (ISL_F_ISSET(map, ISL_MAP_NORMALIZED))\n\t\treturn map;\n\tfor (i = 0; i < map->n; ++i) {\n\t\tbmap = isl_basic_map_normalize(isl_basic_map_copy(map->p[i]));\n\t\tif (!bmap)\n\t\t\tgoto error;\n\t\tisl_basic_map_free(map->p[i]);\n\t\tmap->p[i] = bmap;\n\t}\n\n\tmap = sort_and_remove_duplicates(map);\n\tif (map)\n\t\tISL_F_SET(map, ISL_MAP_NORMALIZED);\n\treturn map;\nerror:\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n__isl_give isl_set *isl_set_normalize(__isl_take isl_set *set)\n{\n\treturn set_from_map(isl_map_normalize(set_to_map(set)));\n}\n\nisl_bool isl_map_plain_is_equal(__isl_keep isl_map *map1,\n\t__isl_keep isl_map *map2)\n{\n\tint i;\n\tisl_bool equal;\n\n\tif (!map1 || !map2)\n\t\treturn isl_bool_error;\n\n\tif (map1 == map2)\n\t\treturn isl_bool_true;\n\tequal = isl_map_has_equal_space(map1, map2);\n\tif (equal < 0 || !equal)\n\t\treturn equal;\n\n\tmap1 = isl_map_copy(map1);\n\tmap2 = isl_map_copy(map2);\n\tmap1 = isl_map_normalize(map1);\n\tmap2 = isl_map_normalize(map2);\n\tif (!map1 || !map2)\n\t\tgoto error;\n\tequal = map1->n == map2->n;\n\tfor (i = 0; equal && i < map1->n; ++i) {\n\t\tequal = isl_basic_map_plain_is_equal(map1->p[i], map2->p[i]);\n\t\tif (equal < 0)\n\t\t\tgoto error;\n\t}\n\tisl_map_free(map1);\n\tisl_map_free(map2);\n\treturn equal;\nerror:\n\tisl_map_free(map1);\n\tisl_map_free(map2);\n\treturn isl_bool_error;\n}\n\nisl_bool isl_set_plain_is_equal(__isl_keep isl_set *set1,\n\t__isl_keep isl_set *set2)\n{\n\treturn isl_map_plain_is_equal(set_to_map(set1), set_to_map(set2));\n}\n\n/* Return the basic maps in \"map\" as a list.\n */\n__isl_give isl_basic_map_list *isl_map_get_basic_map_list(\n\t__isl_keep isl_map *map)\n{\n\tint i;\n\tisl_ctx *ctx;\n\tisl_basic_map_list *list;\n\n\tif (!map)\n\t\treturn NULL;\n\tctx = isl_map_get_ctx(map);\n\tlist = isl_basic_map_list_alloc(ctx, map->n);\n\n\tfor (i = 0; i < map->n; ++i) {\n\t\tisl_basic_map *bmap;\n\n\t\tbmap = isl_basic_map_copy(map->p[i]);\n\t\tlist = isl_basic_map_list_add(list, bmap);\n\t}\n\n\treturn list;\n}\n\n/* Return the intersection of the elements in the non-empty list \"list\".\n * All elements are assumed to live in the same space.\n */\n__isl_give isl_basic_map *isl_basic_map_list_intersect(\n\t__isl_take isl_basic_map_list *list)\n{\n\tint i;\n\tisl_size n;\n\tisl_basic_map *bmap;\n\n\tn = isl_basic_map_list_n_basic_map(list);\n\tif (n < 0)\n\t\tgoto error;\n\tif (n < 1)\n\t\tisl_die(isl_basic_map_list_get_ctx(list), isl_error_invalid,\n\t\t\t\"expecting non-empty list\", goto error);\n\n\tbmap = isl_basic_map_list_get_basic_map(list, 0);\n\tfor (i = 1; i < n; ++i) {\n\t\tisl_basic_map *bmap_i;\n\n\t\tbmap_i = isl_basic_map_list_get_basic_map(list, i);\n\t\tbmap = isl_basic_map_intersect(bmap, bmap_i);\n\t}\n\n\tisl_basic_map_list_free(list);\n\treturn bmap;\nerror:\n\tisl_basic_map_list_free(list);\n\treturn NULL;\n}\n\n/* Return the intersection of the elements in the non-empty list \"list\".\n * All elements are assumed to live in the same space.\n */\n__isl_give isl_basic_set *isl_basic_set_list_intersect(\n\t__isl_take isl_basic_set_list *list)\n{\n\treturn isl_basic_map_list_intersect(list);\n}\n\n/* Return the union of the elements of \"list\".\n * The list is required to have at least one element.\n */\n__isl_give isl_set *isl_basic_set_list_union(\n\t__isl_take isl_basic_set_list *list)\n{\n\tint i;\n\tisl_size n;\n\tisl_space *space;\n\tisl_basic_set *bset;\n\tisl_set *set;\n\n\tn = isl_basic_set_list_n_basic_set(list);\n\tif (n < 0)\n\t\tgoto error;\n\tif (n < 1)\n\t\tisl_die(isl_basic_set_list_get_ctx(list), isl_error_invalid,\n\t\t\t\"expecting non-empty list\", goto error);\n\n\tbset = isl_basic_set_list_get_basic_set(list, 0);\n\tspace = isl_basic_set_get_space(bset);\n\tisl_basic_set_free(bset);\n\n\tset = isl_set_alloc_space(space, n, 0);\n\tfor (i = 0; i < n; ++i) {\n\t\tbset = isl_basic_set_list_get_basic_set(list, i);\n\t\tset = isl_set_add_basic_set(set, bset);\n\t}\n\n\tisl_basic_set_list_free(list);\n\treturn set;\nerror:\n\tisl_basic_set_list_free(list);\n\treturn NULL;\n}\n\n/* Return the union of the elements in the non-empty list \"list\".\n * All elements are assumed to live in the same space.\n */\n__isl_give isl_set *isl_set_list_union(__isl_take isl_set_list *list)\n{\n\tint i;\n\tisl_size n;\n\tisl_set *set;\n\n\tn = isl_set_list_n_set(list);\n\tif (n < 0)\n\t\tgoto error;\n\tif (n < 1)\n\t\tisl_die(isl_set_list_get_ctx(list), isl_error_invalid,\n\t\t\t\"expecting non-empty list\", goto error);\n\n\tset = isl_set_list_get_set(list, 0);\n\tfor (i = 1; i < n; ++i) {\n\t\tisl_set *set_i;\n\n\t\tset_i = isl_set_list_get_set(list, i);\n\t\tset = isl_set_union(set, set_i);\n\t}\n\n\tisl_set_list_free(list);\n\treturn set;\nerror:\n\tisl_set_list_free(list);\n\treturn NULL;\n}\n\n__isl_give isl_basic_map *isl_basic_map_product(\n\t__isl_take isl_basic_map *bmap1, __isl_take isl_basic_map *bmap2)\n{\n\tisl_space *space_result = NULL;\n\tstruct isl_basic_map *bmap;\n\tunsigned in1, in2, out1, out2, nparam, total, pos;\n\tstruct isl_dim_map *dim_map1, *dim_map2;\n\n\tif (isl_basic_map_check_equal_params(bmap1, bmap2) < 0)\n\t\tgoto error;\n\tspace_result = isl_space_product(isl_space_copy(bmap1->dim),\n\t\t\t\t\t\t   isl_space_copy(bmap2->dim));\n\n\tin1 = isl_basic_map_dim(bmap1, isl_dim_in);\n\tin2 = isl_basic_map_dim(bmap2, isl_dim_in);\n\tout1 = isl_basic_map_dim(bmap1, isl_dim_out);\n\tout2 = isl_basic_map_dim(bmap2, isl_dim_out);\n\tnparam = isl_basic_map_dim(bmap1, isl_dim_param);\n\n\ttotal = nparam + in1 + in2 + out1 + out2 + bmap1->n_div + bmap2->n_div;\n\tdim_map1 = isl_dim_map_alloc(bmap1->ctx, total);\n\tdim_map2 = isl_dim_map_alloc(bmap1->ctx, total);\n\tisl_dim_map_dim(dim_map1, bmap1->dim, isl_dim_param, pos = 0);\n\tisl_dim_map_dim(dim_map2, bmap2->dim, isl_dim_param, pos = 0);\n\tisl_dim_map_dim(dim_map1, bmap1->dim, isl_dim_in, pos += nparam);\n\tisl_dim_map_dim(dim_map2, bmap2->dim, isl_dim_in, pos += in1);\n\tisl_dim_map_dim(dim_map1, bmap1->dim, isl_dim_out, pos += in2);\n\tisl_dim_map_dim(dim_map2, bmap2->dim, isl_dim_out, pos += out1);\n\tisl_dim_map_div(dim_map1, bmap1, pos += out2);\n\tisl_dim_map_div(dim_map2, bmap2, pos += bmap1->n_div);\n\n\tbmap = isl_basic_map_alloc_space(space_result,\n\t\t\tbmap1->n_div + bmap2->n_div,\n\t\t\tbmap1->n_eq + bmap2->n_eq,\n\t\t\tbmap1->n_ineq + bmap2->n_ineq);\n\tbmap = isl_basic_map_add_constraints_dim_map(bmap, bmap1, dim_map1);\n\tbmap = isl_basic_map_add_constraints_dim_map(bmap, bmap2, dim_map2);\n\tbmap = isl_basic_map_simplify(bmap);\n\treturn isl_basic_map_finalize(bmap);\nerror:\n\tisl_basic_map_free(bmap1);\n\tisl_basic_map_free(bmap2);\n\treturn NULL;\n}\n\n__isl_give isl_basic_map *isl_basic_map_flat_product(\n\t__isl_take isl_basic_map *bmap1, __isl_take isl_basic_map *bmap2)\n{\n\tisl_basic_map *prod;\n\n\tprod = isl_basic_map_product(bmap1, bmap2);\n\tprod = isl_basic_map_flatten(prod);\n\treturn prod;\n}\n\n__isl_give isl_basic_set *isl_basic_set_flat_product(\n\t__isl_take isl_basic_set *bset1, __isl_take isl_basic_set *bset2)\n{\n\treturn isl_basic_map_flat_range_product(bset1, bset2);\n}\n\n__isl_give isl_basic_map *isl_basic_map_domain_product(\n\t__isl_take isl_basic_map *bmap1, __isl_take isl_basic_map *bmap2)\n{\n\tisl_space *space1, *space2;\n\tisl_space *space_result = NULL;\n\tisl_basic_map *bmap;\n\tisl_size in1, in2, out, nparam;\n\tunsigned total, pos;\n\tstruct isl_dim_map *dim_map1, *dim_map2;\n\n\tin1 = isl_basic_map_dim(bmap1, isl_dim_in);\n\tin2 = isl_basic_map_dim(bmap2, isl_dim_in);\n\tout = isl_basic_map_dim(bmap1, isl_dim_out);\n\tnparam = isl_basic_map_dim(bmap1, isl_dim_param);\n\tif (in1 < 0 || in2 < 0 || out < 0 || nparam < 0)\n\t\tgoto error;\n\n\tspace1 = isl_basic_map_get_space(bmap1);\n\tspace2 = isl_basic_map_get_space(bmap2);\n\tspace_result = isl_space_domain_product(space1, space2);\n\n\ttotal = nparam + in1 + in2 + out + bmap1->n_div + bmap2->n_div;\n\tdim_map1 = isl_dim_map_alloc(bmap1->ctx, total);\n\tdim_map2 = isl_dim_map_alloc(bmap1->ctx, total);\n\tisl_dim_map_dim(dim_map1, bmap1->dim, isl_dim_param, pos = 0);\n\tisl_dim_map_dim(dim_map2, bmap2->dim, isl_dim_param, pos = 0);\n\tisl_dim_map_dim(dim_map1, bmap1->dim, isl_dim_in, pos += nparam);\n\tisl_dim_map_dim(dim_map2, bmap2->dim, isl_dim_in, pos += in1);\n\tisl_dim_map_dim(dim_map1, bmap1->dim, isl_dim_out, pos += in2);\n\tisl_dim_map_dim(dim_map2, bmap2->dim, isl_dim_out, pos);\n\tisl_dim_map_div(dim_map1, bmap1, pos += out);\n\tisl_dim_map_div(dim_map2, bmap2, pos += bmap1->n_div);\n\n\tbmap = isl_basic_map_alloc_space(space_result,\n\t\t\tbmap1->n_div + bmap2->n_div,\n\t\t\tbmap1->n_eq + bmap2->n_eq,\n\t\t\tbmap1->n_ineq + bmap2->n_ineq);\n\tbmap = isl_basic_map_add_constraints_dim_map(bmap, bmap1, dim_map1);\n\tbmap = isl_basic_map_add_constraints_dim_map(bmap, bmap2, dim_map2);\n\tbmap = isl_basic_map_simplify(bmap);\n\treturn isl_basic_map_finalize(bmap);\nerror:\n\tisl_basic_map_free(bmap1);\n\tisl_basic_map_free(bmap2);\n\treturn NULL;\n}\n\n__isl_give isl_basic_map *isl_basic_map_range_product(\n\t__isl_take isl_basic_map *bmap1, __isl_take isl_basic_map *bmap2)\n{\n\tisl_bool rational;\n\tisl_space *space_result = NULL;\n\tisl_basic_map *bmap;\n\tisl_size in, out1, out2, nparam;\n\tunsigned total, pos;\n\tstruct isl_dim_map *dim_map1, *dim_map2;\n\n\trational = isl_basic_map_is_rational(bmap1);\n\tif (rational >= 0 && rational)\n\t\trational = isl_basic_map_is_rational(bmap2);\n\tin = isl_basic_map_dim(bmap1, isl_dim_in);\n\tout1 = isl_basic_map_dim(bmap1, isl_dim_out);\n\tout2 = isl_basic_map_dim(bmap2, isl_dim_out);\n\tnparam = isl_basic_map_dim(bmap1, isl_dim_param);\n\tif (in < 0 || out1 < 0 || out2 < 0 || nparam < 0 || rational < 0)\n\t\tgoto error;\n\n\tif (isl_basic_map_check_equal_params(bmap1, bmap2) < 0)\n\t\tgoto error;\n\n\tspace_result = isl_space_range_product(isl_space_copy(bmap1->dim),\n\t\t\t\t\t   isl_space_copy(bmap2->dim));\n\n\ttotal = nparam + in + out1 + out2 + bmap1->n_div + bmap2->n_div;\n\tdim_map1 = isl_dim_map_alloc(bmap1->ctx, total);\n\tdim_map2 = isl_dim_map_alloc(bmap1->ctx, total);\n\tisl_dim_map_dim(dim_map1, bmap1->dim, isl_dim_param, pos = 0);\n\tisl_dim_map_dim(dim_map2, bmap2->dim, isl_dim_param, pos = 0);\n\tisl_dim_map_dim(dim_map1, bmap1->dim, isl_dim_in, pos += nparam);\n\tisl_dim_map_dim(dim_map2, bmap2->dim, isl_dim_in, pos);\n\tisl_dim_map_dim(dim_map1, bmap1->dim, isl_dim_out, pos += in);\n\tisl_dim_map_dim(dim_map2, bmap2->dim, isl_dim_out, pos += out1);\n\tisl_dim_map_div(dim_map1, bmap1, pos += out2);\n\tisl_dim_map_div(dim_map2, bmap2, pos += bmap1->n_div);\n\n\tbmap = isl_basic_map_alloc_space(space_result,\n\t\t\tbmap1->n_div + bmap2->n_div,\n\t\t\tbmap1->n_eq + bmap2->n_eq,\n\t\t\tbmap1->n_ineq + bmap2->n_ineq);\n\tbmap = isl_basic_map_add_constraints_dim_map(bmap, bmap1, dim_map1);\n\tbmap = isl_basic_map_add_constraints_dim_map(bmap, bmap2, dim_map2);\n\tif (rational)\n\t\tbmap = isl_basic_map_set_rational(bmap);\n\tbmap = isl_basic_map_simplify(bmap);\n\treturn isl_basic_map_finalize(bmap);\nerror:\n\tisl_basic_map_free(bmap1);\n\tisl_basic_map_free(bmap2);\n\treturn NULL;\n}\n\n__isl_give isl_basic_map *isl_basic_map_flat_range_product(\n\t__isl_take isl_basic_map *bmap1, __isl_take isl_basic_map *bmap2)\n{\n\tisl_basic_map *prod;\n\n\tprod = isl_basic_map_range_product(bmap1, bmap2);\n\tprod = isl_basic_map_flatten_range(prod);\n\treturn prod;\n}\n\n/* Apply \"basic_map_product\" to each pair of basic maps in \"map1\" and \"map2\"\n * and collect the results.\n * The result live in the space obtained by calling \"space_product\"\n * on the spaces of \"map1\" and \"map2\".\n * If \"remove_duplicates\" is set then the result may contain duplicates\n * (even if the inputs do not) and so we try and remove the obvious\n * duplicates.\n */\nstatic __isl_give isl_map *map_product(__isl_take isl_map *map1,\n\t__isl_take isl_map *map2,\n\t__isl_give isl_space *(*space_product)(__isl_take isl_space *left,\n\t\t\t\t\t   __isl_take isl_space *right),\n\t__isl_give isl_basic_map *(*basic_map_product)(\n\t\t__isl_take isl_basic_map *left,\n\t\t__isl_take isl_basic_map *right),\n\tint remove_duplicates)\n{\n\tunsigned flags = 0;\n\tstruct isl_map *result;\n\tint i, j;\n\tisl_bool m;\n\n\tm = isl_map_has_equal_params(map1, map2);\n\tif (m < 0)\n\t\tgoto error;\n\tif (!m)\n\t\tisl_die(isl_map_get_ctx(map1), isl_error_invalid,\n\t\t\t\"parameters don't match\", goto error);\n\n\tif (ISL_F_ISSET(map1, ISL_MAP_DISJOINT) &&\n\t    ISL_F_ISSET(map2, ISL_MAP_DISJOINT))\n\t\tISL_FL_SET(flags, ISL_MAP_DISJOINT);\n\n\tresult = isl_map_alloc_space(space_product(isl_space_copy(map1->dim),\n\t\t\t\t\t       isl_space_copy(map2->dim)),\n\t\t\t\tmap1->n * map2->n, flags);\n\tif (!result)\n\t\tgoto error;\n\tfor (i = 0; i < map1->n; ++i)\n\t\tfor (j = 0; j < map2->n; ++j) {\n\t\t\tstruct isl_basic_map *part;\n\t\t\tpart = basic_map_product(isl_basic_map_copy(map1->p[i]),\n\t\t\t\t\t\t isl_basic_map_copy(map2->p[j]));\n\t\t\tif (isl_basic_map_is_empty(part))\n\t\t\t\tisl_basic_map_free(part);\n\t\t\telse\n\t\t\t\tresult = isl_map_add_basic_map(result, part);\n\t\t\tif (!result)\n\t\t\t\tgoto error;\n\t\t}\n\tif (remove_duplicates)\n\t\tresult = isl_map_remove_obvious_duplicates(result);\n\tisl_map_free(map1);\n\tisl_map_free(map2);\n\treturn result;\nerror:\n\tisl_map_free(map1);\n\tisl_map_free(map2);\n\treturn NULL;\n}\n\n/* Given two maps A -> B and C -> D, construct a map [A -> C] -> [B -> D]\n */\n__isl_give isl_map *isl_map_product(__isl_take isl_map *map1,\n\t__isl_take isl_map *map2)\n{\n\tisl_map_align_params_bin(&map1, &map2);\n\treturn map_product(map1, map2, &isl_space_product,\n\t\t\t&isl_basic_map_product, 0);\n}\n\n/* Given two maps A -> B and C -> D, construct a map (A, C) -> (B, D)\n */\n__isl_give isl_map *isl_map_flat_product(__isl_take isl_map *map1,\n\t__isl_take isl_map *map2)\n{\n\tisl_map *prod;\n\n\tprod = isl_map_product(map1, map2);\n\tprod = isl_map_flatten(prod);\n\treturn prod;\n}\n\n/* Given two set A and B, construct its Cartesian product A x B.\n */\n__isl_give isl_set *isl_set_product(__isl_take isl_set *set1,\n\t__isl_take isl_set *set2)\n{\n\treturn isl_map_range_product(set1, set2);\n}\n\n__isl_give isl_set *isl_set_flat_product(__isl_take isl_set *set1,\n\t__isl_take isl_set *set2)\n{\n\treturn isl_map_flat_range_product(set1, set2);\n}\n\n/* Given two maps A -> B and C -> D, construct a map [A -> C] -> (B * D)\n */\n__isl_give isl_map *isl_map_domain_product(__isl_take isl_map *map1,\n\t__isl_take isl_map *map2)\n{\n\tisl_map_align_params_bin(&map1, &map2);\n\treturn map_product(map1, map2, &isl_space_domain_product,\n\t\t\t\t&isl_basic_map_domain_product, 1);\n}\n\n/* Given two maps A -> B and C -> D, construct a map (A * C) -> [B -> D]\n */\n__isl_give isl_map *isl_map_range_product(__isl_take isl_map *map1,\n\t__isl_take isl_map *map2)\n{\n\tisl_map_align_params_bin(&map1, &map2);\n\treturn map_product(map1, map2, &isl_space_range_product,\n\t\t\t\t&isl_basic_map_range_product, 1);\n}\n\n/* Given a map of the form [A -> B] -> [C -> D], return the map A -> C.\n */\n__isl_give isl_map *isl_map_factor_domain(__isl_take isl_map *map)\n{\n\tisl_space *space;\n\tisl_size total1, keep1, total2, keep2;\n\n\ttotal1 = isl_map_dim(map, isl_dim_in);\n\ttotal2 = isl_map_dim(map, isl_dim_out);\n\tif (total1 < 0 || total2 < 0)\n\t\treturn isl_map_free(map);\n\tif (!isl_space_domain_is_wrapping(map->dim) ||\n\t    !isl_space_range_is_wrapping(map->dim))\n\t\tisl_die(isl_map_get_ctx(map), isl_error_invalid,\n\t\t\t\"not a product\", return isl_map_free(map));\n\n\tspace = isl_map_get_space(map);\n\tspace = isl_space_factor_domain(space);\n\tkeep1 = isl_space_dim(space, isl_dim_in);\n\tkeep2 = isl_space_dim(space, isl_dim_out);\n\tif (keep1 < 0 || keep2 < 0)\n\t\tmap = isl_map_free(map);\n\tmap = isl_map_project_out(map, isl_dim_in, keep1, total1 - keep1);\n\tmap = isl_map_project_out(map, isl_dim_out, keep2, total2 - keep2);\n\tmap = isl_map_reset_space(map, space);\n\n\treturn map;\n}\n\n/* Given a map of the form [A -> B] -> [C -> D], return the map B -> D.\n */\n__isl_give isl_map *isl_map_factor_range(__isl_take isl_map *map)\n{\n\tisl_space *space;\n\tisl_size total1, keep1, total2, keep2;\n\n\ttotal1 = isl_map_dim(map, isl_dim_in);\n\ttotal2 = isl_map_dim(map, isl_dim_out);\n\tif (total1 < 0 || total2 < 0)\n\t\treturn isl_map_free(map);\n\tif (!isl_space_domain_is_wrapping(map->dim) ||\n\t    !isl_space_range_is_wrapping(map->dim))\n\t\tisl_die(isl_map_get_ctx(map), isl_error_invalid,\n\t\t\t\"not a product\", return isl_map_free(map));\n\n\tspace = isl_map_get_space(map);\n\tspace = isl_space_factor_range(space);\n\tkeep1 = isl_space_dim(space, isl_dim_in);\n\tkeep2 = isl_space_dim(space, isl_dim_out);\n\tif (keep1 < 0 || keep2 < 0)\n\t\tmap = isl_map_free(map);\n\tmap = isl_map_project_out(map, isl_dim_in, 0, total1 - keep1);\n\tmap = isl_map_project_out(map, isl_dim_out, 0, total2 - keep2);\n\tmap = isl_map_reset_space(map, space);\n\n\treturn map;\n}\n\n/* Given a map of the form [A -> B] -> C, return the map A -> C.\n */\n__isl_give isl_map *isl_map_domain_factor_domain(__isl_take isl_map *map)\n{\n\tisl_space *space;\n\tisl_size total, keep;\n\n\ttotal = isl_map_dim(map, isl_dim_in);\n\tif (total < 0)\n\t\treturn isl_map_free(map);\n\tif (!isl_space_domain_is_wrapping(map->dim))\n\t\tisl_die(isl_map_get_ctx(map), isl_error_invalid,\n\t\t\t\"domain is not a product\", return isl_map_free(map));\n\n\tspace = isl_map_get_space(map);\n\tspace = isl_space_domain_factor_domain(space);\n\tkeep = isl_space_dim(space, isl_dim_in);\n\tif (keep < 0)\n\t\tmap = isl_map_free(map);\n\tmap = isl_map_project_out(map, isl_dim_in, keep, total - keep);\n\tmap = isl_map_reset_space(map, space);\n\n\treturn map;\n}\n\n/* Given a map of the form [A -> B] -> C, return the map B -> C.\n */\n__isl_give isl_map *isl_map_domain_factor_range(__isl_take isl_map *map)\n{\n\tisl_space *space;\n\tisl_size total, keep;\n\n\ttotal = isl_map_dim(map, isl_dim_in);\n\tif (total < 0)\n\t\treturn isl_map_free(map);\n\tif (!isl_space_domain_is_wrapping(map->dim))\n\t\tisl_die(isl_map_get_ctx(map), isl_error_invalid,\n\t\t\t\"domain is not a product\", return isl_map_free(map));\n\n\tspace = isl_map_get_space(map);\n\tspace = isl_space_domain_factor_range(space);\n\tkeep = isl_space_dim(space, isl_dim_in);\n\tif (keep < 0)\n\t\tmap = isl_map_free(map);\n\tmap = isl_map_project_out(map, isl_dim_in, 0, total - keep);\n\tmap = isl_map_reset_space(map, space);\n\n\treturn map;\n}\n\n/* Given a map A -> [B -> C], extract the map A -> B.\n */\n__isl_give isl_map *isl_map_range_factor_domain(__isl_take isl_map *map)\n{\n\tisl_space *space;\n\tisl_size total, keep;\n\n\ttotal = isl_map_dim(map, isl_dim_out);\n\tif (total < 0)\n\t\treturn isl_map_free(map);\n\tif (!isl_space_range_is_wrapping(map->dim))\n\t\tisl_die(isl_map_get_ctx(map), isl_error_invalid,\n\t\t\t\"range is not a product\", return isl_map_free(map));\n\n\tspace = isl_map_get_space(map);\n\tspace = isl_space_range_factor_domain(space);\n\tkeep = isl_space_dim(space, isl_dim_out);\n\tif (keep < 0)\n\t\tmap = isl_map_free(map);\n\tmap = isl_map_project_out(map, isl_dim_out, keep, total - keep);\n\tmap = isl_map_reset_space(map, space);\n\n\treturn map;\n}\n\n/* Given a map A -> [B -> C], extract the map A -> C.\n */\n__isl_give isl_map *isl_map_range_factor_range(__isl_take isl_map *map)\n{\n\tisl_space *space;\n\tisl_size total, keep;\n\n\ttotal = isl_map_dim(map, isl_dim_out);\n\tif (total < 0)\n\t\treturn isl_map_free(map);\n\tif (!isl_space_range_is_wrapping(map->dim))\n\t\tisl_die(isl_map_get_ctx(map), isl_error_invalid,\n\t\t\t\"range is not a product\", return isl_map_free(map));\n\n\tspace = isl_map_get_space(map);\n\tspace = isl_space_range_factor_range(space);\n\tkeep = isl_space_dim(space, isl_dim_out);\n\tif (keep < 0)\n\t\tmap = isl_map_free(map);\n\tmap = isl_map_project_out(map, isl_dim_out, 0, total - keep);\n\tmap = isl_map_reset_space(map, space);\n\n\treturn map;\n}\n\n/* Given two maps A -> B and C -> D, construct a map (A, C) -> (B * D)\n */\n__isl_give isl_map *isl_map_flat_domain_product(__isl_take isl_map *map1,\n\t__isl_take isl_map *map2)\n{\n\tisl_map *prod;\n\n\tprod = isl_map_domain_product(map1, map2);\n\tprod = isl_map_flatten_domain(prod);\n\treturn prod;\n}\n\n/* Given two maps A -> B and C -> D, construct a map (A * C) -> (B, D)\n */\n__isl_give isl_map *isl_map_flat_range_product(__isl_take isl_map *map1,\n\t__isl_take isl_map *map2)\n{\n\tisl_map *prod;\n\n\tprod = isl_map_range_product(map1, map2);\n\tprod = isl_map_flatten_range(prod);\n\treturn prod;\n}\n\nuint32_t isl_basic_map_get_hash(__isl_keep isl_basic_map *bmap)\n{\n\tint i;\n\tuint32_t hash = isl_hash_init();\n\tisl_size total;\n\n\tif (!bmap)\n\t\treturn 0;\n\tbmap = isl_basic_map_copy(bmap);\n\tbmap = isl_basic_map_normalize(bmap);\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tif (total < 0)\n\t\treturn 0;\n\tisl_hash_byte(hash, bmap->n_eq & 0xFF);\n\tfor (i = 0; i < bmap->n_eq; ++i) {\n\t\tuint32_t c_hash;\n\t\tc_hash = isl_seq_get_hash(bmap->eq[i], 1 + total);\n\t\tisl_hash_hash(hash, c_hash);\n\t}\n\tisl_hash_byte(hash, bmap->n_ineq & 0xFF);\n\tfor (i = 0; i < bmap->n_ineq; ++i) {\n\t\tuint32_t c_hash;\n\t\tc_hash = isl_seq_get_hash(bmap->ineq[i], 1 + total);\n\t\tisl_hash_hash(hash, c_hash);\n\t}\n\tisl_hash_byte(hash, bmap->n_div & 0xFF);\n\tfor (i = 0; i < bmap->n_div; ++i) {\n\t\tuint32_t c_hash;\n\t\tif (isl_int_is_zero(bmap->div[i][0]))\n\t\t\tcontinue;\n\t\tisl_hash_byte(hash, i & 0xFF);\n\t\tc_hash = isl_seq_get_hash(bmap->div[i], 1 + 1 + total);\n\t\tisl_hash_hash(hash, c_hash);\n\t}\n\tisl_basic_map_free(bmap);\n\treturn hash;\n}\n\nuint32_t isl_basic_set_get_hash(__isl_keep isl_basic_set *bset)\n{\n\treturn isl_basic_map_get_hash(bset_to_bmap(bset));\n}\n\nuint32_t isl_map_get_hash(__isl_keep isl_map *map)\n{\n\tint i;\n\tuint32_t hash;\n\n\tif (!map)\n\t\treturn 0;\n\tmap = isl_map_copy(map);\n\tmap = isl_map_normalize(map);\n\tif (!map)\n\t\treturn 0;\n\n\thash = isl_hash_init();\n\tfor (i = 0; i < map->n; ++i) {\n\t\tuint32_t bmap_hash;\n\t\tbmap_hash = isl_basic_map_get_hash(map->p[i]);\n\t\tisl_hash_hash(hash, bmap_hash);\n\t}\n\t\t\n\tisl_map_free(map);\n\n\treturn hash;\n}\n\nuint32_t isl_set_get_hash(__isl_keep isl_set *set)\n{\n\treturn isl_map_get_hash(set_to_map(set));\n}\n\n/* Return the number of basic maps in the (current) representation of \"map\".\n */\nisl_size isl_map_n_basic_map(__isl_keep isl_map *map)\n{\n\treturn map ? map->n : isl_size_error;\n}\n\nisl_size isl_set_n_basic_set(__isl_keep isl_set *set)\n{\n\treturn set ? set->n : isl_size_error;\n}\n\nisl_stat isl_map_foreach_basic_map(__isl_keep isl_map *map,\n\tisl_stat (*fn)(__isl_take isl_basic_map *bmap, void *user), void *user)\n{\n\tint i;\n\n\tif (!map)\n\t\treturn isl_stat_error;\n\n\tfor (i = 0; i < map->n; ++i)\n\t\tif (fn(isl_basic_map_copy(map->p[i]), user) < 0)\n\t\t\treturn isl_stat_error;\n\n\treturn isl_stat_ok;\n}\n\nisl_stat isl_set_foreach_basic_set(__isl_keep isl_set *set,\n\tisl_stat (*fn)(__isl_take isl_basic_set *bset, void *user), void *user)\n{\n\tint i;\n\n\tif (!set)\n\t\treturn isl_stat_error;\n\n\tfor (i = 0; i < set->n; ++i)\n\t\tif (fn(isl_basic_set_copy(set->p[i]), user) < 0)\n\t\t\treturn isl_stat_error;\n\n\treturn isl_stat_ok;\n}\n\n/* Does \"test\" succeed on every basic set in \"set\"?\n */\nisl_bool isl_set_every_basic_set(__isl_keep isl_set *set,\n\tisl_bool (*test)(__isl_keep isl_basic_set *bset, void *user),\n\tvoid *user)\n{\n\tint i;\n\n\tif (!set)\n\t\treturn isl_bool_error;\n\n\tfor (i = 0; i < set->n; ++i) {\n\t\tisl_bool r;\n\n\t\tr = test(set->p[i], user);\n\t\tif (r < 0 || !r)\n\t\t\treturn r;\n\t}\n\n\treturn isl_bool_true;\n}\n\n/* Return a list of basic sets, the union of which is equal to \"set\".\n */\n__isl_give isl_basic_set_list *isl_set_get_basic_set_list(\n\t__isl_keep isl_set *set)\n{\n\tint i;\n\tisl_basic_set_list *list;\n\n\tif (!set)\n\t\treturn NULL;\n\n\tlist = isl_basic_set_list_alloc(isl_set_get_ctx(set), set->n);\n\tfor (i = 0; i < set->n; ++i) {\n\t\tisl_basic_set *bset;\n\n\t\tbset = isl_basic_set_copy(set->p[i]);\n\t\tlist = isl_basic_set_list_add(list, bset);\n\t}\n\n\treturn list;\n}\n\n__isl_give isl_basic_set *isl_basic_set_lift(__isl_take isl_basic_set *bset)\n{\n\tisl_space *space;\n\n\tif (!bset)\n\t\treturn NULL;\n\n\tbset = isl_basic_set_cow(bset);\n\tif (!bset)\n\t\treturn NULL;\n\n\tspace = isl_basic_set_get_space(bset);\n\tspace = isl_space_lift(space, bset->n_div);\n\tif (!space)\n\t\tgoto error;\n\tisl_space_free(bset->dim);\n\tbset->dim = space;\n\tbset->extra -= bset->n_div;\n\tbset->n_div = 0;\n\n\tbset = isl_basic_set_finalize(bset);\n\n\treturn bset;\nerror:\n\tisl_basic_set_free(bset);\n\treturn NULL;\n}\n\n__isl_give isl_set *isl_set_lift(__isl_take isl_set *set)\n{\n\tint i;\n\tisl_space *space;\n\tunsigned n_div;\n\n\tset = set_from_map(isl_map_align_divs_internal(set_to_map(set)));\n\n\tif (!set)\n\t\treturn NULL;\n\n\tset = isl_set_cow(set);\n\tif (!set)\n\t\treturn NULL;\n\n\tn_div = set->p[0]->n_div;\n\tspace = isl_set_get_space(set);\n\tspace = isl_space_lift(space, n_div);\n\tif (!space)\n\t\tgoto error;\n\tisl_space_free(set->dim);\n\tset->dim = space;\n\n\tfor (i = 0; i < set->n; ++i) {\n\t\tset->p[i] = isl_basic_set_lift(set->p[i]);\n\t\tif (!set->p[i])\n\t\t\tgoto error;\n\t}\n\n\treturn set;\nerror:\n\tisl_set_free(set);\n\treturn NULL;\n}\n\nint isl_basic_set_size(__isl_keep isl_basic_set *bset)\n{\n\tisl_size dim;\n\tint size = 0;\n\n\tdim = isl_basic_set_dim(bset, isl_dim_all);\n\tif (dim < 0)\n\t\treturn -1;\n\tsize += bset->n_eq * (1 + dim);\n\tsize += bset->n_ineq * (1 + dim);\n\tsize += bset->n_div * (2 + dim);\n\n\treturn size;\n}\n\nint isl_set_size(__isl_keep isl_set *set)\n{\n\tint i;\n\tint size = 0;\n\n\tif (!set)\n\t\treturn -1;\n\n\tfor (i = 0; i < set->n; ++i)\n\t\tsize += isl_basic_set_size(set->p[i]);\n\n\treturn size;\n}\n\n/* Check if there is any lower bound (if lower == 0) and/or upper\n * bound (if upper == 0) on the specified dim.\n */\nstatic isl_bool basic_map_dim_is_bounded(__isl_keep isl_basic_map *bmap,\n\tenum isl_dim_type type, unsigned pos, int lower, int upper)\n{\n\tint i;\n\n\tif (isl_basic_map_check_range(bmap, type, pos, 1) < 0)\n\t\treturn isl_bool_error;\n\n\tpos += isl_basic_map_offset(bmap, type);\n\n\tfor (i = 0; i < bmap->n_div; ++i) {\n\t\tif (isl_int_is_zero(bmap->div[i][0]))\n\t\t\tcontinue;\n\t\tif (!isl_int_is_zero(bmap->div[i][1 + pos]))\n\t\t\treturn isl_bool_true;\n\t}\n\n\tfor (i = 0; i < bmap->n_eq; ++i)\n\t\tif (!isl_int_is_zero(bmap->eq[i][pos]))\n\t\t\treturn isl_bool_true;\n\n\tfor (i = 0; i < bmap->n_ineq; ++i) {\n\t\tint sgn = isl_int_sgn(bmap->ineq[i][pos]);\n\t\tif (sgn > 0)\n\t\t\tlower = 1;\n\t\tif (sgn < 0)\n\t\t\tupper = 1;\n\t}\n\n\treturn lower && upper;\n}\n\nisl_bool isl_basic_map_dim_is_bounded(__isl_keep isl_basic_map *bmap,\n\tenum isl_dim_type type, unsigned pos)\n{\n\treturn basic_map_dim_is_bounded(bmap, type, pos, 0, 0);\n}\n\nisl_bool isl_basic_map_dim_has_lower_bound(__isl_keep isl_basic_map *bmap,\n\tenum isl_dim_type type, unsigned pos)\n{\n\treturn basic_map_dim_is_bounded(bmap, type, pos, 0, 1);\n}\n\nisl_bool isl_basic_map_dim_has_upper_bound(__isl_keep isl_basic_map *bmap,\n\tenum isl_dim_type type, unsigned pos)\n{\n\treturn basic_map_dim_is_bounded(bmap, type, pos, 1, 0);\n}\n\nisl_bool isl_map_dim_is_bounded(__isl_keep isl_map *map,\n\tenum isl_dim_type type, unsigned pos)\n{\n\tint i;\n\n\tif (!map)\n\t\treturn isl_bool_error;\n\n\tfor (i = 0; i < map->n; ++i) {\n\t\tisl_bool bounded;\n\t\tbounded = isl_basic_map_dim_is_bounded(map->p[i], type, pos);\n\t\tif (bounded < 0 || !bounded)\n\t\t\treturn bounded;\n\t}\n\n\treturn isl_bool_true;\n}\n\n/* Return true if the specified dim is involved in both an upper bound\n * and a lower bound.\n */\nisl_bool isl_set_dim_is_bounded(__isl_keep isl_set *set,\n\tenum isl_dim_type type, unsigned pos)\n{\n\treturn isl_map_dim_is_bounded(set_to_map(set), type, pos);\n}\n\n/* Does \"map\" have a bound (according to \"fn\") for any of its basic maps?\n */\nstatic isl_bool has_any_bound(__isl_keep isl_map *map,\n\tenum isl_dim_type type, unsigned pos,\n\tisl_bool (*fn)(__isl_keep isl_basic_map *bmap,\n\t\t  enum isl_dim_type type, unsigned pos))\n{\n\tint i;\n\n\tif (!map)\n\t\treturn isl_bool_error;\n\n\tfor (i = 0; i < map->n; ++i) {\n\t\tisl_bool bounded;\n\t\tbounded = fn(map->p[i], type, pos);\n\t\tif (bounded < 0 || bounded)\n\t\t\treturn bounded;\n\t}\n\n\treturn isl_bool_false;\n}\n\n/* Return 1 if the specified dim is involved in any lower bound.\n */\nisl_bool isl_set_dim_has_any_lower_bound(__isl_keep isl_set *set,\n\tenum isl_dim_type type, unsigned pos)\n{\n\treturn has_any_bound(set, type, pos,\n\t\t\t\t&isl_basic_map_dim_has_lower_bound);\n}\n\n/* Return 1 if the specified dim is involved in any upper bound.\n */\nisl_bool isl_set_dim_has_any_upper_bound(__isl_keep isl_set *set,\n\tenum isl_dim_type type, unsigned pos)\n{\n\treturn has_any_bound(set, type, pos,\n\t\t\t\t&isl_basic_map_dim_has_upper_bound);\n}\n\n/* Does \"map\" have a bound (according to \"fn\") for all of its basic maps?\n */\nstatic isl_bool has_bound(__isl_keep isl_map *map,\n\tenum isl_dim_type type, unsigned pos,\n\tisl_bool (*fn)(__isl_keep isl_basic_map *bmap,\n\t\t  enum isl_dim_type type, unsigned pos))\n{\n\tint i;\n\n\tif (!map)\n\t\treturn isl_bool_error;\n\n\tfor (i = 0; i < map->n; ++i) {\n\t\tisl_bool bounded;\n\t\tbounded = fn(map->p[i], type, pos);\n\t\tif (bounded < 0 || !bounded)\n\t\t\treturn bounded;\n\t}\n\n\treturn isl_bool_true;\n}\n\n/* Return 1 if the specified dim has a lower bound (in each of its basic sets).\n */\nisl_bool isl_set_dim_has_lower_bound(__isl_keep isl_set *set,\n\tenum isl_dim_type type, unsigned pos)\n{\n\treturn has_bound(set, type, pos, &isl_basic_map_dim_has_lower_bound);\n}\n\n/* Return 1 if the specified dim has an upper bound (in each of its basic sets).\n */\nisl_bool isl_set_dim_has_upper_bound(__isl_keep isl_set *set,\n\tenum isl_dim_type type, unsigned pos)\n{\n\treturn has_bound(set, type, pos, &isl_basic_map_dim_has_upper_bound);\n}\n\n/* For each of the \"n\" variables starting at \"first\", determine\n * the sign of the variable and put the results in the first \"n\"\n * elements of the array \"signs\".\n * Sign\n *\t1 means that the variable is non-negative\n *\t-1 means that the variable is non-positive\n *\t0 means the variable attains both positive and negative values.\n */\nisl_stat isl_basic_set_vars_get_sign(__isl_keep isl_basic_set *bset,\n\tunsigned first, unsigned n, int *signs)\n{\n\tisl_vec *bound = NULL;\n\tstruct isl_tab *tab = NULL;\n\tstruct isl_tab_undo *snap;\n\tint i;\n\tisl_size total;\n\n\ttotal = isl_basic_set_dim(bset, isl_dim_all);\n\tif (total < 0 || !signs)\n\t\treturn isl_stat_error;\n\n\tbound = isl_vec_alloc(bset->ctx, 1 + total);\n\ttab = isl_tab_from_basic_set(bset, 0);\n\tif (!bound || !tab)\n\t\tgoto error;\n\n\tisl_seq_clr(bound->el, bound->size);\n\tisl_int_set_si(bound->el[0], -1);\n\n\tsnap = isl_tab_snap(tab);\n\tfor (i = 0; i < n; ++i) {\n\t\tint empty;\n\n\t\tisl_int_set_si(bound->el[1 + first + i], -1);\n\t\tif (isl_tab_add_ineq(tab, bound->el) < 0)\n\t\t\tgoto error;\n\t\tempty = tab->empty;\n\t\tisl_int_set_si(bound->el[1 + first + i], 0);\n\t\tif (isl_tab_rollback(tab, snap) < 0)\n\t\t\tgoto error;\n\n\t\tif (empty) {\n\t\t\tsigns[i] = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tisl_int_set_si(bound->el[1 + first + i], 1);\n\t\tif (isl_tab_add_ineq(tab, bound->el) < 0)\n\t\t\tgoto error;\n\t\tempty = tab->empty;\n\t\tisl_int_set_si(bound->el[1 + first + i], 0);\n\t\tif (isl_tab_rollback(tab, snap) < 0)\n\t\t\tgoto error;\n\n\t\tsigns[i] = empty ? -1 : 0;\n\t}\n\n\tisl_tab_free(tab);\n\tisl_vec_free(bound);\n\treturn isl_stat_ok;\nerror:\n\tisl_tab_free(tab);\n\tisl_vec_free(bound);\n\treturn isl_stat_error;\n}\n\nisl_stat isl_basic_set_dims_get_sign(__isl_keep isl_basic_set *bset,\n\tenum isl_dim_type type, unsigned first, unsigned n, int *signs)\n{\n\tif (!bset || !signs)\n\t\treturn isl_stat_error;\n\tif (isl_basic_set_check_range(bset, type, first, n) < 0)\n\t\treturn isl_stat_error;\n\n\tfirst += pos(bset->dim, type) - 1;\n\treturn isl_basic_set_vars_get_sign(bset, first, n, signs);\n}\n\n/* Is it possible for the integer division \"div\" to depend (possibly\n * indirectly) on any output dimensions?\n *\n * If the div is undefined, then we conservatively assume that it\n * may depend on them.\n * Otherwise, we check if it actually depends on them or on any integer\n * divisions that may depend on them.\n */\nstatic isl_bool div_may_involve_output(__isl_keep isl_basic_map *bmap, int div)\n{\n\tint i;\n\tisl_size n_out, n_div;\n\tunsigned o_out, o_div;\n\n\tif (isl_int_is_zero(bmap->div[div][0]))\n\t\treturn isl_bool_true;\n\n\tn_out = isl_basic_map_dim(bmap, isl_dim_out);\n\tif (n_out < 0)\n\t\treturn isl_bool_error;\n\to_out = isl_basic_map_offset(bmap, isl_dim_out);\n\n\tif (isl_seq_first_non_zero(bmap->div[div] + 1 + o_out, n_out) != -1)\n\t\treturn isl_bool_true;\n\n\tn_div = isl_basic_map_dim(bmap, isl_dim_div);\n\tif (n_div < 0)\n\t\treturn isl_bool_error;\n\to_div = isl_basic_map_offset(bmap, isl_dim_div);\n\n\tfor (i = 0; i < n_div; ++i) {\n\t\tisl_bool may_involve;\n\n\t\tif (isl_int_is_zero(bmap->div[div][1 + o_div + i]))\n\t\t\tcontinue;\n\t\tmay_involve = div_may_involve_output(bmap, i);\n\t\tif (may_involve < 0 || may_involve)\n\t\t\treturn may_involve;\n\t}\n\n\treturn isl_bool_false;\n}\n\n/* Return the first integer division of \"bmap\" in the range\n * [first, first + n[ that may depend on any output dimensions and\n * that has a non-zero coefficient in \"c\" (where the first coefficient\n * in \"c\" corresponds to integer division \"first\").\n */\nstatic int first_div_may_involve_output(__isl_keep isl_basic_map *bmap,\n\tisl_int *c, int first, int n)\n{\n\tint k;\n\n\tif (!bmap)\n\t\treturn -1;\n\n\tfor (k = first; k < first + n; ++k) {\n\t\tisl_bool may_involve;\n\n\t\tif (isl_int_is_zero(c[k]))\n\t\t\tcontinue;\n\t\tmay_involve = div_may_involve_output(bmap, k);\n\t\tif (may_involve < 0)\n\t\t\treturn -1;\n\t\tif (may_involve)\n\t\t\treturn k;\n\t}\n\n\treturn first + n;\n}\n\n/* Look for a pair of inequality constraints in \"bmap\" of the form\n *\n *\t-l + i >= 0\t\tor\t\ti >= l\n * and\n *\tn + l - i >= 0\t\tor\t\ti <= l + n\n *\n * with n < \"m\" and i the output dimension at position \"pos\".\n * (Note that n >= 0 as otherwise the two constraints would conflict.)\n * Furthermore, \"l\" is only allowed to involve parameters, input dimensions\n * and earlier output dimensions, as well as integer divisions that do\n * not involve any of the output dimensions.\n *\n * Return the index of the first inequality constraint or bmap->n_ineq\n * if no such pair can be found.\n */\nstatic int find_modulo_constraint_pair(__isl_keep isl_basic_map *bmap,\n\tint pos, isl_int m)\n{\n\tint i, j;\n\tisl_ctx *ctx;\n\tisl_size total;\n\tisl_size n_div, n_out;\n\tunsigned o_div, o_out;\n\tint less;\n\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tn_out = isl_basic_map_dim(bmap, isl_dim_out);\n\tn_div = isl_basic_map_dim(bmap, isl_dim_div);\n\tif (total < 0 || n_out < 0 || n_div < 0)\n\t\treturn -1;\n\n\tctx = isl_basic_map_get_ctx(bmap);\n\to_out = isl_basic_map_offset(bmap, isl_dim_out);\n\to_div = isl_basic_map_offset(bmap, isl_dim_div);\n\tfor (i = 0; i < bmap->n_ineq; ++i) {\n\t\tif (!isl_int_abs_eq(bmap->ineq[i][o_out + pos], ctx->one))\n\t\t\tcontinue;\n\t\tif (isl_seq_first_non_zero(bmap->ineq[i] + o_out + pos + 1,\n\t\t\t\t\tn_out - (pos + 1)) != -1)\n\t\t\tcontinue;\n\t\tif (first_div_may_involve_output(bmap, bmap->ineq[i] + o_div,\n\t\t\t\t\t\t0, n_div) < n_div)\n\t\t\tcontinue;\n\t\tfor (j = i + 1; j < bmap->n_ineq; ++j) {\n\t\t\tif (!isl_int_abs_eq(bmap->ineq[j][o_out + pos],\n\t\t\t\t\t    ctx->one))\n\t\t\t\tcontinue;\n\t\t\tif (!isl_seq_is_neg(bmap->ineq[i] + 1,\n\t\t\t\t\t    bmap->ineq[j] + 1, total))\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\t\tif (j >= bmap->n_ineq)\n\t\t\tcontinue;\n\t\tisl_int_add(bmap->ineq[i][0],\n\t\t\t    bmap->ineq[i][0], bmap->ineq[j][0]);\n\t\tless = isl_int_abs_lt(bmap->ineq[i][0], m);\n\t\tisl_int_sub(bmap->ineq[i][0],\n\t\t\t    bmap->ineq[i][0], bmap->ineq[j][0]);\n\t\tif (!less)\n\t\t\tcontinue;\n\t\tif (isl_int_is_one(bmap->ineq[i][o_out + pos]))\n\t\t\treturn i;\n\t\telse\n\t\t\treturn j;\n\t}\n\n\treturn bmap->n_ineq;\n}\n\n/* Return the index of the equality of \"bmap\" that defines\n * the output dimension \"pos\" in terms of earlier dimensions.\n * The equality may also involve integer divisions, as long\n * as those integer divisions are defined in terms of\n * parameters or input dimensions.\n * In this case, *div is set to the number of integer divisions and\n * *ineq is set to the number of inequality constraints (provided\n * div and ineq are not NULL).\n *\n * The equality may also involve a single integer division involving\n * the output dimensions (typically only output dimension \"pos\") as\n * long as the coefficient of output dimension \"pos\" is 1 or -1 and\n * there is a pair of constraints i >= l and i <= l + n, with i referring\n * to output dimension \"pos\", l an expression involving only earlier\n * dimensions and n smaller than the coefficient of the integer division\n * in the equality.  In this case, the output dimension can be defined\n * in terms of a modulo expression that does not involve the integer division.\n * *div is then set to this single integer division and\n * *ineq is set to the index of constraint i >= l.\n *\n * Return bmap->n_eq if there is no such equality.\n * Return -1 on error.\n */\nint isl_basic_map_output_defining_equality(__isl_keep isl_basic_map *bmap,\n\tint pos, int *div, int *ineq)\n{\n\tint j, k, l;\n\tisl_size n_div, n_out;\n\tunsigned o_div, o_out;\n\n\tn_out = isl_basic_map_dim(bmap, isl_dim_out);\n\tn_div = isl_basic_map_dim(bmap, isl_dim_div);\n\tif (n_out < 0 || n_div < 0)\n\t\treturn -1;\n\n\to_out = isl_basic_map_offset(bmap, isl_dim_out);\n\to_div = isl_basic_map_offset(bmap, isl_dim_div);\n\n\tif (ineq)\n\t\t*ineq = bmap->n_ineq;\n\tif (div)\n\t\t*div = n_div;\n\tfor (j = 0; j < bmap->n_eq; ++j) {\n\t\tif (isl_int_is_zero(bmap->eq[j][o_out + pos]))\n\t\t\tcontinue;\n\t\tif (isl_seq_first_non_zero(bmap->eq[j] + o_out + pos + 1,\n\t\t\t\t\tn_out - (pos + 1)) != -1)\n\t\t\tcontinue;\n\t\tk = first_div_may_involve_output(bmap, bmap->eq[j] + o_div,\n\t\t\t\t\t\t0, n_div);\n\t\tif (k >= n_div)\n\t\t\treturn j;\n\t\tif (!isl_int_is_one(bmap->eq[j][o_out + pos]) &&\n\t\t    !isl_int_is_negone(bmap->eq[j][o_out + pos]))\n\t\t\tcontinue;\n\t\tif (first_div_may_involve_output(bmap, bmap->eq[j] + o_div,\n\t\t\t\t\t\tk + 1, n_div - (k+1)) < n_div)\n\t\t\tcontinue;\n\t\tl = find_modulo_constraint_pair(bmap, pos,\n\t\t\t\t\t\tbmap->eq[j][o_div + k]);\n\t\tif (l < 0)\n\t\t\treturn -1;\n\t\tif (l >= bmap->n_ineq)\n\t\t\tcontinue;\n\t\tif (div)\n\t\t\t*div = k;\n\t\tif (ineq)\n\t\t\t*ineq = l;\n\t\treturn j;\n\t}\n\n\treturn bmap->n_eq;\n}\n\n/* Check if the given basic map is obviously single-valued.\n * In particular, for each output dimension, check that there is\n * an equality that defines the output dimension in terms of\n * earlier dimensions.\n */\nisl_bool isl_basic_map_plain_is_single_valued(__isl_keep isl_basic_map *bmap)\n{\n\tint i;\n\tisl_size n_out;\n\n\tn_out = isl_basic_map_dim(bmap, isl_dim_out);\n\tif (n_out < 0)\n\t\treturn isl_bool_error;\n\n\tfor (i = 0; i < n_out; ++i) {\n\t\tint eq;\n\n\t\teq = isl_basic_map_output_defining_equality(bmap, i,\n\t\t\t\t\t\t\t    NULL, NULL);\n\t\tif (eq < 0)\n\t\t\treturn isl_bool_error;\n\t\tif (eq >= bmap->n_eq)\n\t\t\treturn isl_bool_false;\n\t}\n\n\treturn isl_bool_true;\n}\n\n/* Check if the given basic map is single-valued.\n * We simply compute\n *\n *\tM \\circ M^-1\n *\n * and check if the result is a subset of the identity mapping.\n */\nisl_bool isl_basic_map_is_single_valued(__isl_keep isl_basic_map *bmap)\n{\n\tisl_space *space;\n\tisl_basic_map *test;\n\tisl_basic_map *id;\n\tisl_bool sv;\n\n\tsv = isl_basic_map_plain_is_single_valued(bmap);\n\tif (sv < 0 || sv)\n\t\treturn sv;\n\n\ttest = isl_basic_map_reverse(isl_basic_map_copy(bmap));\n\ttest = isl_basic_map_apply_range(test, isl_basic_map_copy(bmap));\n\n\tspace = isl_basic_map_get_space(bmap);\n\tspace = isl_space_map_from_set(isl_space_range(space));\n\tid = isl_basic_map_identity(space);\n\n\tsv = isl_basic_map_is_subset(test, id);\n\n\tisl_basic_map_free(test);\n\tisl_basic_map_free(id);\n\n\treturn sv;\n}\n\n/* Check if the given map is obviously single-valued.\n */\nisl_bool isl_map_plain_is_single_valued(__isl_keep isl_map *map)\n{\n\tif (!map)\n\t\treturn isl_bool_error;\n\tif (map->n == 0)\n\t\treturn isl_bool_true;\n\tif (map->n >= 2)\n\t\treturn isl_bool_false;\n\n\treturn isl_basic_map_plain_is_single_valued(map->p[0]);\n}\n\n/* Check if the given map is single-valued.\n * We simply compute\n *\n *\tM \\circ M^-1\n *\n * and check if the result is a subset of the identity mapping.\n */\nisl_bool isl_map_is_single_valued(__isl_keep isl_map *map)\n{\n\tisl_space *space;\n\tisl_map *test;\n\tisl_map *id;\n\tisl_bool sv;\n\n\tsv = isl_map_plain_is_single_valued(map);\n\tif (sv < 0 || sv)\n\t\treturn sv;\n\n\ttest = isl_map_reverse(isl_map_copy(map));\n\ttest = isl_map_apply_range(test, isl_map_copy(map));\n\n\tspace = isl_space_map_from_set(isl_space_range(isl_map_get_space(map)));\n\tid = isl_map_identity(space);\n\n\tsv = isl_map_is_subset(test, id);\n\n\tisl_map_free(test);\n\tisl_map_free(id);\n\n\treturn sv;\n}\n\nisl_bool isl_map_is_injective(__isl_keep isl_map *map)\n{\n\tisl_bool in;\n\n\tmap = isl_map_copy(map);\n\tmap = isl_map_reverse(map);\n\tin = isl_map_is_single_valued(map);\n\tisl_map_free(map);\n\n\treturn in;\n}\n\n/* Check if the given map is obviously injective.\n */\nisl_bool isl_map_plain_is_injective(__isl_keep isl_map *map)\n{\n\tisl_bool in;\n\n\tmap = isl_map_copy(map);\n\tmap = isl_map_reverse(map);\n\tin = isl_map_plain_is_single_valued(map);\n\tisl_map_free(map);\n\n\treturn in;\n}\n\nisl_bool isl_map_is_bijective(__isl_keep isl_map *map)\n{\n\tisl_bool sv;\n\n\tsv = isl_map_is_single_valued(map);\n\tif (sv < 0 || !sv)\n\t\treturn sv;\n\n\treturn isl_map_is_injective(map);\n}\n\nisl_bool isl_set_is_singleton(__isl_keep isl_set *set)\n{\n\treturn isl_map_is_single_valued(set_to_map(set));\n}\n\n/* Does \"map\" only map elements to themselves?\n *\n * If the domain and range spaces are different, then \"map\"\n * is considered not to be an identity relation, even if it is empty.\n * Otherwise, construct the maximal identity relation and\n * check whether \"map\" is a subset of this relation.\n */\nisl_bool isl_map_is_identity(__isl_keep isl_map *map)\n{\n\tisl_map *id;\n\tisl_bool equal, is_identity;\n\n\tequal = isl_map_tuple_is_equal(map, isl_dim_in, map, isl_dim_out);\n\tif (equal < 0 || !equal)\n\t\treturn equal;\n\n\tid = isl_map_identity(isl_map_get_space(map));\n\tis_identity = isl_map_is_subset(map, id);\n\tisl_map_free(id);\n\n\treturn is_identity;\n}\n\nint isl_map_is_translation(__isl_keep isl_map *map)\n{\n\tint ok;\n\tisl_set *delta;\n\n\tdelta = isl_map_deltas(isl_map_copy(map));\n\tok = isl_set_is_singleton(delta);\n\tisl_set_free(delta);\n\n\treturn ok;\n}\n\nstatic int unique(isl_int *p, unsigned pos, unsigned len)\n{\n\tif (isl_seq_first_non_zero(p, pos) != -1)\n\t\treturn 0;\n\tif (isl_seq_first_non_zero(p + pos + 1, len - pos - 1) != -1)\n\t\treturn 0;\n\treturn 1;\n}\n\nisl_bool isl_basic_set_is_box(__isl_keep isl_basic_set *bset)\n{\n\tint i, j;\n\tisl_size nvar, n_div;\n\tunsigned ovar;\n\n\tn_div = isl_basic_set_dim(bset, isl_dim_div);\n\tif (n_div < 0)\n\t\treturn isl_bool_error;\n\tif (n_div != 0)\n\t\treturn isl_bool_false;\n\n\tnvar = isl_basic_set_dim(bset, isl_dim_set);\n\tif (nvar < 0)\n\t\treturn isl_bool_error;\n\tovar = isl_space_offset(bset->dim, isl_dim_set);\n\tfor (j = 0; j < nvar; ++j) {\n\t\tint lower = 0, upper = 0;\n\t\tfor (i = 0; i < bset->n_eq; ++i) {\n\t\t\tif (isl_int_is_zero(bset->eq[i][1 + ovar + j]))\n\t\t\t\tcontinue;\n\t\t\tif (!unique(bset->eq[i] + 1 + ovar, j, nvar))\n\t\t\t\treturn isl_bool_false;\n\t\t\tbreak;\n\t\t}\n\t\tif (i < bset->n_eq)\n\t\t\tcontinue;\n\t\tfor (i = 0; i < bset->n_ineq; ++i) {\n\t\t\tif (isl_int_is_zero(bset->ineq[i][1 + ovar + j]))\n\t\t\t\tcontinue;\n\t\t\tif (!unique(bset->ineq[i] + 1 + ovar, j, nvar))\n\t\t\t\treturn isl_bool_false;\n\t\t\tif (isl_int_is_pos(bset->ineq[i][1 + ovar + j]))\n\t\t\t\tlower = 1;\n\t\t\telse\n\t\t\t\tupper = 1;\n\t\t}\n\t\tif (!lower || !upper)\n\t\t\treturn isl_bool_false;\n\t}\n\n\treturn isl_bool_true;\n}\n\nisl_bool isl_set_is_box(__isl_keep isl_set *set)\n{\n\tif (!set)\n\t\treturn isl_bool_error;\n\tif (set->n != 1)\n\t\treturn isl_bool_false;\n\n\treturn isl_basic_set_is_box(set->p[0]);\n}\n\nisl_bool isl_basic_set_is_wrapping(__isl_keep isl_basic_set *bset)\n{\n\tif (!bset)\n\t\treturn isl_bool_error;\n\t\n\treturn isl_space_is_wrapping(bset->dim);\n}\n\nisl_bool isl_set_is_wrapping(__isl_keep isl_set *set)\n{\n\tif (!set)\n\t\treturn isl_bool_error;\n\t\n\treturn isl_space_is_wrapping(set->dim);\n}\n\n/* Modify the space of \"map\" through a call to \"change\".\n * If \"can_change\" is set (not NULL), then first call it to check\n * if the modification is allowed, printing the error message \"cannot_change\"\n * if it is not.\n */\nstatic __isl_give isl_map *isl_map_change_space(__isl_take isl_map *map,\n\tisl_bool (*can_change)(__isl_keep isl_map *map),\n\tconst char *cannot_change,\n\t__isl_give isl_space *(*change)(__isl_take isl_space *space))\n{\n\tisl_bool ok;\n\tisl_space *space;\n\n\tif (!map)\n\t\treturn NULL;\n\n\tok = can_change ? can_change(map) : isl_bool_true;\n\tif (ok < 0)\n\t\treturn isl_map_free(map);\n\tif (!ok)\n\t\tisl_die(isl_map_get_ctx(map), isl_error_invalid, cannot_change,\n\t\t\treturn isl_map_free(map));\n\n\tspace = change(isl_map_get_space(map));\n\tmap = isl_map_reset_space(map, space);\n\n\treturn map;\n}\n\n/* Is the domain of \"map\" a wrapped relation?\n */\nisl_bool isl_map_domain_is_wrapping(__isl_keep isl_map *map)\n{\n\tif (!map)\n\t\treturn isl_bool_error;\n\n\treturn isl_space_domain_is_wrapping(map->dim);\n}\n\n/* Does \"map\" have a wrapped relation in both domain and range?\n */\nisl_bool isl_map_is_product(__isl_keep isl_map *map)\n{\n\treturn isl_space_is_product(isl_map_peek_space(map));\n}\n\n/* Is the range of \"map\" a wrapped relation?\n */\nisl_bool isl_map_range_is_wrapping(__isl_keep isl_map *map)\n{\n\tif (!map)\n\t\treturn isl_bool_error;\n\n\treturn isl_space_range_is_wrapping(map->dim);\n}\n\n__isl_give isl_basic_set *isl_basic_map_wrap(__isl_take isl_basic_map *bmap)\n{\n\tisl_space *space;\n\n\tspace = isl_basic_map_take_space(bmap);\n\tspace = isl_space_wrap(space);\n\tbmap = isl_basic_map_restore_space(bmap, space);\n\n\tbmap = isl_basic_map_finalize(bmap);\n\n\treturn bset_from_bmap(bmap);\n}\n\n/* Given a map A -> B, return the set (A -> B).\n */\n__isl_give isl_set *isl_map_wrap(__isl_take isl_map *map)\n{\n\treturn isl_map_change_space(map, NULL, NULL, &isl_space_wrap);\n}\n\n__isl_give isl_basic_map *isl_basic_set_unwrap(__isl_take isl_basic_set *bset)\n{\n\tbset = isl_basic_set_cow(bset);\n\tif (!bset)\n\t\treturn NULL;\n\n\tbset->dim = isl_space_unwrap(bset->dim);\n\tif (!bset->dim)\n\t\tgoto error;\n\n\tbset = isl_basic_set_finalize(bset);\n\n\treturn bset_to_bmap(bset);\nerror:\n\tisl_basic_set_free(bset);\n\treturn NULL;\n}\n\n/* Given a set (A -> B), return the map A -> B.\n * Error out if \"set\" is not of the form (A -> B).\n */\n__isl_give isl_map *isl_set_unwrap(__isl_take isl_set *set)\n{\n\treturn isl_map_change_space(set, &isl_set_is_wrapping,\n\t\t\t\t    \"not a wrapping set\", &isl_space_unwrap);\n}\n\n__isl_give isl_basic_map *isl_basic_map_reset(__isl_take isl_basic_map *bmap,\n\tenum isl_dim_type type)\n{\n\tisl_space *space;\n\n\tspace = isl_basic_map_take_space(bmap);\n\tspace = isl_space_reset(space, type);\n\tbmap = isl_basic_map_restore_space(bmap, space);\n\n\tbmap = isl_basic_map_mark_final(bmap);\n\n\treturn bmap;\n}\n\n__isl_give isl_map *isl_map_reset(__isl_take isl_map *map,\n\tenum isl_dim_type type)\n{\n\tint i;\n\tisl_space *space;\n\n\tif (!map)\n\t\treturn NULL;\n\n\tif (!isl_space_is_named_or_nested(map->dim, type))\n\t\treturn map;\n\n\tmap = isl_map_cow(map);\n\tif (!map)\n\t\treturn NULL;\n\n\tfor (i = 0; i < map->n; ++i) {\n\t\tmap->p[i] = isl_basic_map_reset(map->p[i], type);\n\t\tif (!map->p[i])\n\t\t\tgoto error;\n\t}\n\n\tspace = isl_map_take_space(map);\n\tspace = isl_space_reset(space, type);\n\tmap = isl_map_restore_space(map, space);\n\n\treturn map;\nerror:\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n__isl_give isl_basic_map *isl_basic_map_flatten(__isl_take isl_basic_map *bmap)\n{\n\tisl_space *space;\n\n\tspace = isl_basic_map_take_space(bmap);\n\tspace = isl_space_flatten(space);\n\tbmap = isl_basic_map_restore_space(bmap, space);\n\n\tbmap = isl_basic_map_mark_final(bmap);\n\n\treturn bmap;\n}\n\n__isl_give isl_basic_set *isl_basic_set_flatten(__isl_take isl_basic_set *bset)\n{\n\treturn bset_from_bmap(isl_basic_map_flatten(bset_to_bmap(bset)));\n}\n\n__isl_give isl_basic_map *isl_basic_map_flatten_domain(\n\t__isl_take isl_basic_map *bmap)\n{\n\tisl_space *space;\n\n\tspace = isl_basic_map_take_space(bmap);\n\tspace = isl_space_flatten_domain(space);\n\tbmap = isl_basic_map_restore_space(bmap, space);\n\n\tbmap = isl_basic_map_mark_final(bmap);\n\n\treturn bmap;\n}\n\n__isl_give isl_basic_map *isl_basic_map_flatten_range(\n\t__isl_take isl_basic_map *bmap)\n{\n\tisl_space *space;\n\n\tspace = isl_basic_map_take_space(bmap);\n\tspace = isl_space_flatten_range(space);\n\tbmap = isl_basic_map_restore_space(bmap, space);\n\n\tbmap = isl_basic_map_mark_final(bmap);\n\n\treturn bmap;\n}\n\n/* Remove any internal structure from the spaces of domain and range of \"map\".\n */\n__isl_give isl_map *isl_map_flatten(__isl_take isl_map *map)\n{\n\tif (!map)\n\t\treturn NULL;\n\n\tif (!map->dim->nested[0] && !map->dim->nested[1])\n\t\treturn map;\n\n\treturn isl_map_change_space(map, NULL, NULL, &isl_space_flatten);\n}\n\n__isl_give isl_set *isl_set_flatten(__isl_take isl_set *set)\n{\n\treturn set_from_map(isl_map_flatten(set_to_map(set)));\n}\n\n__isl_give isl_map *isl_set_flatten_map(__isl_take isl_set *set)\n{\n\tisl_space *space, *flat_space;\n\tisl_map *map;\n\n\tspace = isl_set_get_space(set);\n\tflat_space = isl_space_flatten(isl_space_copy(space));\n\tmap = isl_map_identity(isl_space_join(isl_space_reverse(space),\n\t\t\t\t\t\tflat_space));\n\tmap = isl_map_intersect_domain(map, set);\n\n\treturn map;\n}\n\n/* Remove any internal structure from the space of the domain of \"map\".\n */\n__isl_give isl_map *isl_map_flatten_domain(__isl_take isl_map *map)\n{\n\tif (!map)\n\t\treturn NULL;\n\n\tif (!map->dim->nested[0])\n\t\treturn map;\n\n\treturn isl_map_change_space(map, NULL, NULL, &isl_space_flatten_domain);\n}\n\n/* Remove any internal structure from the space of the range of \"map\".\n */\n__isl_give isl_map *isl_map_flatten_range(__isl_take isl_map *map)\n{\n\tif (!map)\n\t\treturn NULL;\n\n\tif (!map->dim->nested[1])\n\t\treturn map;\n\n\treturn isl_map_change_space(map, NULL, NULL, &isl_space_flatten_range);\n}\n\n/* Reorder the dimensions of \"bmap\" according to the given dim_map\n * and set the dimension specification to \"space\" and\n * perform Gaussian elimination on the result.\n */\n__isl_give isl_basic_map *isl_basic_map_realign(__isl_take isl_basic_map *bmap,\n\t__isl_take isl_space *space, __isl_take struct isl_dim_map *dim_map)\n{\n\tisl_basic_map *res;\n\tunsigned flags;\n\tisl_size n_div;\n\n\tn_div = isl_basic_map_dim(bmap, isl_dim_div);\n\tif (n_div < 0 || !space || !dim_map)\n\t\tgoto error;\n\n\tflags = bmap->flags;\n\tISL_FL_CLR(flags, ISL_BASIC_MAP_FINAL);\n\tISL_FL_CLR(flags, ISL_BASIC_MAP_SORTED);\n\tISL_FL_CLR(flags, ISL_BASIC_MAP_NORMALIZED_DIVS);\n\tres = isl_basic_map_alloc_space(space, n_div, bmap->n_eq, bmap->n_ineq);\n\tres = isl_basic_map_add_constraints_dim_map(res, bmap, dim_map);\n\tif (res)\n\t\tres->flags = flags;\n\tres = isl_basic_map_gauss(res, NULL);\n\tres = isl_basic_map_finalize(res);\n\treturn res;\nerror:\n\tisl_dim_map_free(dim_map);\n\tisl_basic_map_free(bmap);\n\tisl_space_free(space);\n\treturn NULL;\n}\n\n/* Reorder the dimensions of \"map\" according to given reordering.\n */\n__isl_give isl_map *isl_map_realign(__isl_take isl_map *map,\n\t__isl_take isl_reordering *r)\n{\n\tint i;\n\tstruct isl_dim_map *dim_map;\n\n\tmap = isl_map_cow(map);\n\tdim_map = isl_dim_map_from_reordering(r);\n\tif (!map || !r || !dim_map)\n\t\tgoto error;\n\n\tfor (i = 0; i < map->n; ++i) {\n\t\tstruct isl_dim_map *dim_map_i;\n\t\tisl_space *space;\n\n\t\tdim_map_i = isl_dim_map_extend(dim_map, map->p[i]);\n\n\t\tspace = isl_reordering_get_space(r);\n\t\tmap->p[i] = isl_basic_map_realign(map->p[i], space, dim_map_i);\n\n\t\tif (!map->p[i])\n\t\t\tgoto error;\n\t}\n\n\tmap = isl_map_reset_space(map, isl_reordering_get_space(r));\n\tmap = isl_map_unmark_normalized(map);\n\n\tisl_reordering_free(r);\n\tisl_dim_map_free(dim_map);\n\treturn map;\nerror:\n\tisl_dim_map_free(dim_map);\n\tisl_map_free(map);\n\tisl_reordering_free(r);\n\treturn NULL;\n}\n\n__isl_give isl_set *isl_set_realign(__isl_take isl_set *set,\n\t__isl_take isl_reordering *r)\n{\n\treturn set_from_map(isl_map_realign(set_to_map(set), r));\n}\n\n__isl_give isl_map *isl_map_align_params(__isl_take isl_map *map,\n\t__isl_take isl_space *model)\n{\n\tisl_ctx *ctx;\n\tisl_bool aligned;\n\n\tif (!map || !model)\n\t\tgoto error;\n\n\tctx = isl_space_get_ctx(model);\n\tif (!isl_space_has_named_params(model))\n\t\tisl_die(ctx, isl_error_invalid,\n\t\t\t\"model has unnamed parameters\", goto error);\n\tif (isl_map_check_named_params(map) < 0)\n\t\tgoto error;\n\taligned = isl_map_space_has_equal_params(map, model);\n\tif (aligned < 0)\n\t\tgoto error;\n\tif (!aligned) {\n\t\tisl_reordering *exp;\n\n\t\texp = isl_parameter_alignment_reordering(map->dim, model);\n\t\texp = isl_reordering_extend_space(exp, isl_map_get_space(map));\n\t\tmap = isl_map_realign(map, exp);\n\t}\n\n\tisl_space_free(model);\n\treturn map;\nerror:\n\tisl_space_free(model);\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n__isl_give isl_set *isl_set_align_params(__isl_take isl_set *set,\n\t__isl_take isl_space *model)\n{\n\treturn isl_map_align_params(set, model);\n}\n\n/* Align the parameters of \"bmap\" to those of \"model\", introducing\n * additional parameters if needed.\n */\n__isl_give isl_basic_map *isl_basic_map_align_params(\n\t__isl_take isl_basic_map *bmap, __isl_take isl_space *model)\n{\n\tisl_ctx *ctx;\n\tisl_bool equal_params;\n\n\tif (!bmap || !model)\n\t\tgoto error;\n\n\tctx = isl_space_get_ctx(model);\n\tif (!isl_space_has_named_params(model))\n\t\tisl_die(ctx, isl_error_invalid,\n\t\t\t\"model has unnamed parameters\", goto error);\n\tif (isl_basic_map_check_named_params(bmap) < 0)\n\t\tgoto error;\n\tequal_params = isl_space_has_equal_params(bmap->dim, model);\n\tif (equal_params < 0)\n\t\tgoto error;\n\tif (!equal_params) {\n\t\tisl_reordering *exp;\n\t\tstruct isl_dim_map *dim_map;\n\n\t\texp = isl_parameter_alignment_reordering(bmap->dim, model);\n\t\texp = isl_reordering_extend_space(exp,\n\t\t\t\t\tisl_basic_map_get_space(bmap));\n\t\tdim_map = isl_dim_map_from_reordering(exp);\n\t\tbmap = isl_basic_map_realign(bmap,\n\t\t\t\t    isl_reordering_get_space(exp),\n\t\t\t\t    isl_dim_map_extend(dim_map, bmap));\n\t\tisl_reordering_free(exp);\n\t\tisl_dim_map_free(dim_map);\n\t}\n\n\tisl_space_free(model);\n\treturn bmap;\nerror:\n\tisl_space_free(model);\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n/* Do \"bset\" and \"space\" have the same parameters?\n */\nisl_bool isl_basic_set_space_has_equal_params(__isl_keep isl_basic_set *bset,\n\t__isl_keep isl_space *space)\n{\n\tisl_space *bset_space;\n\n\tbset_space = isl_basic_set_peek_space(bset);\n\treturn isl_space_has_equal_params(bset_space, space);\n}\n\n/* Do \"map\" and \"space\" have the same parameters?\n */\nisl_bool isl_map_space_has_equal_params(__isl_keep isl_map *map,\n\t__isl_keep isl_space *space)\n{\n\tisl_space *map_space;\n\n\tmap_space = isl_map_peek_space(map);\n\treturn isl_space_has_equal_params(map_space, space);\n}\n\n/* Do \"set\" and \"space\" have the same parameters?\n */\nisl_bool isl_set_space_has_equal_params(__isl_keep isl_set *set,\n\t__isl_keep isl_space *space)\n{\n\treturn isl_map_space_has_equal_params(set_to_map(set), space);\n}\n\n/* Align the parameters of \"bset\" to those of \"model\", introducing\n * additional parameters if needed.\n */\n__isl_give isl_basic_set *isl_basic_set_align_params(\n\t__isl_take isl_basic_set *bset, __isl_take isl_space *model)\n{\n\treturn isl_basic_map_align_params(bset, model);\n}\n\n/* Drop all parameters not referenced by \"map\".\n */\n__isl_give isl_map *isl_map_drop_unused_params(__isl_take isl_map *map)\n{\n\tint i;\n\tisl_size n;\n\n\tn = isl_map_dim(map, isl_dim_param);\n\tif (isl_map_check_named_params(map) < 0 || n < 0)\n\t\treturn isl_map_free(map);\n\n\tfor (i = n - 1; i >= 0; i--) {\n\t\tisl_bool involves;\n\n\t\tinvolves = isl_map_involves_dims(map, isl_dim_param, i, 1);\n\t\tif (involves < 0)\n\t\t\treturn isl_map_free(map);\n\t\tif (!involves)\n\t\t\tmap = isl_map_project_out(map, isl_dim_param, i, 1);\n\t}\n\n\treturn map;\n}\n\n/* Drop all parameters not referenced by \"set\".\n */\n__isl_give isl_set *isl_set_drop_unused_params(\n\t__isl_take isl_set *set)\n{\n\treturn set_from_map(isl_map_drop_unused_params(set_to_map(set)));\n}\n\n/* Drop all parameters not referenced by \"bmap\".\n */\n__isl_give isl_basic_map *isl_basic_map_drop_unused_params(\n\t__isl_take isl_basic_map *bmap)\n{\n\tisl_size nparam;\n\tint i;\n\n\tnparam = isl_basic_map_dim(bmap, isl_dim_param);\n\tif (nparam < 0 || isl_basic_map_check_named_params(bmap) < 0)\n\t\treturn isl_basic_map_free(bmap);\n\n\tfor (i = nparam - 1; i >= 0; i--) {\n\t\tisl_bool involves;\n\n\t\tinvolves = isl_basic_map_involves_dims(bmap,\n\t\t\t\t\t\t\tisl_dim_param, i, 1);\n\t\tif (involves < 0)\n\t\t\treturn isl_basic_map_free(bmap);\n\t\tif (!involves)\n\t\t\tbmap = isl_basic_map_drop(bmap, isl_dim_param, i, 1);\n\t}\n\n\treturn bmap;\n}\n\n/* Drop all parameters not referenced by \"bset\".\n */\n__isl_give isl_basic_set *isl_basic_set_drop_unused_params(\n\t__isl_take isl_basic_set *bset)\n{\n\treturn bset_from_bmap(isl_basic_map_drop_unused_params(\n\t\t\t\t\t\t\tbset_to_bmap(bset)));\n}\n\n/* Given a tuple of identifiers \"tuple\" in a space that corresponds\n * to that of \"set\", if any of those identifiers appear as parameters\n * in \"set\", then equate those parameters with the corresponding\n * set dimensions and project out the parameters.\n * The result therefore has no such parameters.\n */\nstatic __isl_give isl_set *equate_params(__isl_take isl_set *set,\n\t__isl_keep isl_multi_id *tuple)\n{\n\tint i;\n\tisl_size n;\n\tisl_space *set_space, *tuple_space;\n\n\tset_space = isl_set_peek_space(set);\n\ttuple_space = isl_multi_id_peek_space(tuple);\n\tif (isl_space_check_equal_tuples(tuple_space, set_space) < 0)\n\t\treturn isl_set_free(set);\n\tn = isl_multi_id_size(tuple);\n\tif (n < 0)\n\t\treturn isl_set_free(set);\n\tfor (i = 0; i < n; ++i) {\n\t\tisl_id *id;\n\t\tint pos;\n\n\t\tid = isl_multi_id_get_at(tuple, i);\n\t\tif (!id)\n\t\t\treturn isl_set_free(set);\n\t\tpos = isl_set_find_dim_by_id(set, isl_dim_param, id);\n\t\tisl_id_free(id);\n\t\tif (pos < 0)\n\t\t\tcontinue;\n\t\tset = isl_set_equate(set, isl_dim_param, pos, isl_dim_set, i);\n\t\tset = isl_set_project_out(set, isl_dim_param, pos, 1);\n\t}\n\treturn set;\n}\n\n/* Bind the set dimensions of \"set\" to parameters with identifiers\n * specified by \"tuple\", living in the same space as \"set\".\n *\n * If no parameters with these identifiers appear in \"set\" already,\n * then the set dimensions are simply reinterpreted as parameters.\n * Otherwise, the parameters are first equated to the corresponding\n * set dimensions.\n */\n__isl_give isl_set *isl_set_bind(__isl_take isl_set *set,\n\t__isl_take isl_multi_id *tuple)\n{\n\tisl_space *space;\n\n\tset = equate_params(set, tuple);\n\tspace = isl_set_get_space(set);\n\tspace = isl_space_bind_set(space, tuple);\n\tisl_multi_id_free(tuple);\n\tset = isl_set_reset_space(set, space);\n\n\treturn set;\n}\n\n/* Given a tuple of identifiers \"tuple\" in a space that corresponds\n * to the domain of \"map\", if any of those identifiers appear as parameters\n * in \"map\", then equate those parameters with the corresponding\n * input dimensions and project out the parameters.\n * The result therefore has no such parameters.\n */\nstatic __isl_give isl_map *map_equate_params(__isl_take isl_map *map,\n\t__isl_keep isl_multi_id *tuple)\n{\n\tint i;\n\tisl_size n;\n\tisl_space *map_space, *tuple_space;\n\n\tmap_space = isl_map_peek_space(map);\n\ttuple_space = isl_multi_id_peek_space(tuple);\n\tif (isl_space_check_domain_tuples(tuple_space, map_space) < 0)\n\t\treturn isl_map_free(map);\n\tn = isl_multi_id_size(tuple);\n\tif (n < 0)\n\t\treturn isl_map_free(map);\n\tfor (i = 0; i < n; ++i) {\n\t\tisl_id *id;\n\t\tint pos;\n\n\t\tid = isl_multi_id_get_at(tuple, i);\n\t\tif (!id)\n\t\t\treturn isl_map_free(map);\n\t\tpos = isl_map_find_dim_by_id(map, isl_dim_param, id);\n\t\tisl_id_free(id);\n\t\tif (pos < 0)\n\t\t\tcontinue;\n\t\tmap = isl_map_equate(map, isl_dim_param, pos, isl_dim_in, i);\n\t\tmap = isl_map_project_out(map, isl_dim_param, pos, 1);\n\t}\n\treturn map;\n}\n\n/* Bind the input dimensions of \"map\" to parameters with identifiers\n * specified by \"tuple\", living in the domain space of \"map\".\n *\n * If no parameters with these identifiers appear in \"map\" already,\n * then the input dimensions are simply reinterpreted as parameters.\n * Otherwise, the parameters are first equated to the corresponding\n * input dimensions.\n */\n__isl_give isl_set *isl_map_bind_domain(__isl_take isl_map *map,\n\t__isl_take isl_multi_id *tuple)\n{\n\tisl_space *space;\n\tisl_set *set;\n\n\tmap = map_equate_params(map, tuple);\n\tspace = isl_map_get_space(map);\n\tspace = isl_space_bind_map_domain(space, tuple);\n\tisl_multi_id_free(tuple);\n\tset = set_from_map(isl_map_reset_space(map, space));\n\n\treturn set;\n}\n\n/* Bind the output dimensions of \"map\" to parameters with identifiers\n * specified by \"tuple\", living in the range space of \"map\".\n *\n * Since binding is more easily implemented on the domain,\n * bind the input dimensions of the inverse of \"map\".\n */\n__isl_give isl_set *isl_map_bind_range(__isl_take isl_map *map,\n\t__isl_take isl_multi_id *tuple)\n{\n\treturn isl_map_bind_domain(isl_map_reverse(map), tuple);\n}\n\n/* Insert a domain corresponding to \"tuple\"\n * into the nullary or unary relation \"set\".\n * The result has an extra initial tuple and is therefore\n * either a unary or binary relation.\n * Any parameters with identifiers in \"tuple\" are reinterpreted\n * as the corresponding domain dimensions.\n */\nstatic __isl_give isl_map *unbind_params_insert_domain(\n\t__isl_take isl_set *set, __isl_take isl_multi_id *tuple)\n{\n\tisl_space *space;\n\tisl_reordering *r;\n\n\tspace = isl_set_peek_space(set);\n\tr = isl_reordering_unbind_params_insert_domain(space, tuple);\n\tisl_multi_id_free(tuple);\n\n\treturn isl_map_realign(set_to_map(set), r);\n}\n\n/* Construct a set with \"tuple\" as domain from the parameter domain \"set\".\n * Any parameters with identifiers in \"tuple\" are reinterpreted\n * as the corresponding set dimensions.\n */\n__isl_give isl_set *isl_set_unbind_params(__isl_take isl_set *set,\n\t__isl_take isl_multi_id *tuple)\n{\n\tisl_bool is_params;\n\n\tis_params = isl_set_is_params(set);\n\tif (is_params < 0)\n\t\tset = isl_set_free(set);\n\telse if (!is_params)\n\t\tisl_die(isl_set_get_ctx(set), isl_error_invalid,\n\t\t\t\"expecting parameter domain\", set = isl_set_free(set));\n\treturn set_from_map(unbind_params_insert_domain(set, tuple));\n}\n\n/* Check that \"set\" is a proper set, i.e., that it is not a parameter domain.\n */\nstatic isl_stat isl_set_check_is_set(__isl_keep isl_set *set)\n{\n\tisl_bool is_params;\n\n\tis_params = isl_set_is_params(set);\n\tif (is_params < 0)\n\t\treturn isl_stat_error;\n\telse if (is_params)\n\t\tisl_die(isl_set_get_ctx(set), isl_error_invalid,\n\t\t\t\"expecting proper set\", return isl_stat_error);\n\n\treturn isl_stat_ok;\n}\n\n/* Construct a map with \"domain\" as domain and \"set\" as range.\n * Any parameters with identifiers in \"domain\" are reinterpreted\n * as the corresponding domain dimensions.\n */\n__isl_give isl_map *isl_set_unbind_params_insert_domain(\n\t__isl_take isl_set *set, __isl_take isl_multi_id *domain)\n{\n\tif (isl_set_check_is_set(set) < 0)\n\t\tset = isl_set_free(set);\n\treturn unbind_params_insert_domain(set, domain);\n}\n\n/* Construct a map with \"domain\" as domain and \"set\" as range.\n */\n__isl_give isl_map *isl_set_insert_domain(__isl_take isl_set *set,\n\t__isl_take isl_space *domain)\n{\n\tisl_size dim;\n\tisl_space *space;\n\tisl_map *map;\n\n\tif (isl_set_check_is_set(set) < 0 || isl_space_check_is_set(domain) < 0)\n\t\tdomain = isl_space_free(domain);\n\tdim = isl_space_dim(domain, isl_dim_set);\n\tif (dim < 0)\n\t\tdomain = isl_space_free(domain);\n\tspace = isl_set_get_space(set);\n\tdomain = isl_space_replace_params(domain, space);\n\tspace = isl_space_map_from_domain_and_range(domain, space);\n\n\tmap = isl_map_from_range(set);\n\tmap = isl_map_add_dims(map, isl_dim_in, dim);\n\tmap = isl_map_reset_space(map, space);\n\n\treturn map;\n}\n\n__isl_give isl_mat *isl_basic_map_equalities_matrix(\n\t\t__isl_keep isl_basic_map *bmap, enum isl_dim_type c1,\n\t\tenum isl_dim_type c2, enum isl_dim_type c3,\n\t\tenum isl_dim_type c4, enum isl_dim_type c5)\n{\n\tenum isl_dim_type c[5] = { c1, c2, c3, c4, c5 };\n\tstruct isl_mat *mat;\n\tint i, j, k;\n\tint pos;\n\tisl_size total;\n\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tif (total < 0)\n\t\treturn NULL;\n\tmat = isl_mat_alloc(bmap->ctx, bmap->n_eq, total + 1);\n\tif (!mat)\n\t\treturn NULL;\n\tfor (i = 0; i < bmap->n_eq; ++i)\n\t\tfor (j = 0, pos = 0; j < 5; ++j) {\n\t\t\tint off = isl_basic_map_offset(bmap, c[j]);\n\t\t\tisl_size dim = isl_basic_map_dim(bmap, c[j]);\n\t\t\tif (dim < 0)\n\t\t\t\treturn isl_mat_free(mat);\n\t\t\tfor (k = 0; k < dim; ++k) {\n\t\t\t\tisl_int_set(mat->row[i][pos],\n\t\t\t\t\t    bmap->eq[i][off + k]);\n\t\t\t\t++pos;\n\t\t\t}\n\t\t}\n\n\treturn mat;\n}\n\n__isl_give isl_mat *isl_basic_map_inequalities_matrix(\n\t\t__isl_keep isl_basic_map *bmap, enum isl_dim_type c1,\n\t\tenum isl_dim_type c2, enum isl_dim_type c3,\n\t\tenum isl_dim_type c4, enum isl_dim_type c5)\n{\n\tenum isl_dim_type c[5] = { c1, c2, c3, c4, c5 };\n\tstruct isl_mat *mat;\n\tint i, j, k;\n\tint pos;\n\tisl_size total;\n\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tif (total < 0)\n\t\treturn NULL;\n\tmat = isl_mat_alloc(bmap->ctx, bmap->n_ineq, total + 1);\n\tif (!mat)\n\t\treturn NULL;\n\tfor (i = 0; i < bmap->n_ineq; ++i)\n\t\tfor (j = 0, pos = 0; j < 5; ++j) {\n\t\t\tint off = isl_basic_map_offset(bmap, c[j]);\n\t\t\tisl_size dim = isl_basic_map_dim(bmap, c[j]);\n\t\t\tif (dim < 0)\n\t\t\t\treturn isl_mat_free(mat);\n\t\t\tfor (k = 0; k < dim; ++k) {\n\t\t\t\tisl_int_set(mat->row[i][pos],\n\t\t\t\t\t    bmap->ineq[i][off + k]);\n\t\t\t\t++pos;\n\t\t\t}\n\t\t}\n\n\treturn mat;\n}\n\n__isl_give isl_basic_map *isl_basic_map_from_constraint_matrices(\n\t__isl_take isl_space *space,\n\t__isl_take isl_mat *eq, __isl_take isl_mat *ineq, enum isl_dim_type c1,\n\tenum isl_dim_type c2, enum isl_dim_type c3,\n\tenum isl_dim_type c4, enum isl_dim_type c5)\n{\n\tenum isl_dim_type c[5] = { c1, c2, c3, c4, c5 };\n\tisl_basic_map *bmap = NULL;\n\tisl_size dim;\n\tunsigned total;\n\tunsigned extra;\n\tint i, j, k, l;\n\tint pos;\n\n\tdim = isl_space_dim(space, isl_dim_all);\n\tif (dim < 0 || !eq || !ineq)\n\t\tgoto error;\n\n\tif (eq->n_col != ineq->n_col)\n\t\tisl_die(space->ctx, isl_error_invalid,\n\t\t\t\"equalities and inequalities matrices should have \"\n\t\t\t\"same number of columns\", goto error);\n\n\ttotal = 1 + dim;\n\n\tif (eq->n_col < total)\n\t\tisl_die(space->ctx, isl_error_invalid,\n\t\t\t\"number of columns too small\", goto error);\n\n\textra = eq->n_col - total;\n\n\tbmap = isl_basic_map_alloc_space(isl_space_copy(space), extra,\n\t\t\t\t       eq->n_row, ineq->n_row);\n\tif (!bmap)\n\t\tgoto error;\n\tfor (i = 0; i < extra; ++i) {\n\t\tk = isl_basic_map_alloc_div(bmap);\n\t\tif (k < 0)\n\t\t\tgoto error;\n\t\tisl_int_set_si(bmap->div[k][0], 0);\n\t}\n\tfor (i = 0; i < eq->n_row; ++i) {\n\t\tl = isl_basic_map_alloc_equality(bmap);\n\t\tif (l < 0)\n\t\t\tgoto error;\n\t\tfor (j = 0, pos = 0; j < 5; ++j) {\n\t\t\tint off = isl_basic_map_offset(bmap, c[j]);\n\t\t\tisl_size dim = isl_basic_map_dim(bmap, c[j]);\n\t\t\tif (dim < 0)\n\t\t\t\tgoto error;\n\t\t\tfor (k = 0; k < dim; ++k) {\n\t\t\t\tisl_int_set(bmap->eq[l][off + k], \n\t\t\t\t\t    eq->row[i][pos]);\n\t\t\t\t++pos;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < ineq->n_row; ++i) {\n\t\tl = isl_basic_map_alloc_inequality(bmap);\n\t\tif (l < 0)\n\t\t\tgoto error;\n\t\tfor (j = 0, pos = 0; j < 5; ++j) {\n\t\t\tint off = isl_basic_map_offset(bmap, c[j]);\n\t\t\tisl_size dim = isl_basic_map_dim(bmap, c[j]);\n\t\t\tif (dim < 0)\n\t\t\t\tgoto error;\n\t\t\tfor (k = 0; k < dim; ++k) {\n\t\t\t\tisl_int_set(bmap->ineq[l][off + k], \n\t\t\t\t\t    ineq->row[i][pos]);\n\t\t\t\t++pos;\n\t\t\t}\n\t\t}\n\t}\n\n\tisl_space_free(space);\n\tisl_mat_free(eq);\n\tisl_mat_free(ineq);\n\n\tbmap = isl_basic_map_simplify(bmap);\n\treturn isl_basic_map_finalize(bmap);\nerror:\n\tisl_space_free(space);\n\tisl_mat_free(eq);\n\tisl_mat_free(ineq);\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n__isl_give isl_mat *isl_basic_set_equalities_matrix(\n\t__isl_keep isl_basic_set *bset, enum isl_dim_type c1,\n\tenum isl_dim_type c2, enum isl_dim_type c3, enum isl_dim_type c4)\n{\n\treturn isl_basic_map_equalities_matrix(bset_to_bmap(bset),\n\t\t\t\t\t\tc1, c2, c3, c4, isl_dim_in);\n}\n\n__isl_give isl_mat *isl_basic_set_inequalities_matrix(\n\t__isl_keep isl_basic_set *bset, enum isl_dim_type c1,\n\tenum isl_dim_type c2, enum isl_dim_type c3, enum isl_dim_type c4)\n{\n\treturn isl_basic_map_inequalities_matrix(bset_to_bmap(bset),\n\t\t\t\t\t\t c1, c2, c3, c4, isl_dim_in);\n}\n\n__isl_give isl_basic_set *isl_basic_set_from_constraint_matrices(\n\t__isl_take isl_space *space,\n\t__isl_take isl_mat *eq, __isl_take isl_mat *ineq, enum isl_dim_type c1,\n\tenum isl_dim_type c2, enum isl_dim_type c3, enum isl_dim_type c4)\n{\n\tisl_basic_map *bmap;\n\tbmap = isl_basic_map_from_constraint_matrices(space, eq, ineq,\n\t\t\t\t\t\t   c1, c2, c3, c4, isl_dim_in);\n\treturn bset_from_bmap(bmap);\n}\n\nisl_bool isl_basic_map_can_zip(__isl_keep isl_basic_map *bmap)\n{\n\tif (!bmap)\n\t\treturn isl_bool_error;\n\t\n\treturn isl_space_can_zip(bmap->dim);\n}\n\nisl_bool isl_map_can_zip(__isl_keep isl_map *map)\n{\n\tif (!map)\n\t\treturn isl_bool_error;\n\t\n\treturn isl_space_can_zip(map->dim);\n}\n\n/* Given a basic map (A -> B) -> (C -> D), return the corresponding basic map\n * (A -> C) -> (B -> D).\n */\n__isl_give isl_basic_map *isl_basic_map_zip(__isl_take isl_basic_map *bmap)\n{\n\tunsigned pos;\n\tisl_size n_in;\n\tisl_size n1;\n\tisl_size n2;\n\n\tif (!bmap)\n\t\treturn NULL;\n\n\tif (!isl_basic_map_can_zip(bmap))\n\t\tisl_die(bmap->ctx, isl_error_invalid,\n\t\t\t\"basic map cannot be zipped\", goto error);\n\tn_in = isl_space_dim(bmap->dim->nested[0], isl_dim_in);\n\tn1 = isl_space_dim(bmap->dim->nested[0], isl_dim_out);\n\tn2 = isl_space_dim(bmap->dim->nested[1], isl_dim_in);\n\tif (n_in < 0 || n1 < 0 || n2 < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tpos = isl_basic_map_offset(bmap, isl_dim_in) + n_in;\n\tbmap = isl_basic_map_cow(bmap);\n\tbmap = isl_basic_map_swap_vars(bmap, pos, n1, n2);\n\tif (!bmap)\n\t\treturn NULL;\n\tbmap->dim = isl_space_zip(bmap->dim);\n\tif (!bmap->dim)\n\t\tgoto error;\n\tbmap = isl_basic_map_mark_final(bmap);\n\treturn bmap;\nerror:\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n/* Given a map (A -> B) -> (C -> D), return the corresponding map\n * (A -> C) -> (B -> D).\n */\n__isl_give isl_map *isl_map_zip(__isl_take isl_map *map)\n{\n\tif (!map)\n\t\treturn NULL;\n\n\tif (!isl_map_can_zip(map))\n\t\tisl_die(map->ctx, isl_error_invalid, \"map cannot be zipped\",\n\t\t\tgoto error);\n\n\treturn isl_map_transform(map, &isl_space_zip, &isl_basic_map_zip);\nerror:\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n/* Can we apply isl_basic_map_curry to \"bmap\"?\n * That is, does it have a nested relation in its domain?\n */\nisl_bool isl_basic_map_can_curry(__isl_keep isl_basic_map *bmap)\n{\n\tif (!bmap)\n\t\treturn isl_bool_error;\n\n\treturn isl_space_can_curry(bmap->dim);\n}\n\n/* Can we apply isl_map_curry to \"map\"?\n * That is, does it have a nested relation in its domain?\n */\nisl_bool isl_map_can_curry(__isl_keep isl_map *map)\n{\n\tif (!map)\n\t\treturn isl_bool_error;\n\n\treturn isl_space_can_curry(map->dim);\n}\n\n/* Given a basic map (A -> B) -> C, return the corresponding basic map\n * A -> (B -> C).\n */\n__isl_give isl_basic_map *isl_basic_map_curry(__isl_take isl_basic_map *bmap)\n{\n\n\tif (!bmap)\n\t\treturn NULL;\n\n\tif (!isl_basic_map_can_curry(bmap))\n\t\tisl_die(bmap->ctx, isl_error_invalid,\n\t\t\t\"basic map cannot be curried\", goto error);\n\tbmap = isl_basic_map_cow(bmap);\n\tif (!bmap)\n\t\treturn NULL;\n\tbmap->dim = isl_space_curry(bmap->dim);\n\tif (!bmap->dim)\n\t\tgoto error;\n\tbmap = isl_basic_map_mark_final(bmap);\n\treturn bmap;\nerror:\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n/* Given a map (A -> B) -> C, return the corresponding map\n * A -> (B -> C).\n */\n__isl_give isl_map *isl_map_curry(__isl_take isl_map *map)\n{\n\treturn isl_map_change_space(map, &isl_map_can_curry,\n\t\t\t\t    \"map cannot be curried\", &isl_space_curry);\n}\n\n/* Can isl_map_range_curry be applied to \"map\"?\n * That is, does it have a nested relation in its range,\n * the domain of which is itself a nested relation?\n */\nisl_bool isl_map_can_range_curry(__isl_keep isl_map *map)\n{\n\tif (!map)\n\t\treturn isl_bool_error;\n\n\treturn isl_space_can_range_curry(map->dim);\n}\n\n/* Given a map A -> ((B -> C) -> D), return the corresponding map\n * A -> (B -> (C -> D)).\n */\n__isl_give isl_map *isl_map_range_curry(__isl_take isl_map *map)\n{\n\treturn isl_map_change_space(map, &isl_map_can_range_curry,\n\t\t\t\t    \"map range cannot be curried\",\n\t\t\t\t    &isl_space_range_curry);\n}\n\n/* Can we apply isl_basic_map_uncurry to \"bmap\"?\n * That is, does it have a nested relation in its domain?\n */\nisl_bool isl_basic_map_can_uncurry(__isl_keep isl_basic_map *bmap)\n{\n\tif (!bmap)\n\t\treturn isl_bool_error;\n\n\treturn isl_space_can_uncurry(bmap->dim);\n}\n\n/* Can we apply isl_map_uncurry to \"map\"?\n * That is, does it have a nested relation in its domain?\n */\nisl_bool isl_map_can_uncurry(__isl_keep isl_map *map)\n{\n\tif (!map)\n\t\treturn isl_bool_error;\n\n\treturn isl_space_can_uncurry(map->dim);\n}\n\n/* Given a basic map A -> (B -> C), return the corresponding basic map\n * (A -> B) -> C.\n */\n__isl_give isl_basic_map *isl_basic_map_uncurry(__isl_take isl_basic_map *bmap)\n{\n\n\tif (!bmap)\n\t\treturn NULL;\n\n\tif (!isl_basic_map_can_uncurry(bmap))\n\t\tisl_die(bmap->ctx, isl_error_invalid,\n\t\t\t\"basic map cannot be uncurried\",\n\t\t\treturn isl_basic_map_free(bmap));\n\tbmap = isl_basic_map_cow(bmap);\n\tif (!bmap)\n\t\treturn NULL;\n\tbmap->dim = isl_space_uncurry(bmap->dim);\n\tif (!bmap->dim)\n\t\treturn isl_basic_map_free(bmap);\n\tbmap = isl_basic_map_mark_final(bmap);\n\treturn bmap;\n}\n\n/* Given a map A -> (B -> C), return the corresponding map\n * (A -> B) -> C.\n */\n__isl_give isl_map *isl_map_uncurry(__isl_take isl_map *map)\n{\n\treturn isl_map_change_space(map, &isl_map_can_uncurry,\n\t\t\t\t\"map cannot be uncurried\", &isl_space_uncurry);\n}\n\n__isl_give isl_set *isl_set_equate(__isl_take isl_set *set,\n\tenum isl_dim_type type1, int pos1, enum isl_dim_type type2, int pos2)\n{\n\treturn isl_map_equate(set, type1, pos1, type2, pos2);\n}\n\n/* Construct a basic map where the given dimensions are equal to each other.\n */\nstatic __isl_give isl_basic_map *equator(__isl_take isl_space *space,\n\tenum isl_dim_type type1, int pos1, enum isl_dim_type type2, int pos2)\n{\n\tisl_basic_map *bmap = NULL;\n\tint i;\n\tisl_size total;\n\n\ttotal = isl_space_dim(space, isl_dim_all);\n\tif (total < 0 ||\n\t    isl_space_check_range(space, type1, pos1, 1) < 0 ||\n\t    isl_space_check_range(space, type2, pos2, 1) < 0)\n\t\tgoto error;\n\n\tif (type1 == type2 && pos1 == pos2)\n\t\treturn isl_basic_map_universe(space);\n\n\tbmap = isl_basic_map_alloc_space(isl_space_copy(space), 0, 1, 0);\n\ti = isl_basic_map_alloc_equality(bmap);\n\tif (i < 0)\n\t\tgoto error;\n\tisl_seq_clr(bmap->eq[i], 1 + total);\n\tpos1 += isl_basic_map_offset(bmap, type1);\n\tpos2 += isl_basic_map_offset(bmap, type2);\n\tisl_int_set_si(bmap->eq[i][pos1], -1);\n\tisl_int_set_si(bmap->eq[i][pos2], 1);\n\tbmap = isl_basic_map_finalize(bmap);\n\tisl_space_free(space);\n\treturn bmap;\nerror:\n\tisl_space_free(space);\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n/* Add a constraint imposing that the given two dimensions are equal.\n */\n__isl_give isl_basic_map *isl_basic_map_equate(__isl_take isl_basic_map *bmap,\n\tenum isl_dim_type type1, int pos1, enum isl_dim_type type2, int pos2)\n{\n\tisl_basic_map *eq;\n\n\teq = equator(isl_basic_map_get_space(bmap), type1, pos1, type2, pos2);\n\n\tbmap = isl_basic_map_intersect(bmap, eq);\n\n\treturn bmap;\n}\n\n/* Add a constraint imposing that the given two dimensions are equal.\n */\n__isl_give isl_map *isl_map_equate(__isl_take isl_map *map,\n\tenum isl_dim_type type1, int pos1, enum isl_dim_type type2, int pos2)\n{\n\tisl_basic_map *bmap;\n\n\tbmap = equator(isl_map_get_space(map), type1, pos1, type2, pos2);\n\n\tmap = isl_map_intersect(map, isl_map_from_basic_map(bmap));\n\n\treturn map;\n}\n\n/* Add a constraint imposing that the given two dimensions have opposite values.\n */\n__isl_give isl_map *isl_map_oppose(__isl_take isl_map *map,\n\tenum isl_dim_type type1, int pos1, enum isl_dim_type type2, int pos2)\n{\n\tisl_basic_map *bmap = NULL;\n\tint i;\n\tisl_size total;\n\n\tif (isl_map_check_range(map, type1, pos1, 1) < 0)\n\t\treturn isl_map_free(map);\n\tif (isl_map_check_range(map, type2, pos2, 1) < 0)\n\t\treturn isl_map_free(map);\n\n\ttotal = isl_map_dim(map, isl_dim_all);\n\tif (total < 0)\n\t\treturn isl_map_free(map);\n\tbmap = isl_basic_map_alloc_space(isl_map_get_space(map), 0, 1, 0);\n\ti = isl_basic_map_alloc_equality(bmap);\n\tif (i < 0)\n\t\tgoto error;\n\tisl_seq_clr(bmap->eq[i], 1 + total);\n\tpos1 += isl_basic_map_offset(bmap, type1);\n\tpos2 += isl_basic_map_offset(bmap, type2);\n\tisl_int_set_si(bmap->eq[i][pos1], 1);\n\tisl_int_set_si(bmap->eq[i][pos2], 1);\n\tbmap = isl_basic_map_finalize(bmap);\n\n\tmap = isl_map_intersect(map, isl_map_from_basic_map(bmap));\n\n\treturn map;\nerror:\n\tisl_basic_map_free(bmap);\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n/* Construct a constraint imposing that the value of the first dimension is\n * greater than or equal to that of the second.\n */\nstatic __isl_give isl_constraint *constraint_order_ge(\n\t__isl_take isl_space *space, enum isl_dim_type type1, int pos1,\n\tenum isl_dim_type type2, int pos2)\n{\n\tisl_constraint *c;\n\n\tif (isl_space_check_range(space, type1, pos1, 1) < 0 ||\n\t    isl_space_check_range(space, type2, pos2, 1) < 0)\n\t\tspace = isl_space_free(space);\n\tif (!space)\n\t\treturn NULL;\n\n\tc = isl_constraint_alloc_inequality(isl_local_space_from_space(space));\n\n\tif (type1 == type2 && pos1 == pos2)\n\t\treturn c;\n\n\tc = isl_constraint_set_coefficient_si(c, type1, pos1, 1);\n\tc = isl_constraint_set_coefficient_si(c, type2, pos2, -1);\n\n\treturn c;\n}\n\n/* Add a constraint imposing that the value of the first dimension is\n * greater than or equal to that of the second.\n */\n__isl_give isl_basic_map *isl_basic_map_order_ge(__isl_take isl_basic_map *bmap,\n\tenum isl_dim_type type1, int pos1, enum isl_dim_type type2, int pos2)\n{\n\tisl_constraint *c;\n\tisl_space *space;\n\n\tif (type1 == type2 && pos1 == pos2)\n\t\treturn bmap;\n\tspace = isl_basic_map_get_space(bmap);\n\tc = constraint_order_ge(space, type1, pos1, type2, pos2);\n\tbmap = isl_basic_map_add_constraint(bmap, c);\n\n\treturn bmap;\n}\n\n/* Add a constraint imposing that the value of the first dimension is\n * greater than or equal to that of the second.\n */\n__isl_give isl_map *isl_map_order_ge(__isl_take isl_map *map,\n\tenum isl_dim_type type1, int pos1, enum isl_dim_type type2, int pos2)\n{\n\tisl_constraint *c;\n\tisl_space *space;\n\n\tif (type1 == type2 && pos1 == pos2)\n\t\treturn map;\n\tspace = isl_map_get_space(map);\n\tc = constraint_order_ge(space, type1, pos1, type2, pos2);\n\tmap = isl_map_add_constraint(map, c);\n\n\treturn map;\n}\n\n/* Add a constraint imposing that the value of the first dimension is\n * less than or equal to that of the second.\n */\n__isl_give isl_map *isl_map_order_le(__isl_take isl_map *map,\n\tenum isl_dim_type type1, int pos1, enum isl_dim_type type2, int pos2)\n{\n\treturn isl_map_order_ge(map, type2, pos2, type1, pos1);\n}\n\n/* Construct a basic map where the value of the first dimension is\n * greater than that of the second.\n */\nstatic __isl_give isl_basic_map *greator(__isl_take isl_space *space,\n\tenum isl_dim_type type1, int pos1, enum isl_dim_type type2, int pos2)\n{\n\tisl_basic_map *bmap = NULL;\n\tint i;\n\tisl_size total;\n\n\tif (isl_space_check_range(space, type1, pos1, 1) < 0 ||\n\t    isl_space_check_range(space, type2, pos2, 1) < 0)\n\t\tgoto error;\n\n\tif (type1 == type2 && pos1 == pos2)\n\t\treturn isl_basic_map_empty(space);\n\n\tbmap = isl_basic_map_alloc_space(space, 0, 0, 1);\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\ti = isl_basic_map_alloc_inequality(bmap);\n\tif (total < 0 || i < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tisl_seq_clr(bmap->ineq[i], 1 + total);\n\tpos1 += isl_basic_map_offset(bmap, type1);\n\tpos2 += isl_basic_map_offset(bmap, type2);\n\tisl_int_set_si(bmap->ineq[i][pos1], 1);\n\tisl_int_set_si(bmap->ineq[i][pos2], -1);\n\tisl_int_set_si(bmap->ineq[i][0], -1);\n\tbmap = isl_basic_map_finalize(bmap);\n\n\treturn bmap;\nerror:\n\tisl_space_free(space);\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n/* Add a constraint imposing that the value of the first dimension is\n * greater than that of the second.\n */\n__isl_give isl_basic_map *isl_basic_map_order_gt(__isl_take isl_basic_map *bmap,\n\tenum isl_dim_type type1, int pos1, enum isl_dim_type type2, int pos2)\n{\n\tisl_basic_map *gt;\n\n\tgt = greator(isl_basic_map_get_space(bmap), type1, pos1, type2, pos2);\n\n\tbmap = isl_basic_map_intersect(bmap, gt);\n\n\treturn bmap;\n}\n\n/* Add a constraint imposing that the value of the first dimension is\n * greater than that of the second.\n */\n__isl_give isl_map *isl_map_order_gt(__isl_take isl_map *map,\n\tenum isl_dim_type type1, int pos1, enum isl_dim_type type2, int pos2)\n{\n\tisl_basic_map *bmap;\n\n\tbmap = greator(isl_map_get_space(map), type1, pos1, type2, pos2);\n\n\tmap = isl_map_intersect(map, isl_map_from_basic_map(bmap));\n\n\treturn map;\n}\n\n/* Add a constraint imposing that the value of the first dimension is\n * smaller than that of the second.\n */\n__isl_give isl_map *isl_map_order_lt(__isl_take isl_map *map,\n\tenum isl_dim_type type1, int pos1, enum isl_dim_type type2, int pos2)\n{\n\treturn isl_map_order_gt(map, type2, pos2, type1, pos1);\n}\n\n__isl_give isl_aff *isl_basic_map_get_div(__isl_keep isl_basic_map *bmap,\n\tint pos)\n{\n\tisl_aff *div;\n\tisl_local_space *ls;\n\n\tif (!bmap)\n\t\treturn NULL;\n\n\tif (!isl_basic_map_divs_known(bmap))\n\t\tisl_die(isl_basic_map_get_ctx(bmap), isl_error_invalid,\n\t\t\t\"some divs are unknown\", return NULL);\n\n\tls = isl_basic_map_get_local_space(bmap);\n\tdiv = isl_local_space_get_div(ls, pos);\n\tisl_local_space_free(ls);\n\n\treturn div;\n}\n\n__isl_give isl_aff *isl_basic_set_get_div(__isl_keep isl_basic_set *bset,\n\tint pos)\n{\n\treturn isl_basic_map_get_div(bset, pos);\n}\n\n/* Plug in \"subs\" for dimension \"type\", \"pos\" of \"bset\".\n *\n * Let i be the dimension to replace and let \"subs\" be of the form\n *\n *\tf/d\n *\n * Any integer division with a non-zero coefficient for i,\n *\n *\tfloor((a i + g)/m)\n *\n * is replaced by\n *\n *\tfloor((a f + d g)/(m d))\n *\n * Constraints of the form\n *\n *\ta i + g\n *\n * are replaced by\n *\n *\ta f + d g\n *\n * We currently require that \"subs\" is an integral expression.\n * Handling rational expressions may require us to add stride constraints\n * as we do in isl_basic_set_preimage_multi_aff.\n */\n__isl_give isl_basic_set *isl_basic_set_substitute(\n\t__isl_take isl_basic_set *bset,\n\tenum isl_dim_type type, unsigned pos, __isl_keep isl_aff *subs)\n{\n\tint i;\n\tisl_int v;\n\tisl_ctx *ctx;\n\tisl_size n_div;\n\n\tif (bset && isl_basic_set_plain_is_empty(bset))\n\t\treturn bset;\n\n\tbset = isl_basic_set_cow(bset);\n\tif (!bset || !subs)\n\t\tgoto error;\n\n\tctx = isl_basic_set_get_ctx(bset);\n\tif (!isl_space_is_equal(bset->dim, subs->ls->dim))\n\t\tisl_die(ctx, isl_error_invalid,\n\t\t\t\"spaces don't match\", goto error);\n\tn_div = isl_local_space_dim(subs->ls, isl_dim_div);\n\tif (n_div < 0)\n\t\tgoto error;\n\tif (n_div != 0)\n\t\tisl_die(ctx, isl_error_unsupported,\n\t\t\t\"cannot handle divs yet\", goto error);\n\tif (!isl_int_is_one(subs->v->el[0]))\n\t\tisl_die(ctx, isl_error_invalid,\n\t\t\t\"can only substitute integer expressions\", goto error);\n\n\tpos += isl_basic_set_offset(bset, type);\n\n\tisl_int_init(v);\n\n\tfor (i = 0; i < bset->n_eq; ++i) {\n\t\tif (isl_int_is_zero(bset->eq[i][pos]))\n\t\t\tcontinue;\n\t\tisl_int_set(v, bset->eq[i][pos]);\n\t\tisl_int_set_si(bset->eq[i][pos], 0);\n\t\tisl_seq_combine(bset->eq[i], subs->v->el[0], bset->eq[i],\n\t\t\t\tv, subs->v->el + 1, subs->v->size - 1);\n\t}\n\n\tfor (i = 0; i < bset->n_ineq; ++i) {\n\t\tif (isl_int_is_zero(bset->ineq[i][pos]))\n\t\t\tcontinue;\n\t\tisl_int_set(v, bset->ineq[i][pos]);\n\t\tisl_int_set_si(bset->ineq[i][pos], 0);\n\t\tisl_seq_combine(bset->ineq[i], subs->v->el[0], bset->ineq[i],\n\t\t\t\tv, subs->v->el + 1, subs->v->size - 1);\n\t}\n\n\tfor (i = 0; i < bset->n_div; ++i) {\n\t\tif (isl_int_is_zero(bset->div[i][1 + pos]))\n\t\t\tcontinue;\n\t\tisl_int_set(v, bset->div[i][1 + pos]);\n\t\tisl_int_set_si(bset->div[i][1 + pos], 0);\n\t\tisl_seq_combine(bset->div[i] + 1,\n\t\t\t\tsubs->v->el[0], bset->div[i] + 1,\n\t\t\t\tv, subs->v->el + 1, subs->v->size - 1);\n\t\tisl_int_mul(bset->div[i][0], bset->div[i][0], subs->v->el[0]);\n\t}\n\n\tisl_int_clear(v);\n\n\tbset = isl_basic_set_simplify(bset);\n\treturn isl_basic_set_finalize(bset);\nerror:\n\tisl_basic_set_free(bset);\n\treturn NULL;\n}\n\n/* Plug in \"subs\" for dimension \"type\", \"pos\" of \"set\".\n */\n__isl_give isl_set *isl_set_substitute(__isl_take isl_set *set,\n\tenum isl_dim_type type, unsigned pos, __isl_keep isl_aff *subs)\n{\n\tint i;\n\n\tif (set && isl_set_plain_is_empty(set))\n\t\treturn set;\n\n\tset = isl_set_cow(set);\n\tif (!set || !subs)\n\t\tgoto error;\n\n\tfor (i = set->n - 1; i >= 0; --i) {\n\t\tset->p[i] = isl_basic_set_substitute(set->p[i], type, pos, subs);\n\t\tset = set_from_map(remove_if_empty(set_to_map(set), i));\n\t\tif (!set)\n\t\t\treturn NULL;\n\t}\n\n\treturn set;\nerror:\n\tisl_set_free(set);\n\treturn NULL;\n}\n\n/* Check if the range of \"ma\" is compatible with the domain or range\n * (depending on \"type\") of \"bmap\".\n */\nstatic isl_stat check_basic_map_compatible_range_multi_aff(\n\t__isl_keep isl_basic_map *bmap, enum isl_dim_type type,\n\t__isl_keep isl_multi_aff *ma)\n{\n\tisl_bool m;\n\tisl_space *ma_space;\n\n\tma_space = isl_multi_aff_get_space(ma);\n\n\tm = isl_space_has_equal_params(bmap->dim, ma_space);\n\tif (m < 0)\n\t\tgoto error;\n\tif (!m)\n\t\tisl_die(isl_basic_map_get_ctx(bmap), isl_error_invalid,\n\t\t\t\"parameters don't match\", goto error);\n\tm = isl_space_tuple_is_equal(bmap->dim, type, ma_space, isl_dim_out);\n\tif (m < 0)\n\t\tgoto error;\n\tif (!m)\n\t\tisl_die(isl_basic_map_get_ctx(bmap), isl_error_invalid,\n\t\t\t\"spaces don't match\", goto error);\n\n\tisl_space_free(ma_space);\n\treturn isl_stat_ok;\nerror:\n\tisl_space_free(ma_space);\n\treturn isl_stat_error;\n}\n\n/* Copy the divs from \"ma\" to \"bmap\", adding zeros for the \"n_before\"\n * coefficients before the transformed range of dimensions,\n * the \"n_after\" coefficients after the transformed range of dimensions\n * and the coefficients of the other divs in \"bmap\".\n */\nstatic __isl_give isl_basic_map *set_ma_divs(__isl_take isl_basic_map *bmap,\n\t__isl_keep isl_multi_aff *ma, int n_before, int n_after, int n_div)\n{\n\tint i;\n\tisl_size n_param;\n\tisl_size n_set;\n\tisl_local_space *ls;\n\n\tif (n_div == 0)\n\t\treturn bmap;\n\n\tls = isl_aff_get_domain_local_space(ma->u.p[0]);\n\tn_param = isl_local_space_dim(ls, isl_dim_param);\n\tn_set = isl_local_space_dim(ls, isl_dim_set);\n\tif (n_param < 0 || n_set < 0)\n\t\treturn isl_basic_map_free(bmap);\n\n\tfor (i = 0; i < n_div; ++i) {\n\t\tint o_bmap = 0, o_ls = 0;\n\n\t\tisl_seq_cpy(bmap->div[i], ls->div->row[i], 1 + 1 + n_param);\n\t\to_bmap += 1 + 1 + n_param;\n\t\to_ls += 1 + 1 + n_param;\n\t\tisl_seq_clr(bmap->div[i] + o_bmap, n_before);\n\t\to_bmap += n_before;\n\t\tisl_seq_cpy(bmap->div[i] + o_bmap,\n\t\t\t    ls->div->row[i] + o_ls, n_set);\n\t\to_bmap += n_set;\n\t\to_ls += n_set;\n\t\tisl_seq_clr(bmap->div[i] + o_bmap, n_after);\n\t\to_bmap += n_after;\n\t\tisl_seq_cpy(bmap->div[i] + o_bmap,\n\t\t\t    ls->div->row[i] + o_ls, n_div);\n\t\to_bmap += n_div;\n\t\to_ls += n_div;\n\t\tisl_seq_clr(bmap->div[i] + o_bmap, bmap->n_div - n_div);\n\t\tbmap = isl_basic_map_add_div_constraints(bmap, i);\n\t\tif (!bmap)\n\t\t\tgoto error;\n\t}\n\n\tisl_local_space_free(ls);\n\treturn bmap;\nerror:\n\tisl_local_space_free(ls);\n\treturn isl_basic_map_free(bmap);\n}\n\n/* How many stride constraints does \"ma\" enforce?\n * That is, how many of the affine expressions have a denominator\n * different from one?\n */\nstatic int multi_aff_strides(__isl_keep isl_multi_aff *ma)\n{\n\tint i;\n\tint strides = 0;\n\n\tfor (i = 0; i < ma->n; ++i)\n\t\tif (!isl_int_is_one(ma->u.p[i]->v->el[0]))\n\t\t\tstrides++;\n\n\treturn strides;\n}\n\n/* For each affine expression in ma of the form\n *\n *\tx_i = (f_i y + h_i)/m_i\n *\n * with m_i different from one, add a constraint to \"bmap\"\n * of the form\n *\n *\tf_i y + h_i = m_i alpha_i\n *\n * with alpha_i an additional existentially quantified variable.\n *\n * The input variables of \"ma\" correspond to a subset of the variables\n * of \"bmap\".  There are \"n_before\" variables in \"bmap\" before this\n * subset and \"n_after\" variables after this subset.\n * The integer divisions of the affine expressions in \"ma\" are assumed\n * to have been aligned.  There are \"n_div_ma\" of them and\n * they appear first in \"bmap\", straight after the \"n_after\" variables.\n */\nstatic __isl_give isl_basic_map *add_ma_strides(\n\t__isl_take isl_basic_map *bmap, __isl_keep isl_multi_aff *ma,\n\tint n_before, int n_after, int n_div_ma)\n{\n\tint i, k;\n\tint div;\n\tisl_size total;\n\tisl_size n_param;\n\tisl_size n_in;\n\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tn_param = isl_multi_aff_dim(ma, isl_dim_param);\n\tn_in = isl_multi_aff_dim(ma, isl_dim_in);\n\tif (total < 0 || n_param < 0 || n_in < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tfor (i = 0; i < ma->n; ++i) {\n\t\tint o_bmap = 0, o_ma = 1;\n\n\t\tif (isl_int_is_one(ma->u.p[i]->v->el[0]))\n\t\t\tcontinue;\n\t\tdiv = isl_basic_map_alloc_div(bmap);\n\t\tk = isl_basic_map_alloc_equality(bmap);\n\t\tif (div < 0 || k < 0)\n\t\t\tgoto error;\n\t\tisl_int_set_si(bmap->div[div][0], 0);\n\t\tisl_seq_cpy(bmap->eq[k] + o_bmap,\n\t\t\t    ma->u.p[i]->v->el + o_ma, 1 + n_param);\n\t\to_bmap += 1 + n_param;\n\t\to_ma += 1 + n_param;\n\t\tisl_seq_clr(bmap->eq[k] + o_bmap, n_before);\n\t\to_bmap += n_before;\n\t\tisl_seq_cpy(bmap->eq[k] + o_bmap,\n\t\t\t    ma->u.p[i]->v->el + o_ma, n_in);\n\t\to_bmap += n_in;\n\t\to_ma += n_in;\n\t\tisl_seq_clr(bmap->eq[k] + o_bmap, n_after);\n\t\to_bmap += n_after;\n\t\tisl_seq_cpy(bmap->eq[k] + o_bmap,\n\t\t\t    ma->u.p[i]->v->el + o_ma, n_div_ma);\n\t\to_bmap += n_div_ma;\n\t\to_ma += n_div_ma;\n\t\tisl_seq_clr(bmap->eq[k] + o_bmap, 1 + total - o_bmap);\n\t\tisl_int_neg(bmap->eq[k][1 + total], ma->u.p[i]->v->el[0]);\n\t\ttotal++;\n\t}\n\n\treturn bmap;\nerror:\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n/* Replace the domain or range space (depending on \"type) of \"space\" by \"set\".\n */\nstatic __isl_give isl_space *isl_space_set(__isl_take isl_space *space,\n\tenum isl_dim_type type, __isl_take isl_space *set)\n{\n\tif (type == isl_dim_in) {\n\t\tspace = isl_space_range(space);\n\t\tspace = isl_space_map_from_domain_and_range(set, space);\n\t} else {\n\t\tspace = isl_space_domain(space);\n\t\tspace = isl_space_map_from_domain_and_range(space, set);\n\t}\n\n\treturn space;\n}\n\n/* Compute the preimage of the domain or range (depending on \"type\")\n * of \"bmap\" under the function represented by \"ma\".\n * In other words, plug in \"ma\" in the domain or range of \"bmap\".\n * The result is a basic map that lives in the same space as \"bmap\"\n * except that the domain or range has been replaced by\n * the domain space of \"ma\".\n *\n * If bmap is represented by\n *\n *\tA(p) + S u + B x + T v + C(divs) >= 0,\n *\n * where u and x are input and output dimensions if type == isl_dim_out\n * while x and v are input and output dimensions if type == isl_dim_in,\n * and ma is represented by\n *\n *\tx = D(p) + F(y) + G(divs')\n *\n * then the result is\n *\n *\tA(p) + B D(p) + S u + B F(y) + T v + B G(divs') + C(divs) >= 0\n *\n * The divs in the input set are similarly adjusted.\n * In particular\n *\n *\tfloor((a_i(p) + s u + b_i x + t v + c_i(divs))/n_i)\n *\n * becomes\n *\n *\tfloor((a_i(p) + b_i D(p) + s u + b_i F(y) + t v +\n *\t\tB_i G(divs') + c_i(divs))/n_i)\n *\n * If bmap is not a rational map and if F(y) involves any denominators\n *\n *\tx_i = (f_i y + h_i)/m_i\n *\n * then additional constraints are added to ensure that we only\n * map back integer points.  That is we enforce\n *\n *\tf_i y + h_i = m_i alpha_i\n *\n * with alpha_i an additional existentially quantified variable.\n *\n * We first copy over the divs from \"ma\".\n * Then we add the modified constraints and divs from \"bmap\".\n * Finally, we add the stride constraints, if needed.\n */\n__isl_give isl_basic_map *isl_basic_map_preimage_multi_aff(\n\t__isl_take isl_basic_map *bmap, enum isl_dim_type type,\n\t__isl_take isl_multi_aff *ma)\n{\n\tint i, k;\n\tisl_space *space;\n\tisl_basic_map *res = NULL;\n\tisl_size n_before, n_after, n_div_bmap, n_div_ma;\n\tisl_int f, c1, c2, g;\n\tisl_bool rational;\n\tint strides;\n\n\tisl_int_init(f);\n\tisl_int_init(c1);\n\tisl_int_init(c2);\n\tisl_int_init(g);\n\n\tma = isl_multi_aff_align_divs(ma);\n\tif (!bmap || !ma)\n\t\tgoto error;\n\tif (check_basic_map_compatible_range_multi_aff(bmap, type, ma) < 0)\n\t\tgoto error;\n\n\tif (type == isl_dim_in) {\n\t\tn_before = 0;\n\t\tn_after = isl_basic_map_dim(bmap, isl_dim_out);\n\t} else {\n\t\tn_before = isl_basic_map_dim(bmap, isl_dim_in);\n\t\tn_after = 0;\n\t}\n\tn_div_bmap = isl_basic_map_dim(bmap, isl_dim_div);\n\tn_div_ma = ma->n ? isl_aff_dim(ma->u.p[0], isl_dim_div) : 0;\n\tif (n_before < 0 || n_after < 0 || n_div_bmap < 0 || n_div_ma < 0)\n\t\tgoto error;\n\n\tspace = isl_multi_aff_get_domain_space(ma);\n\tspace = isl_space_set(isl_basic_map_get_space(bmap), type, space);\n\trational = isl_basic_map_is_rational(bmap);\n\tstrides = rational ? 0 : multi_aff_strides(ma);\n\tres = isl_basic_map_alloc_space(space, n_div_ma + n_div_bmap + strides,\n\t\t\t    bmap->n_eq + strides, bmap->n_ineq + 2 * n_div_ma);\n\tif (rational)\n\t\tres = isl_basic_map_set_rational(res);\n\n\tfor (i = 0; i < n_div_ma + n_div_bmap; ++i)\n\t\tif (isl_basic_map_alloc_div(res) < 0)\n\t\t\tgoto error;\n\n\tres = set_ma_divs(res, ma, n_before, n_after, n_div_ma);\n\tif (!res)\n\t\tgoto error;\n\n\tfor (i = 0; i < bmap->n_eq; ++i) {\n\t\tk = isl_basic_map_alloc_equality(res);\n\t\tif (k < 0)\n\t\t\tgoto error;\n\t\tif (isl_seq_preimage(res->eq[k], bmap->eq[i], ma, n_before,\n\t\t\t\t    n_after, n_div_ma, n_div_bmap,\n\t\t\t\t    f, c1, c2, g, 0) < 0)\n\t\t\tgoto error;\n\t}\n\n\tfor (i = 0; i < bmap->n_ineq; ++i) {\n\t\tk = isl_basic_map_alloc_inequality(res);\n\t\tif (k < 0)\n\t\t\tgoto error;\n\t\tif (isl_seq_preimage(res->ineq[k], bmap->ineq[i], ma, n_before,\n\t\t\t\t    n_after, n_div_ma, n_div_bmap,\n\t\t\t\t    f, c1, c2, g, 0) < 0)\n\t\t\tgoto error;\n\t}\n\n\tfor (i = 0; i < bmap->n_div; ++i) {\n\t\tif (isl_int_is_zero(bmap->div[i][0])) {\n\t\t\tisl_int_set_si(res->div[n_div_ma + i][0], 0);\n\t\t\tcontinue;\n\t\t}\n\t\tif (isl_seq_preimage(res->div[n_div_ma + i], bmap->div[i], ma,\n\t\t\t\t    n_before, n_after, n_div_ma, n_div_bmap,\n\t\t\t\t    f, c1, c2, g, 1) < 0)\n\t\t\tgoto error;\n\t}\n\n\tif (strides)\n\t\tres = add_ma_strides(res, ma, n_before, n_after, n_div_ma);\n\n\tisl_int_clear(f);\n\tisl_int_clear(c1);\n\tisl_int_clear(c2);\n\tisl_int_clear(g);\n\tisl_basic_map_free(bmap);\n\tisl_multi_aff_free(ma);\n\tres = isl_basic_map_simplify(res);\n\treturn isl_basic_map_finalize(res);\nerror:\n\tisl_int_clear(f);\n\tisl_int_clear(c1);\n\tisl_int_clear(c2);\n\tisl_int_clear(g);\n\tisl_basic_map_free(bmap);\n\tisl_multi_aff_free(ma);\n\tisl_basic_map_free(res);\n\treturn NULL;\n}\n\n/* Compute the preimage of \"bset\" under the function represented by \"ma\".\n * In other words, plug in \"ma\" in \"bset\".  The result is a basic set\n * that lives in the domain space of \"ma\".\n */\n__isl_give isl_basic_set *isl_basic_set_preimage_multi_aff(\n\t__isl_take isl_basic_set *bset, __isl_take isl_multi_aff *ma)\n{\n\treturn isl_basic_map_preimage_multi_aff(bset, isl_dim_set, ma);\n}\n\n/* Compute the preimage of the domain of \"bmap\" under the function\n * represented by \"ma\".\n * In other words, plug in \"ma\" in the domain of \"bmap\".\n * The result is a basic map that lives in the same space as \"bmap\"\n * except that the domain has been replaced by the domain space of \"ma\".\n */\n__isl_give isl_basic_map *isl_basic_map_preimage_domain_multi_aff(\n\t__isl_take isl_basic_map *bmap, __isl_take isl_multi_aff *ma)\n{\n\treturn isl_basic_map_preimage_multi_aff(bmap, isl_dim_in, ma);\n}\n\n/* Compute the preimage of the range of \"bmap\" under the function\n * represented by \"ma\".\n * In other words, plug in \"ma\" in the range of \"bmap\".\n * The result is a basic map that lives in the same space as \"bmap\"\n * except that the range has been replaced by the domain space of \"ma\".\n */\n__isl_give isl_basic_map *isl_basic_map_preimage_range_multi_aff(\n\t__isl_take isl_basic_map *bmap, __isl_take isl_multi_aff *ma)\n{\n\treturn isl_basic_map_preimage_multi_aff(bmap, isl_dim_out, ma);\n}\n\n/* Check if the range of \"ma\" is compatible with the domain or range\n * (depending on \"type\") of \"map\".\n * Return isl_stat_error if anything is wrong.\n */\nstatic isl_stat check_map_compatible_range_multi_aff(\n\t__isl_keep isl_map *map, enum isl_dim_type type,\n\t__isl_keep isl_multi_aff *ma)\n{\n\tisl_bool m;\n\tisl_space *ma_space;\n\n\tma_space = isl_multi_aff_get_space(ma);\n\tm = isl_map_space_tuple_is_equal(map, type, ma_space, isl_dim_out);\n\tisl_space_free(ma_space);\n\tif (m < 0)\n\t\treturn isl_stat_error;\n\tif (!m)\n\t\tisl_die(isl_map_get_ctx(map), isl_error_invalid,\n\t\t\t\"spaces don't match\", return isl_stat_error);\n\treturn isl_stat_ok;\n}\n\n/* Compute the preimage of the domain or range (depending on \"type\")\n * of \"map\" under the function represented by \"ma\".\n * In other words, plug in \"ma\" in the domain or range of \"map\".\n * The result is a map that lives in the same space as \"map\"\n * except that the domain or range has been replaced by\n * the domain space of \"ma\".\n *\n * The parameters are assumed to have been aligned.\n */\nstatic __isl_give isl_map *map_preimage_multi_aff(__isl_take isl_map *map,\n\tenum isl_dim_type type, __isl_take isl_multi_aff *ma)\n{\n\tint i;\n\tisl_space *space;\n\n\tmap = isl_map_cow(map);\n\tma = isl_multi_aff_align_divs(ma);\n\tif (!map || !ma)\n\t\tgoto error;\n\tif (check_map_compatible_range_multi_aff(map, type, ma) < 0)\n\t\tgoto error;\n\n\tfor (i = 0; i < map->n; ++i) {\n\t\tmap->p[i] = isl_basic_map_preimage_multi_aff(map->p[i], type,\n\t\t\t\t\t\t\tisl_multi_aff_copy(ma));\n\t\tif (!map->p[i])\n\t\t\tgoto error;\n\t}\n\n\tspace = isl_multi_aff_get_domain_space(ma);\n\tspace = isl_space_set(isl_map_get_space(map), type, space);\n\n\tisl_space_free(isl_map_take_space(map));\n\tmap = isl_map_restore_space(map, space);\n\tif (!map)\n\t\tgoto error;\n\n\tisl_multi_aff_free(ma);\n\tif (map->n > 1)\n\t\tISL_F_CLR(map, ISL_MAP_DISJOINT);\n\tISL_F_CLR(map, ISL_SET_NORMALIZED);\n\treturn map;\nerror:\n\tisl_multi_aff_free(ma);\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n/* Compute the preimage of the domain or range (depending on \"type\")\n * of \"map\" under the function represented by \"ma\".\n * In other words, plug in \"ma\" in the domain or range of \"map\".\n * The result is a map that lives in the same space as \"map\"\n * except that the domain or range has been replaced by\n * the domain space of \"ma\".\n */\n__isl_give isl_map *isl_map_preimage_multi_aff(__isl_take isl_map *map,\n\tenum isl_dim_type type, __isl_take isl_multi_aff *ma)\n{\n\tisl_bool aligned;\n\n\tif (!map || !ma)\n\t\tgoto error;\n\n\taligned = isl_map_space_has_equal_params(map, ma->space);\n\tif (aligned < 0)\n\t\tgoto error;\n\tif (aligned)\n\t\treturn map_preimage_multi_aff(map, type, ma);\n\n\tif (isl_map_check_named_params(map) < 0)\n\t\tgoto error;\n\tif (!isl_space_has_named_params(ma->space))\n\t\tisl_die(map->ctx, isl_error_invalid,\n\t\t\t\"unaligned unnamed parameters\", goto error);\n\tmap = isl_map_align_params(map, isl_multi_aff_get_space(ma));\n\tma = isl_multi_aff_align_params(ma, isl_map_get_space(map));\n\n\treturn map_preimage_multi_aff(map, type, ma);\nerror:\n\tisl_multi_aff_free(ma);\n\treturn isl_map_free(map);\n}\n\n/* Compute the preimage of \"set\" under the function represented by \"ma\".\n * In other words, plug in \"ma\" in \"set\".  The result is a set\n * that lives in the domain space of \"ma\".\n */\n__isl_give isl_set *isl_set_preimage_multi_aff(__isl_take isl_set *set,\n\t__isl_take isl_multi_aff *ma)\n{\n\treturn isl_map_preimage_multi_aff(set, isl_dim_set, ma);\n}\n\n/* Compute the preimage of the domain of \"map\" under the function\n * represented by \"ma\".\n * In other words, plug in \"ma\" in the domain of \"map\".\n * The result is a map that lives in the same space as \"map\"\n * except that the domain has been replaced by the domain space of \"ma\".\n */\n__isl_give isl_map *isl_map_preimage_domain_multi_aff(__isl_take isl_map *map,\n\t__isl_take isl_multi_aff *ma)\n{\n\treturn isl_map_preimage_multi_aff(map, isl_dim_in, ma);\n}\n\n/* Compute the preimage of the range of \"map\" under the function\n * represented by \"ma\".\n * In other words, plug in \"ma\" in the range of \"map\".\n * The result is a map that lives in the same space as \"map\"\n * except that the range has been replaced by the domain space of \"ma\".\n */\n__isl_give isl_map *isl_map_preimage_range_multi_aff(__isl_take isl_map *map,\n\t__isl_take isl_multi_aff *ma)\n{\n\treturn isl_map_preimage_multi_aff(map, isl_dim_out, ma);\n}\n\n/* Compute the preimage of \"map\" under the function represented by \"pma\".\n * In other words, plug in \"pma\" in the domain or range of \"map\".\n * The result is a map that lives in the same space as \"map\",\n * except that the space of type \"type\" has been replaced by\n * the domain space of \"pma\".\n *\n * The parameters of \"map\" and \"pma\" are assumed to have been aligned.\n */\nstatic __isl_give isl_map *isl_map_preimage_pw_multi_aff_aligned(\n\t__isl_take isl_map *map, enum isl_dim_type type,\n\t__isl_take isl_pw_multi_aff *pma)\n{\n\tint i;\n\tisl_map *res;\n\n\tif (!pma)\n\t\tgoto error;\n\n\tif (pma->n == 0) {\n\t\tisl_pw_multi_aff_free(pma);\n\t\tres = isl_map_empty(isl_map_get_space(map));\n\t\tisl_map_free(map);\n\t\treturn res;\n\t}\n\n\tres = isl_map_preimage_multi_aff(isl_map_copy(map), type,\n\t\t\t\t\tisl_multi_aff_copy(pma->p[0].maff));\n\tif (type == isl_dim_in)\n\t\tres = isl_map_intersect_domain(res,\n\t\t\t\t\t\tisl_map_copy(pma->p[0].set));\n\telse\n\t\tres = isl_map_intersect_range(res,\n\t\t\t\t\t\tisl_map_copy(pma->p[0].set));\n\n\tfor (i = 1; i < pma->n; ++i) {\n\t\tisl_map *res_i;\n\n\t\tres_i = isl_map_preimage_multi_aff(isl_map_copy(map), type,\n\t\t\t\t\tisl_multi_aff_copy(pma->p[i].maff));\n\t\tif (type == isl_dim_in)\n\t\t\tres_i = isl_map_intersect_domain(res_i,\n\t\t\t\t\t\tisl_map_copy(pma->p[i].set));\n\t\telse\n\t\t\tres_i = isl_map_intersect_range(res_i,\n\t\t\t\t\t\tisl_map_copy(pma->p[i].set));\n\t\tres = isl_map_union(res, res_i);\n\t}\n\n\tisl_pw_multi_aff_free(pma);\n\tisl_map_free(map);\n\treturn res;\nerror:\n\tisl_pw_multi_aff_free(pma);\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n/* Compute the preimage of \"map\" under the function represented by \"pma\".\n * In other words, plug in \"pma\" in the domain or range of \"map\".\n * The result is a map that lives in the same space as \"map\",\n * except that the space of type \"type\" has been replaced by\n * the domain space of \"pma\".\n */\n__isl_give isl_map *isl_map_preimage_pw_multi_aff(__isl_take isl_map *map,\n\tenum isl_dim_type type, __isl_take isl_pw_multi_aff *pma)\n{\n\tisl_bool aligned;\n\n\tif (!map || !pma)\n\t\tgoto error;\n\n\taligned = isl_map_space_has_equal_params(map, pma->dim);\n\tif (aligned < 0)\n\t\tgoto error;\n\tif (aligned)\n\t\treturn isl_map_preimage_pw_multi_aff_aligned(map, type, pma);\n\n\tif (isl_map_check_named_params(map) < 0)\n\t\tgoto error;\n\tif (isl_pw_multi_aff_check_named_params(pma) < 0)\n\t\tgoto error;\n\tmap = isl_map_align_params(map, isl_pw_multi_aff_get_space(pma));\n\tpma = isl_pw_multi_aff_align_params(pma, isl_map_get_space(map));\n\n\treturn isl_map_preimage_pw_multi_aff_aligned(map, type, pma);\nerror:\n\tisl_pw_multi_aff_free(pma);\n\treturn isl_map_free(map);\n}\n\n/* Compute the preimage of \"set\" under the function represented by \"pma\".\n * In other words, plug in \"pma\" in \"set\".  The result is a set\n * that lives in the domain space of \"pma\".\n */\n__isl_give isl_set *isl_set_preimage_pw_multi_aff(__isl_take isl_set *set,\n\t__isl_take isl_pw_multi_aff *pma)\n{\n\treturn isl_map_preimage_pw_multi_aff(set, isl_dim_set, pma);\n}\n\n/* Compute the preimage of the domain of \"map\" under the function\n * represented by \"pma\".\n * In other words, plug in \"pma\" in the domain of \"map\".\n * The result is a map that lives in the same space as \"map\",\n * except that domain space has been replaced by the domain space of \"pma\".\n */\n__isl_give isl_map *isl_map_preimage_domain_pw_multi_aff(\n\t__isl_take isl_map *map, __isl_take isl_pw_multi_aff *pma)\n{\n\treturn isl_map_preimage_pw_multi_aff(map, isl_dim_in, pma);\n}\n\n/* Compute the preimage of the range of \"map\" under the function\n * represented by \"pma\".\n * In other words, plug in \"pma\" in the range of \"map\".\n * The result is a map that lives in the same space as \"map\",\n * except that range space has been replaced by the domain space of \"pma\".\n */\n__isl_give isl_map *isl_map_preimage_range_pw_multi_aff(\n\t__isl_take isl_map *map, __isl_take isl_pw_multi_aff *pma)\n{\n\treturn isl_map_preimage_pw_multi_aff(map, isl_dim_out, pma);\n}\n\n/* Compute the preimage of \"map\" under the function represented by \"mpa\".\n * In other words, plug in \"mpa\" in the domain or range of \"map\".\n * The result is a map that lives in the same space as \"map\",\n * except that the space of type \"type\" has been replaced by\n * the domain space of \"mpa\".\n *\n * If the map does not involve any constraints that refer to the\n * dimensions of the substituted space, then the only possible\n * effect of \"mpa\" on the map is to map the space to a different space.\n * We create a separate isl_multi_aff to effectuate this change\n * in order to avoid spurious splitting of the map along the pieces\n * of \"mpa\".\n * If \"mpa\" has a non-trivial explicit domain, however,\n * then the full substitution should be performed.\n */\n__isl_give isl_map *isl_map_preimage_multi_pw_aff(__isl_take isl_map *map,\n\tenum isl_dim_type type, __isl_take isl_multi_pw_aff *mpa)\n{\n\tisl_size n;\n\tisl_bool full;\n\tisl_pw_multi_aff *pma;\n\n\tn = isl_map_dim(map, type);\n\tif (n < 0 || !mpa)\n\t\tgoto error;\n\n\tfull = isl_map_involves_dims(map, type, 0, n);\n\tif (full >= 0 && !full)\n\t\tfull = isl_multi_pw_aff_has_non_trivial_domain(mpa);\n\tif (full < 0)\n\t\tgoto error;\n\tif (!full) {\n\t\tisl_space *space;\n\t\tisl_multi_aff *ma;\n\n\t\tspace = isl_multi_pw_aff_get_space(mpa);\n\t\tisl_multi_pw_aff_free(mpa);\n\t\tma = isl_multi_aff_zero(space);\n\t\treturn isl_map_preimage_multi_aff(map, type, ma);\n\t}\n\n\tpma = isl_pw_multi_aff_from_multi_pw_aff(mpa);\n\treturn isl_map_preimage_pw_multi_aff(map, type, pma);\nerror:\n\tisl_map_free(map);\n\tisl_multi_pw_aff_free(mpa);\n\treturn NULL;\n}\n\n/* Compute the preimage of \"map\" under the function represented by \"mpa\".\n * In other words, plug in \"mpa\" in the domain \"map\".\n * The result is a map that lives in the same space as \"map\",\n * except that domain space has been replaced by the domain space of \"mpa\".\n */\n__isl_give isl_map *isl_map_preimage_domain_multi_pw_aff(\n\t__isl_take isl_map *map, __isl_take isl_multi_pw_aff *mpa)\n{\n\treturn isl_map_preimage_multi_pw_aff(map, isl_dim_in, mpa);\n}\n\n/* Compute the preimage of \"set\" by the function represented by \"mpa\".\n * In other words, plug in \"mpa\" in \"set\".\n */\n__isl_give isl_set *isl_set_preimage_multi_pw_aff(__isl_take isl_set *set,\n\t__isl_take isl_multi_pw_aff *mpa)\n{\n\treturn isl_map_preimage_multi_pw_aff(set, isl_dim_set, mpa);\n}\n\n/* Return a copy of the equality constraints of \"bset\" as a matrix.\n */\n__isl_give isl_mat *isl_basic_set_extract_equalities(\n\t__isl_keep isl_basic_set *bset)\n{\n\tisl_ctx *ctx;\n\tisl_size total;\n\n\ttotal = isl_basic_set_dim(bset, isl_dim_all);\n\tif (total < 0)\n\t\treturn NULL;\n\n\tctx = isl_basic_set_get_ctx(bset);\n\treturn isl_mat_sub_alloc6(ctx, bset->eq, 0, bset->n_eq, 0, 1 + total);\n}\n\n/* Are the \"n\" \"coefficients\" starting at \"first\" of the integer division\n * expressions at position \"pos1\" in \"bmap1\" and \"pos2\" in \"bmap2\" equal\n * to each other?\n * The \"coefficient\" at position 0 is the denominator.\n * The \"coefficient\" at position 1 is the constant term.\n */\nisl_bool isl_basic_map_equal_div_expr_part(__isl_keep isl_basic_map *bmap1,\n\tint pos1, __isl_keep isl_basic_map *bmap2, int pos2,\n\tunsigned first, unsigned n)\n{\n\tif (isl_basic_map_check_range(bmap1, isl_dim_div, pos1, 1) < 0)\n\t\treturn isl_bool_error;\n\tif (isl_basic_map_check_range(bmap2, isl_dim_div, pos2, 1) < 0)\n\t\treturn isl_bool_error;\n\treturn isl_seq_eq(bmap1->div[pos1] + first,\n\t\t\t  bmap2->div[pos2] + first, n);\n}\n\n/* Are the integer division expressions at position \"pos1\" in \"bmap1\" and\n * \"pos2\" in \"bmap2\" equal to each other, except that the constant terms\n * are different?\n */\nisl_bool isl_basic_map_equal_div_expr_except_constant(\n\t__isl_keep isl_basic_map *bmap1, int pos1,\n\t__isl_keep isl_basic_map *bmap2, int pos2)\n{\n\tisl_bool equal;\n\tisl_size total, total2;\n\n\ttotal = isl_basic_map_dim(bmap1, isl_dim_all);\n\ttotal2 = isl_basic_map_dim(bmap2, isl_dim_all);\n\tif (total < 0 || total2 < 0)\n\t\treturn isl_bool_error;\n\tif (total != total2)\n\t\tisl_die(isl_basic_map_get_ctx(bmap1), isl_error_invalid,\n\t\t\t\"incomparable div expressions\", return isl_bool_error);\n\tequal = isl_basic_map_equal_div_expr_part(bmap1, pos1, bmap2, pos2,\n\t\t\t\t\t\t0, 1);\n\tif (equal < 0 || !equal)\n\t\treturn equal;\n\tequal = isl_basic_map_equal_div_expr_part(bmap1, pos1, bmap2, pos2,\n\t\t\t\t\t\t1, 1);\n\tif (equal < 0 || equal)\n\t\treturn isl_bool_not(equal);\n\treturn isl_basic_map_equal_div_expr_part(bmap1, pos1, bmap2, pos2,\n\t\t\t\t\t\t2, total);\n}\n\n/* Replace the numerator of the constant term of the integer division\n * expression at position \"div\" in \"bmap\" by \"value\".\n * The caller guarantees that this does not change the meaning\n * of the input.\n */\n__isl_give isl_basic_map *isl_basic_map_set_div_expr_constant_num_si_inplace(\n\t__isl_take isl_basic_map *bmap, int div, int value)\n{\n\tif (isl_basic_map_check_range(bmap, isl_dim_div, div, 1) < 0)\n\t\treturn isl_basic_map_free(bmap);\n\n\tisl_int_set_si(bmap->div[div][1], value);\n\n\treturn bmap;\n}\n\n/* Is the point \"inner\" internal to inequality constraint \"ineq\"\n * of \"bset\"?\n * The point is considered to be internal to the inequality constraint,\n * if it strictly lies on the positive side of the inequality constraint,\n * or if it lies on the constraint and the constraint is lexico-positive.\n */\nstatic isl_bool is_internal(__isl_keep isl_vec *inner,\n\t__isl_keep isl_basic_set *bset, int ineq)\n{\n\tisl_ctx *ctx;\n\tint pos;\n\tisl_size total;\n\n\tif (!inner || !bset)\n\t\treturn isl_bool_error;\n\n\tctx = isl_basic_set_get_ctx(bset);\n\tisl_seq_inner_product(inner->el, bset->ineq[ineq], inner->size,\n\t\t\t\t&ctx->normalize_gcd);\n\tif (!isl_int_is_zero(ctx->normalize_gcd))\n\t\treturn isl_int_is_nonneg(ctx->normalize_gcd);\n\n\ttotal = isl_basic_set_dim(bset, isl_dim_all);\n\tif (total < 0)\n\t\treturn isl_bool_error;\n\tpos = isl_seq_first_non_zero(bset->ineq[ineq] + 1, total);\n\treturn isl_int_is_pos(bset->ineq[ineq][1 + pos]);\n}\n\n/* Tighten the inequality constraints of \"bset\" that are outward with respect\n * to the point \"vec\".\n * That is, tighten the constraints that are not satisfied by \"vec\".\n *\n * \"vec\" is a point internal to some superset S of \"bset\" that is used\n * to make the subsets of S disjoint, by tightening one half of the constraints\n * that separate two subsets.  In particular, the constraints of S\n * are all satisfied by \"vec\" and should not be tightened.\n * Of the internal constraints, those that have \"vec\" on the outside\n * are tightened.  The shared facet is included in the adjacent subset\n * with the opposite constraint.\n * For constraints that saturate \"vec\", this criterion cannot be used\n * to determine which of the two sides should be tightened.\n * Instead, the sign of the first non-zero coefficient is used\n * to make this choice.  Note that this second criterion is never used\n * on the constraints of S since \"vec\" is interior to \"S\".\n */\n__isl_give isl_basic_set *isl_basic_set_tighten_outward(\n\t__isl_take isl_basic_set *bset, __isl_keep isl_vec *vec)\n{\n\tint j;\n\n\tbset = isl_basic_set_cow(bset);\n\tif (!bset)\n\t\treturn NULL;\n\tfor (j = 0; j < bset->n_ineq; ++j) {\n\t\tisl_bool internal;\n\n\t\tinternal = is_internal(vec, bset, j);\n\t\tif (internal < 0)\n\t\t\treturn isl_basic_set_free(bset);\n\t\tif (internal)\n\t\t\tcontinue;\n\t\tisl_int_sub_ui(bset->ineq[j][0], bset->ineq[j][0], 1);\n\t}\n\n\treturn bset;\n}\n\n/* Replace the variables x of type \"type\" starting at \"first\" in \"bmap\"\n * by x' with x = M x' with M the matrix trans.\n * That is, replace the corresponding coefficients c by c M.\n *\n * The transformation matrix should be a square matrix.\n */\n__isl_give isl_basic_map *isl_basic_map_transform_dims(\n\t__isl_take isl_basic_map *bmap, enum isl_dim_type type, unsigned first,\n\t__isl_take isl_mat *trans)\n{\n\tunsigned pos;\n\n\tbmap = isl_basic_map_cow(bmap);\n\tif (!bmap || !trans)\n\t\tgoto error;\n\n\tif (trans->n_row != trans->n_col)\n\t\tisl_die(trans->ctx, isl_error_invalid,\n\t\t\t\"expecting square transformation matrix\", goto error);\n\tif (isl_basic_map_check_range(bmap, type, first, trans->n_row) < 0)\n\t\tgoto error;\n\n\tpos = isl_basic_map_offset(bmap, type) + first;\n\n\tif (isl_mat_sub_transform(bmap->eq, bmap->n_eq, pos,\n\t\t\tisl_mat_copy(trans)) < 0)\n\t\tgoto error;\n\tif (isl_mat_sub_transform(bmap->ineq, bmap->n_ineq, pos,\n\t\t      isl_mat_copy(trans)) < 0)\n\t\tgoto error;\n\tif (isl_mat_sub_transform(bmap->div, bmap->n_div, 1 + pos,\n\t\t      isl_mat_copy(trans)) < 0)\n\t\tgoto error;\n\n\tISL_F_CLR(bmap, ISL_BASIC_MAP_SORTED);\n\tISL_F_CLR(bmap, ISL_BASIC_MAP_NORMALIZED_DIVS);\n\n\tisl_mat_free(trans);\n\treturn bmap;\nerror:\n\tisl_mat_free(trans);\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n/* Replace the variables x of type \"type\" starting at \"first\" in \"bset\"\n * by x' with x = M x' with M the matrix trans.\n * That is, replace the corresponding coefficients c by c M.\n *\n * The transformation matrix should be a square matrix.\n */\n__isl_give isl_basic_set *isl_basic_set_transform_dims(\n\t__isl_take isl_basic_set *bset, enum isl_dim_type type, unsigned first,\n\t__isl_take isl_mat *trans)\n{\n\treturn isl_basic_map_transform_dims(bset, type, first, trans);\n}\n"}, "3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/ctx.h", "content": "/*\n * Copyright 2008-2009 Katholieke Universiteit Leuven\n *\n * Use of this software is governed by the MIT license\n *\n * Written by Sven Verdoolaege, K.U.Leuven, Departement\n * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium\n */\n\n#ifndef ISL_CTX_H\n#define ISL_CTX_H\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include <isl/arg.h>\n\n#ifndef __isl_give\n#define __isl_give\n#endif\n#ifndef __isl_take\n#define __isl_take\n#endif\n#ifndef __isl_keep\n#define __isl_keep\n#endif\n#ifndef __isl_null\n#define __isl_null\n#endif\n#ifndef __isl_export\n#define __isl_export\n#endif\n#ifndef __isl_overload\n#define __isl_overload\n#endif\n#ifndef __isl_constructor\n#define __isl_constructor\n#endif\n#ifndef __isl_subclass\n#define __isl_subclass(super)\n#endif\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif\n\n/* Nearly all isa functions require a struct isl_ctx allocated using\n * isl_ctx_alloc.  This ctx contains (or will contain) options that\n * control the behavior of the library and some caches.\n *\n * An object allocated within a given ctx should never be used inside\n * another ctx.  Functions for moving objects from one ctx to another\n * will be added as the need arises.\n *\n * A given context should only be used inside a single thread.\n * A global context for synchronization between different threads\n * as well as functions for moving a context to a different thread\n * will be added as the need arises.\n *\n * If anything goes wrong (out of memory, failed assertion), then\n * the library will currently simply abort.  This will be made\n * configurable in the future.\n * Users of the library should expect functions that return\n * a pointer to a structure, to return NULL, indicating failure.\n * Any function accepting a pointer to a structure will treat\n * a NULL argument as a failure, resulting in the function freeing\n * the remaining structures (if any) and returning NULL itself\n * (in case of pointer return type).\n * The only exception is the isl_ctx argument, which should never be NULL.\n */\nstruct isl_stats {\n\tlong\tgbr_solved_lps;\n};\nenum isl_error {\n\tisl_error_none = 0,\n\tisl_error_abort,\n\tisl_error_alloc,\n\tisl_error_unknown,\n\tisl_error_internal,\n\tisl_error_invalid,\n\tisl_error_quota,\n\tisl_error_unsupported\n};\ntypedef enum {\n\tisl_stat_error = -1,\n\tisl_stat_ok = 0\n} isl_stat;\nisl_stat isl_stat_non_null(void *obj);\ntypedef enum {\n\tisl_bool_error = -1,\n\tisl_bool_false = 0,\n\tisl_bool_true = 1\n} isl_bool;\nisl_bool isl_bool_not(isl_bool b);\nisl_bool isl_bool_ok(int b);\ntypedef int\tisl_size;\n#define isl_size_error\t((int) -1)\nstruct isl_ctx;\ntypedef struct isl_ctx isl_ctx;\n\n/* Some helper macros */\n\n#if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 1)\n#define ISL_DEPRECATED\t__attribute__((__deprecated__))\n#else\n#define ISL_DEPRECATED\n#endif\n\n#define ISL_FL_INIT(l, f)   (l) = (f)               /* Specific flags location. */\n#define ISL_FL_SET(l, f)    ((l) |= (f))\n#define ISL_FL_CLR(l, f)    ((l) &= ~(f))\n#define ISL_FL_ISSET(l, f)  (!!((l) & (f)))\n\n#define ISL_F_INIT(p, f)    ISL_FL_INIT((p)->flags, f)  /* Structure element flags. */\n#define ISL_F_SET(p, f)     ISL_FL_SET((p)->flags, f)\n#define ISL_F_CLR(p, f)     ISL_FL_CLR((p)->flags, f)\n#define ISL_F_ISSET(p, f)   ISL_FL_ISSET((p)->flags, f)\n\nvoid *isl_malloc_or_die(isl_ctx *ctx, size_t size);\nvoid *isl_calloc_or_die(isl_ctx *ctx, size_t nmemb, size_t size);\nvoid *isl_realloc_or_die(isl_ctx *ctx, void *ptr, size_t size);\n\n#define isl_alloc(ctx,type,size)\t((type *)isl_malloc_or_die(ctx, size))\n#define isl_calloc(ctx,type,size)\t((type *)isl_calloc_or_die(ctx,\\\n\t\t\t\t\t\t\t\t    1, size))\n#define isl_realloc(ctx,ptr,type,size)\t((type *)isl_realloc_or_die(ctx,\\\n\t\t\t\t\t\t\t\t    ptr, size))\n#define isl_alloc_type(ctx,type)\tisl_alloc(ctx,type,sizeof(type))\n#define isl_calloc_type(ctx,type)\tisl_calloc(ctx,type,sizeof(type))\n#define isl_realloc_type(ctx,ptr,type)\tisl_realloc(ctx,ptr,type,sizeof(type))\n#define isl_alloc_array(ctx,type,n)\tisl_alloc(ctx,type,(n)*sizeof(type))\n#define isl_calloc_array(ctx,type,n)\t((type *)isl_calloc_or_die(ctx,\\\n\t\t\t\t\t\t\t    n, sizeof(type)))\n#define isl_realloc_array(ctx,ptr,type,n) \\\n\t\t\t\t    isl_realloc(ctx,ptr,type,(n)*sizeof(type))\n\n#define isl_die(ctx,errno,msg,code)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tisl_handle_error(ctx, errno, msg, __FILE__, __LINE__);\t\\\n\t\tcode;\t\t\t\t\t\t\t\\\n\t} while (0)\n\nvoid isl_handle_error(isl_ctx *ctx, enum isl_error error, const char *msg,\n\tconst char *file, int line);\n\n#define isl_assert4(ctx,test,code,errno)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (test)\t\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\tisl_die(ctx, errno, \"Assertion \\\"\" #test \"\\\" failed\", code);\t\\\n\t} while (0)\n#define isl_assert(ctx,test,code)\t\t\t\t\t\\\n\tisl_assert4(ctx,test,code,isl_error_unknown)\n\n#define isl_min(a,b)\t\t\t((a < b) ? (a) : (b))\n\n/* struct isl_ctx functions */\n\nstruct isl_options *isl_ctx_options(isl_ctx *ctx);\n\nisl_ctx *isl_ctx_alloc_with_options(struct isl_args *args,\n\t__isl_take void *opt);\nisl_ctx *isl_ctx_alloc(void);\nvoid *isl_ctx_peek_options(isl_ctx *ctx, struct isl_args *args);\nint isl_ctx_parse_options(isl_ctx *ctx, int argc, char **argv, unsigned flags);\nvoid isl_ctx_ref(struct isl_ctx *ctx);\nvoid isl_ctx_deref(struct isl_ctx *ctx);\nvoid isl_ctx_free(isl_ctx *ctx);\n\nvoid isl_ctx_abort(isl_ctx *ctx);\nvoid isl_ctx_resume(isl_ctx *ctx);\nint isl_ctx_aborted(isl_ctx *ctx);\n\nvoid isl_ctx_set_max_operations(isl_ctx *ctx, unsigned long max_operations);\nunsigned long isl_ctx_get_max_operations(isl_ctx *ctx);\nvoid isl_ctx_reset_operations(isl_ctx *ctx);\n\n#define ISL_ARG_CTX_DECL(prefix,st,args)\t\t\t\t\\\nst *isl_ctx_peek_ ## prefix(isl_ctx *ctx);\n\n#define ISL_ARG_CTX_DEF(prefix,st,args)\t\t\t\t\t\\\nst *isl_ctx_peek_ ## prefix(isl_ctx *ctx)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn (st *)isl_ctx_peek_options(ctx, &(args));\t\t\\\n}\n\n#define ISL_CTX_GET_INT_DEF(prefix,st,args,field)\t\t\t\\\nint prefix ## _get_ ## field(isl_ctx *ctx)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tst *options;\t\t\t\t\t\t\t\\\n\toptions = isl_ctx_peek_ ## prefix(ctx);\t\t\t\t\\\n\tif (!options)\t\t\t\t\t\t\t\\\n\t\tisl_die(ctx, isl_error_invalid,\t\t\t\t\\\n\t\t\t\"isl_ctx does not reference \" #prefix,\t\t\\\n\t\t\treturn -1);\t\t\t\t\t\\\n\treturn options->field;\t\t\t\t\t\t\\\n}\n\n#define ISL_CTX_SET_INT_DEF(prefix,st,args,field)\t\t\t\\\nisl_stat prefix ## _set_ ## field(isl_ctx *ctx, int val)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tst *options;\t\t\t\t\t\t\t\\\n\toptions = isl_ctx_peek_ ## prefix(ctx);\t\t\t\t\\\n\tif (!options)\t\t\t\t\t\t\t\\\n\t\tisl_die(ctx, isl_error_invalid,\t\t\t\t\\\n\t\t\t\"isl_ctx does not reference \" #prefix,\t\t\\\n\t\t\treturn isl_stat_error);\t\t\t\t\\\n\toptions->field = val;\t\t\t\t\t\t\\\n\treturn isl_stat_ok;\t\t\t\t\t\t\\\n}\n\n#define ISL_CTX_GET_STR_DEF(prefix,st,args,field)\t\t\t\\\nconst char *prefix ## _get_ ## field(isl_ctx *ctx)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tst *options;\t\t\t\t\t\t\t\\\n\toptions = isl_ctx_peek_ ## prefix(ctx);\t\t\t\t\\\n\tif (!options)\t\t\t\t\t\t\t\\\n\t\tisl_die(ctx, isl_error_invalid,\t\t\t\t\\\n\t\t\t\"isl_ctx does not reference \" #prefix,\t\t\\\n\t\t\treturn NULL);\t\t\t\t\t\\\n\treturn options->field;\t\t\t\t\t\t\\\n}\n\n#define ISL_CTX_SET_STR_DEF(prefix,st,args,field)\t\t\t\\\nisl_stat prefix ## _set_ ## field(isl_ctx *ctx, const char *val)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tst *options;\t\t\t\t\t\t\t\\\n\toptions = isl_ctx_peek_ ## prefix(ctx);\t\t\t\t\\\n\tif (!options)\t\t\t\t\t\t\t\\\n\t\tisl_die(ctx, isl_error_invalid,\t\t\t\t\\\n\t\t\t\"isl_ctx does not reference \" #prefix,\t\t\\\n\t\t\treturn isl_stat_error);\t\t\t\t\\\n\tif (!val)\t\t\t\t\t\t\t\\\n\t\treturn isl_stat_error;\t\t\t\t\t\\\n\tfree(options->field);\t\t\t\t\t\t\\\n\toptions->field = strdup(val);\t\t\t\t\t\\\n\tif (!options->field)\t\t\t\t\t\t\\\n\t\treturn isl_stat_error;\t\t\t\t\t\\\n\treturn isl_stat_ok;\t\t\t\t\t\t\\\n}\n\n#define ISL_CTX_GET_BOOL_DEF(prefix,st,args,field)\t\t\t\\\n\tISL_CTX_GET_INT_DEF(prefix,st,args,field)\n\n#define ISL_CTX_SET_BOOL_DEF(prefix,st,args,field)\t\t\t\\\n\tISL_CTX_SET_INT_DEF(prefix,st,args,field)\n\n#define ISL_CTX_GET_CHOICE_DEF(prefix,st,args,field)\t\t\t\\\n\tISL_CTX_GET_INT_DEF(prefix,st,args,field)\n\n#define ISL_CTX_SET_CHOICE_DEF(prefix,st,args,field)\t\t\t\\\n\tISL_CTX_SET_INT_DEF(prefix,st,args,field)\n\nenum isl_error isl_ctx_last_error(isl_ctx *ctx);\nconst char *isl_ctx_last_error_msg(isl_ctx *ctx);\nconst char *isl_ctx_last_error_file(isl_ctx *ctx);\nint isl_ctx_last_error_line(isl_ctx *ctx);\nvoid isl_ctx_reset_error(isl_ctx *ctx);\nvoid isl_ctx_set_error(isl_ctx *ctx, enum isl_error error);\n\n#if defined(__cplusplus)\n}\n#endif\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 16, "file": 2, "line": 477}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "e5adbdc8b300d5b6926dc6b1bc04ffab", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 17, "file": 2, "line": 1148}, "message": "comparison of integers of different signs: 'unsigned int' and 'isl_size' (aka 'int')"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "27b90d889a6be3319a97178e798afb65", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 17, "file": 2, "line": 1150}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "a8a5148d38243c71bf144e1fc3f2be71", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 2, "line": 1162}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "88387ea63b0cd0b2aba894220973cd84", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 1259}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "51658690bf395d521ba5ac68cde59f39", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 1262}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "56515b86fdfdb589c2d08040ac20c836", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 1352}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "f236f87184e85d5a9bcdc8fc493aeebb", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 1359}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "f32ee766aca4e6099fd12b3d44fac03a", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 1366}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "7bf22e68ae6d1d972693a9cb6f996e2e", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 18, "file": 3, "line": 153}, "message": "expanded from macro 'isl_assert'"}, {"location": {"col": 7, "file": 3, "line": 148}, "message": "expanded from macro 'isl_assert4'"}, {"location": {"col": 55, "file": 2, "line": 1583}, "message": "comparison of integers of different signs: 'long' and 'size_t' (aka 'unsigned long')"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "b80239e967e8d2175dd54c09be1e0935", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 43, "file": 2, "line": 1589}, "message": "comparison of integers of different signs: 'long' and 'size_t' (aka 'unsigned long')"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "f4b6dc642d48bc6a7b078cd29c2d9c31", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 18, "file": 2, "line": 1647}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "5b71804c4f4bff600abc0361d364db90", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 1861}, "message": "comparison of integers of different signs: 'unsigned int' and 'int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "0b92e6612e17643a1b3d204d8d014787", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 2078}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "9181cf064473f3f73096c22373657ef9", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 2082}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "d2cee7285debede6fb94c69dc1bc4598", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 2086}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "e5adbdc8b300d5b6926dc6b1bc04ffab", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 2244}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "9181cf064473f3f73096c22373657ef9", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 2247}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "d2cee7285debede6fb94c69dc1bc4598", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 2250}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "e5adbdc8b300d5b6926dc6b1bc04ffab", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 2290}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "dffadd14177b044cb8c4b1cfdc010838", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 2292}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "7ca04cdf3e3c8bfc1f38cbe2b8a3eb09", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 2294}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "dffadd14177b044cb8c4b1cfdc010838", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 2344}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "9181cf064473f3f73096c22373657ef9", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 2347}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "d2cee7285debede6fb94c69dc1bc4598", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 2350}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "e5adbdc8b300d5b6926dc6b1bc04ffab", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 30, "file": 2, "line": 2660}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "4999d46faf06d334d85812de31467891", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 17, "file": 2, "line": 2681}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "ec048183d4bb2df904d76c0396de5c74", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 17, "file": 2, "line": 2693}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "ec048183d4bb2df904d76c0396de5c74", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 44, "file": 2, "line": 2773}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "186c2b066a70a961daef76d4ad60f446", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 24, "file": 2, "line": 2786}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "7f3083c58cfd62d811c7a6aa8fd0ab67", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 2885}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "9181cf064473f3f73096c22373657ef9", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 2888}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "d2cee7285debede6fb94c69dc1bc4598", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 2891}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "fa78055b2a260ac3048a2ecf20cab306", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 17, "file": 2, "line": 3395}, "message": "comparison of integers of different signs: 'int' and 'size_t' (aka 'unsigned long')"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "54d841e0d9ec15204ddab5850d5a4b38", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 3603}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "09388711d9bda80ac076fa60eeec16df", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 3608}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "f128b4198a9091bf23457fdc4fb46c50", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 3616}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "12ab151df79fb2163945d75cca421081", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 4363}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "679a2f689e1ef51d517b60ace642ce1d", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 4403}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "1e091bf249c03959b65d0ae14225d699", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 4616}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "dffadd14177b044cb8c4b1cfdc010838", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 4634}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "f275d89b6c3d393d8fb2aca94ed850f4", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 4877}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "9181cf064473f3f73096c22373657ef9", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 4880}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "d2cee7285debede6fb94c69dc1bc4598", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 4883}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "e5adbdc8b300d5b6926dc6b1bc04ffab", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 5164}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "6455a7de1d03c3af17e34e9d6ea05706", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 5179}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "826372d8ff7f6595e2d54df81ce01f0f", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 5195}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "5db1efeb98c8284f0503b04123d66253", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 5211}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "826372d8ff7f6595e2d54df81ce01f0f", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 5227}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "5db1efeb98c8284f0503b04123d66253", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 20, "file": 2, "line": 5244}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "ac8c6685f422e1c97ccce0ad1bfa2933", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 20, "file": 2, "line": 5300}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "ac8c6685f422e1c97ccce0ad1bfa2933", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 17, "file": 2, "line": 5654}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "500fde3825d3a5d127fbcf4fbdd300bd", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 17, "file": 2, "line": 5656}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "9e84dd44aa8ad98bb2e386a9c3a28a09", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 18, "file": 3, "line": 153}, "message": "expanded from macro 'isl_assert'"}, {"location": {"col": 7, "file": 3, "line": 148}, "message": "expanded from macro 'isl_assert4'"}, {"location": {"col": 30, "file": 2, "line": 6314}, "message": "comparison of integers of different signs: 'int' and 'size_t' (aka 'unsigned long')"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "e65c5facc4a2491fd7247b6b8c80e935", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 18, "file": 3, "line": 153}, "message": "expanded from macro 'isl_assert'"}, {"location": {"col": 7, "file": 3, "line": 148}, "message": "expanded from macro 'isl_assert4'"}, {"location": {"col": 35, "file": 2, "line": 7446}, "message": "comparison of integers of different signs: 'unsigned int' and 'int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "27e7920d6795853b505d85c891c7eb2a", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 17, "file": 2, "line": 7475}, "message": "comparison of integers of different signs: 'unsigned int' and 'int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "dc5f6119c3084e622e1bedb1aef5b9ab", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 7515}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "08456a49f4cfffb7a2606ae99eafa6c7", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 31, "file": 2, "line": 7576}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "d4e313b693c5bbce2cf691feeafd2ae8", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 8, "file": 2, "line": 7667}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "d699a5ac6317e9df0b6333794a102dce", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 13, "file": 2, "line": 7689}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "2973329798858b0bc1fc90d0506ed48b", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 23, "file": 2, "line": 7843}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "07ce391cc4aa1bed6ed46db4a09b2f6d", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 7910}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "fa78055b2a260ac3048a2ecf20cab306", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 8871}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "f275d89b6c3d393d8fb2aca94ed850f4", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 2, "line": 9319}, "message": "comparison of integers of different signs: 'unsigned int' and 'int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "a0663ecee1558398a62fe81d8324fdf9", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 9367}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "fa78055b2a260ac3048a2ecf20cab306", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 20, "file": 2, "line": 9442}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "ab8607b7d454cb320fd40ec9fbe0bd7a", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 9454}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "f2bf0833896c822a25c4fd6a1df9771d", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 18, "file": 3, "line": 153}, "message": "expanded from macro 'isl_assert'"}, {"location": {"col": 7, "file": 3, "line": 148}, "message": "expanded from macro 'isl_assert4'"}, {"location": {"col": 27, "file": 2, "line": 9503}, "message": "comparison of integers of different signs: 'unsigned int' and 'isl_size' (aka 'int')"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "9e6bb67a49bb34d9e8409aa6a4c7275e", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 9560}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "7bf22e68ae6d1d972693a9cb6f996e2e", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 29, "file": 2, "line": 9911}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "f51eeb74b45c32b9f2a44cae51b27be4", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 49, "file": 2, "line": 9911}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "2044d5f23aa7a763dd0e3e2812b1e521", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 14, "file": 2, "line": 9912}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "150f3b2b3fde781737117b7b3130c4d2", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 2, "line": 9915}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "4bb7006056f9798ad6efe907a5a6bad4", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 10227}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "63b352d4003fcd9bdaab0a74ec0d9989", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 10232}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "79f40a99e197f908a10991865d19a72e", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 10237}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "f3964c7bb8511067d6dabb511154df5f", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 11046}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "f128b4198a9091bf23457fdc4fb46c50", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 11052}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "12ab151df79fb2163945d75cca421081", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 11058}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "fa78055b2a260ac3048a2ecf20cab306", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 11295}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "fa78055b2a260ac3048a2ecf20cab306", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 11302}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "9181cf064473f3f73096c22373657ef9", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 11306}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "12ab151df79fb2163945d75cca421081", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 11470}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "f275d89b6c3d393d8fb2aca94ed850f4", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 11623}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "12ab151df79fb2163945d75cca421081", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 21, "file": 2, "line": 11632}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "f95fac6761dfa7f2d2da51140a5bbf91", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 2, "line": 11641}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "08adf23302a93b08d91ebc4ad305300f", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 11701}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "d155c0096b599dbf75723a6c7c5d7761", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 2, "line": 11721}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "2959251f12aafc6ae8be98a38f7f2c0b", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 10, "file": 2, "line": 11754}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "05282f66e852cd2ab10a234fda401f3f", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 17, "file": 2, "line": 11944}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "df515b83cb09c28552f55cf20a110049", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 2, "line": 11951}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "f782c21c448fdbdee6f6f6119769a463", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 17, "file": 2, "line": 11953}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "0ba1ce28ba340ce2aecb4375cf70d6e0", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 12756}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "9181cf064473f3f73096c22373657ef9", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 12789}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "d2cee7285debede6fb94c69dc1bc4598", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 12840}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "ea7aaf2bd1a21eb66958645f5d3c3fd8", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 12846}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "08456a49f4cfffb7a2606ae99eafa6c7", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 12862}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "a2f08d92e9e71fa971353ac0e341870f", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 13462}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "907e1d2acbec6145bd7e40db2e22e47c", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 13471}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "1cf61197fd6b64ae19df9f134ef8b378", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 13480}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "1a3450277e828ad3616932912af80187", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 13812}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "f128b4198a9091bf23457fdc4fb46c50", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 13822}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "12ab151df79fb2163945d75cca421081", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 13832}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "fa78055b2a260ac3048a2ecf20cab306", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 2, "line": 14365}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map.c", "reportHash": "791d49861f63985225c30e8587f40d6f", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
